## API Report File for "@tldraw/editor"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="react" />

import { Atom } from '@tldraw/state';
import { atom } from '@tldraw/state';
import { BoxModel } from '@tldraw/tlschema';
import { ComponentType } from 'react';
import { Computed } from '@tldraw/state';
import { computed } from '@tldraw/state';
import { Dispatch } from 'react';
import { EffectScheduler } from '@tldraw/state';
import { EMPTY_ARRAY } from '@tldraw/state';
import EventEmitter from 'eventemitter3';
import { ExoticComponent } from 'react';
import { HistoryEntry } from '@tldraw/store';
import { IndexKey } from '@tldraw/utils';
import { JsonObject } from '@tldraw/utils';
import { JSX as JSX_2 } from 'react/jsx-runtime';
import { LegacyMigrations } from '@tldraw/store';
import { MigrationSequence } from '@tldraw/store';
import { NamedExoticComponent } from 'react';
import { PerformanceTracker } from '@tldraw/utils';
import { PointerEventHandler } from 'react';
import { react } from '@tldraw/state';
import { default as React_2 } from 'react';
import * as React_3 from 'react';
import { ReactElement } from 'react';
import { ReactNode } from 'react';
import { RecordProps } from '@tldraw/tlschema';
import { RecordsDiff } from '@tldraw/store';
import { RefObject } from 'react';
import { SerializedSchema } from '@tldraw/store';
import { SerializedStore } from '@tldraw/store';
import { SetStateAction } from 'react';
import { Signal } from '@tldraw/state';
import { Store } from '@tldraw/store';
import { StoreSchema } from '@tldraw/store';
import { StoreSideEffects } from '@tldraw/store';
import { StyleProp } from '@tldraw/tlschema';
import { StylePropValue } from '@tldraw/tlschema';
import { T } from '@tldraw/validate';
import { Timers } from '@tldraw/utils';
import { TLAsset } from '@tldraw/tlschema';
import { TLAssetId } from '@tldraw/tlschema';
import { TLAssetPartial } from '@tldraw/tlschema';
import { TLAssetStore } from '@tldraw/tlschema';
import { TLBaseShape } from '@tldraw/tlschema';
import { TLBinding } from '@tldraw/tlschema';
import { TLBindingCreate } from '@tldraw/tlschema';
import { TLBindingId } from '@tldraw/tlschema';
import { TLBindingUpdate } from '@tldraw/tlschema';
import { TLBookmarkAsset } from '@tldraw/tlschema';
import { TLCamera } from '@tldraw/tlschema';
import { TLCursor } from '@tldraw/tlschema';
import { TLCursorType } from '@tldraw/tlschema';
import { TLDefaultDashStyle } from '@tldraw/tlschema';
import { TLDefaultHorizontalAlignStyle } from '@tldraw/tlschema';
import { TLDocument } from '@tldraw/tlschema';
import { TLGroupShape } from '@tldraw/tlschema';
import { TLHandle } from '@tldraw/tlschema';
import { TLImageAsset } from '@tldraw/tlschema';
import { TLInstance } from '@tldraw/tlschema';
import { TLInstancePageState } from '@tldraw/tlschema';
import { TLInstancePresence } from '@tldraw/tlschema';
import { TLPage } from '@tldraw/tlschema';
import { TLPageId } from '@tldraw/tlschema';
import { TLParentId } from '@tldraw/tlschema';
import { TLPropsMigrations } from '@tldraw/tlschema';
import { TLRecord } from '@tldraw/tlschema';
import { TLScribble } from '@tldraw/tlschema';
import { TLShape } from '@tldraw/tlschema';
import { TLShapeId } from '@tldraw/tlschema';
import { TLShapePartial } from '@tldraw/tlschema';
import { TLStore } from '@tldraw/tlschema';
import { TLStoreProps } from '@tldraw/tlschema';
import { TLStoreSchema } from '@tldraw/tlschema';
import { TLStoreSnapshot } from '@tldraw/tlschema';
import { TLUnknownBinding } from '@tldraw/tlschema';
import { TLUnknownShape } from '@tldraw/tlschema';
import { TLVideoAsset } from '@tldraw/tlschema';
import { track } from '@tldraw/state-react';
import { transact } from '@tldraw/state';
import { transaction } from '@tldraw/state';
import { UnknownRecord } from '@tldraw/store';
import { useAtom } from '@tldraw/state-react';
import { useComputed } from '@tldraw/state-react';
import { useQuickReactor } from '@tldraw/state-react';
import { useReactor } from '@tldraw/state-react';
import { useStateTracking } from '@tldraw/state-react';
import { useValue } from '@tldraw/state-react';
import { VecModel } from '@tldraw/tlschema';
import { whyAmIRunning } from '@tldraw/state';

// @public
export function angleDistance(fromAngle: number, toAngle: number, direction: number): number;

// @internal (undocumented)
export function applyRotationToSnapshotShapes({ delta, editor, snapshot, stage, centerOverride, }: {
    centerOverride?: VecLike;
    delta: number;
    editor: Editor;
    snapshot: TLRotationSnapshot;
    stage: 'end' | 'one-off' | 'start' | 'update';
}): void;

// @public
export function approximately(a: number, b: number, precision?: number): boolean;

// @public (undocumented)
export class Arc2d extends Geometry2d {
    constructor(config: Omit<Geometry2dOptions, 'isClosed' | 'isFilled'> & {
        center: Vec;
        end: Vec;
        largeArcFlag: number;
        start: Vec;
        sweepFlag: number;
    });
    // (undocumented)
    angleEnd: number;
    // (undocumented)
    angleStart: number;
    // (undocumented)
    _center: Vec;
    // (undocumented)
    end: Vec;
    // (undocumented)
    getLength(): number;
    // (undocumented)
    getSvgPathData(first?: boolean): string;
    // (undocumented)
    getVertices(): Vec[];
    // (undocumented)
    hitTestLineSegment(A: Vec, B: Vec): boolean;
    // (undocumented)
    largeArcFlag: number;
    // (undocumented)
    measure: number;
    // (undocumented)
    nearestPoint(point: Vec): Vec;
    // (undocumented)
    radius: number;
    // (undocumented)
    start: Vec;
    // (undocumented)
    sweepFlag: number;
}

// @public
export function areAnglesCompatible(a: number, b: number): boolean;

export { Atom }

export { atom }

// @public (undocumented)
export function average(A: VecLike, B: VecLike): string;

// @public (undocumented)
export abstract class BaseBoxShapeTool extends StateNode {
    // (undocumented)
    static children(): TLStateNodeConstructor[];
    // (undocumented)
    static id: string;
    // (undocumented)
    static initial: string;
    // (undocumented)
    onCreate?(_shape: null | TLShape): null | void;
    // (undocumented)
    abstract shapeType: string;
}

// @public (undocumented)
export abstract class BaseBoxShapeUtil<Shape extends TLBaseBoxShape> extends ShapeUtil<Shape> {
    // (undocumented)
    getGeometry(shape: Shape): Geometry2d;
    // (undocumented)
    getHandleSnapGeometry(shape: Shape): HandleSnapGeometry;
    // (undocumented)
    getInterpolatedProps(startShape: Shape, endShape: Shape, t: number): Shape['props'];
    // (undocumented)
    onResize(shape: any, info: TLResizeInfo<any>): any;
}

// @public
export interface BindingOnChangeOptions<Binding extends TLUnknownBinding> {
    bindingAfter: Binding;
    bindingBefore: Binding;
}

// @public
export interface BindingOnCreateOptions<Binding extends TLUnknownBinding> {
    binding: Binding;
}

// @public
export interface BindingOnDeleteOptions<Binding extends TLUnknownBinding> {
    binding: Binding;
}

// @public
export interface BindingOnShapeChangeOptions<Binding extends TLUnknownBinding> {
    binding: Binding;
    shapeAfter: TLShape;
    shapeBefore: TLShape;
}

// @public
export interface BindingOnShapeDeleteOptions<Binding extends TLUnknownBinding> {
    binding: Binding;
    shape: TLShape;
}

// @public
export interface BindingOnShapeIsolateOptions<Binding extends TLUnknownBinding> {
    binding: Binding;
    removedShape: TLShape;
}

// @public (undocumented)
export abstract class BindingUtil<Binding extends TLUnknownBinding = TLUnknownBinding> {
    constructor(editor: Editor);
    // (undocumented)
    editor: Editor;
    abstract getDefaultProps(): Partial<Binding['props']>;
    // (undocumented)
    static migrations?: TLPropsMigrations;
    onAfterChange?(options: BindingOnChangeOptions<Binding>): void;
    onAfterChangeFromShape?(options: BindingOnShapeChangeOptions<Binding>): void;
    onAfterChangeToShape?(options: BindingOnShapeChangeOptions<Binding>): void;
    onAfterCreate?(options: BindingOnCreateOptions<Binding>): void;
    onAfterDelete?(options: BindingOnDeleteOptions<Binding>): void;
    onBeforeChange?(options: BindingOnChangeOptions<Binding>): Binding | void;
    onBeforeCreate?(options: BindingOnCreateOptions<Binding>): Binding | void;
    onBeforeDelete?(options: BindingOnDeleteOptions<Binding>): void;
    onBeforeDeleteFromShape?(options: BindingOnShapeDeleteOptions<Binding>): void;
    onBeforeDeleteToShape?(options: BindingOnShapeDeleteOptions<Binding>): void;
    onBeforeIsolateFromShape?(options: BindingOnShapeIsolateOptions<Binding>): void;
    onBeforeIsolateToShape?(options: BindingOnShapeIsolateOptions<Binding>): void;
    onOperationComplete?(): void;
    // (undocumented)
    static props?: RecordProps<TLUnknownBinding>;
    static type: string;
}

// @public
export interface BoundsSnapGeometry {
    points?: VecModel[];
}

// @public (undocumented)
export interface BoundsSnapPoint {
    // (undocumented)
    handle?: SelectionCorner;
    // (undocumented)
    id: string;
    // (undocumented)
    x: number;
    // (undocumented)
    y: number;
}

// @public (undocumented)
export class BoundsSnaps {
    constructor(manager: SnapManager);
    // (undocumented)
    readonly editor: Editor;
    // (undocumented)
    getSnapPoints(shapeId: TLShapeId): BoundsSnapPoint[];
    // (undocumented)
    readonly manager: SnapManager;
    // (undocumented)
    snapResizeShapes({ initialSelectionPageBounds, dragDelta, handle: originalHandle, isAspectRatioLocked, isResizingFromCenter, }: {
        dragDelta: Vec;
        handle: SelectionCorner | SelectionEdge;
        initialSelectionPageBounds: Box;
        isAspectRatioLocked: boolean;
        isResizingFromCenter: boolean;
    }): SnapData;
    // (undocumented)
    snapTranslateShapes({ lockedAxis, initialSelectionPageBounds, initialSelectionSnapPoints, dragDelta, }: {
        dragDelta: Vec;
        initialSelectionPageBounds: Box;
        initialSelectionSnapPoints: BoundsSnapPoint[];
        lockedAxis: 'x' | 'y' | null;
    }): SnapData;
}

// @public (undocumented)
export class Box {
    constructor(x?: number, y?: number, w?: number, h?: number);
    // (undocumented)
    get aspectRatio(): number;
    // (undocumented)
    get center(): Vec;
    set center(v: Vec);
    // (undocumented)
    clone(): Box;
    // (undocumented)
    static Collides(A: Box, B: Box): boolean;
    // (undocumented)
    collides(B: Box): boolean;
    // (undocumented)
    static Common(boxes: Box[]): Box;
    // (undocumented)
    static Contains(A: Box, B: Box): boolean;
    // (undocumented)
    contains(B: Box): boolean;
    // (undocumented)
    static ContainsPoint(A: Box, B: VecLike, margin?: number): boolean;
    // (undocumented)
    containsPoint(V: VecLike, margin?: number): boolean;
    // (undocumented)
    get corners(): Vec[];
    // (undocumented)
    get cornersAndCenter(): Vec[];
    // (undocumented)
    static Equals(a: Box | BoxModel, b: Box | BoxModel): boolean;
    // (undocumented)
    equals(other: Box | BoxModel): boolean;
    // (undocumented)
    static Expand(A: Box, B: Box): Box;
    // (undocumented)
    expand(A: Box): this;
    // (undocumented)
    static ExpandBy(A: Box, n: number): Box;
    // (undocumented)
    expandBy(n: number): this;
    // (undocumented)
    static From(box: BoxModel): Box;
    // (undocumented)
    static FromCenter(center: VecLike, size: VecLike): Box;
    // (undocumented)
    static FromPoints(points: VecLike[]): Box;
    // (undocumented)
    getHandlePoint(handle: SelectionCorner | SelectionEdge): Vec;
    // (undocumented)
    h: number;
    // (undocumented)
    get height(): number;
    set height(n: number);
    // (undocumented)
    static Includes(A: Box, B: Box): boolean;
    // (undocumented)
    includes(B: Box): boolean;
    // (undocumented)
    get maxX(): number;
    // (undocumented)
    get maxY(): number;
    // (undocumented)
    get midX(): number;
    // (undocumented)
    get midY(): number;
    // (undocumented)
    get minX(): number;
    set minX(n: number);
    // (undocumented)
    get minY(): number;
    set minY(n: number);
    // (undocumented)
    get point(): Vec;
    set point(val: Vec);
    // (undocumented)
    static Resize(box: Box, handle: SelectionCorner | SelectionEdge | string, dx: number, dy: number, isAspectRatioLocked?: boolean): {
        box: Box;
        scaleX: number;
        scaleY: number;
    };
    // (undocumented)
    resize(handle: SelectionCorner | SelectionEdge | string, dx: number, dy: number): void;
    // (undocumented)
    scale(n: number): this;
    // (undocumented)
    set(x?: number, y?: number, w?: number, h?: number): this;
    // (undocumented)
    setTo(B: Box): this;
    // (undocumented)
    static Sides(A: Box, inset?: number): Vec[][];
    // (undocumented)
    get sides(): Array<[Vec, Vec]>;
    // (undocumented)
    get size(): Vec;
    // (undocumented)
    snapToGrid(size: number): void;
    // (undocumented)
    toFixed(): this;
    // (undocumented)
    toJson(): BoxModel;
    // (undocumented)
    translate(delta: VecLike): this;
    // (undocumented)
    union(box: BoxModel): this;
    // (undocumented)
    w: number;
    // (undocumented)
    get width(): number;
    set width(n: number);
    // (undocumented)
    x: number;
    // (undocumented)
    y: number;
    // (undocumented)
    static ZeroFix(other: Box | BoxModel): Box;
    // (undocumented)
    zeroFix(): this;
}

// @public (undocumented)
export type BoxLike = Box | BoxModel;

// @public (undocumented)
export function canonicalizeRotation(a: number): number;

// @public
export function centerOfCircleFromThreePoints(a: VecLike, b: VecLike, c: VecLike): null | Vec;

// @public (undocumented)
export class Circle2d extends Geometry2d {
    constructor(config: Omit<Geometry2dOptions, 'isClosed'> & {
        isFilled: boolean;
        radius: number;
        x?: number;
        y?: number;
    });
    // (undocumented)
    _center: Vec;
    // (undocumented)
    config: Omit<Geometry2dOptions, 'isClosed'> & {
        isFilled: boolean;
        radius: number;
        x?: number;
        y?: number;
    };
    // (undocumented)
    getBounds(): Box;
    // (undocumented)
    getSvgPathData(): string;
    // (undocumented)
    getVertices(): Vec[];
    // (undocumented)
    hitTestLineSegment(A: Vec, B: Vec, distance?: number): boolean;
    // (undocumented)
    nearestPoint(point: Vec): Vec;
    // (undocumented)
    radius: number;
    // (undocumented)
    x: number;
    // (undocumented)
    y: number;
}

// @public
export function clamp(n: number, min: number): number;

// @public
export function clamp(n: number, min: number, max: number): number;

// @public
export function clampRadians(r: number): number;

// @public (undocumented)
export class ClickManager {
    constructor(editor: Editor);
    // @internal
    cancelDoubleClickTimeout(): void;
    get clickState(): TLClickState | undefined;
    // (undocumented)
    editor: Editor;
    // (undocumented)
    _getClickTimeout(state: TLClickState, id?: string): void;
    // (undocumented)
    handlePointerEvent(info: TLPointerEventInfo): TLClickEventInfo | TLPointerEventInfo;
    // (undocumented)
    lastPointerInfo: TLPointerEventInfo;
}

// @public
export function clockwiseAngleDist(a0: number, a1: number): number;

export { computed }

// @public (undocumented)
export function ContainerProvider({ container, children }: ContainerProviderProps): JSX_2.Element;

// @public (undocumented)
export interface ContainerProviderProps {
    // (undocumented)
    children: React.ReactNode;
    // (undocumented)
    container: HTMLElement;
}

// @public (undocumented)
export const coreShapes: readonly [typeof GroupShapeUtil];

// @public
export function counterClockwiseAngleDist(a0: number, a1: number): number;

// @public
export function createDeepLinkString(deepLink: TLDeepLink): string;

// @public
export function createSessionStateSnapshotSignal(store: TLStore): Signal<null | TLSessionStateSnapshot>;

// @public
export function createTLSchemaFromUtils(opts: TLStoreSchemaOptions): StoreSchema<TLRecord, TLStoreProps>;

// @public
export function createTLStore({ initialData, defaultName, id, assets, onMount, collaboration, ...rest }?: TLStoreOptions): TLStore;

// @public (undocumented)
export function createTLUser(opts?: {
    setUserPreferences?: ((userPreferences: TLUserPreferences) => void) | undefined;
    userPreferences?: Signal<TLUserPreferences, unknown> | undefined;
}): TLUser;

// @public (undocumented)
export class CubicBezier2d extends Polyline2d {
    constructor(config: Omit<Geometry2dOptions, 'isClosed' | 'isFilled'> & {
        cp1: Vec;
        cp2: Vec;
        end: Vec;
        start: Vec;
    });
    // (undocumented)
    a: Vec;
    // (undocumented)
    b: Vec;
    // (undocumented)
    c: Vec;
    // (undocumented)
    d: Vec;
    // (undocumented)
    static GetAtT(segment: CubicBezier2d, t: number): Vec;
    // (undocumented)
    getLength(precision?: number): number;
    // (undocumented)
    getSvgPathData(first?: boolean): string;
    // (undocumented)
    getVertices(): Vec[];
    // (undocumented)
    midPoint(): Vec;
    // (undocumented)
    nearestPoint(A: Vec): Vec;
}

// @public (undocumented)
export class CubicSpline2d extends Geometry2d {
    constructor(config: Omit<Geometry2dOptions, 'isClosed' | 'isFilled'> & {
        points: Vec[];
    });
    // (undocumented)
    getLength(): number;
    // (undocumented)
    getSvgPathData(): string;
    // (undocumented)
    getVertices(): Vec[];
    // (undocumented)
    hitTestLineSegment(A: Vec, B: Vec): boolean;
    // (undocumented)
    nearestPoint(A: Vec): Vec;
    // (undocumented)
    points: Vec[];
    // (undocumented)
    get segments(): CubicBezier2d[];
    // (undocumented)
    _segments?: CubicBezier2d[];
}

// @public (undocumented)
export function dataUrlToFile(url: string, filename: string, mimeType: string): Promise<File>;

// @public @deprecated (undocumented)
export function debugEnableLicensing(): void;

// @internal (undocumented)
export type DebugFlag<T> = DebugFlagDef<T> & Atom<T>;

// @internal (undocumented)
export interface DebugFlagDef<T> {
    // (undocumented)
    defaults: DebugFlagDefaults<T>;
    // (undocumented)
    name: string;
    // (undocumented)
    shouldStoreForSession: boolean;
}

// @internal (undocumented)
export interface DebugFlagDefaults<T> {
    // (undocumented)
    all: T;
    // (undocumented)
    development?: T;
    // (undocumented)
    production?: T;
    // (undocumented)
    staging?: T;
}

// @internal (undocumented)
export const debugFlags: {
    readonly debugCursors: DebugFlag<boolean>;
    readonly debugGeometry: DebugFlag<boolean>;
    readonly debugSvg: DebugFlag<boolean>;
    readonly editOnType: DebugFlag<boolean>;
    readonly forceSrgb: DebugFlag<boolean>;
    readonly hideShapes: DebugFlag<boolean>;
    readonly logElementRemoves: DebugFlag<boolean>;
    readonly logPointerCaptures: DebugFlag<boolean>;
    readonly logPreventDefaults: DebugFlag<boolean>;
    readonly measurePerformance: DebugFlag<boolean>;
    readonly reconnectOnPing: DebugFlag<boolean>;
    readonly showFps: DebugFlag<boolean>;
    readonly throwToBlob: DebugFlag<boolean>;
};

// @internal (undocumented)
export const DEFAULT_ANIMATION_OPTIONS: {
    duration: number;
    easing: (t: number) => number;
};

// @internal (undocumented)
export const DEFAULT_CAMERA_OPTIONS: TLCameraOptions;

// @public (undocumented)
export function DefaultBackground(): JSX_2.Element;

// @public (undocumented)
export const DefaultBrush: ({ brush, color, opacity, className }: TLBrushProps) => JSX_2.Element;

// @public (undocumented)
export function DefaultCanvas({ className }: TLCanvasComponentProps): JSX_2.Element;

// @public (undocumented)
export function DefaultCollaboratorHint({ className, zoom, point, color, viewport, opacity, }: TLCollaboratorHintProps): JSX_2.Element;

// @public (undocumented)
export const DefaultCursor: NamedExoticComponent<TLCursorProps>;

// @public (undocumented)
export const DefaultErrorFallback: TLErrorFallbackComponent;

// @public (undocumented)
export function DefaultGrid({ x, y, z, size }: TLGridProps): JSX_2.Element;

// @public (undocumented)
export function DefaultHandle({ handle, isCoarse, className, zoom }: TLHandleProps): JSX_2.Element;

// @public (undocumented)
export const DefaultHandles: ({ children }: TLHandlesProps) => JSX_2.Element;

// @public (undocumented)
export function DefaultScribble({ scribble, zoom, color, opacity, className }: TLScribbleProps): JSX_2.Element | null;

// @public (undocumented)
export function DefaultSelectionBackground({ bounds, rotation }: TLSelectionBackgroundProps): JSX_2.Element;

// @public (undocumented)
export function DefaultSelectionForeground({ bounds, rotation }: TLSelectionForegroundProps): JSX_2.Element;

// @public (undocumented)
export const DefaultShapeIndicator: NamedExoticComponent<TLShapeIndicatorProps>;

// @public (undocumented)
export const DefaultShapeIndicators: NamedExoticComponent<object>;

// @public (undocumented)
export function DefaultSnapIndicator({ className, line, zoom }: TLSnapIndicatorProps): JSX_2.Element;

// @public (undocumented)
export function DefaultSpinner(): JSX_2.Element;

// @public (undocumented)
export const DefaultSvgDefs: () => null;

// @public (undocumented)
export const defaultTldrawOptions: {
    readonly actionShortcutsLocation: "swap";
    readonly adjacentShapeMargin: 10;
    readonly animationMediumMs: 320;
    readonly cameraMovingTimeoutMs: 64;
    readonly cameraSlideFriction: 0.09;
    readonly coarseDragDistanceSquared: 36;
    readonly coarseHandleRadius: 20;
    readonly coarsePointerWidth: 12;
    readonly collaboratorCheckIntervalMs: 1200;
    readonly collaboratorIdleTimeoutMs: 3000;
    readonly collaboratorInactiveTimeoutMs: 60000;
    readonly createTextOnCanvasDoubleClick: true;
    readonly defaultSvgPadding: 32;
    readonly doubleClickDurationMs: 450;
    readonly dragDistanceSquared: 16;
    readonly edgeScrollDelay: 200;
    readonly edgeScrollDistance: 8;
    readonly edgeScrollEaseDuration: 200;
    readonly edgeScrollSpeed: 25;
    readonly exportProvider: ExoticComponent<    {
    children?: ReactNode;
    }>;
    readonly flattenImageBoundsExpand: 64;
    readonly flattenImageBoundsPadding: 16;
    readonly followChaseViewportSnap: 2;
    readonly gridSteps: readonly [{
        readonly mid: 0.15;
        readonly min: -1;
        readonly step: 64;
    }, {
        readonly mid: 0.375;
        readonly min: 0.05;
        readonly step: 16;
    }, {
        readonly mid: 1;
        readonly min: 0.15;
        readonly step: 4;
    }, {
        readonly mid: 2.5;
        readonly min: 0.7;
        readonly step: 1;
    }];
    readonly handleRadius: 12;
    readonly hitTestMargin: 8;
    readonly laserDelayMs: 1200;
    readonly longPressDurationMs: 500;
    readonly maxExportDelayMs: 5000;
    readonly maxFilesAtOnce: 100;
    readonly maxPages: 40;
    readonly maxPointsPerDrawShape: 500;
    readonly maxShapesPerPage: 4000;
    readonly multiClickDurationMs: 200;
    readonly temporaryAssetPreviewLifetimeMs: 180000;
    readonly textShadowLod: 0.35;
};

// @public (undocumented)
export const defaultUserPreferences: Readonly<{
    animationSpeed: 0 | 1;
    color: "#02B1CC" | "#11B3A3" | "#39B178" | "#55B467" | "#7B66DC" | "#9D5BD2" | "#BD54C6" | "#E34BA9" | "#EC5E41" | "#F04F88" | "#F2555A" | "#FF802B";
    colorScheme: "light";
    edgeScrollSpeed: 1;
    isDynamicSizeMode: false;
    isPasteAtCursorMode: false;
    isSnapMode: false;
    isWrapMode: false;
    locale: "ar" | "bn" | "ca" | "cs" | "da" | "de" | "el" | "en" | "es" | "fa" | "fi" | "fr" | "gl" | "gu-in" | "he" | "hi-in" | "hr" | "hu" | "id" | "it" | "ja" | "km-kh" | "kn" | "ko-kr" | "ml" | "mr" | "ms" | "ne" | "nl" | "no" | "pa" | "pl" | "pt-br" | "pt-pt" | "ro" | "ru" | "sl" | "so" | "sv" | "ta" | "te" | "th" | "tl" | "tr" | "uk" | "ur" | "vi" | "zh-cn" | "zh-tw";
    name: "New User";
}>;

// @public
export function degreesToRadians(d: number): number;

// @public (undocumented)
export const EASINGS: {
    readonly easeInCubic: (t: number) => number;
    readonly easeInExpo: (t: number) => number;
    readonly easeInOutCubic: (t: number) => number;
    readonly easeInOutExpo: (t: number) => number;
    readonly easeInOutQuad: (t: number) => number;
    readonly easeInOutQuart: (t: number) => number;
    readonly easeInOutQuint: (t: number) => number;
    readonly easeInOutSine: (t: number) => number;
    readonly easeInQuad: (t: number) => number;
    readonly easeInQuart: (t: number) => number;
    readonly easeInQuint: (t: number) => number;
    readonly easeInSine: (t: number) => number;
    readonly easeOutCubic: (t: number) => number;
    readonly easeOutExpo: (t: number) => number;
    readonly easeOutQuad: (t: number) => number;
    readonly easeOutQuart: (t: number) => number;
    readonly easeOutQuint: (t: number) => number;
    readonly easeOutSine: (t: number) => number;
    readonly linear: (t: number) => number;
};

// @public (undocumented)
export class Edge2d extends Geometry2d {
    constructor(config: {
        end: Vec;
        start: Vec;
    });
    // (undocumented)
    d: Vec;
    // (undocumented)
    end: Vec;
    // (undocumented)
    getLength(): number;
    // (undocumented)
    getSvgPathData(first?: boolean): string;
    // (undocumented)
    getVertices(): Vec[];
    // (undocumented)
    hitTestLineSegment(A: Vec, B: Vec, distance?: number): boolean;
    // (undocumented)
    midPoint(): Vec;
    // (undocumented)
    nearestPoint(point: Vec): Vec;
    // (undocumented)
    start: Vec;
    // (undocumented)
    u: Vec;
    // (undocumented)
    ul: number;
}

// @public (undocumented)
export class EdgeScrollManager {
    constructor(editor: Editor);
    // (undocumented)
    editor: Editor;
    updateEdgeScrolling(elapsed: number): void;
}

// @public (undocumented)
export class Editor extends EventEmitter<TLEventMap> {
    constructor({ store, user, shapeUtils, bindingUtils, tools, getContainer, cameraOptions, initialState, autoFocus, inferDarkMode, options, isShapeHidden, }: TLEditorOptions);
    // @deprecated (undocumented)
    addOpenMenu(id: string): this;
    alignShapes(shapes: TLShape[] | TLShapeId[], operation: 'bottom' | 'center-horizontal' | 'center-vertical' | 'left' | 'right' | 'top'): this;
    animateShape(partial: null | TLShapePartial | undefined, opts?: TLCameraMoveOptions): this;
    animateShapes(partials: (null | TLShapePartial | undefined)[], opts?: TLCameraMoveOptions): this;
    // @internal (undocumented)
    annotateError(error: unknown, { origin, willCrashApp, tags, extras, }: {
        extras?: Record<string, unknown>;
        origin: string;
        tags?: Record<string, boolean | number | string>;
        willCrashApp: boolean;
    }): this;
    bail(): this;
    bailToMark(id: string): this;
    // @deprecated (undocumented)
    batch(fn: () => void, opts?: TLEditorRunOptions): this;
    bindingUtils: {
        readonly [K in string]?: BindingUtil<TLUnknownBinding>;
    };
    blur({ blurContainer }?: {
        blurContainer?: boolean | undefined;
    }): this;
    bringForward(shapes: TLShape[] | TLShapeId[], opts?: {
        considerAllShapes?: boolean;
    }): this;
    bringToFront(shapes: TLShape[] | TLShapeId[]): this;
    // (undocumented)
    canBindShapes({ fromShape, toShape, binding, }: {
        binding: {
            type: TLBinding['type'];
        } | TLBinding | TLBinding['type'];
        fromShape: {
            type: TLShape['type'];
        } | TLShape | TLShape['type'];
        toShape: {
            type: TLShape['type'];
        } | TLShape | TLShape['type'];
    }): boolean;
    cancel(): this;
    cancelDoubleClick(): void;
    // @internal (undocumented)
    capturedPointerId: null | number;
    centerOnPoint(point: VecLike, opts?: TLCameraMoveOptions): this;
    // (undocumented)
    clearHistory(): this;
    // @deprecated (undocumented)
    clearOpenMenus(): this;
    // @internal
    protected _clickManager: ClickManager;
    complete(): this;
    // (undocumented)
    readonly contextId: string;
    // @internal (undocumented)
    crash(error: unknown): this;
    createAssets(assets: TLAsset[]): this;
    createBinding<B extends TLBinding = TLBinding>(partial: TLBindingCreate<B>): this;
    createBindings(partials: TLBindingCreate[]): this;
    createDeepLink(opts?: {
        param?: string;
        to?: TLDeepLink;
        url?: string | URL;
    }): URL;
    // @internal (undocumented)
    createErrorAnnotations(origin: string, willCrashApp: 'unknown' | boolean): {
        extras: {
            activeStateNode?: string;
            editingShape?: TLUnknownShape;
            inputs?: Record<string, unknown>;
            selectedShapes?: TLUnknownShape[];
        };
        tags: {
            origin: string;
            willCrashApp: 'unknown' | boolean;
        };
    };
    createPage(page: Partial<TLPage>): this;
    createShape<T extends TLUnknownShape>(shape: OptionalKeys<TLShapePartial<T>, 'id'>): this;
    createShapes<T extends TLUnknownShape>(shapes: OptionalKeys<TLShapePartial<T>, 'id'>[]): this;
    createTemporaryAssetPreview(assetId: TLAssetId, file: File): string | undefined;
    // (undocumented)
    _decayCameraStateTimeout(elapsed: number): void;
    deleteAssets(assets: TLAsset[] | TLAssetId[]): this;
    deleteBinding(binding: TLBinding | TLBindingId, opts?: Parameters<this['deleteBindings']>[1]): this;
    deleteBindings(bindings: (TLBinding | TLBindingId)[], { isolateShapes }?: {
        isolateShapes?: boolean | undefined;
    }): this;
    // @deprecated (undocumented)
    deleteOpenMenu(id: string): this;
    deletePage(page: TLPage | TLPageId): this;
    deleteShape(id: TLShapeId): this;
    // (undocumented)
    deleteShape(shape: TLShape): this;
    deleteShapes(ids: TLShapeId[]): this;
    // (undocumented)
    deleteShapes(shapes: TLShape[]): this;
    deselect(...shapes: TLShape[] | TLShapeId[]): this;
    dispatch(info: TLEventInfo): this;
    readonly disposables: Set<() => void>;
    dispose(): void;
    distributeShapes(shapes: TLShape[] | TLShapeId[], operation: 'horizontal' | 'vertical'): this;
    duplicatePage(page: TLPage | TLPageId, createId?: TLPageId): this;
    duplicateShapes(shapes: TLShape[] | TLShapeId[], offset?: VecLike): this;
    edgeScrollManager: EdgeScrollManager;
    // @deprecated
    readonly environment: {
        isAndroid: boolean;
        isChromeForIos: boolean;
        isDarwin: boolean;
        isFirefox: boolean;
        isIos: boolean;
        isSafari: boolean;
        isWebview: boolean;
    };
    // @internal (undocumented)
    externalAssetContentHandlers: {
        [K in TLExternalAssetContent['type']]: {
            [Key in K]: ((info: TLExternalAssetContent & {
                type: Key;
            }) => Promise<TLAsset | undefined>) | null;
        }[K];
    };
    // @internal (undocumented)
    externalContentHandlers: {
        [K in TLExternalContent<any>['type']]: {
            [Key in K]: ((info: TLExternalContent<any> & {
                type: Key;
            }) => void) | null;
        }[K];
    };
    findCommonAncestor(shapes: TLShape[] | TLShapeId[], predicate?: (shape: TLShape) => boolean): TLShapeId | undefined;
    findShapeAncestor(shape: TLShape | TLShapeId, predicate: (parent: TLShape) => boolean): TLShape | undefined;
    flipShapes(shapes: TLShape[] | TLShapeId[], operation: 'horizontal' | 'vertical'): this;
    // (undocumented)
    _flushEventForTick(info: TLEventInfo): this | undefined;
    focus({ focusContainer }?: {
        focusContainer?: boolean | undefined;
    }): this;
    getAncestorPageId(shape?: TLShape | TLShapeId): TLPageId | undefined;
    getAsset<T extends TLAsset>(asset: T | T['id']): T | undefined;
    getAssetForExternalContent(info: TLExternalAssetContent): Promise<TLAsset | undefined>;
    getAssets(): (TLBookmarkAsset | TLImageAsset | TLVideoAsset)[];
    getBaseZoom(): number;
    getBinding(id: TLBindingId): TLBinding | undefined;
    getBindingsFromShape<Binding extends TLUnknownBinding = TLBinding>(shape: TLShape | TLShapeId, type: Binding['type']): Binding[];
    getBindingsInvolvingShape<Binding extends TLUnknownBinding = TLBinding>(shape: TLShape | TLShapeId, type?: Binding['type']): Binding[];
    getBindingsToShape<Binding extends TLUnknownBinding = TLBinding>(shape: TLShape | TLShapeId, type: Binding['type']): Binding[];
    getBindingUtil<S extends TLUnknownBinding>(binding: {
        type: S['type'];
    } | S): BindingUtil<S>;
    // (undocumented)
    getBindingUtil<S extends TLUnknownBinding>(type: S['type']): BindingUtil<S>;
    // (undocumented)
    getBindingUtil<T extends BindingUtil>(type: T extends BindingUtil<infer R> ? R['type'] : string): T;
    getCamera(): TLCamera;
    getCameraOptions(): TLCameraOptions;
    getCameraState(): "idle" | "moving";
    getCanRedo(): boolean;
    getCanUndo(): boolean;
    getCollaborators(): TLInstancePresence[];
    getCollaboratorsOnCurrentPage(): TLInstancePresence[];
    getContainer: () => HTMLElement;
    getContentFromCurrentPage(shapes: TLShape[] | TLShapeId[]): TLContent | undefined;
    // @internal
    getCrashingError(): unknown;
    getCroppingShapeId(): null | TLShapeId;
    getCulledShapes(): Set<TLShapeId>;
    getCurrentPage(): TLPage;
    getCurrentPageBounds(): Box | undefined;
    getCurrentPageId(): TLPageId;
    getCurrentPageRenderingShapesSorted(): TLShape[];
    getCurrentPageShapeIds(): Set<TLShapeId>;
    // @internal (undocumented)
    getCurrentPageShapeIdsSorted(): TLShapeId[];
    getCurrentPageShapes(): TLShape[];
    getCurrentPageShapesSorted(): TLShape[];
    getCurrentPageState(): TLInstancePageState;
    getCurrentTool(): StateNode;
    getCurrentToolId(): string;
    getDocumentSettings(): TLDocument;
    getDroppingOverShape(point: VecLike, droppingShapes?: TLShape[]): TLUnknownShape | undefined;
    getEditingShape(): TLShape | undefined;
    getEditingShapeId(): null | TLShapeId;
    getErasingShapeIds(): TLShapeId[];
    getErasingShapes(): NonNullable<TLShape | undefined>[];
    getFocusedGroup(): TLShape | undefined;
    getFocusedGroupId(): TLPageId | TLShapeId;
    getHighestIndexForParent(parent: TLPage | TLParentId | TLShape): IndexKey;
    getHintingShape(): NonNullable<TLShape | undefined>[];
    getHintingShapeIds(): TLShapeId[];
    getHoveredShape(): TLShape | undefined;
    getHoveredShapeId(): null | TLShapeId;
    getInitialMetaForShape(_shape: TLShape): JsonObject;
    getInitialZoom(): number;
    getInstanceState(): TLInstance;
    // (undocumented)
    getIsFocused(): boolean;
    // @deprecated (undocumented)
    getIsMenuOpen(): boolean;
    // (undocumented)
    getIsReadonly(): boolean;
    // @internal
    getMarkIdMatching(idSubstring: string): null | string;
    getOnlySelectedShape(): null | TLShape;
    getOnlySelectedShapeId(): null | TLShapeId;
    // @deprecated (undocumented)
    getOpenMenus(): string[];
    getOutermostSelectableShape(shape: TLShape | TLShapeId, filter?: (shape: TLShape) => boolean): TLShape;
    getPage(page: TLPage | TLPageId): TLPage | undefined;
    getPages(): TLPage[];
    getPageShapeIds(page: TLPage | TLPageId): Set<TLShapeId>;
    getPageStates(): TLInstancePageState[];
    getPath(): string;
    getPointInParentSpace(shape: TLShape | TLShapeId, point: VecLike): Vec;
    getPointInShapeSpace(shape: TLShape | TLShapeId, point: VecLike): Vec;
    getRenderingShapes(): TLRenderingShape[];
    getSelectedShapeAtPoint(point: VecLike): TLShape | undefined;
    getSelectedShapeIds(): TLShapeId[];
    getSelectedShapes(): TLShape[];
    getSelectionPageBounds(): Box | null;
    getSelectionRotatedPageBounds(): Box | undefined;
    getSelectionRotatedScreenBounds(): Box | undefined;
    getSelectionRotation(): number;
    getShape<T extends TLShape = TLShape>(shape: TLParentId | TLShape): T | undefined;
    getShapeAncestors(shape: TLShape | TLShapeId, acc?: TLShape[]): TLShape[];
    getShapeAndDescendantIds(ids: TLShapeId[]): Set<TLShapeId>;
    getShapeAtPoint(point: VecLike, opts?: {
        filter?(shape: TLShape): boolean;
        hitFrameInside?: boolean | undefined;
        hitInside?: boolean | undefined;
        hitLabels?: boolean | undefined;
        hitLocked?: boolean | undefined;
        margin?: number | undefined;
        renderingOnly?: boolean | undefined;
    }): TLShape | undefined;
    getShapeClipPath(shape: TLShape | TLShapeId): string | undefined;
    getShapeGeometry<T extends Geometry2d>(shape: TLShape | TLShapeId): T;
    getShapeHandles<T extends TLShape>(shape: T | T['id']): TLHandle[] | undefined;
    getShapeLocalTransform(shape: TLShape | TLShapeId): Mat;
    getShapeMask(shape: TLShape | TLShapeId): undefined | VecLike[];
    getShapeMaskedPageBounds(shape: TLShape | TLShapeId): Box | undefined;
    // @internal
    getShapeNearestSibling(siblingShape: TLShape, targetShape: TLShape | undefined): TLShape | undefined;
    getShapePageBounds(shape: TLShape | TLShapeId): Box | undefined;
    getShapePageTransform(shape: TLShape | TLShapeId): Mat;
    getShapeParent(shape?: TLShape | TLShapeId): TLShape | undefined;
    getShapeParentTransform(shape: TLShape | TLShapeId): Mat;
    getShapesAtPoint(point: VecLike, opts?: {
        hitInside?: boolean | undefined;
        margin?: number | undefined;
    }): TLShape[];
    // @internal (undocumented)
    getShapesPageBounds(shapeIds: TLShapeId[]): Box | null;
    // @internal (undocumented)
    getShapesRotatedPageBounds(shapeIds: TLShapeId[]): Box | undefined;
    // @internal (undocumented)
    getShapesSharedRotation(shapeIds: TLShapeId[]): number;
    // (undocumented)
    getShapeStyleIfExists<T>(shape: TLShape, style: StyleProp<T>): T | undefined;
    getShapeUtil<S extends TLUnknownShape>(shape: S | TLShapePartial<S>): ShapeUtil<S>;
    // (undocumented)
    getShapeUtil<S extends TLUnknownShape>(type: S['type']): ShapeUtil<S>;
    // (undocumented)
    getShapeUtil<T extends ShapeUtil>(type: T extends ShapeUtil<infer R> ? R['type'] : string): T;
    getSharedOpacity(): SharedStyle<number>;
    getSharedStyles(): ReadonlySharedStyleMap;
    // (undocumented)
    getSnapshot(): TLEditorSnapshot;
    getSortedChildIdsForParent(parent: TLPage | TLParentId | TLShape): TLShapeId[];
    getStateDescendant<T extends StateNode>(path: string): T | undefined;
    getStyleForNextShape<T>(style: StyleProp<T>): T;
    // @deprecated (undocumented)
    getSvg(shapes: TLShape[] | TLShapeId[], opts?: TLImageExportOptions): Promise<SVGSVGElement | undefined>;
    getSvgElement(shapes: TLShape[] | TLShapeId[], opts?: TLImageExportOptions): Promise<{
        height: number;
        svg: SVGSVGElement;
        width: number;
    } | undefined>;
    getSvgString(shapes: TLShape[] | TLShapeId[], opts?: TLImageExportOptions): Promise<{
        height: number;
        svg: string;
        width: number;
    } | undefined>;
    getTemporaryAssetPreview(assetId: TLAssetId): string | undefined;
    // @internal (undocumented)
    getUnorderedRenderingShapes(useEditorState: boolean): TLRenderingShape[];
    getViewportPageBounds(): Box;
    getViewportScreenBounds(): Box;
    getViewportScreenCenter(): Vec;
    getZoomLevel(): number;
    groupShapes(shapes: TLShape[], opts?: Partial<{
        groupId: TLShapeId;
        select: boolean;
    }>): this;
    // (undocumented)
    groupShapes(ids: TLShapeId[], opts?: Partial<{
        groupId: TLShapeId;
        select: boolean;
    }>): this;
    hasAncestor(shape: TLShape | TLShapeId | undefined, ancestorId: TLShapeId): boolean;
    // (undocumented)
    hasExternalAssetHandler(type: TLExternalAssetContent['type']): boolean;
    protected readonly history: HistoryManager<TLRecord>;
    inputs: {
        buttons: Set<number>;
        keys: Set<string>;
        originScreenPoint: Vec;
        originPagePoint: Vec;
        currentScreenPoint: Vec;
        currentPagePoint: Vec;
        previousScreenPoint: Vec;
        previousPagePoint: Vec;
        pointerVelocity: Vec;
        altKey: boolean;
        ctrlKey: boolean;
        isPen: boolean;
        metaKey: boolean;
        shiftKey: boolean;
        isDragging: boolean;
        isEditing: boolean;
        isPanning: boolean;
        isPinching: boolean;
        isPointing: boolean;
        isSpacebarPanning: boolean;
    };
    interrupt(): this;
    isAncestorSelected(shape: TLShape | TLShapeId): boolean;
    isDisposed: boolean;
    isIn(path: string): boolean;
    isInAny(...paths: string[]): boolean;
    isPointInShape(shape: TLShape | TLShapeId, point: VecLike, opts?: {
        hitInside?: boolean | undefined;
        margin?: number | undefined;
    }): boolean;
    // (undocumented)
    isShapeHidden(shapeOrId: TLShape | TLShapeId): boolean;
    isShapeInPage(shape: TLShape | TLShapeId, pageId?: TLPageId): boolean;
    isShapeOfType<T extends TLUnknownShape>(shape: TLUnknownShape, type: T['type']): shape is T;
    // (undocumented)
    isShapeOfType<T extends TLUnknownShape>(shapeId: TLUnknownShape['id'], type: T['type']): shapeId is T['id'];
    isShapeOrAncestorLocked(shape?: TLShape): boolean;
    // (undocumented)
    isShapeOrAncestorLocked(id?: TLShapeId): boolean;
    loadSnapshot(snapshot: Partial<TLEditorSnapshot> | TLStoreSnapshot, opts?: TLLoadSnapshotOptions): this;
    // @deprecated
    mark(markId?: string): this;
    markHistoryStoppingPoint(name?: string): string;
    // (undocumented)
    menus: {
        addOpenMenu: (id: string) => void;
        clearOpenMenus: () => void;
        deleteOpenMenu: (id: string) => void;
        getOpenMenus: () => string[];
        hasAnyOpenMenus: () => boolean;
        hasOpenMenus: () => boolean;
        isMenuOpen: (id: string) => boolean;
    };
    moveShapesToPage(shapes: TLShape[] | TLShapeId[], pageId: TLPageId): this;
    navigateToDeepLink(opts?: {
        param?: string;
        url?: string | URL;
    } | TLDeepLink): Editor;
    nudgeShapes(shapes: TLShape[] | TLShapeId[], offset: VecLike): this;
    // (undocumented)
    readonly options: TldrawOptions;
    packShapes(shapes: TLShape[] | TLShapeId[], gap: number): this;
    pageToScreen(point: VecLike): Vec;
    pageToViewport(point: VecLike): Vec;
    popFocusedGroupId(): this;
    putContentOntoCurrentPage(content: TLContent, opts?: {
        point?: VecLike;
        preserveIds?: boolean;
        preservePosition?: boolean;
        select?: boolean;
    }): this;
    putExternalContent<E>(info: TLExternalContent<E>): Promise<void>;
    redo(): this;
    registerDeepLinkListener(opts?: TLDeepLinkOptions): () => void;
    registerExternalAssetHandler<T extends TLExternalAssetContent['type']>(type: T, handler: ((info: TLExternalAssetContent & {
        type: T;
    }) => Promise<TLAsset>) | null): this;
    registerExternalContentHandler<T extends TLExternalContent<E>['type'], E>(type: T, handler: ((info: T extends TLExternalContent<E>['type'] ? TLExternalContent<E> & {
        type: T;
    } : TLExternalContent<E>) => void) | null): this;
    renamePage(page: TLPage | TLPageId, name: string): this;
    reparentShapes(shapes: TLShape[] | TLShapeId[], parentId: TLParentId, insertIndex?: IndexKey): this;
    resetZoom(point?: Vec, opts?: TLCameraMoveOptions): this;
    resizeShape(shape: TLShape | TLShapeId, scale: VecLike, opts?: TLResizeShapeOptions): this;
    // (undocumented)
    resolveAssetsInContent(content: TLContent | undefined): Promise<TLContent | undefined>;
    // (undocumented)
    resolveAssetUrl(assetId: null | TLAssetId, context: {
        screenScale?: number;
        shouldResolveToOriginal?: boolean;
    }): Promise<null | string>;
    readonly root: StateNode;
    rotateShapesBy(shapes: TLShape[] | TLShapeId[], delta: number, opts?: {
        center?: VecLike;
    }): this;
    run(fn: () => void, opts?: TLEditorRunOptions): this;
    screenToPage(point: VecLike): Vec;
    readonly scribbles: ScribbleManager;
    select(...shapes: TLShape[] | TLShapeId[]): this;
    selectAll(): this;
    selectNone(): this;
    sendBackward(shapes: TLShape[] | TLShapeId[], opts?: {
        considerAllShapes?: boolean;
    }): this;
    sendToBack(shapes: TLShape[] | TLShapeId[]): this;
    // @internal (undocumented)
    _setAltKeyTimeout(): void;
    setCamera(point: VecLike, opts?: TLCameraMoveOptions): this;
    setCameraOptions(opts: Partial<TLCameraOptions>): this;
    setCroppingShape(shape: null | TLShape | TLShapeId): this;
    // @internal (undocumented)
    _setCtrlKeyTimeout(): void;
    setCurrentPage(page: TLPage | TLPageId): this;
    setCurrentTool(id: string, info?: {}): this;
    setCursor(cursor: Partial<TLCursor>): this;
    setEditingShape(shape: null | TLShape | TLShapeId): this;
    setErasingShapes(shapes: TLShape[] | TLShapeId[]): this;
    setFocusedGroup(shape: null | TLGroupShape | TLShapeId): this;
    setHintingShapes(shapes: TLShape[] | TLShapeId[]): this;
    setHoveredShape(shape: null | TLShape | TLShapeId): this;
    // @internal (undocumented)
    _setMetaKeyTimeout(): void;
    setOpacityForNextShapes(opacity: number, historyOptions?: TLHistoryBatchOptions): this;
    setOpacityForSelectedShapes(opacity: number): this;
    setSelectedShapes(shapes: TLShape[] | TLShapeId[]): this;
    // @internal (undocumented)
    _setShiftKeyTimeout(): void;
    setStyleForNextShapes<T>(style: StyleProp<T>, value: T, historyOptions?: TLHistoryBatchOptions): this;
    setStyleForSelectedShapes<S extends StyleProp<any>>(style: S, value: StylePropValue<S>): this;
    shapeUtils: {
        readonly [K in string]?: ShapeUtil<TLUnknownShape>;
    };
    readonly sideEffects: StoreSideEffects<TLRecord>;
    slideCamera(opts?: {
        direction: VecLike;
        force?: boolean | undefined;
        friction?: number | undefined;
        speed: number;
        speedThreshold?: number | undefined;
    }): this;
    readonly snaps: SnapManager;
    squashToMark(markId: string): this;
    stackShapes(shapes: TLShape[] | TLShapeId[], operation: 'horizontal' | 'vertical', gap: number): this;
    startFollowingUser(userId: string): this;
    stopCameraAnimation(): this;
    stopFollowingUser(): this;
    readonly store: TLStore;
    stretchShapes(shapes: TLShape[] | TLShapeId[], operation: 'horizontal' | 'vertical'): this;
    // (undocumented)
    styleProps: {
        [key: string]: Map<StyleProp<any>, string>;
    };
    readonly textMeasure: TextManager;
    // (undocumented)
    _tickCameraState(): void;
    readonly timers: {
        dispose: () => void;
        requestAnimationFrame: (callback: FrameRequestCallback) => number;
        setInterval: (handler: TimerHandler, timeout?: number | undefined, ...args: any[]) => number;
        setTimeout: (handler: TimerHandler, timeout?: number | undefined, ...args: any[]) => number;
    };
    toggleLock(shapes: TLShape[] | TLShapeId[]): this;
    undo(): this;
    ungroupShapes(ids: TLShapeId[], opts?: Partial<{
        select: boolean;
    }>): this;
    // (undocumented)
    ungroupShapes(shapes: TLShape[], opts?: Partial<{
        select: boolean;
    }>): this;
    updateAssets(assets: TLAssetPartial[]): this;
    updateBinding<B extends TLBinding = TLBinding>(partial: TLBindingUpdate<B>): this;
    updateBindings(partials: (null | TLBindingUpdate | undefined)[]): this;
    updateCurrentPageState(partial: Partial<Omit<TLInstancePageState, 'editingShapeId' | 'focusedGroupId' | 'pageId' | 'selectedShapeIds'>>): this;
    // (undocumented)
    _updateCurrentPageState(partial: Partial<Omit<TLInstancePageState, 'selectedShapeIds'>>): void;
    updateDocumentSettings(settings: Partial<TLDocument>): this;
    updateInstanceState(partial: Partial<Omit<TLInstance, 'currentPageId'>>, historyOptions?: TLHistoryBatchOptions): this;
    // @internal (undocumented)
    _updateInstanceState(partial: Partial<Omit<TLInstance, 'currentPageId'>>, opts?: TLHistoryBatchOptions): void;
    updatePage(partial: RequiredKeys<Partial<TLPage>, 'id'>): this;
    updateShape<T extends TLUnknownShape>(partial: null | TLShapePartial<T> | undefined): this;
    updateShapes<T extends TLUnknownShape>(partials: (null | TLShapePartial<T> | undefined)[]): this;
    // @internal (undocumented)
    _updateShapes(_partials: (null | TLShapePartial | undefined)[]): void;
    updateViewportScreenBounds(screenBounds: Box | HTMLElement, center?: boolean): this;
    uploadAsset(asset: TLAsset, file: File, abortSignal?: AbortSignal): Promise<string>;
    readonly user: UserPreferencesManager;
    visitDescendants(parent: TLPage | TLParentId | TLShape, visitor: (id: TLShapeId) => false | void): this;
    zoomIn(point?: Vec, opts?: TLCameraMoveOptions): this;
    zoomOut(point?: Vec, opts?: TLCameraMoveOptions): this;
    zoomToBounds(bounds: BoxLike, opts?: {
        inset?: number;
        targetZoom?: number;
    } & TLCameraMoveOptions): this;
    zoomToFit(opts?: TLCameraMoveOptions): this;
    zoomToSelection(opts?: TLCameraMoveOptions): this;
    zoomToUser(userId: string, opts?: TLCameraMoveOptions): this;
}

// @public (undocumented)
export const EditorContext: React_2.Context<Editor | null>;

export { EffectScheduler }

// @public (undocumented)
export class Ellipse2d extends Geometry2d {
    constructor(config: Omit<Geometry2dOptions, 'isClosed'> & {
        height: number;
        width: number;
    });
    // (undocumented)
    config: Omit<Geometry2dOptions, 'isClosed'> & {
        height: number;
        width: number;
    };
    // (undocumented)
    get edges(): Edge2d[];
    // (undocumented)
    _edges?: Edge2d[];
    // (undocumented)
    getBounds(): Box;
    // (undocumented)
    getLength(): number;
    // (undocumented)
    getSvgPathData(first?: boolean): string;
    // (undocumented)
    getVertices(): any[];
    // (undocumented)
    h: number;
    // (undocumented)
    hitTestLineSegment(A: Vec, B: Vec): boolean;
    // (undocumented)
    nearestPoint(A: Vec): Vec;
    // (undocumented)
    w: number;
}

export { EMPTY_ARRAY }

// @public (undocumented)
export class ErrorBoundary extends React_3.Component<React_3.PropsWithRef<React_3.PropsWithChildren<TLErrorBoundaryProps>>, {
    error: Error | null;
}> {
    // (undocumented)
    componentDidCatch(error: unknown): void;
    // (undocumented)
    static getDerivedStateFromError(error: Error): {
        error: Error;
    };
    // (undocumented)
    render(): boolean | JSX_2.Element | Iterable<React_3.ReactNode> | null | number | string | undefined;
    // (undocumented)
    state: {
        error: null;
    };
}

// @public (undocumented)
export function ErrorScreen({ children }: LoadingScreenProps): JSX_2.Element;

// @public (undocumented)
export const EVENT_NAME_MAP: Record<Exclude<TLEventName, TLPinchEventName>, keyof TLEventHandlers>;

// @internal (undocumented)
export function extractSessionStateFromLegacySnapshot(store: Record<string, UnknownRecord>): null | TLSessionStateSnapshot;

// @internal (undocumented)
export const featureFlags: Record<string, DebugFlag<boolean>>;

// @public (undocumented)
export interface GapsSnapIndicator {
    // (undocumented)
    direction: 'horizontal' | 'vertical';
    // (undocumented)
    gaps: Array<{
        endEdge: [VecLike, VecLike];
        startEdge: [VecLike, VecLike];
    }>;
    // (undocumented)
    id: string;
    // (undocumented)
    type: 'gaps';
}

// @public (undocumented)
export abstract class Geometry2d {
    constructor(opts: Geometry2dOptions);
    // (undocumented)
    get area(): number;
    // (undocumented)
    get bounds(): Box;
    // (undocumented)
    get center(): Vec;
    // (undocumented)
    debugColor?: string;
    // (undocumented)
    distanceToLineSegment(A: Vec, B: Vec): number;
    // (undocumented)
    distanceToPoint(point: Vec, hitInside?: boolean): number;
    // (undocumented)
    getArea(): number;
    // (undocumented)
    getBounds(): Box;
    // (undocumented)
    getLength(): number;
    // (undocumented)
    abstract getSvgPathData(first: boolean): string;
    // (undocumented)
    abstract getVertices(): Vec[];
    // (undocumented)
    hitTestLineSegment(A: Vec, B: Vec, distance?: number): boolean;
    // (undocumented)
    hitTestPoint(point: Vec, margin?: number, hitInside?: boolean): boolean;
    // (undocumented)
    ignore?: boolean;
    // (undocumented)
    isClosed: boolean;
    // (undocumented)
    isFilled: boolean;
    // (undocumented)
    isLabel: boolean;
    // (undocumented)
    isPointInBounds(point: Vec, margin?: number): boolean;
    // (undocumented)
    get length(): number;
    // (undocumented)
    abstract nearestPoint(point: Vec): Vec;
    // (undocumented)
    nearestPointOnLineSegment(A: Vec, B: Vec): Vec;
    // (undocumented)
    toSimpleSvgPath(): string;
    // (undocumented)
    get vertices(): Vec[];
}

// @public (undocumented)
export interface Geometry2dOptions {
    // (undocumented)
    debugColor?: string;
    // (undocumented)
    ignore?: boolean;
    // (undocumented)
    isClosed: boolean;
    // (undocumented)
    isFilled: boolean;
    // (undocumented)
    isLabel?: boolean;
}

// @public
export function getArcMeasure(A: number, B: number, sweepFlag: number, largeArcFlag: number): number;

// @public (undocumented)
export function getCursor(cursor: TLCursorType, rotation?: number, color?: string): string;

// @public (undocumented)
export function getDefaultCdnBaseUrl(): string;

// @public (undocumented)
export function getFreshUserPreferences(): TLUserPreferences;

// @public
export function getIncrementedName(name: string, others: string[]): string;

// @public (undocumented)
export function getPerfectDashProps(totalLength: number, strokeWidth: number, opts?: Partial<{
    closed: boolean;
    end: 'none' | 'outset' | 'skip';
    forceSolid: boolean;
    lengthRatio: number;
    snap: number;
    start: 'none' | 'outset' | 'skip';
    style: TLDefaultDashStyle;
}>): {
    strokeDasharray: string;
    strokeDashoffset: string;
};

// @public (undocumented)
export function getPointerInfo(e: PointerEvent | React.PointerEvent): {
    accelKey: boolean;
    altKey: boolean;
    button: number;
    ctrlKey: boolean;
    isPen: boolean;
    metaKey: boolean;
    point: {
        x: number;
        y: number;
        z: number;
    };
    pointerId: number;
    shiftKey: boolean;
};

// @public
export function getPointInArcT(mAB: number, A: number, B: number, P: number): number;

// @public
export function getPointOnCircle(center: VecLike, r: number, a: number): Vec;

// @public (undocumented)
export function getPointsOnArc(startPoint: VecLike, endPoint: VecLike, center: null | VecLike, radius: number, numPoints: number): Vec[];

// @public (undocumented)
export function getPolygonVertices(width: number, height: number, sides: number): Vec[];

// @internal (undocumented)
export function getRotationSnapshot({ editor, ids, }: {
    editor: Editor;
    ids: TLShapeId[];
}): null | TLRotationSnapshot;

// @public (undocumented)
export function getSnapshot(store: TLStore): TLEditorSnapshot;

// @public
export function getSvgPathFromPoints(points: VecLike[], closed?: boolean): string;

// @public (undocumented)
export function getUserPreferences(): TLUserPreferences;

// @public (undocumented)
export class Group2d extends Geometry2d {
    constructor(config: Omit<Geometry2dOptions, 'isClosed' | 'isFilled'> & {
        children: Geometry2d[];
    });
    // (undocumented)
    children: Geometry2d[];
    // (undocumented)
    distanceToPoint(point: Vec, hitInside?: boolean): number;
    // (undocumented)
    getArea(): number;
    // (undocumented)
    getLength(): number;
    // (undocumented)
    getSvgPathData(): string;
    // (undocumented)
    getVertices(): Vec[];
    // (undocumented)
    hitTestLineSegment(A: Vec, B: Vec, zoom: number): boolean;
    // (undocumented)
    hitTestPoint(point: Vec, margin: number, hitInside: boolean): boolean;
    // (undocumented)
    ignoredChildren: Geometry2d[];
    // (undocumented)
    nearestPoint(point: Vec): Vec;
    // (undocumented)
    toSimpleSvgPath(): string;
}

// @public (undocumented)
export class GroupShapeUtil extends ShapeUtil<TLGroupShape> {
    // (undocumented)
    canBind(): boolean;
    // (undocumented)
    component(shape: TLGroupShape): JSX_2.Element | null;
    // (undocumented)
    getDefaultProps(): TLGroupShape['props'];
    // (undocumented)
    getGeometry(shape: TLGroupShape): Geometry2d;
    // (undocumented)
    hideSelectionBoundsFg(): boolean;
    // (undocumented)
    indicator(shape: TLGroupShape): JSX_2.Element;
    // (undocumented)
    static migrations: TLPropsMigrations;
    // (undocumented)
    onChildrenChange(group: TLGroupShape): void;
    // (undocumented)
    static props: RecordProps<TLGroupShape>;
    // (undocumented)
    static type: "group";
}

// @public (undocumented)
export const HALF_PI: number;

// @public
export interface HandleSnapGeometry {
    getSelfSnapOutline?(handle: TLHandle): Geometry2d | null;
    getSelfSnapPoints?(handle: TLHandle): VecModel[];
    outline?: Geometry2d | null;
    points?: VecModel[];
}

// @public (undocumented)
export class HandleSnaps {
    constructor(manager: SnapManager);
    // (undocumented)
    readonly editor: Editor;
    // (undocumented)
    readonly manager: SnapManager;
    // (undocumented)
    snapHandle({ currentShapeId, handle, }: {
        currentShapeId: TLShapeId;
        handle: TLHandle;
    }): null | SnapData;
}

// @public
export function hardReset({ shouldReload }?: {
    shouldReload?: boolean | undefined;
}): Promise<void>;

// @public (undocumented)
export function hardResetEditor(): void;

// @public (undocumented)
export class HistoryManager<R extends UnknownRecord> {
    constructor(opts: {
        annotateError?(error: unknown): void;
        store: Store<R>;
    });
    // (undocumented)
    bail(): this;
    // (undocumented)
    bailToMark(id: string): this;
    // (undocumented)
    batch(fn: () => void, opts?: TLHistoryBatchOptions): this;
    // (undocumented)
    clear(): void;
    // @internal (undocumented)
    debug(): {
        pendingDiff: {
            diff: RecordsDiff<R>;
            isEmpty: boolean;
        };
        redos: (NonNullable<TLHistoryEntry<R>> | undefined)[];
        state: string;
        undos: (NonNullable<TLHistoryEntry<R>> | undefined)[];
    };
    // (undocumented)
    readonly dispose: () => void;
    // @internal (undocumented)
    getMarkIdMatching(idSubstring: string): null | string;
    // (undocumented)
    getNumRedos(): number;
    // (undocumented)
    getNumUndos(): number;
    // @internal (undocumented)
    _isInBatch: boolean;
    // @internal (undocumented)
    _mark(id: string): void;
    // (undocumented)
    redo(): this;
    // (undocumented)
    squashToMark(id: string): this;
    // (undocumented)
    undo(): this;
    // (undocumented)
    _undo({ pushToRedoStack, toMark }: {
        pushToRedoStack: boolean;
        toMark?: string;
    }): this;
}

// @public (undocumented)
export function HTMLContainer({ children, className, ...rest }: HTMLContainerProps): JSX_2.Element;

// @public (undocumented)
export type HTMLContainerProps = React_3.HTMLAttributes<HTMLDivElement>;

// @public (undocumented)
export const inlineBase64AssetStore: TLAssetStore;

// @public
export function intersectCircleCircle(c1: VecLike, r1: number, c2: VecLike, r2: number): Vec[];

// @public
export function intersectCirclePolygon(c: VecLike, r: number, points: VecLike[]): null | VecLike[];

// @public
export function intersectCirclePolyline(c: VecLike, r: number, points: VecLike[]): null | VecLike[];

// @public
export function intersectLineSegmentCircle(a1: VecLike, a2: VecLike, c: VecLike, r: number): null | VecLike[];

// @public
export function intersectLineSegmentLineSegment(a1: VecLike, a2: VecLike, b1: VecLike, b2: VecLike): null | Vec;

// @public
export function intersectLineSegmentPolygon(a1: VecLike, a2: VecLike, points: VecLike[]): null | VecLike[];

// @public
export function intersectLineSegmentPolyline(a1: VecLike, a2: VecLike, points: VecLike[]): null | VecLike[];

// @public
export function intersectPolygonBounds(points: VecLike[], bounds: Box): null | VecLike[];

// @public
export function intersectPolygonPolygon(polygonA: VecLike[], polygonB: VecLike[]): null | VecLike[];

// @internal (undocumented)
export interface InvalidLicenseKeyResult {
    // (undocumented)
    isLicenseParseable: false;
    // (undocumented)
    reason: InvalidLicenseReason;
}

// @internal (undocumented)
export type InvalidLicenseReason = 'has-key-development-mode' | 'invalid-license-key' | 'no-key-provided';

// @internal (undocumented)
export const isAccelKey: <InputType extends {
    ctrlKey: boolean;
    metaKey: boolean;
}>(e: InputType) => boolean;

// @public
export const isSafeFloat: (n: number) => boolean;

// @internal (undocumented)
export type LicenseFromKeyResult = InvalidLicenseKeyResult | ValidLicenseKeyResult;

// @internal (undocumented)
export interface LicenseInfo {
    // (undocumented)
    expiryDate: string;
    // (undocumented)
    flags: number;
    // (undocumented)
    hosts: string[];
    // (undocumented)
    id: string;
}

// @internal (undocumented)
export class LicenseManager {
    constructor(licenseKey: string | undefined, testPublicKey?: string, testEnvironment?: TestEnvironment);
    // (undocumented)
    static className: string;
    // (undocumented)
    getLicenseFromKey(licenseKey?: string): Promise<LicenseFromKeyResult>;
    // (undocumented)
    isCryptoAvailable: boolean;
    // (undocumented)
    isDevelopment: boolean;
    // (undocumented)
    isTest: boolean;
    // (undocumented)
    state: Atom<"licensed-with-watermark" | "licensed" | "pending" | "unlicensed", unknown>;
    // (undocumented)
    verbose: boolean;
}

// @public (undocumented)
export function linesIntersect(A: VecLike, B: VecLike, C: VecLike, D: VecLike): boolean;

// @public (undocumented)
export function LoadingScreen({ children }: LoadingScreenProps): JSX_2.Element;

// @public (undocumented)
export interface LoadingScreenProps {
    // (undocumented)
    children: ReactNode;
}

// @public
export function loadSessionStateSnapshotIntoStore(store: TLStore, snapshot: TLSessionStateSnapshot, opts?: TLLoadSessionStateSnapshotOptions): void;

// @public
export function loadSnapshot(store: TLStore, _snapshot: Partial<TLEditorSnapshot> | TLStoreSnapshot, opts?: TLLoadSnapshotOptions): void;

// @internal (undocumented)
export class LocalIndexedDb {
    constructor(persistenceKey: string);
    // (undocumented)
    close(): Promise<void>;
    // (undocumented)
    static connectedInstances: Set<LocalIndexedDb>;
    // (undocumented)
    getAsset(assetId: string): Promise<File | undefined>;
    // (undocumented)
    load({ sessionId }?: {
        sessionId?: string;
    }): Promise<{
        records: any[];
        schema: any;
        sessionStateSnapshot: TLSessionStateSnapshot | undefined;
    }>;
    pending(): Promise<void>;
    // (undocumented)
    pruneSessions(): Promise<void>;
    // (undocumented)
    storeAsset(assetId: string, blob: File): Promise<void>;
    // (undocumented)
    storeChanges({ schema, changes, sessionId, sessionStateSnapshot, }: {
        changes: RecordsDiff<any>;
        schema: TLStoreSchema;
        sessionId?: null | string;
        sessionStateSnapshot?: null | TLSessionStateSnapshot;
    }): Promise<void>;
    // (undocumented)
    storeSnapshot({ schema, snapshot, sessionId, sessionStateSnapshot, }: {
        schema: TLStoreSchema;
        sessionId?: null | string;
        sessionStateSnapshot?: null | TLSessionStateSnapshot;
        snapshot: SerializedStore<any>;
    }): Promise<void>;
}

// @public (undocumented)
export function loopToHtmlElement(elm: Element): HTMLElement;

// @public (undocumented)
export class Mat {
    constructor(a: number, b: number, c: number, d: number, e: number, f: number);
    // (undocumented)
    a: number;
    // (undocumented)
    static Absolute(m: MatLike): MatModel;
    // (undocumented)
    static applyToBounds(m: MatLike, box: Box): Box;
    // (undocumented)
    applyToPoint(point: VecLike): Vec;
    // (undocumented)
    static applyToPoint(m: MatLike, point: VecLike): Vec;
    // (undocumented)
    applyToPoints(points: VecLike[]): Vec[];
    // (undocumented)
    static applyToPoints(m: MatLike, points: VecLike[]): Vec[];
    // (undocumented)
    static applyToXY(m: MatLike, x: number, y: number): number[];
    // (undocumented)
    b: number;
    // (undocumented)
    c: number;
    // (undocumented)
    static Cast(m: MatLike): Mat;
    // (undocumented)
    clone(): Mat;
    // (undocumented)
    static Compose(...matrices: MatLike[]): Mat;
    // (undocumented)
    d: number;
    // (undocumented)
    static Decompose(m: MatLike): {
        rotation: number;
        scaleX: number;
        scaleY: number;
        x: number;
        y: number;
    };
    // (undocumented)
    decompose(): {
        rotation: number;
        scaleX: number;
        scaleY: number;
        x: number;
        y: number;
    };
    // (undocumented)
    decomposed(): {
        rotation: number;
        scaleX: number;
        scaleY: number;
        x: number;
        y: number;
    };
    // (undocumented)
    e: number;
    // (undocumented)
    equals(m: Mat | MatModel): boolean;
    // (undocumented)
    f: number;
    // (undocumented)
    static From(m: MatLike): Mat;
    // (undocumented)
    static Identity(): Mat;
    // (undocumented)
    identity(): this;
    // (undocumented)
    static Inverse(m: MatModel): MatModel;
    // (undocumented)
    invert(): this;
    // (undocumented)
    static Multiply(m1: MatModel, m2: MatModel): MatModel;
    // (undocumented)
    multiply(m: Mat | MatModel): this;
    // (undocumented)
    static Point(m: MatLike): Vec;
    // (undocumented)
    point(): Vec;
    // (undocumented)
    static Rotate(r: number, cx?: number, cy?: number): Mat;
    // (undocumented)
    rotate(r: number, cx?: number, cy?: number): Mat;
    // (undocumented)
    static Rotation(m: MatLike): number;
    // (undocumented)
    rotation(): number;
    // (undocumented)
    static Scale(x: number, y: number): MatModel;
    // (undocumented)
    static Scale(x: number, y: number, cx: number, cy: number): MatModel;
    // (undocumented)
    scale(x: number, y: number): this;
    // (undocumented)
    setTo(model: MatModel): this;
    // (undocumented)
    static Smooth(m: MatLike, precision?: number): MatLike;
    // (undocumented)
    toCssString(): string;
    // (undocumented)
    static toCssString(m: MatLike): string;
    // (undocumented)
    static Translate(x: number, y: number): Mat;
    // (undocumented)
    translate(x: number, y: number): Mat;
}

// @public (undocumented)
export type MatLike = Mat | MatModel;

// @public (undocumented)
export interface MatModel {
    // (undocumented)
    a: number;
    // (undocumented)
    b: number;
    // (undocumented)
    c: number;
    // (undocumented)
    d: number;
    // (undocumented)
    e: number;
    // (undocumented)
    f: number;
}

// @public
export function maybeSnapToGrid(point: Vec, editor: Editor): Vec;

// @public
export function MenuClickCapture(): false | JSX_2.Element;

// @internal (undocumented)
export function normalizeWheel(event: React.WheelEvent<HTMLElement> | WheelEvent): {
    x: number;
    y: number;
    z: number;
};

// @public (undocumented)
export function openWindow(url: string, target?: string): void;

// @internal (undocumented)
export function OptionalErrorBoundary({ children, fallback, ...props }: Omit<TLErrorBoundaryProps, 'fallback'> & {
    fallback: TLErrorFallbackComponent;
}): boolean | JSX_2.Element | Iterable<React_3.ReactNode> | null | number | string | undefined;

// @public (undocumented)
export type OptionalKeys<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

// @public
export function parseDeepLinkString(deepLinkString: string): TLDeepLink;

// @public
export function perimeterOfEllipse(rx: number, ry: number): number;

// @public (undocumented)
export const PI: number;

// @public (undocumented)
export const PI2: number;

// @public (undocumented)
export class Point2d extends Geometry2d {
    constructor(config: Omit<Geometry2dOptions, 'isClosed' | 'isFilled'> & {
        margin: number;
        point: Vec;
    });
    // (undocumented)
    getSvgPathData(): string;
    // (undocumented)
    getVertices(): Vec[];
    // (undocumented)
    hitTestLineSegment(A: Vec, B: Vec, margin: number): boolean;
    // (undocumented)
    nearestPoint(): Vec;
    // (undocumented)
    point: Vec;
}

// @public
export function pointInPolygon(A: VecLike, points: VecLike[]): boolean;

// @public (undocumented)
export interface PointsSnapIndicator {
    // (undocumented)
    id: string;
    // (undocumented)
    points: VecLike[];
    // (undocumented)
    type: 'points';
}

// @public (undocumented)
export class Polygon2d extends Polyline2d {
    constructor(config: Omit<Geometry2dOptions, 'isClosed'> & {
        points: Vec[];
    });
}

// @public (undocumented)
export function polygonIntersectsPolyline(polygon: VecLike[], polyline: VecLike[]): boolean;

// @public (undocumented)
export function polygonsIntersect(a: VecLike[], b: VecLike[]): boolean;

// @public (undocumented)
export class Polyline2d extends Geometry2d {
    constructor(config: Omit<Geometry2dOptions, 'isClosed' | 'isFilled'> & {
        points: Vec[];
    });
    // (undocumented)
    getLength(): number;
    // (undocumented)
    getSvgPathData(): string;
    // (undocumented)
    getVertices(): Vec[];
    // (undocumented)
    hitTestLineSegment(A: Vec, B: Vec, distance?: number): boolean;
    // (undocumented)
    nearestPoint(A: Vec): Vec;
    // (undocumented)
    points: Vec[];
    // (undocumented)
    get segments(): Edge2d[];
    // (undocumented)
    _segments?: Edge2d[];
}

// @public (undocumented)
export function precise(A: VecLike): string;

// @public
export function preventDefault(event: Event | React_2.BaseSyntheticEvent): void;

// @public
export function radiansToDegrees(r: number): number;

// @public
export function rangeIntersection(a0: number, a1: number, b0: number, b1: number): [number, number] | null;

export { react }

// @public
export class ReadonlySharedStyleMap {
    // (undocumented)
    [Symbol.iterator](): IterableIterator<[StyleProp<any>, SharedStyle<unknown>]>;
    constructor(entries?: Iterable<[StyleProp<unknown>, SharedStyle<unknown>]>);
    // (undocumented)
    entries(): IterableIterator<[StyleProp<any>, SharedStyle<unknown>]>;
    // (undocumented)
    equals(other: ReadonlySharedStyleMap): boolean;
    // (undocumented)
    get<T>(prop: StyleProp<T>): SharedStyle<T> | undefined;
    // (undocumented)
    getAsKnownValue<T>(prop: StyleProp<T>): T | undefined;
    // (undocumented)
    keys(): IterableIterator<StyleProp<any>>;
    // @internal (undocumented)
    protected map: Map<StyleProp<any>, SharedStyle<unknown>>;
    // (undocumented)
    get size(): number;
    // (undocumented)
    values(): IterableIterator<SharedStyle<unknown>>;
}

// @public (undocumented)
export class Rectangle2d extends Polygon2d {
    constructor(config: Omit<Geometry2dOptions, 'isClosed'> & {
        height: number;
        width: number;
        x?: number;
        y?: number;
    });
    // (undocumented)
    getBounds(): Box;
    // (undocumented)
    getSvgPathData(): string;
    // (undocumented)
    h: number;
    // (undocumented)
    w: number;
    // (undocumented)
    x: number;
    // (undocumented)
    y: number;
}

// @public (undocumented)
export function refreshPage(): void;

// @public (undocumented)
export function releasePointerCapture(element: Element, event: PointerEvent | React_2.PointerEvent<Element>): void;

// @public (undocumented)
export type RequiredKeys<T, K extends keyof T> = Required<Pick<T, K>> & Omit<T, K>;

// @public (undocumented)
export function resizeBox<T extends TLBaseBoxShape>(shape: T, info: {
    handle: TLResizeHandle;
    initialBounds: Box;
    initialShape: T;
    mode: TLResizeMode;
    newPoint: VecModel;
    scaleX: number;
    scaleY: number;
}, opts?: ResizeBoxOptions): T;

// @public (undocumented)
export interface ResizeBoxOptions {
    // (undocumented)
    maxHeight?: number;
    // (undocumented)
    maxWidth?: number;
    // (undocumented)
    minHeight?: number;
    // (undocumented)
    minWidth?: number;
}

// @public (undocumented)
export const ROTATE_CORNER_TO_SELECTION_CORNER: {
    readonly bottom_left_rotate: "bottom_left";
    readonly bottom_right_rotate: "bottom_right";
    readonly mobile_rotate: "top_left";
    readonly top_left_rotate: "top_left";
    readonly top_right_rotate: "top_right";
};

// @public (undocumented)
export type RotateCorner = 'bottom_left_rotate' | 'bottom_right_rotate' | 'mobile_rotate' | 'top_left_rotate' | 'top_right_rotate';

// @public (undocumented)
export function rotateSelectionHandle(handle: SelectionHandle, rotation: number): SelectionHandle;

// @public (undocumented)
export const runtime: {
    hardReset(): void;
    openWindow(url: string, target: string): void;
    refreshPage(): void;
};

// @public
export type SafeId = string & {
    __brand: 'SafeId';
};

// @public (undocumented)
export function sanitizeId(id: string): string;

// @public (undocumented)
export interface ScribbleItem {
    // (undocumented)
    delayRemaining: number;
    // (undocumented)
    id: string;
    // (undocumented)
    next: null | VecModel;
    // (undocumented)
    prev: null | VecModel;
    // (undocumented)
    scribble: TLScribble;
    // (undocumented)
    timeoutMs: number;
}

// @public (undocumented)
export class ScribbleManager {
    constructor(editor: Editor);
    addPoint(id: ScribbleItem['id'], x: number, y: number, z?: number): ScribbleItem;
    // (undocumented)
    addScribble(scribble: Partial<TLScribble>, id?: string): ScribbleItem;
    // (undocumented)
    reset(): void;
    // (undocumented)
    scribbleItems: Map<string, ScribbleItem>;
    // (undocumented)
    state: "paused" | "running";
    stop(id: ScribbleItem['id']): ScribbleItem;
    tick(elapsed: number): void;
}

// @public (undocumented)
export type SelectionCorner = 'bottom_left' | 'bottom_right' | 'top_left' | 'top_right';

// @public (undocumented)
export type SelectionEdge = 'bottom' | 'left' | 'right' | 'top';

// @public (undocumented)
export type SelectionHandle = SelectionCorner | SelectionEdge;

// @public (undocumented)
export function setPointerCapture(element: Element, event: PointerEvent | React_2.PointerEvent<Element>): void;

// @public (undocumented)
export function setRuntimeOverrides(input: Partial<typeof runtime>): void;

// @public (undocumented)
export function setUserPreferences(user: TLUserPreferences): void;

// @public (undocumented)
export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
    constructor(editor: Editor);
    // @internal
    backgroundComponent?(shape: Shape): any;
    canBeLaidOut(_shape: Shape): boolean;
    canBind(_opts: TLShapeUtilCanBindOpts<Shape>): boolean;
    canCrop(_shape: Shape): boolean;
    canDropShapes(_shape: Shape, _shapes: TLShape[]): boolean;
    canEdit(_shape: Shape): boolean;
    canEditInReadOnly(_shape: Shape): boolean;
    canReceiveNewChildrenOfType(_shape: Shape, _type: TLShape['type']): boolean;
    canResize(_shape: Shape): boolean;
    canScroll(_shape: Shape): boolean;
    canSnap(_shape: Shape): boolean;
    abstract component(shape: Shape): any;
    // (undocumented)
    editor: Editor;
    // @internal (undocumented)
    expandSelectionOutlinePx(shape: Shape): Box | number;
    getBoundsSnapGeometry(_shape: Shape): BoundsSnapGeometry;
    getCanvasSvgDefs(): TLShapeUtilCanvasSvgDef[];
    abstract getDefaultProps(): Shape['props'];
    abstract getGeometry(shape: Shape): Geometry2d;
    getHandles?(shape: Shape): TLHandle[];
    getHandleSnapGeometry(_shape: Shape): HandleSnapGeometry;
    getInterpolatedProps?(startShape: Shape, endShape: Shape, progress: number): Shape['props'];
    // (undocumented)
    getText(_shape: Shape): string | undefined;
    hideResizeHandles(_shape: Shape): boolean;
    hideRotateHandle(_shape: Shape): boolean;
    hideSelectionBoundsBg(_shape: Shape): boolean;
    hideSelectionBoundsFg(_shape: Shape): boolean;
    abstract indicator(shape: Shape): any;
    isAspectRatioLocked(_shape: Shape): boolean;
    static migrations?: LegacyMigrations | MigrationSequence | TLPropsMigrations;
    onBeforeCreate?(next: Shape): Shape | void;
    onBeforeUpdate?(prev: Shape, next: Shape): Shape | void;
    // @internal
    onBindingChange?(shape: Shape): TLShapePartial<Shape> | void;
    onChildrenChange?(shape: Shape): TLShapePartial[] | void;
    onClick?(shape: Shape): TLShapePartial<Shape> | void;
    onDoubleClick?(shape: Shape): TLShapePartial<Shape> | void;
    onDoubleClickEdge?(shape: Shape): TLShapePartial<Shape> | void;
    onDoubleClickHandle?(shape: Shape, handle: TLHandle): TLShapePartial<Shape> | void;
    onDragShapesOut?(shape: Shape, shapes: TLShape[]): void;
    onDragShapesOver?(shape: Shape, shapes: TLShape[]): void;
    onDropShapesOver?(shape: Shape, shapes: TLShape[]): void;
    onEditEnd?(shape: Shape): void;
    onHandleDrag?(shape: Shape, info: TLHandleDragInfo<Shape>): TLShapePartial<Shape> | void;
    onResize?(shape: Shape, info: TLResizeInfo<Shape>): Omit<TLShapePartial<Shape>, 'id' | 'type'> | undefined | void;
    onResizeEnd?(initial: Shape, current: Shape): TLShapePartial<Shape> | void;
    onResizeStart?(shape: Shape): TLShapePartial<Shape> | void;
    onRotate?(initial: Shape, current: Shape): TLShapePartial<Shape> | void;
    onRotateEnd?(initial: Shape, current: Shape): TLShapePartial<Shape> | void;
    onRotateStart?(shape: Shape): TLShapePartial<Shape> | void;
    onTranslate?(initial: Shape, current: Shape): TLShapePartial<Shape> | void;
    onTranslateEnd?(initial: Shape, current: Shape): TLShapePartial<Shape> | void;
    onTranslateStart?(shape: Shape): TLShapePartial<Shape> | void;
    static props?: RecordProps<TLUnknownShape>;
    // @internal
    providesBackgroundForChildren(_shape: Shape): boolean;
    toBackgroundSvg?(shape: Shape, ctx: SvgExportContext): null | Promise<null | ReactElement> | ReactElement;
    toSvg?(shape: Shape, ctx: SvgExportContext): null | Promise<null | ReactElement> | ReactElement;
    static type: string;
}

// @public
export type SharedStyle<T> = {
    readonly type: 'mixed';
} | {
    readonly type: 'shared';
    readonly value: T;
};

// @internal (undocumented)
export class SharedStyleMap extends ReadonlySharedStyleMap {
    // (undocumented)
    applyValue<T>(prop: StyleProp<T>, value: T): void;
    // (undocumented)
    set<T>(prop: StyleProp<T>, value: SharedStyle<T>): void;
}

// @public
export function shortAngleDist(a0: number, a1: number): number;

// @public (undocumented)
export const SIDES: readonly ["top", "right", "bottom", "left"];

export { Signal }

// @public (undocumented)
export const SIN: (x: number) => number;

// @public
export function snapAngle(r: number, segments: number): number;

// @public (undocumented)
export interface SnapData {
    // (undocumented)
    nudge: Vec;
}

// @public (undocumented)
export type SnapIndicator = GapsSnapIndicator | PointsSnapIndicator;

// @public (undocumented)
export class SnapManager {
    constructor(editor: Editor);
    // (undocumented)
    clearIndicators(): void;
    // (undocumented)
    readonly editor: Editor;
    // (undocumented)
    getCurrentCommonAncestor(): TLShapeId | undefined;
    // (undocumented)
    getIndicators(): SnapIndicator[];
    // (undocumented)
    getSnappableShapes(): Set<TLShapeId>;
    // (undocumented)
    getSnapThreshold(): number;
    // (undocumented)
    readonly handles: HandleSnaps;
    // (undocumented)
    setIndicators(indicators: SnapIndicator[]): void;
    // (undocumented)
    readonly shapeBounds: BoundsSnaps;
}

// @public (undocumented)
export class Stadium2d extends Geometry2d {
    constructor(config: Omit<Geometry2dOptions, 'isClosed'> & {
        height: number;
        width: number;
    });
    // (undocumented)
    a: Arc2d;
    // (undocumented)
    b: Edge2d;
    // (undocumented)
    c: Arc2d;
    // (undocumented)
    config: Omit<Geometry2dOptions, 'isClosed'> & {
        height: number;
        width: number;
    };
    // (undocumented)
    d: Edge2d;
    // (undocumented)
    getBounds(): Box;
    // (undocumented)
    getLength(): number;
    // (undocumented)
    getSvgPathData(): string;
    // (undocumented)
    getVertices(): Vec[];
    // (undocumented)
    h: number;
    // (undocumented)
    hitTestLineSegment(A: Vec, B: Vec): boolean;
    // (undocumented)
    nearestPoint(A: Vec): Vec;
    // (undocumented)
    w: number;
}

// @public (undocumented)
export abstract class StateNode implements Partial<TLEventHandlers> {
    constructor(editor: Editor, parent?: StateNode);
    // (undocumented)
    static children?: () => TLStateNodeConstructor[];
    // (undocumented)
    children?: Record<string, StateNode>;
    _currentToolIdMask: Atom<string | undefined, unknown>;
    // (undocumented)
    editor: Editor;
    // (undocumented)
    enter(info: any, from: string): void;
    // (undocumented)
    exit(info: any, from: string): void;
    getCurrent(): StateNode | undefined;
    // (undocumented)
    getCurrentToolIdMask(): string | undefined;
    getIsActive(): boolean;
    getPath(): string;
    // (undocumented)
    handleEvent(info: Exclude<TLEventInfo, TLPinchEventInfo>): void;
    // (undocumented)
    static id: string;
    // (undocumented)
    id: string;
    // (undocumented)
    static initial?: string;
    // (undocumented)
    initial?: string;
    // (undocumented)
    static isLockable: boolean;
    // (undocumented)
    isLockable: boolean;
    // (undocumented)
    onCancel?(info: TLCancelEventInfo): void;
    // (undocumented)
    onComplete?(info: TLCompleteEventInfo): void;
    // (undocumented)
    onDoubleClick?(info: TLClickEventInfo): void;
    // (undocumented)
    onEnter?(info: any, from: string): void;
    // (undocumented)
    onExit?(info: any, to: string): void;
    // (undocumented)
    onInterrupt?(info: TLInterruptEventInfo): void;
    // (undocumented)
    onKeyDown?(info: TLKeyboardEventInfo): void;
    // (undocumented)
    onKeyRepeat?(info: TLKeyboardEventInfo): void;
    // (undocumented)
    onKeyUp?(info: TLKeyboardEventInfo): void;
    // (undocumented)
    onLongPress?(info: TLPointerEventInfo): void;
    // (undocumented)
    onMiddleClick?(info: TLPointerEventInfo): void;
    // (undocumented)
    onPointerDown?(info: TLPointerEventInfo): void;
    // (undocumented)
    onPointerMove?(info: TLPointerEventInfo): void;
    // (undocumented)
    onPointerUp?(info: TLPointerEventInfo): void;
    // (undocumented)
    onQuadrupleClick?(info: TLClickEventInfo): void;
    // (undocumented)
    onRightClick?(info: TLPointerEventInfo): void;
    // (undocumented)
    onTick?(info: TLTickEventInfo): void;
    // (undocumented)
    onTripleClick?(info: TLClickEventInfo): void;
    // (undocumented)
    onWheel?(info: TLWheelEventInfo): void;
    // (undocumented)
    parent: StateNode;
    // (undocumented)
    _path: Computed<string>;
    // (undocumented)
    performanceTracker: PerformanceTracker;
    // (undocumented)
    setCurrentToolIdMask(id: string | undefined): void;
    // (undocumented)
    shapeType?: string;
    transition(id: string, info?: any): this;
    // (undocumented)
    type: 'branch' | 'leaf' | 'root';
}

// @public (undocumented)
export const stopEventPropagation: (e: any) => any;

// @internal (undocumented)
export type StoreName = (typeof Table)[keyof typeof Table];

// @public (undocumented)
export function suffixSafeId(id: SafeId, suffix: string): SafeId;

// @public (undocumented)
export function SVGContainer({ children, className, ...rest }: SVGContainerProps): JSX_2.Element;

// @public (undocumented)
export type SVGContainerProps = React_3.ComponentProps<'svg'>;

// @public (undocumented)
export interface SvgExportContext {
    addExportDef(def: SvgExportDef): void;
    readonly isDarkMode: boolean;
    waitUntil(promise: Promise<void>): void;
}

// @public (undocumented)
export interface SvgExportDef {
    // (undocumented)
    getElement(): null | Promise<null | ReactElement> | ReactElement;
    // (undocumented)
    key: string;
}

// @public
export const TAB_ID: string;

// @internal (undocumented)
export const Table: {
    readonly Assets: "assets";
    readonly Records: "records";
    readonly Schema: "schema";
    readonly SessionState: "session_state";
};

// @internal (undocumented)
export type TestEnvironment = 'development' | 'production';

// @public (undocumented)
export class TextManager {
    constructor(editor: Editor);
    // (undocumented)
    editor: Editor;
    measureElementTextNodeSpans(element: HTMLElement, { shouldTruncateToFirstLine }?: {
        shouldTruncateToFirstLine?: boolean;
    }): {
        didTruncate: boolean;
        spans: {
            box: BoxModel;
            text: string;
        }[];
    };
    // (undocumented)
    measureText(textToMeasure: string, opts: {
        maxWidth: null | number;
        disableOverflowWrapBreaking?: boolean;
        fontFamily: string;
        fontSize: number;
        fontStyle: string;
        fontWeight: string;
        lineHeight: number;
        minWidth?: null | number;
        padding: string;
    }): BoxModel & {
        scrollWidth: number;
    };
    measureTextSpans(textToMeasure: string, opts: TLMeasureTextSpanOpts): {
        box: BoxModel;
        text: string;
    }[];
}

// @public (undocumented)
export type TLAnyBindingUtilConstructor = TLBindingUtilConstructor<any>;

// @public (undocumented)
export type TLAnyShapeUtilConstructor = TLShapeUtilConstructor<any>;

// @public (undocumented)
export type TLBaseBoxShape = TLBaseShape<string, {
    h: number;
    w: number;
}>;

// @public (undocumented)
export interface TLBaseEventInfo {
    // (undocumented)
    accelKey: boolean;
    // (undocumented)
    altKey: boolean;
    // (undocumented)
    ctrlKey: boolean;
    // (undocumented)
    metaKey: boolean;
    // (undocumented)
    shiftKey: boolean;
    // (undocumented)
    type: UiEventType;
}

// @public (undocumented)
export interface TLBindingUtilConstructor<T extends TLUnknownBinding, U extends BindingUtil<T> = BindingUtil<T>> {
    // (undocumented)
    new (editor: Editor): U;
    migrations?: TLPropsMigrations;
    props?: RecordProps<T>;
    // (undocumented)
    type: T['type'];
}

// @public (undocumented)
export interface TLBrushProps {
    // (undocumented)
    brush: BoxModel;
    // (undocumented)
    className?: string;
    // (undocumented)
    color?: string;
    // (undocumented)
    opacity?: number;
}

// @public (undocumented)
export interface TLCameraConstraints {
    baseZoom: 'default' | 'fit-max-100' | 'fit-max' | 'fit-min-100' | 'fit-min' | 'fit-x-100' | 'fit-x' | 'fit-y-100' | 'fit-y';
    behavior: 'contain' | 'fixed' | 'free' | 'inside' | 'outside' | {
        x: 'contain' | 'fixed' | 'free' | 'inside' | 'outside';
        y: 'contain' | 'fixed' | 'free' | 'inside' | 'outside';
    };
    bounds: BoxModel;
    initialZoom: 'default' | 'fit-max-100' | 'fit-max' | 'fit-min-100' | 'fit-min' | 'fit-x-100' | 'fit-x' | 'fit-y-100' | 'fit-y';
    origin: VecLike;
    padding: VecLike;
}

// @public (undocumented)
export interface TLCameraMoveOptions {
    animation?: {
        easing?(t: number): number;
        duration?: number;
    };
    force?: boolean;
    immediate?: boolean;
    reset?: boolean;
}

// @public (undocumented)
export interface TLCameraOptions {
    constraints?: TLCameraConstraints;
    isLocked: boolean;
    panSpeed: number;
    wheelBehavior: 'none' | 'pan' | 'zoom';
    zoomSpeed: number;
    zoomSteps: number[];
}

// @public (undocumented)
export type TLCancelEvent = (info: TLCancelEventInfo) => void;

// @public (undocumented)
export interface TLCancelEventInfo {
    // (undocumented)
    name: 'cancel';
    // (undocumented)
    type: 'misc';
}

// @public (undocumented)
export interface TLCanvasComponentProps {
    // (undocumented)
    className?: string;
}

// @public (undocumented)
export type TLClickEvent = (info: TLClickEventInfo) => void;

// @public (undocumented)
export type TLClickEventInfo = TLBaseEventInfo & {
    button: number;
    name: TLCLickEventName;
    phase: 'down' | 'settle' | 'up';
    point: VecLike;
    pointerId: number;
    type: 'click';
} & TLPointerEventTarget;

// @public (undocumented)
export type TLCLickEventName = 'double_click' | 'quadruple_click' | 'triple_click';

// @public (undocumented)
export type TLClickState = 'idle' | 'overflow' | 'pendingDouble' | 'pendingOverflow' | 'pendingQuadruple' | 'pendingTriple';

// @public (undocumented)
export interface TLCollaboratorHintProps {
    // (undocumented)
    className?: string;
    // (undocumented)
    color: string;
    // (undocumented)
    opacity?: number;
    // (undocumented)
    point: VecModel;
    // (undocumented)
    viewport: Box;
    // (undocumented)
    zoom: number;
}

// @public (undocumented)
export type TLCompleteEvent = (info: TLCompleteEventInfo) => void;

// @public (undocumented)
export interface TLCompleteEventInfo {
    // (undocumented)
    name: 'complete';
    // (undocumented)
    type: 'misc';
}

// @public (undocumented)
export interface TLContent {
    // (undocumented)
    assets: TLAsset[];
    // (undocumented)
    bindings: TLBinding[] | undefined;
    // (undocumented)
    rootShapeIds: TLShapeId[];
    // (undocumented)
    schema: SerializedSchema;
    // (undocumented)
    shapes: TLShape[];
}

// @public (undocumented)
export interface TLCursorProps {
    // (undocumented)
    chatMessage: string;
    // (undocumented)
    className?: string;
    // (undocumented)
    color?: string;
    // (undocumented)
    name: null | string;
    // (undocumented)
    point: null | VecModel;
    // (undocumented)
    zoom: number;
}

// @public (undocumented)
export type TLDeepLink = {
    bounds: BoxModel;
    pageId?: TLPageId;
    type: 'viewport';
} | {
    pageId: TLPageId;
    type: 'page';
} | {
    shapeIds: TLShapeId[];
    type: 'shapes';
};

// @public (undocumented)
export interface TLDeepLinkOptions {
    debounceMs?: number;
    getTarget?(editor: Editor): TLDeepLink;
    getUrl?(editor: Editor): string | URL;
    onChange?(url: URL, editor: Editor): void;
    param?: string;
}

// @public (undocumented)
export const TldrawEditor: React_2.NamedExoticComponent<TldrawEditorProps>;

// @public
export interface TldrawEditorBaseProps {
    autoFocus?: boolean;
    bindingUtils?: readonly TLAnyBindingUtilConstructor[];
    cameraOptions?: Partial<TLCameraOptions>;
    children?: ReactNode;
    className?: string;
    components?: TLEditorComponents;
    deepLinks?: TLDeepLinkOptions | true;
    inferDarkMode?: boolean;
    initialState?: string;
    isShapeHidden?(shape: TLShape, editor: Editor): boolean;
    licenseKey?: string;
    onMount?: TLOnMountHandler;
    options?: Partial<TldrawOptions>;
    shapeUtils?: readonly TLAnyShapeUtilConstructor[];
    tools?: readonly TLStateNodeConstructor[];
    user?: TLUser;
}

// @public
export type TldrawEditorProps = TldrawEditorBaseProps & TldrawEditorStoreProps;

// @public (undocumented)
export type TldrawEditorStoreProps = TldrawEditorWithoutStoreProps | TldrawEditorWithStoreProps;

// @public
export interface TldrawEditorWithoutStoreProps extends TLStoreBaseOptions {
    migrations?: readonly MigrationSequence[];
    persistenceKey?: string;
    // (undocumented)
    sessionId?: string;
    snapshot?: TLEditorSnapshot | TLStoreSnapshot;
    // (undocumented)
    store?: undefined;
}

// @public
export interface TldrawEditorWithStoreProps {
    store: TLStore | TLStoreWithStatus;
}

// @public
export interface TldrawOptions {
    // (undocumented)
    readonly actionShortcutsLocation: 'menu' | 'swap' | 'toolbar';
    // (undocumented)
    readonly adjacentShapeMargin: number;
    // (undocumented)
    readonly animationMediumMs: number;
    // (undocumented)
    readonly cameraMovingTimeoutMs: number;
    // (undocumented)
    readonly cameraSlideFriction: number;
    // (undocumented)
    readonly coarseDragDistanceSquared: number;
    // (undocumented)
    readonly coarseHandleRadius: number;
    // (undocumented)
    readonly coarsePointerWidth: number;
    // (undocumented)
    readonly collaboratorCheckIntervalMs: number;
    // (undocumented)
    readonly collaboratorIdleTimeoutMs: number;
    // (undocumented)
    readonly collaboratorInactiveTimeoutMs: number;
    // (undocumented)
    readonly createTextOnCanvasDoubleClick: boolean;
    // (undocumented)
    readonly defaultSvgPadding: number;
    // (undocumented)
    readonly doubleClickDurationMs: number;
    // (undocumented)
    readonly dragDistanceSquared: number;
    // (undocumented)
    readonly edgeScrollDelay: number;
    // (undocumented)
    readonly edgeScrollDistance: number;
    // (undocumented)
    readonly edgeScrollEaseDuration: number;
    // (undocumented)
    readonly edgeScrollSpeed: number;
    readonly exportProvider: ComponentType<{
        children: React.ReactNode;
    }>;
    // (undocumented)
    readonly flattenImageBoundsExpand: number;
    // (undocumented)
    readonly flattenImageBoundsPadding: number;
    // (undocumented)
    readonly followChaseViewportSnap: number;
    // (undocumented)
    readonly gridSteps: readonly {
        readonly mid: number;
        readonly min: number;
        readonly step: number;
    }[];
    // (undocumented)
    readonly handleRadius: number;
    // (undocumented)
    readonly hitTestMargin: number;
    // (undocumented)
    readonly laserDelayMs: number;
    // (undocumented)
    readonly longPressDurationMs: number;
    // (undocumented)
    readonly maxExportDelayMs: number;
    // (undocumented)
    readonly maxFilesAtOnce: number;
    // (undocumented)
    readonly maxPages: number;
    // (undocumented)
    readonly maxPointsPerDrawShape: number;
    // (undocumented)
    readonly maxShapesPerPage: number;
    // (undocumented)
    readonly multiClickDurationMs: number;
    readonly temporaryAssetPreviewLifetimeMs: number;
    // (undocumented)
    readonly textShadowLod: number;
}

// @public (undocumented)
export interface TLEditorComponents {
    // (undocumented)
    Background?: ComponentType | null;
    // (undocumented)
    Brush?: ComponentType<TLBrushProps> | null;
    // (undocumented)
    Canvas?: ComponentType<TLCanvasComponentProps> | null;
    // (undocumented)
    CollaboratorBrush?: ComponentType<TLBrushProps> | null;
    // (undocumented)
    CollaboratorCursor?: ComponentType<TLCursorProps> | null;
    // (undocumented)
    CollaboratorHint?: ComponentType<TLCollaboratorHintProps> | null;
    // (undocumented)
    CollaboratorScribble?: ComponentType<TLScribbleProps> | null;
    // (undocumented)
    CollaboratorShapeIndicator?: ComponentType<TLShapeIndicatorProps> | null;
    // (undocumented)
    Cursor?: ComponentType<TLCursorProps> | null;
    // (undocumented)
    ErrorFallback?: TLErrorFallbackComponent;
    // (undocumented)
    Grid?: ComponentType<TLGridProps> | null;
    // (undocumented)
    Handle?: ComponentType<TLHandleProps> | null;
    // (undocumented)
    Handles?: ComponentType<TLHandlesProps> | null;
    // (undocumented)
    InFrontOfTheCanvas?: ComponentType | null;
    // (undocumented)
    LoadingScreen?: ComponentType | null;
    // (undocumented)
    OnTheCanvas?: ComponentType | null;
    // (undocumented)
    Scribble?: ComponentType<TLScribbleProps> | null;
    // (undocumented)
    SelectionBackground?: ComponentType<TLSelectionBackgroundProps> | null;
    // (undocumented)
    SelectionForeground?: ComponentType<TLSelectionForegroundProps> | null;
    // (undocumented)
    ShapeErrorFallback?: TLShapeErrorFallbackComponent;
    // (undocumented)
    ShapeIndicator?: ComponentType<TLShapeIndicatorProps> | null;
    // (undocumented)
    ShapeIndicatorErrorFallback?: TLShapeIndicatorErrorFallbackComponent;
    // (undocumented)
    ShapeIndicators?: ComponentType | null;
    // (undocumented)
    SnapIndicator?: ComponentType<TLSnapIndicatorProps> | null;
    // (undocumented)
    Spinner?: ComponentType | null;
    // (undocumented)
    SvgDefs?: ComponentType | null;
    // (undocumented)
    ZoomBrush?: ComponentType<TLBrushProps> | null;
}

// @public (undocumented)
export interface TLEditorOptions {
    autoFocus?: boolean;
    bindingUtils: readonly TLAnyBindingUtilConstructor[];
    cameraOptions?: Partial<TLCameraOptions>;
    getContainer(): HTMLElement;
    inferDarkMode?: boolean;
    initialState?: string;
    isShapeHidden?(shape: TLShape, editor: Editor): boolean;
    // (undocumented)
    licenseKey?: string;
    // (undocumented)
    options?: Partial<TldrawOptions>;
    shapeUtils: readonly TLAnyShapeUtilConstructor[];
    store: TLStore;
    tools: readonly TLStateNodeConstructor[];
    user?: TLUser;
}

// @public
export interface TLEditorRunOptions extends TLHistoryBatchOptions {
    // (undocumented)
    ignoreShapeLock?: boolean;
}

// @public (undocumented)
export interface TLEditorSnapshot {
    // (undocumented)
    document: TLStoreSnapshot;
    // (undocumented)
    session: TLSessionStateSnapshot;
}

// @public (undocumented)
export type TLEnterEventHandler = (info: any, from: string) => void;

// @public
export const tlenv: {
    isAndroid: boolean;
    isChromeForIos: boolean;
    isDarwin: boolean;
    isFirefox: boolean;
    isIos: boolean;
    isSafari: boolean;
    isWebview: boolean;
};

// @public (undocumented)
export interface TLErrorBoundaryProps {
    // (undocumented)
    children: React_3.ReactNode;
    // (undocumented)
    fallback: TLErrorFallbackComponent;
    // (undocumented)
    onError?: ((error: unknown) => void) | null;
}

// @public (undocumented)
export type TLErrorFallbackComponent = ComponentType<{
    editor?: Editor;
    error: unknown;
}>;

// @public (undocumented)
export interface TLEventHandlers {
    // (undocumented)
    onCancel: TLCancelEvent;
    // (undocumented)
    onComplete: TLCompleteEvent;
    // (undocumented)
    onDoubleClick: TLClickEvent;
    // (undocumented)
    onInterrupt: TLInterruptEvent;
    // (undocumented)
    onKeyDown: TLKeyboardEvent;
    // (undocumented)
    onKeyRepeat: TLKeyboardEvent;
    // (undocumented)
    onKeyUp: TLKeyboardEvent;
    // (undocumented)
    onLongPress: TLPointerEvent;
    // (undocumented)
    onMiddleClick: TLPointerEvent;
    // (undocumented)
    onPointerDown: TLPointerEvent;
    // (undocumented)
    onPointerMove: TLPointerEvent;
    // (undocumented)
    onPointerUp: TLPointerEvent;
    // (undocumented)
    onQuadrupleClick: TLClickEvent;
    // (undocumented)
    onRightClick: TLPointerEvent;
    // (undocumented)
    onTick: TLTickEvent;
    // (undocumented)
    onTripleClick: TLClickEvent;
    // (undocumented)
    onWheel: TLWheelEvent;
}

// @public (undocumented)
export type TLEventInfo = TLCancelEventInfo | TLClickEventInfo | TLCompleteEventInfo | TLInterruptEventInfo | TLKeyboardEventInfo | TLPinchEventInfo | TLPointerEventInfo | TLTickEventInfo | TLWheelEventInfo;

// @public (undocumented)
export interface TLEventMap {
    // (undocumented)
    'max-shapes': [{
        count: number;
        name: string;
        pageId: TLPageId;
    }];
    // (undocumented)
    'select-all-text': [{
        shapeId: TLShapeId;
    }];
    // (undocumented)
    'stop-camera-animation': [];
    // (undocumented)
    'stop-following': [];
    // (undocumented)
    change: [HistoryEntry<TLRecord>];
    // (undocumented)
    crash: [{
        error: unknown;
    }];
    // (undocumented)
    event: [TLEventInfo];
    // (undocumented)
    frame: [number];
    // (undocumented)
    mount: [];
    // (undocumented)
    tick: [number];
    // (undocumented)
    update: [];
}

// @public (undocumented)
export type TLEventMapHandler<T extends keyof TLEventMap> = (...args: TLEventMap[T]) => void;

// @public (undocumented)
export type TLEventName = 'cancel' | 'complete' | 'interrupt' | 'tick' | 'wheel' | TLCLickEventName | TLKeyboardEventName | TLPinchEventName | TLPointerEventName;

// @public (undocumented)
export type TLExitEventHandler = (info: any, to: string) => void;

// @public (undocumented)
export type TLExternalAssetContent = {
    assetId?: TLAssetId;
    file: File;
    type: 'file';
} | {
    type: 'url';
    url: string;
};

// @public (undocumented)
export type TLExternalContent<EmbedDefinition> = {
    point?: VecLike;
    sources?: TLExternalContentSource[];
} & ({
    embed: EmbedDefinition;
    type: 'embed';
    url: string;
} | {
    files: File[];
    ignoreParent: boolean;
    type: 'files';
} | {
    text: string;
    type: 'svg-text';
} | {
    text: string;
    type: 'text';
} | {
    type: 'url';
    url: string;
});

// @public (undocumented)
export type TLExternalContentSource = {
    data: any;
    type: 'excalidraw';
} | {
    data: null | string;
    reason: string;
    type: 'error';
} | {
    data: string;
    subtype: 'html' | 'json' | 'text' | 'url';
    type: 'text';
} | {
    data: TLContent;
    type: 'tldraw';
};

// @public (undocumented)
export interface TLGridProps {
    // (undocumented)
    size: number;
    // (undocumented)
    x: number;
    // (undocumented)
    y: number;
    // (undocumented)
    z: number;
}

// @public (undocumented)
export interface TLHandleDragInfo<T extends TLShape> {
    // (undocumented)
    handle: TLHandle;
    // (undocumented)
    initial?: T | undefined;
    // (undocumented)
    isPrecise: boolean;
}

// @public (undocumented)
export interface TLHandleProps {
    // (undocumented)
    className?: string;
    // (undocumented)
    handle: TLHandle;
    // (undocumented)
    isCoarse: boolean;
    // (undocumented)
    shapeId: TLShapeId;
    // (undocumented)
    zoom: number;
}

// @public (undocumented)
export interface TLHandlesProps {
    // (undocumented)
    children: ReactNode;
}

// @public (undocumented)
export interface TLHistoryBatchOptions {
    history?: 'ignore' | 'record-preserveRedoStack' | 'record';
}

// @public (undocumented)
export interface TLHistoryDiff<R extends UnknownRecord> {
    // (undocumented)
    diff: RecordsDiff<R>;
    // (undocumented)
    type: 'diff';
}

// @public (undocumented)
export type TLHistoryEntry<R extends UnknownRecord> = TLHistoryDiff<R> | TLHistoryMark;

// @public (undocumented)
export interface TLHistoryMark {
    // (undocumented)
    id: string;
    // (undocumented)
    type: 'stop';
}

// @public (undocumented)
export interface TLImageExportOptions {
    // (undocumented)
    background?: boolean;
    // (undocumented)
    bounds?: Box;
    // (undocumented)
    darkMode?: boolean;
    // (undocumented)
    padding?: number;
    // (undocumented)
    pixelRatio?: number;
    // (undocumented)
    preserveAspectRatio?: React.SVGAttributes<SVGSVGElement>['preserveAspectRatio'];
    // (undocumented)
    quality?: number;
    // (undocumented)
    scale?: number;
}

// @public (undocumented)
export type TLInterruptEvent = (info: TLInterruptEventInfo) => void;

// @public (undocumented)
export interface TLInterruptEventInfo {
    // (undocumented)
    name: 'interrupt';
    // (undocumented)
    type: 'misc';
}

// @public (undocumented)
export type TLKeyboardEvent = (info: TLKeyboardEventInfo) => void;

// @public (undocumented)
export type TLKeyboardEventInfo = TLBaseEventInfo & {
    code: string;
    key: string;
    name: TLKeyboardEventName;
    type: 'keyboard';
};

// @public (undocumented)
export type TLKeyboardEventName = 'key_down' | 'key_repeat' | 'key_up';

// @public
export interface TLLoadSessionStateSnapshotOptions {
    forceOverwrite?: boolean;
}

// @public
export interface TLLoadSnapshotOptions {
    forceOverwriteSessionState?: boolean;
}

// @public (undocumented)
export interface TLMeasureTextSpanOpts {
    // (undocumented)
    fontFamily: string;
    // (undocumented)
    fontSize: number;
    // (undocumented)
    fontStyle: string;
    // (undocumented)
    fontWeight: string;
    // (undocumented)
    height: number;
    // (undocumented)
    lineHeight: number;
    // (undocumented)
    overflow: 'truncate-clip' | 'truncate-ellipsis' | 'wrap';
    // (undocumented)
    padding: number;
    // (undocumented)
    textAlign: TLDefaultHorizontalAlignStyle;
    // (undocumented)
    width: number;
}

// @public (undocumented)
export const tlmenus: {
    _hiddenMenus: string[];
    menus: Atom<string[], unknown>;
    addOpenMenu(id: string, contextId?: string): void;
    clearOpenMenus(contextId?: string): void;
    deleteOpenMenu(id: string, contextId?: string): void;
    getOpenMenus(contextId?: string): string[];
    isMenuOpen(id: string, contextId?: string): boolean;
    hasOpenMenus(contextId: string): boolean;
    hasAnyOpenMenus(): boolean;
    hideOpenMenus(contextId?: string): void;
    showOpenMenus(contextId?: string): void;
    forContext(contextId: string): {
        addOpenMenu: (id: string) => void;
        clearOpenMenus: () => void;
        deleteOpenMenu: (id: string) => void;
        getOpenMenus: () => string[];
        hasAnyOpenMenus: () => boolean;
        hasOpenMenus: () => boolean;
        isMenuOpen: (id: string) => boolean;
    };
};

// @public
export type TLOnMountHandler = (editor: Editor) => (() => undefined | void) | undefined | void;

// @public (undocumented)
export type TLPinchEvent = (info: TLPinchEventInfo) => void;

// @public (undocumented)
export type TLPinchEventInfo = TLBaseEventInfo & {
    delta: VecModel;
    name: TLPinchEventName;
    point: VecModel;
    type: 'pinch';
};

// @public (undocumented)
export type TLPinchEventName = 'pinch_end' | 'pinch_start' | 'pinch';

// @public (undocumented)
export type TLPointerEvent = (info: TLPointerEventInfo) => void;

// @public (undocumented)
export type TLPointerEventInfo = TLBaseEventInfo & {
    button: number;
    isPen: boolean;
    name: TLPointerEventName;
    point: VecLike;
    pointerId: number;
    type: 'pointer';
} & TLPointerEventTarget;

// @public (undocumented)
export type TLPointerEventName = 'long_press' | 'middle_click' | 'pointer_down' | 'pointer_move' | 'pointer_up' | 'right_click';

// @public (undocumented)
export type TLPointerEventTarget = {
    handle: TLHandle;
    shape: TLShape;
    target: 'handle';
} | {
    handle?: TLSelectionHandle;
    shape?: undefined;
    target: 'selection';
} | {
    shape: TLShape;
    target: 'shape';
} | {
    shape?: undefined;
    target: 'canvas';
};

// @public (undocumented)
export interface TLRenderingShape {
    // (undocumented)
    backgroundIndex: number;
    // (undocumented)
    id: TLShapeId;
    // (undocumented)
    index: number;
    // (undocumented)
    opacity: number;
    // (undocumented)
    shape: TLShape;
    // (undocumented)
    util: ShapeUtil;
}

// @public (undocumented)
export type TLResizeHandle = SelectionCorner | SelectionEdge;

// @public
export interface TLResizeInfo<T extends TLShape> {
    // (undocumented)
    handle: TLResizeHandle;
    // (undocumented)
    initialBounds: Box;
    // (undocumented)
    initialShape: T;
    // (undocumented)
    mode: TLResizeMode;
    // (undocumented)
    newPoint: Vec;
    // (undocumented)
    scaleX: number;
    // (undocumented)
    scaleY: number;
}

// @public
export type TLResizeMode = 'resize_bounds' | 'scale_shape';

// @public (undocumented)
export type TLResizeShapeOptions = Partial<{
    dragHandle: TLResizeHandle;
    initialBounds: Box;
    initialPageTransform: MatLike;
    initialShape: TLShape;
    isAspectRatioLocked: boolean;
    mode: TLResizeMode;
    scaleAxisRotation: number;
    scaleOrigin: VecLike;
    skipStartAndEndCallbacks: boolean;
}>;

// @internal (undocumented)
export interface TLRotationSnapshot {
    // (undocumented)
    initialCursorAngle: number;
    // (undocumented)
    initialShapesRotation: number;
    // (undocumented)
    pageCenter: Vec;
    // (undocumented)
    shapeSnapshots: {
        initialPagePoint: Vec;
        shape: TLShape;
    }[];
}

// @public (undocumented)
export interface TLScribbleProps {
    // (undocumented)
    className?: string;
    // (undocumented)
    color?: string;
    // (undocumented)
    opacity?: number;
    // (undocumented)
    scribble: TLScribble;
    // (undocumented)
    zoom: number;
}

// @public (undocumented)
export interface TLSelectionBackgroundProps {
    // (undocumented)
    bounds: Box;
    // (undocumented)
    rotation: number;
}

// @public (undocumented)
export interface TLSelectionForegroundProps {
    // (undocumented)
    bounds: Box;
    // (undocumented)
    rotation: number;
}

// @public (undocumented)
export type TLSelectionHandle = RotateCorner | SelectionCorner | SelectionEdge;

// @public
export interface TLSessionStateSnapshot {
    // (undocumented)
    currentPageId?: TLPageId;
    // (undocumented)
    exportBackground?: boolean;
    // (undocumented)
    isDebugMode?: boolean;
    // (undocumented)
    isFocusMode?: boolean;
    // (undocumented)
    isGridMode?: boolean;
    // (undocumented)
    isToolLocked?: boolean;
    // (undocumented)
    pageStates?: Array<{
        camera?: {
            x: number;
            y: number;
            z: number;
        };
        focusedGroupId?: null | TLShapeId;
        pageId: TLPageId;
        selectedShapeIds?: TLShapeId[];
    }>;
    // (undocumented)
    version: number;
}

// @public (undocumented)
export type TLShapeErrorFallbackComponent = ComponentType<{
    error: any;
}>;

// @public (undocumented)
export type TLShapeIndicatorErrorFallbackComponent = ComponentType<{
    error: unknown;
}>;

// @public (undocumented)
export interface TLShapeIndicatorProps {
    // (undocumented)
    className?: string;
    // (undocumented)
    color?: string | undefined;
    // (undocumented)
    hidden?: boolean;
    // (undocumented)
    opacity?: number;
    // (undocumented)
    shapeId: TLShapeId;
}

// @public
export interface TLShapeUtilCanBindOpts<Shape extends TLUnknownShape = TLShape> {
    bindingType: string;
    fromShapeType: string;
    toShapeType: string;
}

// @public (undocumented)
export interface TLShapeUtilCanvasSvgDef {
    // (undocumented)
    component: React.ComponentType;
    // (undocumented)
    key: string;
}

// @public (undocumented)
export interface TLShapeUtilConstructor<T extends TLUnknownShape, U extends ShapeUtil<T> = ShapeUtil<T>> {
    // (undocumented)
    new (editor: Editor): U;
    // (undocumented)
    migrations?: LegacyMigrations | MigrationSequence | TLPropsMigrations;
    // (undocumented)
    props?: RecordProps<T>;
    // (undocumented)
    type: T['type'];
}

// @public (undocumented)
export interface TLSnapIndicatorProps {
    // (undocumented)
    className?: string;
    // (undocumented)
    line: SnapIndicator;
    // (undocumented)
    zoom: number;
}

// @public (undocumented)
export interface TLStateNodeConstructor {
    // (undocumented)
    new (editor: Editor, parent?: StateNode): StateNode;
    // (undocumented)
    children?(): TLStateNodeConstructor[];
    // (undocumented)
    id: string;
    // (undocumented)
    initial?: string;
    // (undocumented)
    isLockable: boolean;
}

// @public (undocumented)
export interface TLStoreBaseOptions {
    assets?: TLAssetStore;
    defaultName?: string;
    initialData?: SerializedStore<TLRecord>;
    onMount?(editor: Editor): (() => void) | void;
    snapshot?: Partial<TLEditorSnapshot> | TLStoreSnapshot;
}

// @public (undocumented)
export type TLStoreEventInfo = HistoryEntry<TLRecord>;

// @public (undocumented)
export type TLStoreOptions = TLStoreBaseOptions & {
    collaboration?: {
        mode?: null | Signal<'readonly' | 'readwrite'>;
        status: null | Signal<'offline' | 'online'>;
    };
    id?: string;
} & TLStoreSchemaOptions;

// @public (undocumented)
export type TLStoreSchemaOptions = {
    bindingUtils?: readonly TLAnyBindingUtilConstructor[];
    migrations?: readonly MigrationSequence[];
    shapeUtils?: readonly TLAnyShapeUtilConstructor[];
} | {
    schema?: StoreSchema<TLRecord, TLStoreProps>;
};

// @public (undocumented)
export type TLStoreWithStatus = {
    readonly connectionStatus: 'offline' | 'online';
    readonly error?: undefined;
    readonly status: 'synced-remote';
    readonly store: TLStore;
} | {
    readonly error: Error;
    readonly status: 'error';
    readonly store?: undefined;
} | {
    readonly error?: undefined;
    readonly status: 'loading';
    readonly store?: undefined;
} | {
    readonly error?: undefined;
    readonly status: 'not-synced';
    readonly store: TLStore;
} | {
    readonly error?: undefined;
    readonly status: 'synced-local';
    readonly store: TLStore;
};

// @public @deprecated (undocumented)
export type TLSvgOptions = TLImageExportOptions;

// @public (undocumented)
export type TLTickEvent = (info: TLTickEventInfo) => void;

// @public (undocumented)
export interface TLTickEventInfo {
    // (undocumented)
    elapsed: number;
    // (undocumented)
    name: 'tick';
    // (undocumented)
    type: 'misc';
}

// @public
export const tltime: Timers;

// @public (undocumented)
export interface TLUser {
    // (undocumented)
    readonly setUserPreferences: (userPreferences: TLUserPreferences) => void;
    // (undocumented)
    readonly userPreferences: Signal<TLUserPreferences>;
}

// @public
export interface TLUserPreferences {
    // (undocumented)
    animationSpeed?: null | number;
    // (undocumented)
    color?: null | string;
    // (undocumented)
    colorScheme?: 'dark' | 'light' | 'system';
    // (undocumented)
    edgeScrollSpeed?: null | number;
    // (undocumented)
    id: string;
    // (undocumented)
    isDynamicSizeMode?: boolean | null;
    // (undocumented)
    isPasteAtCursorMode?: boolean | null;
    // (undocumented)
    isSnapMode?: boolean | null;
    // (undocumented)
    isWrapMode?: boolean | null;
    // (undocumented)
    locale?: null | string;
    // (undocumented)
    name?: null | string;
}

// @public (undocumented)
export type TLWheelEvent = (info: TLWheelEventInfo) => void;

// @public (undocumented)
export type TLWheelEventInfo = TLBaseEventInfo & {
    delta: VecModel;
    name: 'wheel';
    point: VecModel;
    type: 'wheel';
};

// @public
export function toDomPrecision(v: number): number;

// @public (undocumented)
export function toFixed(v: number): number;

// @public
export function toPrecision(n: number, precision?: number): number;

export { track }

export { transact }

export { transaction }

// @public (undocumented)
export type UiEvent = TLCancelEvent | TLClickEvent | TLCompleteEvent | TLKeyboardEvent | TLPinchEvent | TLPointerEvent;

// @public (undocumented)
export type UiEventType = 'click' | 'keyboard' | 'pinch' | 'pointer' | 'wheel' | 'zoom';

// @public (undocumented)
export function uniq<T>(array: {
    readonly [n: number]: T;
    readonly length: number;
} | null | undefined): T[];

export { useAtom }

export { useComputed }

// @public (undocumented)
export function useContainer(): HTMLElement;

// @public (undocumented)
export function useContainerIfExists(): HTMLElement | null;

// @public
export function useDelaySvgExport(): () => void;

// @public (undocumented)
export function useEditor(): Editor;

// @public (undocumented)
export function useEditorComponents(): Required<TLEditorComponents>;

// @internal
export function useEvent<Args extends Array<unknown>, Result>(handler: (...args: Args) => Result): (...args: Args) => Result;

// @public (undocumented)
export function useGlobalMenuIsOpen(id: string, onChange?: (isOpen: boolean) => void, onEvent?: (id: string) => void): readonly [boolean, (isOpen: boolean) => void];

// @public (undocumented)
export function useIsCropping(shapeId: TLShapeId): boolean;

// @public (undocumented)
export function useIsDarkMode(): boolean;

// @public (undocumented)
export function useIsEditing(shapeId: TLShapeId): boolean;

// @internal (undocumented)
export function useLocalStore(options: {
    persistenceKey?: string;
    sessionId?: string;
    snapshot?: TLEditorSnapshot | TLStoreSnapshot;
} & TLStoreOptions): TLStoreWithStatus;

// @public (undocumented)
export function useMaybeEditor(): Editor | null;

// @internal (undocumented)
export function useOnMount(onMount?: TLOnMountHandler): void;

// @public (undocumented)
export function usePassThroughWheelEvents(ref: RefObject<HTMLElement>): void;

// @internal (undocumented)
export function usePeerIds(): string[];

// @internal (undocumented)
export function usePresence(userId: string): null | TLInstancePresence;

export { useQuickReactor }

// @internal (undocumented)
export const USER_COLORS: readonly ["#FF802B", "#EC5E41", "#F2555A", "#F04F88", "#E34BA9", "#BD54C6", "#9D5BD2", "#7B66DC", "#02B1CC", "#11B3A3", "#39B178", "#55B467"];

// @internal
export function useReactiveEvent<Args extends Array<unknown>, Result>(handler: (...args: Args) => Result): (...args: Args) => Result;

export { useReactor }

// @internal
export function useRefState<T>(initialValue: T): [T, Dispatch<SetStateAction<T>>];

// @public (undocumented)
export class UserPreferencesManager {
    constructor(user: TLUser, inferDarkMode: boolean);
    // (undocumented)
    disposables: Set<() => void>;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    getAnimationSpeed(): number;
    // (undocumented)
    getColor(): string;
    getEdgeScrollSpeed(): number;
    // (undocumented)
    getId(): string;
    // (undocumented)
    getIsDarkMode(): boolean;
    // (undocumented)
    getIsDynamicResizeMode(): boolean;
    // (undocumented)
    getIsPasteAtCursorMode(): boolean;
    // (undocumented)
    getIsSnapMode(): boolean;
    // (undocumented)
    getIsWrapMode(): boolean;
    // (undocumented)
    getLocale(): string;
    // (undocumented)
    getName(): string;
    // (undocumented)
    getUserPreferences(): {
        animationSpeed: number;
        color: string;
        colorScheme: "dark" | "light" | "system" | undefined;
        id: string;
        isDarkMode: boolean;
        isDynamicResizeMode: boolean;
        isSnapMode: boolean;
        isWrapMode: boolean;
        locale: string;
        name: string;
    };
    // (undocumented)
    systemColorScheme: Atom<"dark" | "light", unknown>;
    // (undocumented)
    updateUserPreferences(userPreferences: Partial<TLUserPreferences>): void;
}

// @public (undocumented)
export const userTypeValidator: T.Validator<TLUserPreferences>;

// @public (undocumented)
export function useSelectionEvents(handle: TLSelectionHandle): {
    onPointerDown: PointerEventHandler<Element>;
    onPointerMove: (e: React.PointerEvent) => void;
    onPointerUp: PointerEventHandler<Element>;
};

// @internal (undocumented)
export function useShallowArrayIdentity<T extends null | readonly any[] | undefined>(arr: T): T;

// @internal (undocumented)
export function useShallowObjectIdentity<T extends null | object | undefined>(obj: T): T;

// @public
export function useSharedSafeId(id: string): SafeId;

export { useStateTracking }

// @public
export function useSvgExportContext(): null | SvgExportContext;

// @public (undocumented)
export function useTldrawUser(opts: {
    setUserPreferences?: (userPreferences: TLUserPreferences) => void;
    userPreferences?: Signal<TLUserPreferences> | TLUserPreferences;
}): TLUser;

// @public (undocumented)
export function useTLSchemaFromUtils(opts: TLStoreSchemaOptions): StoreSchema<TLRecord, TLStoreProps>;

// @public (undocumented)
export function useTLStore(opts: TLStoreOptions): TLStore;

// @public (undocumented)
export function useTransform(ref: React.RefObject<HTMLElement | SVGElement>, x?: number, y?: number, scale?: number, rotate?: number, additionalOffset?: VecLike): void;

// @public
export function useUniqueSafeId(suffix?: string): SafeId;

export { useValue }

// @internal (undocumented)
export interface ValidLicenseKeyResult {
    // (undocumented)
    expiryDate: Date;
    // (undocumented)
    isAnnualLicense: boolean;
    // (undocumented)
    isAnnualLicenseExpired: boolean;
    // (undocumented)
    isDevelopment: boolean;
    // (undocumented)
    isDomainValid: boolean;
    // (undocumented)
    isInternalLicense: boolean;
    // (undocumented)
    isLicensedWithWatermark: boolean;
    // (undocumented)
    isLicenseParseable: true;
    // (undocumented)
    isPerpetualLicense: boolean;
    // (undocumented)
    isPerpetualLicenseExpired: boolean;
    // (undocumented)
    license: LicenseInfo;
}

// @public (undocumented)
export class Vec {
    constructor(x?: number, y?: number, z?: number);
    // (undocumented)
    static Abs(A: VecLike): Vec;
    // (undocumented)
    abs(): this;
    // (undocumented)
    static Add(A: VecLike, B: VecLike): Vec;
    // (undocumented)
    add(V: VecLike): this;
    // (undocumented)
    static AddScalar(A: VecLike, n: number): Vec;
    // (undocumented)
    addScalar(n: number): this;
    // (undocumented)
    static AddXY(A: VecLike, x: number, y: number): Vec;
    // (undocumented)
    addXY(x: number, y: number): this;
    // (undocumented)
    static Angle(A: VecLike, B: VecLike): number;
    // (undocumented)
    angle(B: VecLike): number;
    // (undocumented)
    static Average(arr: VecLike[]): Vec;
    // (undocumented)
    static Cast(A: VecLike): Vec;
    // (undocumented)
    static Clamp(A: Vec, min: number, max?: number): Vec;
    // (undocumented)
    clamp(min: number, max?: number): this;
    // (undocumented)
    static Clockwise(A: VecLike, B: VecLike, C: VecLike): boolean;
    // (undocumented)
    clone(): Vec;
    static Cpr(A: VecLike, B: VecLike): number;
    // (undocumented)
    cpr(V: VecLike): number;
    // (undocumented)
    static Cross(A: VecLike, V: VecLike): Vec;
    // (undocumented)
    cross(V: VecLike): this;
    // (undocumented)
    static Dist(A: VecLike, B: VecLike): number;
    // (undocumented)
    dist(V: VecLike): number;
    // (undocumented)
    static Dist2(A: VecLike, B: VecLike): number;
    // (undocumented)
    static DistanceToLineSegment(A: VecLike, B: VecLike, P: VecLike, clamp?: boolean): number;
    // (undocumented)
    distanceToLineSegment(A: VecLike, B: VecLike): number;
    // (undocumented)
    static DistanceToLineThroughPoint(A: VecLike, u: VecLike, P: VecLike): number;
    // (undocumented)
    static DistMin(A: VecLike, B: VecLike, n: number): boolean;
    // (undocumented)
    static Div(A: VecLike, t: number): Vec;
    // (undocumented)
    div(t: number): this;
    // (undocumented)
    static DivV(A: VecLike, B: VecLike): Vec;
    // (undocumented)
    divV(V: VecLike): this;
    static Dpr(A: VecLike, B: VecLike): number;
    // (undocumented)
    dpr(V: VecLike): number;
    // (undocumented)
    static Equals(A: VecLike, B: VecLike): boolean;
    // (undocumented)
    equals(B: VecLike): boolean;
    // (undocumented)
    static EqualsXY(A: VecLike, x: number, y: number): boolean;
    // (undocumented)
    equalsXY(x: number, y: number): boolean;
    // (undocumented)
    static From({ x, y, z }: VecModel): Vec;
    // (undocumented)
    static FromAngle(r: number, length?: number): Vec;
    // (undocumented)
    static FromArray(v: number[]): Vec;
    // (undocumented)
    static IsNaN(A: VecLike): boolean;
    // (undocumented)
    static Len(A: VecLike): number;
    // (undocumented)
    len(): number;
    // (undocumented)
    static Len2(A: VecLike): number;
    // (undocumented)
    len2(): number;
    static Lrp(A: VecLike, B: VecLike, t: number): Vec;
    // (undocumented)
    lrp(B: VecLike, t: number): Vec;
    // (undocumented)
    static Max(A: VecLike, B: VecLike): Vec;
    // (undocumented)
    static Med(A: VecLike, B: VecLike): Vec;
    // (undocumented)
    static Min(A: VecLike, B: VecLike): Vec;
    // (undocumented)
    static Mul(A: VecLike, t: number): Vec;
    // (undocumented)
    mul(t: number): this;
    // (undocumented)
    static MulV(A: VecLike, B: VecLike): Vec;
    // (undocumented)
    mulV(V: VecLike): this;
    // (undocumented)
    static NearestPointOnLineSegment(A: VecLike, B: VecLike, P: VecLike, clamp?: boolean): Vec;
    static NearestPointOnLineThroughPoint(A: VecLike, u: VecLike, P: VecLike): Vec;
    // (undocumented)
    static Neg(A: VecLike): Vec;
    // (undocumented)
    neg(): this;
    // (undocumented)
    norm(): this;
    // (undocumented)
    static Nudge(A: VecLike, B: VecLike, distance: number): Vec;
    // (undocumented)
    nudge(B: VecLike, distance: number): this;
    static Per(A: VecLike): Vec;
    // (undocumented)
    per(): this;
    static PointsBetween(A: VecModel, B: VecModel, steps?: number): Vec[];
    // (undocumented)
    get pressure(): number;
    static Pry(A: VecLike, B: VecLike): number;
    // (undocumented)
    pry(V: VecLike): number;
    // (undocumented)
    static Rescale(A: VecLike, n: number): Vec;
    // (undocumented)
    static Rot(A: VecLike, r?: number): Vec;
    // (undocumented)
    rot(r: number): this;
    // (undocumented)
    static RotWith(A: VecLike, C: VecLike, r: number): Vec;
    // (undocumented)
    rotWith(C: VecLike, r: number): this;
    // (undocumented)
    static ScaleWithOrigin(A: VecLike, scale: number, origin: VecLike): Vec;
    // (undocumented)
    set(x?: number, y?: number, z?: number): this;
    // (undocumented)
    setTo({ x, y, z }: VecLike): this;
    // (undocumented)
    static Slope(A: VecLike, B: VecLike): number;
    // (undocumented)
    slope(B: VecLike): number;
    // (undocumented)
    static Snap(A: VecLike, step?: number): Vec;
    // (undocumented)
    static SnapToGrid(A: VecLike, gridSize?: number): Vec;
    // (undocumented)
    snapToGrid(gridSize: number): this;
    // (undocumented)
    static Sub(A: VecLike, B: VecLike): Vec;
    // (undocumented)
    sub(V: VecLike): this;
    // (undocumented)
    static SubScalar(A: VecLike, n: number): Vec;
    // (undocumented)
    subScalar(n: number): this;
    // (undocumented)
    static SubXY(A: VecLike, x: number, y: number): Vec;
    // (undocumented)
    subXY(x: number, y: number): this;
    // (undocumented)
    static Tan(A: VecLike, B: VecLike): Vec;
    // (undocumented)
    tan(V: VecLike): Vec;
    // (undocumented)
    static ToAngle(A: VecLike): number;
    // (undocumented)
    toAngle(): number;
    // (undocumented)
    static ToArray(A: VecLike): number[];
    // (undocumented)
    toArray(): number[];
    // (undocumented)
    static ToCss(A: VecLike): string;
    // (undocumented)
    static ToFixed(A: VecLike): Vec;
    // (undocumented)
    toFixed(): Vec;
    // (undocumented)
    static ToInt(A: VecLike): Vec;
    // (undocumented)
    static ToJson(A: VecLike): {
        x: number;
        y: number;
        z: number | undefined;
    };
    // (undocumented)
    toJson(): VecModel;
    // (undocumented)
    static ToString(A: VecLike): string;
    // (undocumented)
    toString(): string;
    static Uni(A: VecLike): Vec;
    // (undocumented)
    uni(): Vec;
    // (undocumented)
    x: number;
    // (undocumented)
    y: number;
    // (undocumented)
    z: number;
}

// @public (undocumented)
export type VecLike = Vec | VecModel;

export { whyAmIRunning }


export * from "@tldraw/store";
export * from "@tldraw/tlschema";
export * from "@tldraw/utils";
export * from "@tldraw/validate";

// (No @packageDocumentation comment for this package)

```
