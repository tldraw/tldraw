## API Report File for "@tldraw/sync-core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Atom } from '@tldraw/state';
import { AtomMap } from '@tldraw/store';
import { DebouncedFunc } from 'lodash';
import { Emitter } from 'nanoevents';
import { RecordsDiff } from '@tldraw/store';
import { RecordType } from '@tldraw/store';
import { SerializedSchema } from '@tldraw/store';
import { SerializedSchemaV2 } from '@tldraw/store';
import { Signal } from '@tldraw/state';
import { Store } from '@tldraw/store';
import { StoreSchema } from '@tldraw/store';
import { StoreSnapshot } from '@tldraw/store';
import { SynchronousStorage } from '@tldraw/store';
import { TLDocument } from '@tldraw/tlschema';
import { TLPage } from '@tldraw/tlschema';
import { TLRecord } from '@tldraw/tlschema';
import { TLStoreSnapshot } from '@tldraw/tlschema';
import { TLStoreSnapshot as TLStoreSnapshot_2 } from 'tldraw';
import { UnknownRecord } from '@tldraw/store';

// @internal
export type AppendOp = [type: typeof ValueOpType.Append, value: string | unknown[], offset: number];

// @internal
export function applyObjectDiff<T extends object>(object: T, objectDiff: ObjectDiff): T;

// @internal
export function chunk(msg: string, maxSafeMessageSize?: number): string[];

// @internal
export class ClientWebSocketAdapter implements TLPersistentClientSocket<TLSocketClientSentEvent<TLRecord>, TLSocketServerSentEvent<TLRecord>> {
    constructor(getUri: () => Promise<string> | string);
    close(): void;
    // (undocumented)
    _closeSocket(): void;
    get connectionStatus(): TLPersistentClientSocketStatus;
    // (undocumented)
    _connectionStatus: Atom<'initial' | TLPersistentClientSocketStatus>;
    // (undocumented)
    isDisposed: boolean;
    onReceiveMessage(cb: (val: TLSocketServerSentEvent<TLRecord>) => void): () => void;
    onStatusChange(cb: TLSocketStatusListener): () => void;
    // (undocumented)
    readonly _reconnectManager: ReconnectManager;
    restart(): void;
    sendMessage(msg: TLSocketClientSentEvent<TLRecord>): void;
    // (undocumented)
    _setNewSocket(ws: WebSocket): void;
    // (undocumented)
    _ws: null | WebSocket;
}

// @public
export const DEFAULT_INITIAL_SNAPSHOT: {
    documentClock: number;
    documents: ({
        lastChangedClock: number;
        state: TLDocument;
    } | {
        lastChangedClock: number;
        state: TLPage;
    })[];
    schema: SerializedSchemaV2;
    tombstoneHistoryStartsAtClock: number;
};

// @internal
export type DeleteOp = [type: typeof ValueOpType.Delete];

// @internal
export function diffRecord(prev: object, next: object, legacyAppendMode?: boolean): null | ObjectDiff;

// @public
export class DurableObjectSqliteSyncWrapper implements TLSyncSqliteWrapper {
    constructor(storage: {
        sql: {
            exec(sql: string, ...bindings: unknown[]): Iterable<any> & {
                toArray(): any[];
            };
        };
        transactionSync(callback: () => any): any;
    }, config?: TLSyncSqliteWrapperConfig | undefined);
    // (undocumented)
    config?: TLSyncSqliteWrapperConfig | undefined;
    // (undocumented)
    exec(sql: string): void;
    // (undocumented)
    prepare<TResult extends TLSqliteRow | void = void, TParams extends TLSqliteInputValue[] = []>(sql: string): TLSyncSqliteStatement<TResult, TParams>;
    // (undocumented)
    transaction<T>(callback: () => T): T;
}

// @internal
export function getNetworkDiff<R extends UnknownRecord>(diff: RecordsDiff<R>): NetworkDiff<R> | null;

// @internal
export function getTlsyncProtocolVersion(): number;

// @public
export class InMemorySyncStorage<R extends UnknownRecord> implements TLSyncStorage<R> {
    constructor({ snapshot, onChange, }?: {
        onChange?(arg: TLSyncStorageOnChangeCallbackProps): unknown;
        snapshot?: RoomSnapshot;
    });
    // @internal (undocumented)
    documentClock: Atom<number>;
    // @internal (undocumented)
    documents: AtomMap<string, {
        lastChangedClock: number;
        state: R;
    }>;
    // (undocumented)
    getClock(): number;
    // (undocumented)
    getSnapshot(): RoomSnapshot;
    // (undocumented)
    onChange(callback: (arg: TLSyncStorageOnChangeCallbackProps) => unknown): () => void;
    // @internal (undocumented)
    pruneTombstones: DebouncedFunc<() => void>;
    // @internal (undocumented)
    schema: Atom<SerializedSchema>;
    // @internal (undocumented)
    tombstoneHistoryStartsAtClock: Atom<number>;
    // @internal (undocumented)
    tombstones: AtomMap<string, number>;
    // (undocumented)
    transaction<T>(callback: TLSyncStorageTransactionCallback<R, T>, opts?: TLSyncStorageTransactionOptions): TLSyncStorageTransactionResult<T, R>;
}

// @public
export class JsonChunkAssembler {
    handleMessage(msg: string): {
        data: object;
        stringified: string;
    } | {
        error: Error;
    } | null;
    state: 'idle' | {
        chunksReceived: string[];
        totalChunks: number;
    };
}

// @public
export function loadSnapshotIntoStorage<R extends UnknownRecord>(txn: TLSyncStorageTransaction<R>, schema: StoreSchema<R, any>, snapshot: RoomSnapshot | TLStoreSnapshot_2): void;

// @internal (undocumented)
export interface MinimalDocStore<R extends UnknownRecord> {
    // (undocumented)
    delete(id: string): void;
    // (undocumented)
    get(id: string): undefined | UnknownRecord;
    // (undocumented)
    set(id: string, record: R): void;
}

// @internal
export interface NetworkDiff<R extends UnknownRecord> {
    // (undocumented)
    [id: string]: RecordOp<R>;
}

// @public
export class NodeSqliteWrapper implements TLSyncSqliteWrapper {
    constructor(db: SyncSqliteDatabase, config?: TLSyncSqliteWrapperConfig | undefined);
    // (undocumented)
    config?: TLSyncSqliteWrapperConfig | undefined;
    // (undocumented)
    exec(sql: string): void;
    // (undocumented)
    prepare<TResult extends TLSqliteRow | void = void, TParams extends TLSqliteInputValue[] = TLSqliteInputValue[]>(sql: string): TLSyncSqliteStatement<TResult, TParams>;
    // (undocumented)
    transaction<T>(callback: () => T): T;
}

// @internal
export interface ObjectDiff {
    // (undocumented)
    [k: string]: ValueOp;
}

// @public
export type OmitVoid<T, KS extends keyof T = keyof T> = {
    [K in KS extends any ? (void extends T[KS] ? never : KS) : never]: T[K];
};

// @internal
export type PatchOp = [type: typeof ValueOpType.Patch, diff: ObjectDiff];

// @internal
export interface PersistedRoomSnapshotForSupabase {
    // (undocumented)
    drawing: RoomSnapshot;
    // (undocumented)
    id: string;
    // (undocumented)
    slug: string;
}

// @internal (undocumented)
export class PresenceStore<R extends UnknownRecord> implements MinimalDocStore<R> {
    // (undocumented)
    delete(id: string): void;
    // (undocumented)
    get(id: string): undefined | UnknownRecord;
    // (undocumented)
    set(id: string, state: R): void;
    // (undocumented)
    values(): Generator<R, undefined, unknown>;
}

// @internal
export type PutOp = [type: typeof ValueOpType.Put, value: unknown];

// @internal
export class ReconnectManager {
    constructor(socketAdapter: ClientWebSocketAdapter, getUri: () => Promise<string> | string);
    close(): void;
    connected(): void;
    disconnected(): void;
    // (undocumented)
    intendedDelay: number;
    maybeReconnected(): void;
}

// @internal
export type RecordOp<R extends UnknownRecord> = [typeof RecordOpType.Patch, ObjectDiff] | [typeof RecordOpType.Put, R] | [typeof RecordOpType.Remove];

// @internal
export const RecordOpType: {
    readonly Patch: "patch";
    readonly Put: "put";
    readonly Remove: "remove";
};

// @internal
export type RecordOpType = (typeof RecordOpType)[keyof typeof RecordOpType];

// @internal
export type RoomSession<R extends UnknownRecord, Meta> = (RoomSessionBase<R, Meta> & {
    state: typeof RoomSessionState.AwaitingConnectMessage;
    sessionStartTime: number;
}) | (RoomSessionBase<R, Meta> & {
    state: typeof RoomSessionState.AwaitingRemoval;
    cancellationTime: number;
}) | (RoomSessionBase<R, Meta> & {
    state: typeof RoomSessionState.Connected;
    outstandingDataMessages: TLSocketServerSentDataEvent<R>[];
    serializedSchema: SerializedSchema;
    debounceTimer: null | ReturnType<typeof setTimeout>;
    lastInteractionTime: number;
    requiresDownMigrations: boolean;
});

// @internal
export interface RoomSessionBase<R extends UnknownRecord, Meta> {
    isReadonly: boolean;
    meta: Meta;
    presenceId: null | string;
    requiresLegacyRejection: boolean;
    sessionId: string;
    socket: TLRoomSocket<R>;
    supportsStringAppend: boolean;
}

// @internal
export const RoomSessionState: {
    readonly AwaitingRemoval: "awaiting-removal";
    readonly Connected: "connected";
    readonly AwaitingConnectMessage: "awaiting-connect-message";
};

// @internal
export type RoomSessionState = (typeof RoomSessionState)[keyof typeof RoomSessionState];

// @public
export interface RoomSnapshot {
    clock?: number;
    documentClock?: number;
    documents: Array<{
        lastChangedClock: number;
        state: UnknownRecord;
    }>;
    schema?: SerializedSchema;
    tombstoneHistoryStartsAtClock?: number;
    tombstones?: Record<string, number>;
}

// @public @deprecated
export interface RoomStoreMethods<R extends UnknownRecord = UnknownRecord> {
    delete(recordOrId: R | string): void;
    get(id: string): null | R;
    getAll(): R[];
    put(record: R): void;
}

// @public
export class SQLiteSyncStorage<R extends UnknownRecord> implements TLSyncStorage<R> {
    constructor({ sql, snapshot, onChange, }: {
        onChange?(arg: TLSyncStorageOnChangeCallbackProps): unknown;
        snapshot?: RoomSnapshot | StoreSnapshot<R>;
        sql: TLSyncSqliteWrapper;
    });
    // (undocumented)
    getClock(): number;
    static getDocumentClock(storage: TLSyncSqliteWrapper): null | number;
    // @internal (undocumented)
    _getSchema(): SerializedSchema;
    // (undocumented)
    getSnapshot(): RoomSnapshot;
    // @internal (undocumented)
    _getTombstoneHistoryStartsAtClock(): number;
    static hasBeenInitialized(storage: TLSyncSqliteWrapper): boolean;
    // (undocumented)
    onChange(callback: (arg: TLSyncStorageOnChangeCallbackProps) => void): () => void;
    // @internal (undocumented)
    pruneTombstones: DebouncedFunc<() => void>;
    // @internal (undocumented)
    _setSchema(schema: SerializedSchema): void;
    // (undocumented)
    transaction<T>(callback: TLSyncStorageTransactionCallback<R, T>, opts?: TLSyncStorageTransactionOptions): TLSyncStorageTransactionResult<T, R>;
}

// @public
export type SubscribingFn<T> = (cb: (val: T) => void) => () => void;

// @public
export interface SyncSqliteDatabase {
    exec(sql: string): void;
    prepare(sql: string): {
        all(...params: unknown[]): unknown[];
        iterate(...params: unknown[]): IterableIterator<unknown>;
        run(...params: unknown[]): unknown;
    };
}

// @internal
export interface TLConnectRequest {
    // (undocumented)
    connectRequestId: string;
    // (undocumented)
    lastServerClock: number;
    // (undocumented)
    protocolVersion: number;
    // (undocumented)
    schema: SerializedSchema;
    // (undocumented)
    type: 'connect';
}

// @public
export type TLCustomMessageHandler = (this: null, data: any) => void;

// @internal @deprecated
export const TLIncompatibilityReason: {
    readonly ClientTooOld: "clientTooOld";
    readonly InvalidOperation: "invalidOperation";
    readonly InvalidRecord: "invalidRecord";
    readonly ServerTooOld: "serverTooOld";
};

// @internal @deprecated
export type TLIncompatibilityReason = (typeof TLIncompatibilityReason)[keyof typeof TLIncompatibilityReason];

// @public
export interface TLPersistentClientSocket<ClientSentMessage extends object = object, ServerSentMessage extends object = object> {
    close(): void;
    connectionStatus: 'error' | 'offline' | 'online';
    onReceiveMessage: SubscribingFn<ServerSentMessage>;
    onStatusChange: SubscribingFn<TLSocketStatusChangeEvent>;
    restart(): void;
    sendMessage(msg: ClientSentMessage): void;
}

// @internal
export type TLPersistentClientSocketStatus = 'error' | 'offline' | 'online';

// @internal
export interface TLPingRequest {
    // (undocumented)
    type: 'ping';
}

// @public
export type TLPresenceMode =
/** No presence sharing - client operates independently */
'full'
| 'solo'
/** Full presence sharing - cursors and selections visible to others */;

// @internal
export interface TLPushRequest<R extends UnknownRecord> {
    // (undocumented)
    clientClock: number;
    // (undocumented)
    diff?: NetworkDiff<R>;
    // (undocumented)
    presence?: [typeof RecordOpType.Patch, ObjectDiff] | [typeof RecordOpType.Put, R];
    // (undocumented)
    type: 'push';
}

// @public
export class TLRemoteSyncError extends Error {
    constructor(reason: string | TLSyncErrorCloseEventReason);
    // (undocumented)
    name: string;
    // (undocumented)
    readonly reason: string | TLSyncErrorCloseEventReason;
}

// @internal
export interface TLRoomSocket<R extends UnknownRecord> {
    close(code?: number, reason?: string): void;
    isOpen: boolean;
    sendMessage(msg: TLSocketServerSentEvent<R>): void;
}

// @internal
export type TLSocketClientSentEvent<R extends UnknownRecord> = TLConnectRequest | TLPingRequest | TLPushRequest<R>;

// @public
export class TLSocketRoom<R extends UnknownRecord = UnknownRecord, SessionMeta = void> {
    constructor(opts: TLSocketRoomOptions<R, SessionMeta>);
    close(): void;
    closeSession(sessionId: string, fatalReason?: string | TLSyncErrorCloseEventReason): void;
    getCurrentDocumentClock(): number;
    // @deprecated
    getCurrentSnapshot(): RoomSnapshot;
    getNumActiveSessions(): number;
    // @internal
    getPresenceRecords(): Record<string, UnknownRecord>;
    getRecord(id: string): R;
    getSessions(): Array<{
        isConnected: boolean;
        isReadonly: boolean;
        meta: SessionMeta;
        sessionId: string;
    }>;
    handleSocketClose(sessionId: string): void;
    handleSocketConnect(opts: {
        isReadonly?: boolean;
        sessionId: string;
        socket: WebSocketMinimal;
    } & (SessionMeta extends void ? object : {
        meta: SessionMeta;
    })): void;
    handleSocketError(sessionId: string): void;
    handleSocketMessage(sessionId: string, message: AllowSharedBufferSource | string): void;
    isClosed(): boolean;
    loadSnapshot(snapshot: RoomSnapshot | TLStoreSnapshot): void;
    // (undocumented)
    readonly log?: TLSyncLog;
    // (undocumented)
    readonly opts: TLSocketRoomOptions<R, SessionMeta>;
    sendCustomMessage(sessionId: string, data: any): void;
    // (undocumented)
    storage: TLSyncStorage<R>;
    // @deprecated
    updateStore(updater: (store: RoomStoreMethods<R>) => Promise<void> | void): Promise<void>;
}

// @public
export interface TLSocketRoomOptions<R extends UnknownRecord, SessionMeta> {
    // (undocumented)
    clientTimeout?: number;
    // @deprecated (undocumented)
    initialSnapshot?: RoomSnapshot | TLStoreSnapshot;
    // (undocumented)
    log?: TLSyncLog;
    // (undocumented)
    onAfterReceiveMessage?: (args: {
        message: TLSocketServerSentEvent<R>;
        meta: SessionMeta;
        sessionId: string;
        stringified: string;
    }) => void;
    // (undocumented)
    onBeforeSendMessage?: (args: {
        message: TLSocketServerSentEvent<R>;
        meta: SessionMeta;
        sessionId: string;
        stringified: string;
    }) => void;
    // @deprecated (undocumented)
    onDataChange?(): void;
    // @internal (undocumented)
    onPresenceChange?(): void;
    // (undocumented)
    onSessionRemoved?: (room: TLSocketRoom<R, SessionMeta>, args: {
        meta: SessionMeta;
        numSessionsRemaining: number;
        sessionId: string;
    }) => void;
    // (undocumented)
    schema?: StoreSchema<R, any>;
    // (undocumented)
    storage?: TLSyncStorage<R>;
}

// @internal
export type TLSocketServerSentDataEvent<R extends UnknownRecord> = {
    action: 'commit' | 'discard' | {
        rebaseWithDiff: NetworkDiff<R>;
    };
    clientClock: number;
    serverClock: number;
    type: 'push_result';
} | {
    diff: NetworkDiff<R>;
    serverClock: number;
    type: 'patch';
};

// @internal
export type TLSocketServerSentEvent<R extends UnknownRecord> = {
    connectRequestId: string;
    diff: NetworkDiff<R>;
    hydrationType: 'wipe_all' | 'wipe_presence';
    isReadonly: boolean;
    protocolVersion: number;
    schema: SerializedSchema;
    serverClock: number;
    type: 'connect';
} | {
    data: any;
    type: 'custom';
} | {
    data: TLSocketServerSentDataEvent<R>[];
    type: 'data';
} | {
    reason: TLIncompatibilityReason;
    type: 'incompatibility_error';
} | {
    type: 'pong';
} | TLSocketServerSentDataEvent<R>;

// @public
export type TLSocketStatusChangeEvent = {
    status: 'offline' | 'online';
} | {
    status: 'error';
    reason: string;
};

// @internal
export type TLSocketStatusListener = (params: TLSocketStatusChangeEvent) => void;

// @public
export type TLSqliteInputValue = bigint | null | number | string | Uint8Array;

// @public
export type TLSqliteOutputValue = bigint | null | number | string | Uint8Array;

// @public
export type TLSqliteRow = Record<string, TLSqliteOutputValue>;

// @public
export class TLSyncClient<R extends UnknownRecord, S extends Store<R> = Store<R>> {
    constructor(config: {
        didCancel?(): boolean;
        onAfterConnect?(self: TLSyncClient<R, S>, details: {
            isReadonly: boolean;
        }): void;
        onCustomMessageReceived?: TLCustomMessageHandler;
        onLoad(self: TLSyncClient<R, S>): void;
        onSyncError(reason: string): void;
        presence: Signal<null | R>;
        presenceMode?: Signal<TLPresenceMode>;
        socket: TLPersistentClientSocket<any, any>;
        store: S;
    });
    close(): void;
    // @internal (undocumented)
    isConnectedToRoom: boolean;
    // @internal (undocumented)
    latestConnectRequestId: null | string;
    // @internal (undocumented)
    readonly presenceMode: Signal<TLPresenceMode> | undefined;
    // @internal (undocumented)
    readonly presenceState: Signal<null | R> | undefined;
    // @internal (undocumented)
    readonly socket: TLPersistentClientSocket<TLSocketClientSentEvent<R>, TLSocketServerSentEvent<R>>;
    // @internal (undocumented)
    readonly store: S;
}

// @public
export const TLSyncErrorCloseEventCode: 4099;

// @public
export const TLSyncErrorCloseEventReason: {
    readonly RATE_LIMITED: "RATE_LIMITED";
    readonly CLIENT_TOO_OLD: "CLIENT_TOO_OLD";
    readonly INVALID_RECORD: "INVALID_RECORD";
    readonly ROOM_FULL: "ROOM_FULL";
    readonly NOT_FOUND: "NOT_FOUND";
    readonly SERVER_TOO_OLD: "SERVER_TOO_OLD";
    readonly UNKNOWN_ERROR: "UNKNOWN_ERROR";
    readonly NOT_AUTHENTICATED: "NOT_AUTHENTICATED";
    readonly FORBIDDEN: "FORBIDDEN";
};

// @public
export type TLSyncErrorCloseEventReason = (typeof TLSyncErrorCloseEventReason)[keyof typeof TLSyncErrorCloseEventReason];

// @public
export interface TLSyncForwardDiff<R extends UnknownRecord> {
    // (undocumented)
    deletes: string[];
    // (undocumented)
    puts: Record<string, [before: R, after: R] | R>;
}

// @public
export interface TLSyncLog {
    error?(...args: any[]): void;
    warn?(...args: any[]): void;
}

// @internal
export class TLSyncRoom<R extends UnknownRecord, SessionMeta> {
    constructor(opts: {
        log?: TLSyncLog;
        onPresenceChange?(): void;
        schema: StoreSchema<R, any>;
        storage: TLSyncStorage<R>;
    });
    close(): void;
    // (undocumented)
    readonly documentTypes: Set<string>;
    // (undocumented)
    readonly events: Emitter<    {
    room_became_empty(): void;
    session_removed(args: {
    meta: SessionMeta;
    sessionId: string;
    }): void;
    }>;
    // (undocumented)
    _flushDataMessages(sessionId: string): void;
    getCanEmitStringAppend(): boolean;
    handleClose(sessionId: string): void;
    handleMessage(sessionId: string, message: TLSocketClientSentEvent<R>): Promise<void>;
    handleNewSession(opts: {
        isReadonly: boolean;
        meta: SessionMeta;
        sessionId: string;
        socket: TLRoomSocket<R>;
    }): this;
    // (undocumented)
    readonly internalTxnId = "TLSyncRoom.txn";
    isClosed(): boolean;
    // (undocumented)
    readonly presenceStore: PresenceStore<R>;
    // (undocumented)
    readonly presenceType: null | RecordType<R, any>;
    // (undocumented)
    pruneSessions: () => void;
    rejectSession(sessionId: string, fatalReason?: string | TLSyncErrorCloseEventReason): void;
    // (undocumented)
    readonly schema: StoreSchema<R, any>;
    sendCustomMessage(sessionId: string, data: any): void;
    // (undocumented)
    readonly serializedSchema: SerializedSchema;
    // (undocumented)
    readonly sessions: Map<string, RoomSession<R, SessionMeta>>;
}

// @public
export interface TLSyncSqliteStatement<TResult extends TLSqliteRow | void, TParams extends TLSqliteInputValue[] = []> {
    all(...bindings: TParams): TResult[];
    iterate(...bindings: TParams): IterableIterator<TResult>;
    run(...bindings: TParams): void;
}

// @public
export interface TLSyncSqliteWrapper {
    readonly config?: TLSyncSqliteWrapperConfig;
    exec(sql: string): void;
    prepare<TResult extends TLSqliteRow | void, TParams extends TLSqliteInputValue[] = []>(sql: string): TLSyncSqliteStatement<TResult, TParams>;
    transaction<T>(callback: () => T): T;
}

// @public
export interface TLSyncSqliteWrapperConfig {
    tablePrefix?: string;
}

// @public
export interface TLSyncStorage<R extends UnknownRecord> {
    // (undocumented)
    getClock(): number;
    // (undocumented)
    getSnapshot?(): RoomSnapshot;
    // (undocumented)
    onChange(callback: (arg: TLSyncStorageOnChangeCallbackProps) => unknown): () => void;
    // (undocumented)
    transaction<T>(callback: TLSyncStorageTransactionCallback<R, T>, opts?: TLSyncStorageTransactionOptions): TLSyncStorageTransactionResult<T, R>;
}

// @public
export interface TLSyncStorageGetChangesSinceResult<R extends UnknownRecord> {
    diff: TLSyncForwardDiff<R>;
    wipeAll: boolean;
}

// @public
export interface TLSyncStorageOnChangeCallbackProps {
    // (undocumented)
    documentClock: number;
    id?: string;
}

// @public
export interface TLSyncStorageTransaction<R extends UnknownRecord> extends SynchronousStorage<R> {
    getChangesSince(sinceClock: number): TLSyncStorageGetChangesSinceResult<R> | undefined;
    getClock(): number;
}

// @public
export type TLSyncStorageTransactionCallback<R extends UnknownRecord, T> = (txn: TLSyncStorageTransaction<R>) => T extends Promise<any> ? {
    __error: 'Transaction callbacks cannot be async. Use synchronous operations only.';
} : T;

// @public
export interface TLSyncStorageTransactionOptions {
    emitChanges?: 'always' | 'when-different';
    id?: string;
}

// @public
export interface TLSyncStorageTransactionResult<T, R extends UnknownRecord = UnknownRecord> {
    changes?: TLSyncForwardDiff<R>;
    // (undocumented)
    didChange: boolean;
    // (undocumented)
    documentClock: number;
    // (undocumented)
    result: T;
}

// @internal
export type ValueOp = AppendOp | DeleteOp | PatchOp | PutOp;

// @internal
export const ValueOpType: {
    readonly Append: "append";
    readonly Delete: "delete";
    readonly Patch: "patch";
    readonly Put: "put";
};

// @internal
export type ValueOpType = (typeof ValueOpType)[keyof typeof ValueOpType];

// @public
export interface WebSocketMinimal {
    addEventListener?: (type: 'close' | 'error' | 'message', listener: (event: any) => void) => void;
    close: (code?: number, reason?: string) => void;
    readyState: number;
    removeEventListener?: (type: 'close' | 'error' | 'message', listener: (event: any) => void) => void;
    send: (data: string) => void;
}

// (No @packageDocumentation comment for this package)

```
