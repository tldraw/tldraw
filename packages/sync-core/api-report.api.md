## API Report File for "@tldraw/sync-core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Atom } from '@tldraw/state';
import { AtomMap } from '@tldraw/store';
import { Emitter } from 'nanoevents';
import { RecordsDiff } from '@tldraw/store';
import { RecordType } from '@tldraw/store';
import { Result } from '@tldraw/utils';
import { SerializedSchema } from '@tldraw/store';
import { Signal } from '@tldraw/state';
import { Store } from '@tldraw/store';
import { StoreSchema } from '@tldraw/store';
import { TLRecord } from '@tldraw/tlschema';
import { TLStoreSnapshot } from '@tldraw/tlschema';
import { UnknownRecord } from '@tldraw/store';

// @internal
export type AppendOp = [type: typeof ValueOpType.Append, values: unknown[], offset: number];

// @internal
export function applyObjectDiff<T extends object>(object: T, objectDiff: ObjectDiff): T;

// @internal
export function chunk(msg: string, maxSafeMessageSize?: number): string[];

// @internal
export class ClientWebSocketAdapter implements TLPersistentClientSocket<TLRecord> {
    constructor(getUri: () => Promise<string> | string);
    close(): void;
    // (undocumented)
    _closeSocket(): void;
    get connectionStatus(): TLPersistentClientSocketStatus;
    // (undocumented)
    _connectionStatus: Atom<'initial' | TLPersistentClientSocketStatus>;
    // (undocumented)
    isDisposed: boolean;
    onReceiveMessage(cb: (val: TLSocketServerSentEvent<TLRecord>) => void): () => void;
    onStatusChange(cb: TLSocketStatusListener): () => void;
    // (undocumented)
    readonly _reconnectManager: ReconnectManager;
    restart(): void;
    sendMessage(msg: TLSocketClientSentEvent<TLRecord>): void;
    // (undocumented)
    _setNewSocket(ws: WebSocket): void;
    // (undocumented)
    _ws: null | WebSocket;
}

// @internal
export type DeleteOp = [type: typeof ValueOpType.Delete];

// @internal
export function diffRecord(prev: object, next: object): null | ObjectDiff;

// @internal
export class DocumentState<R extends UnknownRecord> {
    static createAndValidate<R extends UnknownRecord>(state: R, lastChangedClock: number, recordType: RecordType<R, any>): Result<DocumentState<R>, Error>;
    static createWithoutValidating<R extends UnknownRecord>(state: R, lastChangedClock: number, recordType: RecordType<R, any>): DocumentState<R>;
    // (undocumented)
    readonly lastChangedClock: number;
    mergeDiff(diff: ObjectDiff, clock: number): Result<[ObjectDiff, DocumentState<R>] | null, Error>;
    replaceState(state: R, clock: number): Result<[ObjectDiff, DocumentState<R>] | null, Error>;
    // (undocumented)
    readonly state: R;
}

// @internal
export function getNetworkDiff<R extends UnknownRecord>(diff: RecordsDiff<R>): NetworkDiff<R> | null;

// @internal
export function getTlsyncProtocolVersion(): number;

// @internal
export interface NetworkDiff<R extends UnknownRecord> {
    // (undocumented)
    [id: string]: RecordOp<R>;
}

// @internal
export interface ObjectDiff {
    // (undocumented)
    [k: string]: ValueOp;
}

// @public
export type OmitVoid<T, KS extends keyof T = keyof T> = {
    [K in KS extends any ? (void extends T[KS] ? never : KS) : never]: T[K];
};

// @internal
export type PatchOp = [type: typeof ValueOpType.Patch, diff: ObjectDiff];

// @internal
export interface PersistedRoomSnapshotForSupabase {
    // (undocumented)
    drawing: RoomSnapshot;
    // (undocumented)
    id: string;
    // (undocumented)
    slug: string;
}

// @internal
export type PutOp = [type: typeof ValueOpType.Put, value: unknown];

// @internal
export class ReconnectManager {
    constructor(socketAdapter: ClientWebSocketAdapter, getUri: () => Promise<string> | string);
    close(): void;
    connected(): void;
    disconnected(): void;
    // (undocumented)
    intendedDelay: number;
    maybeReconnected(): void;
}

// @internal
export type RecordOp<R extends UnknownRecord> = [typeof RecordOpType.Patch, ObjectDiff] | [typeof RecordOpType.Put, R] | [typeof RecordOpType.Remove];

// @internal
export const RecordOpType: {
    readonly Patch: "patch";
    readonly Put: "put";
    readonly Remove: "remove";
};

// @internal
export type RecordOpType = (typeof RecordOpType)[keyof typeof RecordOpType];

// @internal
export type RoomSession<R extends UnknownRecord, Meta> = {
    state: typeof RoomSessionState.AwaitingConnectMessage;
    meta: Meta;
    presenceId: null | string;
    sessionStartTime: number;
    sessionId: string;
    socket: TLRoomSocket<R>;
    isReadonly: boolean;
    requiresLegacyRejection: boolean;
} | {
    state: typeof RoomSessionState.AwaitingRemoval;
    meta: Meta;
    presenceId: null | string;
    cancellationTime: number;
    sessionId: string;
    socket: TLRoomSocket<R>;
    isReadonly: boolean;
    requiresLegacyRejection: boolean;
} | {
    state: typeof RoomSessionState.Connected;
    meta: Meta;
    presenceId: null | string;
    outstandingDataMessages: TLSocketServerSentDataEvent<R>[];
    serializedSchema: SerializedSchema;
    debounceTimer: null | ReturnType<typeof setTimeout>;
    lastInteractionTime: number;
    sessionId: string;
    socket: TLRoomSocket<R>;
    isReadonly: boolean;
    requiresLegacyRejection: boolean;
};

// @internal
export const RoomSessionState: {
    readonly AwaitingRemoval: "awaiting-removal";
    readonly Connected: "connected";
    readonly AwaitingConnectMessage: "awaiting-connect-message";
};

// @internal
export type RoomSessionState = (typeof RoomSessionState)[keyof typeof RoomSessionState];

// @public
export interface RoomSnapshot {
    clock: number;
    documentClock?: number;
    documents: Array<{
        lastChangedClock: number;
        state: UnknownRecord;
    }>;
    schema?: SerializedSchema;
    tombstoneHistoryStartsAtClock?: number;
    tombstones?: Record<string, number>;
}

// @public
export interface RoomStoreMethods<R extends UnknownRecord = UnknownRecord> {
    delete(recordOrId: R | string): void;
    get(id: string): null | R;
    getAll(): R[];
    put(record: R): void;
}

// @internal
export type SubscribingFn<T> = (cb: (val: T) => void) => () => void;

// @internal
export interface TLConnectRequest {
    // (undocumented)
    connectRequestId: string;
    // (undocumented)
    lastServerClock: number;
    // (undocumented)
    protocolVersion: number;
    // (undocumented)
    schema: SerializedSchema;
    // (undocumented)
    type: 'connect';
}

// @public
export type TLCustomMessageHandler = (this: null, data: any) => void;

// @internal @deprecated
export const TLIncompatibilityReason: {
    readonly ClientTooOld: "clientTooOld";
    readonly InvalidOperation: "invalidOperation";
    readonly InvalidRecord: "invalidRecord";
    readonly ServerTooOld: "serverTooOld";
};

// @internal @deprecated
export type TLIncompatibilityReason = (typeof TLIncompatibilityReason)[keyof typeof TLIncompatibilityReason];

// @internal
export interface TLPersistentClientSocket<R extends UnknownRecord = UnknownRecord> {
    connectionStatus: 'error' | 'offline' | 'online';
    onReceiveMessage: SubscribingFn<TLSocketServerSentEvent<R>>;
    onStatusChange: SubscribingFn<TlSocketStatusChangeEvent>;
    restart(): void;
    sendMessage(msg: TLSocketClientSentEvent<R>): void;
}

// @internal
export type TLPersistentClientSocketStatus = 'error' | 'offline' | 'online';

// @internal
export interface TLPingRequest {
    // (undocumented)
    type: 'ping';
}

// @internal
export type TLPresenceMode =
/** No presence sharing - client operates independently */
'full'
| 'solo'
/** Full presence sharing - cursors and selections visible to others */;

// @internal
export interface TLPushRequest<R extends UnknownRecord> {
    // (undocumented)
    clientClock: number;
    // (undocumented)
    diff?: NetworkDiff<R>;
    // (undocumented)
    presence?: [typeof RecordOpType.Patch, ObjectDiff] | [typeof RecordOpType.Put, R];
    // (undocumented)
    type: 'push';
}

// @public
export class TLRemoteSyncError extends Error {
    constructor(reason: string | TLSyncErrorCloseEventReason);
    // (undocumented)
    name: string;
    // (undocumented)
    readonly reason: string | TLSyncErrorCloseEventReason;
}

// @internal
export interface TLRoomSocket<R extends UnknownRecord> {
    close(code?: number, reason?: string): void;
    isOpen: boolean;
    sendMessage(msg: TLSocketServerSentEvent<R>): void;
}

// @internal
export type TLSocketClientSentEvent<R extends UnknownRecord> = TLConnectRequest | TLPingRequest | TLPushRequest<R>;

// @public
export class TLSocketRoom<R extends UnknownRecord = UnknownRecord, SessionMeta = void> {
    constructor(opts: {
        onPresenceChange?(): void;
        clientTimeout?: number;
        initialSnapshot?: RoomSnapshot | TLStoreSnapshot;
        log?: TLSyncLog;
        onAfterReceiveMessage?: (args: {
            message: TLSocketServerSentEvent<R>;
            meta: SessionMeta;
            sessionId: string;
            stringified: string;
        }) => void;
        onBeforeSendMessage?: (args: {
            message: TLSocketServerSentEvent<R>;
            meta: SessionMeta;
            sessionId: string;
            stringified: string;
        }) => void;
        onDataChange?(): void;
        onSessionRemoved?: (room: TLSocketRoom<R, SessionMeta>, args: {
            meta: SessionMeta;
            numSessionsRemaining: number;
            sessionId: string;
        }) => void;
        schema?: StoreSchema<R, any>;
    });
    close(): void;
    closeSession(sessionId: string, fatalReason?: string | TLSyncErrorCloseEventReason): void;
    getCurrentDocumentClock(): number;
    // @internal
    getCurrentSerializedSnapshot(): string;
    getCurrentSnapshot(): RoomSnapshot;
    getNumActiveSessions(): number;
    // @internal
    getPresenceRecords(): Record<string, UnknownRecord>;
    getRecord(id: string): R | undefined;
    getSessions(): Array<{
        isConnected: boolean;
        isReadonly: boolean;
        meta: SessionMeta;
        sessionId: string;
    }>;
    handleSocketClose(sessionId: string): void;
    handleSocketConnect(opts: {
        isReadonly?: boolean;
        sessionId: string;
        socket: WebSocketMinimal;
    } & (SessionMeta extends void ? object : {
        meta: SessionMeta;
    })): void;
    handleSocketError(sessionId: string): void;
    handleSocketMessage(sessionId: string, message: AllowSharedBufferSource | string): void;
    isClosed(): boolean;
    loadSnapshot(snapshot: RoomSnapshot | TLStoreSnapshot): void;
    // (undocumented)
    readonly log?: TLSyncLog;
    // (undocumented)
    readonly opts: {
        onPresenceChange?(): void;
        clientTimeout?: number;
        initialSnapshot?: RoomSnapshot | TLStoreSnapshot;
        log?: TLSyncLog;
        onAfterReceiveMessage?: (args: {
            message: TLSocketServerSentEvent<R>;
            meta: SessionMeta;
            sessionId: string;
            stringified: string;
        }) => void;
        onBeforeSendMessage?: (args: {
            message: TLSocketServerSentEvent<R>;
            meta: SessionMeta;
            sessionId: string;
            stringified: string;
        }) => void;
        onDataChange?(): void;
        onSessionRemoved?: (room: TLSocketRoom<R, SessionMeta>, args: {
            meta: SessionMeta;
            numSessionsRemaining: number;
            sessionId: string;
        }) => void;
        schema?: StoreSchema<R, any>;
    };
    sendCustomMessage(sessionId: string, data: any): void;
    updateStore(updater: (store: RoomStoreMethods<R>) => Promise<void> | void): Promise<void>;
}

// @internal
export type TLSocketServerSentDataEvent<R extends UnknownRecord> = {
    action: 'commit' | 'discard' | {
        rebaseWithDiff: NetworkDiff<R>;
    };
    clientClock: number;
    serverClock: number;
    type: 'push_result';
} | {
    diff: NetworkDiff<R>;
    serverClock: number;
    type: 'patch';
};

// @internal
export type TLSocketServerSentEvent<R extends UnknownRecord> = {
    connectRequestId: string;
    diff: NetworkDiff<R>;
    hydrationType: 'wipe_all' | 'wipe_presence';
    isReadonly: boolean;
    protocolVersion: number;
    schema: SerializedSchema;
    serverClock: number;
    type: 'connect';
} | {
    data: any;
    type: 'custom';
} | {
    data: TLSocketServerSentDataEvent<R>[];
    type: 'data';
} | {
    reason: TLIncompatibilityReason;
    type: 'incompatibility_error';
} | {
    type: 'pong';
} | TLSocketServerSentDataEvent<R>;

// @internal
export type TlSocketStatusChangeEvent = {
    status: 'offline' | 'online';
} | {
    status: 'error';
    reason: string;
};

// @internal
export type TLSocketStatusListener = (params: TlSocketStatusChangeEvent) => void;

// @internal
export class TLSyncClient<R extends UnknownRecord, S extends Store<R> = Store<R>> {
    constructor(config: {
        didCancel?(): boolean;
        onAfterConnect?(self: TLSyncClient<R, S>, details: {
            isReadonly: boolean;
        }): void;
        onCustomMessageReceived?: TLCustomMessageHandler;
        onLoad(self: TLSyncClient<R, S>): void;
        onSyncError(reason: string): void;
        presence: Signal<null | R>;
        presenceMode?: Signal<TLPresenceMode>;
        socket: TLPersistentClientSocket<R>;
        store: S;
    });
    close(): void;
    // (undocumented)
    didCancel?: () => boolean;
    // (undocumented)
    incomingDiffBuffer: TLSocketServerSentDataEvent<R>[];
    // (undocumented)
    isConnectedToRoom: boolean;
    // (undocumented)
    lastPushedPresenceState: null | R;
    // (undocumented)
    latestConnectRequestId: null | string;
    readonly onAfterConnect?: (self: this, details: {
        isReadonly: boolean;
    }) => void;
    // (undocumented)
    readonly presenceMode: Signal<TLPresenceMode> | undefined;
    // (undocumented)
    readonly presenceState: Signal<null | R> | undefined;
    // (undocumented)
    readonly socket: TLPersistentClientSocket<R>;
    // (undocumented)
    readonly store: S;
}

// @public
export const TLSyncErrorCloseEventCode: 4099;

// @public
export const TLSyncErrorCloseEventReason: {
    readonly RATE_LIMITED: "RATE_LIMITED";
    readonly CLIENT_TOO_OLD: "CLIENT_TOO_OLD";
    readonly INVALID_RECORD: "INVALID_RECORD";
    readonly ROOM_FULL: "ROOM_FULL";
    readonly NOT_FOUND: "NOT_FOUND";
    readonly SERVER_TOO_OLD: "SERVER_TOO_OLD";
    readonly UNKNOWN_ERROR: "UNKNOWN_ERROR";
    readonly NOT_AUTHENTICATED: "NOT_AUTHENTICATED";
    readonly FORBIDDEN: "FORBIDDEN";
};

// @public
export type TLSyncErrorCloseEventReason = (typeof TLSyncErrorCloseEventReason)[keyof typeof TLSyncErrorCloseEventReason];

// @public
export interface TLSyncLog {
    error?(...args: any[]): void;
    warn?(...args: any[]): void;
}

// @internal
export class TLSyncRoom<R extends UnknownRecord, SessionMeta> {
    constructor(opts: {
        log?: TLSyncLog;
        onDataChange?(): void;
        onPresenceChange?(): void;
        schema: StoreSchema<R, any>;
        snapshot?: RoomSnapshot;
    });
    broadcastPatch(message: {
        diff: NetworkDiff<R>;
        sourceSessionId?: string;
    }): this;
    // (undocumented)
    clock: number;
    close(): void;
    // (undocumented)
    documentClock: number;
    // (undocumented)
    documents: AtomMap<string, DocumentState<R>>;
    // (undocumented)
    readonly documentTypes: Set<string>;
    // (undocumented)
    readonly events: Emitter<    {
    room_became_empty(): void;
    session_removed(args: {
    meta: SessionMeta;
    sessionId: string;
    }): void;
    }>;
    // (undocumented)
    _flushDataMessages(sessionId: string): void;
    getSnapshot(): RoomSnapshot;
    handleClose(sessionId: string): void;
    handleMessage(sessionId: string, message: TLSocketClientSentEvent<R>): Promise<void>;
    handleNewSession(opts: {
        isReadonly: boolean;
        meta: SessionMeta;
        sessionId: string;
        socket: TLRoomSocket<R>;
    }): this;
    isClosed(): boolean;
    // (undocumented)
    readonly presenceType: null | RecordType<R, any>;
    // (undocumented)
    pruneSessions: () => void;
    rejectSession(sessionId: string, fatalReason?: string | TLSyncErrorCloseEventReason): void;
    // (undocumented)
    readonly schema: StoreSchema<R, any>;
    sendCustomMessage(sessionId: string, data: any): void;
    // (undocumented)
    readonly serializedSchema: SerializedSchema;
    // (undocumented)
    readonly sessions: Map<string, RoomSession<R, SessionMeta>>;
    // (undocumented)
    tombstoneHistoryStartsAtClock: number;
    // (undocumented)
    tombstones: AtomMap<string, number>;
    updateStore(updater: (store: RoomStoreMethods<R>) => Promise<void> | void): Promise<void>;
}

// @internal
export type ValueOp = AppendOp | DeleteOp | PatchOp | PutOp;

// @internal
export const ValueOpType: {
    readonly Append: "append";
    readonly Delete: "delete";
    readonly Patch: "patch";
    readonly Put: "put";
};

// @internal
export type ValueOpType = (typeof ValueOpType)[keyof typeof ValueOpType];

// @public
export interface WebSocketMinimal {
    addEventListener?: (type: 'close' | 'error' | 'message', listener: (event: any) => void) => void;
    close: (code?: number, reason?: string) => void;
    readyState: number;
    removeEventListener?: (type: 'close' | 'error' | 'message', listener: (event: any) => void) => void;
    send: (data: string) => void;
}

// (No @packageDocumentation comment for this package)

```
