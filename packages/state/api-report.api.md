## API Report File for "@tldraw/state"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @internal
export class ArraySet<T> {
    add(elem: T): boolean;
    // (undocumented)
    clear(): void;
    // (undocumented)
    has(elem: T): boolean;
    get isEmpty(): boolean;
    remove(elem: T): boolean;
    // (undocumented)
    size(): number;
    visit(visitor: (item: T) => void): void;
}

// @public
export interface Atom<Value, Diff = unknown> extends Signal<Value, Diff> {
    set(value: Value, diff?: Diff): Value;
    update(updater: (value: Value) => Value): Value;
}

// @public
export function atom<Value, Diff = unknown>(
name: string,
initialValue: Value,
options?: AtomOptions<Value, Diff>): Atom<Value, Diff>;

// @public
export interface AtomOptions<Value, Diff> {
    computeDiff?: ComputeDiff<Value, Diff>;
    historyLength?: number;
    isEqual?(a: any, b: any): boolean;
}

// @internal (undocumented)
export interface Child {
    // (undocumented)
    isActivelyListening: boolean;
    // (undocumented)
    lastTraversedEpoch: number;
    // (undocumented)
    readonly parentEpochs: number[];
    // (undocumented)
    readonly parents: Signal<any, any>[];
    // (undocumented)
    readonly parentSet: ArraySet<Signal<any, any>>;
}

// @public
export interface Computed<Value, Diff = unknown> extends Signal<Value, Diff> {
    readonly isActivelyListening: boolean;
    // @internal (undocumented)
    readonly parentEpochs: number[];
    // @internal (undocumented)
    readonly parents: Signal<any, any>[];
    // @internal (undocumented)
    readonly parentSet: ArraySet<Signal<any, any>>;
}

// @public
export function computed<Value, Diff = unknown>(name: string, compute: (previousValue: typeof UNINITIALIZED | Value, lastComputedEpoch: number) => Value | WithDiff<Value, Diff>, options?: ComputedOptions<Value, Diff>): Computed<Value, Diff>;

// @public
export function computed<This extends object, Value>(compute: () => Value, context: ClassMethodDecoratorContext<This, () => Value>): () => Value;

// @public
export function computed(target: any, key: string, descriptor: PropertyDescriptor): PropertyDescriptor;

// @public
export function computed<Value, Diff = unknown>(options?: ComputedOptions<Value, Diff>): ((target: any, key: string, descriptor: PropertyDescriptor) => PropertyDescriptor) & (<This>(compute: () => Value, context: ClassMethodDecoratorContext<This, () => Value>) => () => Value);

// @public
export type ComputeDiff<Value, Diff> = (previousValue: Value, currentValue: Value, lastComputedEpoch: number, currentEpoch: number) => Diff | RESET_VALUE;

// @public
export interface ComputedOptions<Value, Diff> {
    computeDiff?: ComputeDiff<Value, Diff>;
    historyLength?: number;
    isEqual?(a: any, b: any): boolean;
}

// @public
export const EffectScheduler: new <Result>(name: string, runEffect: (lastReactedEpoch: number) => Result, options?: EffectSchedulerOptions) => EffectScheduler<Result>;

// @public (undocumented)
export interface EffectScheduler<Result> {
    attach(): void;
    detach(): void;
    execute(): Result;
    readonly isActivelyListening: boolean;
    // @internal (undocumented)
    readonly lastTraversedEpoch: number;
    // @internal (undocumented)
    maybeExecute(): void;
    // @internal (undocumented)
    maybeScheduleEffect(): void;
    // @internal (undocumented)
    readonly parentEpochs: number[];
    // @internal (undocumented)
    readonly parents: Signal<any, any>[];
    // @internal (undocumented)
    readonly parentSet: ArraySet<Signal<any, any>>;
    readonly scheduleCount: number;
    // @internal (undocumented)
    scheduleEffect(): void;
}

// @public (undocumented)
export interface EffectSchedulerOptions {
    scheduleEffect?: (execute: () => void) => void;
}

// @public (undocumented)
export const EMPTY_ARRAY: [];

// @public
export function getComputedInstance<Obj extends object, Prop extends keyof Obj>(obj: Obj, propertyName: Prop): Computed<Obj[Prop]>;

// @public
export function isAtom(value: unknown): value is Atom<unknown>;

// @public (undocumented)
export function isSignal(value: any): value is Signal<any>;

// @public
export function isUninitialized(value: any): value is UNINITIALIZED;

// @public
export function react(name: string, fn: (lastReactedEpoch: number) => any, options?: EffectSchedulerOptions): () => void;

// @public
export interface Reactor<T = unknown> {
    scheduler: EffectScheduler<T>;
    start(options?: {
        force?: boolean;
    }): void;
    stop(): void;
}

// @public
export function reactor<Result>(name: string, fn: (lastReactedEpoch: number) => Result, options?: EffectSchedulerOptions): Reactor<Result>;

// @public (undocumented)
export const RESET_VALUE: unique symbol;

// @public (undocumented)
export type RESET_VALUE = typeof RESET_VALUE;

// @public
export interface Signal<Value, Diff = unknown> {
    __unsafe__getWithoutCapture(ignoreErrors?: boolean): Value;
    // @internal (undocumented)
    children: ArraySet<Child>;
    get(): Value;
    getDiffSince(epoch: number): Diff[] | RESET_VALUE;
    lastChangedEpoch: number;
    name: string;
}

// @public
export function transact<T>(fn: () => T): T;

// @public
export function transaction<T>(fn: (rollback: () => void) => T): T;

// @public (undocumented)
export const UNINITIALIZED: unique symbol;

// @public
export type UNINITIALIZED = typeof UNINITIALIZED;

// @public
export function unsafe__withoutCapture<T>(fn: () => T): T;

// @public
export function whyAmIRunning(): void;

// @public (undocumented)
export const WithDiff: {
    new <Value, Diff>(value: Value, diff: Diff): {
        diff: Diff;
        value: Value;
    };
};

// @public (undocumented)
export interface WithDiff<Value, Diff> {
    // (undocumented)
    diff: Diff;
    // (undocumented)
    value: Value;
}

// @public
export function withDiff<Value, Diff>(value: Value, diff: Diff): WithDiff<Value, Diff>;

// (No @packageDocumentation comment for this package)

```
