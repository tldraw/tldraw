---
title: Ticks
created_at: 12/20/2025
updated_at: 12/20/2025
keywords:
  - tick
  - frame
  - animation
  - TickManager
  - requestAnimationFrame
status: published
date: 12/20/2025
order: 29
---

The tick system provides a frame-synchronized update loop for the editor through the `TickManager`. It emits `tick` events at the browser's native refresh rate using `requestAnimationFrame`, enabling smooth animations, edge scrolling during drag operations, and time-based state updates. Tools can implement the `onTick` handler to receive continuous updates with precise elapsed time information.

The tick system bridges the gap between user interactions and frame-based updates. While pointer and keyboard events fire in response to user input, tick events fire on every animation frame, providing a consistent timing mechanism for operations that need to update smoothly over time.

## How the TickManager works

The `TickManager` class manages the animation frame loop for the editor. It starts automatically when the editor initializes and runs continuously until the editor is disposed.

```typescript
export class TickManager {
	constructor(public editor: Editor) {
		this.start()
	}

	start() {
		this.isPaused = false
		this.cancelRaf = throttleToNextFrame(this.tick)
		this.now = Date.now()
	}

	tick() {
		if (this.isPaused) return

		const now = Date.now()
		const elapsed = now - this.now
		this.now = now

		this.editor.inputs.updatePointerVelocity(elapsed)
		this.editor.emit('frame', elapsed)
		this.editor.emit('tick', elapsed)
		this.cancelRaf = throttleToNextFrame(this.tick)
	}
}
```

The manager tracks elapsed time between frames by comparing timestamps. This elapsed time is passed to all tick event handlers, allowing them to scale their updates based on the actual frame duration rather than assuming a fixed framerate.

## Tick events in the state tree

When the `TickManager` emits a tick event, the editor dispatches it through the root state node, which propagates it down the active tool hierarchy. Each active state node can handle the tick event:

```typescript
// In Editor.ts
this.on('tick', (elapsed) => {
	if (elapsed > 0) {
		this.root.handleEvent({ type: 'misc', name: 'tick', elapsed })
	}
	this.scribbles.tick(elapsed)
})
```

Tools implement the `onTick` handler to receive these events:

```typescript
export interface TLTickEventInfo {
	type: 'misc'
	name: 'tick'
	elapsed: number
}

export type TLTickEvent = (info: TLTickEventInfo) => void

export interface TLEventHandlers {
	// ... other handlers
	onTick: TLTickEvent
}
```

## Implementing onTick in tools

Tools that need continuous frame-based updates override the `onTick` method in their state node. The most common use case is edge scrolling during drag operations:

```typescript
// From Translating.ts
export class Translating extends StateNode {
	override onTick({ elapsed }: TLTickEventInfo) {
		const { editor } = this
		editor.edgeScrollManager.updateEdgeScrolling(elapsed)
	}
}
```

The `EdgeScrollManager` uses the elapsed time to smoothly accelerate the scroll speed when the pointer is near screen edges:

```typescript
updateEdgeScrolling(elapsed: number) {
  const edgeScrollProximityFactor = this.getEdgeScroll()

  if (edgeScrollProximityFactor.x !== 0 || edgeScrollProximityFactor.y !== 0) {
    this._edgeScrollDuration += elapsed

    if (this._edgeScrollDuration > editor.options.edgeScrollDelay) {
      const eased = EASINGS.easeInCubic(
        Math.min(1, this._edgeScrollDuration /
          (editor.options.edgeScrollDelay + editor.options.edgeScrollEaseDuration))
      )

      this.moveCameraWhenCloseToEdge({
        x: edgeScrollProximityFactor.x * eased,
        y: edgeScrollProximityFactor.y * eased,
      })
    }
  }
}
```

## Scribbles and tick updates

The `ScribbleManager` also subscribes to tick events to animate scribble trails (the visual feedback during brush selection and laser tool usage):

```typescript
// Simplified for clarity - see ScribbleManager.ts for full implementation
tick(elapsed: number) {
  if (this.scribbleItems.size === 0) return

  this.scribbleItems.forEach((item) => {
    const { next, prev, delayRemaining, scribble } = item
    item.timeoutMs += elapsed

    if (scribble.state === 'active') {
      // Add new points and shrink from the tail
      if (next && next !== prev) {
        scribble.points.push(next)
        if (delayRemaining === 0 && scribble.points.length > 8) {
          scribble.points.shift()
        }
      }
    } else if (scribble.state === 'stopping') {
      // Gradually shrink the scribble
      if (scribble.points.length === 1) {
        this.scribbleItems.delete(item.id)
      } else {
        scribble.size = Math.max(1, scribble.size * (1 - scribble.shrink))
        scribble.points.shift()
      }
    }
  })
}
```

## Use cases for tick events

Tick events are appropriate when you need:

1. **Edge scrolling** - Continuously update the camera position when the pointer is near screen edges during drag operations
2. **Scribble animations** - Animate visual feedback trails that grow and shrink over time
3. **Pointer velocity tracking** - Calculate pointer movement speed for gesture detection
4. **Time-based state transitions** - Implement delays or timeouts that should respect frame timing
5. **Smooth interpolation** - Gradually transition values over multiple frames

Tick events should not be used for:

- Responding to user input (use pointer, keyboard, or wheel events instead)
- One-time calculations (use event handlers or computed values)
- State changes that don't need frame-by-frame updates

## Related examples

- **[Snowstorm](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/snowstorm)** - Uses tick events to animate falling snowflakes on the canvas.
- **[Sticker bindings](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/sticker-bindings)** - Uses onTick to update sticker positions as their bound shapes move.
