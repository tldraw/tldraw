---
title: Shape indexing
created_at: 12/20/2025
updated_at: 12/20/2025
keywords:
  - index
  - z-order
  - fractional
  - sorting
  - layers
status: published
date: 12/20/2025
order: 22
---

The shape indexing system determines the visual stacking order (z-order) of shapes on the canvas. Every shape has an `index` property that controls whether it appears above or below other shapes. This system enables efficient reordering operations and supports real-time collaboration where multiple users might reorder shapes simultaneously.

## Fractional indexing

tldraw uses string-based fractional indices instead of integers. Integer-based indexing systems require renumbering when inserting shapes between existing ones. If you have shapes with indices `[0, 1, 2]` and want to insert a shape between 0 and 1, you must either renumber all subsequent shapes or use floating-point numbers which eventually exhaust precision.

Fractional indexing solves this by using lexicographically sortable strings. You can always generate a new index between any two existing indices. The strings compare correctly using standard JavaScript string comparison, so sorting shapes by index is a simple lexicographic sort. Reordering shapes only updates the shapes being moved, not every shape on the canvas.

## Index structure

Fractional indices are based on the [jittered fractional indexing](https://www.npmjs.com/package/jittered-fractional-indexing) algorithm. Each index is a string consisting of an integer part followed by an optional fractional part. Indices use base-62 encoding (a-z, A-Z, 0-9) to maximize density.

The integer part determines the rough position in the sequence. The fractional part provides precision for inserting between existing indices. Indices omit trailing zeros in the fractional part to stay compact.

## Generating indices

The `@tldraw/utils` package provides functions for generating indices:

```typescript
import { getIndexBetween, getIndicesAbove, getIndicesBelow } from '@tldraw/utils'

const index = getIndexBetween('a0', 'a2') // 'a1'
const indices = getIndicesAbove('a0', 3) // ['a1', 'a2', 'a3']
const below = getIndicesBelow('a2', 2) // ['a1', 'a0V']
```

The algorithm includes optional jittering (randomization) to reduce conflicts in collaborative environments where multiple users might simultaneously insert shapes at the same position. Tests disable jittering for deterministic behavior.

## Reordering operations

The Editor class provides four methods for reordering shapes.

### Send to back and bring to front

```typescript
editor.sendToBack(['shape1', 'shape2'])
editor.bringToFront(['shape1', 'shape2'])
```

These methods move shapes to the bottom or top of the z-order within their parent. The `sendToBack` method finds the lowest non-moving shape and inserts the selected shapes below it. The `bringToFront` method finds the highest non-moving shape and inserts the selected shapes above it. If some shapes at the target position are already being moved, they stay in their relative order.

### Send backward and bring forward

```typescript
editor.sendBackward(['shape1'])
editor.bringForward(['shape1'])
```

These methods move shapes one position down or up in the z-order. By default, they only move shapes past overlapping shapes. Pass `considerAllShapes: true` to move past any shape regardless of overlap:

```typescript
editor.sendBackward(['shape1'], { considerAllShapes: true })
```

This creates intuitive behavior where keyboard shortcuts move shapes past only the shapes they visually overlap.

### Relative order preservation

All reordering methods maintain the relative order of moved shapes. If you select shapes A, B, and C (where A is below B which is below C) and bring them forward, they maintain that A-B-C ordering at their new position in the stack.

## Reordering algorithm

The reordering logic follows this pattern:

1. Group shapes by their parent (indices are relative to siblings)
2. For each parent, identify which children are moving and which are stationary
3. Find the insertion point based on the operation (toFront, toBack, forward, backward)
4. Generate new indices for moved shapes using `getIndicesBetween`
5. Update only the shapes that need new indices

The algorithm optimizes by not generating indices for shapes that don't need to move. If shapes are already at the target position, no updates occur.

## Collaboration support

Fractional indexing supports real-time collaboration. When two users simultaneously reorder shapes, they generate different indices in the same region of the index space. Since indices are strings, these don't conflict - both operations succeed and the final order depends on which operation completed last.

The jittering in the fractional indexing algorithm reduces the likelihood that two users generate identical indices for different shapes. Without jittering, two users inserting shapes at the same position would generate the same index, requiring conflict resolution. With jittering, they generate different indices that sort near each other but remain distinct.

The `@tldraw/sync` package handles merging concurrent updates. Since reordering operations only update the moved shapes' indices, they don't interfere with other concurrent operations on different shapes.

## Index validation

The `IndexKey` type is a branded type that prevents accidentally using arbitrary strings as indices. The `validateIndexKey` function ensures a string is a valid index by attempting to generate an index after it. Invalid indices throw an error during validation.

All shapes must have valid indices. The store validates indices when you create or update shapes, ensuring the editor never enters an invalid state.

## Related examples

- **[Layer panel](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/layer-panel)** - Display shape hierarchy and z-order with reordering controls.
- **[API example](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/api-example)** - Create shapes programmatically, including managing their z-order indices.
