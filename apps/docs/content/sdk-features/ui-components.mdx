---
title: UI components
created_at: 12/17/2025
updated_at: 12/20/2025
keywords:
  - ui
  - components
  - toolbar
  - menu
  - customization
status: published
date: 12/20/2025
order: 9
---

The `@tldraw/tldraw` package includes a complete React-based UI. It provides the menus, toolbars, panels, and dialogs that users interact with when creating and editing content. The UI is composed of named component slots that you can selectively override or hide, so you can customize the interface while still benefiting from the editor's reactive state management.

The UI connects to the editor through React hooks and context providers. Components automatically update when editor state changes. You can replace individual parts of the interface without reimplementing the logic that connects UI actions to editor operations.

## How it works

### Component slot architecture

The UI divides the screen into distinct layout zones:

```
┌─────────────────────────────────────────────────────────┐
│                    Top Panel                             │
├────────────┬──────────────────────────┬─────────────────┤
│   Left     │         Canvas           │     Right       │
│   Panel    │                          │     Panel       │
├────────────┴──────────────────────────┴─────────────────┤
│                   Bottom Panel                           │
└─────────────────────────────────────────────────────────┘
```

The top zone contains the main menu, helper buttons (like "Back to content"), the top panel for collaboration features, and the share and style panels. The bottom zone houses navigation controls, the main toolbar with drawing tools, and the help menu. On desktop, the style panel appears in the top-right zone; on mobile it moves to a modal overlay.

Each zone can host multiple components. The toolbar includes the tool selector, tool-specific options, and the tool lock button. These components share context and coordinate through the editor's state.

### Context providers and state management

The UI establishes a hierarchy of React context providers that manage different aspects of the interface. At the root, `TldrawUiContextProvider` coordinates all other providers and merges your overrides. Specialized providers handle translations, tooltips, dialogs, toasts, breakpoints for responsive behavior, and the component registry.

The actions and tools providers transform raw editor methods into UI-friendly actions with labels, icons, and keyboard shortcuts. When you click a toolbar button, the component calls an action from context, which invokes the appropriate editor method. This indirection means the same action can be triggered from multiple places (toolbar, menu, keyboard shortcut) with consistent behavior.

### Reactive UI updates

UI components read editor state through hooks like `useEditor`, `useValue`, and `useReactor`. These hooks use the editor's reactive signal system to automatically re-render when relevant state changes. The style panel uses `useRelevantStyles` to determine which style controls to show based on the current selection—when you select a different shape, the hook detects the change and the panel updates.

This reactive approach means you don't need to manually manage subscriptions or worry about stale state. Components declare their dependencies, and the reactivity system handles the rest.

## Key components

### Component slots

The UI defines several component slots you can override or hide.

The **Toolbar** contains the primary tool selector with buttons for each available tool (select, draw, shapes, etc.). On mobile, it hides automatically when editing text to make room for the virtual keyboard.

The **TopPanel** displays the page name and collaboration indicators when multiplayer features are enabled. It's hidden in single-player mode.

The **StylePanel** shows style controls for selected shapes: color, fill, stroke, size, opacity. It appears in the top-right on desktop and as a modal on mobile.

The **MenuPanel** houses the main application menu with actions like export, print, and preferences. It's typically in the top-left corner.

The **NavigationPanel** provides page navigation, zoom controls, and the minimap toggle. It sits in the bottom-left area.

**HelperButtons** are context-sensitive buttons that appear based on editor state—"Back to content" when the camera is far from shapes, "Exit pen mode" on touch devices.

**ActionsMenu**, **ContextMenu**, and **HelpMenu** provide access to actions and information through different interaction patterns.

Each slot is optional. Pass `null` as an override to hide a component entirely, or provide your own React component to replace the default implementation.

### UI hooks

Components access editor functionality through specialized hooks.

`useEditor` returns the editor instance, providing direct access to all editor methods and state.

`useActions` returns a collection of UI actions (copy, paste, delete) with their labels, icons, and keyboard shortcuts. Each action is a function you can call from your custom UI.

`useTools` returns the available tools with their metadata. The toolbar uses this to render tool buttons.

`useRelevantStyles` determines which styles are relevant to the current selection and returns their values. It powers the style panel.

`useBreakpoint` returns the current responsive breakpoint (mobile, tablet, desktop), allowing components to adapt their layout.

These hooks encapsulate common UI patterns and keep your custom components in sync with editor state.

## Hiding the UI

You can hide the default tldraw user interface entirely using the `hideUi` prop. This turns off both the visuals and the keyboard shortcuts.

```tsx
function App() {
	return <Tldraw hideUi />
}
```

While you can't select tools using keyboard shortcuts when the UI is hidden, you can still control the editor programmatically. Open the console and try:

```ts
editor.setCurrentTool('draw')
```

All of our user interface works by controlling the editor via its `Editor` methods. If you hide the user interface, you can still use these same methods to control the editor. See our [custom user interface example](/examples/custom-ui) for this in action.

## Extension points

### Overriding components

Override individual components by passing them to the `components` prop. Your component receives the same props as the default implementation:

```tsx
function CustomToolbar() {
	const editor = useEditor()
	const tools = useTools()

	return (
		<div className="my-toolbar">
			{tools.map((tool) => (
				<button key={tool.id} onClick={() => editor.setCurrentTool(tool.id)}>
					{tool.label}
				</button>
			))}
		</div>
	)
}

function App() {
	return (
		<Tldraw
			components={{
				Toolbar: CustomToolbar,
			}}
		/>
	)
}
```

### Hiding components

Pass `null` to hide a component entirely. This is useful for focused experiences that don't need all the default UI:

```tsx
function App() {
	return (
		<Tldraw
			components={{
				HelpMenu: null,
				DebugMenu: null,
				SharePanel: null,
			}}
		/>
	)
}
```

## Overrides

The content of tldraw's menus can be controlled via the `overrides` prop. This prop accepts a [TLUiOverrides](/reference/tldraw/TLUiOverrides) object, which has methods for each part of the user interface, such as the `toolbar` or `keyboardShortcutsMenu`.

### Actions

The user interface has a set of shared `actions` that are used in the menus and keyboard shortcuts. These actions can be overridden by passing a new set of actions to the `overrides.actions` method.

To create, update, or delete actions, provide an `actions` method that receives both the editor and the [default actions](https://github.com/tldraw/tldraw/blob/main/packages/tldraw/src/lib/ui/context/actions.tsx) and returns a mutated actions object.

```tsx
const myOverrides: TLUiOverrides = {
	actions(editor, actions) {
		// You can delete actions, but remember to
		// also delete the menu items that reference them!
		delete actions['insert-embed']

		// Create a new action or replace an existing one
		actions['my-new-action'] = {
			id: 'my-new-action',
			label: 'My new action',
			readonlyOk: true,
			kbd: 'cmd+u,ctrl+u',
			onSelect(source: any) {
				// Whatever you want to happen when the action is run
				window.alert('My new action just happened!')
			},
		}
		return actions
	},
}

function App() {
	return <Tldraw overrides={myOverrides} />
}
```

The `actions` object is a map of [TLUiActionItem](/reference/tldraw/TLUiActionItem)s, with each item keyed under its `id`.

### Tools

Tools work the same way as actions. Override the default tools by passing a `tools` method that accepts the [default tools object](https://github.com/tldraw/tldraw/blob/main/packages/tldraw/src/lib/ui/hooks/useTools.tsx) and returns a mutated version of that object.

```tsx
const myOverrides: TLUiOverrides = {
	tools(editor, tools) {
		// Create a tool item in the ui's context
		tools.card = {
			id: 'card',
			icon: 'color',
			label: 'tools.card',
			kbd: 'c',
			onSelect: () => {
				// Whatever you want to happen when the tool is selected
				editor.setCurrentTool('card')
			},
		}
		return tools
	},
}

function App() {
	return <Tldraw overrides={myOverrides} />
}
```

The `tools` object is a map of [TLUiToolItem](/reference/tldraw/TLUiToolItem)s, with each item keyed under its `id`.

### Translations

The `translations` property accepts a table of new translations. For example, if you wanted a tool to reference a key `"tools.card"`, you should at minimum provide an english translation for this key.

```tsx
const myOverrides: TLUiOverrides = {
	translations: {
		en: {
			'tools.card': 'Card',
		},
	},
}

function App() {
	return <Tldraw overrides={myOverrides} />
}
```

## UI events

The [Tldraw](?) component has a prop, `onUiEvent`, that the user interface will call when certain events occur.

```tsx
function App() {
	function handleEvent(name, data) {
		// do something with the event
	}

	return <Tldraw onUiEvent={handleEvent} />
}
```

The `onUiEvent` callback is called with the name of the event as a string and an object with information about the event's source (e.g. `menu` or `context-menu`) and possibly other data specific to each event, such as the direction in an `align-shapes` event.

Note that `onUiEvent` is only called when interacting with the user interface. It is not called when running commands manually against the app—calling [Editor#alignShapes](?) will not call `onUiEvent`.

## Related articles

- **[UI primitives](/docs/ui-primitives)** — Use tldraw's button, menu, dialog, and other UI components in your custom interfaces

## Related examples

- **[Custom UI](/examples/ui/custom-ui)** — Build a completely custom toolbar UI while using the editor's functionality
- **[Custom components](/examples/basic/custom-components)** — Override individual canvas components like the brush selection box and scribble
- **[Hide UI](/examples/ui/hide-ui)** — Use hideUi to hide the entire default interface
- **[UI components hidden](/examples/ui/ui-components-hidden)** — Selectively hide specific UI components
- **[Custom menus](/examples/ui/menus/custom-menus)** — Create custom menus using tldraw's menu system
- **[Vertical toolbar](/examples/ui/vertical-toolbar)** — Rearrange the toolbar layout
