---
title: Error handling
created_at: 12/22/2025
updated_at: 12/22/2025
keywords:
  - error
  - ErrorBoundary
  - crash
  - fallback
  - ErrorFallback
  - ShapeErrorFallback
reviewed_by: steveruizok
status: published
date: 12/22/2025
order: 12
---

We wrap the editor in multiple layers of React error boundaries so that a bug in one shape doesn't take down the entire canvas. When a shape throws during render, only that shape shows a fallback—the rest of the editor keeps working. This matters because custom shapes are a common extension point, and we don't want third-party code to crash the whole experience.

## Error boundary layers

We use error boundaries at three levels, each with different recovery behavior:

1. The application-level boundary wraps the entire editor. If something throws here, we show a full-screen error with options to refresh or reset local data. This is the last resort.

2. Each shape renders inside its own boundary. A broken shape disappears, but the user can still interact with everything else. We chose per-shape isolation because ShapeUtil code is the most likely place for bugs—especially in custom shapes.

3. Selection indicators have their own boundaries, separate from shape content. This way, a shape can render correctly even if its indicator throws (or vice versa).

```tsx
// The editor automatically wraps your content
<TldrawEditor>
	<OptionalErrorBoundary fallback={ErrorFallback}>
		{/* Your shapes, each with their own boundary */}
		<Shape>
			<OptionalErrorBoundary fallback={ShapeErrorFallback}>
				{/* Shape content */}
			</OptionalErrorBoundary>
		</Shape>
	</OptionalErrorBoundary>
</TldrawEditor>
```

## Default fallbacks

Each boundary level has a default fallback component.

The application-level `DefaultErrorFallback` shows a modal with the error message and stack trace. We try to render the canvas behind the modal—even though it might fail—so users can see their work is probably still there. The modal offers buttons to copy the error, refresh the page, or reset local data.

For shapes, `DefaultShapeErrorFallback` just renders an empty div. We intentionally keep this minimal: the shape vanishes, but nothing else breaks. You can style the `.tl-shape-error-boundary` class if you want broken shapes to be more visible.

The indicator fallback renders a red circle where the selection outline would be. It's a simple visual signal that something went wrong without disrupting selection behavior.

## Customizing error components

You can replace any error fallback through the `components` prop:

```tsx
function MyErrorFallback({ error, editor }) {
	return (
		<div className="my-error-screen">
			<h1>Oops!</h1>
			<p>{error.message}</p>
			<button onClick={() => window.location.reload()}>Refresh</button>
		</div>
	)
}

function MyShapeErrorFallback({ error }) {
	return <div className="broken-shape">⚠️ This shape failed to render</div>
}

;<Tldraw
	components={{
		ErrorFallback: MyErrorFallback,
		ShapeErrorFallback: MyShapeErrorFallback,
		ShapeIndicatorErrorFallback: MyShapeIndicatorErrorFallback,
	}}
/>
```

Set a fallback to `null` to disable the error boundary at that level, which lets errors propagate to the parent boundary.

## Crash handling

When the editor encounters a fatal error during event processing, it enters a crashed state. You can detect this by listening to the `crash` event or checking the crashing error:

```tsx
// Listen for crashes
editor.on('crash', ({ error }) => {
	console.error('Editor crashed:', error)
	// Report to error tracking service
})

// Check if editor is crashed
const crashingError = editor.getCrashingError()
if (crashingError) {
	// Editor is in crashed state
}
```

When crashed, the editor stops processing new events to prevent further damage. The error boundary displays the fallback UI, giving users options to recover.

## Error annotation

The editor annotates errors with contextual information before they're reported. This helps with debugging by including details about where the error originated.

```typescript
editor.annotateError(error, {
	origin: 'myCustomTool.onPointerDown',
	willCrashApp: false,
	tags: { toolName: 'laser' },
	extras: { shapeCount: 42 },
})
```

The method attaches metadata that helps with debugging: an `origin` string identifying where the error occurred, a `willCrashApp` boolean, plus arbitrary `tags` and `extras` for your error tracking service.

When `willCrashApp` is true, we also mark the store as possibly corrupted. This is a signal to avoid further writes—the data might be in an inconsistent state.

## ErrorBoundary component

You can use the exported `ErrorBoundary` component directly in your own code:

```tsx
import { ErrorBoundary } from 'tldraw'

function MyComponent() {
	return (
		<ErrorBoundary
			fallback={({ error }) => <div>Error: {error.message}</div>}
			onError={(error) => console.error('Caught:', error)}
		>
			<RiskyComponent />
		</ErrorBoundary>
	)
}
```

Pass a `fallback` component that receives `{ error }` props, and optionally an `onError` callback for logging.

## Related examples

- **[Error boundary](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/error-boundary)** - Customize the ShapeErrorFallback component to display a custom message when shapes throw errors.
- **[Custom error capture](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/custom-error-capture)** - Override the ErrorFallback component to create a custom error screen with annotations for debugging.
