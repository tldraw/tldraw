---
title: '@tldraw/sync'
created_at: 12/17/2024
updated_at: 12/20/2024
keywords:
  - sync
  - multiplayer
  - collaboration
  - real-time
  - websocket
  - presence
status: published
date: 12/20/2024
order: 18
---

The `@tldraw/sync` package provides React hooks for real-time multiplayer collaboration in tldraw applications. It wraps the lower-level `@tldraw/sync-core` protocol with React-friendly hooks that manage WebSocket connections, state synchronization, user presence, and automatic reconnection. With minimal configuration, it transforms a single-user tldraw instance into a collaborative multiplayer experience.

This is the recommended package for React applications requiring multiplayer functionality. For non-React environments, custom server implementations, or advanced protocol control, use `@tldraw/sync-core` directly.

## Architecture

The sync hooks build on `@tldraw/sync-core` to provide a complete React integration layer. Understanding how the pieces fit together helps when building production multiplayer applications.

### Client-server communication

The hooks establish WebSocket connections to a sync server and manage the full lifecycle:

1. Connection establishment with authentication support
2. Initial synchronization downloading current document state
3. Bidirectional change streaming as users edit
4. Presence broadcasting for cursors and selections
5. Automatic reconnection with state reconciliation

Each browser tab receives a unique session ID, and each store instance gets a unique store ID. These identifiers allow the server to track which changes come from which client, enabling proper conflict resolution and presence management.

### State progression

The hooks return a store wrapper that progresses through three states:

**Loading**: Initial connection establishment and synchronization. The client opens the WebSocket, performs authentication if required, and downloads the current document state from the server. During this phase, display loading UI to indicate the connection is in progress.

**Synced-remote**: Successfully connected and actively synchronizing. Changes made locally apply immediately (optimistic updates) and propagate to other clients through the server. The store includes a `connectionStatus` field indicating whether the network connection is online or offline. When offline, local changes queue and send when the connection restores.

**Error**: Connection or synchronization failed. The error indicates the reason (authentication failure, room not found, rate limiting, protocol error). Display appropriate error messages and allow users to retry or troubleshoot based on the error type.

### Relationship to sync-core

This package depends on `@tldraw/sync-core` and uses its client-side components:

- `TLSyncClient`: Manages synchronization, conflict resolution, and state reconciliation
- `ClientWebSocketAdapter`: Wraps WebSocket connections with automatic reconnection
- Protocol types and error codes for communication with servers

The hooks handle React-specific concerns like lifecycle management, hook dependencies, and reactive integration with tldraw's signal system. The underlying sync-core machinery handles the actual synchronization protocol.

## Key concepts

### useSync hook

The production multiplayer hook that connects a tldraw store to a sync server:

```typescript
const store = useSync({
	uri: 'wss://myserver.com/sync/room-123',
	assets: myAssetStore,
	userInfo: { id: 'user-1', name: 'Alice', color: '#ff0000' },
})
```

The hook requires a WebSocket URI and an asset store. It returns a store wrapper with connection status that progresses from loading to synced-remote or error. Pass the wrapped store to the Tldraw component to enable multiplayer features.

### useSyncDemo hook

A simplified hook for prototyping that connects to tldraw's hosted demo server:

```typescript
const store = useSyncDemo({
	roomId: 'my-company-demo-room',
})
```

The demo hook pre-configures the asset store and server URI. It's suitable for quick prototypes and demos but not for production use. Demo data expires after approximately 24 hours, and rooms are publicly accessible to anyone with the room ID.

### Store wrapper states

The hooks return `RemoteTLStoreWithStatus`, which excludes local-only states since multiplayer stores are always either loading, connected, or in an error state:

```typescript
type RemoteTLStoreWithStatus =
	| { status: 'loading' }
	| { status: 'error'; error: Error }
	| {
			status: 'synced-remote'
			connectionStatus: 'online' | 'offline'
			store: TLStore
	  }
```

Check the status and render appropriate UI for each state. The synced-remote state includes both the store and the connection status, allowing you to show offline indicators while still allowing local editing.

### Presence system

User presence tracks cursors, selections, and user metadata in real-time. The hooks manage presence automatically using a reactive computation that runs whenever the store state changes. By default, presence includes cursor position, selected shapes, current page, and viewport. Customize presence by providing a `getUserPresence` function:

```typescript
const store = useSync({
	uri: wsUri,
	assets: myAssets,
	getUserPresence: (store, user) => ({
		userId: user.id,
		userName: user.name,
		cursor: getCurrentCursor(store),
		selectedShapeIds: store.selectedShapeIds,
		currentTool: store.currentTool,
	}),
})
```

The presence system operates in two modes: solo mode when you're alone in the room (minimal overhead), and full mode when others are present (full cursor and selection tracking). This optimization reduces unnecessary computation and bandwidth.

### Asset stores

Asset stores handle binary file uploads and storage. Without an asset store, files embed as base64 strings within the document, causing massive document sizes and slow performance. An asset store externalizes files to blob storage, keeping documents lightweight:

```typescript
const myAssetStore: TLAssetStore = {
	upload: async (asset, file) => {
		const url = await uploadToS3(file)
		return { src: url }
	},
	resolve: (asset, context) => {
		return getCdnUrl(asset.src, context)
	},
}
```

The upload method receives an asset record and file, uploads to cloud storage, and returns the permanent URL. The resolve method receives display context (screen scale, DPI, network quality) and returns an optimized URL for rendering.

### Reconnection and recovery

Network connections drop, and servers restart. The hooks handle this gracefully through automatic reconnection with exponential backoff. When offline, local changes still apply immediately and queue internally. When the connection restores, queued changes send to the server, which validates and reconciles them with changes from other clients.

The server acts as the source of truth during reconnection. If conflicts occurred while offline, server state wins. The client applies the server's authoritative state, then reapplies any local changes on top. This ensures all clients converge to the same state.

## API patterns

### Basic multiplayer setup

Connect to your sync server and enable multiplayer features:

```tsx
import { Tldraw } from 'tldraw'
import { useSync } from '@tldraw/sync'

function CollaborativeApp() {
	const store = useSync({
		uri: 'wss://myserver.com/sync/room-123',
		assets: myAssetStore,
		userInfo: {
			id: 'user-1',
			name: 'Alice',
			color: '#ff0000',
		},
	})

	if (store.status === 'loading') {
		return <div>Connecting...</div>
	}

	if (store.status === 'error') {
		return <div>Connection failed: {store.error.message}</div>
	}

	return <Tldraw store={store.store} />
}
```

### Dynamic authentication

Generate URIs dynamically for authentication tokens or room routing:

```tsx
const store = useSync({
	uri: async () => {
		const token = await getAuthToken()
		return `wss://myserver.com/sync/room-123?token=${token}`
	},
	assets: authenticatedAssetStore,
})
```

The URI function runs on each connection attempt, allowing token refresh during reconnection.

### Reactive user info

Pass a signal for user info to update presence without remounting:

```tsx
import { atom } from '@tldraw/state'

const userSignal = atom('user', {
	id: 'user-1',
	name: 'Alice',
	color: '#ff0000',
})

const store = useSync({
	uri: wsUri,
	assets: myAssets,
	userInfo: userSignal,
})

// Later, update the user info
userSignal.set({
	id: 'user-1',
	name: 'Alice Smith',
	color: '#00ff00',
})
// Presence automatically updates for all clients
```

### Connection status indicators

Show connection status to inform users of network issues:

```tsx
function EditorWithStatus() {
	const store = useSync({ uri: wsUri, assets: myAssets })

	if (store.status === 'loading') {
		return <LoadingSpinner />
	}

	if (store.status === 'error') {
		return <ErrorMessage error={store.error} />
	}

	const isOffline = store.connectionStatus === 'offline'

	return (
		<>
			{isOffline && <div>Offline - changes will sync when reconnected</div>}
			<Tldraw store={store.store} />
		</>
	)
}
```

### Error handling

Handle specific error types to provide meaningful feedback:

```tsx
if (store.status === 'error') {
	const errorMsg = store.error.message

	if (errorMsg.includes('NOT_FOUND')) {
		return <div>This room doesn't exist</div>
	}

	if (errorMsg.includes('FORBIDDEN')) {
		return <div>You don't have access to this room</div>
	}

	if (errorMsg.includes('NOT_AUTHENTICATED')) {
		return <div>Please log in to access this room</div>
	}

	return <div>Connection error: {errorMsg}</div>
}
```

### Demo server for prototyping

Use the hosted demo server for quick prototypes:

```tsx
import { useSyncDemo } from '@tldraw/sync'

function DemoApp() {
	const store = useSyncDemo({
		roomId: 'my-company-demo-room-123',
		userInfo: { id: 'user-1', name: 'Alice', color: '#ff0000' },
	})

	return <Tldraw store={store} />
}
```

Choose a unique room ID that includes your company or project name to avoid collisions with other demo users.

### Custom messages

Implement application-specific communication beyond shape synchronization:

```tsx
const store = useSync({
	uri: wsUri,
	assets: myAssets,
	onCustomMessageReceived: (data) => {
		if (data.type === 'chat') {
			addChatMessage(data.message)
		} else if (data.type === 'notification') {
			showNotification(data.text)
		}
	},
})

// Send custom messages through the sync client
// (Requires access to the underlying TLSyncClient instance)
```

## Key files

- packages/sync/src/index.ts - Package exports
- packages/sync/src/useSync.ts - Production multiplayer hook
- packages/sync/src/useSyncDemo.ts - Demo server integration

## Related

- [@tldraw/sync-core](./sync-core.md) - Lower-level sync protocol and client
- [@tldraw/store](./store.md) - Reactive store underlying synchronization
- [Multiplayer architecture](../architecture/multiplayer.md) - System design patterns
