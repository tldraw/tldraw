---
title: tldraw sync
status: published
author: alex
date: 7/11/2024
order: 7
keywords:
  - data
  - sync
  - persistence
  - database
  - multiplayer
  - collaboration
  - server
  - websockets
---

You can add realtime multi-user collaboration to your tldraw app by using **tldraw sync**. It's our library for fast, fault-tolerant shared document syncing, and is used in production on our flagship app [tldraw.com](https://tldraw.com).

We offer a [hosted demo](/docs/collaboration#tldraw-sync-demo) of tldraw sync which is suitable for prototyping. To use tldraw sync in production, you will need to host it yourself.

## Deploying tldraw sync

There are two main ways to go about hosting tldraw sync:

1. Deploy a full backend to Cloudflare using our template (recommended).
2. Integrate tldraw sync into your own JavaScript backend using our examples and docs as a guide.

### Use our Cloudflare template

The best way to get started hosting your own backend is to clone and deploy [our Cloudflare template](https://github.com/tldraw/tldraw-sync-cloudflare). The template provides a production-grade minimal setup of the system that runs on tldraw.com.

It uses:

- [Durable Objects](https://developers.cloudflare.com/durable-objects/) to provide a unique WebSocket server per room.
- [R2](https://developers.cloudflare.com/r2/) to persist document snapshots and store large binary assets like images and videos.

There are some features that we have not provided and you might want to add yourself:

- Authentication and authorization.
- Rate limiting and size limiting for asset uploads.
- Storing snapshots of documents over time for long-term history.
- Listing and searching for rooms.

Make sure you also read the section below about [deployment concerns](#deployment-concerns).

[Get started with the Cloudflare template](https://github.com/tldraw/tldraw-sync-cloudflare).

### Integrate tldraw sync into your own backend

We recommend using Cloudflare, but the `@tldraw/sync-core` library can be used to integrate tldraw sync into any JavaScript server environment that supports WebSockets.

We have a [custom Socket.IO server example](https://github.com/tldraw/tldraw/tree/main/templates/custom-server-example) that shows how to integrate tldraw sync with Socket.IO instead of standard WebSockets. We also have a [simple server example](https://github.com/tldraw/tldraw/tree/main/templates/simple-server-example), supporting both NodeJS and Bun, to use as a reference for how things should be stitched together.

## What does a tldraw sync backend do?

A backend for tldraw sync consists of two or three parts:

- A **WebSocket server** that provides rooms for each shared document, and is responsible for synchronizing and persisting document state.
- An **asset storage** provider for large binary files like images and videos.
- (If using the built-in bookmark shape) An **unfurling service** to extract metadata about bookmark URLs.

On the frontend, there is just one part: the **sync client**, created using the [`useSync`](?) hook from the `@tldraw/sync` package.

Pulling all four of these together, here's what a simple client implementation might look like:

```tsx
import { Tldraw, TLAssetStore, Editor } from 'tldraw'
import { useSync } from '@tldraw/sync'
import { uploadFileAndReturnUrl } from './assets'
import { convertUrlToBookmarkAsset } from './unfurl'

function MyEditorComponent({myRoomId}) {
	// This hook creates a sync client that manages the websocket connection to the server
	// and coordinates updates to the document state.
	const store = useSync({
		// This is how you tell the sync client which server and room to connect to.
		uri: `wss://my-custom-backend.com/connect/${myRoomId}`,
		// This is how you tell the sync client how to store and retrieve blobs.
		assets: myAssetStore,
	})
	// When the tldraw Editor mounts, you can register an asset handler for the bookmark URLs.
	return <Tldraw store={store} onMount={registerUrlHandler} />
}

const myAssetStore: TLAssetStore {
	upload(file, asset) {
		return uploadFileAndReturnUrl(file)
	},
	resolve(asset) {
		return asset.props.src
	},
}

function registerUrlHandler(editor: Editor) {
	editor.registerExternalAssetHandler('url', async ({url}) => {
		return await convertUrlToBookmarkAsset(url)
	})
}
```

And [here's a full working example](https://github.com/tldraw/tldraw/blob/main/templates/simple-server-example/src/client/App.tsx) of the client-side code.

### WebSocket server

The `@tldraw/sync-core` package exports a class called [`TLSocketRoom`](?) that should be created server-side on a per-document basis.

`TLSocketRoom` is used to

- Store an authoritative in-memory copy of the document state
- Transparently set up communication between multiple sync clients via WebSockets.
- Provide hooks for persisting the document state when it changes.

<Callout type="info">
	You should make sure that there's only ever one `TLSocketRoom` globally for each room in your app.
	If there's more than one, users won't see each other and will overwrite others' changes. We use
	[Durable Objects](https://developers.cloudflare.com/durable-objects/) to achieve this on
	tldraw.com.
</Callout>

Read the reference docs for [`TLSocketRoom`](?), and see an example of how to use it in the [simple server example](https://github.com/tldraw/tldraw/blob/main/templates/simple-server-example/src/server/rooms.ts).

### Sync client

On the client side, the `@tldraw/sync-core` package exports a class called [`TLSyncClient`](?) that handles the connection and synchronization with the server.

<Callout type="warning">
	**Advanced usage only:** Most applications should use the [`useSync`](?) hook from the
	`@tldraw/sync` package instead of creating `TLSyncClient` directly. The `useSync` hook handles all
	the complexity of setting up the sync client, managing presence, and integrating with React
	components.
</Callout>

`TLSyncClient` is used to:

- Establish and maintain a WebSocket connection to the server
- Send local changes to the server and apply remote changes from other clients
- Handle network interruptions and reconnections automatically
- Manage optimistic updates and conflict resolution
- Synchronize user presence information (cursors, selections, etc.)

#### When to use TLSyncClient directly

You might need to create `TLSyncClient` directly if you're:

- Building a non-React application
- Implementing custom connection logic or error handling
- Need fine-grained control over the sync lifecycle
- Building a custom integration with a different UI framework

#### Direct usage example

Here's a complete advanced usage example that mirrors how `useSync` works internally:

```tsx
import {
	TLSyncClient,
	TLSyncErrorCloseEventReason,
	type TLPresenceMode,
	type TLPersistentClientSocket,
} from '@tldraw/sync-core'
import {
	createTLStore,
	InstancePresenceRecordType,
	getDefaultUserPresence,
	getUserPreferences,
	defaultUserPreferences,
	TAB_ID,
	uniqueId,
} from 'tldraw'
import { atom, computed, transact } from '@tldraw/state'
import { io, type Socket } from 'socket.io-client'

// Generate unique identifiers
const storeId = uniqueId()
const roomId = 'my-room-123'

// User preferences (in real app, this would come from your auth system)
const userPreferences = {
	id: 'user-' + uniqueId(),
	name: 'John Doe',
	color: '#ff0000',
}

// Manual Socket.IO implementation
import { io, type Socket } from 'socket.io-client'

// Create Socket.IO connection
const ioSocket = io('wss://my-server.com', {
	query: {
		sessionId: TAB_ID,
		storeId: storeId,
		roomId: roomId,
	},
})

// Implement TLPersistentClientSocket manually
const socket: TLPersistentClientSocket = {
	connectionStatus: 'offline',

	sendMessage: (message) => {
		console.log('📤 Sending:', message)
		// Send tldraw sync protocol messages via Socket.IO
		ioSocket.emit('tldraw-message', message)
	},

	onReceiveMessage: (callback) => {
		// Listen for tldraw sync protocol messages
		const handler = (message: any) => {
			console.log('📥 Received:', message)
			callback(message)
		}

		ioSocket.on('tldraw-message', handler)

		// Return cleanup function
		return () => {
			ioSocket.off('tldraw-message', handler)
		}
	},

	onStatusChange: (callback) => {
		// Map Socket.IO events to TLPersistentClientSocket status
		const connectHandler = () => {
			;(socket as any).connectionStatus = 'online'
			callback({ status: 'online' })
		}

		const disconnectHandler = () => {
			;(socket as any).connectionStatus = 'offline'
			callback({ status: 'offline' })
		}

		const errorHandler = (error: any) => {
			;(socket as any).connectionStatus = 'error'
			callback({
				status: 'error',
				reason: error.message || 'Connection error',
			})
		}

		ioSocket.on('connect', connectHandler)
		ioSocket.on('disconnect', disconnectHandler)
		ioSocket.on('connect_error', errorHandler)

		// Set initial status
		if (ioSocket.connected) {
			;(socket as any).connectionStatus = 'online'
			setTimeout(() => callback({ status: 'online' }), 0)
		}

		// Return cleanup function
		return () => {
			ioSocket.off('connect', connectHandler)
			ioSocket.off('disconnect', disconnectHandler)
			ioSocket.off('connect_error', errorHandler)
		}
	},

	restart: () => {
		console.log('🔄 Restarting Socket.IO connection...')
		ioSocket.disconnect()
		ioSocket.connect()
	},
}

// Track connection status for collaboration UX
const collaborationStatus = computed('collaboration status', () =>
	socket.connectionStatus === 'error' ? 'offline' : socket.connectionStatus
)

// Track read/write mode
const syncMode = atom('sync mode', 'readwrite' as 'readonly' | 'readwrite')

// Create the store with collaboration status
const store = createTLStore({
	id: storeId,
	// Pass your schema, assets, etc. here
	collaboration: {
		status: collaborationStatus,
		mode: syncMode,
	},
})

// Create presence signal using tldraw's built-in logic
const presence = computed('instancePresence', () => {
	const presenceState = getDefaultUserPresence(store, userPreferences)
	if (!presenceState) return null

	return InstancePresenceRecordType.create({
		...presenceState,
		id: InstancePresenceRecordType.createId(store.id),
	})
})

// Track other users for presence mode
const otherUserPresences = store.query.ids('instance_presence', () => ({
	userId: { neq: userPreferences.id },
}))

const presenceMode = computed<TLPresenceMode>('presenceMode', () => {
	if (otherUserPresences.get().size === 0) return 'solo'
	return 'full'
})

// Track cancellation state
let didCancel = false

// Create the sync client (mirrors useSync implementation)
const client = new TLSyncClient({
	store,
	socket,
	presence,
	presenceMode,
	didCancel: () => didCancel,

	onLoad: (client) => {
		console.log('✅ Sync client loaded and ready')
		// At this point, the store is synchronized and ready to use
		// You can now render your UI or perform other initialization
	},

	onSyncError: (reason) => {
		console.error('❌ Sync error:', reason)

		// Handle specific error types
		switch (reason) {
			case TLSyncErrorCloseEventReason.NOT_FOUND:
				console.error('Room not found')
				break
			case TLSyncErrorCloseEventReason.FORBIDDEN:
				console.error('Access forbidden')
				break
			case TLSyncErrorCloseEventReason.NOT_AUTHENTICATED:
				console.error('Authentication required')
				break
			case TLSyncErrorCloseEventReason.RATE_LIMITED:
				console.error('Rate limited - too many requests')
				break
			case TLSyncErrorCloseEventReason.ROOM_FULL:
				console.error('Room is full')
				break
			default:
				console.error('Unknown sync error:', reason)
		}

		// Clean up on error
		socket.close()
	},

	onAfterConnect: (client, { isReadonly }) => {
		console.log('🔄 Connected to room', { isReadonly })

		// Update sync mode and ensure store is usable
		transact(() => {
			syncMode.set(isReadonly ? 'readonly' : 'readwrite')
			store.ensureStoreIsUsable()
		})
	},

	// Optional: Handle custom messages
	onCustomMessageReceived: (message) => {
		console.log('📨 Custom message:', message)
		// Process your custom server messages here
	},
})

// Example: Send custom messages to server
function sendCustomMessage(type: string, data: any) {
	if (socket.connectionStatus === 'online') {
		socket.sendMessage({
			type: 'custom' as any, // Extend the protocol
			customType: type,
			data,
		})
	}
}

// Example: Update user presence manually
function updateUserCursor(x: number, y: number) {
	const current = presence.get()
	if (current) {
		// The presence signal will automatically sync to other users
		// This is handled by TLSyncClient's internal reactivity
		store.put([
			{
				...current,
				cursor: { x, y, type: 'default', rotation: 0 },
			},
		])
	}
}

// Cleanup function
function cleanup() {
	didCancel = true
	client.close()
	socket.close()
}

// The store is now ready to use with tldraw:
// <Tldraw store={store} />
```

#### Alternative transport implementations

Here are examples of implementing `TLPersistentClientSocket` with other transport layers:

**Raw WebSocket:**

```tsx
const ws = new WebSocket('wss://my-server.com/sync')

const socket: TLPersistentClientSocket = {
	connectionStatus: 'offline',

	sendMessage: (message) => {
		if (ws.readyState === WebSocket.OPEN) {
			ws.send(JSON.stringify(message))
		}
	},

	onReceiveMessage: (callback) => {
		const handler = (event: MessageEvent) => {
			callback(JSON.parse(event.data))
		}
		ws.addEventListener('message', handler)
		return () => ws.removeEventListener('message', handler)
	},

	onStatusChange: (callback) => {
		const openHandler = () => {
			;(socket as any).connectionStatus = 'online'
			callback({ status: 'online' })
		}
		const closeHandler = () => {
			;(socket as any).connectionStatus = 'offline'
			callback({ status: 'offline' })
		}
		const errorHandler = () => {
			;(socket as any).connectionStatus = 'error'
			callback({ status: 'error', reason: 'WebSocket error' })
		}

		ws.addEventListener('open', openHandler)
		ws.addEventListener('close', closeHandler)
		ws.addEventListener('error', errorHandler)

		return () => {
			ws.removeEventListener('open', openHandler)
			ws.removeEventListener('close', closeHandler)
			ws.removeEventListener('error', errorHandler)
		}
	},

	restart: () => {
		ws.close()
		// You'd need to recreate the WebSocket here
	},
}
```

**Custom HTTP polling:**

```tsx
let pollInterval: NodeJS.Timeout
let messageHandlers: Array<(message: any) => void> = []

const socket: TLPersistentClientSocket = {
	connectionStatus: 'offline',

	sendMessage: async (message) => {
		try {
			await fetch('/api/sync/send', {
				method: 'POST',
				body: JSON.stringify({ roomId, message }),
				headers: { 'Content-Type': 'application/json' },
			})
		} catch (error) {
			console.error('Failed to send message:', error)
		}
	},

	onReceiveMessage: (callback) => {
		messageHandlers.push(callback)

		// Start polling if not already polling
		if (!pollInterval) {
			pollInterval = setInterval(async () => {
				try {
					const response = await fetch(`/api/sync/poll?roomId=${roomId}`)
					const messages = await response.json()
					messages.forEach((msg: any) => {
						messageHandlers.forEach((handler) => handler(msg))
					})
				} catch (error) {
					console.error('Polling error:', error)
				}
			}, 1000) // Poll every second
		}

		return () => {
			messageHandlers = messageHandlers.filter((h) => h !== callback)
			if (messageHandlers.length === 0 && pollInterval) {
				clearInterval(pollInterval)
				pollInterval = null
			}
		}
	},

	onStatusChange: (callback) => {
		// Simulate connection status
		setTimeout(() => callback({ status: 'online' }), 100)
		return () => {}
	},

	restart: () => {
		// Restart polling logic
	},
}
```

### Asset storage

As well as synchronizing the rapidly-changing document data, tldraw also needs a way to store and
retrieve large binary assets like images or videos.

You'll need to make sure your backend can handle asset uploads & downloads, then implement
[`TLAssetStore`](?) to connect it to tldraw.

- Read about [how assets work in tldraw](/docs/assets).
- Read the [`TLAssetStore`](?) reference docs.
- See a complete example of an asset store in the
  [`tldraw-sync-cloudflare`](https://github.com/tldraw/tldraw/blob/main/templates/sync-cloudflare/client/multiplayerAssetStore.tsx)
  template.

### Unfurling service

If you want to use the built-in bookmark shape, you'll need to use or implement an unfurling service that returns metadata about URLs.

This should be registered with the [`Editor`](?) when it loads.

```tsx
<Tldraw
	store={store}
	onMount={(editor) => {
		editor.registerExternalAssetHandler('url', unfurlBookmarkUrl)
	}}
/>
```

Refer to the simple server example for example [client](https://github.com/tldraw/tldraw/blob/main/templates/simple-server-example/src/client/App.tsx) and [server](https://github.com/tldraw/tldraw/blob/main/templates/simple-server-example/src/server/unfurl.ts) code.

## Using tldraw sync in your app

### Custom shapes & bindings

`@tldraw/sync` validates the contents of your document and runs migrations to make sure clients of
different versions can collaborate without issue. To support this, you need to make sure that both
the sync client and server know about any custom shapes or bindings you've added.

#### On the client

You can pass `shapeUtils` and `bindingUtils` props to `useSync`. Unlike `<Tldraw />`,
these don't automatically include tldraw's default shapes like arrows and rectangles. You should
pass those in explicitly if you're using them:

```tsx
import { Tldraw, defaultShapeUtils, defaultBindingUtils } from 'tldraw'
import { useSync } from '@tldraw/sync'

function MyApp() {
	const store = useSync({
		uri: '...',
		assets: myAssetStore,
		shapeUtils: useMemo(() => [...customShapeUtils, ...defaultShapeUtils], []),
		bindingUtils: useMemo(() => [...customBindingUtils, ...defaultBindingUtils], []),
	})

	return <Tldraw store={store} shapeUtils={customShapeUtils} bindingUtils={customBindingUtils} />
}
```

#### On the server

Use [`createTLSchema`](?) to create a store schema, and pass that into [`TLSocketRoom`](?). You can
use shape/binding utils here, but schema will only look at two properties:
[`props`](/reference/editor/ShapeUtil#props) and
[`migrations`](/docs/persistence#Shape-props-migrations). You need to provide the default shape
schemas if you're using them.

```tsx
import { createTLSchema, defaultShapeSchemas, defaultBindingSchemas } from '@tldraw/tlschema'
import { TLSocketRoom } from '@tldraw/sync-core'

const schema = createTLSchema({
	shapes: {
		...defaultShapeSchemas,

		myCustomShape: {
			// Validations for this shapes `props`.
			props: myCustomShapeProps,
			// Migrations between versions of this shape.
			migrations: myCustomShapeMigrations,
		},

		// The schema knows about this shape, but it has no migrations or validation.
		mySimpleShape: {},
	},
	bindings: defaultBindingSchemas,
})

// Later, in your app server:
const room = new TLSocketRoom({
	schema: schema,
	// ...
})
```

Both `props` and `migration` are optional. If you omit `props`, you won't have any server-side
validation for your shape, which could result in bad data being stored. If you omit `migrations`,
clients on different versions won't be able to collaborate without errors.

### Deployment concerns

<Callout type="warning">
	You must make sure that the tldraw version in your client matches the version on the server. We
	don't guarantee server backwards compatibility forever, and very occasionally we might release a
	version where the backend cannot meaningfully support older clients, in which case tldraw will
	display a "please refresh the page" message. So you should make sure that the backend is updated
	at the same time as the client, and that the new backend is up and running just before the new
	client rolls out.
</Callout>

### Migrating data from a legacy system

If you have been using some other solution for data sync, you can migrate your existing data to the tldraw sync format.

[`TLSocketRoom`](?) supports loading [`TLStoreSnapshot`](?) snapshots, so in your data loading code you can add a backwards-compatibility layer that lazily imports data from your old system and converts it to a `TLStoreSnapshot`.

Something like

```tsx
import { TLSocketRoom } from '@tldraw/sync-core'

async function loadOrMakeRoom(roomId: string) {
	const data = await loadRoomDataFromCurrentStore(roomId)
	if (data) {
		return new TLSocketRoom({ initialSnapshot: data })
	}
	const legacyData = await loadRoomDataFromLegacyStore(roomId)
	if (legacyData) {
		// Convert your old data to a TLStoreSnapshot.
		const snapshot = convertOldDataToSnapshot(legacyData)
		// Load it into the room.
		const room = new TLSocketRoom({ initialSnapshot: snapshot })
		// Save an updated copy of the snapshot in the new place
		// so that next time we can load it directly.
		await saveRoomData(roomId, room.getCurrentSnapshot())
		// Optionally delete the old data.
		await deleteLegacyRoomData(roomId)
		// And finally return the room.
		return room
	}
	// If there's no data at all, just make a new blank room.
	return new TLSocketRoom()
}
```
