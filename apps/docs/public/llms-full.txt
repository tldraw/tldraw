# tldraw SDK Examples

## Tldraw component

Keywords: basic, intro, simple, quick, start

The `Tldraw` component provides the tldraw editor as a regular React component. You can put this component anywhere in your React project. In this example, we make the component take up the height and width of the container.

By default, the component does not persist between refreshes or sync locally between tabs. To keep your work after a refresh, check the [`persistenceKey`](https://tldraw.dev/examples/basic/peristence-key) example.

### App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function BasicExample() {
	return (
		<>
			<div className="tldraw__editor">
				<Tldraw persistenceKey="example"></Tldraw>
			</div>
		</>
	)
}
```

## Custom renderer

Keywords: html, canvas, background, context

You can _sort of_ use a custom renderer with tldraw.

This example shows how you might use a custom renderer with tldraw.

### App.tsx

```tsx
import { useLayoutEffect } from 'react'
import { DefaultCanvas, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import { CustomRenderer } from './CustomRenderer'

export default function CustomRendererExample() {
	useLayoutEffect(() => {
		// Hide the regular shapes layer using CSS.
		const script = document.createElement('style')
		if (!script) return
		script.innerHTML = `.tl-shapes { display: none; }`
		document.body.appendChild(script)
		return () => {
			script.remove()
		}
	})

	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="example"
				components={{
					// We're replacing the Background component with our custom renderer
					Background: CustomRenderer,
					// Even though we're hiding the shapes, we'll still do a bunch of work
					// in react to figure out which shapes to create. In reality, you might
					// want to set the Canvas component to null and render it all yourself.
					Canvas: DefaultCanvas,
				}}
			/>
		</div>
	)
}
```
### CustomRenderer.tsx

```tsx
import { useLayoutEffect, useRef } from 'react'
import { TLDrawShape, TLGeoShape, getDefaultColorTheme, useEditor } from 'tldraw'

export function CustomRenderer() {
	const editor = useEditor()
	const rCanvas = useRef<HTMLCanvasElement>(null)

	useLayoutEffect(() => {
		const canvas = rCanvas.current
		if (!canvas) return

		canvas.style.width = '100%'
		canvas.style.height = '100%'

		const rect = canvas.getBoundingClientRect()

		canvas.width = rect.width
		canvas.height = rect.height

		const ctx = canvas.getContext('2d')!

		let raf = -1

		function render() {
			if (!canvas) return

			ctx.resetTransform()
			ctx.clearRect(0, 0, canvas.width, canvas.height)

			const camera = editor.getCamera()
			ctx.scale(camera.z, camera.z)
			ctx.translate(camera.x, camera.y)

			const renderingShapes = editor.getRenderingShapes()
			const theme = getDefaultColorTheme({ isDarkMode: editor.user.getIsDarkMode() })
			const currentPageId = editor.getCurrentPageId()

			for (const { shape, opacity } of renderingShapes) {
				const maskedPageBounds = editor.getShapeMaskedPageBounds(shape)
				if (!maskedPageBounds) continue
				ctx.save()

				if (shape.parentId !== currentPageId) {
					ctx.beginPath()
					ctx.rect(
						maskedPageBounds.minX,
						maskedPageBounds.minY,
						maskedPageBounds.width,
						maskedPageBounds.height
					)
					ctx.clip()
				}

				ctx.beginPath()

				ctx.globalAlpha = opacity

				const transform = editor.getShapePageTransform(shape.id)
				ctx.transform(transform.a, transform.b, transform.c, transform.d, transform.e, transform.f)

				if (editor.isShapeOfType<TLDrawShape>(shape, 'draw')) {
					// Draw a freehand shape
					for (const segment of shape.props.segments) {
						ctx.moveTo(segment.points[0].x, segment.points[0].y)
						if (segment.type === 'straight') {
							ctx.lineTo(segment.points[1].x, segment.points[1].y)
						} else {
							for (const point of segment.points.slice(1)) {
								ctx.lineTo(point.x, point.y)
							}
						}
					}
					ctx.strokeStyle = theme[shape.props.color].solid
					ctx.lineWidth = 4
					ctx.stroke()
					if (shape.props.fill !== 'none' && shape.props.isClosed) {
						ctx.fillStyle = theme[shape.props.color].semi
						ctx.fill()
					}
				} else if (editor.isShapeOfType<TLGeoShape>(shape, 'geo')) {
					// Draw a geo shape
					const bounds = editor.getShapeGeometry(shape).bounds
					ctx.strokeStyle = theme[shape.props.color].solid
					ctx.lineWidth = 2
					ctx.strokeRect(bounds.minX, bounds.minY, bounds.width, bounds.height)
				} else {
					// Draw any other kind of shape
					const bounds = editor.getShapeGeometry(shape).bounds
					ctx.strokeStyle = 'black'
					ctx.lineWidth = 2
					ctx.strokeRect(bounds.minX, bounds.minY, bounds.width, bounds.height)
				}
				ctx.restore()
			}

			raf = requestAnimationFrame(render)
		}

		render()

		return () => {
			cancelAnimationFrame(raf)
		}
	}, [editor])

	return <canvas ref={rCanvas} />
}
```

## Static assets

Keywords: icons, fonts, pre-load

Use custom fonts, icons, and preload them using the `Tldraw` component.

The `Tldraw` component relies on static assets for fonts and icons. These must be pre-loaded in order that the component runs properly.

### App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function StaticAssetsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="static-assets"
				assetUrls={{
					fonts: {
						// [1]
						tldraw_draw: '/ComicMono.woff',
					},
					icons: {
						'tool-arrow': '/custom-arrow-icon.svg',
					},
				}}
			/>
		</div>
	)
}

/**
These assets are stored in the /public folder of this Vite project, but this could be any URL.
By default, the Tldraw component will pull in assets from tldraw's asset CDN.
*/
```

## Persistence key

Keywords: local storage

If the `persistenceKey` prop is provided to the `<Tldraw/>` component, the editor will persist its data locally under that key.

### App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function PersistenceKeyExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example" />
		</div>
	)
}
```

## Read-only

Keywords: read, only mode

Use the editor in readonly mode.

If the `readonly` prop is provide to the `Tldraw` component, the editor won't allow a user to change the contents of the document. It will still allow the user to move the camera, select shapes, copy, and make other superficial changes.

### App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function ReadOnlyExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="example"
				onMount={(editor) => {
					editor.updateInstanceState({ isReadonly: true })
				}}
			/>
		</div>
	)
}

/* 
This example shows how to make the editor read-only. We use the `onMount` prop to
set the editor's `isReadonly` state to `true`. This will disable all editing
functionality and show only the select tool, hand tool and laser pointer on the
toolbar.
*/
```

## State and store

Keywords: signia, state, store, side, effects, subscribe, track

Tldraw uses signals to manage its state and store. You can subscribe to
values in the store and run side effects when they change.



### App.tsx

```tsx
import { TLComponents, Tldraw, track, useEditor, useReactor, useValue } from 'tldraw'
import 'tldraw/tldraw.css'

// [1]
const InfoPanel = track(() => {
	const editor = useEditor()
	const tool = editor.getCurrentToolId()
	const zoom = editor.getZoomLevel().toFixed(2)
	useReactor(
		'change title',
		() => {
			const shapes = editor.getCurrentPageShapes()
			document.title = `shapes: ${shapes.length}`
		},
		[editor]
	)
	return (
		<div style={{ pointerEvents: 'all', backgroundColor: 'thistle', fontSize: 14, padding: 8 }}>
			<div>tool: {tool}</div>
			<div>zoom: {zoom}</div>
		</div>
	)
})

// [2]
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function AlternativeInfoPanel() {
	const editor = useEditor()
	const tool = useValue(
		'current tool',
		() => {
			if (!editor) throw new Error('No editor')
			return `Current Tool: ${editor.getCurrentToolId()}`
		},
		[editor]
	)
	const zoom = useValue(
		'zoom',
		() => {
			if (!editor) throw new Error('No editor')
			return `Zoom Level: ${editor.getZoomLevel().toFixed(2)}`
		},
		[editor]
	)

	return (
		<div style={{ pointerEvents: 'all', backgroundColor: 'thistle', fontSize: 14, padding: 8 }}>
			<div>{tool}</div>
			<div>{zoom}</div>
		</div>
	)
}

const components: TLComponents = {
	SharePanel: InfoPanel,
}

export default function StateStoreExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw components={components} />
		</div>
	)
}

/* 

Tldraw uses signals to manage its state and store. You can subscribe to values in the store 
and run side effects when they change.

[1]
	Our InfoPanel component will display above the style panel. We want it to show the current
	selected tool and zoom level of the editor. In order to make sure it displays up-to-date
	information, we can wrap the component in the track function. This will track any signals
	used in the component and re-render it when they change. 
	
	We also use the useReactor hook to update the document title with the number of shapes. This 
	side effect will run whenever the shapes on the page change. We pass the editor as a 
	dependency to the useReactor hook so it will always have the latest editor instance. 
	useQuickReactor runs immediately, whereas useReactor runs on the next animation frame.

	Check out the Fog of War example to see useReactor in action.

[2]
	We can also use the useValue hook to subscribe to a value in the store. You can pass it a 
	value or a function. Functions will be memoized and only re-run when the dependencies change.

*/
```

## Deep Links

Keywords: basic, intro, simple, quick, start

Allow linking to specific parts of a tldraw document

Deep Links are URLs which point to a specific part of a document. We provide a comprehensive set of tools to help you create and manage deep links in your application.

## The `deepLinks` prop

The highest-level API for managing deep links is the `deepLinks` prop on the `<Tldraw />` component. This prop is designed for manipulating `window.location` to add a search param which tldraw can use to navigate to a specific part of the document.

e.g. `https://my-app.com/document-name?d=v1234.-234.3.21`

If you set `deepLinks` to `true` e.g. `<Tldraw deepLinks />` the following default behavior will be enabled:

1. When the editor initializes, before the initial render, it will check the current `window.location` for a search param called `d`. If found, it will try to parse the value of this param as a deep link and navigate to that part of the document.
2. 500 milliseconds after every time the editor finishes navigating to a new part of the document, it will update `window.location` to add the latest version of the `d` param.

You can customize this behavior by passing a configuration object as the `deepLinks` prop. e.g.

```tsx
<Tldraw
	deepLinks={{
		// change the param name to `page`
		paramName: 'page',
		// only link to the current page
		getTarget(editor) {
			return { type: 'page', pageId: editor.getCurrentPageId() }
		},
		// log the new search params to the console instead of updating `window.location`
		onChange(url) {
			console.log('the new search params are', url.searchParams)
		},
		// set the debounce interval to 100ms instead of 500ms
		debounceMs: 100,
	}}
/>
```

For full options see the [`TLDeepLinkOptions`](/reference/editor/TLDeepLinkOptions) API reference.

## Handling deep links manually

We expose the core functionality for managing deep links as a set of methods and utilities. This gives you more control e.g. if you prefer not to use search params in the URL.

### Creating a deep link

You can create an isolated deep link string using the [`createDeepLinkString`](/reference/editor/createDeepLinkString) helper which takes a [`TLDeepLink`](/reference/editor/TLDeepLink) descriptor object.

```tsx
createDeepLinkString({ type: 'page', pageId: 'page:abc123' })
// => 'pabc123'
createDeepLinkString({ type: 'shapes', shapeIds: ['shape:foo', 'shape:bar'] })
// => 'sfoo.bar'
createDeepLinkString({
	type: 'viewport',
	pageId: 'page:abc123',
	bounds: {
		x: 0,
		y: 0,
		w: 1024,
		h: 768,
	},
})
// => 'v0.0.1024.768.abc123'
```

If you do prefer to put this in a URL as a query param, you can use the [`Editor.createDeepLink`](/reference/editor/Editor#createDeepLink) method.

```tsx
editor.createDeepLink({ to: { type: 'page', pageId: 'page:abc123' } })
// => 'https://my-app.com/document-name?d=pabc123'
```

### Handling a deep link

You can parse a deep link string with [`parseDeepLinkString`](/reference/editor/parseDeepLinkString) which returns a [`TLDeepLink`](/reference/editor/TLDeepLink) descriptor object.

You can then call [`Editor.navigateToDeepLink`](/reference/editor/Editor#navigateToDeepLink) with this descriptor to navigate to the part of the document described by the deep link.

`Editor#navigateToDeepLink` also can take a plain URL if the deep link is encoded as a query param.

```tsx
editor.navigateToDeepLink(parseDeepLinkString('pabc123'))
// or pass in a url
editor.navigateToDeepLink({ url: 'https://my-app.com/document-name?d=pabc123' })
// or call without options to use the current `window.location`
editor.navigateToDeepLink()
```

### Listening for deep link changes

You can listen for deep link changes with the [`Editor.registerDeepLinkListener`](/reference/editor/Editor#registerDeepLinkListener) method, which takes the same options as the `deepLinks` prop.

```tsx
useEffect(() => {
	const unlisten = editor.registerDeepLinkListener({
		paramName: 'page',
		getTarget(editor) {
			return { type: 'page', pageId: editor.getCurrentPageId() }
		},
		onChange(url) {
			console.log('the new search params are', url.searchParams)
		},
		debounceMs: 100,
	})
	return () => {
		unlisten()
	}
}, [])
```

### App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function DeepLinksExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example" deepLinks />
		</div>
	)
}
```

## Force mobile

Keywords: force, mobile, breakpoint

Force the editor UI to render as if it were on a mobile device.



### App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function ForceMobileExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example" forceMobile />
		</div>
	)
}

/* 
This example shows how you can force the editor to use the mobile breakpoint.
Simply pass the `forceMobile` prop to the editor component.
*/
```

## Custom options

Keywords: 

Use the `options` property to override tldraw's options. In this example, we limit the maximum
number of pages to 3, and slow down camera animations like zoom in and zoom out.



### App.tsx

```tsx
import { Tldraw, TldrawOptions } from 'tldraw'
import 'tldraw/tldraw.css'

const options: Partial<TldrawOptions> = {
	maxPages: 3,
	animationMediumMs: 5000,
}

export default function CustomOptionsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example" options={options} />
		</div>
	)
}
```

## Custom paste

Keywords: 

Use the tldraw external content handler to tweak how pasting works.

This example adds a special rule for pasting single frame shapes, so they'll try to find an empty space instead of always pasting in the location they were copied from.

### App.tsx

```tsx
import {
	defaultHandleExternalTldrawContent,
	Editor,
	Tldraw,
	TLFrameShape,
	TLTldrawExternalContent,
} from 'tldraw'

// this example adds special behavior when pasting a single frame shape, matching the behavior of figma
export default function CustomPasteExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					// on mount, override the default tldraw handler
					editor.registerExternalContentHandler('tldraw', (content) =>
						handleCustomTldrawPaste(editor, content)
					)
				}}
			/>
		</div>
	)
}

const SPACING_BETWEEN_FRAMES = 50

function handleCustomTldrawPaste(editor: Editor, { content, point }: TLTldrawExternalContent) {
	// find the only shape in the pasted content
	const onlyCopiedShape =
		content.rootShapeIds.length === 1
			? content.shapes.find((shape) => shape.id === content.rootShapeIds[0])
			: null

	// make sure that the shape is a frame. if it is, retrieve the current version of that frame
	// from the document.
	const onlyCopiedFrame =
		onlyCopiedShape?.type === 'frame' ? (onlyCopiedShape as TLFrameShape) : null

	// we only want to use our special behavior if the frame (current & pasted) will be a direct
	// descendant of the current page.
	const willPasteOnCurrentPage = onlyCopiedFrame
		? !editor.getShape(onlyCopiedFrame.parentId)
		: false

	// if the paste is happening at a specific point, or we didn't copy a single frame that belongs
	// to this page, fall back to the default paste behavior
	if (point || !onlyCopiedFrame || !willPasteOnCurrentPage) {
		defaultHandleExternalTldrawContent(editor, { content, point })
		return
	}

	// if we are pasting a single frame, and that frame is still in the document, we want to find a
	// free space to the right of the frame to put this one.
	editor.putContentOntoCurrentPage(content, { select: true })
	const newlyPastedFrame = editor.getOnlySelectedShape()
	if (!newlyPastedFrame || !editor.isShapeOfType<TLFrameShape>(newlyPastedFrame, 'frame')) return

	const siblingIds = editor.getSortedChildIdsForParent(newlyPastedFrame.parentId)
	const pastedBounds = editor.getShapePageBounds(newlyPastedFrame.id)!
	let targetPosition = pastedBounds.minX

	const siblingBounds = siblingIds
		.map((id) => ({ id, bounds: editor.getShapePageBounds(id)! }))
		.sort((a, b) => a.bounds.minX - b.bounds.minX)

	for (const sibling of siblingBounds) {
		if (sibling.id === newlyPastedFrame.id) continue

		// if this sibling is above or below the copied frame, we don't need to take it into account
		if (sibling.bounds.minY > pastedBounds.maxY || sibling.bounds.maxY < pastedBounds.minY) continue

		// if the sibling is to the left of the copied frame, we don't need to take it into account
		if (sibling.bounds.maxX < targetPosition) continue

		// if the sibling is to the right of where the pasted frame would end up, we don't care about it
		if (sibling.bounds.minX > targetPosition + pastedBounds.w) continue

		// otherwise, we need to shift our target right edge to the right of this sibling
		targetPosition = sibling.bounds.maxX + SPACING_BETWEEN_FRAMES
	}

	// translate the pasted frame into position:
	editor.nudgeShapes([newlyPastedFrame.id], {
		x: targetPosition - pastedBounds.minX,
		y: 0,
	})
}
```

## Infer dark mode

Keywords: props

When the `Tldraw` component's `inferDarkMode` is true, the editor will infer its initial theme based on the user's system preferences, if available. You can toggle the dark mode by pressing `Command + /`.

### App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function InferDarkModeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw inferDarkMode />
		</div>
	)
}
```

## Inset editor

Keywords: inline

The `<Tldraw/>` component may be placed in any layout, even if it's not full-screen. In this example, the editor is inset within the screen layout. The component's interactions should still behave as you'd expect them to.



### App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function InsetExample() {
	return (
		<div style={{ position: 'absolute', inset: 100 }}>
			<div className="tldraw__editor">
				<Tldraw />
			</div>
		</div>
	)
}
```

## Scrolling container

Keywords: focus, mouse wheel

Use the editor inside a scrollable container.

The `Tldraw` component can be used inside of any layout, including a scrollable container. Note that the editor will accept mousewheel events unless it is "unfocused".

### App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function ScrollExample() {
	return (
		<div
			style={{
				width: '150vw',
				height: '150vh',
				display: 'flex',
				justifyContent: 'center',
				alignItems: 'center',
				backgroundColor: '#fff',
			}}
		>
			<div style={{ width: '60vw', height: '80vh' }}>
				<Tldraw persistenceKey="scroll-example" autoFocus={true} />
			</div>
		</div>
	)
}

/*
This example shows how you can use the Tldraw component inside a scrollable container. 
The component will still accept mousewheel events while "focused". Try turning off the
autoFocus prop to see the difference.
*/
```

## Multiple editors

Keywords: multiple, focus

Use multiple `<Tldraw/>` components on the same page.



### App.tsx

```tsx
import { createContext, useCallback, useContext, useState } from 'react'
import { Editor, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this page!

// [1]
const focusedEditorContext = createContext(
	{} as {
		focusedEditor: Editor | null
		setFocusedEditor(id: Editor | null): void
	}
)

// [2]
export default function MultipleExample() {
	const [focusedEditor, _setFocusedEditor] = useState<Editor | null>(null)

	const setFocusedEditor = useCallback(
		(editor: Editor | null) => {
			if (focusedEditor !== editor) {
				if (focusedEditor) {
					focusedEditor.blur()
				}
				if (editor) {
					editor.focus()
				}
				_setFocusedEditor(editor)
			}
		},
		[focusedEditor]
	)

	const focusName =
		focusedEditor === (window as any).EDITOR_A
			? 'A'
			: focusedEditor === (window as any).EDITOR_B
				? 'B'
				: focusedEditor === (window as any).EDITOR_C
					? 'C'
					: 'none'

	return (
		<div
			style={{
				padding: 32,
			}}
			// Sorry you need to do this yourself
			onPointerDown={() => setFocusedEditor(null)}
		>
			<focusedEditorContext.Provider value={{ focusedEditor, setFocusedEditor }}>
				<h1>Focusing: {focusName}</h1>
				<EditorA />
				<textarea data-testid="textarea" placeholder="type in me" style={{ margin: 10 }} />
				<div
					style={{
						width: '100%',
						display: 'grid',
						gridTemplateColumns: 'repeat(auto-fit, minmax(420px, 1fr))',
						gap: 64,
					}}
				>
					<EditorB />
					<EditorC />
				</div>
				<p>
					These two editors share the same persistence key so they will share a (locally)
					synchronized document.
				</p>
				<ABunchOfText />
			</focusedEditorContext.Provider>
		</div>
	)
}

// [3]
function EditorA() {
	const { setFocusedEditor } = useContext(focusedEditorContext)

	return (
		<div style={{ padding: 32 }}>
			<h2>A</h2>
			<div
				tabIndex={-1}
				onFocus={() => setFocusedEditor((window as any).EDITOR_A)}
				style={{ height: 600 }}
			>
				<Tldraw
					persistenceKey="steve"
					className="A"
					autoFocus={false}
					onMount={(editor) => {
						;(window as any).EDITOR_A = editor
						setFocusedEditor(editor)
					}}
				/>
			</div>
		</div>
	)
}

// [4]
function EditorB() {
	const { setFocusedEditor } = useContext(focusedEditorContext)

	return (
		<div>
			<h2>B</h2>
			<div
				tabIndex={-1}
				onFocus={() => setFocusedEditor((window as any).EDITOR_B)}
				style={{ height: 600 }}
			>
				<Tldraw
					persistenceKey="david"
					className="B"
					autoFocus={false}
					onMount={(editor) => {
						;(window as any).EDITOR_B = editor
					}}
				/>
			</div>
		</div>
	)
}

function EditorC() {
	const { setFocusedEditor } = useContext(focusedEditorContext)

	return (
		<div>
			<h2>C</h2>
			<div
				tabIndex={-1}
				onFocus={() => setFocusedEditor((window as any).EDITOR_C)}
				style={{ height: 600 }}
			>
				<Tldraw
					persistenceKey="david"
					className="C"
					autoFocus={false}
					onMount={(editor) => {
						;(window as any).EDITOR_C = editor
					}}
				/>
			</div>
		</div>
	)
}

// [5]
function ABunchOfText() {
	return (
		<article style={{ maxWidth: 500 }}>
			<h1>White Board</h1>
			<h2>Chapter 1: The First Strokes</h2>
			<p>
				The fluorescent lights flickered overhead as John sat hunched over his desk, his fingers
				tapping rhythmically on the keyboard. He was a software developer, and tonight, he had a
				peculiar mission. A mission that would take him deep into the labyrinthine world of web
				development. John had stumbled upon a new whiteboard library called “tldraw”, a seemingly
				simple tool that promised to revolutionize collaborative drawing on the web. Little did he
				know that this discovery would set off a chain of events that would challenge his skills,
				test his perseverance, and blur the line between reality and imagination.
			</p>
			<p>
				With a newfound sense of excitement, John began integrating “tldraw” into his latest
				project. As lines of code danced across his screen, he imagined the possibilities that lay
				ahead. The potential to create virtual spaces where ideas could be shared, concepts could be
				visualized, and teams could collaborate seamlessly from different corners of the world. It
				was a dream that seemed within reach, a vision of a future where creativity and technology
				merged into a harmonious symphony.
			</p>
			<p>
				As the night wore on, John’s mind became consumed with the whiteboard library. He couldn’t
				help but marvel at its elegance and simplicity. With each stroke of his keyboard, he felt a
				surge of inspiration, a connection to something greater than himself. It was as if the lines
				of code he was writing were transforming into a digital canvas, waiting to be filled with
				the strokes of imagination. In that moment, John realized that he was not just building a
				tool, but breathing life into a new form of expression. The whiteboard was no longer just a
				blank slate; it had become a portal to a world where ideas could flourish and dreams could
				take shape.
			</p>
			<p>
				Little did John know, this integration of “tldraw” was only the beginning. It would lead him
				down a path filled with unforeseen challenges, where he would confront his own limitations
				and question the very nature of creation. The journey ahead would test his resolve, pushing
				him to the edge of his sanity. And as he embarked on this perilous adventure, he could not
				shake the feeling that the whiteboard held secrets far beyond his understanding. Secrets
				that would unfold before his eyes, one stroke at a time.
			</p>
		</article>
	)
}

/* 
This example shows how to use multiple editors on the same page. When doing this, you'll
need to make sure that only one editor is focused at a time. We can manage this using 
the autofocus prop on the tldraw component, along with React's context and set state 
APIs.

[1]
We first create a context that will hold the focused editor id and a setter for that id. 
We'll use this to keep track of which editor is focused.

[2]
Wrap the editors in the context provider. This will make the context available to all
of the editors.

[3]	
Get the focused editor id and the setter from the context. We'll use these to determine
if the editor should be focused or not. We wrap the Tldraw component in a div and use 
the onFocus event to set the focused editor id. 

[4]
Same again, but we're using the same persistence key for editors B and C. This means
that they will share a document. 

[5]
A long story that doesn't really go anywhere, clearly written by a computer. But it's	
a good way to test the scroll behavior of the page.
*/
```

## Disable Pages

Keywords: basic, intro, simple, quick, start, page

Disabling page-related UI for single-page use cases.

You can set the `maxPages` option to `1` to disable the page selector and other UI related to managing pages.

### App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// You can set the `maxPages` option to 1 to disable UI related to managing multiple pages.

export default function DisablePagesExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="disable-pages" options={{ maxPages: 1 }} />
		</div>
	)
}
```

## Hidden UI components

Keywords: hide, ui, overrides

You can hide tldraw's UI components.

Custom UI components can be hidden providing a `null` as the value for a component in `components In this case, all configurable UI components are hidden.

### App.tsx

```tsx
import { TLUiComponents, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// The type here is include only to ensure this example contains all possible ui components,
const components: Required<TLUiComponents> = {
	ContextMenu: null,
	ActionsMenu: null,
	HelpMenu: null,
	ZoomMenu: null,
	MainMenu: null,
	Minimap: null,
	StylePanel: null,
	PageMenu: null,
	NavigationPanel: null,
	Toolbar: null,
	KeyboardShortcutsDialog: null,
	QuickActions: null,
	HelperButtons: null,
	DebugPanel: null,
	DebugMenu: null,
	SharePanel: null,
	MenuPanel: null,
	TopPanel: null,
	CursorChatBubble: null,
	RichTextToolbar: null,
	Dialogs: null,
	Toasts: null,
}

export default function UiComponentsHiddenExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw components={components} />
		</div>
	)
}
```

## Hide UI

Keywords: 

Hide tldraw's UI with the `hideUi` prop.

Useful for a bare-bones editor, or if you want to build your own UI.

### App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function HideUiExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="hide-ui-example" hideUi />
		</div>
	)
}

/* 
This example shows how to hide the UI of the editor. Simply pass the hideUi prop
to the Tldraw component. This is useful if you want to build your own UI around
the editor. See the custom ui example if you need help building your own UI.
*/
```

## Inset canvas

Keywords: 

Handling events when the canvas is inset within the editor.

If for some reason you need to move the canvas around, that should still work.

### App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import './inset-canvas.css'

export default function InsetCanvasExample() {
	return (
		<div className="tldraw__editor tldraw__editor-with-inset-canvas">
			<Tldraw />
		</div>
	)
}
```
### inset-canvas.css

```css
.tldraw__editor-with-inset-canvas .tl-canvas {
	position: absolute;
	inset: 100px 200px 100px 100px;
}
```

## Changing default colors

Keywords: colours, styles, palette, style panel

Change the tldraw theme colors.

While there's currently no way to add or remove our colors from our default shapes' colors, this example shows how you can adjust the values for the default color styles.

Note that this will change the colors for ALL instances of tldraw. For example, try loading this example and then loading another example—the changes will be present there too until you reload!

### App.tsx

```tsx
import { DefaultColorThemePalette, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

// [1]
DefaultColorThemePalette.lightMode.black.solid = 'aqua'

export default function ChangingDefaultColorsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example" />
		</div>
	)
}

/*

[1]
The default color theme is exported from the tldraw library. You can 
modify it directly outside of the React lifecycle, so that your changes
are used when the component mounts.

Remember that you can't add or remove colors here yet. These colors are
used by our default shapes and we need to make sure that we don't end
up with a color that we can't handle, or else this could get propagated
to other users in a multiplayer session.

At the moment, if you want to create new colors, you will need to create 
your own shapes that understand those colors. We're working on making 
this easier!
*/
```

## Changing default menus

Keywords: menu, panel, actions, style, toolbar, main, page, zoom, navigation, quick

Customize tldraw's menus.

You can use the `components` prop to override tldraw's default menus. You can provide a React component of your own, import our default component and edit it, or return null to hide it completely. This example demonstrates how to do this with every menu in tldraw.

### App.tsx

```tsx
import {
	DefaultActionsMenu,
	DefaultActionsMenuContent,
	DefaultColorStyle,
	DefaultContextMenu,
	DefaultContextMenuContent,
	DefaultDebugMenu,
	DefaultDebugMenuContent,
	DefaultHelpMenu,
	DefaultHelpMenuContent,
	DefaultKeyboardShortcutsDialog,
	DefaultKeyboardShortcutsDialogContent,
	DefaultMainMenu,
	DefaultMainMenuContent,
	DefaultPageMenu,
	DefaultQuickActions,
	DefaultQuickActionsContent,
	DefaultStylePanel,
	DefaultStylePanelContent,
	DefaultToolbar,
	DefaultToolbarContent,
	DefaultZoomMenu,
	DefaultZoomMenuContent,
	TLComponents,
	Tldraw,
	TldrawUiButton,
	TldrawUiButtonLabel,
	TldrawUiMenuGroup,
	TldrawUiMenuItem,
	TLUiContextMenuProps,
	TLUiKeyboardShortcutsDialogProps,
	TLUiStylePanelProps,
	useEditor,
	useIsToolSelected,
	useRelevantStyles,
	useTools,
} from 'tldraw'
import 'tldraw/tldraw.css'

//[1]

function CustomActionsMenu() {
	return (
		<div style={{ backgroundColor: 'thistle' }}>
			<DefaultActionsMenu>
				<div style={{ backgroundColor: 'thistle' }}>
					<TldrawUiMenuItem
						id="like"
						label="Like my posts"
						icon="external-link"
						readonlyOk
						onSelect={() => {
							window.open('https://x.com/tldraw', '_blank')
						}}
					/>
				</div>
				<DefaultActionsMenuContent />
			</DefaultActionsMenu>
		</div>
	)
}
//[2]
function CustomContextMenu(props: TLUiContextMenuProps) {
	return (
		<DefaultContextMenu {...props}>
			<TldrawUiMenuGroup id="example">
				<div style={{ backgroundColor: 'thistle' }}>
					<TldrawUiMenuItem
						id="like"
						label="Like my posts"
						icon="external-link"
						readonlyOk
						onSelect={() => {
							window.open('https://x.com/tldraw', '_blank')
						}}
					/>
				</div>
			</TldrawUiMenuGroup>
			<DefaultContextMenuContent />
		</DefaultContextMenu>
	)
}
//[3]
function CustomDebugMenu() {
	return (
		<div style={{ backgroundColor: 'thistle' }}>
			<DefaultDebugMenu>
				<DefaultDebugMenuContent />
				<div style={{ backgroundColor: 'thistle' }}>
					<TldrawUiMenuGroup id="example">
						<TldrawUiMenuItem
							id="like"
							label="Like my posts"
							icon="external-link"
							readonlyOk
							onSelect={() => {
								window.open('https://x.com/tldraw', '_blank')
							}}
						/>
					</TldrawUiMenuGroup>
				</div>
			</DefaultDebugMenu>
		</div>
	)
}
//[4]
function CustomHelpMenu() {
	return (
		<DefaultHelpMenu>
			<div style={{ backgroundColor: 'thistle' }}>
				<TldrawUiMenuGroup id="example">
					<TldrawUiMenuItem
						id="like"
						label="Like my posts"
						icon="external-link"
						readonlyOk
						onSelect={() => {
							window.open('https://x.com/tldraw', '_blank')
						}}
					/>
				</TldrawUiMenuGroup>
			</div>
			<DefaultHelpMenuContent />
		</DefaultHelpMenu>
	)
}
//[5]
function CustomKeyboardShortcutsDialog(props: TLUiKeyboardShortcutsDialogProps) {
	return (
		<DefaultKeyboardShortcutsDialog {...props}>
			<div style={{ backgroundColor: 'thistle' }}>
				<TldrawUiMenuItem
					id="like-my-posts"
					label="Like my posts"
					icon="external-link"
					readonlyOk
					kbd=":)"
					onSelect={() => {
						window.open('https://x.com/tldraw', '_blank')
					}}
				/>
			</div>
			<DefaultKeyboardShortcutsDialogContent />
		</DefaultKeyboardShortcutsDialog>
	)
}
//[6]
function CustomMainMenu() {
	return (
		<DefaultMainMenu>
			<div style={{ backgroundColor: 'thistle' }}>
				<TldrawUiMenuGroup id="example">
					<TldrawUiMenuItem
						id="like"
						label="Like my posts"
						icon="external-link"
						readonlyOk
						onSelect={() => {
							window.open('https://x.com/tldraw', '_blank')
						}}
					/>
				</TldrawUiMenuGroup>
			</div>
			<DefaultMainMenuContent />
		</DefaultMainMenu>
	)
}
//[7]
function CustomNavigationPanel() {
	return <div style={{ backgroundColor: 'thistle', padding: '14px' }}>here you are</div>
}
//[8]
function CustomPageMenu() {
	return (
		<div style={{ transform: 'rotate(3.14rad)', backgroundColor: 'thistle' }}>
			<DefaultPageMenu />
		</div>
	)
}
//[9]
function CustomQuickActions() {
	return (
		<DefaultQuickActions>
			<DefaultQuickActionsContent />
			<div style={{ backgroundColor: 'thistle' }}>
				<TldrawUiMenuItem id="code" icon="code" onSelect={() => window.alert('code')} />
			</div>
		</DefaultQuickActions>
	)
}
//[10]
function CustomStylePanel(props: TLUiStylePanelProps) {
	const editor = useEditor()

	// Styles are complex, sorry. Check our DefaultStylePanel for an example.

	const styles = useRelevantStyles()

	return (
		<DefaultStylePanel {...props}>
			<div style={{ backgroundColor: 'thistle' }}>
				<TldrawUiButton
					type="menu"
					onClick={() => {
						editor.setStyleForSelectedShapes(DefaultColorStyle, 'red')
					}}
				>
					<TldrawUiButtonLabel>Red</TldrawUiButtonLabel>
				</TldrawUiButton>
			</div>
			<div style={{ backgroundColor: 'thistle' }}>
				<TldrawUiButton
					type="menu"
					onClick={() => {
						editor.setStyleForSelectedShapes(DefaultColorStyle, 'green')
					}}
				>
					<TldrawUiButtonLabel>Green</TldrawUiButtonLabel>
				</TldrawUiButton>
			</div>
			<DefaultStylePanelContent styles={styles} />
		</DefaultStylePanel>
	)
}
//[11]
function CustomToolbar() {
	const editor = useEditor()
	const tools = useTools()
	const isScreenshotSelected = useIsToolSelected(tools['rhombus-2'])
	return (
		<div>
			<DefaultToolbar>
				<TldrawUiMenuItem {...tools['rhombus-2']} isSelected={isScreenshotSelected} />

				<DefaultToolbarContent />
				<button
					onClick={() => {
						editor.selectAll().deleteShapes(editor.getSelectedShapeIds())
					}}
					title="delete all"
				>
					🧨
				</button>
			</DefaultToolbar>
		</div>
	)
}
//[12]
function CustomZoomMenu() {
	return (
		<DefaultZoomMenu>
			<div style={{ backgroundColor: 'thistle' }}>
				<TldrawUiMenuGroup id="example">
					<TldrawUiMenuItem
						id="like"
						label="Like my posts"
						icon="external-link"
						readonlyOk
						onSelect={() => {
							window.open('https://x.com/tldraw', '_blank')
						}}
					/>
				</TldrawUiMenuGroup>
			</div>
			<DefaultZoomMenuContent />
		</DefaultZoomMenu>
	)
}
const components: TLComponents = {
	ActionsMenu: CustomActionsMenu,
	ContextMenu: CustomContextMenu,
	DebugMenu: CustomDebugMenu,
	HelpMenu: CustomHelpMenu,
	KeyboardShortcutsDialog: CustomKeyboardShortcutsDialog,
	MainMenu: CustomMainMenu,
	NavigationPanel: CustomNavigationPanel,
	PageMenu: CustomPageMenu,
	QuickActions: CustomQuickActions,
	StylePanel: CustomStylePanel,
	Toolbar: CustomToolbar,
	ZoomMenu: CustomZoomMenu,
}

export default function CustomActionsMenuExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw components={components} />
		</div>
	)
}

/*
You can use the `components` prop to override tldraw's default menus. 
You can provide a React component of your own, import our default 
component and edit it, or return null to hide it completely. This 
example demonstrates how to do this with every menu in tldraw.

[1]
	The actions menu is a dropdown menu that can be found in the 
	top-left of the tldraw component, or just above the toolbar on 
	smaller screens. It contains actions related to editing shapes 
	such as grouping, rotating or changing shape order. 

[2]
	Create some shapes, select them and right click the selection to 
	see the custom context menu.

[3]
	The debug menu contains helpful menu items for debugging the tldraw 
	component. To show the debug menu, turn on debug mode in the 
	preferences.
[4]
	The help menu contains menu items to change the language of the
	application, and to open the keyboard shortcuts dialog.


[5]
	The keyboard shortcuts dialog is a modal that shows all the 
	keyboard shortcuts available in tldraw. You can open it via the help
	menu.

[6]
	The main menu contains important submenus: Edit, Shape, Preferences etc. 
	To open the main menu, click the hamburger icon in the top left corner 
	of the tldraw component.

[7]
	The navigation panel is in the bottom left of the tldraw component at 
	larger breakpoints. It contains zoom controls and a mini map.

[8]
	The page menu contains options for creating and editing pages. To open 
	the page menu, click the page name in the top left of the tldraw component.

[9]
	The quick actions menu is a dropdown menu that appears in the Main Menu,
	or above the toolbar on smaller screens.

[10]
	The style panel is a panel that appears on the right side of the tldraw
	component. It contains options to change the style of shapes, such as
	color, stroke width, and opacity.

[11]
	The toolbar contains tools to create shapes, select shapes, and more.

[12]
	The zoom menu is in the bottom left of the tldraw component, the button 
	to open it is labeled with a percentage indicating the editor's current 
	zoom level.

 */
```

## Changing default style

Keywords: size, styles, default

Change the default value for a style prop.

Want to set the default value for a property to something other than it's built-in default? In this example we make the size style have small as its default calue.

### App.tsx

```tsx
import { DefaultSizeStyle, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

DefaultSizeStyle.setDefaultValue('s')

export default function ChangingDefaultStyleExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example" />
		</div>
	)
}
```

## Custom UI

Keywords: hide, ui, event listener

Replace tldraw's UI with your own.

This UI has keyboard shortcuts and buttons for selecting tools. If you want to see the editor methods associated with every part of the ui, check out the ui events example.

### App.tsx

```tsx
import { useEffect } from 'react'
import { Tldraw, track, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'
import './custom-ui.css'

// There's a guide at the bottom of this file!

// [1]
export default function CustomUiExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw hideUi>
				<CustomUi />
			</Tldraw>
		</div>
	)
}

// [2]
const CustomUi = track(() => {
	const editor = useEditor()

	useEffect(() => {
		const handleKeyUp = (e: KeyboardEvent) => {
			switch (e.key) {
				case 'Delete':
				case 'Backspace': {
					editor.deleteShapes(editor.getSelectedShapeIds())
					break
				}
				case 'v': {
					editor.setCurrentTool('select')
					break
				}
				case 'e': {
					editor.setCurrentTool('eraser')
					break
				}
				case 'x':
				case 'p':
				case 'b':
				case 'd': {
					editor.setCurrentTool('draw')
					break
				}
			}
		}

		window.addEventListener('keyup', handleKeyUp)
		return () => {
			window.removeEventListener('keyup', handleKeyUp)
		}
	})

	return (
		<div className="custom-layout">
			<div className="custom-toolbar">
				<button
					className="custom-button"
					data-isactive={editor.getCurrentToolId() === 'select'}
					onClick={() => editor.setCurrentTool('select')}
				>
					Select
				</button>
				<button
					className="custom-button"
					data-isactive={editor.getCurrentToolId() === 'draw'}
					onClick={() => editor.setCurrentTool('draw')}
				>
					Pencil
				</button>
				<button
					className="custom-button"
					data-isactive={editor.getCurrentToolId() === 'eraser'}
					onClick={() => editor.setCurrentTool('eraser')}
				>
					Eraser
				</button>
			</div>
		</div>
	)
})

/* 
This example shows how to create your own custom ui for the editor.

[1]
We render the Tldraw component with the `hideUi` prop. This will hide the default
toolbar, style menu and pages menu. We also render our custom ui component inside the 
Tldraw component. This gives us access to the editor instance via React context.

The context menu isn't hidden by the `hideUi` prop, if you want to hide it you can
render the parts that make up the Tldraw component separately and omit the context
menu. Check out the exploded example to see how to do this.

[2]
We use the `track` function to wrap our component. This makes our component reactive- it will
re-render when the signals it is tracking change. Check out the signia docs for more: 
https://signia.tldraw.dev/docs/API/signia_react/functions/track

We gain access to the editor instance via the `useEditor` hook. We use the `useEffect` hook
to add event listeners for keyboard shortcuts. We use editor methods to change the current
tool and delete shapes.

*/
```
### custom-ui.css

```css
.custom-layout {
	position: absolute;
	inset: 0px;
	z-index: 300;
	pointer-events: none;
}

.custom-toolbar {
	position: absolute;
	top: 0px;
	left: 0px;
	width: 100%;
	display: flex;
	align-items: center;
	justify-content: center;
	padding: 8px;
	gap: 8px;
}

.custom-button {
	pointer-events: all;
	padding: 4px 12px;
	background: white;
	border: 1px solid black;
	border-radius: 64px;
}

.custom-button[data-isactive='true'] {
	background-color: black;
	color: white;
}
```

## UI zones

Keywords: top zone, share zone

Inject custom components into tldraw's UI.

Our default UI has two empty "zones" - the `topZone` (in the top-center of the screen) and `shareZone` (in the top right).

You can set these zones to any React component you want.

### App.tsx

```tsx
import { TLComponents, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

const components: TLComponents = {
	SharePanel: CustomShareZone,
	TopPanel: CustomTopZone,
}

// [1]
export default function Example() {
	return (
		<div className="tldraw__editor">
			<Tldraw components={components} />
		</div>
	)
}

// [2]
function CustomTopZone() {
	return (
		<div
			style={{
				backgroundColor: 'thistle',
				width: '100%',
				textAlign: 'center',
				padding: '2px',
				minWidth: '80px',
			}}
		>
			<p>Top Zone</p>
		</div>
	)
}

// [3]
function CustomShareZone() {
	return (
		<div
			style={{
				backgroundColor: 'thistle',
				width: '100%',
				textAlign: 'center',
				minWidth: '80px',
			}}
		>
			<p>Share Zone</p>
		</div>
	)
}

/* 
This example shows how to pass in a custom component to the share panel and top panel.
The share panel is in the top right corner above the style menu, the top panel is in 
the top center.

[1]
We pass in our custom components to the Tldraw topZone and shareZone props.

[2]
This is the component that will be rendered in the top zone.

[3]
This is the component that will be rendered in the share zone.
*/
```

## Action overrides

Keywords: keyboard, shortcut, copy, paste, group, align

Override tldraw's actions.

This example shows how you can override tldraw's actions object to change the keyboard shortcuts. In this case we're changing the delete action's shortcut to 'x'. To customize the actions menu please see the custom actions menu example. For more information on keyboard shortcuts see the keyboard shortcuts example.

### App.tsx

```tsx
import { Tldraw, TLUiActionItem, TLUiActionsContextType } from 'tldraw'
import 'tldraw/tldraw.css'

export default function BasicExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				overrides={{
					actions: (_editor, actions, helpers) => {
						const myCustomAction: TLUiActionItem = {
							id: 'my-action',
							label: 'My action',
							icon: 'circle',
							// [2]
							kbd: '$u',
							onSelect(source) {
								// [3]
								helpers.addToast({ title: `My action was selected from ${source}!` })
							},
						}

						// [4]
						const newActions: TLUiActionsContextType = {
							...actions,
							'my-action': myCustomAction,
							delete: {
								...actions['delete'],
								kbd: '!x',
							},
						}

						return newActions
					},
				}}
			/>
		</div>
	)
}

/* 
Tldraw's actions can be fired via keyboard shortcuts, or from anywhere in the user interface via 
the `useActions` hook. This example shows how you can override tldraw's actions object via the Tldraw
component's `overrides` prop. To learn more about using this actions via a customized menu, see the 
custom actions menu example.

[2]
For kbds, Shift = !, Alt = ?, Cmd = $, i.e. Cmd+Shift+U is $!u. For more information on keyboard shortcuts see the
keyboard shortcuts example.

[3]
You can access UI helpers like addToast, removeToast, etc. from the helpers object.

[4]
Return a new object with the new actions added. You can also modify existing actions as shown here with the delete action.
*/
```

## Add a tool to the Toolbar

Keywords: 

Add your custom tool to the toolbar

You can make an icon for your custom tool appear on tldraw's toolbar. To do this you will need to override the toolbar component, pass in a custom component for the keyboard shortcuts dialog, and pass in an asset url for your icon. This example shows how to do that. For more information on how to implement custom tools, check out the custom tool example.

### App.tsx

```tsx
import {
	DefaultKeyboardShortcutsDialog,
	DefaultKeyboardShortcutsDialogContent,
	DefaultToolbar,
	DefaultToolbarContent,
	TLComponents,
	TLUiAssetUrlOverrides,
	TLUiOverrides,
	Tldraw,
	TldrawUiMenuItem,
	useIsToolSelected,
	useTools,
} from 'tldraw'
import 'tldraw/tldraw.css'
import { StickerTool } from './sticker-tool-util'

// There's a guide at the bottom of this file!

// [1]
const uiOverrides: TLUiOverrides = {
	tools(editor, tools) {
		// Create a tool item in the ui's context.
		tools.sticker = {
			id: 'sticker',
			icon: 'heart-icon',
			label: 'Sticker',
			kbd: 's',
			onSelect: () => {
				editor.setCurrentTool('sticker')
			},
		}
		return tools
	},
}

// [2]
const components: TLComponents = {
	Toolbar: (props) => {
		const tools = useTools()
		const isStickerSelected = useIsToolSelected(tools['sticker'])
		return (
			<DefaultToolbar {...props}>
				<TldrawUiMenuItem {...tools['sticker']} isSelected={isStickerSelected} />
				<DefaultToolbarContent />
			</DefaultToolbar>
		)
	},
	KeyboardShortcutsDialog: (props) => {
		const tools = useTools()
		return (
			<DefaultKeyboardShortcutsDialog {...props}>
				<DefaultKeyboardShortcutsDialogContent />
				{/* Ideally, we'd interleave this into the tools group */}
				<TldrawUiMenuItem {...tools['sticker']} />
			</DefaultKeyboardShortcutsDialog>
		)
	},
}

// [3]
export const customAssetUrls: TLUiAssetUrlOverrides = {
	icons: {
		'heart-icon': '/heart-icon.svg',
	},
}

// [4]
const customTools = [StickerTool]

export default function ToolInToolbarExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// Pass in the array of custom tool classes
				tools={customTools}
				// Set the initial state to the sticker tool
				initialState="sticker"
				// Pass in our ui overrides
				overrides={uiOverrides}
				// pass in our custom components
				components={components}
				// pass in our custom asset urls
				assetUrls={customAssetUrls}
			/>
		</div>
	)
}

/* 
Introduction:
You can make an icon for your custom tool appear on tldraw's toolbar. To do this 
you will need to override the toolbar component, pass in a custom component for 
the keyboard shortcuts dialog, and pass in an asset url for your icon. This 
example shows how to do that. For more information on how to implement custom 
tools, check out the custom tool example.

[1]
First, we define the uiOverrides object. We can override the tools function to
add our custom tool to the ui's context. We can also override the toolbar function
to add our custom tool to the toolbar. We are going to splice it into the toolbar
so it appears in between the eraser and arrow tools.

[2]
Next, we want to override the default keyboard shortcuts dialog so that the 
shortcut for our custom tool appears in the dialog. We don't want to change its 
appearance very much, so we can use the DefaultKeyboardShortcutsDialog component 
and pass in the DefaultKeyboardShortcutsDialogContent component. With the useTools 
hook, we can get the tools from context and pass in the sticker tool to the keyboard 
shortcuts dialog. This will make the keyboard shortcut for the sticker tool appear 
in the dialog.

[3]
We need to make sure the editor knows where to find the icon for our custom tool.
We do this by defining the customAssetUrls object and passing in the asset url for
our icon.

[4]
Finally, we define the customTools array. This array contains the custom tool
class. We then pass the customTools array, the uiOverrides object, the
components object, and the customAssetUrls object to the Tldraw component as
props. This will make the icon for the custom tool appear on the toolbar.

*/
```
### sticker-tool-util.tsx

```tsx
import { StateNode, TLTextShape, toRichText } from 'tldraw'

// Check out the custom tool example for a more detailed explanation of the tool class.

const OFFSET = 12
export class StickerTool extends StateNode {
	static override id = 'sticker'

	override onEnter() {
		this.editor.setCursor({ type: 'cross', rotation: 0 })
	}

	override onPointerDown() {
		const { currentPagePoint } = this.editor.inputs
		this.editor.createShape<TLTextShape>({
			type: 'text',
			x: currentPagePoint.x - OFFSET,
			y: currentPagePoint.y - OFFSET,
			props: { richText: toRichText('❤️') },
		})
	}
}
```

## Canvas components

Keywords: custom, Background, SvgDefs, Brush, ZoomBrush, ShapeIndicator, Cursor, Canvas, CollaboratorBrush, CollaboratorCursor, CollaboratorHint, CollaboratorShapeIndicator, Grid, Scribble, CollaboratorScribble, SnapIndicator, Handles, Handle, Spinner, SelectionForeground, SelectionBackground, OnTheCanvas, InFrontOfTheCanvas, LoadingScreen

Replace tldraw's on-canvas UI with your own.

Tldraw's on-canvas UI is built from replaceable React components.

Try dragging to select or using the eraser tool to see the custom components in this example.

### App.tsx

```tsx
import { useRef } from 'react'
import { Tldraw, TLEditorComponents, toDomPrecision, useTransform } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

const components: TLEditorComponents = {
	Brush: function MyBrush({ brush }) {
		const rSvg = useRef<SVGSVGElement>(null)

		useTransform(rSvg, brush.x, brush.y)

		const w = toDomPrecision(Math.max(1, brush.w))
		const h = toDomPrecision(Math.max(1, brush.h))

		return (
			<svg ref={rSvg} className="tl-overlays__item">
				<rect className="tl-brush" stroke="red" fill="none" width={w} height={h} />
			</svg>
		)
	},
	Scribble: ({ scribble, opacity, color }) => {
		return (
			<svg className="tl-overlays__item">
				<polyline
					points={scribble.points.map((p) => `${p.x},${p.y}`).join(' ')}
					stroke={color ?? 'black'}
					opacity={opacity ?? '1'}
					fill="none"
				/>
			</svg>
		)
	},
	SnapIndicator: null,
}

export default function CustomComponentsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="custom-components-example" components={components} />
		</div>
	)
}

/* 
This example shows how to change the default components that tldraw uses on the canvas via the `components` prop.
Components include things like the background, the grid, handles, spinners etc. In this case we change the box 
that appears when drag-selecting shapes, and the scribble left behind when using the eraser and laser pointer.

*/
```

## Context toolbar

Keywords: in front of the canvas, contextual

Show a contextual toolbar above the shapes when they are selected.

An example of how to show a contextual toolbar which appears on top of the selected shapes. It is displayed above the canvas, but below other UI elements.

Select shapes of different types and adjust the size of the shapes - this works just like adjusting the size from the Style panel on the right side.

### App.tsx

```tsx
import {
	DefaultSizeStyle,
	Tldraw,
	TldrawUiIcon,
	TLEditorComponents,
	track,
	useEditor,
} from 'tldraw'
import 'tldraw/tldraw.css'

const SIZES = [
	{ value: 's', icon: 'size-small' },
	{ value: 'm', icon: 'size-medium' },
	{ value: 'l', icon: 'size-large' },
	{ value: 'xl', icon: 'size-extra-large' },
] as const

// There's a guide at the bottom of this file!

// [1]
const ContextToolbarComponent = track(() => {
	const editor = useEditor()
	const showToolbar = editor.isIn('select.idle')
	if (!showToolbar) return null
	const selectionRotatedPageBounds = editor.getSelectionRotatedPageBounds()
	if (!selectionRotatedPageBounds) return null

	// [2]
	const size = editor.getSharedStyles().get(DefaultSizeStyle)
	if (!size) return null
	const currentSize = size.type === 'shared' ? size.value : undefined

	const pageCoordinates = editor.pageToViewport(selectionRotatedPageBounds.point)

	return (
		<div
			style={{
				position: 'absolute',
				pointerEvents: 'all',
				top: pageCoordinates.y - 42,
				left: pageCoordinates.x,
				// [3]
				width: selectionRotatedPageBounds.width * editor.getZoomLevel(),
				display: 'flex',
				justifyContent: 'center',
				alignItems: 'center',
			}}
			// [4]
			onPointerDown={(e) => e.stopPropagation()}
		>
			<div
				style={{
					borderRadius: 8,
					display: 'flex',
					boxShadow: '0 0 0 1px rgba(0,0,0,0.1), 0 4px 8px rgba(0,0,0,0.1)',
					background: 'var(--color-panel)',
					width: 'fit-content',
					alignItems: 'center',
				}}
			>
				{SIZES.map(({ value, icon }) => {
					const isActive = value === currentSize
					return (
						<div
							key={value}
							style={{
								display: 'flex',
								alignItems: 'center',
								justifyContent: 'center',
								height: 32,
								width: 32,
								background: isActive ? 'var(--color-muted-2)' : 'transparent',
							}}
							onClick={() => editor.setStyleForSelectedShapes(DefaultSizeStyle, value)}
						>
							<TldrawUiIcon icon={icon} />
						</div>
					)
				})}
			</div>
		</div>
	)
})

const components: TLEditorComponents = {
	InFrontOfTheCanvas: ContextToolbarComponent,
}

export default function ContextToolbar() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="things-on-the-canvas-example" components={components} />
		</div>
	)
}

/*
This example shows how you can implement a context toolbar that appears when you select shapes.
It's using the `InFrontOfTheCanvas` component to render the toolbar. This allows us to render
the toolbar on top of the shapes, but behind the existing UI. The toolbar is only rendered when
we are in the `select.idle` state (so we are not rotating, moving, resizing, drawing,...).
You can also check the `Things on the canvas` example for more info on how to use `TLEditorComponents`.

[1]
This is our context toolbar. It's positioned absolutely on top of the selected shapes.

[2]
Different shapes support different style properties and this is how we get the styles that are 
supported by all selected shapes. If none of the selected shapes supported the `DefaultSizeStyle`
we wouldn't show the toolbar at all.
We also get the current value of the size property. If all the shapes have the same size then the
type of the size property is `shared`. This will allow us to show the currently selected size in the
toolbar. If the shapes have different sizes then the type of the size property is `mixed` and none
of the sizes will be highlighted.

[3]
We will show the toolbar in the middle of the selected shapes. We'll achieve this by making the parent
take the whole width, then use flexbox to center the toolbar.

[4]
We stop the event propagation so that clicking on the toolbar doesn't deselect the shapes.
*/
```

## Error boundary

Keywords: shape

Catch errors in shapes.

When something goes wrong in a shape, it won't crash the whole editor - just the shape that went wrong.

### App.tsx

```tsx
import { createShapeId, Tldraw, TLShapePartial } from 'tldraw'
import 'tldraw/tldraw.css'
import { ErrorShape, ErrorShapeUtil } from './ErrorShape'

// There's a guide at the bottom of this file!

// [1]
const shapes = [ErrorShapeUtil]

// [2]
export default function ErrorBoundaryExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				shapeUtils={shapes}
				components={{
					ShapeErrorFallback: ({ error }) => <div>Shape error! {String(error)}</div>, // use a custom error fallback for shapes
				}}
				onMount={(editor) => {
					const errorShapePartial: TLShapePartial<ErrorShape> = {
						type: 'error',
						id: createShapeId(),
						x: 0,
						y: 0,
						props: { message: 'Something has gone wrong' },
					}
					// [3]
					// When the app starts, create our error shape so we can see.
					editor.createShapes<ErrorShape>([errorShapePartial])

					// Center the camera on the error shape
					editor.zoomToFit()
					editor.resetZoom()
				}}
			/>
		</div>
	)
}

/* 
This example shows how the tldraw error boundary can allow you to render a custom error
fallback for shapes that throw errors. We simulate this scenario by creating a shape
that always throws an error when it renders.

[1] 
We have a shape util that always throws an error when it renders. Check out ErrorShape.ts
to see how this works. It's important to define this array of shape utils outside of a
React competent so that they are not recreated on every render.

[2]
We pass in our shape util to the tldraw component. We also pass in a custom error fallback
component that will be used to render any shapes that throw an error. Check out the 
custom component example for more examples of components you can customize.

[3]
When the app starts, we create our error shape and center the camera. 

*/
```
### ErrorShape.ts

```ts
import { BaseBoxShapeUtil, TLBaseShape } from 'tldraw'

export type ErrorShape = TLBaseShape<'error', { w: number; h: number; message: string }>

export class ErrorShapeUtil extends BaseBoxShapeUtil<ErrorShape> {
	static override type = 'error' as const

	getDefaultProps() {
		return { message: 'Error!', w: 100, h: 100 }
	}
	component(shape: ErrorShape) {
		throw new Error(shape.props.message)
	}
	indicator() {
		throw new Error(`Error shape indicator!`)
	}
}
```

## External UI

Keywords: outside, editor

This example shows how to control the tldraw editor from an external UI, outside of the `Tldraw` component.

This example shows how to control the tldraw editor from an external UI, outside
of the `Tldraw` component. There are a few ways of doing this—for example, by putting the editor on the window object, passing it around via props, or using React context.

In this example, we'll just put the editor instance in state and use it in the same component. See the External UI Example 2 for an alternative (and more realistic) solution using React context.

### App.tsx

```tsx
import { useState } from 'react'
import { Editor, GeoShapeGeoStyle, Tldraw, useValue } from 'tldraw'
import 'tldraw/tldraw.css'
import './external-ui.css'

// There's a guide at the bottom of this file!

export default function ExternalUiExample() {
	// [1]
	const [editor, setEditor] = useState<Editor | null>(null)

	const currentToolId = useValue('current tool id', () => editor?.getCurrentToolId(), [editor])

	return (
		<div style={{ margin: 32, width: 600 }}>
			<div style={{ height: 400 }}>
				<Tldraw
					// [2]
					onMount={(editor) => setEditor(editor)}
					components={{ Toolbar: null }}
				/>
			</div>
			{/* [3] */}
			<div>
				<div className="external-toolbar">
					<button
						className="external-button"
						data-isactive={currentToolId === 'select'}
						onClick={() => editor?.setCurrentTool('select')}
					>
						Select
					</button>
					<button
						className="external-button"
						data-isactive={currentToolId === 'draw'}
						onClick={() => editor?.setCurrentTool('draw')}
					>
						Pencil
					</button>
					<button
						className="external-button"
						data-isactive={
							currentToolId === 'geo' && editor?.getStyleForNextShape(GeoShapeGeoStyle) === 'oval'
						}
						onClick={() => {
							if (!editor) return
							editor.run(() => {
								// [4]
								editor.setStyleForNextShapes(GeoShapeGeoStyle, 'oval')
								editor.setCurrentTool('geo')
							})
						}}
					>
						Oval
					</button>
				</div>
			</div>
		</div>
	)
}

/*
[1] 
Use React state to store the editor instance.

[2]
Use the `onMount` prop to get the editor instance and store it in state.

[3]
Use data from the editor instance or use the editor's methods to control the editor.
Note that these callbacks also need to work if the editor isn't mounted yet.

[4]
The geo tool is a bit special since it controls the creation of many geo shapes (oval, rectangle, etc).
This is why we first set the type of the shape we wish to add, then we set the tool to 'geo'.
You can see all the available geo shapes in the `GeoShapeGeoStyle` enum.
*/
```
### external-ui.css

```css
.external-toolbar {
	display: flex;
	align-items: center;
	justify-content: center;
	padding: 8px;
	gap: 8px;
}

.external-button {
	pointer-events: all;
	padding: 4px 12px;
	background: white;
	border: 1px solid black;
	border-radius: 16px;
}

.external-button[data-isactive='true'] {
	background-color: black;
	color: white;
}
```

## External UI (Context)

Keywords: outside, editor, context

This example shows how to control the tldraw editor from an external UI, outside of the `Tldraw` component. This example shows how to pass a reference to the editor around using React Context.

This example shows how to control the tldraw editor from an external UI, outside
of the `Tldraw` component. There are a few ways of doing this—for example, by putting the editor on the window object, passing it around via props, or using React context.

In this example, we use React context to distribute a reference to the editor to child components.

### App.tsx

```tsx
import { createContext, useContext, useState } from 'react'
import { Editor, GeoShapeGeoStyle, Tldraw, useValue } from 'tldraw'
import 'tldraw/tldraw.css'
import './external-ui.css'

// There's a guide at the bottom of this file!

// [1]
const editorContext = createContext({} as { editor: Editor })

export default function ExternalUiExample2() {
	const [editor, setEditor] = useState<Editor | null>(null)

	return (
		<div style={{ margin: 32, width: 600 }}>
			<div style={{ height: 400 }}>
				<Tldraw
					// [2]
					onMount={(editor) => setEditor(editor)}
					components={{ Toolbar: null }}
				/>
			</div>
			{/* [3] */}
			{editor && (
				<editorContext.Provider value={{ editor }}>
					<ExternalToolbar />
				</editorContext.Provider>
			)}
		</div>
	)
}

// [4]
const ExternalToolbar = () => {
	const { editor } = useContext(editorContext)

	const currentToolId = useValue('current tool id', () => editor?.getCurrentToolId(), [editor])

	return (
		<div>
			<div className="external-toolbar">
				<button
					className="external-button"
					data-isactive={currentToolId === 'select'}
					onClick={() => editor.setCurrentTool('select')}
				>
					Select
				</button>
				<button
					className="external-button"
					data-isactive={currentToolId === 'draw'}
					onClick={() => editor.setCurrentTool('draw')}
				>
					Pencil
				</button>
				<button
					className="external-button"
					data-isactive={
						currentToolId === 'geo' && editor?.getStyleForNextShape(GeoShapeGeoStyle) === 'oval'
					}
					onClick={() => {
						editor.run(() => {
							editor.setStyleForNextShapes(GeoShapeGeoStyle, 'oval')
							editor.setCurrentTool('geo')
						})
					}}
				>
					Oval
				</button>
			</div>
		</div>
	)
}

/*

[1] 
Use React context to store the editor at a higher place in the React component tree. 

[2] 
Use the `onMount` prop to get the editor instance and store it in state.

[3]
When we have an editor in state, render the context provider and its descendants.

[4]
You can access the editor from any of the provider's descendants.
*/
```
### external-ui.css

```css
.external-toolbar {
	display: flex;
	align-items: center;
	justify-content: center;
	padding: 8px;
	gap: 8px;
}

.external-button {
	pointer-events: all;
	padding: 4px 12px;
	background: white;
	border: 1px solid black;
	border-radius: 16px;
}

.external-button[data-isactive='true'] {
	background-color: black;
	color: white;
}
```

## Keyboard shortcuts

Keywords: dialog, overrides, actions, tools

How to replace tldraw's default keyboard shortcuts with your own.

This example shows how you can replace tldraw's default keyboard shortcuts with your own,
or add a shortcut for an action that doesn't have one. An example of how to add shortcuts
for custom tools can be found in the custom-config example.

- Toggle show grid by pressing 'x'
- Select the Draw tool by pressing 'p'
- Copy as png by pressing 'ctrl/cmd + 1'

### App.tsx

```tsx
import { TLUiActionsContextType, TLUiOverrides, TLUiToolsContextType, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

// [1]
const overrides: TLUiOverrides = {
	//[a]
	actions(_editor, actions): TLUiActionsContextType {
		const newActions = {
			...actions,
			'toggle-grid': { ...actions['toggle-grid'], kbd: 'x' },
			'copy-as-png': { ...actions['copy-as-png'], kbd: '$1' },
		}

		return newActions
	},
	//[b]
	tools(_editor, tools): TLUiToolsContextType {
		const newTools = { ...tools, draw: { ...tools.draw, kbd: 'p' } }
		return newTools
	},
}

// [2]
export default function KeyboardShortcuts() {
	return (
		<div className="tldraw__editor">
			<Tldraw overrides={overrides} />
		</div>
	)
}

/* 
This example shows how you can replace tldraw's default keyboard shortcuts with your own,
or add a shortcut for an action that doesn't have one. An example of how to add shortcuts
for custom tools can be found in the custom-config example.

In this case we are overriding the toggle grid and draw tool shortcuts, and creating a 
shortcut for copy-as-png. An override of an existing shortcut will automatically update 
the keyboard shortcuts dialog. However, adding a new shortcut won't, we'll need to add it 
ourselves.

You can describe modifier keys with the following syntax:
	
	shift: !
 ctrl/cmd: $
	  alt: ?

[1]
We start by defining our overrides, this is an object with functions that we can use to 
change the ui. Keyboard shortcuts are associated with either tools (draw, eraser, etc) or 
actions (group, undo/redo etc). We're going to override two actions [a], one tool [b], and 
add a new shortcut to the keyboard shortcuts dialog [c].

[a] actions
	There are two actions we're modifying here, copy-as-png and toggle-grid. copy-as-png
	doesn't have an existing shortcut, but we can still add the property and later add it
	to the keyboard shortcuts dialog [c].

[b] tools
	We're overriding the draw tool's shortcut to 'p', maybe we want to rename it to the pen
	tool or something.

[2]
Finally, we pass our overrides object into the Tldraw component's overrides prop. Now when
the component mounts, our overrides will be applied. If you open the keyboard shortcuts 
dialog, you'll see the changes we made.
*/
```

## Things on the canvas

Keywords: in front of the canvas, scale, zoom, ui

Add custom components to the editor

Components can either float on top of the canvas unaffected by the camera, or be a part of the canvas itself.

### App.tsx

```tsx
import { useState } from 'react'
import { stopEventPropagation, Tldraw, TLEditorComponents, track, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

// [1]
function MyComponent() {
	const [state, setState] = useState(0)

	return (
		<>
			<div
				style={{
					position: 'absolute',
					top: 50,
					left: 50,
					width: 200,
					padding: 12,
					borderRadius: 8,
					backgroundColor: 'goldenrod',
					zIndex: 0,
					userSelect: 'unset',
					boxShadow: '0 0 0 1px rgba(0,0,0,0.1), 0 4px 8px rgba(0,0,0,0.1)',
				}}
				onPointerDown={stopEventPropagation}
				onPointerMove={stopEventPropagation}
			>
				<p>The count is {state}! </p>
				<button onClick={() => setState((s) => s - 1)}>-1</button>
				<p>These components are on the canvas. They will scale with camera zoom like shapes.</p>
			</div>
			<div
				style={{
					position: 'absolute',
					top: 210,
					left: 150,
					width: 200,
					padding: 12,
					borderRadius: 8,
					backgroundColor: 'pink',
					zIndex: 99999999,
					userSelect: 'unset',
					boxShadow: '0 0 0 1px rgba(0,0,0,0.1), 0 4px 8px rgba(0,0,0,0.1)',
				}}
				onPointerDown={stopEventPropagation}
				onPointerMove={stopEventPropagation}
			>
				<p>The count is {state}! </p>
				<button onClick={() => setState((s) => s + 1)}>+1</button>
				<p>Create and select a shape to see the in front of the canvas component</p>
			</div>
		</>
	)
}

//[2]
const MyComponentInFront = track(() => {
	const editor = useEditor()
	const selectionRotatedPageBounds = editor.getSelectionRotatedPageBounds()
	if (!selectionRotatedPageBounds) return null

	const pageCoordinates = editor.pageToViewport(selectionRotatedPageBounds.point)

	return (
		<div
			style={{
				position: 'absolute',
				top: Math.max(64, pageCoordinates.y - 64),
				left: Math.max(64, pageCoordinates.x),
				borderRadius: 8,
				paddingLeft: 10,
				paddingRight: 10,
				background: '#efefef',
				boxShadow: '0 0 0 1px rgba(0,0,0,0.1), 0 4px 8px rgba(0,0,0,0.1)',
			}}
		>
			<p>This won’t scale with zoom.</p>
		</div>
	)
})

// [3]
const components: TLEditorComponents = {
	OnTheCanvas: MyComponent,
	InFrontOfTheCanvas: MyComponentInFront,
}

// [4]
export default function OnTheCanvasExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="things-on-the-canvas-example" components={components} />
		</div>
	)
}

/* 
This example shows how you can use the onTheCanvas and inFrontOfTheCanvas components.
onTheCanvas components will behave similarly to shapes, they will scale with the zoom
and move when the page is panned. inFrontOfTheCanvas components don't scale with the
zoom, but still move when the page is panned. 

For another example that shows how to customize components, check out the custom
components example.

To have a component that ignores the camera entirely, you should check out the custom 
UI example.


[1]
This is our onTheCanvas component. We also stop event propagation on the pointer events 
so that we don't accidentally select shapes when interacting with the component.

[2]
This is our inFrontOfTheCanvas component. We want to render this next to a selected shape,
so we need to make sure it's reactive to changes in the editor. We use the track function
to make sure the component is re-rendered whenever the selection changes. Check out the
Signia docs for more info: https://signia.tldraw.dev/docs/API/signia_react/functions/track

Using the editor instance we can get the bounds of the selection box and convert them to
screen coordinates. We then render the component at those coordinates.


[3]
This is where we define the object that will be passed to the Tldraw component prop. 

[4]
This is where we render the Tldraw component. Let's pass the components object to the 
components prop.

*/
```

## Blocking events

Keywords: event, block, propagation, stop, no, select, user-select

Stop events from reaching the canvas.

If you don't want the user's interactions from reaching the canvas, you can call `stopPropagation` on the user's pointer events.

### App.tsx

```tsx
import { TLComponents, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

function WelcomeScreen() {
	return (
		<div
			style={{
				position: 'absolute',
				inset: 0,
				display: 'flex',
				alignItems: 'center',
				justifyContent: 'center',
				pointerEvents: 'none', // [1]
			}}
		>
			<div
				style={{
					padding: 32,
					borderRadius: 20,
					boxShadow: '2px 2px 12px rgba(0,0,0,.2)',
					backgroundColor: 'white',
					pointerEvents: 'all', // [2]
					width: 400,
				}}
			>
				<p
					style={{
						userSelect: 'text', // [3]
					}}
				>
					Notice that if you click on this box or start a drag from in here, you will not be
					interacting with the canvas. However, you can still interact with the canvas by clicking
					anywhere else!
				</p>
				<div>
					<button onClick={() => window.alert('Thanks')}>Click here</button>
				</div>
			</div>
		</div>
	)
}

const components: TLComponents = {
	InFrontOfTheCanvas: WelcomeScreen,
}

export default function EventBlockerExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example" components={components} />
		</div>
	)
}

/*
[1]
This div will overlay the whole canvas. We want the user's pointer events to
pass through this div rather than getting blocked by it div, so we turn
pointer events off.

[2]
This is the container that's centered on the screen. For this div, we want to
block pointer events so that the user can't interact with the canvas behind it,
so we turn pointer events on.

[3]
As a side note, we also turn off user-select for anything inside of the canvas.
If you want the user to be able to select text, you can set this style to 'all'.
*/
```

## External dialog

Keywords: css

You can make dialogs pop outside of the `Tldraw` component by overriding our default styles.

### App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// This CSS file overrides the default styles for dialogs
import './external-dialog.css'

export default function ExternalDialog() {
	return (
		<div style={{ margin: 32, width: 600, height: 400 }}>
			<Tldraw />
		</div>
	)
}
```
### external-dialog.css

```css
.tlui-dialog__overlay {
	position: fixed;
}
```

## Floaty window

Keywords: 



### App.tsx

```tsx
import { useEffect } from 'react'
import { Tldraw, Vec, useContainer, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'

export default function FloatyExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="tldraw_floaty_example">
				<SneakyFloatyHook />
			</Tldraw>
		</div>
	)
}

function SneakyFloatyHook() {
	const editor = useEditor()
	const container = useContainer()

	useEffect(() => {
		if (!window.screenLeft) {
			window.screenLeft = window.screenX
			window.screenTop = window.screenY
		}

		let x = window.screenLeft ?? window.screenX
		let y = window.screenTop ?? window.screenY

		function updatePositions() {
			const sx = window.screenLeft ?? window.screenX
			const sy = window.screenTop ?? window.screenY

			if (sx !== x || sy !== y) {
				x = sx
				y = sy
				editor.setCamera(new Vec(-x, -y))
			}
		}

		editor.on('tick', updatePositions)

		return () => {
			editor.off('tick', updatePositions)
		}
	}, [editor, container])

	return null
}
```

## Inline behavior

Keywords: focus, blur, multiple

tldraw can be used as an inline block within a larger document editor.

This example demonstrates some common best practices for using tldraw as an inline block within a larger editor. It includes:

- Making sure that only one editor has focus at a time.
- Always defaulting to the hand tool when you click into an editor.
- Deselecting everything when an editor loses focus.
- Hiding the UI when an editor is not focused.
- Disabling edge scrolling by default.
- Using a stripped down UI to make the most of the available space.
- Removing actions from the context menu to match the stripped down UI.

### App.tsx

```tsx
import { createContext, useContext, useState } from 'react'
import {
	ArrangeMenuSubmenu,
	ClipboardMenuGroup,
	ConversionsMenuGroup,
	ConvertToBookmarkMenuItem,
	ConvertToEmbedMenuItem,
	DefaultContextMenu,
	EditLinkMenuItem,
	Editor,
	FitFrameToContentMenuItem,
	GroupMenuItem,
	RemoveFrameMenuItem,
	ReorderMenuSubmenu,
	SelectAllMenuItem,
	TLUiContextMenuProps,
	Tldraw,
	TldrawUiMenuGroup,
	ToggleAutoSizeMenuItem,
	ToggleLockMenuItem,
	UngroupMenuItem,
	useEditor,
	useValue,
} from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this page!

// [1]
const focusedEditorContext = createContext(
	{} as {
		focusedEditor: Editor | null
		setFocusedEditor(id: Editor | null): void
	}
)

// [2]
function blurEditor(editor: Editor) {
	editor.blur({ blurContainer: false })
	editor.selectNone()
	editor.setCurrentTool('hand')
}

export default function InlineBehaviorExample() {
	const [focusedEditor, setFocusedEditor] = useState<Editor | null>(null)

	return (
		<focusedEditorContext.Provider value={{ focusedEditor, setFocusedEditor }}>
			<div
				style={{
					margin: 20,
					display: 'flex',
					flexDirection: 'column',
					gap: 20,
				}}
				// [3]
				onPointerDown={() => {
					if (!focusedEditor) return
					blurEditor(focusedEditor)
					setFocusedEditor(null)
				}}
			>
				<InlineBlock persistenceKey="block-a" />
				<InlineBlock persistenceKey="block-b" />
				<InlineBlock persistenceKey="block-c" />
			</div>
		</focusedEditorContext.Provider>
	)
}

function InlineBlock({ persistenceKey }: { persistenceKey: string }) {
	const { focusedEditor, setFocusedEditor } = useContext(focusedEditorContext)
	const [editor, setEditor] = useState<Editor>()

	return (
		<div
			style={{ width: 600, height: 400, maxWidth: '100%' }}
			// [4]
			onFocus={() => {
				if (!editor) return
				if (focusedEditor && focusedEditor !== editor) {
					blurEditor(focusedEditor)
				}
				editor.focus({ focusContainer: false })
				setFocusedEditor(editor)
			}}
		>
			<Tldraw
				persistenceKey={persistenceKey}
				autoFocus={false}
				// [5]
				hideUi={focusedEditor !== editor}
				// [6]
				components={{
					HelpMenu: null,
					NavigationPanel: null,
					MainMenu: null,
					PageMenu: null,
					ContextMenu: CustomContextMenu,
				}}
				// [7]
				onMount={(editor) => {
					setEditor(editor)
					editor.setCurrentTool('hand')
					editor.user.updateUserPreferences({ edgeScrollSpeed: 0 })
				}}
			/>
		</div>
	)
}

// [8]
function CustomContextMenu(props: TLUiContextMenuProps) {
	const editor = useEditor()

	const selectToolActive = useValue(
		'isSelectToolActive',
		() => editor.getCurrentToolId() === 'select',
		[editor]
	)

	return (
		<DefaultContextMenu {...props}>
			{selectToolActive && (
				<>
					<TldrawUiMenuGroup id="misc">
						<GroupMenuItem />
						<UngroupMenuItem />
						<EditLinkMenuItem />
						<ToggleAutoSizeMenuItem />
						<RemoveFrameMenuItem />
						<FitFrameToContentMenuItem />
						<ConvertToEmbedMenuItem />
						<ConvertToBookmarkMenuItem />
						<ToggleLockMenuItem />
					</TldrawUiMenuGroup>
					<TldrawUiMenuGroup id="modify">
						<ArrangeMenuSubmenu />
						<ReorderMenuSubmenu />
						{/* <MoveToPageMenu /> */}
					</TldrawUiMenuGroup>
					<ClipboardMenuGroup />
					<ConversionsMenuGroup />
					<TldrawUiMenuGroup id="select-all">
						<SelectAllMenuItem />
					</TldrawUiMenuGroup>
				</>
			)}
		</DefaultContextMenu>
	)
}

/*
This example demonstrates some common best practices for using tldraw as an
inline block within a larger document editor.

It includes:

- Making sure that only one editor has focus at a time.
- Always defaulting to the hand tool when you click into an editor.
- Deselecting everything when an editor loses focus.
- Hiding the UI when an editor is not focused.
- Disabling edge scrolling by default.
- Using a stripped down UI to make the most of the available space.
- Removing actions from the context menu to match the stripped down UI.

[1]
We use a context to manage which editor is currently focused. This allows us to
have multiple editors on the same page, without them interfering with each
other, or hijacking any keyboard shortcuts. For more information about handling
focus, check out the 'Multiple editors' and 'Editor focus' examples.

[2]
We have a helper function that we call on any editor that loses focus. We
deselect everything, and switch back to the hand tool, essentially 'resetting'
the user's tool state.

[3]
When the user clicks anywhere on the page outside of an editor, we blur the
currently focused editor.

[4]
When the user clicks into an editor, we focus it, and blur any other editor.

[5]
We hide the UI of any unfocused editor.

[6]
We disable many of tldraw's default UI components to make the most of the
available space. We also pass through a custom context menu component. Check out
point [8] for more information about that.

[7]
When an editor mounts, we default to the hand tool, and disable edge scrolling.
We also store a reference to the editor so that we can access it later. For the
purposes of this example, we also disable debug mode, so that you can see the
full effect of the stripped down UI.

[8]
For our custom context menu, we've copied the default context menu contents, and
we've commented out the 'Move to page' action. This is because we've removed
the Pages menu, so we don't want any drawings getting lost on a different page!

*/
```

## Inline layout

Keywords: focus, auto, focus, multiple, editors

The `Tldraw` component can be used inline with a set height and width.
This example shows the editor's default appearance at various different sizes.

### App.tsx

```tsx
import { createContext, useContext, useState } from 'react'
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

const FocusedEditorContext = createContext(
	{} as {
		focusedEditor: string | null
		setFocusedEditor(id: string | null): void
	}
)

export default function InlineExample() {
	const [focusedEditor, setFocusedEditor] = useState<string | null>(null)
	return (
		<FocusedEditorContext.Provider value={{ focusedEditor, setFocusedEditor }}>
			<div
				style={{
					display: 'flex',
					flexDirection: 'column',
					justifyContent: 'center',
					padding: 32,
					paddingTop: 12,
					gap: 12,
				}}
			>
				<InlineEditor width={500} height={300} />
				<InlineEditor width={600} height={400} />
				<InlineEditor width={700} height={500} />
				<InlineEditor width={900} height={600} />
			</div>
		</FocusedEditorContext.Provider>
	)
}

function InlineEditor({ width, height }: { width: number; height: number }) {
	const { focusedEditor, setFocusedEditor } = useContext(FocusedEditorContext)

	const title = `${width} x ${height}`

	return (
		<div>
			<h2>{title}</h2>
			<div style={{ width, height }} onFocus={() => setFocusedEditor(title)}>
				<Tldraw autoFocus={focusedEditor === title} />
			</div>
		</div>
	)
}
```

## Layer Panel

Keywords: 

Implementing a minimal layers panel for tldraw.

This example adds a simple layers panel to show shapes, groups, and frames in a tree view. It also allows showing/hiding shapes and selecting shapes.

### App.tsx

```tsx
import { TLComponents, TLEditorSnapshot, Tldraw, useEditor, useValue } from 'tldraw'
import 'tldraw/tldraw.css'
import { ShapeList } from './ShapeList'
import './layer-panel.css'
import snapshot from './snapshot.json'

// There's a guide a the bottom of this file!

const components: TLComponents = {
	// [1]
	InFrontOfTheCanvas: () => {
		const editor = useEditor()
		const shapeIds = useValue(
			'shapeIds',
			() => editor.getSortedChildIdsForParent(editor.getCurrentPageId()),
			[editor]
		)
		return (
			<div className="layer-panel">
				<div className="layer-panel-title">Shapes</div>

				<ShapeList
					// [2]
					shapeIds={shapeIds}
					depth={0}
				/>
			</div>
		)
	},
}

export default function LayerPanelExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="layer-panel-example"
				components={components}
				// [3]
				isShapeHidden={(s) => !!s.meta.hidden}
				// this is just to provide some initial content, so visitors can see the layer panel in action
				snapshot={snapshot as any as TLEditorSnapshot}
			/>
		</div>
	)
}

/*
Guide:

1. Here we override the `InFrontOfTheCanvas` component with a custom component that renders a simple layer panel.
2. We pass the root ids of the current page to the recursive ShapeList component. (see ShapeList.tsx)
3. This is a function that determines whether a shape is hidden. We use this to hide shapes that have the `hidden` meta property set to true.
*/
```
### ShapeList.tsx

```tsx
import { capitalize } from 'lodash'
import { useState } from 'react'
import { Editor, TLShapeId, useEditor, useValue } from 'tldraw'
import { VisibilityOff, VisibilityOn } from '../../icons/icons'

const selectedBg = '#E8F4FE'
const childSelectedBg = '#F3F9FE'
const childBg = '#00000006'

function ShapeItem({
	shapeId,
	depth,
	parentIsSelected,
	parentIsHidden,
}: {
	shapeId: TLShapeId
	depth: number
	parentIsSelected?: boolean
	parentIsHidden?: boolean
}) {
	const editor = useEditor()

	const shape = useValue('shape', () => editor.getShape(shapeId), [editor])
	const children = useValue('children', () => editor.getSortedChildIdsForParent(shapeId), [editor])
	const isHidden = useValue('isHidden', () => editor.isShapeHidden(shapeId), [editor])
	const isSelected = useValue('isSelected', () => editor.getSelectedShapeIds().includes(shapeId), [
		editor,
	])
	const shapeName = useValue('shapeName', () => getShapeName(editor, shapeId), [editor])

	const [isEditingName, setIsEditingName] = useState(false)

	if (!shape) return null

	return (
		<>
			{!!shape && (
				<div
					className="shape-item"
					onDoubleClick={() => {
						setIsEditingName(true)
					}}
					onClick={() => {
						// We synchronize the selection state of the layer panel items with the selection state of the shapes in the editor.
						if (editor.inputs.ctrlKey || editor.inputs.shiftKey) {
							if (isSelected) {
								editor.deselect(shape)
							} else {
								editor.select(...editor.getSelectedShapes(), shape)
							}
						} else {
							editor.select(shape)
						}
					}}
					style={{
						paddingLeft: 10 + depth * 20,
						opacity: parentIsHidden || isHidden ? 0.5 : 1,
						background: isSelected
							? selectedBg
							: parentIsSelected
								? childSelectedBg
								: depth > 0
									? childBg
									: undefined,
					}}
				>
					{isEditingName ? (
						<input
							autoFocus
							className="shape-name-input"
							defaultValue={shapeName}
							onBlur={() => setIsEditingName(false)}
							onChange={(ev) => {
								if (shape.type === 'frame') {
									editor.updateShape({ ...shape, props: { name: ev.target.value } })
								} else {
									editor.updateShape({ ...shape, meta: { name: ev.target.value } })
								}
							}}
							onKeyDown={(ev) => {
								// finish editing on enter
								if (ev.key === 'Enter' || ev.key === 'Escape') {
									ev.currentTarget.blur()
								}
							}}
						/>
					) : (
						<div className="shape-name">{shapeName}</div>
					)}
					<button
						className="shape-visibility-toggle"
						onClick={(ev) => {
							editor.updateShape({ ...shape, meta: { hidden: !shape.meta.hidden } })
							ev.stopPropagation()
						}}
					>
						{shape.meta.hidden ? <VisibilityOff /> : <VisibilityOn />}
					</button>
				</div>
			)}
			{!!children?.length && (
				<ShapeList
					shapeIds={children}
					depth={depth + 1}
					parentIsHidden={parentIsHidden || isHidden}
					parentIsSelected={parentIsSelected || isSelected}
				/>
			)}
		</>
	)
}

export function ShapeList({
	shapeIds,
	depth,
	parentIsSelected,
	parentIsHidden,
}: {
	shapeIds: TLShapeId[]
	depth: number
	parentIsSelected?: boolean
	parentIsHidden?: boolean
}) {
	if (!shapeIds.length) return null
	return (
		<div className="shape-tree">
			{shapeIds.map((shapeId) => (
				<ShapeItem
					key={shapeId}
					shapeId={shapeId}
					depth={depth}
					parentIsHidden={parentIsHidden}
					parentIsSelected={parentIsSelected}
				/>
			))}
		</div>
	)
}

function getShapeName(editor: Editor, shapeId: TLShapeId) {
	const shape = editor.getShape(shapeId)
	if (!shape) return 'Unknown shape'
	return (
		// meta.name is the first choice, then the shape's text, then the capitalized shape type
		(shape.meta.name as string) ||
		editor.getShapeUtil(shape).getText(shape) ||
		capitalize(shape.type + ' shape')
	)
}
```
### layer-panel.css

```css
.layer-panel {
	position: absolute;
	left: 0;
	top: 42px;
	width: 200px;
	height: calc(100% - 42px);
	background: white;
	display: flex;
	flex-direction: column;
}
.shape-tree {
	display: flex;
	flex-direction: column;
}
.shape-item {
	display: flex;
	align-items: center;
	justify-content: space-between;
	padding: 6px 10px;
}

.shape-visibility-toggle {
	padding: 3px 6px;
	border-radius: 3px;
	outline: none;
	border: none;
	background: none;
	flex-shrink: 0;
}
.shape-visibility-toggle:hover {
	cursor: pointer;
	background-color: #0000000b;
}

.layer-panel-title {
	padding: 10px;
	font-size: smaller;
	font-weight: bolder;
}

.shape-name-input {
	border: none;
	background: none;
	width: 0;
	flex-grow: 1;
	padding: 0;
}

.shape-name {
	overflow: hidden;
	text-overflow: ellipsis;
	text-wrap: nowrap;
}
```
### snapshot.json

```json
{
	"document": {
		"store": {
			"document:document": {
				"gridSize": 10,
				"name": "",
				"meta": {},
				"id": "document:document",
				"typeName": "document"
			},
			"page:page": {
				"meta": {},
				"id": "page:page",
				"name": "Page 1",
				"index": "a1",
				"typeName": "page"
			},
			"shape:2E29fCb7Xp6JJ7XMRqmOX": {
				"x": 23.14393383125298,
				"y": 26.92246872311614,
				"rotation": 0,
				"isLocked": false,
				"opacity": 1,
				"meta": {},
				"id": "shape:2E29fCb7Xp6JJ7XMRqmOX",
				"type": "text",
				"props": {
					"color": "black",
					"size": "m",
					"w": 295.3359375,
					"text": "I am some text.\nThis is right and proper",
					"font": "draw",
					"textAlign": "start",
					"autoSize": true,
					"scale": 0.9138163638426346
				},
				"parentId": "shape:pC3Ukh78gTCv6GOQ4zn22",
				"index": "a1",
				"typeName": "shape"
			},
			"shape:7BSFn-vb4BwE_lf0BN725": {
				"x": 55.921875,
				"y": 23.38015831238215,
				"rotation": 0,
				"isLocked": false,
				"opacity": 1,
				"meta": {
					"hidden": false,
					"name": "Green"
				},
				"id": "shape:7BSFn-vb4BwE_lf0BN725",
				"type": "geo",
				"props": {
					"w": 66.21875,
					"h": 55.33296668761847,
					"geo": "heart",
					"color": "light-green",
					"labelColor": "black",
					"fill": "solid",
					"dash": "draw",
					"size": "m",
					"font": "draw",
					"text": "",
					"align": "middle",
					"verticalAlign": "middle",
					"growY": 0,
					"url": "",
					"scale": 1
				},
				"parentId": "shape:Yu75LoX6xZZ3CnwMlYV6h",
				"index": "a24Og",
				"typeName": "shape"
			},
			"shape:KSxmiQpQPZ1xcGNr5hWR2": {
				"x": 523.453125,
				"y": 351.890625,
				"rotation": 0,
				"isLocked": false,
				"opacity": 1,
				"meta": {
					"hidden": false
				},
				"id": "shape:KSxmiQpQPZ1xcGNr5hWR2",
				"type": "frame",
				"props": {
					"w": 419.24609375,
					"h": 253.73828125,
					"name": ""
				},
				"parentId": "page:page",
				"index": "a2BmH",
				"typeName": "shape"
			},
			"shape:MlpVtR23pXzap5jL4KzZ-": {
				"x": 21.16015625,
				"y": 17.15625,
				"rotation": 0,
				"isLocked": false,
				"opacity": 1,
				"meta": {
					"hidden": false
				},
				"id": "shape:MlpVtR23pXzap5jL4KzZ-",
				"type": "text",
				"props": {
					"color": "black",
					"size": "m",
					"w": 250.7734375,
					"text": "howdy i am a frame",
					"font": "draw",
					"textAlign": "start",
					"autoSize": true,
					"scale": 1
				},
				"parentId": "shape:KSxmiQpQPZ1xcGNr5hWR2",
				"index": "a1",
				"typeName": "shape"
			},
			"shape:SHGiETBnoma5LpiO7QxJP": {
				"x": 85.30878454832236,
				"y": 108.38218185642694,
				"rotation": 0,
				"isLocked": false,
				"opacity": 1,
				"meta": {},
				"id": "shape:SHGiETBnoma5LpiO7QxJP",
				"type": "geo",
				"props": {
					"w": 260.6563826944372,
					"h": 94.93444908665725,
					"geo": "cloud",
					"color": "red",
					"labelColor": "black",
					"fill": "none",
					"dash": "dotted",
					"size": "m",
					"font": "draw",
					"text": "i am a cloud",
					"align": "middle",
					"verticalAlign": "middle",
					"growY": 0,
					"url": "",
					"scale": 1
				},
				"parentId": "shape:KSxmiQpQPZ1xcGNr5hWR2",
				"index": "a29bI",
				"typeName": "shape"
			},
			"shape:V2EXec6ocrVMEYJ4F1YOz": {
				"x": 65.6953125,
				"y": 97.26171875,
				"rotation": 0,
				"isLocked": false,
				"opacity": 1,
				"meta": {
					"name": "Hey",
					"hidden": false
				},
				"id": "shape:V2EXec6ocrVMEYJ4F1YOz",
				"type": "draw",
				"props": {
					"segments": [
						{
							"type": "free",
							"points": [
								{
									"x": 0,
									"y": 0,
									"z": 0.5
								},
								{
									"x": 0.44,
									"y": 0.14,
									"z": 0.5
								},
								{
									"x": 1.14,
									"y": 0.29,
									"z": 0.5
								},
								{
									"x": 1.91,
									"y": 0.29,
									"z": 0.5
								},
								{
									"x": 3.73,
									"y": 0.29,
									"z": 0.5
								},
								{
									"x": 7.59,
									"y": 0.29,
									"z": 0.5
								},
								{
									"x": 11.96,
									"y": 0.29,
									"z": 0.5
								},
								{
									"x": 15.3,
									"y": 0.29,
									"z": 0.5
								},
								{
									"x": 26.21,
									"y": 0.1,
									"z": 0.5
								},
								{
									"x": 30.11,
									"y": -0.69,
									"z": 0.5
								},
								{
									"x": 37.88,
									"y": -3.89,
									"z": 0.5
								},
								{
									"x": 40.68,
									"y": -5.93,
									"z": 0.5
								},
								{
									"x": 44.4,
									"y": -9.1,
									"z": 0.5
								},
								{
									"x": 47.68,
									"y": -12.72,
									"z": 0.5
								},
								{
									"x": 48.83,
									"y": -14.96,
									"z": 0.5
								},
								{
									"x": 49.86,
									"y": -18.77,
									"z": 0.5
								},
								{
									"x": 50.7,
									"y": -23.29,
									"z": 0.5
								},
								{
									"x": 50.86,
									"y": -26,
									"z": 0.5
								},
								{
									"x": 50.71,
									"y": -33.25,
									"z": 0.5
								},
								{
									"x": 49.89,
									"y": -34.83,
									"z": 0.5
								},
								{
									"x": 44.86,
									"y": -40.89,
									"z": 0.5
								},
								{
									"x": 41.84,
									"y": -42.36,
									"z": 0.5
								},
								{
									"x": 37.45,
									"y": -43.99,
									"z": 0.5
								},
								{
									"x": 35.18,
									"y": -44.21,
									"z": 0.5
								},
								{
									"x": 31.91,
									"y": -44.32,
									"z": 0.5
								},
								{
									"x": 29.62,
									"y": -44.19,
									"z": 0.5
								},
								{
									"x": 27.75,
									"y": -43.46,
									"z": 0.5
								},
								{
									"x": 25.87,
									"y": -41.23,
									"z": 0.5
								},
								{
									"x": 23.63,
									"y": -37.57,
									"z": 0.5
								},
								{
									"x": 21.33,
									"y": -29.09,
									"z": 0.5
								},
								{
									"x": 21.11,
									"y": -21.17,
									"z": 0.5
								},
								{
									"x": 21.28,
									"y": -11.23,
									"z": 0.5
								},
								{
									"x": 22.34,
									"y": -4.41,
									"z": 0.5
								},
								{
									"x": 28.58,
									"y": 17.46,
									"z": 0.5
								},
								{
									"x": 31.34,
									"y": 24.93,
									"z": 0.5
								},
								{
									"x": 36.64,
									"y": 36.99,
									"z": 0.5
								},
								{
									"x": 42.54,
									"y": 49.75,
									"z": 0.5
								},
								{
									"x": 46.3,
									"y": 58.32,
									"z": 0.5
								},
								{
									"x": 52.37,
									"y": 72.09,
									"z": 0.5
								},
								{
									"x": 61.37,
									"y": 94.49,
									"z": 0.5
								},
								{
									"x": 66.52,
									"y": 108.92,
									"z": 0.5
								},
								{
									"x": 68.32,
									"y": 115.91,
									"z": 0.5
								},
								{
									"x": 70.38,
									"y": 125.99,
									"z": 0.5
								},
								{
									"x": 71.08,
									"y": 134.16,
									"z": 0.5
								},
								{
									"x": 70.93,
									"y": 139.88,
									"z": 0.5
								},
								{
									"x": 68.74,
									"y": 145.53,
									"z": 0.5
								},
								{
									"x": 64.62,
									"y": 150.31,
									"z": 0.5
								},
								{
									"x": 59.76,
									"y": 151.97,
									"z": 0.5
								},
								{
									"x": 53.96,
									"y": 153.43,
									"z": 0.5
								},
								{
									"x": 49.13,
									"y": 154.24,
									"z": 0.5
								},
								{
									"x": 45.66,
									"y": 154.39,
									"z": 0.5
								},
								{
									"x": 39.24,
									"y": 154.56,
									"z": 0.5
								},
								{
									"x": 33.64,
									"y": 154.49,
									"z": 0.5
								},
								{
									"x": 29.26,
									"y": 153.19,
									"z": 0.5
								},
								{
									"x": 25.14,
									"y": 151.46,
									"z": 0.5
								},
								{
									"x": 23.13,
									"y": 149.81,
									"z": 0.5
								},
								{
									"x": 21.34,
									"y": 148.11,
									"z": 0.5
								},
								{
									"x": 20.04,
									"y": 145.26,
									"z": 0.5
								},
								{
									"x": 19.79,
									"y": 140.88,
									"z": 0.5
								},
								{
									"x": 21.64,
									"y": 137.54,
									"z": 0.5
								},
								{
									"x": 27.26,
									"y": 132.11,
									"z": 0.5
								},
								{
									"x": 33.93,
									"y": 126.09,
									"z": 0.5
								},
								{
									"x": 43.28,
									"y": 118.9,
									"z": 0.5
								},
								{
									"x": 54.8,
									"y": 109.45,
									"z": 0.5
								},
								{
									"x": 76.47,
									"y": 90.02,
									"z": 0.5
								},
								{
									"x": 95.7,
									"y": 72.28,
									"z": 0.5
								},
								{
									"x": 101.2,
									"y": 66.12,
									"z": 0.5
								},
								{
									"x": 120.61,
									"y": 41.43,
									"z": 0.5
								},
								{
									"x": 124.91,
									"y": 33.9,
									"z": 0.5
								},
								{
									"x": 129.73,
									"y": 22.73,
									"z": 0.5
								},
								{
									"x": 133.54,
									"y": 12.56,
									"z": 0.5
								},
								{
									"x": 134.63,
									"y": 6.59,
									"z": 0.5
								},
								{
									"x": 135.97,
									"y": -2.75,
									"z": 0.5
								},
								{
									"x": 136.71,
									"y": -17.1,
									"z": 0.5
								},
								{
									"x": 136.63,
									"y": -28.66,
									"z": 0.5
								},
								{
									"x": 135.79,
									"y": -33.26,
									"z": 0.5
								},
								{
									"x": 133.5,
									"y": -40.16,
									"z": 0.5
								},
								{
									"x": 130.95,
									"y": -46.79,
									"z": 0.5
								},
								{
									"x": 129.65,
									"y": -49.07,
									"z": 0.5
								},
								{
									"x": 127.59,
									"y": -52.43,
									"z": 0.5
								},
								{
									"x": 125.39,
									"y": -56.14,
									"z": 0.5
								},
								{
									"x": 124.27,
									"y": -57.65,
									"z": 0.5
								},
								{
									"x": 122.38,
									"y": -59.64,
									"z": 0.5
								},
								{
									"x": 119.87,
									"y": -61.68,
									"z": 0.5
								},
								{
									"x": 117.63,
									"y": -62.46,
									"z": 0.5
								},
								{
									"x": 116.19,
									"y": -62.52,
									"z": 0.5
								},
								{
									"x": 115.55,
									"y": -62.23,
									"z": 0.5
								},
								{
									"x": 114.65,
									"y": -60.7,
									"z": 0.5
								},
								{
									"x": 113.61,
									"y": -58.35,
									"z": 0.5
								},
								{
									"x": 112.76,
									"y": -55.82,
									"z": 0.5
								},
								{
									"x": 111.15,
									"y": -49.55,
									"z": 0.5
								},
								{
									"x": 109.6,
									"y": -42.26,
									"z": 0.5
								},
								{
									"x": 108.58,
									"y": -35.39,
									"z": 0.5
								},
								{
									"x": 107.4,
									"y": -26.96,
									"z": 0.5
								},
								{
									"x": 106.74,
									"y": -20.08,
									"z": 0.5
								},
								{
									"x": 106.54,
									"y": -14,
									"z": 0.5
								},
								{
									"x": 106.37,
									"y": -2.8,
									"z": 0.5
								},
								{
									"x": 106.28,
									"y": 7.85,
									"z": 0.5
								},
								{
									"x": 106.27,
									"y": 19.49,
									"z": 0.5
								},
								{
									"x": 106.25,
									"y": 33.38,
									"z": 0.5
								},
								{
									"x": 106.88,
									"y": 41.77,
									"z": 0.5
								},
								{
									"x": 109.42,
									"y": 54.66,
									"z": 0.5
								},
								{
									"x": 112.41,
									"y": 69.13,
									"z": 0.5
								},
								{
									"x": 114.55,
									"y": 77.64,
									"z": 0.5
								},
								{
									"x": 118.51,
									"y": 90.79,
									"z": 0.5
								},
								{
									"x": 123.4,
									"y": 105.02,
									"z": 0.5
								},
								{
									"x": 126.22,
									"y": 110.85,
									"z": 0.5
								},
								{
									"x": 130.61,
									"y": 118.18,
									"z": 0.5
								},
								{
									"x": 136.33,
									"y": 126.75,
									"z": 0.5
								},
								{
									"x": 140.02,
									"y": 130.86,
									"z": 0.5
								},
								{
									"x": 151.61,
									"y": 140.95,
									"z": 0.5
								},
								{
									"x": 156.43,
									"y": 143.2,
									"z": 0.5
								},
								{
									"x": 160.26,
									"y": 144.32,
									"z": 0.5
								},
								{
									"x": 165.38,
									"y": 145.17,
									"z": 0.5
								},
								{
									"x": 171.16,
									"y": 145.8,
									"z": 0.5
								},
								{
									"x": 173.93,
									"y": 145.55,
									"z": 0.5
								},
								{
									"x": 177.35,
									"y": 144.19,
									"z": 0.5
								},
								{
									"x": 182.41,
									"y": 140.88,
									"z": 0.5
								},
								{
									"x": 186.52,
									"y": 136.84,
									"z": 0.5
								},
								{
									"x": 188.79,
									"y": 133.56,
									"z": 0.5
								},
								{
									"x": 191.45,
									"y": 128.8,
									"z": 0.5
								},
								{
									"x": 193.86,
									"y": 123.57,
									"z": 0.5
								},
								{
									"x": 194.73,
									"y": 118.88,
									"z": 0.5
								},
								{
									"x": 195.23,
									"y": 114.32,
									"z": 0.5
								},
								{
									"x": 195.44,
									"y": 109.96,
									"z": 0.5
								},
								{
									"x": 195.48,
									"y": 105.44,
									"z": 0.5
								},
								{
									"x": 194.99,
									"y": 102.75,
									"z": 0.5
								},
								{
									"x": 193.54,
									"y": 100.21,
									"z": 0.5
								},
								{
									"x": 191.56,
									"y": 96.96,
									"z": 0.5
								},
								{
									"x": 189.9,
									"y": 94.92,
									"z": 0.5
								},
								{
									"x": 187.14,
									"y": 92.78,
									"z": 0.5
								},
								{
									"x": 184.71,
									"y": 91.25,
									"z": 0.5
								},
								{
									"x": 183.5,
									"y": 90.94,
									"z": 0.5
								},
								{
									"x": 180.91,
									"y": 90.14,
									"z": 0.5
								},
								{
									"x": 178.83,
									"y": 89.78,
									"z": 0.5
								},
								{
									"x": 177.29,
									"y": 89.75,
									"z": 0.5
								},
								{
									"x": 175.55,
									"y": 89.68,
									"z": 0.5
								},
								{
									"x": 174.62,
									"y": 90.11,
									"z": 0.5
								},
								{
									"x": 173.54,
									"y": 91.56,
									"z": 0.5
								},
								{
									"x": 172.76,
									"y": 93.16,
									"z": 0.5
								},
								{
									"x": 172.24,
									"y": 96,
									"z": 0.5
								},
								{
									"x": 171.74,
									"y": 101.41,
									"z": 0.5
								},
								{
									"x": 172.09,
									"y": 107.81,
									"z": 0.5
								},
								{
									"x": 175.33,
									"y": 116.21,
									"z": 0.5
								},
								{
									"x": 179.73,
									"y": 123.16,
									"z": 0.5
								},
								{
									"x": 183.68,
									"y": 126.92,
									"z": 0.5
								},
								{
									"x": 189.36,
									"y": 131.26,
									"z": 0.5
								},
								{
									"x": 196.93,
									"y": 135.14,
									"z": 0.5
								},
								{
									"x": 202.16,
									"y": 136.69,
									"z": 0.5
								},
								{
									"x": 210.29,
									"y": 137.8,
									"z": 0.5
								},
								{
									"x": 218.77,
									"y": 138.86,
									"z": 0.5
								},
								{
									"x": 222.48,
									"y": 138.68,
									"z": 0.5
								},
								{
									"x": 226.53,
									"y": 137.7,
									"z": 0.5
								},
								{
									"x": 232.79,
									"y": 134.57,
									"z": 0.5
								},
								{
									"x": 237.85,
									"y": 131.29,
									"z": 0.5
								},
								{
									"x": 241.4,
									"y": 126.41,
									"z": 0.5
								},
								{
									"x": 245.43,
									"y": 120.48,
									"z": 0.5
								},
								{
									"x": 247.31,
									"y": 115.09,
									"z": 0.5
								},
								{
									"x": 248.71,
									"y": 107.28,
									"z": 0.5
								},
								{
									"x": 249.1,
									"y": 102.27,
									"z": 0.5
								},
								{
									"x": 249.13,
									"y": 91.84,
									"z": 0.5
								},
								{
									"x": 248.77,
									"y": 90.51,
									"z": 0.5
								},
								{
									"x": 248.01,
									"y": 88.01,
									"z": 0.5
								},
								{
									"x": 247.36,
									"y": 85.84,
									"z": 0.5
								},
								{
									"x": 247.06,
									"y": 85.09,
									"z": 0.5
								},
								{
									"x": 246.59,
									"y": 84.08,
									"z": 0.5
								},
								{
									"x": 246.2,
									"y": 83.23,
									"z": 0.5
								},
								{
									"x": 246.07,
									"y": 82.98,
									"z": 0.5
								},
								{
									"x": 245.91,
									"y": 82.7,
									"z": 0.5
								},
								{
									"x": 245.79,
									"y": 82.7,
									"z": 0.5
								},
								{
									"x": 245.78,
									"y": 83.22,
									"z": 0.5
								},
								{
									"x": 245.78,
									"y": 84.68,
									"z": 0.5
								},
								{
									"x": 245.77,
									"y": 86.57,
									"z": 0.5
								},
								{
									"x": 246.25,
									"y": 91.24,
									"z": 0.5
								},
								{
									"x": 246.67,
									"y": 93.34,
									"z": 0.5
								},
								{
									"x": 247.55,
									"y": 97.32,
									"z": 0.5
								},
								{
									"x": 248.66,
									"y": 101.55,
									"z": 0.5
								},
								{
									"x": 249.91,
									"y": 104.41,
									"z": 0.5
								},
								{
									"x": 252.36,
									"y": 108.89,
									"z": 0.5
								},
								{
									"x": 256.15,
									"y": 114.84,
									"z": 0.5
								},
								{
									"x": 261.02,
									"y": 120.5,
									"z": 0.5
								},
								{
									"x": 265.86,
									"y": 124.98,
									"z": 0.5
								},
								{
									"x": 269.3,
									"y": 127.36,
									"z": 0.5
								},
								{
									"x": 272.22,
									"y": 128.66,
									"z": 0.5
								},
								{
									"x": 279.42,
									"y": 130.68,
									"z": 0.5
								},
								{
									"x": 287.05,
									"y": 132.02,
									"z": 0.5
								},
								{
									"x": 294.17,
									"y": 131.34,
									"z": 0.5
								},
								{
									"x": 302.85,
									"y": 128.85,
									"z": 0.5
								},
								{
									"x": 313.5,
									"y": 120.45,
									"z": 0.5
								},
								{
									"x": 322,
									"y": 112.3,
									"z": 0.5
								},
								{
									"x": 324.66,
									"y": 108.6,
									"z": 0.5
								},
								{
									"x": 328.81,
									"y": 101.77,
									"z": 0.5
								},
								{
									"x": 332.66,
									"y": 94.3,
									"z": 0.5
								},
								{
									"x": 334.07,
									"y": 89.97,
									"z": 0.5
								},
								{
									"x": 335.26,
									"y": 83.64,
									"z": 0.5
								},
								{
									"x": 336.04,
									"y": 78.17,
									"z": 0.5
								},
								{
									"x": 336.04,
									"y": 76.5,
									"z": 0.5
								},
								{
									"x": 336.04,
									"y": 73.37,
									"z": 0.5
								},
								{
									"x": 336.04,
									"y": 70.45,
									"z": 0.5
								},
								{
									"x": 336.04,
									"y": 69.45,
									"z": 0.5
								},
								{
									"x": 336.04,
									"y": 68.2,
									"z": 0.5
								},
								{
									"x": 336.04,
									"y": 67.35,
									"z": 0.5
								},
								{
									"x": 336.04,
									"y": 67.2,
									"z": 0.5
								},
								{
									"x": 336.04,
									"y": 66.78,
									"z": 0.5
								},
								{
									"x": 336.04,
									"y": 66.8,
									"z": 0.5
								},
								{
									"x": 336.04,
									"y": 68.13,
									"z": 0.5
								},
								{
									"x": 336.04,
									"y": 70.28,
									"z": 0.5
								},
								{
									"x": 336.16,
									"y": 72.27,
									"z": 0.5
								},
								{
									"x": 337.6,
									"y": 77.31,
									"z": 0.5
								},
								{
									"x": 339.9,
									"y": 83.81,
									"z": 0.5
								},
								{
									"x": 341.71,
									"y": 88.11,
									"z": 0.5
								},
								{
									"x": 345.83,
									"y": 96.41,
									"z": 0.5
								},
								{
									"x": 350.66,
									"y": 105.26,
									"z": 0.5
								},
								{
									"x": 353.31,
									"y": 109.66,
									"z": 0.5
								},
								{
									"x": 359.54,
									"y": 121.07,
									"z": 0.5
								},
								{
									"x": 364.64,
									"y": 130.93,
									"z": 0.5
								},
								{
									"x": 366.14,
									"y": 134.26,
									"z": 0.5
								},
								{
									"x": 369.95,
									"y": 143.39,
									"z": 0.5
								},
								{
									"x": 372.52,
									"y": 151.19,
									"z": 0.5
								},
								{
									"x": 373.6,
									"y": 157.53,
									"z": 0.5
								},
								{
									"x": 374.41,
									"y": 165.28,
									"z": 0.5
								},
								{
									"x": 372.93,
									"y": 169.71,
									"z": 0.5
								},
								{
									"x": 367.79,
									"y": 174.23,
									"z": 0.5
								},
								{
									"x": 360.38,
									"y": 178.49,
									"z": 0.5
								},
								{
									"x": 353.18,
									"y": 180.41,
									"z": 0.5
								},
								{
									"x": 341.12,
									"y": 182.47,
									"z": 0.5
								},
								{
									"x": 330.2,
									"y": 183.96,
									"z": 0.5
								},
								{
									"x": 324.82,
									"y": 184.14,
									"z": 0.5
								},
								{
									"x": 315.26,
									"y": 184.19,
									"z": 0.5
								},
								{
									"x": 307.75,
									"y": 184.24,
									"z": 0.5
								},
								{
									"x": 305.41,
									"y": 184.11,
									"z": 0.5
								},
								{
									"x": 300.77,
									"y": 183.23,
									"z": 0.5
								},
								{
									"x": 297.25,
									"y": 180.6,
									"z": 0.5
								},
								{
									"x": 299.62,
									"y": 177,
									"z": 0.5
								},
								{
									"x": 305.46,
									"y": 173.45,
									"z": 0.5
								},
								{
									"x": 317.14,
									"y": 166.71,
									"z": 0.5
								},
								{
									"x": 330.66,
									"y": 158.64,
									"z": 0.5
								},
								{
									"x": 340.77,
									"y": 152.09,
									"z": 0.5
								},
								{
									"x": 355.63,
									"y": 141.69,
									"z": 0.5
								},
								{
									"x": 373.86,
									"y": 126.73,
									"z": 0.5
								},
								{
									"x": 389.38,
									"y": 111.63,
									"z": 0.5
								},
								{
									"x": 409.39,
									"y": 84.97,
									"z": 0.5
								},
								{
									"x": 422.51,
									"y": 61.14,
									"z": 0.5
								},
								{
									"x": 426.6,
									"y": 44.95,
									"z": 0.5
								},
								{
									"x": 430.75,
									"y": 21.38,
									"z": 0.5
								},
								{
									"x": 430.49,
									"y": -1.03,
									"z": 0.5
								},
								{
									"x": 426.76,
									"y": -18.87,
									"z": 0.5
								},
								{
									"x": 420.16,
									"y": -31.2,
									"z": 0.5
								},
								{
									"x": 408.49,
									"y": -47.03,
									"z": 0.5
								},
								{
									"x": 397.35,
									"y": -59.73,
									"z": 0.5
								},
								{
									"x": 389.43,
									"y": -65.18,
									"z": 0.5
								},
								{
									"x": 375.86,
									"y": -73.47,
									"z": 0.5
								},
								{
									"x": 361.91,
									"y": -80.23,
									"z": 0.5
								},
								{
									"x": 353.09,
									"y": -82.81,
									"z": 0.5
								},
								{
									"x": 339.45,
									"y": -84.83,
									"z": 0.5
								},
								{
									"x": 324.64,
									"y": -86.14,
									"z": 0.5
								},
								{
									"x": 316.8,
									"y": -86.14,
									"z": 0.5
								},
								{
									"x": 308,
									"y": -85.28,
									"z": 0.5
								},
								{
									"x": 300.98,
									"y": -83.28,
									"z": 0.5
								},
								{
									"x": 297.62,
									"y": -80.89,
									"z": 0.5
								},
								{
									"x": 288.9,
									"y": -67.85,
									"z": 0.5
								},
								{
									"x": 294.11,
									"y": -59.36,
									"z": 0.5
								},
								{
									"x": 303.91,
									"y": -55.25,
									"z": 0.5
								}
							]
						}
					],
					"color": "black",
					"fill": "none",
					"dash": "draw",
					"size": "m",
					"isComplete": true,
					"isClosed": false,
					"isPen": false,
					"scale": 1
				},
				"parentId": "shape:uDYVWEWm2-73skQSH6bvO",
				"index": "a1",
				"typeName": "shape"
			},
			"shape:X2P_zA-YWYustVxUpPlAD": {
				"x": 498.93978421901375,
				"y": 205.234375,
				"rotation": 0,
				"isLocked": false,
				"opacity": 1,
				"meta": {
					"hidden": false
				},
				"id": "shape:X2P_zA-YWYustVxUpPlAD",
				"type": "text",
				"props": {
					"color": "black",
					"size": "m",
					"w": 25,
					"text": "🐢",
					"font": "draw",
					"textAlign": "start",
					"autoSize": true,
					"scale": 3.7107547624789006
				},
				"parentId": "shape:uDYVWEWm2-73skQSH6bvO",
				"index": "a22lA",
				"typeName": "shape"
			},
			"shape:Yu75LoX6xZZ3CnwMlYV6h": {
				"x": 248.875,
				"y": 417.7790624999994,
				"rotation": 0,
				"isLocked": false,
				"opacity": 1,
				"meta": {
					"name": "Hearts",
					"hidden": false
				},
				"id": "shape:Yu75LoX6xZZ3CnwMlYV6h",
				"type": "group",
				"parentId": "page:page",
				"index": "a61dg",
				"props": {},
				"typeName": "shape"
			},
			"shape:dlQla6vDH_jrodsF3sSH1": {
				"x": 0,
				"y": 36.38015831238215,
				"rotation": 0,
				"isLocked": false,
				"opacity": 1,
				"meta": {
					"hidden": false,
					"name": "Blue"
				},
				"id": "shape:dlQla6vDH_jrodsF3sSH1",
				"type": "geo",
				"props": {
					"w": 66.21875,
					"h": 55.33296668761847,
					"geo": "heart",
					"color": "light-blue",
					"labelColor": "black",
					"fill": "solid",
					"dash": "draw",
					"size": "m",
					"font": "draw",
					"text": "",
					"align": "middle",
					"verticalAlign": "middle",
					"growY": 0,
					"url": "",
					"scale": 1
				},
				"parentId": "shape:Yu75LoX6xZZ3CnwMlYV6h",
				"index": "a3Br7",
				"typeName": "shape"
			},
			"shape:f3p0iOBXUZ4LjFYGGneBY": {
				"x": 12.56640625,
				"y": -0.31124793761784986,
				"rotation": 0,
				"isLocked": false,
				"opacity": 1,
				"meta": {
					"hidden": false,
					"name": "Red"
				},
				"id": "shape:f3p0iOBXUZ4LjFYGGneBY",
				"type": "geo",
				"props": {
					"w": 66.21875,
					"h": 55.33296668761847,
					"geo": "heart",
					"color": "red",
					"labelColor": "black",
					"fill": "solid",
					"dash": "draw",
					"size": "m",
					"font": "draw",
					"text": "",
					"align": "middle",
					"verticalAlign": "middle",
					"growY": 0,
					"url": "",
					"scale": 1
				},
				"parentId": "shape:Yu75LoX6xZZ3CnwMlYV6h",
				"index": "a1",
				"typeName": "shape"
			},
			"shape:pC3Ukh78gTCv6GOQ4zn22": {
				"x": 87.80044663643741,
				"y": 689.2766739442229,
				"rotation": 0,
				"isLocked": false,
				"opacity": 1,
				"meta": {},
				"id": "shape:pC3Ukh78gTCv6GOQ4zn22",
				"type": "frame",
				"parentId": "page:page",
				"index": "a80ok",
				"props": {
					"w": 320,
					"h": 180,
					"name": "this is a frame"
				},
				"typeName": "shape"
			},
			"shape:uDYVWEWm2-73skQSH6bvO": {
				"x": 458.328125,
				"y": 690.00390625,
				"rotation": 0,
				"isLocked": false,
				"opacity": 1,
				"meta": {
					"hidden": true
				},
				"id": "shape:uDYVWEWm2-73skQSH6bvO",
				"type": "frame",
				"props": {
					"w": 592.73828125,
					"h": 313.16796875,
					"name": "Secret stuff"
				},
				"parentId": "page:page",
				"index": "a1",
				"typeName": "shape"
			},
			"shape:zvgIK801i6HR9kF8BAr0A": {
				"x": 41.55078125,
				"y": 55.06765831238215,
				"rotation": 0,
				"isLocked": false,
				"opacity": 1,
				"meta": {
					"hidden": false,
					"name": "Gold"
				},
				"id": "shape:zvgIK801i6HR9kF8BAr0A",
				"type": "geo",
				"props": {
					"w": 66.21875,
					"h": 55.33296668761847,
					"geo": "heart",
					"color": "yellow",
					"labelColor": "black",
					"fill": "solid",
					"dash": "draw",
					"size": "m",
					"font": "draw",
					"text": "",
					"align": "middle",
					"verticalAlign": "middle",
					"growY": 0,
					"url": "",
					"scale": 1
				},
				"parentId": "shape:Yu75LoX6xZZ3CnwMlYV6h",
				"index": "a434G",
				"typeName": "shape"
			}
		},
		"schema": {
			"schemaVersion": 2,
			"sequences": {
				"com.tldraw.store": 4,
				"com.tldraw.asset": 1,
				"com.tldraw.camera": 1,
				"com.tldraw.document": 2,
				"com.tldraw.instance": 25,
				"com.tldraw.instance_page_state": 5,
				"com.tldraw.page": 1,
				"com.tldraw.instance_presence": 5,
				"com.tldraw.pointer": 1,
				"com.tldraw.shape": 4,
				"com.tldraw.asset.bookmark": 2,
				"com.tldraw.asset.image": 5,
				"com.tldraw.asset.video": 5,
				"com.tldraw.shape.group": 0,
				"com.tldraw.shape.text": 2,
				"com.tldraw.shape.bookmark": 2,
				"com.tldraw.shape.draw": 2,
				"com.tldraw.shape.geo": 9,
				"com.tldraw.shape.note": 7,
				"com.tldraw.shape.line": 5,
				"com.tldraw.shape.frame": 0,
				"com.tldraw.shape.arrow": 5,
				"com.tldraw.shape.highlight": 1,
				"com.tldraw.shape.embed": 4,
				"com.tldraw.shape.image": 4,
				"com.tldraw.shape.video": 2,
				"com.tldraw.binding.arrow": 0
			}
		}
	},
	"session": {
		"version": 0,
		"currentPageId": "page:page",
		"exportBackground": true,
		"isFocusMode": false,
		"isDebugMode": true,
		"isToolLocked": false,
		"isGridMode": false,
		"pageStates": [
			{
				"pageId": "page:page",
				"camera": {
					"x": 266.60725344785806,
					"y": -280.6819614737602,
					"z": 0.8848541364668738
				},
				"selectedShapeIds": [],
				"focusedGroupId": null
			}
		]
	}
}
```

## Tldraw image component

Keywords: snapshot, export

Display a tldraw snapshot as an image by using the `TldrawImage` component.



### App.tsx

```tsx
import { useState } from 'react'
import {
	Box,
	Editor,
	StoreSnapshot,
	TLPageId,
	TLRecord,
	TLStoreSnapshot,
	Tldraw,
	TldrawImage,
	getSnapshot,
} from 'tldraw'
import 'tldraw/tldraw.css'
import initialSnapshot from './snapshot.json'

// There's a guide at the bottom of this file!

export default function TldrawImageExample() {
	const [editor, setEditor] = useState<Editor>()
	const [snapshot, setSnapshot] = useState<StoreSnapshot<TLRecord>>(
		initialSnapshot as TLStoreSnapshot
	)
	const [currentPageId, setCurrentPageId] = useState<TLPageId | undefined>()
	const [showBackground, setShowBackground] = useState(true)
	const [isDarkMode, setIsDarkMode] = useState(false)
	const [viewportPageBounds, setViewportPageBounds] = useState(new Box(0, 0, 600, 400))
	const [isEditing, setIsEditing] = useState(false)
	const [format, setFormat] = useState<'svg' | 'png'>('svg')

	return (
		<div style={{ padding: 30 }}>
			<div>
				<button
					style={{ cursor: 'pointer', marginRight: 8 }}
					onClick={() => {
						if (isEditing) {
							if (!editor) return
							setIsDarkMode(editor.user.getIsDarkMode())
							setShowBackground(editor.getInstanceState().exportBackground)
							setViewportPageBounds(editor.getViewportPageBounds())
							setCurrentPageId(editor.getCurrentPageId())
							setSnapshot(getSnapshot(editor.store).document)
							setIsEditing(false)
						} else {
							setIsEditing(true)
						}
					}}
				>
					{isEditing ? '✓ Save drawing' : '✎ Edit drawing'}
				</button>
				{!isEditing && (
					<>
						<label htmlFor="format" style={{ marginRight: 8 }}>
							Format
						</label>
						<select
							name="format"
							value={format}
							onChange={(e) => {
								setFormat(e.currentTarget.value as 'svg' | 'png')
							}}
						>
							<option value="svg">SVG</option>
							<option value="png">PNG</option>
						</select>
					</>
				)}
			</div>
			<div style={{ width: 600, height: 400, marginTop: 15 }}>
				{isEditing ? (
					<Tldraw
						snapshot={snapshot}
						onMount={(editor: Editor) => {
							setEditor(editor)
							editor.user.updateUserPreferences({ colorScheme: isDarkMode ? 'dark' : 'light' })
							if (currentPageId) {
								editor.setCurrentPage(currentPageId)
							}
							if (viewportPageBounds) {
								editor.zoomToBounds(viewportPageBounds, { inset: 0 })
							}
						}}
					/>
				) : (
					<TldrawImage
						//[1]
						snapshot={snapshot}
						// [2]
						pageId={currentPageId}
						// [3]
						background={showBackground}
						darkMode={isDarkMode}
						bounds={viewportPageBounds}
						padding={0}
						scale={1}
						format={format}
					/>
				)}
			</div>
		</div>
	)
}

/*

This example shows how to use the `TldrawImage` component to display a snapshot
as an image. The example also allows you to toggle between editing the snapshot
and viewing it.

[1] Pass your snapshot to the `snapshot` prop of the `TldrawImage` component.

[2] You can specify which page to display by using the `pageId` prop. By
    default, the first page is shown.

[3] You can customize the appearance of the image by passing other props to the
        `TldrawImage` component. For example, you can toggle the background, set
        the dark mode, and specify the viewport bounds.
 */
```
### snapshot.json

```json
{
	"store": {
		"document:document": {
			"gridSize": 10,
			"name": "",
			"meta": {},
			"id": "document:document",
			"typeName": "document"
		},
		"page:3qj9EtNgqSCW_6knX2K9_": {
			"meta": {},
			"id": "page:3qj9EtNgqSCW_6knX2K9_",
			"name": "Page 1",
			"index": "a1",
			"typeName": "page"
		},
		"asset:imageAssetA": {
			"type": "image",
			"props": {
				"w": 1200,
				"h": 800,
				"name": "",
				"isAnimated": false,
				"mimeType": "png",
				"src": ""
			},
			"meta": {},
			"id": "asset:imageAssetA",
			"typeName": "asset"
		},
		"shape:EHeAIsYe4xu1-kGxK-Tl_": {
			"x": 108.01190683749454,
			"y": 138.58783300957418,
			"rotation": 0,
			"isLocked": false,
			"opacity": 1,
			"meta": {},
			"type": "draw",
			"props": {
				"segments": [
					{
						"type": "free",
						"points": [
							{ "x": 0, "y": 0, "z": 0.5 },
							{ "x": -0.07, "y": 0.07, "z": 0.5 },
							{ "x": -0.03, "y": 0.14, "z": 0.5 },
							{ "x": 0.47, "y": 0.14, "z": 0.5 },
							{ "x": 3.54, "y": 0.14, "z": 0.5 },
							{ "x": 10.47, "y": -1.05, "z": 0.5 },
							{ "x": 17.57, "y": -3.65, "z": 0.5 },
							{ "x": 24.13, "y": -7.67, "z": 0.5 },
							{ "x": 31.36, "y": -13.59, "z": 0.5 },
							{ "x": 36.65, "y": -20.16, "z": 0.5 },
							{ "x": 39.27, "y": -26.49, "z": 0.5 },
							{ "x": 40.12, "y": -32.21, "z": 0.5 },
							{ "x": 40.11, "y": -37.65, "z": 0.5 },
							{ "x": 39.45, "y": -41.67, "z": 0.5 },
							{ "x": 36.85, "y": -44.45, "z": 0.5 },
							{ "x": 33.68, "y": -46.36, "z": 0.5 },
							{ "x": 30.91, "y": -46.85, "z": 0.5 },
							{ "x": 27.84, "y": -46.77, "z": 0.5 },
							{ "x": 24.96, "y": -45.3, "z": 0.5 },
							{ "x": 22.43, "y": -42.1, "z": 0.5 },
							{ "x": 20.4, "y": -36.5, "z": 0.5 },
							{ "x": 19.37, "y": -26.9, "z": 0.5 },
							{ "x": 19.17, "y": -14.09, "z": 0.5 },
							{ "x": 21.12, "y": 1.65, "z": 0.5 },
							{ "x": 25.48, "y": 20.19, "z": 0.5 },
							{ "x": 29.24, "y": 36.72, "z": 0.5 },
							{ "x": 31.85, "y": 53.01, "z": 0.5 },
							{ "x": 33.37, "y": 70.4, "z": 0.5 },
							{ "x": 33.2, "y": 84.67, "z": 0.5 },
							{ "x": 30.57, "y": 95.01, "z": 0.5 },
							{ "x": 24.99, "y": 101.14, "z": 0.5 },
							{ "x": 17.55, "y": 103.88, "z": 0.5 },
							{ "x": 9.92, "y": 104.49, "z": 0.5 },
							{ "x": 3.66, "y": 104.01, "z": 0.5 },
							{ "x": -0.64, "y": 102.5, "z": 0.5 },
							{ "x": -2.92, "y": 100.27, "z": 0.5 },
							{ "x": -3.6, "y": 96.97, "z": 0.5 },
							{ "x": -0.45, "y": 91.45, "z": 0.5 },
							{ "x": 9.15, "y": 83.2, "z": 0.5 },
							{ "x": 24.06, "y": 72.39, "z": 0.5 },
							{ "x": 40.16, "y": 59.82, "z": 0.5 },
							{ "x": 54.06, "y": 45.99, "z": 0.5 },
							{ "x": 63.61, "y": 33.29, "z": 0.5 },
							{ "x": 69.31, "y": 20.87, "z": 0.5 },
							{ "x": 72.36, "y": 8.36, "z": 0.5 },
							{ "x": 73.05, "y": -0.07, "z": 0.5 },
							{ "x": 72.5, "y": -5.4, "z": 0.5 },
							{ "x": 71, "y": -9.15, "z": 0.5 },
							{ "x": 69.23, "y": -11.13, "z": 0.5 },
							{ "x": 67.7, "y": -12.08, "z": 0.5 },
							{ "x": 66.64, "y": -12.35, "z": 0.5 },
							{ "x": 66.07, "y": -12.29, "z": 0.5 },
							{ "x": 65.59, "y": -10.98, "z": 0.5 },
							{ "x": 64.91, "y": -5.01, "z": 0.5 },
							{ "x": 63.56, "y": 6.47, "z": 0.5 },
							{ "x": 61.24, "y": 21.76, "z": 0.5 },
							{ "x": 59.27, "y": 36.74, "z": 0.5 },
							{ "x": 58.63, "y": 50.8, "z": 0.5 },
							{ "x": 58.56, "y": 64.21, "z": 0.5 },
							{ "x": 59.69, "y": 72.89, "z": 0.5 },
							{ "x": 62.94, "y": 78.64, "z": 0.5 },
							{ "x": 66.62, "y": 82.15, "z": 0.5 },
							{ "x": 70.67, "y": 82.79, "z": 0.5 },
							{ "x": 75.98, "y": 81.09, "z": 0.5 },
							{ "x": 81.97, "y": 75.87, "z": 0.5 },
							{ "x": 87.87, "y": 68.39, "z": 0.5 },
							{ "x": 92.7, "y": 59.73, "z": 0.5 },
							{ "x": 95.82, "y": 50.99, "z": 0.5 },
							{ "x": 96.92, "y": 44.55, "z": 0.5 },
							{ "x": 97.02, "y": 39.91, "z": 0.5 },
							{ "x": 96.56, "y": 36.38, "z": 0.5 },
							{ "x": 95.41, "y": 34.37, "z": 0.5 },
							{ "x": 94.09, "y": 33.59, "z": 0.5 },
							{ "x": 92.51, "y": 33.65, "z": 0.5 },
							{ "x": 90.9, "y": 36.01, "z": 0.5 },
							{ "x": 89.8, "y": 42.11, "z": 0.5 },
							{ "x": 89.36, "y": 50.78, "z": 0.5 },
							{ "x": 90.17, "y": 60.6, "z": 0.5 },
							{ "x": 92.22, "y": 67.78, "z": 0.5 },
							{ "x": 95.07, "y": 71.7, "z": 0.5 },
							{ "x": 98.44, "y": 73.97, "z": 0.5 },
							{ "x": 101.62, "y": 74.13, "z": 0.5 },
							{ "x": 105.05, "y": 70.76, "z": 0.5 },
							{ "x": 108.93, "y": 63.31, "z": 0.5 },
							{ "x": 112.09, "y": 54.51, "z": 0.5 },
							{ "x": 113.75, "y": 47.54, "z": 0.5 },
							{ "x": 114.33, "y": 42.98, "z": 0.5 },
							{ "x": 114.57, "y": 40.11, "z": 0.5 },
							{ "x": 114.53, "y": 39.06, "z": 0.5 },
							{ "x": 114.21, "y": 39.22, "z": 0.5 },
							{ "x": 113.61, "y": 41.78, "z": 0.5 },
							{ "x": 113.24, "y": 47.65, "z": 0.5 },
							{ "x": 113.2, "y": 54.77, "z": 0.5 },
							{ "x": 113.59, "y": 59.94, "z": 0.5 },
							{ "x": 115.15, "y": 63.14, "z": 0.5 },
							{ "x": 117.5, "y": 65.35, "z": 0.5 },
							{ "x": 119.82, "y": 65.98, "z": 0.5 },
							{ "x": 122.17, "y": 64.83, "z": 0.5 },
							{ "x": 124.45, "y": 60.83, "z": 0.5 },
							{ "x": 126.38, "y": 54.53, "z": 0.5 },
							{ "x": 127.57, "y": 48.58, "z": 0.5 },
							{ "x": 128.02, "y": 43.71, "z": 0.5 },
							{ "x": 128.14, "y": 40, "z": 0.5 },
							{ "x": 128.14, "y": 37.99, "z": 0.5 },
							{ "x": 128.05, "y": 37.08, "z": 0.5 },
							{ "x": 127.96, "y": 36.89, "z": 0.5 },
							{ "x": 128.34, "y": 37.5, "z": 0.5 },
							{ "x": 131.02, "y": 39.91, "z": 0.5 },
							{ "x": 137.11, "y": 44.76, "z": 0.5 },
							{ "x": 145.28, "y": 51.58, "z": 0.5 },
							{ "x": 153.49, "y": 59.87, "z": 0.5 },
							{ "x": 159.26, "y": 69.47, "z": 0.5 },
							{ "x": 161.58, "y": 81.66, "z": 0.5 },
							{ "x": 158.71, "y": 94.96, "z": 0.5 },
							{ "x": 147.18, "y": 107.43, "z": 0.5 },
							{ "x": 132.52, "y": 116.36, "z": 0.5 },
							{ "x": 119.46, "y": 120.3, "z": 0.5 },
							{ "x": 109.14, "y": 121.49, "z": 0.5 },
							{ "x": 102.95, "y": 119.79, "z": 0.5 },
							{ "x": 100.5, "y": 114.09, "z": 0.5 },
							{ "x": 105.6, "y": 103.93, "z": 0.5 },
							{ "x": 120.72, "y": 89.8, "z": 0.5 },
							{ "x": 143.19, "y": 72.46, "z": 0.5 },
							{ "x": 167.67, "y": 53.41, "z": 0.5 },
							{ "x": 185.27, "y": 37.82, "z": 0.5 },
							{ "x": 193.79, "y": 26.69, "z": 0.5 },
							{ "x": 197.17, "y": 17.76, "z": 0.5 },
							{ "x": 194.75, "y": 11.87, "z": 0.5 },
							{ "x": 185.34, "y": 9.07, "z": 0.5 },
							{ "x": 172.73, "y": 8.91, "z": 0.5 },
							{ "x": 162.58, "y": 10.74, "z": 0.5 },
							{ "x": 155.42, "y": 13.45, "z": 0.5 },
							{ "x": 151.3, "y": 15.61, "z": 0.5 },
							{ "x": 150.03, "y": 17.66, "z": 0.5 }
						]
					}
				],
				"color": "black",
				"fill": "none",
				"dash": "draw",
				"size": "l",
				"isComplete": true,
				"isClosed": false,
				"isPen": false
			},
			"parentId": "page:3qj9EtNgqSCW_6knX2K9_",
			"index": "a1",
			"id": "shape:EHeAIsYe4xu1-kGxK-Tl_",
			"typeName": "shape"
		},
		"shape:v0c3Ac-kUqB5C8cLsyT_E": {
			"x": 325.71484375,
			"y": 165.9453125,
			"rotation": 0,
			"isLocked": false,
			"opacity": 1,
			"meta": {},
			"type": "text",
			"props": {
				"color": "black",
				"size": "m",
				"w": 139.38919029117903,
				"text": "hey hey hey",
				"font": "draw",
				"align": "middle",
				"autoSize": false,
				"scale": 1.178662627660688
			},
			"parentId": "page:3qj9EtNgqSCW_6knX2K9_",
			"index": "a2",
			"id": "shape:v0c3Ac-kUqB5C8cLsyT_E",
			"typeName": "shape"
		},
		"page:2E1xHBVQtZUB5fzXfSUPl": {
			"meta": {},
			"id": "page:2E1xHBVQtZUB5fzXfSUPl",
			"name": "Page 2",
			"index": "a2",
			"typeName": "page"
		},
		"shape:qZ9C8PqSv6tSWya7LpL1t": {
			"x": 144.09765625,
			"y": 139.14829380718655,
			"rotation": 0,
			"isLocked": false,
			"opacity": 1,
			"meta": {},
			"type": "text",
			"props": {
				"color": "black",
				"size": "m",
				"w": 74.73082091700364,
				"text": "Page",
				"font": "draw",
				"align": "middle",
				"autoSize": false,
				"scale": 1.6823620652062432
			},
			"parentId": "page:2E1xHBVQtZUB5fzXfSUPl",
			"index": "a1",
			"id": "shape:qZ9C8PqSv6tSWya7LpL1t",
			"typeName": "shape"
		},
		"shape:935Jl5xP5gxCs4JGaE81D": {
			"x": 293.97412290107434,
			"y": 137.07222276594962,
			"rotation": 0,
			"isLocked": false,
			"opacity": 1,
			"meta": {},
			"type": "draw",
			"props": {
				"segments": [
					{
						"type": "free",
						"points": [
							{ "x": 0, "y": 0, "z": 0.5 },
							{ "x": -0.07, "y": 0, "z": 0.5 },
							{ "x": -0.15, "y": -0.07, "z": 0.5 },
							{ "x": -0.15, "y": -0.13, "z": 0.5 },
							{ "x": -0.15, "y": -0.3, "z": 0.5 },
							{ "x": -0.15, "y": -0.57, "z": 0.5 },
							{ "x": -0.15, "y": -1.21, "z": 0.5 },
							{ "x": -0.15, "y": -2.07, "z": 0.5 },
							{ "x": -0.15, "y": -2.93, "z": 0.5 },
							{ "x": -0.15, "y": -3.79, "z": 0.5 },
							{ "x": 0.72, "y": -5.84, "z": 0.5 },
							{ "x": 2.02, "y": -8.45, "z": 0.5 },
							{ "x": 3.62, "y": -10.87, "z": 0.5 },
							{ "x": 5.3, "y": -13.09, "z": 0.5 },
							{ "x": 9.45, "y": -17.77, "z": 0.5 },
							{ "x": 10.99, "y": -19.35, "z": 0.5 },
							{ "x": 12.21, "y": -20.59, "z": 0.5 },
							{ "x": 17.21, "y": -25.22, "z": 0.5 },
							{ "x": 20.05, "y": -27.37, "z": 0.5 },
							{ "x": 22.88, "y": -29.39, "z": 0.5 },
							{ "x": 25.87, "y": -31.19, "z": 0.5 },
							{ "x": 28.6, "y": -32.74, "z": 0.5 },
							{ "x": 29.98, "y": -33.01, "z": 0.5 },
							{ "x": 31.22, "y": -33.16, "z": 0.5 },
							{ "x": 36.02, "y": -33.8, "z": 0.5 },
							{ "x": 38.11, "y": -33.82, "z": 0.5 },
							{ "x": 41.03, "y": -33.82, "z": 0.5 },
							{ "x": 44.67, "y": -33.82, "z": 0.5 },
							{ "x": 47.41, "y": -33.82, "z": 0.5 },
							{ "x": 49.29, "y": -33.56, "z": 0.5 },
							{ "x": 50.76, "y": -33.13, "z": 0.5 },
							{ "x": 51.93, "y": -32.45, "z": 0.5 },
							{ "x": 52.89, "y": -31.61, "z": 0.5 },
							{ "x": 53.67, "y": -30.82, "z": 0.5 },
							{ "x": 54.27, "y": -30.1, "z": 0.5 },
							{ "x": 54.93, "y": -29.21, "z": 0.5 },
							{ "x": 55.59, "y": -28.3, "z": 0.5 },
							{ "x": 55.97, "y": -27.29, "z": 0.5 },
							{ "x": 56.22, "y": -26.26, "z": 0.5 },
							{ "x": 56.39, "y": -25.3, "z": 0.5 },
							{ "x": 56.51, "y": -24.46, "z": 0.5 },
							{ "x": 56.54, "y": -23.28, "z": 0.5 },
							{ "x": 56.54, "y": -22.04, "z": 0.5 },
							{ "x": 56.66, "y": -20.78, "z": 0.5 },
							{ "x": 56.8, "y": -19.55, "z": 0.5 },
							{ "x": 56.83, "y": -17.43, "z": 0.5 },
							{ "x": 56.83, "y": -15.23, "z": 0.5 },
							{ "x": 56.83, "y": -13.16, "z": 0.5 },
							{ "x": 56.83, "y": -11.22, "z": 0.5 },
							{ "x": 56.38, "y": -9.22, "z": 0.5 },
							{ "x": 55.89, "y": -7.28, "z": 0.5 },
							{ "x": 54.78, "y": -4.61, "z": 0.5 },
							{ "x": 52.96, "y": -0.39, "z": 0.5 },
							{ "x": 51.48, "y": 2.96, "z": 0.5 },
							{ "x": 47.31, "y": 10.43, "z": 0.5 },
							{ "x": 40.34, "y": 21.06, "z": 0.5 },
							{ "x": 34.42, "y": 28.68, "z": 0.5 },
							{ "x": 30.28, "y": 33.6, "z": 0.5 },
							{ "x": 27.27, "y": 37.05, "z": 0.5 },
							{ "x": 25.13, "y": 39.37, "z": 0.5 },
							{ "x": 21.82, "y": 42.92, "z": 0.5 },
							{ "x": 17.82, "y": 47.17, "z": 0.5 },
							{ "x": 15.34, "y": 49.73, "z": 0.5 },
							{ "x": 13.9, "y": 51.19, "z": 0.5 },
							{ "x": 11.34, "y": 53.73, "z": 0.5 },
							{ "x": 8.28, "y": 56.8, "z": 0.5 },
							{ "x": 5.59, "y": 59.34, "z": 0.5 },
							{ "x": 3.26, "y": 61.47, "z": 0.5 },
							{ "x": 2.07, "y": 62.53, "z": 0.5 },
							{ "x": 1.33, "y": 63.14, "z": 0.5 },
							{ "x": 0, "y": 64.42, "z": 0.5 },
							{ "x": -1.45, "y": 65.88, "z": 0.5 },
							{ "x": -2.44, "y": 66.86, "z": 0.5 },
							{ "x": -3.21, "y": 67.63, "z": 0.5 },
							{ "x": -3.85, "y": 68.27, "z": 0.5 },
							{ "x": -4.46, "y": 68.88, "z": 0.5 },
							{ "x": -4.73, "y": 69.23, "z": 0.5 },
							{ "x": -4.91, "y": 69.5, "z": 0.5 },
							{ "x": -5.01, "y": 69.67, "z": 0.5 },
							{ "x": -5.1, "y": 69.83, "z": 0.5 },
							{ "x": -5.1, "y": 69.92, "z": 0.5 },
							{ "x": -5.1, "y": 69.99, "z": 0.5 },
							{ "x": -5.03, "y": 70, "z": 0.5 },
							{ "x": -4.44, "y": 69.89, "z": 0.5 },
							{ "x": -3.48, "y": 69.5, "z": 0.5 },
							{ "x": -2.76, "y": 69.01, "z": 0.5 },
							{ "x": -1.38, "y": 68.32, "z": 0.5 },
							{ "x": 0.4, "y": 67.51, "z": 0.5 },
							{ "x": 3.06, "y": 66.45, "z": 0.5 },
							{ "x": 6.29, "y": 65.24, "z": 0.5 },
							{ "x": 9.81, "y": 64.23, "z": 0.5 },
							{ "x": 13.24, "y": 63.43, "z": 0.5 },
							{ "x": 17.8, "y": 62.5, "z": 0.5 },
							{ "x": 22.71, "y": 61.56, "z": 0.5 },
							{ "x": 28.7, "y": 60.72, "z": 0.5 },
							{ "x": 34.89, "y": 59.94, "z": 0.5 },
							{ "x": 42.4, "y": 59.29, "z": 0.5 },
							{ "x": 50.03, "y": 58.71, "z": 0.5 },
							{ "x": 57.97, "y": 58.58, "z": 0.5 },
							{ "x": 65.61, "y": 58.58, "z": 0.5 },
							{ "x": 73.79, "y": 58.58, "z": 0.5 },
							{ "x": 81.93, "y": 58.58, "z": 0.5 },
							{ "x": 89.91, "y": 58.58, "z": 0.5 },
							{ "x": 97.54, "y": 58.58, "z": 0.5 },
							{ "x": 101.72, "y": 58.58, "z": 0.5 },
							{ "x": 104.83, "y": 58.58, "z": 0.5 },
							{ "x": 110.48, "y": 58.58, "z": 0.5 },
							{ "x": 117.33, "y": 58.75, "z": 0.5 },
							{ "x": 119.83, "y": 59.08, "z": 0.5 },
							{ "x": 124.73, "y": 59.89, "z": 0.5 },
							{ "x": 129.54, "y": 60.77, "z": 0.5 },
							{ "x": 131.86, "y": 61.42, "z": 0.5 },
							{ "x": 134.07, "y": 62.11, "z": 0.5 },
							{ "x": 135.85, "y": 62.57, "z": 0.5 },
							{ "x": 137.3, "y": 62.85, "z": 0.5 },
							{ "x": 138.44, "y": 63.19, "z": 0.5 },
							{ "x": 139.28, "y": 63.56, "z": 0.5 },
							{ "x": 139.96, "y": 63.9, "z": 0.5 },
							{ "x": 140.48, "y": 64.22, "z": 0.5 },
							{ "x": 140.93, "y": 64.47, "z": 0.5 },
							{ "x": 141.32, "y": 64.65, "z": 0.5 },
							{ "x": 141.57, "y": 64.84, "z": 0.5 },
							{ "x": 141.72, "y": 65.01, "z": 0.5 },
							{ "x": 141.84, "y": 65.17, "z": 0.5 },
							{ "x": 141.92, "y": 65.33, "z": 0.5 },
							{ "x": 141.94, "y": 65.43, "z": 0.5 },
							{ "x": 141.94, "y": 65.51, "z": 0.5 },
							{ "x": 141.94, "y": 65.58, "z": 0.5 },
							{ "x": 141.94, "y": 65.65, "z": 0.5 },
							{ "x": 141.94, "y": 65.73, "z": 0.5 },
							{ "x": 141.94, "y": 65.8, "z": 0.5 },
							{ "x": 141.94, "y": 65.88, "z": 0.5 },
							{ "x": 141.94, "y": 65.95, "z": 0.5 },
							{ "x": 141.94, "y": 66.03, "z": 0.5 },
							{ "x": 141.94, "y": 66.1, "z": 0.5 },
							{ "x": 141.94, "y": 66.18, "z": 0.5 },
							{ "x": 141.86, "y": 66.29, "z": 0.5 },
							{ "x": 141.69, "y": 66.37, "z": 0.5 },
							{ "x": 141.45, "y": 66.42, "z": 0.5 },
							{ "x": 141.12, "y": 66.5, "z": 0.5 }
						]
					}
				],
				"color": "black",
				"fill": "none",
				"dash": "draw",
				"size": "xl",
				"isComplete": true,
				"isClosed": false,
				"isPen": false
			},
			"parentId": "page:2E1xHBVQtZUB5fzXfSUPl",
			"index": "a2",
			"id": "shape:935Jl5xP5gxCs4JGaE81D",
			"typeName": "shape"
		}
	},
	"schema": {
		"schemaVersion": 1,
		"storeVersion": 4,
		"recordVersions": {
			"asset": {
				"version": 1,
				"subTypeKey": "type",
				"subTypeVersions": { "image": 3, "video": 3, "bookmark": 1 }
			},
			"camera": { "version": 1 },
			"document": { "version": 2 },
			"instance": { "version": 24 },
			"instance_page_state": { "version": 5 },
			"page": { "version": 1 },
			"shape": {
				"version": 3,
				"subTypeKey": "type",
				"subTypeVersions": {
					"group": 0,
					"text": 1,
					"bookmark": 2,
					"draw": 1,
					"geo": 8,
					"note": 5,
					"line": 1,
					"frame": 0,
					"arrow": 3,
					"highlight": 0,
					"embed": 4,
					"image": 3,
					"video": 2
				}
			},
			"instance_presence": { "version": 5 },
			"pointer": { "version": 1 }
		}
	}
}
```

## Toasts and dialogs

Keywords: ui, components, dialogs, toasts

To control toasts and dialogs your app, you can use the `useToasts` and `useDialogs` hooks.
These hooks give you access to functions which allow you to add, remove and clear toasts
and dialogs.

Dialogs are especially customisable, allowing you to pass in a custom component to render
as the dialog content. Alternatively, you can use the `ExampleDialog` component which is
provided by the library.

### App.tsx

```tsx
import {
	TLComponents,
	Tldraw,
	TldrawUiButton,
	TldrawUiButtonLabel,
	TldrawUiDialogBody,
	TldrawUiDialogCloseButton,
	TldrawUiDialogFooter,
	TldrawUiDialogHeader,
	TldrawUiDialogTitle,
	useDialogs,
	useToasts,
} from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file

// [1]
function MyDialog({ onClose }: { onClose(): void }) {
	return (
		<>
			<TldrawUiDialogHeader>
				<TldrawUiDialogTitle>Title</TldrawUiDialogTitle>
				<TldrawUiDialogCloseButton />
			</TldrawUiDialogHeader>
			<TldrawUiDialogBody style={{ maxWidth: 350 }}>Description...</TldrawUiDialogBody>
			<TldrawUiDialogFooter className="tlui-dialog__footer__actions">
				<TldrawUiButton type="normal" onClick={onClose}>
					<TldrawUiButtonLabel>Cancel</TldrawUiButtonLabel>
				</TldrawUiButton>
				<TldrawUiButton type="primary" onClick={onClose}>
					<TldrawUiButtonLabel>Continue</TldrawUiButtonLabel>
				</TldrawUiButton>
			</TldrawUiDialogFooter>
		</>
	)
}

// [2]
function MySimpleDialog({ onClose }: { onClose(): void }) {
	return (
		<div style={{ padding: 16 }}>
			<h2>Title</h2>
			<p>Description...</p>
			<button onClick={onClose}>Okay</button>
		</div>
	)
}

const CustomSharePanel = () => {
	const { addToast } = useToasts()
	const { addDialog } = useDialogs()

	return (
		<div style={{ padding: 16, gap: 16, display: 'flex', pointerEvents: 'all' }}>
			<button
				onClick={() => {
					addToast({ title: 'Hello world!', severity: 'success' })
				}}
			>
				Show toast
			</button>
			<button
				onClick={() => {
					addDialog({
						component: MyDialog,
						onClose() {
							// You can do something after the dialog is closed
							void null
						},
					})
				}}
			>
				Show dialog
			</button>
			<button
				onClick={() => {
					addDialog({
						component: MySimpleDialog,
						onClose() {
							// You can do something after the dialog is closed
							void null
						},
					})
				}}
			>
				Show simple dialog
			</button>
		</div>
	)
}

const components: TLComponents = {
	SharePanel: CustomSharePanel,
}

export default function ToastsDialogsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw components={components} persistenceKey="example" />
		</div>
	)
}

/* 

To control toasts and dialogs your app, you can use the `useToasts` and `useDialogs` hooks. 
These hooks give you access to functions which allow you to add, remove and clear toasts 
and dialogs.

Dialogs are especially customisable, allowing you to pass in a custom component to render
as the dialog content. Alternatively, you can use the `ExampleDialog` component which is
provided by the library.

[1]
The tldraw library provides a set of components that you can use to build your dialogs. 
The `onClose` function passed to the dialog component runs when the dialog closes or 
is dismissed, but you can also call it from buttons to close the dialog.

[2]
...or you can build your own dialog component!
*/
```

## Custom Grid Example

Keywords: grid, background, ui, layout

This example shows how to draw a custom grid on the canvas. It uses a 2d canvas context to draw major and minor grid lines.

### App.tsx

```tsx
import { useLayoutEffect, useRef } from 'react'
import { TLComponents, Tldraw, approximately, useEditor, useIsDarkMode, useValue } from 'tldraw'
import 'tldraw/tldraw.css'

/**
 * There's a guide at the bottom of this file!
 */

const components: TLComponents = {
	// [1]
	Grid: ({ size, ...camera }) => {
		const editor = useEditor()

		// [2]
		const screenBounds = useValue('screenBounds', () => editor.getViewportScreenBounds(), [])
		const devicePixelRatio = useValue('dpr', () => editor.getInstanceState().devicePixelRatio, [])
		const isDarkMode = useIsDarkMode()

		const canvas = useRef<HTMLCanvasElement>(null)

		useLayoutEffect(() => {
			if (!canvas.current) return
			// [3]
			const canvasW = screenBounds.w * devicePixelRatio
			const canvasH = screenBounds.h * devicePixelRatio
			canvas.current.width = canvasW
			canvas.current.height = canvasH

			const ctx = canvas.current?.getContext('2d')
			if (!ctx) return

			// [4]
			ctx.clearRect(0, 0, canvasW, canvasH)

			// [5]
			const pageViewportBounds = editor.getViewportPageBounds()

			const startPageX = Math.ceil(pageViewportBounds.minX / size) * size
			const startPageY = Math.ceil(pageViewportBounds.minY / size) * size
			const endPageX = Math.floor(pageViewportBounds.maxX / size) * size
			const endPageY = Math.floor(pageViewportBounds.maxY / size) * size
			const numRows = Math.round((endPageY - startPageY) / size)
			const numCols = Math.round((endPageX - startPageX) / size)

			ctx.strokeStyle = isDarkMode ? '#555' : '#BBB'

			// [6]
			for (let row = 0; row <= numRows; row++) {
				const pageY = startPageY + row * size
				// convert the page-space Y offset into our canvas' coordinate space
				const canvasY = (pageY + camera.y) * camera.z * devicePixelRatio
				const isMajorLine = approximately(pageY % (size * 10), 0)
				drawLine(ctx, 0, canvasY, canvasW, canvasY, isMajorLine ? 3 : 1)
			}
			for (let col = 0; col <= numCols; col++) {
				const pageX = startPageX + col * size
				// convert the page-space X offset into our canvas' coordinate space
				const canvasX = (pageX + camera.x) * camera.z * devicePixelRatio
				const isMajorLine = approximately(pageX % (size * 10), 0)
				drawLine(ctx, canvasX, 0, canvasX, canvasH, isMajorLine ? 3 : 1)
			}
		}, [screenBounds, camera, size, devicePixelRatio, editor, isDarkMode])

		// [7]
		return <canvas className="tl-grid" ref={canvas} />
	},
}

export default function CustomGridExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="example"
				components={components}
				onMount={(e) => {
					e.updateInstanceState({ isGridMode: true })
				}}
			/>
		</div>
	)
}

function drawLine(
	ctx: CanvasRenderingContext2D,
	x1: number,
	y1: number,
	x2: number,
	y2: number,
	width: number
) {
	ctx.beginPath()
	ctx.moveTo(x1, y1)
	ctx.lineTo(x2, y2)
	ctx.lineWidth = width
	ctx.stroke()
}

/**
 * This example demonstrates how to draw a custom grid component using a 2d canvas.
 *
 * 1. To add a custom grid you must override this Grid component. It is passed props for the camera position, along with the size of the grid in page space.
 * 2. In addition to updating when the camera moves, we want the grid to rerender if the screen bounds change, or if the devicePixelRatio changes, or if the theme changes.
 * 3. To avoid pixelation we want to render at the device's actual resolution, so we need to set the canvas size in terms of the devicePixelRatio.
 * 4. Start by clearing the canvas and making it transparent.
 * 5. Calculate the start and end offsets for the grid, in page space.
 * 6. Draw the grid lines. We draw major lines every 10 grid units.
 * 7. The 'tl-grid' class is important for correct rendering and interaction handling.
 */
```

## Data grid shape

Keywords: data grid ag grid

A custom shape that renders AG grid.



### App.tsx

```tsx
/* eslint-disable react-hooks/rules-of-hooks */
import { AgGridReact } from 'ag-grid-react'
import { BaseBoxShapeUtil, TLBaseShape, Tldraw, createShapeId, useDelaySvgExport } from 'tldraw'

import 'ag-grid-community/styles/ag-grid.css'
import 'ag-grid-community/styles/ag-theme-quartz.css'
import 'tldraw/tldraw.css'

type AgGridShape = TLBaseShape<
	'ag-grid',
	{ w: number; h: number; rowData: any[]; columnDefs: any[] }
>
class AgGridShapeUtil extends BaseBoxShapeUtil<AgGridShape> {
	static override type = 'ag-grid'

	override canScroll(): boolean {
		return true
	}

	override canEdit(): boolean {
		return true
	}

	override getDefaultProps() {
		return {
			w: 300,
			h: 200,
			rowData: [],
			columnDefs: [],
		}
	}
	override component(shape: AgGridShape) {
		const isEditing = this.editor.getEditingShapeId() === shape.id
		const isReady = useDelaySvgExport()

		return (
			<div
				style={{
					width: shape.props.w,
					height: shape.props.h,
					pointerEvents: isEditing ? 'all' : undefined,
				}}
				className="ag-theme-quartz"
			>
				<AgGridReact
					onGridReady={isReady}
					rowData={shape.props.rowData}
					columnDefs={shape.props.columnDefs}
					// autoSizeStrategy={{ type: 'f', width: shape.props.w }}
				/>
			</div>
		)
	}
	override indicator(shape: AgGridShape) {
		return <rect width={shape.props.w} height={shape.props.h} rx={8} ry={8} />
	}
}

export default function DataGridExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="ag-grid-example"
				shapeUtils={[AgGridShapeUtil]}
				onMount={(editor) => {
					const agGridShapeId = createShapeId('ag-grid')

					if (!editor.getShape(agGridShapeId)) {
						editor.createShape<AgGridShape>({
							id: agGridShapeId,
							type: 'ag-grid',
							props: {
								w: 400,
								h: 300,
								rowData: [
									{ make: 'Tesla', model: 'Model Y', price: 64950, electric: true },
									{ make: 'Ford', model: 'F-Series', price: 33850, electric: false },
									{ make: 'Toyota', model: 'Corolla', price: 29600, electric: false },
								],
								columnDefs: [
									{ field: 'make', filter: true, floatingFilter: true, flex: 1 },
									{ field: 'model', flex: 1 },
									{ field: 'price', filter: true, floatingFilter: true, flex: 1 },
									{ field: 'electric', flex: 1 },
								],
							},
						})
						editor.select(agGridShapeId)
						editor.zoomToSelection()
					}
				}}
			/>
		</div>
	)
}
```

## Layout constraints (bindings)

Keywords: constraints, group, shape, custom, bindings, drag, drop, position

How to constrain shapes to a layout using bindings.

You can use bindings to make shapes respond to changes to other shapes. This is useful for enforcing layout constraints

### App.tsx

```tsx
import {
	BindingOnChangeOptions,
	BindingOnCreateOptions,
	BindingOnDeleteOptions,
	BindingOnShapeChangeOptions,
	BindingUtil,
	HTMLContainer,
	IndexKey,
	RecordProps,
	Rectangle2d,
	ShapeUtil,
	T,
	TLBaseBinding,
	TLBaseShape,
	Tldraw,
	Vec,
	clamp,
	createBindingId,
	getIndexBetween,
} from 'tldraw'
import 'tldraw/tldraw.css'
import snapShot from './snapshot.json'

// The container shapes that can contain element shapes

const CONTAINER_PADDING = 24

type ContainerShape = TLBaseShape<'element', { height: number; width: number }>

class ContainerShapeUtil extends ShapeUtil<ContainerShape> {
	static override type = 'container' as const
	static override props: RecordProps<ContainerShape> = { height: T.number, width: T.number }

	override getDefaultProps() {
		return {
			width: 100 + CONTAINER_PADDING * 2,
			height: 100 + CONTAINER_PADDING * 2,
		}
	}

	override canBind({
		fromShapeType,
		toShapeType,
		bindingType,
	}: {
		fromShapeType: string
		toShapeType: string
		bindingType: string
	}) {
		return fromShapeType === 'container' && toShapeType === 'element' && bindingType === 'layout'
	}
	override canEdit() {
		return false
	}
	override canResize() {
		return false
	}
	override hideRotateHandle() {
		return true
	}
	override isAspectRatioLocked() {
		return true
	}

	override getGeometry(shape: ContainerShape) {
		return new Rectangle2d({
			width: shape.props.width,
			height: shape.props.height,
			isFilled: true,
		})
	}

	override component(shape: ContainerShape) {
		return (
			<HTMLContainer
				style={{
					backgroundColor: '#efefef',
					width: shape.props.width,
					height: shape.props.height,
				}}
			/>
		)
	}

	override indicator(shape: ContainerShape) {
		return <rect width={shape.props.width} height={shape.props.height} />
	}
}

// The element shapes that can be placed inside the container shapes

type ElementShape = TLBaseShape<'element', { color: string }>

class ElementShapeUtil extends ShapeUtil<ElementShape> {
	static override type = 'element' as const
	static override props: RecordProps<ElementShape> = {
		color: T.string,
	}

	override getDefaultProps() {
		return {
			color: '#AEC6CF',
		}
	}

	override canBind({
		fromShapeType,
		toShapeType,
		bindingType,
	}: {
		fromShapeType: string
		toShapeType: string
		bindingType: string
	}) {
		return fromShapeType === 'container' && toShapeType === 'element' && bindingType === 'layout'
	}
	override canEdit() {
		return false
	}
	override canResize() {
		return false
	}
	override hideRotateHandle() {
		return true
	}
	override isAspectRatioLocked() {
		return true
	}

	override getGeometry() {
		return new Rectangle2d({
			width: 100,
			height: 100,
			isFilled: true,
		})
	}

	override component(shape: ElementShape) {
		return <HTMLContainer style={{ backgroundColor: shape.props.color }}></HTMLContainer>
	}

	override indicator() {
		return <rect width={100} height={100} />
	}

	private getTargetContainer(shape: ElementShape, pageAnchor: Vec) {
		// Find the container shape that the element is being dropped on
		return this.editor.getShapeAtPoint(pageAnchor, {
			hitInside: true,
			filter: (otherShape) =>
				this.editor.canBindShapes({ fromShape: otherShape, toShape: shape, binding: 'layout' }),
		}) as ContainerShape | undefined
	}

	getBindingIndexForPosition(shape: ElementShape, container: ContainerShape, pageAnchor: Vec) {
		// All the layout bindings from the container
		const allBindings = this.editor
			.getBindingsFromShape<LayoutBinding>(container, 'layout')
			.sort((a, b) => (a.props.index > b.props.index ? 1 : -1))

		// Those bindings that don't involve the element
		const siblings = allBindings.filter((b) => b.toId !== shape.id)

		// Get the relative x position of the element center in the container
		// Where should the element be placed? min index at left, max index + 1
		const order = clamp(
			Math.round((pageAnchor.x - container.x - CONTAINER_PADDING) / (100 + CONTAINER_PADDING)),
			0,
			siblings.length + 1
		)

		// Get a fractional index between the two siblings
		const belowSib = allBindings[order - 1]
		const aboveSib = allBindings[order]
		let index: IndexKey

		if (belowSib?.toId === shape.id) {
			index = belowSib.props.index
		} else if (aboveSib?.toId === shape.id) {
			index = aboveSib.props.index
		} else {
			index = getIndexBetween(belowSib?.props.index, aboveSib?.props.index)
		}

		return index
	}

	override onTranslateStart(shape: ElementShape) {
		// Update all the layout bindings for this shape to be placeholders
		this.editor.updateBindings(
			this.editor.getBindingsToShape<LayoutBinding>(shape, 'layout').map((binding) => ({
				...binding,
				props: { ...binding.props, placeholder: true },
			}))
		)
	}

	override onTranslate(_: ElementShape, shape: ElementShape) {
		// Find the center of the element shape
		const pageAnchor = this.editor.getShapePageTransform(shape).applyToPoint({ x: 50, y: 50 })

		// Find the container shape that the element is being dropped on
		const targetContainer = this.getTargetContainer(shape, pageAnchor)

		if (!targetContainer) {
			// Delete all the bindings to the element
			const bindings = this.editor.getBindingsToShape<LayoutBinding>(shape, 'layout')
			this.editor.deleteBindings(bindings)
			return
		}

		// Get the index for the new binding
		const index = this.getBindingIndexForPosition(shape, targetContainer, pageAnchor)

		// Is there an existing binding already between the container and the shape?
		const existingBinding = this.editor
			.getBindingsFromShape<LayoutBinding>(targetContainer, 'layout')
			.find((b) => b.toId === shape.id)

		if (existingBinding) {
			// If a binding already exists, update it
			if (existingBinding.props.index === index) return
			this.editor.updateBinding<LayoutBinding>({
				...existingBinding,
				props: {
					...existingBinding.props,
					placeholder: true,
					index,
				},
			})
		} else {
			// ...otherwise, create a new one
			this.editor.createBinding<LayoutBinding>({
				id: createBindingId(),
				type: 'layout',
				fromId: targetContainer.id,
				toId: shape.id,
				props: {
					index,
					placeholder: true,
				},
			})
		}
	}

	override onTranslateEnd(_: ElementShape, shape: ElementShape) {
		// Find the center of the element shape
		const pageAnchor = this.editor.getShapePageTransform(shape).applyToPoint({ x: 50, y: 50 })

		// Find the container shape that the element is being dropped on
		const targetContainer = this.getTargetContainer(shape, pageAnchor)

		// No target container? no problem
		if (!targetContainer) return

		// get the index for the new binding
		const index = this.getBindingIndexForPosition(shape, targetContainer, pageAnchor)

		// delete all the previous bindings for this shape
		this.editor.deleteBindings(this.editor.getBindingsToShape<LayoutBinding>(shape, 'layout'))

		// ...and then create a new one
		this.editor.createBinding<LayoutBinding>({
			id: createBindingId(),
			type: 'layout',
			fromId: targetContainer.id,
			toId: shape.id,
			props: {
				index,
				placeholder: false,
			},
		})
	}
}

// The binding between the element shapes and the container shapes

type LayoutBinding = TLBaseBinding<
	'layout',
	{
		index: IndexKey
		placeholder: boolean
	}
>

class LayoutBindingUtil extends BindingUtil<LayoutBinding> {
	static override type = 'layout' as const

	override getDefaultProps() {
		return {
			index: 'a1' as IndexKey,
			placeholder: true,
		}
	}

	override onAfterCreate({ binding }: BindingOnCreateOptions<LayoutBinding>): void {
		this.updateElementsForContainer(binding)
	}

	override onAfterChange({ bindingAfter }: BindingOnChangeOptions<LayoutBinding>): void {
		this.updateElementsForContainer(bindingAfter)
	}

	override onAfterChangeFromShape({ binding }: BindingOnShapeChangeOptions<LayoutBinding>): void {
		this.updateElementsForContainer(binding)
	}

	override onAfterDelete({ binding }: BindingOnDeleteOptions<LayoutBinding>): void {
		this.updateElementsForContainer(binding)
	}

	private updateElementsForContainer({
		props: { placeholder },
		fromId: containerId,
		toId,
	}: LayoutBinding) {
		// Get all of the bindings from the layout container
		const container = this.editor.getShape<ContainerShape>(containerId)
		if (!container) return

		const bindings = this.editor
			.getBindingsFromShape<LayoutBinding>(container, 'layout')
			.sort((a, b) => (a.props.index > b.props.index ? 1 : -1))
		if (bindings.length === 0) return

		for (let i = 0; i < bindings.length; i++) {
			const binding = bindings[i]

			if (toId === binding.toId && placeholder) continue

			const offset = new Vec(CONTAINER_PADDING + i * (100 + CONTAINER_PADDING), CONTAINER_PADDING)

			const shape = this.editor.getShape<ElementShape>(binding.toId)
			if (!shape) continue

			const point = this.editor.getPointInParentSpace(
				shape,
				this.editor.getShapePageTransform(container)!.applyToPoint(offset)
			)

			if (shape.x !== point.x || shape.y !== point.y) {
				this.editor.updateShape({
					id: binding.toId,
					type: 'element',
					x: point.x,
					y: point.y,
				})
			}
		}

		const width =
			CONTAINER_PADDING +
			(bindings.length * 100 + (bindings.length - 1) * CONTAINER_PADDING) +
			CONTAINER_PADDING

		const height = CONTAINER_PADDING + 100 + CONTAINER_PADDING

		if (width !== container.props.width || height !== container.props.height) {
			this.editor.updateShape({
				id: container.id,
				type: 'container',
				props: { width, height },
			})
		}
	}
}

export default function LayoutExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// @ts-ignore
				snapshot={snapShot}
				onMount={(editor) => {
					;(window as any).editor = editor
				}}
				shapeUtils={[ContainerShapeUtil, ElementShapeUtil]}
				bindingUtils={[LayoutBindingUtil]}
			/>
		</div>
	)
}
```
### snapshot.json

```json
{
	"store": {
		"document:document": {
			"gridSize": 10,
			"name": "",
			"meta": {},
			"id": "document:document",
			"typeName": "document"
		},
		"page:page": {
			"meta": {},
			"id": "page:page",
			"name": "Page 1",
			"index": "a1",
			"typeName": "page"
		},
		"shape:f4LKGB_8M2qsyWGpHR5Dq": {
			"x": 30.9375,
			"y": 69.48828125,
			"rotation": 0,
			"isLocked": false,
			"opacity": 1,
			"meta": {},
			"id": "shape:f4LKGB_8M2qsyWGpHR5Dq",
			"type": "container",
			"parentId": "page:page",
			"index": "a1",
			"props": {
				"width": 644,
				"height": 148
			},
			"typeName": "shape"
		},
		"shape:2oThF4kJ4v31xqKN5lvq2": {
			"x": 550.9375,
			"y": 93.48828125,
			"rotation": 0,
			"isLocked": false,
			"opacity": 1,
			"meta": {},
			"id": "shape:2oThF4kJ4v31xqKN5lvq2",
			"type": "element",
			"props": {
				"color": "#5BCEFA"
			},
			"parentId": "page:page",
			"index": "a2",
			"typeName": "shape"
		},
		"shape:K2vk_VTaNh-ANaRNOAvgY": {
			"x": 426.9375,
			"y": 93.48828125,
			"rotation": 0,
			"isLocked": false,
			"opacity": 1,
			"meta": {},
			"id": "shape:K2vk_VTaNh-ANaRNOAvgY",
			"type": "element",
			"props": {
				"color": "#F5A9B8"
			},
			"parentId": "page:page",
			"index": "a3",
			"typeName": "shape"
		},
		"shape:6uouhIK7PvyIRNQHACf-d": {
			"x": 302.9375,
			"y": 93.48828125,
			"rotation": 0,
			"isLocked": false,
			"opacity": 1,
			"meta": {},
			"id": "shape:6uouhIK7PvyIRNQHACf-d",
			"type": "element",
			"props": {
				"color": "#FFFFFF"
			},
			"parentId": "page:page",
			"index": "a4",
			"typeName": "shape"
		},
		"shape:GTQq2qxkWPHEK7KMIRtsh": {
			"x": 54.9375,
			"y": 93.48828125,
			"rotation": 0,
			"isLocked": false,
			"opacity": 1,
			"meta": {},
			"id": "shape:GTQq2qxkWPHEK7KMIRtsh",
			"type": "element",
			"props": {
				"color": "#5BCEFA"
			},
			"parentId": "page:page",
			"index": "a5",
			"typeName": "shape"
		},
		"shape:05jMujN6A0sIp6zzHMpbV": {
			"x": 178.9375,
			"y": 93.48828125,
			"rotation": 0,
			"isLocked": false,
			"opacity": 1,
			"meta": {},
			"id": "shape:05jMujN6A0sIp6zzHMpbV",
			"type": "element",
			"props": {
				"color": "#F5A9B8"
			},
			"parentId": "page:page",
			"index": "a6",
			"typeName": "shape"
		},
		"binding:iOBENBUHvzD8N7mBdIM5l": {
			"meta": {},
			"id": "binding:iOBENBUHvzD8N7mBdIM5l",
			"type": "layout",
			"fromId": "shape:f4LKGB_8M2qsyWGpHR5Dq",
			"toId": "shape:05jMujN6A0sIp6zzHMpbV",
			"props": {
				"index": "a2",
				"placeholder": false
			},
			"typeName": "binding"
		},
		"binding:YTIeOALEmHJk6dczRpQmE": {
			"meta": {},
			"id": "binding:YTIeOALEmHJk6dczRpQmE",
			"type": "layout",
			"fromId": "shape:f4LKGB_8M2qsyWGpHR5Dq",
			"toId": "shape:GTQq2qxkWPHEK7KMIRtsh",
			"props": {
				"index": "a1",
				"placeholder": false
			},
			"typeName": "binding"
		},
		"binding:n4LY_pVuLfjV1qpOTZX-U": {
			"meta": {},
			"id": "binding:n4LY_pVuLfjV1qpOTZX-U",
			"type": "layout",
			"fromId": "shape:f4LKGB_8M2qsyWGpHR5Dq",
			"toId": "shape:6uouhIK7PvyIRNQHACf-d",
			"props": {
				"index": "a3",
				"placeholder": false
			},
			"typeName": "binding"
		},
		"binding:8XayRsWB_nxAH2833SYg1": {
			"meta": {},
			"id": "binding:8XayRsWB_nxAH2833SYg1",
			"type": "layout",
			"fromId": "shape:f4LKGB_8M2qsyWGpHR5Dq",
			"toId": "shape:2oThF4kJ4v31xqKN5lvq2",
			"props": {
				"index": "a5",
				"placeholder": false
			},
			"typeName": "binding"
		},
		"binding:MTYuIRiEVTn2DyVChthry": {
			"meta": {},
			"id": "binding:MTYuIRiEVTn2DyVChthry",
			"type": "layout",
			"fromId": "shape:f4LKGB_8M2qsyWGpHR5Dq",
			"toId": "shape:K2vk_VTaNh-ANaRNOAvgY",
			"props": {
				"index": "a4",
				"placeholder": false
			},
			"typeName": "binding"
		}
	},
	"schema": {
		"schemaVersion": 2,
		"sequences": {
			"com.tldraw.store": 4,
			"com.tldraw.asset": 1,
			"com.tldraw.camera": 1,
			"com.tldraw.document": 2,
			"com.tldraw.instance": 25,
			"com.tldraw.instance_page_state": 5,
			"com.tldraw.page": 1,
			"com.tldraw.instance_presence": 5,
			"com.tldraw.pointer": 1,
			"com.tldraw.shape": 4,
			"com.tldraw.asset.bookmark": 2,
			"com.tldraw.asset.image": 4,
			"com.tldraw.asset.video": 4,
			"com.tldraw.shape.group": 0,
			"com.tldraw.shape.text": 2,
			"com.tldraw.shape.bookmark": 2,
			"com.tldraw.shape.draw": 2,
			"com.tldraw.shape.geo": 9,
			"com.tldraw.shape.note": 7,
			"com.tldraw.shape.line": 5,
			"com.tldraw.shape.frame": 0,
			"com.tldraw.shape.arrow": 5,
			"com.tldraw.shape.highlight": 1,
			"com.tldraw.shape.embed": 4,
			"com.tldraw.shape.image": 3,
			"com.tldraw.shape.video": 2,
			"com.tldraw.shape.container": 0,
			"com.tldraw.shape.element": 0,
			"com.tldraw.binding.arrow": 0,
			"com.tldraw.binding.layout": 0
		}
	}
}
```

## Note resizing

Keywords: note, resize, sticky

Make the note shape resizable.

The editor's options include alternative resizing behavior for note shapes. Set `options.noteShapeResizeMode` to either `none` for the default behavior or `scale` to allow a user to scale the note.

### App.tsx

```tsx
import { NoteShapeUtil, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// Configure the note shape util to allow scaling to resize
const shapeUtils = [NoteShapeUtil.configure({ resizeMode: 'scale' })]

export default function ResizeNoteExample() {
	return (
		<>
			<div className="tldraw__editor">
				{/* pass the configured shape utils to the editor */}
				<Tldraw persistenceKey="resize-note" shapeUtils={shapeUtils}></Tldraw>
			</div>
		</>
	)
}
```

## Pin (bindings)

Keywords: 

A pin, using bindings to pin together networks of shapes.



### App.tsx

```tsx
import {
	BindingOnShapeChangeOptions,
	BindingOnShapeDeleteOptions,
	BindingUtil,
	Box,
	DefaultFillStyle,
	DefaultToolbar,
	DefaultToolbarContent,
	RecordProps,
	Rectangle2d,
	ShapeUtil,
	StateNode,
	TLBaseBinding,
	TLBaseShape,
	TLEditorComponents,
	TLPointerEventInfo,
	TLShapeId,
	TLShapeUtilCanBindOpts,
	TLUiComponents,
	TLUiOverrides,
	Tldraw,
	TldrawUiMenuItem,
	Vec,
	VecModel,
	createShapeId,
	invLerp,
	lerp,
	useIsToolSelected,
	useTools,
} from 'tldraw'
import 'tldraw/tldraw.css'

// eslint-disable-next-line @typescript-eslint/no-empty-object-type
type PinShape = TLBaseShape<'pin', {}>

const offsetX = -16
const offsetY = -26
class PinShapeUtil extends ShapeUtil<PinShape> {
	static override type = 'pin' as const
	static override props: RecordProps<PinShape> = {}

	override getDefaultProps() {
		return {}
	}

	override canBind({ toShapeType, bindingType }: TLShapeUtilCanBindOpts<PinShape>) {
		if (bindingType === 'pin') {
			// pins cannot bind to other pins!
			return toShapeType !== 'pin'
		}
		// Allow pins to participate in other bindings, e.g. arrows
		return true
	}
	override canEdit() {
		return false
	}
	override canResize() {
		return false
	}
	override hideRotateHandle() {
		return true
	}
	override isAspectRatioLocked() {
		return true
	}

	override getGeometry() {
		return new Rectangle2d({
			width: 32,
			height: 32,
			x: offsetX,
			y: offsetY,
			isFilled: true,
		})
	}

	override component() {
		return (
			<div
				style={{
					width: '100%',
					height: '100%',
					marginLeft: offsetX,
					marginTop: offsetY,
					fontSize: '26px',
					textAlign: 'center',
				}}
			>
				📍
			</div>
		)
	}

	override indicator() {
		return <rect width={32} height={32} x={offsetX} y={offsetY} />
	}

	override onTranslateStart(shape: PinShape) {
		const bindings = this.editor.getBindingsFromShape(shape, 'pin')
		this.editor.deleteBindings(bindings)
	}

	override onTranslateEnd(_initial: PinShape, pin: PinShape) {
		const pageAnchor = this.editor.getShapePageTransform(pin).applyToPoint({ x: 0, y: 0 })

		const targets = this.editor
			.getShapesAtPoint(pageAnchor, { hitInside: true })
			.filter(
				(shape) =>
					this.editor.canBindShapes({ fromShape: pin, toShape: shape, binding: 'pin' }) &&
					shape.parentId === pin.parentId &&
					shape.index < pin.index
			)

		for (const target of targets) {
			const targetBounds = Box.ZeroFix(this.editor.getShapeGeometry(target)!.bounds)
			const pointInTargetSpace = this.editor.getPointInShapeSpace(target, pageAnchor)

			const anchor = {
				x: invLerp(targetBounds.minX, targetBounds.maxX, pointInTargetSpace.x),
				y: invLerp(targetBounds.minY, targetBounds.maxY, pointInTargetSpace.y),
			}

			this.editor.createBinding({
				type: 'pin',
				fromId: pin.id,
				toId: target.id,
				props: {
					anchor,
				},
			})
		}
	}
}

type PinBinding = TLBaseBinding<
	'pin',
	{
		anchor: VecModel
	}
>
class PinBindingUtil extends BindingUtil<PinBinding> {
	static override type = 'pin' as const

	override getDefaultProps() {
		return {
			anchor: { x: 0.5, y: 0.5 },
		}
	}

	private changedToShapes = new Set<TLShapeId>()

	override onOperationComplete(): void {
		if (this.changedToShapes.size === 0) return

		const fixedShapes = this.changedToShapes
		const toCheck = [...this.changedToShapes]

		const initialPositions = new Map<TLShapeId, VecModel>()
		const targetDeltas = new Map<TLShapeId, Map<TLShapeId, VecModel>>()

		const addTargetDelta = (fromId: TLShapeId, toId: TLShapeId, delta: VecModel) => {
			if (!targetDeltas.has(fromId)) targetDeltas.set(fromId, new Map())
			targetDeltas.get(fromId)!.set(toId, delta)

			if (!targetDeltas.has(toId)) targetDeltas.set(toId, new Map())
			targetDeltas.get(toId)!.set(fromId, { x: -delta.x, y: -delta.y })
		}

		const allShapes = new Set<TLShapeId>()
		while (toCheck.length) {
			const shapeId = toCheck.pop()!

			const shape = this.editor.getShape(shapeId)
			if (!shape) continue

			if (allShapes.has(shapeId)) continue
			allShapes.add(shapeId)

			const bindings = this.editor.getBindingsToShape<PinBinding>(shape, 'pin')
			for (const binding of bindings) {
				if (allShapes.has(binding.fromId)) continue
				allShapes.add(binding.fromId)

				const pin = this.editor.getShape<PinShape>(binding.fromId)
				if (!pin) continue

				const pinPosition = this.editor.getShapePageTransform(pin).applyToPoint({ x: 0, y: 0 })
				initialPositions.set(pin.id, pinPosition)

				for (const binding of this.editor.getBindingsFromShape<PinBinding>(pin.id, 'pin')) {
					const shapeBounds = this.editor.getShapeGeometry(binding.toId)!.bounds
					const shapeAnchor = {
						x: lerp(shapeBounds.minX, shapeBounds.maxX, binding.props.anchor.x),
						y: lerp(shapeBounds.minY, shapeBounds.maxY, binding.props.anchor.y),
					}
					const currentPageAnchor = this.editor
						.getShapePageTransform(binding.toId)
						.applyToPoint(shapeAnchor)

					const shapeOrigin = this.editor
						.getShapePageTransform(binding.toId)
						.applyToPoint({ x: 0, y: 0 })
					initialPositions.set(binding.toId, shapeOrigin)

					addTargetDelta(pin.id, binding.toId, {
						x: currentPageAnchor.x - shapeOrigin.x,
						y: currentPageAnchor.y - shapeOrigin.y,
					})

					if (!allShapes.has(binding.toId)) toCheck.push(binding.toId)
				}
			}
		}

		const currentPositions = new Map(initialPositions)

		const iterations = 30
		for (let i = 0; i < iterations; i++) {
			const movements = new Map<TLShapeId, VecModel[]>()
			for (const [aId, deltas] of targetDeltas) {
				if (fixedShapes.has(aId)) continue
				const aPosition = currentPositions.get(aId)!
				for (const [bId, targetDelta] of deltas) {
					const bPosition = currentPositions.get(bId)!

					const adjustmentDelta = {
						x: targetDelta.x - (aPosition.x - bPosition.x),
						y: targetDelta.y - (aPosition.y - bPosition.y),
					}

					if (!movements.has(aId)) movements.set(aId, [])
					movements.get(aId)!.push(adjustmentDelta)
				}
			}

			for (const [shapeId, deltas] of movements) {
				const currentPosition = currentPositions.get(shapeId)!
				currentPositions.set(shapeId, Vec.Average(deltas).add(currentPosition))
			}
		}

		const updates = []
		for (const [shapeId, position] of currentPositions) {
			const delta = Vec.Sub(position, initialPositions.get(shapeId)!)
			if (delta.len2() <= 0.01) continue

			const newPosition = this.editor.getPointInParentSpace(shapeId, position)
			updates.push({
				id: shapeId,
				type: this.editor.getShape(shapeId)!.type,
				x: newPosition.x,
				y: newPosition.y,
			})
		}

		if (updates.length === 0) {
			this.changedToShapes.clear()
		} else {
			this.editor.updateShapes(updates)
		}
	}

	// when the shape we're stuck to changes, update the pin's position
	override onAfterChangeToShape({ binding }: BindingOnShapeChangeOptions<PinBinding>): void {
		this.changedToShapes.add(binding.toId)
	}

	// when the thing we're stuck to is deleted, delete the pin too
	override onBeforeDeleteToShape({ binding }: BindingOnShapeDeleteOptions<PinBinding>): void {
		this.editor.deleteShape(binding.fromId)
	}
}

class PinTool extends StateNode {
	static override id = 'pin'

	override onEnter() {
		this.editor.setCursor({ type: 'cross', rotation: 0 })
	}

	override onPointerDown(info: TLPointerEventInfo) {
		const { currentPagePoint } = this.editor.inputs
		const pinId = createShapeId()
		this.editor.markHistoryStoppingPoint()
		this.editor.createShape({
			id: pinId,
			type: 'pin',
			x: currentPagePoint.x,
			y: currentPagePoint.y,
		})
		this.editor.setSelectedShapes([pinId])
		this.editor.setCurrentTool('select.translating', {
			...info,
			target: 'shape',
			shape: this.editor.getShape(pinId),
			isCreating: true,
			onInteractionEnd: 'pin',
			onCreate: () => {
				this.editor.setCurrentTool('pin')
			},
		})
	}
}

const overrides: TLUiOverrides = {
	tools(editor, schema) {
		schema['pin'] = {
			id: 'pin',
			label: 'Pin',
			icon: 'heart-icon',
			kbd: 'p',
			onSelect: () => {
				editor.setCurrentTool('pin')
			},
		}
		return schema
	},
}

const components: TLUiComponents & TLEditorComponents = {
	Toolbar: (...props) => {
		const pin = useTools().pin
		const isPinSelected = useIsToolSelected(pin)
		return (
			<DefaultToolbar {...props}>
				<TldrawUiMenuItem {...pin} isSelected={isPinSelected} />
				<DefaultToolbarContent />
			</DefaultToolbar>
		)
	},
}

export default function PinExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="pin-example"
				onMount={(editor) => {
					;(window as any).editor = editor
					editor.setStyleForNextShapes(DefaultFillStyle, 'semi')
				}}
				shapeUtils={[PinShapeUtil]}
				bindingUtils={[PinBindingUtil]}
				tools={[PinTool]}
				overrides={overrides}
				components={components}
			/>
		</div>
	)
}
```

## Popup shape

Keywords: dynamic shadows, css

...

...

### App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import { PopupShapeUtil } from './PopupShapeUtil'

const customShapeUtils = [PopupShapeUtil]

export default function PopupShapeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				shapeUtils={customShapeUtils}
				onMount={(editor) => {
					for (let i = 0; i < 9; i++) {
						editor.createShape({
							type: 'my-popup-shape',
							x: (i % 3) * 220,
							y: Math.floor(i / 3) * 220,
						})
					}
					editor.zoomToBounds(editor.getCurrentPageBounds()!, { animation: { duration: 0 } })
				}}
			/>
		</div>
	)
}
```
### PopupShapeUtil.tsx

```tsx
/* eslint-disable react-hooks/rules-of-hooks */
import { useEffect, useRef, useState } from 'react'
import {
	BaseBoxShapeUtil,
	HTMLContainer,
	RecordProps,
	T,
	TLBaseShape,
	stopEventPropagation,
} from 'tldraw'

type IMyPopupShape = TLBaseShape<
	'my-popup-shape',
	{
		w: number
		h: number
		animal: number
	}
>

export class PopupShapeUtil extends BaseBoxShapeUtil<IMyPopupShape> {
	static override type = 'my-popup-shape' as const
	static override props: RecordProps<IMyPopupShape> = {
		w: T.number,
		h: T.number,
		animal: T.number,
	}

	getDefaultProps(): IMyPopupShape['props'] {
		return {
			w: 200,
			h: 200,
			animal: 0,
		}
	}

	component(shape: IMyPopupShape) {
		const [popped, setPopped] = useState(false)

		const ref = useRef<HTMLDivElement>(null)
		const ref2 = useRef<HTMLDivElement>(null)

		useEffect(() => {
			const elm = ref.current
			if (!elm) return
			const elm2 = ref2.current
			if (!elm2) return
			if (popped) {
				// man
				// elm2.style.transform = `rotateX(0deg) translateY(0px) translateZ(0px)`
				// note
				elm.style.transform = `rotateX(0deg) translateY(0px) translateZ(0px)`
			} else {
				// man
				// elm.style.transform = `rotateX(-50deg) translateY(5px) translateZ(0px)`
				// elm2.style.transform = `scaleY(.8)`
				// note
				elm.style.transform = `rotateX(20deg)`
			}
		}, [popped])

		const vpb = this.editor.getViewportPageBounds()
		const spb = this.editor.getShapePageBounds(shape)!
		const px = vpb.midX - spb.midX + spb.w / 2
		const py = vpb.midY - spb.midY + spb.h / 2

		return (
			<HTMLContainer
				style={{
					pointerEvents: 'all',
					perspective: `${Math.max(vpb.w, vpb.h)}px`,
					perspectiveOrigin: `${px}px ${py}px`,
				}}
				onPointerDown={stopEventPropagation}
				onDoubleClick={(e) => {
					setPopped((p) => !p)
					stopEventPropagation(e)
				}}
			>
				<div
					ref={ref2}
					style={{
						position: 'absolute',
						top: 0,
						left: 0,
						width: '100%',
						height: '100%',
						transition: `all .5s`,
						backgroundSize: 'contain',
						backgroundRepeat: 'no-repeat',
						backgroundPosition: 'center',
						// man
						// transformOrigin: 'bottom center',
						// backgroundImage: `url(/shadow-man.png)`,
						// note
						backgroundColor: 'rgba(0,0,0,.5)',
					}}
				/>
				<div
					ref={ref}
					style={{
						position: 'absolute',
						top: 0,
						left: 0,
						width: '100%',
						height: '100%',
						transition: `all .5s`,
						display: 'flex',
						alignItems: 'center',
						justifyContent: 'center',
						padding: 16,
						overflow: 'hidden',
						fontFamily: 'tldraw_draw',
						color: '#333',
						fontSize: 24,
						backgroundSize: 'contain',
						backgroundRepeat: 'no-repeat',
						backgroundPosition: 'center',
						transformOrigin: 'top center',
						// man
						// backgroundImage: `url(/man.png)`,
						// transformOrigin: 'bottom center',
						// transform: `rotateX(20deg) translateY(5px) translateZ(40px)`,
						// note
						background: `gold`,
						border: '1px solid goldenrod',
					}}
				>
					{/* {shape.id.slice(-1).toUpperCase()} */}
				</div>
			</HTMLContainer>
		)
	}

	indicator(shape: IMyPopupShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}
```

## Selection UI

Keywords: duplication controls, handles

You can use the `InFrontOfTheCanvas` component to show extra user interface elements around the user's selection.

### App.tsx

```tsx
import {
	TLComponents,
	Tldraw,
	Vec,
	intersectLineSegmentPolygon,
	stopEventPropagation,
	useEditor,
	useValue,
} from 'tldraw'
import 'tldraw/tldraw.css'

const components: TLComponents = {
	InFrontOfTheCanvas: () => {
		const editor = useEditor()

		const info = useValue(
			'selection bounds',
			() => {
				const screenBounds = editor.getViewportScreenBounds()
				const rotation = editor.getSelectionRotation()
				const rotatedScreenBounds = editor.getSelectionRotatedScreenBounds()
				if (!rotatedScreenBounds) return
				return {
					// we really want the position within the
					// tldraw component's bounds, not the screen itself
					x: rotatedScreenBounds.x - screenBounds.x,
					y: rotatedScreenBounds.y - screenBounds.y,
					width: rotatedScreenBounds.width,
					height: rotatedScreenBounds.height,
					rotation: rotation,
				}
			},
			[editor]
		)

		if (!info) return

		return (
			<div
				style={{
					position: 'absolute',
					top: 0,
					left: 0,
					transformOrigin: 'top left',
					transform: `translate(${info.x}px, ${info.y}px) rotate(${info.rotation}rad)`,
					pointerEvents: 'all',
				}}
				onPointerDown={stopEventPropagation}
			>
				<DuplicateInDirectionButton y={-40} x={info.width / 2 - 16} rotation={-(Math.PI / 2)} />
				<DuplicateInDirectionButton y={info.height / 2 - 16} x={info.width + 8} rotation={0} />
				<DuplicateInDirectionButton
					y={info.height + 8}
					x={info.width / 2 - 16}
					rotation={Math.PI / 3}
				/>
				<DuplicateInDirectionButton y={info.height / 2 - 16} x={-40} rotation={Math.PI} />
			</div>
		)
	},
}

export default function BasicExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example" components={components} />
		</div>
	)
}

/**
 * This button will duplicate the editor's current selected shapes in
 * a certain direction. Its rotation determines the appearance of the
 * button (its actual css rotation) as well as the direction in which
 * the duplicated shapes are offset from the original shapes. It's
 * zeroed to the right.
 */
function DuplicateInDirectionButton({
	x,
	y,
	rotation,
}: {
	x: number
	y: number
	rotation: number
}) {
	const editor = useEditor()

	return (
		<button
			style={{
				position: 'absolute',
				width: 32,
				height: 32,
				pointerEvents: 'all',
				transform: `translate(${x}px, ${y}px) rotate(${rotation}rad)`,
			}}
			onPointerDown={stopEventPropagation}
			onClick={() => {
				const selectionRotation = editor.getSelectionRotation() ?? 0
				const rotatedPageBounds = editor.getSelectionRotatedPageBounds()!
				const selectionPageBounds = editor.getSelectionPageBounds()!
				if (!(rotatedPageBounds && selectionPageBounds)) return

				editor.markHistoryStoppingPoint()

				const PADDING = 32

				// Find an intersection with the page bounds
				const center = Vec.Rot(rotatedPageBounds.center, selectionRotation)
				const int = intersectLineSegmentPolygon(
					center,
					Vec.Add(center, new Vec(100000, 0).rot(selectionRotation + rotation)),
					rotatedPageBounds
						.clone()
						.expandBy(PADDING)
						.corners.map((c) => c.rot(selectionRotation))
				)
				if (!int?.[0]) return

				// Get the direction and distance to the intersection
				const delta = Vec.Sub(int[0], center)
				const dist = delta.len()
				const dir = delta.norm()

				// Get the offset for the duplicated shapes
				const offset = dir.mul(dist * 2)

				editor.duplicateShapes(editor.getSelectedShapes(), offset)
			}}
		>
			→
		</button>
	)
}
```

## Sticker (bindings)

Keywords: attach

A sticker shape, using bindings to attach shapes to one and other



### App.tsx

```tsx
import {
	BindingOnShapeChangeOptions,
	BindingOnShapeDeleteOptions,
	BindingUtil,
	Box,
	DefaultToolbar,
	DefaultToolbarContent,
	RecordProps,
	Rectangle2d,
	ShapeUtil,
	StateNode,
	TLBaseBinding,
	TLBaseShape,
	TLPointerEventInfo,
	TLUiComponents,
	TLUiOverrides,
	Tldraw,
	TldrawUiMenuItem,
	VecModel,
	createShapeId,
	invLerp,
	lerp,
	useIsToolSelected,
	useTools,
} from 'tldraw'
import 'tldraw/tldraw.css'

// eslint-disable-next-line @typescript-eslint/no-empty-object-type
type StickerShape = TLBaseShape<'sticker', {}>

const offsetX = -16
const offsetY = -26
class StickerShapeUtil extends ShapeUtil<StickerShape> {
	static override type = 'sticker' as const
	static override props: RecordProps<StickerShape> = {}

	override getDefaultProps() {
		return {}
	}

	override canBind() {
		// stickers can bind to anything
		return true
	}
	override canEdit() {
		return false
	}
	override canResize() {
		return false
	}
	override canSnap() {
		return false
	}
	override hideRotateHandle() {
		return true
	}
	override isAspectRatioLocked() {
		return true
	}

	override getGeometry() {
		return new Rectangle2d({
			width: 32,
			height: 32,
			x: offsetX,
			y: offsetY,
			isFilled: true,
		})
	}

	override component() {
		return (
			<div
				style={{
					width: '100%',
					height: '100%',
					marginLeft: offsetX,
					marginTop: offsetY,
					fontSize: '26px',
					textAlign: 'center',
				}}
			>
				❤️
			</div>
		)
	}

	override indicator() {
		return <rect width={32} height={32} x={offsetX} y={offsetY} />
	}

	override onTranslateStart(shape: StickerShape) {
		const bindings = this.editor.getBindingsFromShape(shape, 'sticker')
		this.editor.deleteBindings(bindings)
	}

	override onTranslateEnd(_initial: StickerShape, sticker: StickerShape) {
		const pageAnchor = this.editor.getShapePageTransform(sticker).applyToPoint({ x: 0, y: 0 })
		const target = this.editor.getShapeAtPoint(pageAnchor, {
			hitInside: true,
			filter: (shape) =>
				shape.id !== sticker.id &&
				this.editor.canBindShapes({ fromShape: sticker, toShape: shape, binding: 'sticker' }),
		})

		if (!target) return

		const targetBounds = Box.ZeroFix(this.editor.getShapeGeometry(target)!.bounds)
		const pointInTargetSpace = this.editor.getPointInShapeSpace(target, pageAnchor)

		const anchor = {
			x: invLerp(targetBounds.minX, targetBounds.maxX, pointInTargetSpace.x),
			y: invLerp(targetBounds.minY, targetBounds.maxY, pointInTargetSpace.y),
		}

		this.editor.createBinding({
			type: 'sticker',
			fromId: sticker.id,
			toId: target.id,
			props: {
				anchor,
			},
		})
	}
}

type StickerBinding = TLBaseBinding<
	'sticker',
	{
		anchor: VecModel
	}
>
class StickerBindingUtil extends BindingUtil<StickerBinding> {
	static override type = 'sticker' as const

	override getDefaultProps() {
		return {
			anchor: { x: 0.5, y: 0.5 },
		}
	}

	// when the shape we're stuck to changes, update the sticker's position
	override onAfterChangeToShape({
		binding,
		shapeAfter,
	}: BindingOnShapeChangeOptions<StickerBinding>): void {
		const sticker = this.editor.getShape<StickerShape>(binding.fromId)!

		const shapeBounds = this.editor.getShapeGeometry(shapeAfter)!.bounds
		const shapeAnchor = {
			x: lerp(shapeBounds.minX, shapeBounds.maxX, binding.props.anchor.x),
			y: lerp(shapeBounds.minY, shapeBounds.maxY, binding.props.anchor.y),
		}
		const pageAnchor = this.editor.getShapePageTransform(shapeAfter).applyToPoint(shapeAnchor)

		const stickerParentAnchor = this.editor
			.getShapeParentTransform(sticker)
			.invert()
			.applyToPoint(pageAnchor)

		this.editor.updateShape({
			id: sticker.id,
			type: 'sticker',
			x: stickerParentAnchor.x,
			y: stickerParentAnchor.y,
		})
	}

	// when the thing we're stuck to is deleted, delete the sticker too
	override onBeforeDeleteToShape({ binding }: BindingOnShapeDeleteOptions<StickerBinding>): void {
		this.editor.deleteShape(binding.fromId)
	}
}

class StickerTool extends StateNode {
	static override id = 'sticker'

	override onEnter() {
		this.editor.setCursor({ type: 'cross', rotation: 0 })
	}

	override onPointerDown(info: TLPointerEventInfo) {
		const { currentPagePoint } = this.editor.inputs
		const stickerId = createShapeId()
		this.editor.markHistoryStoppingPoint()
		this.editor.createShape({
			id: stickerId,
			type: 'sticker',
			x: currentPagePoint.x,
			y: currentPagePoint.y,
		})
		this.editor.setSelectedShapes([stickerId])
		this.editor.setCurrentTool('select.translating', {
			...info,
			target: 'shape',
			shape: this.editor.getShape(stickerId),
			isCreating: true,
			onInteractionEnd: 'sticker',
			onCreate: () => {
				this.editor.setCurrentTool('sticker')
			},
		})
	}
}

const overrides: TLUiOverrides = {
	tools(editor, schema) {
		schema['sticker'] = {
			id: 'sticker',
			label: 'Sticker',
			icon: 'heart-icon',
			kbd: 'p',
			onSelect: () => {
				editor.setCurrentTool('sticker')
			},
		}
		return schema
	},
}

const components: TLUiComponents = {
	Toolbar: (...props) => {
		const sticker = useTools().sticker
		const isStickerSelected = useIsToolSelected(sticker)
		return (
			<DefaultToolbar {...props}>
				<TldrawUiMenuItem {...sticker} isSelected={isStickerSelected} />
				<DefaultToolbarContent />
			</DefaultToolbar>
		)
	},
}

export default function StickerExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					;(window as any).editor = editor
				}}
				shapeUtils={[StickerShapeUtil]}
				bindingUtils={[StickerBindingUtil]}
				tools={[StickerTool]}
				overrides={overrides}
				components={components}
			/>
		</div>
	)
}
```

## Custom embed

Keywords: embed, custom

Create custom embeds

tldraw comes with support for many types of embeds out of the box, but it also comes with the ability to create custom embeds. In this example we'll remove some of the built in embeds and also create a JSFiddle embed.

### App.tsx

```tsx
import {
	CustomEmbedDefinition,
	DEFAULT_EMBED_DEFINITIONS,
	DefaultEmbedDefinitionType,
	Tldraw,
} from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

// [1]
const defaultEmbedTypesToKeep: DefaultEmbedDefinitionType[] = ['tldraw', 'youtube']
const defaultEmbedsToKeep = DEFAULT_EMBED_DEFINITIONS.filter((embed) =>
	defaultEmbedTypesToKeep.includes(embed.type)
)

// [2]
const customEmbed: CustomEmbedDefinition = {
	type: 'jsfiddle',
	title: 'JSFiddle',
	hostnames: ['jsfiddle.net'],
	minWidth: 300,
	minHeight: 300,
	width: 720,
	height: 500,
	doesResize: true,
	toEmbedUrl: (url) => {
		const urlObj = new URL(url)
		const matches = urlObj.pathname.match(/\/([^/]+)\/([^/]+)\/(\d+)\/embedded/)
		if (matches) {
			return `https://jsfiddle.net/${matches[1]}/${matches[2]}/embedded/`
		}
		return
	},
	fromEmbedUrl: (url) => {
		const urlObj = new URL(url)
		const matches = urlObj.pathname.match(/\/([^/]+)\/([^/]+)\/(\d+)\/embedded/)
		if (matches) {
			return `https://jsfiddle.net/${matches[1]}/${matches[2]}/`
		}
		return
	},
	icon: 'https://jsfiddle.net/img/favicon.png',
}

// [3]
const embeds = [...defaultEmbedsToKeep, customEmbed]

export default function CustomEmbedExample() {
	return (
		<div className="tldraw__editor">
			{/* [4] */}
			<Tldraw embeds={embeds} />
		</div>
	)
}

/**

[1]
tldraw has built-in support for embedding content from several popular apps. In this example, we extract the definitions for handling 'tldraw' and 'youtube' content, and discard the rest.

[2]
We will also add support for embedding JSFiddles. Please note that you have to specify an icon that will be displayed in the `EmbedDialog` component.

[3]
We concatenate the filtered embed definitions with our custom JSFiddle one. 

[4]
We now pass the custom embed definitions to the `Tldraw` component. 

*/
```

## Custom shape

Keywords: util

A simple custom shape.

You can create custom shapes in tldraw by creating a shape util and passing it to the Tldraw component.
In this example, we'll create a custom shape that is a simple rectangle with some text inside of it.

### App.tsx

```tsx
import {
	Geometry2d,
	HTMLContainer,
	RecordProps,
	Rectangle2d,
	ShapeUtil,
	T,
	TLBaseShape,
	TLResizeInfo,
	Tldraw,
	resizeBox,
} from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

// [1]
type ICustomShape = TLBaseShape<
	'my-custom-shape',
	{
		w: number
		h: number
		text: string
	}
>

// [2]
export class MyShapeUtil extends ShapeUtil<ICustomShape> {
	// [a]
	static override type = 'my-custom-shape' as const
	static override props: RecordProps<ICustomShape> = {
		w: T.number,
		h: T.number,
		text: T.string,
	}

	// [b]
	getDefaultProps(): ICustomShape['props'] {
		return {
			w: 200,
			h: 200,
			text: "I'm a shape!",
		}
	}

	// [c]
	override canEdit() {
		return false
	}
	override canResize() {
		return true
	}
	override isAspectRatioLocked() {
		return false
	}

	// [d]
	getGeometry(shape: ICustomShape): Geometry2d {
		return new Rectangle2d({
			width: shape.props.w,
			height: shape.props.h,
			isFilled: true,
		})
	}

	// [e]
	override onResize(shape: any, info: TLResizeInfo<any>) {
		return resizeBox(shape, info)
	}

	// [f]
	component(shape: ICustomShape) {
		return <HTMLContainer style={{ backgroundColor: '#efefef' }}>{shape.props.text}</HTMLContainer>
	}

	// [g]
	indicator(shape: ICustomShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}

// [3]
const customShape = [MyShapeUtil]

export default function CustomShapeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				shapeUtils={customShape}
				onMount={(editor) => {
					editor.createShape({ type: 'my-custom-shape', x: 100, y: 100 })
				}}
			/>
		</div>
	)
}

/*
Introduction:

You can create custom shapes in tldraw by creating a shape util and passing it to the Tldraw component.
In this example, we'll create a custom shape that is a simple rectangle with some text inside of it. 

[1] 
Define the shape type. This is a type that extend the `TLBaseShape` generic and defines the shape's 
props. We need to pass in a unique string literal for the shape's type and an object that defines the
shape's props.

[2] 
This is our shape util. In tldraw shape utils are classes that define how a shape behaves and renders.
We can extend the ShapeUtil class and provide the shape type as a generic. If we extended the 
BaseBoxShapeUtil class instead, we wouldn't have define methods such as `getGeometry` and `onResize`.

	[a]
	This is where we define out shape's props and type for the editor. It's important to use the same
	string for the type as we did in [1]. We need to define the shape's props using tldraw's validator 
	library. The validator will help make sure the store always has shape data we can trust.

	[b]
	This is a method that returns the default props for our shape.

	[c]
	Some handy methods for controlling different shape behaviour. You don't have to define these, and 
	they're only shown here so you know they exist. Check out the editable shape example to learn more 
	about creating an editable shape.

	[d]
	The getGeometry method is what the editor uses for hit-testing, binding etc. We're using the
	Rectangle2d class from tldraw's geometry library to create a rectangle shape. If we extended the
	BaseBoxShapeUtil class, we wouldn't have to define this method.

	[e]
	We're using the resizeBox utility method to handle resizing our shape. If we extended the
	BaseBoxShapeUtil class, we wouldn't have to define this method.

	[f]
	The component method defines how our shape renders. We're returning an HTMLContainer here, which
	is a handy component that tldraw exports. It's essentially a div with some special css. There's a
	lot of flexibility here, and you can use any React hooks you want and return any valid JSX.

	[g]
	The indicator is the blue outline around a selected shape. We're just returning a rectangle with the
	same width and height as the shape here. You can return any valid JSX here.

[3]
This is where we render the Tldraw component with our custom shape. We're passing in our custom shape
util as an array to the shapeUtils prop. We're also using the onMount callback to create a shape on 
the canvas. If you want to learn how to add a tool for your shape, check out the custom config example. 
If you want to learn how to programmatically control the canvas, check out the Editor API examples.

*/
```

## Custom tool

Keywords: state, machine, chart, node, sticker

Create a custom tool

Tools are nodes in tldraw's state machine. They are responsible for handling user input. You can create custom tools by extending the `StateNode` class and overriding its methods. In this example we make a very simple sticker tool that adds a heart emoji to the canvas when you click.

### App.tsx

```tsx
import { StateNode, TLTextShape, Tldraw, toRichText } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

const OFFSET = 12

// [1]
class StickerTool extends StateNode {
	static override id = 'sticker'

	// [a]
	override onEnter() {
		this.editor.setCursor({ type: 'cross', rotation: 0 })
	}

	// [b]
	override onPointerDown() {
		const { currentPagePoint } = this.editor.inputs
		this.editor.createShape<TLTextShape>({
			type: 'text',
			x: currentPagePoint.x - OFFSET,
			y: currentPagePoint.y - OFFSET,
			props: { richText: toRichText('❤️') },
		})
	}
}

// [2]
const customTools = [StickerTool]
export default function CustomToolExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// Pass in the array of custom tool classes
				tools={customTools}
				// Set the initial state to the sticker tool
				initialState="sticker"
				// hide the ui
				hideUi
				// Put some helpful text on the canvas
				onMount={(editor) => {
					editor.createShape<TLTextShape>({
						type: 'text',
						x: 100,
						y: 100,
						props: { richText: toRichText('Click anywhere to add a sticker') },
					})
				}}
			/>
		</div>
	)
}

/* 
Introduction:

Tools are nodes in tldraw's state machine. They are responsible for handling user input. 
You can create custom tools by extending the `StateNode` class and overriding its methods.
In this example we make a very simple sticker tool that adds a heart emoji to the canvas 
when you click. 

[1]
We extend the `StateNode` class to create a new tool called `StickerTool`. We set its id
to "sticker". We are not implementing any child states in this example, so we don't need
to set an initial state or define any children states. To see an example of a custom tool
with child states, check out the screenshot tool or minimal examples.

	[a] The onEnter method is called when the tool is activated. We use it to set the cursor
		to a crosshair.
	
	[b] The onPointerDown method is called when the user clicks on the canvas. We use it to
		create a new shape at the click location. We can get the click location from the
		editor's inputs.

[2]
We pass our custom tool to the Tldraw component using the `tools` prop. We also set the
initial state to our custom tool. We hide the ui and add some helpful text to the canvas 
using the `onMount` prop. This is not necessary for the tool to work but it helps make the 
example more visually clear.
*/
```

## Drag and drop

Keywords: reparent, shapes, grid, counter

Shapes that can be dragged and dropped onto each other.

You can create custom shapes that can be dragged and dropped onto each other.

### App.tsx

```tsx
import {
	Circle2d,
	Geometry2d,
	HTMLContainer,
	Rectangle2d,
	ShapeUtil,
	TLBaseShape,
	TLShape,
	Tldraw,
} from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

// [1]
type MyGridShape = TLBaseShape<'my-grid-shape', Record<string, never>>
type MyCounterShape = TLBaseShape<'my-counter-shape', Record<string, never>>

// [2]
const SLOT_SIZE = 100
class MyCounterShapeUtil extends ShapeUtil<MyCounterShape> {
	static override type = 'my-counter-shape' as const

	override canResize() {
		return false
	}
	override hideResizeHandles() {
		return true
	}

	getDefaultProps(): MyCounterShape['props'] {
		return {}
	}

	getGeometry(): Geometry2d {
		return new Circle2d({ radius: SLOT_SIZE / 2 - 10, isFilled: true })
	}

	component() {
		return (
			<HTMLContainer
				style={{
					backgroundColor: '#e03131',
					border: '1px solid #ff8787',
					borderRadius: '50%',
				}}
			/>
		)
	}

	indicator() {
		return <circle r={SLOT_SIZE / 2 - 10} cx={SLOT_SIZE / 2 - 10} cy={SLOT_SIZE / 2 - 10} />
	}
}

// [3]
class MyGridShapeUtil extends ShapeUtil<MyGridShape> {
	static override type = 'my-grid-shape' as const

	getDefaultProps(): MyGridShape['props'] {
		return {}
	}

	getGeometry(): Geometry2d {
		return new Rectangle2d({
			width: SLOT_SIZE * 5,
			height: SLOT_SIZE * 2,
			isFilled: true,
		})
	}

	override canResize() {
		return false
	}
	override hideResizeHandles() {
		return true
	}

	// [a]
	override canDropShapes(_shape: MyGridShape, shapes: TLShape[]) {
		if (shapes.every((s) => s.type === 'my-counter-shape')) {
			return true
		}
		return false
	}

	// [b]
	override onDragShapesOver(shape: MyGridShape, shapes: TLShape[]) {
		if (!shapes.every((child) => child.parentId === shape.id)) {
			this.editor.reparentShapes(shapes, shape.id)
		}
	}

	// [c]
	override onDragShapesOut(_shape: MyGridShape, shapes: TLShape[]) {
		this.editor.reparentShapes(shapes, this.editor.getCurrentPageId())
	}

	component() {
		return (
			<HTMLContainer
				style={{
					backgroundColor: '#efefef',
					borderRight: '1px solid #ccc',
					borderBottom: '1px solid #ccc',
					backgroundSize: `${SLOT_SIZE}px ${SLOT_SIZE}px`,
					backgroundImage: `
						linear-gradient(to right, #ccc 1px, transparent 1px),
						linear-gradient(to bottom, #ccc 1px, transparent 1px)
					`,
				}}
			/>
		)
	}

	indicator() {
		return <rect width={SLOT_SIZE * 5} height={SLOT_SIZE * 2} />
	}
}

export default function DragAndDropExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				shapeUtils={[MyGridShapeUtil, MyCounterShapeUtil]}
				onMount={(editor) => {
					editor.createShape({ type: 'my-grid-shape', x: 100, y: 100 })
					editor.createShape({ type: 'my-counter-shape', x: 700, y: 100 })
					editor.createShape({ type: 'my-counter-shape', x: 750, y: 200 })
					editor.createShape({ type: 'my-counter-shape', x: 770, y: 300 })
				}}
			/>
		</div>
	)
}

/*

This example demonstrates how to use the drag-and-drop system.

[1] Define some shape types. For the purposes of this example, we'll define two
shapes: a grid and a counter.

[2] Make a shape util for the first shape. For this example, we'll make a simple
red circle that you drag and drop onto the other shape.

[3] Make the other shape util. In this example, we'll make a grid that you can
place the the circle counters onto.

    [a] Use the `canDropShapes` method to specify which shapes can be dropped onto
    the grid shape.

    [b] Use the `onDragShapesOver` method to reparent counters to the grid shape
    when they are dragged on top.

    [c] Use the `onDragShapesOut` method to reparent counters back to the page
    when they are dragged off.

*/
```

## Interactive shape

Keywords: interaction, pointer events, stop propagation, click, todo, input

A custom shape that has its own onClick interactions.

By default the editor handles pointer events, but sometimes you want to handle interactions on your shape in your own ways, for example via a button. You can do this by using the css property `pointer events: all` and stopping event propagation. In this example we want our todo shape to have a checkbox so the user can mark them as done.

Check out my-interactive-shape-util.tsx to see how we create the shape.

### App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

import { myInteractiveShape } from './my-interactive-shape-util'

// There's a guide at the bottom of this file!

// [1]
const customShapeUtils = [myInteractiveShape]

// [2]
export default function InteractiveShapeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				shapeUtils={customShapeUtils}
				onMount={(editor) => {
					editor.createShape({ type: 'my-interactive-shape', x: 100, y: 100 })
				}}
			/>
		</div>
	)
}

/*
[1]
By default the editor handles pointer events, but sometimes you want to handle 
interactions on your shape in your own ways, for example via a button. You can do this 
by using the css property `pointer events: all` and stopping event propagation. In 
this example we want our todo shape to have a checkbox so the user can mark them as 
done.

[2]
Check out my-interactive-shape-util.tsx to see how we create the shape. 
 */
```
### my-interactive-shape-util.tsx

```tsx
import { BaseBoxShapeUtil, HTMLContainer, RecordProps, T, TLBaseShape } from 'tldraw'

// There's a guide at the bottom of this file!

type IMyInteractiveShape = TLBaseShape<
	'my-interactive-shape',
	{
		w: number
		h: number
		checked: boolean
		text: string
	}
>

export class myInteractiveShape extends BaseBoxShapeUtil<IMyInteractiveShape> {
	static override type = 'my-interactive-shape' as const
	static override props: RecordProps<IMyInteractiveShape> = {
		w: T.number,
		h: T.number,
		checked: T.boolean,
		text: T.string,
	}

	getDefaultProps(): IMyInteractiveShape['props'] {
		return {
			w: 230,
			h: 230,
			checked: false,
			text: '',
		}
	}

	// [1]
	component(shape: IMyInteractiveShape) {
		return (
			<HTMLContainer
				style={{
					padding: 16,
					height: shape.props.h,
					width: shape.props.w,
					// [a] This is where we allow pointer events on our shape
					pointerEvents: 'all',
					backgroundColor: '#efefef',
					overflow: 'hidden',
				}}
			>
				<input
					type="checkbox"
					checked={shape.props.checked}
					onChange={() =>
						this.editor.updateShape<IMyInteractiveShape>({
							id: shape.id,
							type: 'my-interactive-shape',
							props: { checked: !shape.props.checked },
						})
					}
					// [b] This is where we stop event propagation
					onPointerDown={(e) => e.stopPropagation()}
					onTouchStart={(e) => e.stopPropagation()}
					onTouchEnd={(e) => e.stopPropagation()}
				/>
				<input
					type="text"
					placeholder="Enter a todo..."
					readOnly={shape.props.checked}
					value={shape.props.text}
					onChange={(e) =>
						this.editor.updateShape<IMyInteractiveShape>({
							id: shape.id,
							type: 'my-interactive-shape',
							props: { text: e.currentTarget.value },
						})
					}
					// [c]
					onPointerDown={(e) => {
						if (!shape.props.checked) {
							e.stopPropagation()
						}
					}}
					onTouchStart={(e) => {
						if (!shape.props.checked) {
							e.stopPropagation()
						}
					}}
					onTouchEnd={(e) => {
						if (!shape.props.checked) {
							e.stopPropagation()
						}
					}}
				/>
			</HTMLContainer>
		)
	}

	// [5]
	indicator(shape: IMyInteractiveShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}

/* 
This is a custom shape, for a more in-depth look at how to create a custom shape,
see our custom shape example.

[1]
This is where we describe how our shape will render

	[a] We need to set pointer-events to all so that we can interact with our shape. This CSS property is
	set to "none" off by default. We need to manually opt-in to accepting pointer events by setting it to
	'all' or 'auto'. 

	[b] We need to stop event propagation so that the editor doesn't select the shape
		when we click on the checkbox. The 'canvas container' forwards events that it receives
		on to the editor, so stopping propagation here prevents the event from reaching the canvas.
	
	[c] If the shape is not checked, we stop event propagation so that the editor doesn't
		select the shape when we click on the input. If the shape is checked then we allow that event to
		propagate to the canvas and then get sent to the editor, triggering clicks or drags as usual.

*/
```

## Rich text with custom extension and custom toolbar

Keywords: text, tip, tap, extension, toolbar

Extend the TipTap text editor.

The text editor can be extended by setting the `textOptions` prop.

### App.tsx

```tsx
import { Mark, mergeAttributes } from '@tiptap/core'
import StarterKit from '@tiptap/starter-kit'
import {
	DefaultRichTextToolbar,
	TLComponents,
	Tldraw,
	TldrawUiButton,
	preventDefault,
	useEditor,
	useValue,
} from 'tldraw'
import 'tldraw/tldraw.css'
import './RichTextCustomExtension.css'

interface WavyExtensionOptions {
	HTMLAttributes: object
}

declare module '@tiptap/core' {
	interface Commands<ReturnType> {
		wavy: {
			setWavy(): ReturnType
			toggleWavy(): ReturnType
			unsetWavy(): ReturnType
		}
	}
}

const Wavy = Mark.create<WavyExtensionOptions>({
	name: 'wavy',

	addOptions() {
		return {
			HTMLAttributes: {},
		}
	},

	parseHTML() {
		return [
			{
				tag: 'span.wavy',
			},
		]
	},

	renderHTML({ HTMLAttributes }) {
		return [
			'span',
			mergeAttributes(this.options.HTMLAttributes, { class: 'wavy' }, HTMLAttributes),
			0,
		]
	},

	addCommands() {
		return {
			setWavy:
				() =>
				({ commands }) =>
					commands.setMark(this.name),
			toggleWavy:
				() =>
				({ commands }: any) =>
					commands.toggleMark(this.name),
			unsetWavy:
				() =>
				({ commands }) =>
					commands.unsetMark(this.name),
		}
	},
})

const components: TLComponents = {
	RichTextToolbar: () => {
		const editor = useEditor()
		const textEditor = useValue('textEditor', () => editor.getRichTextEditor(), [editor])

		return (
			<DefaultRichTextToolbar>
				<TldrawUiButton
					type="icon"
					onClick={() => {
						textEditor?.chain().focus().toggleWavy().run()
					}}
					isActive={textEditor?.isActive('wavy')}
					onPointerDown={preventDefault}
				>
					〰️
				</TldrawUiButton>
				{/* Add the DefaultRichTextToolbarContent if you want to add more items. */}
				{/* <DefaultRichTextToolbarContent textEditor={textEditor} onEditLinkIntent={() => {}} /> */}
			</DefaultRichTextToolbar>
		)
	},
}

const textOptions = {
	tipTapConfig: {
		extensions: [StarterKit, Wavy],
	},
}

export default function RichTextCustomExtensionExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="rich-text-custom-extension"
				components={components}
				textOptions={textOptions}
			/>
		</div>
	)
}

/*
This example shows how to set custom properties on the TipTap editor.
*/
```
### RichTextCustomExtension.css

```css
.wavy {
	text-decoration: wavy underline hotpink;
}
```

## Rich text with font options

Keywords: text, tip, tap, extension, toolbar, font

Extend the TipTap text editor by adding font-family and font-size options.

The text editor can be extended by setting the `textOptions` prop.

### App.tsx

```tsx
import { EditorEvents as TextEditorEvents } from '@tiptap/core'
import FontFamily from '@tiptap/extension-font-family'
import TextStyle from '@tiptap/extension-text-style'
import { EditorState as TextEditorState } from '@tiptap/pm/state'
import { useEffect, useState } from 'react'
import {
	DefaultRichTextToolbar,
	DefaultRichTextToolbarContent,
	Editor,
	TLComponents,
	TLTextOptions,
	Tldraw,
	defaultAddFontsFromNode,
	stopEventPropagation,
	tipTapDefaultExtensions,
	useEditor,
	useValue,
} from 'tldraw'
import 'tldraw/tldraw.css'
import { FontSize } from './FontSizeExtension'
import './RichTextFontExtension.css'
import { extensionFontFamilies } from './fonts'

const fontOptions = [
	{ label: 'Default', value: 'DEFAULT' },
	{ label: 'Inter', value: 'Inter' },
	{ label: 'Comic Sans MS', value: 'Comic Sans MS' },
	{ label: 'serif', value: 'serif' },
	{ label: 'monospace', value: 'monospace' },
	{ label: 'cursive', value: 'cursive' },
	{ label: 'Exo 2 (Google Font)', value: "'Exo 2'" },
]

const fontSizeOptions = [
	{ label: 'Small', value: '12px' },
	{ label: 'Normal', value: '16px' },
	{ label: 'Large', value: '20px' },
	{ label: 'X-Large', value: '24px' },
	{ label: 'XX-Large', value: '28px' },
	{ label: 'Huge', value: '32px' },
]

const components: TLComponents = {
	RichTextToolbar: () => {
		const editor = useEditor()
		const textEditor = useValue('textEditor', () => editor.getRichTextEditor(), [editor])
		const [_, setTextEditorState] = useState<TextEditorState | null>(textEditor?.state ?? null)

		// Set up text editor transaction listener.
		useEffect(() => {
			if (!textEditor) {
				setTextEditorState(null)
				return
			}

			const handleTransaction = ({ editor: textEditor }: TextEditorEvents['transaction']) => {
				setTextEditorState(textEditor.state)
			}

			textEditor.on('transaction', handleTransaction)
			return () => {
				textEditor.off('transaction', handleTransaction)
				setTextEditorState(null)
			}
		}, [textEditor])

		if (!textEditor) return null

		const currentFontFamily = textEditor?.getAttributes('textStyle').fontFamily ?? 'DEFAULT'
		const currentFontSize = textEditor?.getAttributes('textStyle').fontSize

		return (
			<DefaultRichTextToolbar>
				<select
					value={currentFontFamily}
					onPointerDown={stopEventPropagation}
					onChange={(e) => {
						textEditor?.chain().focus().setFontFamily(e.target.value).run()
					}}
				>
					{fontOptions.map((option) => (
						<option key={option.value} value={option.value}>
							{option.label}
						</option>
					))}
				</select>
				<select
					value={currentFontSize}
					onPointerDown={stopEventPropagation}
					onChange={(e) => {
						textEditor?.chain().focus().setFontSize(e.target.value).run()
					}}
				>
					{fontSizeOptions.map((option) => (
						<option key={option.value} value={option.value}>
							{option.label}
						</option>
					))}
				</select>
				{/* Add the DefaultRichTextToolbarContent if you want to add more items. */}
				<DefaultRichTextToolbarContent textEditor={textEditor} />
			</DefaultRichTextToolbar>
		)
	},
}

const textOptions: Partial<TLTextOptions> = {
	tipTapConfig: {
		extensions: [...tipTapDefaultExtensions, FontFamily, FontSize, TextStyle],
	},
	addFontsFromNode(node, state, addFont) {
		state = defaultAddFontsFromNode(node, state, addFont)

		// if we have a font-family attribute, keep track of that in the state so it applies to children
		for (const mark of node.marks) {
			if (
				mark.type.name === 'textStyle' &&
				mark.attrs.fontFamily &&
				mark.attrs.fontFamily !== 'DEFAULT' &&
				mark.attrs.fontFamily !== state.family
			) {
				state = { ...state, family: mark.attrs.fontFamily }
			}
		}

		// if one of our extension font families matches the current state, add that font to the document.
		const font = extensionFontFamilies[state.family]?.[state.style]?.[state.weight]
		if (font) addFont(font)

		return state
	},
}

export default function RichTextFontExtensionExample() {
	const fontFaces = Object.values(extensionFontFamilies)
		.map((fontFamily) => Object.values(fontFamily))
		.flat()
		.map((fontStyle) => Object.values(fontStyle))
		.flat()

	// We need to preload the fonts so that they are available when
	// making font changes. This is to avoid any FOUC as you change the
	// font families.
	const onMount = (editor: Editor) => {
		editor.fonts.requestFonts(fontFaces)
	}

	const exoFont = extensionFontFamilies["'Exo 2'"].normal.normal.src.url

	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="rich-text-font-extension"
				components={components}
				textOptions={textOptions}
				// If you want to override one of the custom fonts,
				// you can do so by providing an assetUrls prop.
				assetUrls={{
					fonts: {
						tldraw_mono: exoFont,
					},
				}}
				onMount={onMount}
			/>
		</div>
	)
}

/*
This example shows how to set font family and font size properties on the TipTap editor.
*/
```
### FontSizeExtension.ts

```ts
import '@tiptap/extension-text-style'

import { Extension } from '@tiptap/core'

export interface FontSizeOptions {
	/**
	 * A list of node names where the font size can be applied.
	 * @default ['textStyle']
	 * @example ['heading', 'paragraph']
	 */
	types: string[]
}

declare module '@tiptap/core' {
	interface Commands<ReturnType> {
		fontSize: {
			/**
			 * Set the font size
			 * @param fontSize The font size
			 * @example editor.commands.setFontSize('32px')
			 */
			setFontSize(fontSize: string): ReturnType
			/**
			 * Unset the font size
			 * @example editor.commands.unsetFontSize()
			 */
			unsetFontSize(): ReturnType
		}
	}
}

/**
 * This extension allows you to set a font size for text.
 */
export const FontSize = Extension.create<FontSizeOptions>({
	name: 'fontSize',

	addOptions() {
		return {
			types: ['textStyle'],
		}
	},

	addGlobalAttributes() {
		return [
			{
				types: this.options.types,
				attributes: {
					fontSize: {
						default: null,
						parseHTML: (element) => element.style.fontSize,
						renderHTML: (attributes) => {
							if (!attributes.fontSize) {
								return {}
							}

							return {
								style: `font-size: ${attributes.fontSize}`,
							}
						},
					},
				},
			},
		]
	},

	addCommands() {
		return {
			setFontSize:
				(fontSize) =>
				({ chain }) => {
					return chain().setMark('textStyle', { fontSize }).run()
				},
			unsetFontSize:
				() =>
				({ chain }) => {
					return chain().setMark('textStyle', { fontSize: null }).removeEmptyTextStyle().run()
				},
		}
	},
})
```
### RichTextFontExtension.css

```css
.tlui-buttons__horizontal select {
	border: 0;
	background: transparent;
	margin: 0 8px;
}
```
### fonts.ts

```ts
import { TLDefaultFont, TLFontFace } from 'tldraw'

// NOTE: these fonts only support the latin character set. To support other languages, you'll add
// each one as a new font-family, similar to how you would with @font-face.
export const extensionFontFamilies: {
	[key: string]: { [key: string]: { [key: string]: TLFontFace } }
} = {
	Inter: {
		normal: {
			normal: {
				family: 'Inter',
				src: {
					url: 'https://fonts.gstatic.com/s/inter/v18/UcCO3FwrK3iLTeHuS_nVMrMxCp50SjIw2boKoduKmMEVuI6fAZ9hiJ-Ek-_EeA.woff2',
					format: 'woff2',
				},
				weight: '500',
				style: 'normal',
			},
			bold: {
				family: 'Inter',
				src: {
					url: 'https://fonts.gstatic.com/s/inter/v18/UcCO3FwrK3iLTeHuS_nVMrMxCp50SjIw2boKoduKmMEVuFuYAZ9hiJ-Ek-_EeA.woff2',
					format: 'woff2',
				},
				weight: '700',
				style: 'normal',
			},
		},
		italic: {
			normal: {
				family: 'Inter',
				src: {
					url: 'https://fonts.gstatic.com/s/inter/v18/UcCM3FwrK3iLTcvneQg7Ca725JhhKnNqk4j1ebLhAm8SrXTc69tRipWFsevceSGM.woff2',
					format: 'woff2',
				},
				weight: '500',
				style: 'normal',
			},
			bold: {
				family: 'Inter',
				src: {
					url: 'https://fonts.gstatic.com/s/inter/v18/UcCM3FwrK3iLTcvneQg7Ca725JhhKnNqk4j1ebLhAm8SrXTcPtxRipWFsevceSGM.woff2',
					format: 'woff2',
				},
				weight: '700',
				style: 'normal',
			},
		},
	},
	"'Exo 2'": {
		normal: {
			normal: {
				family: 'Exo 2',
				src: {
					url: 'https://fonts.gstatic.com/s/exo2/v24/7cH1v4okm5zmbvwkAx_sfcEuiD8jjPKsOdC_jJ7bpAhL.woff2',
					format: 'woff2',
				},
				weight: '500',
				style: 'normal',
			},
			bold: {
				family: 'Exo 2',
				src: {
					url: 'https://fonts.gstatic.com/s/exo2/v24/7cH1v4okm5zmbvwkAx_sfcEuiD8jWfWsOdC_jJ7bpAhL.woff2',
					format: 'woff2',
				},
				weight: '700',
				style: 'normal',
			},
		},
		italic: {
			normal: {
				family: 'Exo 2',
				src: {
					url: 'https://fonts.gstatic.com/s/exo2/v24/7cH3v4okm5zmbtYtMeA0FKq0Jjg2drFGfeC9hp_5oBBKRrs.woff2',
					format: 'woff2',
				},
				weight: '500',
				style: 'normal',
			},
			bold: {
				family: 'Exo 2',
				src: {
					url: 'https://fonts.gstatic.com/s/exo2/v24/7cH3v4okm5zmbtYtMeA0FKq0Jjg2drGTeuC9hp_5oBBKRrs.woff2',
					format: 'woff2',
				},
				weight: '700',
				style: 'normal',
			},
		},
	},
} satisfies Record<string, TLDefaultFont>
```

## Speech bubble

Keywords: handles, handle, geometry, interaction, text label

A custom shape with handles



### App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import { SpeechBubbleTool } from './SpeechBubble/SpeechBubbleTool'
import { SpeechBubbleUtil } from './SpeechBubble/SpeechBubbleUtil'
import { components, customAssetUrls, uiOverrides } from './SpeechBubble/ui-overrides'
import './customhandles.css'

// There's a guide at the bottom of this file!

// [1]
const shapeUtils = [SpeechBubbleUtil]
const tools = [SpeechBubbleTool]

// [2]
export default function CustomShapeWithHandles() {
	return (
		<div style={{ position: 'absolute', inset: 0 }}>
			<Tldraw
				shapeUtils={shapeUtils}
				tools={tools}
				overrides={uiOverrides}
				assetUrls={customAssetUrls}
				components={components}
				persistenceKey="whatever"
			/>
		</div>
	)
}

/*
Introduction:

This example shows how to create a custom shape using handles. You can use handles when you want
user interaction to alter the geometry of a shape. In this example, we create a speech bubble shape
with a handle on the tail so the user can alter its position and length. Most of the interesting stuff
is in SpeechBubbleUtil.tsx and helpers.tsx. 

[1]
We define an array to hold the custom shape util and cusom tool. It's important to do this outside of
any React component so that this array doesn't get redefined on every render. We'll pass this into the 
Tldraw component's `shapeUtils` and `tools` props.

Check out SpeechBubbleUtil.tsx and SpeechBubbleTool.tsx to see how we define the shape util and tool.

[2]
We pass the custom shape util and tool into the Tldraw component's `shapeUtils` and `tools` props.
We also pass in the custom ui overrides and asset urls to make sure our icons render where we want them to. 
Check out ui-overrides.ts for more details.

*/
```
### customhandles.css

```css
/* Resize handles are normally on top, but We're going to give shape handles priority */
.tl-user-handles {
	z-index: 101;
}

/* The text label doesn't normally deal with text that goes sideways,
 * so this accounts for that */
.tl-shape[data-shape-type='speech-bubble'] .tl-text-label {
	justify-content: flex-start !important;
}
```
### SpeechBubbleTool.tsx

```tsx
import { BaseBoxShapeTool } from 'tldraw'

export class SpeechBubbleTool extends BaseBoxShapeTool {
	static override id = 'speech-bubble'
	static override initial = 'idle'
	override shapeType = 'speech-bubble'
}

/*
This file contains our speech bubble tool. The tool is a StateNode with the `id` "speech-bubble".

We get a lot of functionality for free by extending the BaseBoxShapeTool. For an example of a tool
with more custom functionality, check out the screenshot-tool example. 

*/
```
### SpeechBubbleUtil.tsx

```tsx
import {
	DefaultColorStyle,
	DefaultFontStyle,
	DefaultHorizontalAlignStyle,
	DefaultSizeStyle,
	DefaultVerticalAlignStyle,
	FONT_FAMILIES,
	Geometry2d,
	LABEL_FONT_SIZES,
	PlainTextLabel,
	Polygon2d,
	RecordPropsType,
	ShapeUtil,
	T,
	TEXT_PROPS,
	TLBaseShape,
	TLHandle,
	TLHandleDragInfo,
	TLResizeInfo,
	Vec,
	ZERO_INDEX_KEY,
	resizeBox,
	structuredClone,
	useDefaultColorTheme,
	vecModelValidator,
} from 'tldraw'
import { getSpeechBubbleVertices, getTailIntersectionPoint } from './helpers'

// Copied from tldraw/tldraw
export const STROKE_SIZES = {
	s: 2,
	m: 3.5,
	l: 5,
	xl: 10,
}

// There's a guide at the bottom of this file!

// [1]

export const speechBubbleShapeProps = {
	w: T.number,
	h: T.number,
	size: DefaultSizeStyle,
	color: DefaultColorStyle,
	font: DefaultFontStyle,
	align: DefaultHorizontalAlignStyle,
	verticalAlign: DefaultVerticalAlignStyle,
	growY: T.positiveNumber,
	text: T.string,
	tail: vecModelValidator,
}

export type SpeechBubbleShapeProps = RecordPropsType<typeof speechBubbleShapeProps>
export type SpeechBubbleShape = TLBaseShape<'speech-bubble', SpeechBubbleShapeProps>

export class SpeechBubbleUtil extends ShapeUtil<SpeechBubbleShape> {
	static override type = 'speech-bubble' as const

	// [2]
	static override props = speechBubbleShapeProps

	override isAspectRatioLocked(_shape: SpeechBubbleShape) {
		return false
	}

	override canResize(_shape: SpeechBubbleShape) {
		return true
	}

	override canEdit() {
		return true
	}

	// [3]
	getDefaultProps(): SpeechBubbleShapeProps {
		return {
			w: 200,
			h: 130,
			color: 'black',
			size: 'm',
			font: 'draw',
			align: 'middle',
			verticalAlign: 'start',
			growY: 0,
			text: '',
			tail: { x: 0.5, y: 1.5 },
		}
	}

	getHeight(shape: SpeechBubbleShape) {
		return shape.props.h + shape.props.growY
	}

	getGeometry(shape: SpeechBubbleShape): Geometry2d {
		const speechBubbleGeometry = getSpeechBubbleVertices(shape)
		const body = new Polygon2d({
			points: speechBubbleGeometry,
			isFilled: true,
		})
		return body
	}

	// [4]
	override getHandles(shape: SpeechBubbleShape): TLHandle[] {
		const { tail, w } = shape.props

		return [
			{
				id: 'tail',
				type: 'vertex',
				index: ZERO_INDEX_KEY,
				// props.tail coordinates are normalized
				// but here we need them in shape space
				x: tail.x * w,
				y: tail.y * this.getHeight(shape),
			},
		]
	}

	override onHandleDrag(shape: SpeechBubbleShape, { handle }: TLHandleDragInfo<SpeechBubbleShape>) {
		return {
			...shape,
			props: {
				tail: {
					x: handle.x / shape.props.w,
					y: handle.y / this.getHeight(shape),
				},
			},
		}
	}

	override onBeforeCreate(next: SpeechBubbleShape) {
		return this.getGrowY(next, next.props.growY)
	}

	// [5]
	override onBeforeUpdate(prev: SpeechBubbleShape, shape: SpeechBubbleShape) {
		const { w, tail } = shape.props
		const fullHeight = this.getHeight(shape)

		const { segmentsIntersection, insideShape } = getTailIntersectionPoint(shape)

		const slantedLength = Math.hypot(w, fullHeight)
		const MIN_DISTANCE = slantedLength / 5
		const MAX_DISTANCE = slantedLength / 1.5

		const tailInShapeSpace = new Vec(tail.x * w, tail.y * fullHeight)

		const distanceToIntersection = tailInShapeSpace.dist(segmentsIntersection)
		const center = new Vec(w / 2, fullHeight / 2)
		const tailDirection = Vec.Sub(tailInShapeSpace, center).uni()

		let newPoint = tailInShapeSpace

		if (insideShape) {
			newPoint = Vec.Add(segmentsIntersection, tailDirection.mul(MIN_DISTANCE))
		} else {
			if (distanceToIntersection <= MIN_DISTANCE) {
				newPoint = Vec.Add(segmentsIntersection, tailDirection.mul(MIN_DISTANCE))
			} else if (distanceToIntersection >= MAX_DISTANCE) {
				newPoint = Vec.Add(segmentsIntersection, tailDirection.mul(MAX_DISTANCE))
			}
		}

		const next = structuredClone(shape)
		next.props.tail.x = newPoint.x / w
		next.props.tail.y = newPoint.y / fullHeight

		return this.getGrowY(next, prev.props.growY)
	}

	component(shape: SpeechBubbleShape) {
		const {
			id,
			type,
			props: { color, font, size, align, text },
		} = shape
		const vertices = getSpeechBubbleVertices(shape)
		const pathData = 'M' + vertices[0] + 'L' + vertices.slice(1) + 'Z'
		const isSelected = shape.id === this.editor.getOnlySelectedShapeId()
		// eslint-disable-next-line react-hooks/rules-of-hooks
		const theme = useDefaultColorTheme()

		return (
			<>
				<svg className="tl-svg-container">
					<path
						d={pathData}
						strokeWidth={STROKE_SIZES[size]}
						stroke={theme[color].solid}
						fill={'none'}
					/>
				</svg>
				<PlainTextLabel
					shapeId={id}
					type={type}
					font={font}
					textWidth={shape.props.w}
					fontSize={LABEL_FONT_SIZES[size]}
					lineHeight={TEXT_PROPS.lineHeight}
					align={align}
					verticalAlign="start"
					text={text}
					labelColor={theme[color].solid}
					isSelected={isSelected}
					wrap
				/>
			</>
		)
	}

	indicator(shape: SpeechBubbleShape) {
		const vertices = getSpeechBubbleVertices(shape)
		const pathData = 'M' + vertices[0] + 'L' + vertices.slice(1) + 'Z'
		return <path d={pathData} />
	}

	override onResize(shape: SpeechBubbleShape, info: TLResizeInfo<SpeechBubbleShape>) {
		const resized = resizeBox(shape, info)
		const next = structuredClone(info.initialShape)
		next.x = resized.x
		next.y = resized.y
		next.props.w = resized.props.w
		next.props.h = resized.props.h
		return next
	}

	getGrowY(shape: SpeechBubbleShape, prevGrowY = 0) {
		const PADDING = 17

		const nextTextSize = this.editor.textMeasure.measureText(shape.props.text, {
			...TEXT_PROPS,
			fontFamily: FONT_FAMILIES[shape.props.font],
			fontSize: LABEL_FONT_SIZES[shape.props.size],
			maxWidth: shape.props.w - PADDING * 2,
		})

		const nextHeight = nextTextSize.h + PADDING * 2

		let growY = 0

		if (nextHeight > shape.props.h) {
			growY = nextHeight - shape.props.h
		} else {
			if (prevGrowY) {
				growY = 0
			}
		}

		return {
			...shape,
			props: {
				...shape.props,
				growY,
			},
		}
	}
}

/*
Introduction: This file contains our custom shape util. The shape util is a class that defines how
our shape behaves. Most of the logic for how the speech bubble shape works is in the onBeforeUpdate
handler [5]. Since this shape has a handle, we need to do some special stuff to make sure it updates
the way we want it to.

[1]
Here is where we define the shape's type. For the tail we can use the `VecModel` type from `tldraw`.

[2]
This is where we define the shape's props and a type validator for each key. tldraw exports a
bunch of handy validators for us to use. Props you define here will determine which style options
show up in the style menu, e.g. we define 'size' and 'color' props, but we could add 'dash', 'fill'
or any other of the default props.

[3]
Here is where we set the default props for our shape, this will determine how the shape looks
when we click-create it. You'll notice we don't store the tail's absolute position though, instead
we record its relative position. This is because we can also drag-create shapes. If we store the
tail's position absolutely it won't scale properly when drag-creating. Throughout the rest of the
util we'll need to convert the tail's relative position to an absolute position and vice versa.

[4]
`getHandles` tells tldraw how to turn our shape into a list of handles that'll show up when it's
selected. We only have one handle, the tail, which simplifies things for us a bit. In
`onHandleDrag`, we tell tldraw how our shape should be updated when the handle is dragged.

[5]
This is the last method that fires after a shape has been changed, we can use it to make sure
the tail stays the right length and position. Check out helpers.tsx to get into some of the more
specific geometry stuff.
*/
```
### helpers.tsx

```tsx
import { Vec, VecLike, lerp, pointInPolygon } from 'tldraw'
import { SpeechBubbleShape } from './SpeechBubbleUtil'

export const getSpeechBubbleVertices = (shape: SpeechBubbleShape): Vec[] => {
	const { w, tail } = shape.props

	const fullHeight = shape.props.h + shape.props.growY
	const tailInShapeSpace = new Vec(tail.x * w, tail.y * fullHeight)

	const [tl, tr, br, bl] = [
		new Vec(0, 0),
		new Vec(w, 0),
		new Vec(w, fullHeight),
		new Vec(0, fullHeight),
	]

	const offsetH = w / 10
	const offsetV = fullHeight / 10

	const { adjustedIntersection, intersectionSegmentIndex } = getTailIntersectionPoint(shape)

	let vertices: Vec[]

	// Inject the tail segments into the geometry of the shape
	switch (intersectionSegmentIndex) {
		case 0:
			// top
			vertices = [
				tl,
				new Vec(adjustedIntersection.x - offsetH, adjustedIntersection.y),
				new Vec(tailInShapeSpace.x, tailInShapeSpace.y),
				new Vec(adjustedIntersection.x + offsetH, adjustedIntersection.y),
				tr,
				br,
				bl,
			]
			break
		case 1:
			// right
			vertices = [
				tl,
				tr,
				new Vec(adjustedIntersection.x, adjustedIntersection.y - offsetV),
				new Vec(tailInShapeSpace.x, tailInShapeSpace.y),
				new Vec(adjustedIntersection.x, adjustedIntersection.y + offsetV),
				br,
				bl,
			]
			break
		case 2:
			// bottom
			vertices = [
				tl,
				tr,
				br,
				new Vec(adjustedIntersection.x + offsetH, adjustedIntersection.y),
				new Vec(tailInShapeSpace.x, tailInShapeSpace.y),
				new Vec(adjustedIntersection.x - offsetH, adjustedIntersection.y),
				bl,
			]
			break
		case 3:
			// left
			vertices = [
				tl,
				tr,
				br,
				bl,
				new Vec(adjustedIntersection.x, adjustedIntersection.y + offsetV),
				new Vec(tailInShapeSpace.x, tailInShapeSpace.y),
				new Vec(adjustedIntersection.x, adjustedIntersection.y - offsetV),
			]
			break
		default:
			throw Error("no intersection found, this shouldn't happen")
	}

	return vertices
}

export function getTailIntersectionPoint(shape: SpeechBubbleShape) {
	const { w, tail } = shape.props
	const fullHeight = shape.props.h + shape.props.growY
	const tailInShapeSpace = new Vec(tail.x * w, tail.y * fullHeight)

	const center = new Vec(w / 2, fullHeight / 2)
	const corners = [new Vec(0, 0), new Vec(w, 0), new Vec(w, fullHeight), new Vec(0, fullHeight)]
	const segments = [
		[corners[0], corners[1]],
		[corners[1], corners[2]],
		[corners[2], corners[3]],
		[corners[3], corners[0]],
	]

	let segmentsIntersection: Vec | null = null
	let intersectionSegment: Vec[] | null = null

	// If the point inside of the box's corners?
	const insideShape = pointInPolygon(tailInShapeSpace, corners)

	// We want to be sure we get an intersection, so if the point is
	// inside the shape, push it away from the center by a big distance
	const pointToCheck = insideShape
		? Vec.Add(tailInShapeSpace, Vec.Sub(tailInShapeSpace, center).uni().mul(1000000))
		: tailInShapeSpace

	// Test each segment for an intersection
	for (const segment of segments) {
		segmentsIntersection = intersectLineSegmentLineSegment(
			segment[0],
			segment[1],
			center,
			pointToCheck
		)

		if (segmentsIntersection) {
			intersectionSegment = segment
			break
		}
	}

	if (!(segmentsIntersection && intersectionSegment)) {
		throw Error("no intersection found, this shouldn't happen")
	}

	const [start, end] = intersectionSegment
	const intersectionSegmentIndex = segments.indexOf(intersectionSegment)

	// a normalised vector from start to end, so this can work in any direction
	const unit = Vec.Sub(end, start).uni()

	// Where is the intersection relative to the start?
	const totalDistance = Vec.Dist(start, end)
	const distance = Vec.Dist(segmentsIntersection, start)

	// make it stick to the middle
	const middleRelative = mapRange(0, totalDistance, -1, 1, distance) // absolute -> -1 to 1
	const squaredRelative = Math.abs(middleRelative) ** 2 * Math.sign(middleRelative) // square it and keep the sign
	const squared = mapRange(-1, 1, 0, totalDistance, squaredRelative) // -1 to 1 -> absolute

	//keep it away from the edges
	const offset = (segments.indexOf(intersectionSegment) % 2 === 0 ? w / 10 : fullHeight / 10) * 3
	const constrained = mapRange(0, totalDistance, offset, totalDistance - offset, distance)

	// combine the two
	const interpolated = lerp(constrained, squared, 0.5)

	const adjustedIntersection = unit.mul(interpolated).add(start)

	// We need the adjusted intersection to draw the tail, but the original intersection
	// for the onBeforeUpdate handler
	return {
		segmentsIntersection,
		adjustedIntersection,
		intersectionSegmentIndex,
		insideShape,
	}
}

// This function is copied from the tldraw codebase
function intersectLineSegmentLineSegment(a1: VecLike, a2: VecLike, b1: VecLike, b2: VecLike) {
	const ABx = a1.x - b1.x
	const ABy = a1.y - b1.y
	const BVx = b2.x - b1.x
	const BVy = b2.y - b1.y
	const AVx = a2.x - a1.x
	const AVy = a2.y - a1.y
	const ua_t = BVx * ABy - BVy * ABx
	const ub_t = AVx * ABy - AVy * ABx
	const u_b = BVy * AVx - BVx * AVy

	if (ua_t === 0 || ub_t === 0) return null // coincident

	if (u_b === 0) return null // parallel

	if (u_b !== 0) {
		const ua = ua_t / u_b
		const ub = ub_t / u_b
		if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
			return Vec.AddXY(a1, ua * AVx, ua * AVy)
		}
	}

	return null // no intersection
}

/**
 * Inverse linear interpolation
 */
function invLerp(a: number, b: number, v: number) {
	return (v - a) / (b - a)
}
/**
 * Maps a value from one range to another.
 * e.g. mapRange(10, 20, 50, 100, 15) => 75
 */
function mapRange(a1: number, b1: number, a2: number, b2: number, s: number) {
	return lerp(a2, b2, invLerp(a1, b1, s))
}
```
### ui-overrides.tsx

```tsx
import {
	DefaultKeyboardShortcutsDialog,
	DefaultKeyboardShortcutsDialogContent,
	DefaultToolbar,
	DefaultToolbarContent,
	TLComponents,
	TLUiAssetUrlOverrides,
	TLUiOverrides,
	TldrawUiMenuItem,
	useIsToolSelected,
	useTools,
} from 'tldraw'

// There's a guide at the bottom of this file!

// [1]
export const uiOverrides: TLUiOverrides = {
	tools(editor, tools) {
		tools.speech = {
			id: 'speech-bubble',
			icon: 'speech-bubble',
			label: 'Speech Bubble',
			kbd: 's',
			onSelect: () => {
				editor.setCurrentTool('speech-bubble')
			},
		}
		return tools
	},
}

// [2]
export const customAssetUrls: TLUiAssetUrlOverrides = {
	icons: {
		'speech-bubble': '/speech-bubble.svg',
	},
}

export const components: TLComponents = {
	Toolbar: (props) => {
		const tools = useTools()
		const isSpeechBubbleSelected = useIsToolSelected(tools['speech'])
		return (
			<DefaultToolbar {...props}>
				<TldrawUiMenuItem {...tools['speech']} isSelected={isSpeechBubbleSelected} />
				<DefaultToolbarContent />
			</DefaultToolbar>
		)
	},
	KeyboardShortcutsDialog: (props) => {
		const tools = useTools()
		return (
			<DefaultKeyboardShortcutsDialog {...props}>
				<TldrawUiMenuItem {...tools['speech']} />
				<DefaultKeyboardShortcutsDialogContent />
			</DefaultKeyboardShortcutsDialog>
		)
	},
}

/* 

This file contains overrides for the Tldraw UI. These overrides are used to add your custom tools
to the toolbar and the keyboard shortcuts menu.

[1]
Here we add our new tool to the UI's tools object in the tools override. This is where we define
all the basic information about our new tool - its icon, label, keyboard shortcut, what happens when
we select it, etc.


[2]
Our toolbar item is using a custom icon, so we need to provide the asset url for it. 
We do this by providing a custom assetUrls object to the Tldraw component. 
This object is a map of icon ids to their urls. The icon ids are the same as the 
icon prop on the toolbar item. We'll pass our assetUrls object into the Tldraw
component's `assetUrls` prop.

[3]
We replace the UI components for the toolbar and keyboard shortcut dialog with our own, that
add our new tool to the existing default content. Ideally, we'd interleave our new tool into the
ideal place among the default tools, but for now we're just adding it at the start to keep things
simple.

*/
```

## Using tldraw styles

Keywords: default styles, style panel

Using the tldraw style panel with your custom shapes

The default tldraw UI will display UI for the styles of your selection or your current tool. For example, when you have two shapes selected that both have the tldraw's "size" style, the size selector will be displayed. If all of your selected shapes have the same value for this style, that value will be shown as selected in the panel. If they have different values, the panel will show the value as "mixed".

You can use tldraw's Styles API to create your own styles that behave in the same way, though you'll also need to create a custom UI for your style.

Alternatively, you can use tldraw's default styles in your own shapes. This example shows how to do that.

### App.tsx

```tsx
import {
	BaseBoxShapeUtil,
	DefaultColorStyle,
	DefaultSizeStyle,
	HTMLContainer,
	T,
	TLBaseShape,
	TLDefaultColorStyle,
	TLDefaultSizeStyle,
	Tldraw,
	useDefaultColorTheme,
} from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

const FONT_SIZES: Record<TLDefaultSizeStyle, number> = {
	s: 14,
	m: 25,
	l: 38,
	xl: 48,
}

type IMyShape = TLBaseShape<
	'myshape',
	{
		w: number
		h: number
		// [1]
		size: TLDefaultSizeStyle
		color: TLDefaultColorStyle
	}
>

class MyShapeUtil extends BaseBoxShapeUtil<IMyShape> {
	static override type = 'myshape' as const

	// [2]
	static override props = {
		w: T.number,
		h: T.number,
		size: DefaultSizeStyle,
		color: DefaultColorStyle,
	}

	getDefaultProps(): IMyShape['props'] {
		return {
			w: 300,
			h: 300,
			size: 'm',
			color: 'black',
		}
	}

	component(shape: IMyShape) {
		// eslint-disable-next-line react-hooks/rules-of-hooks
		const theme = useDefaultColorTheme()

		return (
			<HTMLContainer
				id={shape.id}
				style={{ backgroundColor: 'var(--color-low-border)', overflow: 'hidden' }}
			>
				<div
					style={{
						// [3]
						fontSize: FONT_SIZES[shape.props.size],
						color: theme[shape.props.color].solid,
					}}
				>
					Select the shape and use the style panel to change the font size and color
				</div>
			</HTMLContainer>
		)
	}

	indicator(shape: IMyShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}

const customShapeUtils = [MyShapeUtil]

export default function ShapeWithTldrawStylesExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				shapeUtils={customShapeUtils}
				onMount={(editor) => {
					editor.createShape({ type: 'myshape', x: 100, y: 100 })
				}}
			/>
		</div>
	)
}

/* 

This file shows a custom shape that uses tldraw's default styles. 
For more on custom shapes, see our Custom Shape example.

[1]
In this example, our custom shape will use the size and color styles from the
default styles. When typing a custom shape, you can use our types for
these styles.

[2]
For the shape's props, we'll pass the DefaultSizeStyle and DefaultColorStyle
styles for the two properties, size and color. There's nothing special about
these styles except that the editor will notice when two shapes are selected
that share the same style. (You can use the useRelevantStyles hook to get the
styles of the user's selected shapes.)

[3]
Here in the component, we'll use the styles to change the way that our shape
appears. The style values themselves are just strings, like 'xl' or 'black',
so it's up to you to decide how to use them. In this example, we're using the
size to set the text's font-size property, and also using the default theme
(via the useDefaultColorTheme hook) to get the color for the text.
*/
```

## Custom tool (screenshot)

Keywords: state chart, state machine, child states

Draw a box on the canvas to capture a screenshot of that area.

Tools are the parts of tldraw's state chart. Most interactions in tldraw are tools.

### App.tsx

```tsx
import {
	Box,
	DefaultToolbar,
	DefaultToolbarContent,
	TLComponents,
	TLUiAssetUrlOverrides,
	TLUiOverrides,
	Tldraw,
	TldrawUiMenuItem,
	useEditor,
	useIsToolSelected,
	useTools,
	useValue,
} from 'tldraw'
import 'tldraw/tldraw.css'
import { ScreenshotTool } from './ScreenshotTool/ScreenshotTool'
import { ScreenshotDragging } from './ScreenshotTool/childStates/Dragging'

// There's a guide at the bottom of this file!

// [1]
const customTools = [ScreenshotTool]

// [2]
const customUiOverrides: TLUiOverrides = {
	tools: (editor, tools) => {
		return {
			...tools,
			screenshot: {
				id: 'screenshot',
				label: 'Screenshot',
				icon: 'tool-screenshot',
				kbd: 'j',
				onSelect() {
					editor.setCurrentTool('screenshot')
				},
			},
		}
	},
}

function CustomToolbar() {
	const tools = useTools()
	const isScreenshotSelected = useIsToolSelected(tools['screenshot'])
	return (
		<DefaultToolbar>
			<TldrawUiMenuItem {...tools['screenshot']} isSelected={isScreenshotSelected} />
			<DefaultToolbarContent />
		</DefaultToolbar>
	)
}

// [3]
const customAssetUrls: TLUiAssetUrlOverrides = {
	icons: {
		'tool-screenshot': '/tool-screenshot.svg',
	},
}

// [4]
function ScreenshotBox() {
	const editor = useEditor()

	const screenshotBrush = useValue(
		'screenshot brush',
		() => {
			// Check whether the screenshot tool (and its dragging state) is active
			if (editor.getPath() !== 'screenshot.dragging') return null

			// Get screenshot.dragging state node
			const draggingState = editor.getStateDescendant<ScreenshotDragging>('screenshot.dragging')!

			// Get the box from the screenshot.dragging state node
			const box = draggingState.screenshotBox.get()

			// The box is in "page space", i.e. panned and zoomed with the canvas, but we
			// want to show it in front of the canvas, so we'll need to convert it to
			// "page space", i.e. uneffected by scale, and relative to the tldraw
			// page's top left corner.
			const zoomLevel = editor.getZoomLevel()
			const { x, y } = editor.pageToViewport({ x: box.x, y: box.y })
			return new Box(x, y, box.w * zoomLevel, box.h * zoomLevel)
		},
		[editor]
	)

	if (!screenshotBrush) return null

	return (
		<div
			style={{
				position: 'absolute',
				top: 0,
				left: 0,
				transform: `translate(${screenshotBrush.x}px, ${screenshotBrush.y}px)`,
				width: screenshotBrush.w,
				height: screenshotBrush.h,
				border: '1px solid var(--color-text-0)',
				zIndex: 999,
			}}
		/>
	)
}

const customComponents: TLComponents = {
	InFrontOfTheCanvas: ScreenshotBox,
	Toolbar: CustomToolbar,
}

// [5]
export default function ScreenshotToolExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="tldraw_screenshot_example"
				tools={customTools}
				overrides={customUiOverrides}
				assetUrls={customAssetUrls}
				components={customComponents}
			/>
		</div>
	)
}

/*
Introduction:

This example shows how to create a custom tool. In tldraw, tools are parts of the
tldraw state chart. While the most common use for tools is creating shapes, you can
use tools to create other types of interactions too! In this example, we create a
"screenshot tool" that lets the user draw a box on the canvas. When the user finishes
drawing their box, we'll export (or copy) a screenshot of that area.

[1]
Our custom tool is a class that extends the StateNode class. See the ScreenshotTool
files for more about the too. We define an array (outside of any React component)
to hold the custom tools. We'll pass this into the Tldraw component's `tools` prop.

[2]
Here we make sure the UI knows about our new tool. We do this by adding it to the
`tools` object, which tells other parts of the UI a tool's label, icon, what should
happen when it's selected, etc. We'll pass our customUiOverrides object into the
Tldraw component's `overrides` prop.

[3]
Our toolbar item is using a custom icon, so we need to provide the asset url for it. 
We do this by providing a custom assetUrls object to the Tldraw component. 
This object is a map of icon ids to their urls. The icon ids are the same as the 
icon prop on the toolbar item. We'll pass our assetUrls object into the Tldraw
component's `assetUrls` prop.

[4]
We want to show a box on the canvas when the screenshot tool is active. We do this
by providing an override to the InFrontOfTheCanvas component. This component will be shown
in front of the canvas but behind any other UI elements, such as menus and the toolbar.
We'll pass our components object into the Tldraw component's `components` prop. 

[5]
Finally we pass all of our customizations into the Tldraw component. It's important
that the customizations are defined outside of the React component, otherwise they
will cause the Tldraw component to see them as new values on every render, which may
produce unexpected results.
*/
```
### ScreenshotTool.ts

```ts
import { StateNode } from 'tldraw'
import { ScreenshotDragging } from './childStates/Dragging'
import { ScreenshotIdle } from './childStates/Idle'
import { ScreenshotPointing } from './childStates/Pointing'

// There's a guide at the bottom of this file!

export class ScreenshotTool extends StateNode {
	// [1]
	static override id = 'screenshot'
	static override initial = 'idle'
	static override children() {
		return [ScreenshotIdle, ScreenshotPointing, ScreenshotDragging]
	}

	// [2]
	override onEnter() {
		this.editor.setCursor({ type: 'cross', rotation: 0 })
	}

	override onExit() {
		this.editor.setCursor({ type: 'default', rotation: 0 })
	}

	// [3]
	override onInterrupt() {
		this.complete()
	}

	override onCancel() {
		this.complete()
	}

	private complete() {
		this.parent.transition('select', {})
	}
}

/*
This file contains our screenshot tool. The tool is a StateNode with the `id` "screenshot".

[1]
It has three child state nodes, ScreenshotIdle, ScreenshotPointing, and ScreenshotDragging. 
Its initial state is `idle`.

[2]
When the screenshot tool is entered, we set the cursor to a crosshair. When it is exited, we
set the cursor back to the default cursor. 

[3]
When the screenshot tool is interrupted or cancelled, we transition back to the select tool.
*/
```
### Dragging.ts

```ts
import { Box, StateNode, atom, copyAs, exportAs } from 'tldraw'

// There's a guide at the bottom of this file!

export class ScreenshotDragging extends StateNode {
	static override id = 'dragging'

	// [1]
	screenshotBox = atom('screenshot brush', new Box())

	// [2]
	override onEnter() {
		this.update()
	}

	override onPointerMove() {
		this.update()
	}

	override onKeyDown() {
		this.update()
	}

	override onKeyUp() {
		this.update()
	}

	private update() {
		const {
			inputs: { shiftKey, altKey, originPagePoint, currentPagePoint },
		} = this.editor

		const box = Box.FromPoints([originPagePoint, currentPagePoint])

		if (shiftKey) {
			if (box.w > box.h * (16 / 9)) {
				box.h = box.w * (9 / 16)
			} else {
				box.w = box.h * (16 / 9)
			}

			if (currentPagePoint.x < originPagePoint.x) {
				box.x = originPagePoint.x - box.w
			}

			if (currentPagePoint.y < originPagePoint.y) {
				box.y = originPagePoint.y - box.h
			}
		}

		if (altKey) {
			box.w *= 2
			box.h *= 2
			box.x = originPagePoint.x - box.w / 2
			box.y = originPagePoint.y - box.h / 2
		}

		this.screenshotBox.set(box)
	}

	// [3]
	override onPointerUp() {
		const { editor } = this
		const box = this.screenshotBox.get()

		// get all shapes contained by or intersecting the box
		const shapes = editor.getCurrentPageShapes().filter((s) => {
			const pageBounds = editor.getShapeMaskedPageBounds(s)
			if (!pageBounds) return false
			return box.includes(pageBounds)
		})

		if (shapes.length) {
			if (editor.inputs.ctrlKey) {
				// Copy the shapes to the clipboard
				copyAs(
					editor,
					shapes.map((s) => s.id),
					{ format: 'png', bounds: box }
				)
			} else {
				// Export the shapes as a png
				exportAs(
					editor,
					shapes.map((s) => s.id),
					{
						format: 'png',
						name: 'Screenshot',
						bounds: box,
					}
				)
			}
		}

		this.editor.setCurrentTool('select')
	}

	// [4]
	override onCancel() {
		this.editor.setCurrentTool('select')
	}
}

/*
[1] 
This state has a reactive property (an Atom) called "screenshotBox". This is the box
that the user is drawing on the screen as they drag their pointer. We use an Atom here
so that our UI can subscribe to this property using `useValue` (see the ScreenshotBox
component in ScreenshotToolExample).

[2]
When the user enters this state, or when they move their pointer, we update the 
screenshotBox property to be drawn between the place where the user started pointing
and the place where their pointer is now. If the user is holding Shift, then we modify
the dimensions of this box so that it is in a 16:9 aspect ratio.

[3]
When the user makes a pointer up and stops dragging, we export the shapes contained by
the screenshot box as a png. If the user is holding the ctrl key, we copy the shapes
to the clipboard instead.

[4]
When the user cancels (esc key) or makes a pointer up event, we transition back to the
select tool.
*/
```
### Idle.ts

```ts
import { StateNode } from 'tldraw'

// There's a guide at the bottom of this file!

export class ScreenshotIdle extends StateNode {
	static override id = 'idle'

	// [1]
	override onPointerDown() {
		this.parent.transition('pointing')
	}
}

/*
[1]
When we the user makes a pointer down event, we transition to the pointing state.
*/
```
### Pointing.ts

```ts
import { StateNode } from 'tldraw'

// There's a guide at the bottom of this file!

export class ScreenshotPointing extends StateNode {
	static override id = 'pointing'

	// [1]
	override onPointerMove() {
		if (this.editor.inputs.isDragging) {
			this.parent.transition('dragging')
		}
	}

	// [2]
	override onPointerUp() {
		this.complete()
	}

	override onCancel() {
		this.complete()
	}

	private complete() {
		this.parent.transition('idle')
	}
}

/*
[1]
When the user makes a pointer move event, we check if they are dragging. If they are, 
we transition to the dragging state. If they are not yet dragging, we stay in this state.

[2]
When the user cancelles or makes a pointer up event (while this state is still active, 
so after the user has started pointing but before they've moved their pointer far enough 
to start dragging), then we transition back to the idle state.
*/
```

## Editable shape

Keywords: custom

A custom shape that you can edit by double-clicking it.

In Tldraw, the Editor can have one editing shape at a time. When in its editing state, the editor will ignore events until the user exits the editing state by pressing Escape or clicking on the canvas.

Only shapes with a `canEdit` flag that returns true may become editable. A user may begin editing a shape by double clicking on the editable shape, or selecting the editable shape and pressing enter.

Many of our shapes use editing to allow for interactions inside of the shape. For example, a text shape behaves like a text graphic until the user begins editing it—and only then can the user use their keyboard to edit the text. Note that a shape can be interactive regardless of whether it's the editor's editing shape—the "editing" mechanic is just a way of managing a common pattern in canvas applications.

In this example we'll create a shape that renders an emoji and allows the user to change the emoji when the shape is in the editing state.
Most of the relevant code for this is in the EditableShapeUtil.tsx file. If you want a more in-depth explanation of the shape util, check out the custom shape example.

### App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import { EditableShapeUtil } from './EditableShapeUtil'

const customShapeUtils = [EditableShapeUtil]

export default function EditableShapeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// Pass in the array of custom shape classes
				shapeUtils={customShapeUtils}
				// Create a shape when the editor mounts
				onMount={(editor) => {
					editor.createShape({ type: 'my-editable-shape', x: 100, y: 100 })
				}}
			/>
		</div>
	)
}

/*
Introduction:

In Tldraw shapes can exist in an editing state. When shapes are in the editing state
they are focused and can't be dragged, resized or rotated. Shapes enter this state 
when they are double-clicked. In our default shapes we mostly use this for editing text. 
In this example we'll create a shape that renders an emoji and allows the user to change 
the emoji when the shape is in the editing state.

Most of the relevant code for this is in the EditableShapeUtil.tsx file. If you want a more
in-depth explanation of the shape util, check out the custom shape example.


 */
```
### EditableShapeUtil.tsx

```tsx
import {
	BaseBoxShapeUtil,
	HTMLContainer,
	RecordProps,
	T,
	TLBaseShape,
	stopEventPropagation,
} from 'tldraw'

// There's a guide at the bottom of this file!

const ANIMAL_EMOJIS = ['🐶', '🐱', '🐨', '🐮', '🐴']

type IMyEditableShape = TLBaseShape<
	'my-editable-shape',
	{
		w: number
		h: number
		animal: number
	}
>

export class EditableShapeUtil extends BaseBoxShapeUtil<IMyEditableShape> {
	static override type = 'my-editable-shape' as const
	static override props: RecordProps<IMyEditableShape> = {
		w: T.number,
		h: T.number,
		animal: T.number,
	}

	// [1] !!!
	override canEdit() {
		return true
	}

	getDefaultProps(): IMyEditableShape['props'] {
		return {
			w: 200,
			h: 200,
			animal: 0,
		}
	}

	// [2]
	component(shape: IMyEditableShape) {
		// [a]
		const isEditing = this.editor.getEditingShapeId() === shape.id

		return (
			<HTMLContainer
				id={shape.id}
				// [b]
				onPointerDown={isEditing ? stopEventPropagation : undefined}
				style={{
					pointerEvents: isEditing ? 'all' : 'none',
					backgroundColor: '#efefef',
					fontSize: 24,
					padding: 16,
				}}
			>
				{ANIMAL_EMOJIS[shape.props.animal]}
				{/* [c] */}
				{isEditing ? (
					<button
						onClick={() => {
							this.editor.updateShape({
								id: shape.id,
								type: shape.type,
								props: {
									...shape.props,
									animal: (shape.props.animal + 1) % ANIMAL_EMOJIS.length,
								},
							})
						}}
					>
						Next
					</button>
				) : (
					// [d] when not editing...
					<p style={{ fontSize: 12 }}>Double Click to Edit</p>
				)}
			</HTMLContainer>
		)
	}

	indicator(shape: IMyEditableShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}

	// [3]
	override onEditEnd(shape: IMyEditableShape) {
		this.editor.animateShape(
			{ ...shape, rotation: shape.rotation + Math.PI * 2 },
			{ animation: { duration: 250 } }
		)
	}
}

/* 

This is our shape util, which defines how our shape renders and behaves. For 
more information on the shape util, check out the custom shape example.

[1]
We override the canEdit method to allow the shape to enter the editing state.

[2]
We want to conditionally render the component based on whether it is being 
edited or not.

	[a] We can check whether our shape is being edited by comparing the
		editing shape id to the shape's id.
	
	[b] We want to allow pointer events when the shape is being edited,
		and stop event propagation on pointer down. Check out the interactive
		shape example for more information on this.

	[c] We render a button to change the animal emoji when the shape is being
		edited. 
		
	[e]	We also render a message when the shape is not being edited.

[3]
The onEditEnd method is called when the shape exits the editing state. In this
case we rotate the shape 360 degrees.

*/
```

## Tool with child states

Keywords: state machine, custom tool, state node, interactions

You can implement more complex behaviour in a custom tool by using child states

Tools are nodes in tldraw's state machine. They are responsible for handling user input. You can create custom tools by extending the StateNode class and overriding its methods. In this example we expand on the sticker tool from the custom tool example to show how to create a tool that can handle more complex interactions by using child states.

### App.tsx

```tsx
import {
	StateNode,
	TLClickEventInfo,
	TLPointerEventInfo,
	TLShapePartial,
	TLTextShape,
	Tldraw,
	createShapeId,
	toRichText,
} from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

const OFFSET = -12

// [1]
class StickerTool extends StateNode {
	static override id = 'sticker'
	static override initial = 'idle'
	static override children() {
		return [Idle, Pointing, Dragging]
	}
}

// [2]
class Idle extends StateNode {
	static override id = 'idle'
	//[a]
	override onEnter() {
		this.editor.setCursor({ type: 'cross' })
	}
	//[b]
	override onPointerDown(info: TLPointerEventInfo) {
		const { editor } = this
		switch (info.target) {
			case 'canvas': {
				const hitShape = editor.getShapeAtPoint(editor.inputs.currentPagePoint)
				if (hitShape) {
					this.onPointerDown({
						...info,
						shape: hitShape,
						target: 'shape',
					})
					return
				}
				this.parent.transition('pointing', { shape: null })
				break
			}
			case 'shape': {
				if (editor.inputs.shiftKey) {
					editor.updateShape<TLTextShape>({
						id: info.shape.id,
						type: 'text',
						props: { richText: toRichText('👻 boo!') },
					})
				} else {
					this.parent.transition('pointing', { shape: info.shape })
				}
				break
			}
		}
	}
	//[c]
	override onDoubleClick(info: TLClickEventInfo) {
		const { editor } = this
		if (info.phase !== 'up') return
		switch (info.target) {
			case 'canvas': {
				const hitShape = editor.getShapeAtPoint(editor.inputs.currentPagePoint)

				if (hitShape) {
					this.onDoubleClick({
						...info,
						shape: hitShape,
						target: 'shape',
					})
					return
				}
				const { currentPagePoint } = editor.inputs
				editor.createShape<TLTextShape>({
					type: 'text',
					x: currentPagePoint.x + OFFSET,
					y: currentPagePoint.y + OFFSET,
					props: { richText: toRichText('❤️') },
				})
				break
			}
			case 'shape': {
				editor.deleteShapes([info.shape.id])
				break
			}
		}
	}
}
// [3]
class Pointing extends StateNode {
	static override id = 'pointing'
	private shape: TLTextShape | null = null

	override onEnter(info: { shape: TLTextShape | null }) {
		this.shape = info.shape
	}
	override onPointerUp() {
		this.parent.transition('idle')
	}

	override onPointerMove() {
		if (this.editor.inputs.isDragging) {
			this.parent.transition('dragging', { shape: this.shape })
		}
	}
}

// [4]
class Dragging extends StateNode {
	static override id = 'dragging'
	// [a]
	private shape: TLShapePartial | null = null
	private emojiArray = ['❤️', '🔥', '👍', '👎', '😭', '🤣']

	// [b]
	override onEnter(info: { shape: TLShapePartial }) {
		const { currentPagePoint } = this.editor.inputs
		const newShape: TLShapePartial<TLTextShape> = {
			id: createShapeId(),
			type: 'text',
			x: currentPagePoint.x + OFFSET,
			y: currentPagePoint.y + OFFSET,
			props: { richText: toRichText('❤️') },
		}
		if (info.shape) {
			this.shape = info.shape
		} else {
			this.editor.createShape<TLTextShape>(newShape)
			this.shape = { ...newShape }
		}
	}
	//[c]
	override onPointerUp() {
		this.parent.transition('idle')
	}
	//[d]

	override onPointerMove() {
		const { shape } = this
		const { originPagePoint, currentPagePoint } = this.editor.inputs
		const distance = originPagePoint.dist(currentPagePoint)
		if (shape) {
			this.editor.updateShape<TLTextShape>({
				id: shape.id,
				type: 'text',
				props: {
					richText: toRichText(this.emojiArray[Math.floor(distance / 20) % this.emojiArray.length]),
				},
			})
		}
	}
}

// [5]
const customTools = [StickerTool]
export default function ToolWithChildStatesExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// Pass in the array of custom tool classes
				tools={customTools}
				// Set the initial state to the sticker tool
				initialState="sticker"
				// hide the ui
				hideUi
				// Put some helpful text on the canvas
				onMount={(editor) => {
					editor.createShape<TLTextShape>({
						type: 'text',
						x: 50,
						y: 50,
						props: {
							richText: toRichText(
								'-Double click the canvas to add a sticker\n-Double click a sticker to delete it\n-Click and drag on a sticker to change it\n-Click and drag on the canvas to create a sticker\n-Shift click a sticker for a surprise!'
							),
							size: 's',
							textAlign: 'start',
						},
					})
				}}
			/>
		</div>
	)
}

/* 
Introduction:

Tools are nodes in tldraw's state machine. They are responsible for handling user input. 
You can create custom tools by extending the `StateNode` class and overriding its 
methods. In this example we expand on the sticker tool from the custom tool example to 
show how to create a tool that can handle more complex interactions by using child states.

[1]
This is our custom tool. It has three child states: `Idle`, `Pointing`, and `Dragging`.
We need to define the `id` and `initial` properties, the id is a unique string that
identifies the tool to the editor, and the initial property is the initial state of the
tool. We also need to define a `children` method that returns an array of the tool's
child states.

[2]
This is our Idle state. It is the initial state of the tool. It's job is to figure out
what the user is trying to do and transition to the appropriate state. When transitioning 
between states we can use the second argument to pass data to the new state. It has three 
methods:

	[a] `onEnter` 
	When entering any state, the `onEnter` method is called. In this case, we set the cursor to 
	a crosshair.

	[b] `onPointerDown`
	This method is called when the user presses the mouse button. The target parameter is always
	the canvas, so we can use an editor method to check if we're over a shape, and call the 
	method again with the shape as the target. If we are over a shape, we transition to the
	`pointing` state with the shape in the info object. If we're over a shape and holding the 
	shift key, we update the shape's text. If we're over the canvas, we transition to the 
	`pointing` state with a null shape in the info object.
	
	[c] `onDoubleClick`
	This method is called when the user double clicks the mouse button. We're using some similar
	logic here to check if we're over a shape, and if we are, we delete it. If we're over the canvas,
	we create a new shape.

[3]
This is our `Pointing` state. It's a transitionary state, we use it to store the shape we're pointing
at, and transition to the dragging state if the user starts dragging. It has three methods:

	[a] `onEnter`
	When entering this state, we store the shape we're pointing at by getting it from the info object.

	[b] `onPointerUp`
	This method is called when the user releases the mouse button. We transition to the `idle` state.

	[c] `onPointerMove`
	This method is called when the user moves the mouse. If the user starts dragging, we transition to
	the `dragging` state and pass the shape we're pointing at.

[4]
This is our `Dragging` state. It's responsible for creating and updating the shape that the user is 
dragging.

	[a] `onEnter`
	When entering this state, we create a new shape if we're not dragging an existing one. If we are, 
	we store the shape we're dragging.

	[b] `onPointerUp`
	This method is called when the user releases the mouse button. We transition to the `idle` state.

	[c] `onPointerMove`
	This method is called when the user moves the mouse. We use the distance between the origin and 
	current mouse position to cycle through an array of emojis and update the shape's text.

[5]
We pass our custom tool to the `Tldraw` component as an array. We also set the initial state to our
custom tool. For the purposes of this demo, we're also hiding the UI and adding some helpful text to
the canvas.
*/
```

## Using custom styles

Keywords: style panel, rating

Using the custom styles API with your custom shapes.

In the Using tldraw styles example, we showed how to use tldraw's default styles in your own shapes. This example shows how to create your own styles and use them in your own shapes.

### App.tsx

```tsx
import {
	BaseBoxShapeUtil,
	DefaultStylePanel,
	DefaultStylePanelContent,
	HTMLContainer,
	StyleProp,
	T,
	TLBaseShape,
	Tldraw,
	useEditor,
	useRelevantStyles,
} from 'tldraw'
import 'tldraw/tldraw.css'

// [1]
const myRatingStyle = StyleProp.defineEnum('example:rating', {
	defaultValue: 1,
	values: [1, 2, 3, 4, 5],
})

// [2]
type MyRatingStyle = T.TypeOf<typeof myRatingStyle>

type IMyShape = TLBaseShape<
	'myshape',
	{
		w: number
		h: number
		rating: MyRatingStyle
	}
>

class MyShapeUtil extends BaseBoxShapeUtil<IMyShape> {
	static override type = 'myshape' as const

	// [3]
	static override props = {
		w: T.number,
		h: T.number,
		rating: myRatingStyle,
	}

	getDefaultProps(): IMyShape['props'] {
		return {
			w: 300,
			h: 300,
			rating: 4, // [4]
		}
	}

	component(shape: IMyShape) {
		// [5]
		const stars = ['☆', '☆', '☆', '☆', '☆']
		for (let i = 0; i < shape.props.rating; i++) {
			stars[i] = '★'
		}

		return (
			<HTMLContainer
				id={shape.id}
				style={{ backgroundColor: 'var(--color-low-border)', overflow: 'hidden' }}
			>
				{stars}
			</HTMLContainer>
		)
	}

	indicator(shape: IMyShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}

// [6]
function CustomStylePanel() {
	const editor = useEditor()
	const styles = useRelevantStyles()
	if (!styles) return null

	const rating = styles.get(myRatingStyle)

	return (
		<DefaultStylePanel>
			<DefaultStylePanelContent styles={styles} />
			{rating !== undefined && (
				<div>
					<select
						style={{ width: '100%', padding: 4 }}
						value={rating.type === 'mixed' ? '' : rating.value}
						onChange={(e) => {
							editor.markHistoryStoppingPoint()
							const value = myRatingStyle.validate(+e.currentTarget.value)
							editor.setStyleForSelectedShapes(myRatingStyle, value)
						}}
					>
						{rating.type === 'mixed' ? <option value="">Mixed</option> : null}
						<option value={1}>1</option>
						<option value={2}>2</option>
						<option value={3}>3</option>
						<option value={4}>4</option>
						<option value={5}>5</option>
					</select>
				</div>
			)}
		</DefaultStylePanel>
	)
}

export default function ShapeWithTldrawStylesExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// [7]
				shapeUtils={[MyShapeUtil]}
				components={{
					StylePanel: CustomStylePanel,
				}}
				onMount={(editor) => {
					editor.createShape({ type: 'myshape', x: 100, y: 100 })
					editor.selectAll()
					editor.createShape({ type: 'myshape', x: 450, y: 250, props: { rating: 5 } })
				}}
			/>
		</div>
	)
}

/* 

This file shows a custom shape that uses a user-created styles 

For more on custom shapes, see our Custom Shape example.

[1]
In this example, our custom shape will use a new style called "rating".
We'll need to create the style so that we can pass it to the shape's props.

[2]
Here's we extract the type of the style's values. We use it below when
we define the shape's props.

[3]
We pass the style to the shape's props.

[4]
Since this property uses one a style, whatever value we put here in the
shape's default props will be overwritten by the editor's current value 
for that style, which will either be the default value or the most 
recent value the user has set. This is special behavior just for styles.

[5]
We can use the styles in the component just like any other prop.

[6]
Here we create a custom style panel that includes the default style panel
and also a dropdown for the rating style. We use the useRelevantStyles hook
to get the styles of the user's selected shapes, and the useEditor hook to
set the style for the selected shapes. For more on customizing the style
panel, see our custom style panel example.

[7]
We pass the custom shape util and custom components in as props.

[8]
And for this example, we create two shapes: the first does not specify a
rating, so it will use the editor's current style value (in this example,
this will be the style's default value of 4). The second specifies a 
rating of 5, so it will use that value.
*/
```

## Bounds Snapping Shape

Keywords: geometry, custom

Custom shapes with special bounds snapping behaviour.

This example shows how to create a shape with custom snapping geometry. When shapes are moved around in snap mode, they will snap to the bounds of other shapes by default. However a shape can return custom snapping geometry to snap to instead. This example creates a playing card shape. The cards are designed to snap together so that the top-left icon remains visible when stacked, similar to a hand of cards in a game.The most relevant code for this customisation is in playing-card-util.tsx.

### App.tsx

```tsx
import { Editor, TLStoreSnapshot, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import { PlayingCardTool } from './PlayingCardShape/playing-card-tool'
import { PlayingCardUtil } from './PlayingCardShape/playing-card-util'
import snapshot from './snapshot.json'
import { components, uiOverrides } from './ui-overrides'
// There's a guide at the bottom of this file!

// [1]
const customShapes = [PlayingCardUtil]
const customTools = [PlayingCardTool]

export default function BoundsSnappingShapeExample() {
	// [2]
	const handleMount = (editor: Editor) => {
		editor.user.updateUserPreferences({ isSnapMode: true })
	}
	// [3]
	return (
		<div className="tldraw__editor">
			<Tldraw
				//[a]
				shapeUtils={customShapes}
				tools={customTools}
				// [b]
				overrides={uiOverrides}
				components={components}
				// [c]
				onMount={handleMount}
				// [d]
				snapshot={snapshot as TLStoreSnapshot}
			/>
		</div>
	)
}

/*
Introduction:

This example shows how to create a shape with custom snapping geometry.
When shapes are moved around in snap mode, they will snap to the bounds
of other shapes by default. However a shape can return custom snapping
geometry to snap to instead. This example creates a playing card shape.
The cards are designed to snap together so that the top-left icon
remains visible when stacked, similar to a hand of cards in a game.
The most relevant code for this customisation is in playing-card-util.tsx.

[1]
We define the custom shape and util arrays we'll pass to the Tldraw component.
It's important to do this outside of the component so that the arrays don't
change on every render.


This is where we define the Tldraw component and pass in all our customisations.

[2]
We define a handleMount function that will be called when the editor mounts.
We're using it to set the snap mode to true in the user preferences. This is
just to help demonstrate the custom snapping geometry feature. Without snap
mode being set in this way the user can still enter it by holding cmd/ctrl
while dragging.

[3]
This is where we're passing in all our customisations to the Tldraw component.
Check out the associated files for more information on what's being passed in.

	[a] Firstly our custom shape (playing-card-util.tsx) and tool (playing-card-tool.tsx)
		This tells the editor about our custom shape and tool.
	[b] Then our the uiOverrides and custom keyboard shortcuts component (ui-overrides.tsx),
		this makes sure that an icon for our tool appears in the toolbar and the shortcut
		for it appears in the dialog.
	[c] We pass in our handleMount function so that it's called when the editor mounts.

	[d] Finally we pass in a snapshot so that the editor starts with some shapes in it.
		This isn't necessary, it just makes the example clearer on first glance.
*/
```
### snapshot.json

```json
{
	"store": {
		"document:document": {
			"gridSize": 10,
			"name": "",
			"meta": {},
			"id": "document:document",
			"typeName": "document"
		},
		"page:page": {
			"meta": {},
			"id": "page:page",
			"name": "Page 1",
			"index": "a1",
			"typeName": "page"
		},
		"shape:lO3gDT8toaxNdM8RZyKqm": {
			"x": 436.99609375,
			"y": 317.43359375,
			"rotation": 0,
			"isLocked": false,
			"opacity": 1,
			"meta": {},
			"id": "shape:lO3gDT8toaxNdM8RZyKqm",
			"type": "PlayingCard",
			"parentId": "page:page",
			"index": "a1",
			"props": {
				"w": 270,
				"h": 370,
				"suit": "♠️"
			},
			"typeName": "shape"
		},
		"shape:db5wxGPcC0KNtdDMrSimx": {
			"x": 519.2183159722222,
			"y": 317.43359375,
			"rotation": 0,
			"isLocked": false,
			"opacity": 1,
			"meta": {},
			"id": "shape:db5wxGPcC0KNtdDMrSimx",
			"type": "PlayingCard",
			"parentId": "page:page",
			"index": "a2",
			"props": {
				"w": 270,
				"h": 370,
				"suit": "♣️"
			},
			"typeName": "shape"
		}
	},
	"schema": {
		"schemaVersion": 1,
		"storeVersion": 4,
		"recordVersions": {
			"asset": {
				"version": 1,
				"subTypeKey": "type",
				"subTypeVersions": {
					"image": 3,
					"video": 3,
					"bookmark": 1
				}
			},
			"camera": {
				"version": 1
			},
			"document": {
				"version": 2
			},
			"instance": {
				"version": 24
			},
			"instance_page_state": {
				"version": 5
			},
			"page": {
				"version": 1
			},
			"shape": {
				"version": 3,
				"subTypeKey": "type",
				"subTypeVersions": {
					"group": 0,
					"text": 1,
					"bookmark": 2,
					"draw": 1,
					"geo": 8,
					"note": 5,
					"line": 3,
					"frame": 0,
					"arrow": 3,
					"highlight": 0,
					"embed": 4,
					"image": 3,
					"video": 2,
					"PlayingCard": 0
				}
			},
			"instance_presence": {
				"version": 5
			},
			"pointer": {
				"version": 1
			}
		}
	}
}
```
### ui-overrides.tsx

```tsx
import {
	DefaultKeyboardShortcutsDialog,
	DefaultKeyboardShortcutsDialogContent,
	DefaultToolbar,
	DefaultToolbarContent,
	TLComponents,
	TLUiOverrides,
	TldrawUiMenuItem,
	useIsToolSelected,
	useTools,
} from 'tldraw'

// There's a guide at the bottom of this file!

export const uiOverrides: TLUiOverrides = {
	tools(editor, tools) {
		// Create a tool item in the ui's context.
		tools.PlayingCard = {
			id: 'PlayingCard',
			icon: 'color',
			label: 'PlayingCard',
			kbd: 'c',
			onSelect: () => {
				editor.setCurrentTool('PlayingCard')
			},
		}
		return tools
	},
}

export const components: TLComponents = {
	Toolbar: (props) => {
		const tools = useTools()
		const isCardSelected = useIsToolSelected(tools['PlayingCard'])
		return (
			<DefaultToolbar {...props}>
				<TldrawUiMenuItem {...tools['PlayingCard']} isSelected={isCardSelected} />
				<DefaultToolbarContent />
			</DefaultToolbar>
		)
	},
	KeyboardShortcutsDialog: (props) => {
		const tools = useTools()
		return (
			<DefaultKeyboardShortcutsDialog {...props}>
				<TldrawUiMenuItem {...tools['PlayingCard']} />
				<DefaultKeyboardShortcutsDialogContent />
			</DefaultKeyboardShortcutsDialog>
		)
	},
}

/* 

This file contains overrides for the Tldraw UI. These overrides are used to add your custom tools to
the toolbar and the keyboard shortcuts menu.

First we have to add our new tool to the tools object in the tools override. This is where we define
all the basic information about our new tool - its icon, label, keyboard shortcut, what happens when
we select it, etc.

Then, we replace the UI components for the toolbar and keyboard shortcut dialog with our own, that
add our new tool to the existing default content. Ideally, we'd interleave our new tool into the
ideal place among the default tools, but for now we're just adding it at the start to keep things
simple.
*/
```
### playing-card-tool.tsx

```tsx
import { BaseBoxShapeTool } from 'tldraw'
export class PlayingCardTool extends BaseBoxShapeTool {
	static override id = 'PlayingCard'
	static override initial = 'idle'
	override shapeType = 'PlayingCard'
}

/*
This file contains our custom tool. The tool is a StateNode with the `id` "PlayingCard".

We get a lot of functionality for free by extending the BaseBoxShapeTool. but we can
handle events in our own way by overriding methods like onDoubleClick. For an example 
of a tool with more custom functionality, check out the screenshot-tool example. 

*/
```
### playing-card-util.tsx

```tsx
import {
	BaseBoxShapeUtil,
	BoundsSnapGeometry,
	HTMLContainer,
	RecordProps,
	Rectangle2d,
	T,
	TLBaseShape,
} from 'tldraw'

// There's a guide at the bottom of this file!

// [1]
type IPlayingCard = TLBaseShape<
	'PlayingCard',
	{
		w: number
		h: number
		suit: string
	}
>

export class PlayingCardUtil extends BaseBoxShapeUtil<IPlayingCard> {
	// [2]
	static override type = 'PlayingCard' as const
	static override props: RecordProps<IPlayingCard> = {
		w: T.number,
		h: T.number,
		suit: T.string,
	}

	// [3]
	override isAspectRatioLocked(_shape: IPlayingCard) {
		return true
	}

	// [4]
	getDefaultProps(): IPlayingCard['props'] {
		const cardSuitsArray: string[] = ['♠️', '♣️', '♥️', '♦️']
		const randomSuit = cardSuitsArray[Math.floor(Math.random() * cardSuitsArray.length)]
		return {
			w: 270,
			h: 370,
			suit: randomSuit,
		}
	}

	// [5]
	override getBoundsSnapGeometry(shape: IPlayingCard): BoundsSnapGeometry {
		return new Rectangle2d({
			width: shape.props.h / 4.5,
			height: shape.props.h / 4.5,
			isFilled: true,
		})
	}

	// [7]
	component(shape: IPlayingCard) {
		return (
			<HTMLContainer
				style={{
					height: shape.props.h,
					width: shape.props.w,
					backgroundColor: 'white',
					boxShadow: '0 0 10px 0 rgba(0, 0, 0, 0.2)',
					position: 'relative',
					display: 'flex',
					justifyContent: 'center',
					alignItems: 'center',
					padding: 8,
				}}
				id={shape.id}
			>
				<span
					style={{
						position: 'absolute',
						top: 0,
						left: 0,
						display: 'flex',
						justifyContent: 'center',
						alignItems: 'center',
						height: shape.props.h / 4.5,
						width: shape.props.h / 4.5,
						fontSize: shape.props.h / 5,
					}}
				>
					{shape.props.suit}
				</span>
				<div style={{ fontSize: shape.props.h / 3 }}>{shape.props.suit}</div>
			</HTMLContainer>
		)
	}

	// [7]
	indicator(shape: IPlayingCard) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}

/* 
This is a utility class for the PlayingCard shape. This is where you define the shape's behavior, 
how it renders (its component and indicator), and how it handles different events. The most relevant
part of the code to custom snapping can be found in [6].

[1]
This is where we define the shape's type for Typescript. We can extend the TLBaseShape type,
providing a unique string to identify the shape and the shape's props. We only need height
and width for this shape.

[2]
We define the shape's type and props for the editor. We can use tldraw's validator library to
make sure that the store always has shape data we can trust. In this case, we define the width 
and height properties as numbers and assign a validator from tldraw's library to them.

[3]
We're going to lock the aspect ratio of this shape.

[4]
getDefaultProps determines what our shape looks like when click-creating one. In this case, we
want the shape to be 270x370 pixels and generate a suit for the card at random.

[5]
This is the important part for custom snapping. We define the getBoundsSnapGeometry method. This
method returns the geometry that the shape will snap to. In this case, we want the shape to snap
to a rectangle in the top left that contains the suit of the card. We can use the Rectangle2d helper
again here and set it to the same width and height as the span containing the suit which is defined
in [6].

[6]
We define the component method. This controls what the shape looks like and it returns JSX. It
generates a random suit for the card and returns a div with the suit in the center and a span with
the suit in the top left. The HTMLContainer component is a helpful wrapper that the tldraw library
exports, it's a div that comes with a css class.

[7]
The indicator is the blue box that appears around the shape when it's selected. We're just returning
a rectangle with the same width and height as the shape here.


*/
```

## Custom shape and tool

Keywords: toolbar, migrations, icon, util, ui overrides, card shape

Create custom shapes / tools

The card shape (select ⚫️ in the toolbar) is a custom shape - but also just a normal react component.

### App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import { CardShapeTool } from './CardShape/CardShapeTool'
import { CardShapeUtil } from './CardShape/CardShapeUtil'
import { components, uiOverrides } from './ui-overrides'

// There's a guide at the bottom of this file!

// [1]
const customShapeUtils = [CardShapeUtil]
const customTools = [CardShapeTool]

// [2]
export default function CustomConfigExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// Pass in the array of custom shape classes
				shapeUtils={customShapeUtils}
				// Pass in the array of custom tool classes
				tools={customTools}
				// Pass in any overrides to the user interface
				overrides={uiOverrides}
				// Pass in the new Keybaord Shortcuts component
				components={components}
			/>
		</div>
	)
}

/* 
Introduction:

This example shows how to create a custom shape, and add your own icon for it to the toolbar.
Check out CardShapeUtil.tsx and CardShapeTool.tsx to see how we define the shape util and tool. 
Check out ui-overrides.ts for more info on how to add your icon to the toolbar.

[1] 
We define an array to hold the custom shape util and custom tool. It's important to do this outside of
any React component so that this array doesn't get redefined on every render.

[2]
Now we'll pass these arrays into the Tldraw component's props, along with our ui overrides.


*/
```
### ui-overrides.tsx

```tsx
import {
	DefaultKeyboardShortcutsDialog,
	DefaultKeyboardShortcutsDialogContent,
	DefaultToolbar,
	DefaultToolbarContent,
	TLComponents,
	TLUiOverrides,
	TldrawUiMenuItem,
	useIsToolSelected,
	useTools,
} from 'tldraw'

// There's a guide at the bottom of this file!

export const uiOverrides: TLUiOverrides = {
	tools(editor, tools) {
		// Create a tool item in the ui's context.
		tools.card = {
			id: 'card',
			icon: 'color',
			label: 'Card',
			kbd: 'c',
			onSelect: () => {
				editor.setCurrentTool('card')
			},
		}
		return tools
	},
}

export const components: TLComponents = {
	Toolbar: (props) => {
		const tools = useTools()
		const isCardSelected = useIsToolSelected(tools['card'])
		return (
			<DefaultToolbar {...props}>
				<TldrawUiMenuItem {...tools['card']} isSelected={isCardSelected} />
				<DefaultToolbarContent />
			</DefaultToolbar>
		)
	},
	KeyboardShortcutsDialog: (props) => {
		const tools = useTools()
		return (
			<DefaultKeyboardShortcutsDialog {...props}>
				<TldrawUiMenuItem {...tools['card']} />
				<DefaultKeyboardShortcutsDialogContent />
			</DefaultKeyboardShortcutsDialog>
		)
	},
}

/* 

This file contains overrides for the Tldraw UI. These overrides are used to add your custom tools to
the toolbar and the keyboard shortcuts menu.

First we have to add our new tool to the tools object in the tools override. This is where we define
all the basic information about our new tool - its icon, label, keyboard shortcut, what happens when
we select it, etc.

Then, we replace the UI components for the toolbar and keyboard shortcut dialog with our own, that
add our new tool to the existing default content. Ideally, we'd interleave our new tool into the
ideal place among the default tools, but for now we're just adding it at the start to keep things
simple.
*/
```
### CardShapeTool.tsx

```tsx
import { BaseBoxShapeTool, TLClickEventInfo } from 'tldraw'
export class CardShapeTool extends BaseBoxShapeTool {
	static override id = 'card'
	static override initial = 'idle'
	override shapeType = 'card'

	override onDoubleClick(_info: TLClickEventInfo) {
		// you can handle events in handlers like this one;
		// check the BaseBoxShapeTool source as an example
	}
}

/*
This file contains our custom tool. The tool is a StateNode with the `id` "card".

We get a lot of functionality for free by extending the BaseBoxShapeTool. but we can
handle events in out own way by overriding methods like onDoubleClick. For an example 
of a tool with more custom functionality, check out the screenshot-tool example. 

*/
```
### CardShapeUtil.tsx

```tsx
import { useState } from 'react'
import {
	HTMLContainer,
	Rectangle2d,
	ShapeUtil,
	TLResizeInfo,
	getDefaultColorTheme,
	resizeBox,
} from 'tldraw'
import { cardShapeMigrations } from './card-shape-migrations'
import { cardShapeProps } from './card-shape-props'
import { ICardShape } from './card-shape-types'

// There's a guide at the bottom of this file!

export class CardShapeUtil extends ShapeUtil<ICardShape> {
	static override type = 'card' as const
	// [1]
	static override props = cardShapeProps
	// [2]
	static override migrations = cardShapeMigrations

	// [3]
	override isAspectRatioLocked(_shape: ICardShape) {
		return false
	}
	override canResize(_shape: ICardShape) {
		return true
	}

	// [4]
	getDefaultProps(): ICardShape['props'] {
		return {
			w: 300,
			h: 300,
			color: 'black',
		}
	}

	// [5]
	getGeometry(shape: ICardShape) {
		return new Rectangle2d({
			width: shape.props.w,
			height: shape.props.h,
			isFilled: true,
		})
	}

	// [6]
	component(shape: ICardShape) {
		const bounds = this.editor.getShapeGeometry(shape).bounds
		const theme = getDefaultColorTheme({ isDarkMode: this.editor.user.getIsDarkMode() })

		//[a]
		// eslint-disable-next-line react-hooks/rules-of-hooks
		const [count, setCount] = useState(0)

		return (
			<HTMLContainer
				id={shape.id}
				style={{
					border: '1px solid black',
					display: 'flex',
					flexDirection: 'column',
					alignItems: 'center',
					justifyContent: 'center',
					pointerEvents: 'all',
					backgroundColor: theme[shape.props.color].semi,
					color: theme[shape.props.color].solid,
				}}
			>
				<h2>Clicks: {count}</h2>
				<button
					// [b]
					onClick={() => setCount((count) => count + 1)}
					onPointerDown={(e) => e.stopPropagation()}
				>
					{bounds.w.toFixed()}x{bounds.h.toFixed()}
				</button>
			</HTMLContainer>
		)
	}

	// [7]
	indicator(shape: ICardShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}

	// [8]
	override onResize(shape: ICardShape, info: TLResizeInfo<ICardShape>) {
		return resizeBox(shape, info)
	}
}
/* 
A utility class for the card shape. This is where you define the shape's behavior, 
how it renders (its component and indicator), and how it handles different events.

[1]
A validation schema for the shape's props (optional)
Check out card-shape-props.ts for more info.

[2]
Migrations for upgrading shapes (optional)
Check out card-shape-migrations.ts for more info.

[3]
Letting the editor know if the shape's aspect ratio is locked, and whether it 
can be resized or bound to other shapes. 

[4]
The default props the shape will be rendered with when click-creating one.

[5]
We use this to calculate the shape's geometry for hit-testing, bindings and
doing other geometric calculations. 

[6]
Render method — the React component that will be rendered for the shape. It takes the 
shape as an argument. HTMLContainer is just a div that's being used to wrap our text 
and button. We can get the shape's bounds using our own getGeometry method.
	
- [a] Check it out! We can do normal React stuff here like using setState.
   Annoying: eslint sometimes thinks this is a class component, but it's not.

- [b] You need to stop the pointer down event on buttons, otherwise the editor will
	   think you're trying to select drag the shape.

[7]
Indicator — used when hovering over a shape or when it's selected; must return only SVG elements here

[8]
Resize handler — called when the shape is resized. Sometimes you'll want to do some 
custom logic here, but for our purposes, this is fine.
*/
```
### card-shape-migrations.ts

```ts
import { createShapePropsMigrationIds, createShapePropsMigrationSequence } from 'tldraw'

const versions = createShapePropsMigrationIds(
	// this must match the shape type in the shape definition
	'card',
	{
		AddSomeProperty: 1,
	}
)

// Migrations for the custom card shape (optional but very helpful)
export const cardShapeMigrations = createShapePropsMigrationSequence({
	sequence: [
		{
			id: versions.AddSomeProperty,
			up(props) {
				// it is safe to mutate the props object here
				props.someProperty = 'some value'
			},
			down(props) {
				delete props.someProperty
			},
		},
	],
})
```
### card-shape-props.ts

```ts
import { DefaultColorStyle, RecordProps, T } from 'tldraw'
import { ICardShape } from './card-shape-types'

// Validation for our custom card shape's props, using one of tldraw's default styles
export const cardShapeProps: RecordProps<ICardShape> = {
	w: T.number,
	h: T.number,
	color: DefaultColorStyle,
}

// To generate your own custom styles, check out the custom styles example.
```
### card-shape-types.ts

```ts
import { TLBaseShape, TLDefaultColorStyle } from 'tldraw'

// A type for our custom card shape
export type ICardShape = TLBaseShape<
	'card',
	{
		w: number
		h: number
		color: TLDefaultColorStyle
	}
>
```

## Shape toSvg method

Keywords: basic, svg, custom, export, copy

How to use the toSvg method of a shape util to determine how your custom shapes look when copied/exported as an image.

The "export as SVG/PNG" and "copy as SVG/PNG" actions use the `toSvg` or `toBackgroundSvg` methods of a shape util. If a shape does not have a `toSvg` or `toBackgroundSvg` method defined, it will default to an empty box.

### App.tsx

```tsx
import { ReactElement } from 'react'
import {
	Geometry2d,
	HTMLContainer,
	RecordProps,
	Rectangle2d,
	ShapeUtil,
	SvgExportContext,
	T,
	TLBaseShape,
	Tldraw,
} from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

type ICustomShape = TLBaseShape<
	'my-custom-shape',
	{
		w: number
		h: number
	}
>

const LIGHT_FILL = '#ff8888'
const DARK_FILL = '#ffcccc'

export class MyShapeUtil extends ShapeUtil<ICustomShape> {
	static override type = 'my-custom-shape' as const
	static override props: RecordProps<ICustomShape> = {
		w: T.number,
		h: T.number,
	}

	getDefaultProps(): ICustomShape['props'] {
		return {
			w: 200,
			h: 200,
		}
	}

	override canEdit() {
		return false
	}
	override canResize() {
		return false
	}
	override isAspectRatioLocked() {
		return false
	}

	getGeometry(shape: ICustomShape): Geometry2d {
		return new Rectangle2d({
			width: shape.props.w,
			height: shape.props.h,
			isFilled: true,
		})
	}

	component(_shape: ICustomShape) {
		const isDarkmode = this.editor.user.getIsDarkMode()
		return <HTMLContainer style={{ backgroundColor: isDarkmode ? DARK_FILL : LIGHT_FILL }} />
	}

	indicator(shape: ICustomShape) {
		return this.getSvgRect(shape)
	}

	// [1]
	override toSvg(
		shape: ICustomShape,
		ctx: SvgExportContext
	): ReactElement | null | Promise<ReactElement | null> {
		// ctx.addExportDef(getFontDef(shape))
		const isDarkmode = ctx.isDarkMode
		const fill = isDarkmode ? DARK_FILL : LIGHT_FILL
		return this.getSvgRect(shape, { fill })
	}

	getSvgRect(shape: ICustomShape, props?: { fill: string }) {
		return <rect width={shape.props.w} height={shape.props.h} {...props} />
	}

	// [2]

	// override toBackgroundSvg(
	// 	shape: ICustomShape,
	// 	ctx: SvgExportContext
	// ): ReactElement | null | Promise<ReactElement | null> {
	// 	const isDarkmode = ctx.isDarkMode
	// 	const fill = isDarkmode ? '#333' : '#efefef'
	// 	return <rect width={shape.props.w} height={shape.props.h} fill={fill} />
	// }
}

// [3]

// function getFontDef(shape: ICustomShape): SvgExportDef {
// 	//
// 	return {
// 		some unique key,
// 		key: 'my-custom-shape-font',
// 		getElement: async () => {
// 			return <style></style> element
// 			check out the defaultStyleDefs.tsx file for an example of how
// 			we do this for tldraw fonts
// 		},
// 	}
// }

const customShape = [MyShapeUtil]
export default function CustomShapeToSvgExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				shapeUtils={customShape}
				onMount={(editor) => {
					editor.createShape({ type: 'my-custom-shape', x: 100, y: 100 })
				}}
			/>
		</div>
	)
}
/*
 The "export as SVG/PNG" and "copy as SVG/PNG" actions use the `toSvg` or `toBackgroundSvg`
 methods of a shape util. If a shape does not have a `toSvg` or `toBackgroundSvg` method
 defined, it will default to an empty box.

 For more information on creating a custom shape, check out the custom shape example.

 [1]
    This method should return a React element that represents the shape as an SVG element.
    If your shape is HTML, then you will need to convert it to an SVG representation. In this
    example we've used a `rect` element to represent the shape. Other shapes may require more
    complex work to render them as SVGs, especially if they contain text. Check out [3] for more
	info.

[2]
    The `toBackgroundSvg` method is used to render a layer behind the shape when exporting as SVG.
    We use this in the tldraw codebase to make the highlighter shape. It's commented out here as
    we don't need it for this example.

[3]
	If your shape contains text, you may need to add a font definition to the SVG. This is done
	using the `addExportDef` method of the `SvgExportContext`. Your font def must contain a unique
	key and a function that returns a React element. Check out the `` function
	in the `defaultStyleDefs.tsx` file for an example of how this is done for tldraw fonts.

 */
```

## Shape with geometry

Keywords: svg, path, house, door

This file demonstrates how to create a shape with custom geometry in tldraw. The
shape we're creating is a simple house shape with a door.



### App.tsx

```tsx
import {
	Group2d,
	Polygon2d,
	RecordPropsType,
	Rectangle2d,
	ShapeUtil,
	T,
	TLBaseShape,
	TLResizeInfo,
	Tldraw,
	Vec,
	resizeBox,
	structuredClone,
} from 'tldraw'
import 'tldraw/tldraw.css'

const houseShapeProps = {
	w: T.number,
	h: T.number,
}

type HouseShapeProps = RecordPropsType<typeof houseShapeProps>
type HouseShape = TLBaseShape<'house', HouseShapeProps>
class HouseShapeUtil extends ShapeUtil<HouseShape> {
	static override type = 'house' as const
	static override props = houseShapeProps

	override canResize() {
		return true
	}
	override getDefaultProps() {
		return {
			w: 100,
			h: 100,
		}
	}
	//[1]
	override getGeometry(shape: HouseShape) {
		const { house: houseGeometry } = getHouseVertices(shape)
		const house = new Polygon2d({
			points: houseGeometry,
			isFilled: true,
		})
		const door = new Rectangle2d({
			x: shape.props.w / 2 - shape.props.w / 10,
			y: shape.props.h - shape.props.h / 4,
			width: shape.props.w / 5,
			height: shape.props.h / 4,
			isFilled: true,
		})
		const geometry = new Group2d({
			children: [house, door],
		})
		return geometry
	}
	// [2]
	override component(shape: HouseShape) {
		const { house: houseVertices, door: doorVertices } = getHouseVertices(shape)
		const housePathData = 'M' + houseVertices[0] + 'L' + houseVertices.slice(1) + 'Z'
		const doorPathData = 'M' + doorVertices[0] + 'L' + doorVertices.slice(1) + 'Z'
		return (
			<svg className="tl-svg-container">
				<path strokeWidth={3} stroke="black" d={housePathData + doorPathData} fill="none" />
			</svg>
		)
	}
	// [3]
	override indicator(shape: HouseShape) {
		const { house: houseVertices, door: doorVertices } = getHouseVertices(shape)
		const housePathData = 'M' + houseVertices[0] + 'L' + houseVertices.slice(1) + 'Z'
		const doorPathData = 'M' + doorVertices[0] + 'L' + doorVertices.slice(1) + 'Z'
		return <path d={housePathData + doorPathData} />
	}
	override onResize(shape: HouseShape, info: TLResizeInfo<HouseShape>) {
		const resized = resizeBox(shape, info)
		const next = structuredClone(info.initialShape)
		next.x = resized.x
		next.y = resized.y
		next.props.w = resized.props.w
		next.props.h = resized.props.h
		return next
	}
}
// [4]
function getHouseVertices(shape: HouseShape): { house: Vec[]; door: Vec[] } {
	const { w, h } = shape.props
	const halfW = w / 2
	const roofStart = h / 2.5
	const house = [
		new Vec(0, roofStart), // Roof start (left)
		new Vec(w, roofStart), // Roof start (right)
		new Vec(w, h), // Bottom-right corner
		new Vec(0, h), // Bottom-left corner
		new Vec(0, roofStart), // Roof start (left)
		new Vec(halfW, 0), // Roof peak
		new Vec(w, roofStart), // Roof start (right)
	]
	const door = [
		new Vec(halfW - w / 10, h), // Bottom-left corner
		new Vec(halfW + w / 10, h), // Bottom-right corner
		new Vec(halfW + w / 10, h - h / 4), // Top-right corner
		new Vec(halfW - w / 10, h - h / 4), // Top-left corner
		new Vec(halfW - w / 10, h), // Bottom-left corner
	]
	return { house, door }
}

const shapeUtils = [HouseShapeUtil]

export default function ShapeWithGeometryExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					editor.createShape({
						type: 'house',
						x: 100,
						y: 100,
						props: {
							w: 100,
							h: 100,
						},
					})
				}}
				shapeUtils={shapeUtils}
			/>
		</div>
	)
}

/*
Introduction:
This file demonstrates how to create a shape with custom geometry in tldraw. The 
shape we're creating is a simple house shape with a door. The HouseShapeUtil class 
defines the behavior and appearance of our custom house shape.

[1]
The getGeometry method defines the geometric representation of our shape. This geometry
is used for hit-testing, intersection checking and other geometric calculations. We use 
Polygon2d for the house body and Rectangle2d for the door. These are combined into a 
Group2d to form the complete house geometry.

[2]
The component method determines how our shape is rendered. We create SVG paths for 
both the house body and the door, combining them into a single path element. This 
method is called when the shape needs to be drawn on the canvas. The tl-svg-container
class contains some helpful styles for rendering the svg correctly.

[3]
The indicator method renders the same path as a thin blue line when the shape is selected.

[4]
The getHouseVertices function calculates the vertices for both the house body and the door 
based on the shape's dimensions. This is used by both the geometry and rendering methods 
to ensure consistency in the shape's appearance.

*/
```

## Shape with migrations

Keywords: version, update

Migrate your shapes and their data between versions

Sometimes you'll want to update the way a shape works in your application. When this happens there can be a risk of errors and bugs. For example, users with an old version of a shape in their documents might encounter errors when the editor tries to access a property that doesn't exist. This example shows how you can use our migrations system to preserve your users' data between versions. It uses a snapshot to load a document with a shape that is missing a "color" prop, and uses the migrations method of the shape util to update it.

### App.tsx

```tsx
import {
	BaseBoxShapeUtil,
	HTMLContainer,
	T,
	TLBaseShape,
	TLResizeInfo,
	TLStoreSnapshot,
	Tldraw,
	createShapePropsMigrationIds,
	createShapePropsMigrationSequence,
	resizeBox,
} from 'tldraw'
import 'tldraw/tldraw.css'
import snapshot from './snapshot.json'

// There's a guide at the bottom of this file!

export type IMyShape = TLBaseShape<
	'myshape',
	{
		w: number
		h: number
		color: string
	}
>

// [1]
const versions = createShapePropsMigrationIds(
	// this must match the shape type in the shape definition
	'myshape',
	{
		AddColor: 1,
	}
)

// [2]
export const cardShapeMigrations = createShapePropsMigrationSequence({
	sequence: [
		{
			id: versions.AddColor,
			up(props) {
				// it is safe to mutate the props object here
				props.color = 'lightblue'
			},
			down(props) {
				delete props.color
			},
		},
	],
})

export class MigratedShapeUtil extends BaseBoxShapeUtil<IMyShape> {
	static override type = 'myshape' as const

	static override props = {
		w: T.number,
		h: T.number,
		color: T.string,
	}

	// [3]
	static override migrations = cardShapeMigrations

	getDefaultProps(): IMyShape['props'] {
		return {
			w: 300,
			h: 300,
			color: 'lightblue',
		}
	}

	component(shape: IMyShape) {
		return (
			<HTMLContainer
				id={shape.id}
				style={{
					backgroundColor: shape.props.color,
					boxShadow: '0 0 10px rgba(0,0,0,0.5)',
				}}
			></HTMLContainer>
		)
	}

	indicator(shape: IMyShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}

	override onResize(shape: IMyShape, info: TLResizeInfo<IMyShape>) {
		return resizeBox(shape, info)
	}
}

const customShapeUtils = [MigratedShapeUtil]

export default function ShapeWithMigrationsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// Pass in the array of custom shape classes
				shapeUtils={customShapeUtils}
				// Use a snapshot to load an old version of the shape
				snapshot={snapshot as TLStoreSnapshot}
			/>
		</div>
	)
}

/* 
Introduction:

Sometimes you'll want to update the way a shape works in your application without breaking older
versions of the shape that a user may have stored or persisted in memory. 

This example shows how you can use our migrations system to upgrade (or downgrade) user's data
between different versions. Most of the code above is general "custom shape" code—see our custom
shape example for more details.

[1] First, we need IDs for each migration. List each change with its version number. Once you've
added a migration, it should not change again.

[2] Next, we create a migration sequence. This is where we actually write our migration logic. Each
migration had three parts: an `id` (created in [1]), an `up` migration and `down` migration. In this
case, the `up` migration adds the `color` prop to the shape, and the `down` migration removes it.

In some cases (mainly in multiplayer sessions) a peer or server may need to take a later version of
a shape and migrate it down to an older version—in this case, it would run the down migrations in
order to get it to the needed version.

[3] Finally, we add our migrations to the ShapeUtil. This tells tldraw about the migrations so they
can be used with your shapes.

How it works:

Each time the editor's store creates a snapshot (`editor.store.createSnapshot`), it serializes all
of the records (the snapshot's `store`) as well as versions of each record that it contains (the
snapshot's `schema`). When the editor loads a snapshot, it compares its current schema with the
snapshot's schema to determine which migrations to apply to each record.

In this example, we have a snapshot (snapshot.json) that we created in version 0, however our shape
now has a 'color' prop that was added in version 1. 

The snapshot looks something like this:

```json{
{
    "store": {
        "shape:BqG5uIAa9ig2-ukfnxwBX": {
            ...,
            "props": {
                "w": 300,
                "h": 300
            },
        },
	},
	"schema": {
		...,
		"sequences": {
			...,
			"com.tldraw.shape.arrow": 4,
			"com.tldraw.shape.myshape": 0
		}
	}
}
```

Note that the shape in the snapshot doesn't have a 'color' prop. 

Note also that the schema's version for this shape is 0.

When the editor loads the snapshot, it will compare the serialized schema's version with its current
schema's version for the shape, which is 1 as defined in our shape's migrations. Since the
serialized version is older than its current version, it will use our migration to bring it up to
date: it will run the migration's `up` function, which will add the 'color' prop to the shape.
*/
```
### snapshot.json

```json
{
	"store": {
		"document:document": {
			"gridSize": 10,
			"name": "",
			"meta": {},
			"id": "document:document",
			"typeName": "document"
		},
		"page:page": {
			"meta": {},
			"id": "page:page",
			"name": "Page 1",
			"index": "a1",
			"typeName": "page"
		},
		"shape:BqG5uIAa9ig2-ukfnxwBX": {
			"x": 100,
			"y": 100,
			"rotation": 0,
			"isLocked": false,
			"opacity": 1,
			"meta": {},
			"id": "shape:BqG5uIAa9ig2-ukfnxwBX",
			"type": "myshape",
			"parentId": "page:page",
			"index": "a1",
			"props": {
				"w": 300,
				"h": 300
			},
			"typeName": "shape"
		}
	},
	"schema": {
		"schemaVersion": 1,
		"storeVersion": 4,
		"recordVersions": {
			"asset": {
				"version": 1,
				"subTypeKey": "type",
				"subTypeVersions": {
					"image": 3,
					"video": 3,
					"bookmark": 1
				}
			},
			"camera": {
				"version": 1
			},
			"document": {
				"version": 2
			},
			"instance": {
				"version": 24
			},
			"instance_page_state": {
				"version": 5
			},
			"page": {
				"version": 1
			},
			"shape": {
				"version": 3,
				"subTypeKey": "type",
				"subTypeVersions": {
					"group": 0,
					"text": 1,
					"bookmark": 2,
					"draw": 1,
					"geo": 8,
					"note": 5,
					"line": 4,
					"frame": 0,
					"arrow": 3,
					"highlight": 0,
					"embed": 4,
					"image": 3,
					"video": 2,
					"myshape": 0
				}
			},
			"instance_presence": {
				"version": 5
			},
			"pointer": {
				"version": 1
			}
		}
	}
}
```

## Asset props

Keywords: images, videos, gif, dimensions, accepted image types

Control the assets (images, videos, etc.) that can be added to the canvas.

This example demonstrates the `<Tldraw/>` component's props that give you control over assets: which types are allowed, the maximum size, and maximum dimensions.

### App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function AssetPropsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// only allow jpegs
				acceptedImageMimeTypes={['image/jpeg']}
				// don't allow any videos
				acceptedVideoMimeTypes={[]}
				// accept images of any dimension
				maxImageDimension={Infinity}
				// ...but only accept assets up to 1mb
				maxAssetSize={1 * 1024 * 1024}
			/>
		</div>
	)
}

/* 
This example shows how to use props on the Tldraw component to control what types of
assets can be uploaded.

*/
```

## Local Storage

Keywords: store, snapshot, debounce

Save the contents of the editor

In this example, we load the contents of the editor from your browser's localStorage, and save it there when you make changes.

### App.tsx

```tsx
import { throttle } from 'lodash'
import { useLayoutEffect, useMemo, useState } from 'react'
import { DefaultSpinner, Tldraw, createTLStore, getSnapshot, loadSnapshot } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

const PERSISTENCE_KEY = 'example-3'

export default function PersistenceExample() {
	//[1]
	const store = useMemo(() => createTLStore(), [])
	//[2]
	const [loadingState, setLoadingState] = useState<
		{ status: 'loading' } | { status: 'ready' } | { status: 'error'; error: string }
	>({
		status: 'loading',
	})
	//[3]
	useLayoutEffect(() => {
		setLoadingState({ status: 'loading' })

		// Get persisted data from local storage
		const persistedSnapshot = localStorage.getItem(PERSISTENCE_KEY)

		if (persistedSnapshot) {
			try {
				const snapshot = JSON.parse(persistedSnapshot)
				loadSnapshot(store, snapshot)
				setLoadingState({ status: 'ready' })
			} catch (error: any) {
				setLoadingState({ status: 'error', error: error.message }) // Something went wrong
			}
		} else {
			setLoadingState({ status: 'ready' }) // Nothing persisted, continue with the empty store
		}

		// Each time the store changes, run the (debounced) persist function
		const cleanupFn = store.listen(
			throttle(() => {
				const snapshot = getSnapshot(store)
				localStorage.setItem(PERSISTENCE_KEY, JSON.stringify(snapshot))
			}, 500)
		)

		return () => {
			cleanupFn()
		}
	}, [store])

	// [4]
	if (loadingState.status === 'loading') {
		return (
			<div className="tldraw__editor">
				<h2>
					<DefaultSpinner />
				</h2>
			</div>
		)
	}

	if (loadingState.status === 'error') {
		return (
			<div className="tldraw__editor">
				<h2>Error!</h2>
				<p>{loadingState.error}</p>
			</div>
		)
	}

	return (
		<div className="tldraw__editor">
			<Tldraw store={store} />
		</div>
	)
}

/*
This example shows how to implement persistence in the Tldraw component. We do
this by saving the editor's state to local storage each time it changes. You 
should replace this in your app with some sort of backend storage solution. If 
you just want to save to local storage, you can use the `persistenceKey` prop
instead. Simply pass any string to this prop and the editor will automatically 
save to local storage.

[1]
We create a new store using the `createTLStore` helper function. We pass in the 
default shape utils so that the store knows how to handle the built-in shapes. 

[2]
This is a cool pattern that uses Typescript to help keep track of our app's
loading state.

[3]
We use the `useLayoutEffect` hook to run our persistence code after the first
render. First we grab the persisted snapshot from local storage. If there is
one, we load it into the store and set the loading state to ready. If there
isn't one, we just set the loading state to ready.

Then we setup a listener on the store that will run our persistence code each
time the store changes. We use the `throttle` helper function to debounce the
listener so that it doesn't run too often. We also return a cleanup function
that will remove the listener when the component unmounts.

[4]
This is where we render our application depending on the loading state. If the
loading state is `loading`, we render a loading message. If the loading state
is `error`, we render an error message. If the loading state is `ready`, we
render the Tldraw component.
*/
```

## Export canvas as image

Keywords: basic, assets, svg, png, blob

Export the entire canvas as an image file

This example shows how you can use the `Editor.toImage()` function to create an image with all the shapes on the canvas in it and then download it. The easiest way to download an image is to use the download attribute of a link element.

### App.tsx

```tsx
import { Tldraw, TLUiComponents, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'

function ExportCanvasButton() {
	const editor = useEditor()
	return (
		<button
			style={{ pointerEvents: 'all', fontSize: 18, backgroundColor: 'thistle' }}
			onClick={async () => {
				const shapeIds = editor.getCurrentPageShapeIds()
				if (shapeIds.size === 0) return alert('No shapes on the canvas')
				const { blob } = await editor.toImage([...shapeIds], { format: 'png', background: false })

				const link = document.createElement('a')
				link.href = URL.createObjectURL(blob)
				link.download = 'every-shape-on-the-canvas.jpg'
				link.click()
				URL.revokeObjectURL(link.href)
			}}
		>
			Export canvas as image
		</button>
	)
}
const components: TLUiComponents = {
	SharePanel: ExportCanvasButton,
}
export default function ExportCanvasImageExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw components={components} />
		</div>
	)
}

/* 
This example shows how you can use the `Editor.toImage()` function to create an image with all the shapes 
on the canvas in it and then download it. The easiest way to download an image is to use the download 
attribute of a link element.

To learn more about overriding UI you can check out our various custom menu examples. For more on handling
assets, check out our Local/Hosted images examples.
*/
```

## Export canvas settings

Keywords: basic, assets, svg, png, blob, image, settings

Export the entire canvas as an image file

This example shows how you can use the `Editor.toImage()` function to create an image with all the shapes on the canvas in it and then download it. The easiest way to download an image is to use the download attribute of a link element.

### App.tsx

```tsx
import { useState } from 'react'
import { Box, Tldraw, TLImageExportOptions, TLUiComponents, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'

const components: TLUiComponents = {
	SharePanel: ExportCanvasButton,
}

export default function ExportCanvasImageExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw components={components} />
		</div>
	)
}

function ExportCanvasButton() {
	const editor = useEditor()

	// [1]
	const [opts, setOpts] = useState<TLImageExportOptions>({
		scale: 1,
		background: false,
		padding: editor.options.defaultSvgPadding,
	})

	// [2]
	const [box, setBox] = useState({ x: 0, y: 0, w: 0, h: 0 })

	return (
		<div
			style={{
				pointerEvents: 'all',
				border: '1px solid black',
				borderRadius: 5,
				padding: 12,
				position: 'absolute',
				display: 'flex',
				flexDirection: 'column',
				right: 164,
				top: 8,
			}}
		>
			<div
				style={{
					display: 'grid',
					gridTemplateColumns: '1fr auto',
					gridAutoFlow: 'row',
					rowGap: 4,
					columnGap: 16,
				}}
			>
				<Control
					type="checkbox"
					name="background"
					checked={opts.background}
					onChange={(e) => {
						setOpts({ ...opts, background: e.target.checked })
					}}
				/>
				<Control
					type="checkbox"
					name="darkmode"
					checked={opts.darkMode}
					onChange={(e) => {
						setOpts({ ...opts, darkMode: e.target.checked })
					}}
				/>
				<Control
					type="number"
					name="padding"
					value={opts.padding}
					onChange={(e) => {
						setOpts({ ...opts, padding: Math.ceil(Number(e.target.value)) })
					}}
				/>
				<Control
					type="number"
					name="scale"
					value={opts.scale}
					onChange={(e) => {
						setOpts({ ...opts, scale: Math.ceil(Number(e.target.value)) })
					}}
				/>
				<p style={{ gridColumn: '1 / span 2' }}>Box</p>
				{['x', 'y', 'w', 'h'].map((key) => (
					<div key={key} style={{ display: 'flex', gap: 4 }}>
						<Control
							type="number"
							name={key}
							value={box[key as keyof typeof box]}
							onChange={(event) => {
								setBox({
									...box,
									[key]: Math.ceil(Number(event.target.value)),
								})
							}}
						/>
					</div>
				))}
			</div>
			<button
				style={{ pointerEvents: 'all', marginTop: 16 }}
				onClick={async () => {
					const shapeIds = editor.getCurrentPageShapeIds()
					if (shapeIds.size === 0) return alert('No shapes on the canvas')

					const { blob } = await editor.toImage([...shapeIds], {
						format: 'png',
						...opts,
						// If we have numbers for all of the box values, we can use them as bounds
						bounds: Object.values(box).every((b) => Number.isNaN(b))
							? new Box(box.x, box.y, box.y, box.x)
							: undefined,
					})

					const link = document.createElement('a')
					link.href = window.URL.createObjectURL(blob)
					link.download = 'every-shape-on-the-canvas.jpg'
					link.click()
				}}
			>
				Export canvas as image
			</button>
		</div>
	)
}

const Control = ({
	name,
	type,
	value,
	checked,
	onChange,
}: {
	name: string
	type?: React.HTMLInputTypeAttribute
	value?: string | number | readonly string[]
	checked?: boolean
	onChange?: React.ChangeEventHandler<HTMLInputElement>
}) => {
	return (
		<>
			<label htmlFor={`opt-${name}`} style={{ flexGrow: 2 }}>
				{name}
			</label>
			<input
				id={`opt-${name}`}
				name={name}
				type={type}
				style={{ maxWidth: 64, justifySelf: 'flex-end' }}
				value={value ?? ''}
				checked={!!checked}
				onChange={onChange}
			/>
		</>
	)
}

/* 
This example shows how you can use the image export settings in tldraw when generating an image.

1.
These are our defaults, though the rest of export / copy features use the user preferences,
e.g. editor.user.getIsDarkMode() for whether the user has enabled dark mode or not. But if
you're calling the image functions yourself, you can provide whatever options you wish.

2.
The bounding box is an optional argument that you can use to export a specific part of the canvas
or selection.
*/
```

## External content sources

Keywords: copy, paste, html

Control what happens when the user pastes content into the editor.

In this example, we register a special handler for when the user pastes in 'text/html' content. We add it to a special shape type that renders the html content directly. Try copying and pasting some code from a VSCode file.

### App.tsx

```tsx
import { useCallback } from 'react'
import {
	BaseBoxShapeUtil,
	defaultHandleExternalTextContent,
	Editor,
	HTMLContainer,
	TLBaseShape,
	Tldraw,
} from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this page!

// [1]
export type IDangerousHtmlShape = TLBaseShape<
	'html',
	{
		w: number
		h: number
		html: string
	}
>

// [2]
class DangerousHtmlExample extends BaseBoxShapeUtil<IDangerousHtmlShape> {
	static override type = 'html' as const

	override getDefaultProps() {
		return {
			type: 'html',
			w: 500,
			h: 300,
			html: '<div>hello</div>',
		}
	}

	override component(shape: IDangerousHtmlShape) {
		return (
			<HTMLContainer style={{ overflow: 'auto' }}>
				<div dangerouslySetInnerHTML={{ __html: shape.props.html }}></div>
			</HTMLContainer>
		)
	}

	override indicator(shape: IDangerousHtmlShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}

// [3]

export default function ExternalContentSourcesExample() {
	const handleMount = useCallback((editor: Editor) => {
		// We will register a new handler for text content. When a user pastes `text/html` content into the editor,
		// we will create a new shape with that html content.
		// To test this copy some html content from VS Code or some other text editor.
		editor.registerExternalContentHandler('text', async (content) => {
			const htmlSource = content.sources?.find((s) => s.type === 'text' && s.subtype === 'html')

			if (htmlSource) {
				const center = content.point ?? editor.getViewportPageBounds().center

				editor.createShape({
					type: 'html',
					x: center.x - 250,
					y: center.y - 150,
					props: {
						html: htmlSource.data,
					},
				})
			} else {
				// otherwise, we'll fall back to the default handler
				await defaultHandleExternalTextContent(editor, content)
			}
		})
	}, [])

	return (
		<div className="tldraw__editor">
			<Tldraw onMount={handleMount} shapeUtils={[DangerousHtmlExample]} />
		</div>
	)
}

/* 
Introduction:
This example shows how to handle content pasted from external sources, this could be
embeds, files, svgs, text, images, or urls. In this case we will handle text/html content.

[1]
We want to render our html on the canvas, the best way to do that is to create a new shape util.
Here's where we define the type for our shape.

[2]
This is our shape util. It's a class that extends BaseBoxShapeUtil. For a more detailed
example of how to create a custom shape, see the custom config example.

[3]
We use the onMount prop to get access to the editor instance via 
the handleMount callback (check out the API example for a more detailed look at this). Then we 
call the registerExternalContentHandler method, we could choose to handle embeds, files, svgs, 
text, images, or urls. For this example we will handle text/html content. The handler is called
with the point where the user pasted the content and an array of sources. We will find and 
return the html source, then create a new shape with that html content.

*/
```

## Hosted images

Keywords: assets, video, image, png, jpg, file



### App.tsx

```tsx
import { TLAssetStore, Tldraw, uniqueId } from 'tldraw'
import 'tldraw/tldraw.css'

// [1]
const UPLOAD_URL = '/SOME_ENDPOINT'

// [2]
const myAssetStore: TLAssetStore = {
	// [a]
	async upload(asset, file) {
		const id = uniqueId()

		const objectName = `${id}-${file.name}`.replaceAll(/\W/g, '-')
		const url = `${UPLOAD_URL}/${objectName}`

		await fetch(url, {
			method: 'POST',
			body: file,
		})

		return { src: url }
	},

	// [b]
	resolve(asset) {
		return asset.props.src
	},
}

// [3]
export default function HostedImagesExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw assets={myAssetStore} />
		</div>
	)
}
/* 

Introduction: This example shows how to handle images uploaded by the user. to do this we'll need to
create a TLAssetStore, which tells the editor how to handle uploaded assets. 

[1] You'll want to have an endpoint on your server that accepts file uploads, and returns URLs.

[2] We define our asset store, which has two methods: upload for saving assets, and resolve for
retrieving them.

    [a] The upload method is called when the user creates a file. It should take a `File` object,
    and return a URL that can be used to reference the file in the future.

    [b] After the file has been uploaded, whenever we want to refer to it again the editor will
    call the `resolve` method with the asset. Here, we just do the default and return the `src`
    prop. If you wanted to, you could return a different URL - for example, to serve optimized
    images, or to add an authentication token. The implementation here is the default, and could 
	have been omitted.

[3] Finally, we have our actual instance. We pass our asset store to the `assets` prop of the
`Tldraw` component so it becomes part of the store.

*/
```

## Local images

Keywords: asset, record, create asset

How to use local images in the built-in `ImageShape` shape.

This example shows how to use local images in the built-in `ImageShape` shape. You must first create an asset that holds the source of the image, then create a shape that references the asset.

### App.tsx

```tsx
import { useCallback } from 'react'
import { AssetRecordType, Editor, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
// There's a guide at the bottom of this file!

export default function LocalImagesExample() {
	// [1]
	const handleMount = useCallback((editor: Editor) => {
		//[2]
		const assetId = AssetRecordType.createId()
		const imageWidth = 1200
		const imageHeight = 675
		//[2]
		editor.createAssets([
			{
				id: assetId,
				type: 'image',
				typeName: 'asset',
				props: {
					name: 'tldraw.png',
					src: '/tldraw.png', // You could also use a base64 encoded string here
					w: imageWidth,
					h: imageHeight,
					mimeType: 'image/png',
					isAnimated: false,
				},
				meta: {},
			},
		])
		//[3]
		editor.createShape({
			type: 'image',
			// Let's center the image in the editor
			x: (window.innerWidth - imageWidth) / 2,
			y: (window.innerHeight - imageHeight) / 2,
			props: {
				assetId,
				w: imageWidth,
				h: imageHeight,
			},
		})
	}, [])

	return (
		<div className="tldraw__editor">
			<Tldraw
				// persistenceKey="tldraw_local_images_example"
				onMount={handleMount}
			/>
		</div>
	)
}

/* 
This is an example of how you can add a locally hosted image to the editor.
We need to first create an asset that holds the source image [2], and then 
create the Image shape itself [3].

Because this is a Next.js app, we can use the `public` folder to store the 
image locally, your framework may have a different way of serving static
assets. 

If you want to allow users to upload the images please take a look at the 
hosted images example.

[1] 
We'll access the editor instance via the `onMount` callback. Check out the API 
example for another way to do this.

[2]
Assets are records that store data about shared assets like images, videos, etc. 
Each image has an associated asset record, so we'll create that first. We need an 
`assetId` so that we can later associate it with the image.

[3]
We create the image sgape and pass in the `assetId` that we created earlier. This
will link our image shape to the asset record. Notice that we create the shape with
the same dimensions as the image, later on the user may resize the image, but we 
don't want to resize our asset, this is one of the reasons why it's important to 
keep assets and shapes separate.
*/
```

## Shape meta (on change)

Keywords: side, effects, register, change, initial

Add custom metadata to shapes when they're changed.

We can update a shape's metadata whenever it changes. A UI displays the current selected shape's metadata. Create a shape, select it, and move it around. The metadata will updated any time the shape changes.

### App.tsx

```tsx
import { TLShape, Tldraw, track, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

export default function OnChangeShapeMetaExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="tldraw_change_meta_example"
				onMount={(editor) => {
					// [1]
					editor.getInitialMetaForShape = (_shape) => {
						return {
							updatedBy: editor.user.getId(),
							updatedAt: Date.now(),
						}
					}
					// [2]
					editor.sideEffects.registerBeforeChangeHandler('shape', (_prev, next, source) => {
						if (source !== 'user') return next
						return {
							...next,
							meta: {
								updatedBy: editor.user.getId(),
								updatedAt: Date.now(),
							},
						}
					})
				}}
			>
				<MetaUiHelper />
			</Tldraw>
		</div>
	)
}

// [3]
type ShapeWithMyMeta = TLShape & { meta: { updatedBy: string; updatedAt: string } }

// [4]
export const MetaUiHelper = track(function MetaUiHelper() {
	const editor = useEditor()
	const onlySelectedShape = editor.getOnlySelectedShape() as ShapeWithMyMeta | null

	return (
		<pre style={{ position: 'absolute', zIndex: 300, top: 64, left: 12, margin: 0 }}>
			{onlySelectedShape
				? JSON.stringify(onlySelectedShape.meta, null, '\t')
				: 'Select one shape to see its meta data.'}
		</pre>
	)
})

/* 
This example shows how to add meta data to shapes when they are created and
updated. In this case we are adding `updatedBy` and `updatedAt` fields.

[1]
getInitialMetaForShape is a method you can replace at runtime. Here we use 
a callback on the onMount prop to replace the default implementation with 
our own.

[2]
Here we're using the side effects API to add meta data to shapes when they are
updated. You can use the side effects API to do something on create, update or
delete, and you can target many things including: shapes, pages, the camera, 
the pointer etc.

[3]
All tldraw shapes have a meta property with a type of unknown. To type your 
meta data you can use a union like this.

[4]
A minimal ui component that displays the meta data of the selected shape. We 
use track to make sure that the component is re-rendered when the signals it's 
tracking change. Check out the signia docs for more info: 
https://signia.tldraw.dev/docs/API/signia_react/functions/track
*/
```

## Shape meta (on create)

Keywords: side, effects, initial, meta, register

Add custom metadata to shapes when they're created.

We can update a shape's metadata whenever it is created. A UI displays the current selected shape's metadata. Create a shape and select it. The metadata will display its created at / created by data.

### App.tsx

```tsx
import { TLShape, Tldraw, track, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

export default function OnCreateShapeMetaExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="example"
				onMount={(editor) => {
					//[1]
					editor.getInitialMetaForShape = (_shape) => {
						return {
							createdBy: editor.user.getId(),
							createdAt: Date.now(),
						}
					}
				}}
			>
				<MetaUiHelper />
			</Tldraw>
		</div>
	)
}

// [2]
type ShapeWithMyMeta = TLShape & { meta: { updatedBy: string; updatedAt: string } }

// [3]
export const MetaUiHelper = track(function MetaUiHelper() {
	const editor = useEditor()
	const onlySelectedShape = editor.getOnlySelectedShape() as ShapeWithMyMeta | null

	return (
		<pre style={{ position: 'absolute', zIndex: 300, top: 64, left: 12, margin: 0 }}>
			{onlySelectedShape
				? JSON.stringify(onlySelectedShape.meta, null, '\t')
				: 'Select one shape to see its meta data.'}
		</pre>
	)
})

/* 
This is example demonstrates how to add your own data to shapes using the meta property as they're
created. Check out the docs for a more detailed explanation of the meta property: 
https://tldraw.dev/docs/shapes#Meta-information

[1]
getInitialMetaForShape is a method you can replace at runtime. Here we use a callback on the onMount
prop to replace the default implementation with our own.

[2]
All tldraw shapes have a meta property with a type of unknown. To type your meta data you can use 
a union like this.

[3]
A minimal ui component that displays the meta data of the selected shape. We use track to make sure
that the component is re-rendered when the signals it's tracking change. Check out the signia docs
for more info: https://signia.tldraw.dev/docs/API/signia_react/functions/track

*/
```

## Meta Migrations

Keywords: records, snapshot, sequence

Create custom migrations for `meta` properties.

You can add arbitrary data migrations for tldraw snapshot data. This is mainly useful for updating the `meta` property of a record as your data types evolve.

### App.tsx

```tsx
import { Tldraw, createMigrationIds, createMigrationSequence } from 'tldraw'
import 'tldraw/tldraw.css'
import { snapshot } from './snapshot'
import { components } from './ui-overrides'

/**
 * This example demonstrates how to add custom migrations for `meta` properties, or any other
 * data in your store snapshots.
 *
 * If you have a custom shape type and you want to add migrations for its `props` object,
 * there is a simpler dedicated API for that. Check out [the docs](https://tldraw.dev/docs/persistence#Shape-props-migrations) for more info.
 */

/**
 * Let's say you added some page metadata, e.g. to allow setting the background color of a page independently.
 */
interface _PageMetaV1 {
	backgroundTheme?: 'red' | 'blue' | 'green' | 'purple'
}

/**
 * And then perhaps later on you decided to remove support for 'purple' because it's an ugly color.
 * So all purple pages will become blue.
 */
export interface PageMetaV2 {
	backgroundTheme?: 'red' | 'blue' | 'green'
}

/**
 * You would then create a migration to update the metadata from v1 to v2.
 */

// First pick a 'sequence id' that is unique to your app
const sequenceId = 'com.example.my-app'
// Then create a 'migration id' for each version of your metadata
const versions = createMigrationIds(sequenceId, {
	// the numbers must start at 1 and increment by 1
	RemovePurple: 1,
})
const migrations = createMigrationSequence({
	sequenceId,
	sequence: [
		{
			id: versions.RemovePurple,
			// `scope: 'record` tells the schema to call this migration on individual records.
			// `scope: 'store'` would call it on the entire snapshot, to allow for actions like deleting/creating records.
			scope: 'record',
			// When `scope` is 'record', you can specify a filter function to only apply the migration to records that match the filter.
			filter: (record) => record.typeName === 'page',
			// This up function will be called on all records that match the filter
			up(page: any) {
				if (page.meta.backgroundTheme === 'purple') {
					page.meta.backgroundTheme = 'blue'
					page.name += ' (was purple)'
				}
			},
		},
	],
})

export default function MetaMigrationsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// Pass in the custom migrations
				migrations={[migrations]}
				// When you load a snapshot from a previous version, the migrations will be applied automatically
				snapshot={snapshot}
				// This adds a dropdown to the canvas for changing the backgroundTheme property
				components={components}
			/>
		</div>
	)
}
```
### snapshot.ts

```ts
import { TLStoreSnapshot } from 'tldraw'

export const snapshot = {
	store: {
		'document:document': {
			gridSize: 10,
			name: '',
			meta: {},
			id: 'document:document',
			typeName: 'document',
		},
		'page:red': {
			meta: {
				backgroundTheme: 'red',
			},
			id: 'page:red',
			name: 'Red',
			index: 'a1',
			typeName: 'page',
		},
		'page:green': {
			meta: {
				backgroundTheme: 'green',
			},
			id: 'page:green',
			name: 'Green',
			index: 'a2',
			typeName: 'page',
		},
		'page:blue': {
			meta: {
				backgroundTheme: 'blue',
			},
			id: 'page:blue',
			name: 'Blue',
			index: 'a3',
			typeName: 'page',
		},
		'page:purple': {
			meta: {
				backgroundTheme: 'purple',
			},
			id: 'page:purple',
			name: 'Purple',
			index: 'a0',
			typeName: 'page',
		},
	},
	schema: {
		schemaVersion: 2,
		sequences: {
			'com.tldraw.store': 4,
			'com.tldraw.document': 2,
			'com.tldraw.page': 1,
		},
	},
} as TLStoreSnapshot
```
### ui-overrides.tsx

```tsx
import { useLayoutEffect } from 'react'
import { TLComponents, track, useEditor } from 'tldraw'
import { PageMetaV2 } from './MetaMigrations'

export const components: TLComponents = {
	TopPanel: track(() => {
		const editor = useEditor()
		const currentPage = editor.getCurrentPage()
		const meta: PageMetaV2 = currentPage.meta

		useLayoutEffect(() => {
			const elem = document.querySelector('.tl-background') as HTMLElement
			if (!elem) return
			elem.style.backgroundColor = meta.backgroundTheme ?? 'unset'
		}, [meta.backgroundTheme])

		return (
			<span style={{ pointerEvents: 'all', padding: '5px 15px', margin: 10, fontSize: 18 }}>
				bg: &nbsp;
				<select
					value={meta.backgroundTheme ?? 'none'}
					onChange={(e) => {
						if (e.currentTarget.value === 'none') {
							editor.updatePage({ ...currentPage, meta: {} })
						} else {
							editor.updatePage({
								...currentPage,
								meta: { backgroundTheme: e.currentTarget.value },
							})
						}
					}}
				>
					<option value="none">None</option>
					<option value="red">Red</option>
					<option value="blue">Blue</option>
					<option value="green">Green</option>
				</select>
			</span>
		)
	}),
}
```

## Create an arrow

Keywords: arrow, between

Create an arrow between two shapes.

This example shows how you can use the Editor API to create an arrow between two shapes.

### App.tsx

```tsx
import { createShapeId, Editor, TLArrowBinding, TLArrowShape, Tldraw, TLShapeId, Vec } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

export default function CreateArrowExample() {
	return (
		<>
			<div className="tldraw__editor">
				<Tldraw
					onMount={(editor) => {
						// Only do this on an empty canvas
						if (editor.getCurrentPageShapeIds().size > 0) return

						const shapeAId = createShapeId()
						const shapeBId = createShapeId()

						editor.createShapes([
							{
								id: shapeAId,
								type: 'geo',
								x: 100,
								y: 100,
							},
							{
								id: shapeBId,
								type: 'geo',
								x: 400,
								y: 400,
							},
						])

						createArrowBetweenShapes(editor, shapeAId, shapeBId)
					}}
				/>
			</div>
		</>
	)
}

function createArrowBetweenShapes(
	editor: Editor,
	startShapeId: TLShapeId,
	endShapeId: TLShapeId,
	options = {} as {
		parentId?: TLShapeId
		start?: Partial<Omit<TLArrowBinding['props'], 'terminal'>>
		end?: Partial<Omit<TLArrowBinding['props'], 'terminal'>>
	}
) {
	const { start = {}, end = {}, parentId } = options

	// [1]
	const {
		normalizedAnchor: startNormalizedAnchor = { x: 0.5, y: 0.5 },
		isExact: startIsExact = false,
		isPrecise: startIsPrecise = false,
	} = start
	const {
		normalizedAnchor: endNormalizedAnchor = { x: 0.5, y: 0.5 },
		isExact: endIsExact = false,
		isPrecise: endIsPrecise = false,
	} = end

	const startTerminalNormalizedPosition = Vec.From(startNormalizedAnchor)
	const endTerminalNormalizedPosition = Vec.From(endNormalizedAnchor)

	const parent = parentId ? editor.getShape(parentId) : undefined
	if (parentId && !parent) throw Error(`Parent shape with id ${parentId} not found`)

	const startShapePageBounds = editor.getShapePageBounds(startShapeId)
	const endShapePageBounds = editor.getShapePageBounds(endShapeId)

	const startShapePageRotation = editor.getShapePageTransform(startShapeId).rotation()
	const endShapePageRotation = editor.getShapePageTransform(endShapeId).rotation()

	if (!startShapePageBounds || !endShapePageBounds) return

	const startTerminalPagePosition = Vec.Add(
		startShapePageBounds.point,
		Vec.MulV(
			startShapePageBounds.size,
			Vec.Rot(startTerminalNormalizedPosition, startShapePageRotation)
		)
	)
	const endTerminalPagePosition = Vec.Add(
		endShapePageBounds.point,
		Vec.MulV(
			startShapePageBounds.size,
			Vec.Rot(endTerminalNormalizedPosition, endShapePageRotation)
		)
	)

	const arrowPointInParentSpace = Vec.Min(startTerminalPagePosition, endTerminalPagePosition)
	if (parent) {
		arrowPointInParentSpace.setTo(
			editor.getShapePageTransform(parent.id)!.applyToPoint(arrowPointInParentSpace)
		)
	}

	const arrowId = createShapeId()
	editor.run(() => {
		editor.markHistoryStoppingPoint('creating_arrow')
		editor.createShape<TLArrowShape>({
			id: arrowId,
			type: 'arrow',
			// [2]
			x: arrowPointInParentSpace.x,
			y: arrowPointInParentSpace.y,
			props: {
				// [3]
				start: {
					x: arrowPointInParentSpace.x - startTerminalPagePosition.x,
					y: arrowPointInParentSpace.x - startTerminalPagePosition.x,
				},
				end: {
					x: arrowPointInParentSpace.x - endTerminalPagePosition.x,
					y: arrowPointInParentSpace.x - endTerminalPagePosition.x,
				},
			},
		})

		editor.createBindings<TLArrowBinding>([
			{
				fromId: arrowId,
				toId: startShapeId,
				type: 'arrow',
				props: {
					terminal: 'start',
					normalizedAnchor: startNormalizedAnchor,
					isExact: startIsExact,
					isPrecise: startIsPrecise,
				},
			},
			{
				fromId: arrowId,
				toId: endShapeId,
				type: 'arrow',
				props: {
					terminal: 'end',
					normalizedAnchor: endNormalizedAnchor,
					isExact: endIsExact,
					isPrecise: endIsPrecise,
				},
			},
		])
	})
}

/*
Introduction:

This example shows how to create an arrow between two shapes.

[1] 
The normalized anchor is the position inside the shape that the arrow connects to, where 0 0 is the
top left corner and 1 1 is the bottom right. `isPrecise` needs to be enabled for this position to be
used, otherwise it targets the center of the shape.

By default, arrows don't intersect shapes they're connected to, and instead gracefully touch the
outside of the shape's geometry. You can turn this off and make an arrow intersect a shape by
setting `isExact` to true.

[2]
The arrow shape's position is in parent space, which in this case means the page.

[3]
The arrow's start and end positions are "local", which means they're relative to the arrow's
position. Note: You don't need to set the arrow's start and end positions if they're bound to
another shape, as it gets calculated automatically.

*/
```

## Derived view

Keywords: basic, intro, simple, quick, start

Derive data from the editor's document in an efficient way.

Use incremental derivations to get a specific view of data.

### App.tsx

```tsx
import { isUninitialized, RESET_VALUE } from '@tldraw/state'
import { useMemo, useRef } from 'react'
import { computed, Editor, isShape, Tldraw, TLShapeId, useEditor, useValue } from 'tldraw'
import 'tldraw/tldraw.css'

export default function DerivedViewExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="derived-view">
				<ShowNumberOfDrawShapesOnPage />
			</Tldraw>
		</div>
	)
}

function ShowNumberOfDrawShapesOnPage() {
	const editor = useEditor()
	const rRenders = useRef(0)

	// Create a computed value that tracks the number of draw shapes in the document, returning a set of ids
	const computed = useMemo(() => deriveNumberOfDrawShapesInDocument(editor), [editor])
	// Get the size of the computed value whenever the computed value changes
	const value = useValue('computed value', () => computed.get().size, [computed])

	return (
		<div style={{ position: 'absolute', top: 50, left: 20, zIndex: 99999 }}>
			<p>{value} draw shapes in project</p>
			{/* Will go up by two in dev, NAB */}
			<p>{rRenders.current++} renders</p>
		</div>
	)
}

export const deriveNumberOfDrawShapesInDocument = (editor: Editor) => {
	const { store } = editor
	const shapesIndex = store.query.ids('shape')

	// Create an index of all the shape ids of all the draw shapes
	function fromScratch() {
		return new Set([...shapesIndex.get()].filter((id) => editor.getShape(id)!.type === 'draw'))
	}

	return computed<Set<TLShapeId>>('_shapeIdsInCurrentPage', (prevValue, lastComputedEpoch) => {
		// On first load, return the initial value
		if (isUninitialized(prevValue)) {
			return fromScratch()
		}

		// Get the changes since the last computed value
		const diff = store.history.getDiffSince(lastComputedEpoch)

		// Something caused the store to reset, compute a new value from scratch
		if (diff === RESET_VALUE) {
			return fromScratch()
		}

		// This will be the new set that includes the changes, if we find any
		let nextValue: Set<TLShapeId> | undefined

		for (const changes of diff) {
			// Check all of the added records for new draw shapes
			for (const record of Object.values(changes.added)) {
				if (isShape(record) && record.type === 'draw') {
					// If we haven't created the new set yet, do it now
					if (!nextValue) {
						nextValue = new Set(prevValue)
					}
					// mutate the new set
					nextValue.add(record.id)
				}
			}

			for (const record of Object.values(changes.removed)) {
				// Check all of the removed records for deleted draw shapes
				if (isShape(record) && record.type === 'draw') {
					// If we haven't created the new set yet, do it now
					if (!nextValue) {
						nextValue = new Set(prevValue)
					}
					// mutate the new set
					nextValue.delete(record.id)
				}
			}
		}

		// if something changed, return the new value
		if (nextValue) return nextValue

		// if nothing changed, return the previous value
		return prevValue
	})
}
```

## Editor focus

Keywords: instance, state, keyboard shortcuts

The editor's keyboard shortcuts only work when the editor is "focused".

In this example, we drive the editor's focus in order to turn on and off keyboard shortcuts.

The editor's focus is different from—but usually corresponds to—the browser's concept of "focus", which is related to the document's [active element](https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement).

Unfortunately, the browser's focus cannot be relied on to determine whether the editor's keyboard shortcuts should work. While its possible to detect whether the document's active element is a descendant of the Tldraw component's own element, it's not 100% reliable. For example, iframes are not considered descendants of their parents, and many menus are portalled into different parts of the document tree.

For these reasons, the responsibility falls to you, dear developer, to manage focus for your Tldraw editor, especially in cases where there are more than one editor on the same page.

### App.tsx

```tsx
import { useRef } from 'react'
import { Editor, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import './editor-focus.css'

export default function EditorFocusExample() {
	const editorRef = useRef<Editor | null>(null)
	return (
		<div style={{ padding: 32 }}>
			<input type="text" placeholder="Test me" />
			<p>
				You should be able to type in this text input without worrying about triggering editor
				shortcuts even when the editor is focused.
			</p>
			<div>
				<h2>Controlled Focus</h2>
				<div style={{ display: 'flex', gap: 4 }}>
					<input
						id="focus"
						type="checkbox"
						onChange={(e) => {
							if (e.target.checked) {
								editorRef.current?.focus()
							} else {
								editorRef.current?.blur()
							}
						}}
					/>
					<label htmlFor="focus">Focus</label>
				</div>
			</div>
			<p>The checkbox focuses and blurs the editor.</p>
			<p>
				When the editor is “focused”, its keyboard shortcuts will work. When it is not focused, the
				keyboard shortcuts will not work.
			</p>
			<div style={{ width: 800, maxWidth: '100%', height: 500 }}>
				<Tldraw
					autoFocus={false}
					onMount={(editor) => {
						editorRef.current = editor
					}}
				/>
			</div>
		</div>
	)
}
```
### editor-focus.css

```css
.tl-container__focused {
	outline: 1px solid var(--color-primary);
}
```

## Indicators logic

Keywords: indicators

If for some reason you wanted to show indicators yourself, here's an example of that.

### App.tsx

```tsx
import { TLComponents, Tldraw, useEditor, useEditorComponents, useValue } from 'tldraw'
import 'tldraw/tldraw.css'

const components: TLComponents = {
	OnTheCanvas: () => {
		const editor = useEditor()

		// [1]
		const renderingShapes = useValue(
			'rendering shapes',
			() => editor.getRenderingShapes().filter((_info) => true),
			[editor]
		)

		// [2]
		const { ShapeIndicator } = useEditorComponents()
		if (!ShapeIndicator) return null

		return (
			<div style={{ position: 'absolute', top: 0, left: 0, zIndex: 9999 }}>
				{renderingShapes.map(({ id }) => (
					<ShapeIndicator key={id + '_indicator'} shapeId={id} />
				))}
			</div>
		)
	},
	// [3]
	// ShapeIndicators: () => {
	// 	return <DefaultShapeIndicators showAll />
	// },
}

export default function IndicatorsLogicExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				components={components}
				onMount={(editor) => {
					if (editor.getCurrentPageShapeIds().size === 0) {
						editor.createShapes([
							{
								type: 'geo',
								x: 100,
								y: 100,
							},
							{
								type: 'geo',
								x: 500,
								y: 150,
							},
							{
								type: 'geo',
								x: 100,
								y: 500,
							},
							{
								type: 'geo',
								x: 500,
								y: 500,
							},
						])
					}
				}}
			/>
		</div>
	)
}

/*
[1]
Get which indicators to show (based on the shapes currently on screen).
You could include logic here using the filter to narrow down which shapes
you want to show the indicators for.

[2]
You could override the default ShapeIndicator component in this
same TLComponents object, but the default (DefaultIndicator.tsx)
has a lot of logic for where and how to display the indicator.

[3]
If all you want to do is show or hide all the indicators, you could 
create an override for the ShapeIndicators component that returns the
DefaultShapeIndicators component with `hideAll` or `showAll` props 
set to true.
*/
```

## Lock camera zoom

Keywords: camera, lock, zoom

Press Shift+K to lock the camera at its current zoom.

Need to lock the camera at its current zoom level? You can use the camera controls API to keep the zoom level from changing.

### App.tsx

```tsx
import { Tldraw, TLUiOverrides } from 'tldraw'
import 'tldraw/tldraw.css'

const DEFAULT_CAMERA_STEPS = [0.05, 0.1, 0.25, 0.5, 1, 2, 4, 8]

const overrides: TLUiOverrides = {
	actions(editor, actions) {
		actions.lockCameraZoom = {
			id: 'lock-camera-zoom',
			kbd: '!k',
			onSelect() {
				const isCameraZoomLockedAlready = editor.getCameraOptions().zoomSteps.length === 1
				editor.setCameraOptions({
					zoomSteps: isCameraZoomLockedAlready ? DEFAULT_CAMERA_STEPS : [editor.getZoomLevel()],
				})
			},
		}

		return actions
	},
}

export default function BasicExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example" overrides={overrides} />
		</div>
	)
}
```

## Permissions

Keywords: permissions, effect, side, user

Create a kind of hacky version of permissions in tldraw using `meta` properties and side effects. In this example, a shape can only be updated for five seconds after it is created. It can only be deleted _after_ five seconds.

While there isn't (yet) a permissions API in tldraw, you can achieve a similar effect using shape `meta` tags and side effects.

For this example, we'll store a `createdAt` time on each shape and then use this time to prevent certain changes or deletes. You might use a similar system to stash a `createdBy` properties on the shape's `meta` object and then prevent users from deleting or changing shapes that they didn't create.

### App.tsx

```tsx
import { JsonObject, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

interface MyMeta extends JsonObject {
	createdAt: number
}

export default function PermissionsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="permissions"
				onMount={(e) => {
					// [1]
					e.getInitialMetaForShape = (_shape) => {
						{
							return {
								createdAt: Date.now(),
							}
						}
					}

					// [1.5]
					// e.sideEffects.registerBeforeCreateHandler('shape', (shape, source) => {
					// 	if (source === 'remote') return shape
					// 	return { ...shape, meta: { createdAt: Date.now() } }
					// })

					// [2]
					e.sideEffects.registerBeforeDeleteHandler('shape', (shape, source) => {
						if (source === 'remote') return
						const meta = shape.meta as MyMeta
						if (Date.now() - meta.createdAt < 1000 * 5) return false
						return
					})

					// [3]
					e.sideEffects.registerBeforeChangeHandler('shape', (prev, next, source) => {
						if (source === 'remote') return next
						const meta = next.meta as MyMeta
						if (Date.now() - meta.createdAt > 1000 * 5) return prev
						return next
					})
				}}
			/>
		</div>
	)
}

/*
If you run this example, you'll see that you can't delete a shape that was created less than 5 seconds ago,
and you can't modify a shape that was created more than 5 seconds ago. This is a simple example of how you
can use permissions to control what users can do in the editor.

In your app, you probably have an ID that could be associated with a user. You could use this ID to prevent
users from modifying or deleting shapes that they didn't create. You could also use this ID to prevent users
from modifying, deleting, or perhaps even unlocking certain template shapes. This system could also be dynamic,
such as checking your user's permission level (something like "change-all", "change-own", "change-none") to 
determine what they can or can't do.

Remember that tldraw also has a readonly mode, which can be set on the editor component. (If you wanted to be
extra safe, you could also prevent changes in the client to the readonly mode using the side effect system).

[1]
When a user creates a shape, the editor calls the `getInitialMetaForShape` method. If we want to set the meta
automatically for a shape, we can override the editor's `getInitialMetaForShape` method.

[1.5]
Alternatively, you can use the `beforeCreate` side effect to set the meta for a shape. But be careful! 
This side effect runs whenever a shape record is created for any reason, including when a shape is 
re-created by undoing a deleted shape. If you only want to set the meta when a shape is first created, you
should use `getInitialMetaForShape`.

[2]
The `beforeDelete` side effect runs when a user tries to delete a shape. If we want to prevent a shape
from being deleted, we can return false from this method. If we return false, the shape will not be deleted.
If your app is multiplayer, you should check the `source` argument to see if the delete was caused by the user
or caused by a remote change.

[3]
A `beforeChange` side effect runs when a user tries to modify a shape. If we want to prevent a shape
from being modified, we can return the previous shape record from this method. Whatever we return from
this method will be the new version of the shape. Like with other side effects, if your app is multiplayer,
you should check the `source` argument to see if the delete was caused by the user or caused by a remote change.
*/
```

## Prevent instance change

Keywords: side, effect, instance, grid, mode, prevent

Prevent a change to the "instance" record that would turn off grid mode.

You can use Editor's side effects API to prevent certain changes from occuring in the instance state. In this example, we prevent the user from changing the instance's `isGridMode` property.

### App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this page!

export default function PreventInstanceChangeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					editor.updateInstanceState({ isGridMode: true })

					// [1]
					editor.sideEffects.registerBeforeChangeHandler('instance', (prev, next) => {
						if (!next.isGridMode) {
							return prev
						}
						return next
					})
				}}
			/>
		</div>
	)
}

/*
In this example, we want to prevent the user from changing the isGridMode property.

[1]
Here we register a handler that will run whenever a change is about to be made to
to an "instance" type record.

The logic we want is that: if the new instance has `isGridMode` set to `false`, then
we want to reject the change; otherwise, we want to allow it.

To reject the change, we return the previous record. To allow the change, we
return the next record.
*/
```

## Prevent shape change

Keywords: side, effect, move, prevent

You can use Editor's side effects API to prevent certain changes from occuring in a shape. In this example, we prevent any changes to the shape's position, rotation, or size.

### App.tsx

```tsx
import { TLGeoShape, Tldraw, toRichText } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this page!

export default function PreventMoveExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					editor.createShape<TLGeoShape>({
						type: 'geo',
						x: 100,
						y: 100,
						props: {
							w: 300,
							h: 300,
							richText: toRichText("style me but don't transform me"),
						},
					})

					// [1]
					editor.sideEffects.registerBeforeChangeHandler('shape', (prev, next) => {
						if (
							editor.isShapeOfType<TLGeoShape>(prev, 'geo') &&
							editor.isShapeOfType<TLGeoShape>(next, 'geo') &&
							next.props.geo === 'rectangle'
						) {
							if (
								next.x !== prev.x ||
								next.y !== prev.y ||
								next.rotation !== prev.rotation ||
								next.props.w !== prev.props.w ||
								next.props.h !== prev.props.h
							) {
								return prev
							}
						}
						return next
					})
				}}
			/>
		</div>
	)
}

/*
[1]
Here we register a handler that will run whenever a change is about to be made to
a shape's record.

The logic we want is that: if the shape is a geo shape and a rectangle, and then
if the x, y, or rotation properties would be different in the next version of
the shape record, or if the props.w, or props.h properties would change, then
we want to reject the change; otherwise, we want to allow it.

To reject the change, we return the previous record. To allow the change, we
return the next record.
*/
```

## UI events

Keywords: ui, events, api, x-ray

Useful if you want to build a custom ui. See which editor methods are triggered by ui events.

Try selecting tools, using keyboard shortcuts, undo/redo, etc. Events will be logged next to the canvas.

### App.tsx

```tsx
import { Fragment, useCallback, useState } from 'react'
import { TLUiEventHandler, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import { getCodeSnippet } from './codeSnippets'

// There's a guide at the bottom of this file!

export default function UiEventsExample() {
	const [uiEvents, setUiEvents] = useState<string[]>([])

	const handleUiEvent = useCallback<TLUiEventHandler>((name, data: any) => {
		const codeSnippet = getCodeSnippet(name, data)
		setUiEvents((events) => [
			...events,
			`event: ${name} ${JSON.stringify(data)}${codeSnippet && `\ncode:  ${codeSnippet}`}`,
		])
	}, [])

	return (
		<div style={{ display: 'flex' }}>
			<div style={{ width: '60%', height: '100vh' }}>
				<Tldraw onUiEvent={handleUiEvent} />
			</div>
			<div
				style={{
					width: '40%',
					height: '100vh',
					padding: 8,
					background: '#eee',
					border: 'none',
					fontFamily: 'monospace',
					fontSize: 12,
					borderLeft: 'solid 2px #333',
					overflow: 'auto',
				}}
				onCopy={(event) => event.stopPropagation()}
			>
				{uiEvents.map((t, i) => (
					<Fragment key={i}>
						<pre style={{ borderBottom: '1px solid #000', marginBottom: 0, paddingBottom: '12px' }}>
							{t}
						</pre>
					</Fragment>
				))}
			</div>
		</div>
	)
}

/* 
This example shows how to listen to UI events. This includes includes things like selecting a tool,
grouping shapes, zooming etc. Events are included even if they are triggered by a keyboard shortcut.
However, interactions with the style panel are not included. For a full list of events and sources,
check out the TLUiEventSource and TLUiEventMap types.

It also shows the relevant code snippet for each event. This is useful for debugging and learning
the tldraw SDK.

We can pass a handler function to the onUiEvent prop of the Tldraw component. This handler function
will be called with the name of the event and the data associated with the event. We're going to 
display these events in a list on the right side of the screen.

To listen to canvas events or changes to the store, check out the canvas events and store events 
examples.

*/
```
### codeSnippets.ts

```ts
const STYLE_EVENT = {
	'tldraw:color': 'DefaultColorStyle',
	'tldraw:dash': 'DefaultDashStyle',
	'tldraw:fill': 'DefaultFillStyle',
	'tldraw:font': 'DefaultFontStyle',
	'tldraw:horizontalAlign': 'DefaultHorizontalAlignStyle',
	'tldraw:size': 'DefaultSizeStyle',
	'tldraw:verticalAlign': 'DefaultVerticalAlignStyle',
	'tldraw:geo': 'GeoShapeGeoStyle',
}

const REORDER_EVENT = {
	toFront: 'bringToFront',
	forward: 'bringForward',
	backward: 'sendBackward',
	toBack: 'sendToBack',
}

const SHAPES_META_EVENT = {
	'group-shapes': 'groupShapes',
	'ungroup-shapes': 'ungroupShapes',
	'delete-shapes': 'deleteShapes',
}

const SHAPES_EVENT = {
	'distribute-shapes': 'distributeShapes',
	'align-shapes': 'alignShapes',
	'stretch-shapes': 'stretchShapes',
	'flip-shapes': 'flipShapes',
}

const USER_PREFS_EVENT = {
	'toggle-snap-mode': 'isSnapMode',
	'toggle-dark-mode': 'isDarkMode',
	'toggle-reduce-motion': 'animationSpeed',
	'toggle-edge-scrolling': 'edgeScrollSpeed',
}

const PREFS_EVENT = {
	'toggle-transparent': 'exportBackground',
	'toggle-tool-lock': 'isToolLocked',
	'toggle-focus-mode': 'isFocusMode',
	'toggle-grid-mode': 'isGridMode',
	'toggle-debug-mode': 'isDebugMode',
}

const ZOOM_EVENT = {
	'zoom-in': 'zoomIn',
	'zoom-out': 'zoomOut',
	'reset-zoom': 'resetZoom',
	'zoom-to-fit': 'zoomToFit',
	'zoom-to-selection': 'zoomToSelection',
}

export function getCodeSnippet(name: string, data: any) {
	let codeSnippet = ''

	if (name === 'set-style') {
		if (data.id === 'opacity') {
			codeSnippet = `editor.setOpacityForNextShapes(${data.value});`
		} else {
			codeSnippet = `editor.setStyleForNextShapes(${
				STYLE_EVENT[data.id as keyof typeof STYLE_EVENT] ?? '?'
			}, '${data.value}');`
		}
	} else if (['rotate-ccw', 'rotate-cw'].includes(name)) {
		codeSnippet = 'editor.rotateShapesBy(editor.getSelectedShapeIds(), <number>)'
	} else if (name === 'edit-link') {
		codeSnippet =
			'editor.updateShapes([{ id: editor.getOnlySelectedShape().id, type: editor.getOnlySelectedShape().type, props: { url: <url> }, }, ])'
	} else if (name.startsWith('export-as')) {
		codeSnippet = `exportAs(editor.getSelectedShapeIds(), '${data.format}')`
	} else if (name.startsWith('copy-as')) {
		codeSnippet = `copyAs(editor.getSelectedShapeIds(), '${data.format}')`
	} else if (name === 'select-all-shapes') {
		codeSnippet = `editor.selectAll()`
	} else if (name === 'select-none-shapes') {
		codeSnippet = `editor.selectNone()`
	} else if (name === 'reorder-shapes') {
		codeSnippet = `editor.${
			REORDER_EVENT[data.operation as keyof typeof REORDER_EVENT] ?? '?'
		}(editor.getSelectedShapeIds())`
	} else if (['group-shapes', 'ungroup-shapes', 'delete-shapes'].includes(name)) {
		codeSnippet = `editor.${
			SHAPES_META_EVENT[name as keyof typeof SHAPES_META_EVENT] ?? '?'
		}(editor.getSelectedShapeIds())`
	} else if (name === 'stack-shapes') {
		codeSnippet = `editor.stackShapes(editor.getSelectedShapeIds(), '${data.operation}', 16)`
	} else if (name === 'pack-shapes') {
		codeSnippet = `editor.packShapes(editor.getSelectedShapeIds(), 16)`
	} else if (name === 'duplicate-shapes') {
		codeSnippet = `editor.duplicateShapes(editor.getSelectedShapeIds(), {x: <value>, y: <value>})`
	} else if (name.endsWith('-shapes')) {
		codeSnippet = `editor.${
			SHAPES_EVENT[name as keyof typeof SHAPES_EVENT] ?? '?'
		}(editor.getSelectedShapeIds(), '${data.operation}')`
	} else if (name === 'select-tool') {
		if (data.id === 'media') {
			codeSnippet = 'insertMedia()'
		} else if (data.id.startsWith('geo-')) {
			codeSnippet = `\n  editor.updateInstanceState({
  stylesForNextShape: {
    ...editor.getInstanceState().stylesForNextShape,
    [GeoShapeGeoStyle.id]: '${data.id.replace('geo-', '')}',
  },
}, { ephemeral: true });
editor.setCurrentTool('${data.id}')`
		} else {
			codeSnippet = `editor.setCurrentTool('${data.id}')`
		}
	} else if (name === 'print') {
		codeSnippet = 'printSelectionOrPages()'
	} else if (name === 'unlock-all') {
		codeSnippet = `\n  const updates = [] as TLShapePartial[]
for (const shape of editor.getCurrentPageShapes()) {
  if (shape.isLocked) {
    updates.push({ id: shape.id, type: shape.type, isLocked: false })
  }
}
if (updates.length > 0) {
  editor.updateShapes(updates)
}`
	} else if (['undo', 'redo'].includes(name)) {
		codeSnippet = `editor.${name}()`
	} else if (['cut', 'copy'].includes(name)) {
		codeSnippet = `\n  const { ${name} } = useMenuClipboardEvents();\n  ${name}()`
	} else if (name === 'paste') {
		codeSnippet = `\n  const { paste } = useMenuClipboardEvents();\n  navigator.clipboard?.read().then((clipboardItems) => {\n    paste(clipboardItems)\n  })`
	} else if (name === 'stop-following') {
		codeSnippet = `editor.stopFollowingUser()`
	} else if (name === 'exit-pen-mode') {
		codeSnippet = `editor.updateInstanceState({ isPenMode: false })`
	} else if (name === 'remove-frame') {
		codeSnippet = `removeFrame(editor, editor.getSelectedShapes().map((shape) => shape.id))`
	} else if (name === 'fit-frame-to-content') {
		codeSnippet = `fitFrameToContent(editor, editor.getOnlySelectedShape().id)`
	} else if (name.startsWith('zoom-') || name === 'reset-zoom') {
		codeSnippet = `editor.${ZOOM_EVENT[name as keyof typeof ZOOM_EVENT]}(${
			name !== 'zoom-to-fit' && name !== 'zoom-to-selection'
				? 'editor.getViewportScreenCenter(), '
				: ''
		}{ duration: 320 })`
	} else if (name.startsWith('toggle-')) {
		if (name === 'toggle-lock') {
			codeSnippet = `editor.toggleLock(editor.getSelectedShapeIds())`
		} else {
			const userPrefName = USER_PREFS_EVENT[name as keyof typeof USER_PREFS_EVENT]
			const prefName = PREFS_EVENT[name as keyof typeof PREFS_EVENT]
			codeSnippet = userPrefName
				? `editor.user.updateUserPreferences({ ${userPrefName}: <value> })`
				: `editor.updateInstanceState({ ${prefName}: !editor.getInstanceState().${prefName} })`
		}
	}

	return codeSnippet
}
```

## User presence

Keywords: Instance presence record, cursor

Show other users editing the same document.

Here, we add fake InstancePresence records to the store to simulate other users. If you have your own presence system, you could add real records to the store in the same way.

### App.tsx

```tsx
import { useRef } from 'react'
import { InstancePresenceRecordType, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

// [1]
const USER_NAME = 'huppy da arrow'
const MOVING_CURSOR_SPEED = 0.25 // 0 is stopped, 1 is full send
const MOVING_CURSOR_RADIUS = 100
const CURSOR_CHAT_MESSAGE = 'Hey, I think this is just great.'

// [2]
export default function UserPresenceExample() {
	const rRaf = useRef<any>(-1)
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="user-presence-example"
				onMount={(editor) => {
					// [a]
					const peerPresence = InstancePresenceRecordType.create({
						id: InstancePresenceRecordType.createId(editor.store.id),
						currentPageId: editor.getCurrentPageId(),
						userId: 'peer-1',
						userName: USER_NAME,
						cursor: { x: 0, y: 0, type: 'default', rotation: 0 },
						chatMessage: CURSOR_CHAT_MESSAGE,
					})

					editor.store.mergeRemoteChanges(() => {
						editor.store.put([peerPresence])
					})

					// [b]
					const raf = rRaf.current
					cancelAnimationFrame(raf)

					if (MOVING_CURSOR_SPEED > 0 || CURSOR_CHAT_MESSAGE) {
						function loop() {
							let cursor = peerPresence.cursor
							if (!cursor) return
							let chatMessage = peerPresence.chatMessage

							const now = Date.now()

							if (MOVING_CURSOR_SPEED > 0) {
								const k = 1000 / MOVING_CURSOR_SPEED
								const t = (now % k) / k

								cursor = {
									...cursor,
									x: 150 + Math.cos(t * Math.PI * 2) * MOVING_CURSOR_RADIUS,
									y: 150 + Math.sin(t * Math.PI * 2) * MOVING_CURSOR_RADIUS,
								}
							}

							if (CURSOR_CHAT_MESSAGE) {
								const k = 1000
								const t = (now % (k * 3)) / k
								chatMessage =
									t < 1
										? ''
										: t > 2
											? CURSOR_CHAT_MESSAGE
											: CURSOR_CHAT_MESSAGE.slice(
													0,
													Math.ceil((t - 1) * CURSOR_CHAT_MESSAGE.length)
												)
							}

							editor.store.mergeRemoteChanges(() => {
								editor.store.put([
									{
										...peerPresence,
										cursor,
										chatMessage,
										lastActivityTimestamp: now,
									},
								])
							})

							rRaf.current = editor.timers.requestAnimationFrame(loop)
						}

						rRaf.current = editor.timers.requestAnimationFrame(loop)
					} else {
						editor.store.mergeRemoteChanges(() => {
							editor.store.put([{ ...peerPresence, lastActivityTimestamp: Date.now() }])
						})
						rRaf.current = editor.timers.setInterval(() => {
							editor.store.mergeRemoteChanges(() => {
								editor.store.put([{ ...peerPresence, lastActivityTimestamp: Date.now() }])
							})
						}, 1000)
					}
				}}
			/>
		</div>
	)
}

/* 
This example shows how to add instance presence records to the store to show other users' cursors.
It is not an example of how to implement user presence, check out the yjs example for that:
https://github.com/tldraw/tldraw-yjs-example

[1]
We're going to a fake a user's cursor and chat message, these are the values we'll use.

[2]
This is where we'll render the Tldraw component. We'll use the onMount callback to access the editor 
instance.
	[a] For every connected peer we need to add an instance presence record to the store. We can do
		this using the InstancePresenceRecordType.create function and add it to the store using the
		store.put method.
	[b] We'll use the requestAnimationFrame function to update the cursor position and chat message.
		This is just for demonstration purposes.
*/
```

## Controlling the editor

Keywords: api, create shape, update shape, mount, context

Manipulate the contents of the canvas using the editor API.

This example creates and updates shapes, selects and rotates them, and zooms the camera.

### App.tsx

```tsx
import {
	DefaultColorStyle,
	Editor,
	TLGeoShape,
	TLShapePartial,
	Tldraw,
	toRichText,
	createShapeId,
	useEditor,
} from 'tldraw'
import 'tldraw/tldraw.css'
import { useEffect } from 'react'

// There's a guide at the bottom of this file!

//[1]
export default function APIExample() {
	const handleMount = (editor: Editor) => {
		// Create a shape id
		const id = createShapeId('hello')

		// Create a shape
		editor.createShapes<TLGeoShape>([
			{
				id,
				type: 'geo',
				x: 128 + Math.random() * 500,
				y: 128 + Math.random() * 500,
				props: {
					geo: 'rectangle',
					w: 100,
					h: 100,
					dash: 'draw',
					color: 'blue',
					size: 'm',
				},
			},
		])

		// Get the created shape
		const shape = editor.getShape<TLGeoShape>(id)!

		const shapeUpdate: TLShapePartial<TLGeoShape> = {
			id,
			type: 'geo',
			props: {
				h: shape.props.h * 3,
				richText: toRichText('hello world!'),
			},
		}

		// Update the shape
		editor.updateShapes([shapeUpdate])

		// Select the shape
		editor.select(id)

		// Rotate the shape around its center
		editor.rotateShapesBy([id], Math.PI / 8)

		// Clear the selection
		editor.selectNone()

		// Zoom the camera to fit both shapes
		editor.zoomToFit()
	}

	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="api-example" onMount={handleMount}>
				<InsideOfEditorContext />
			</Tldraw>
		</div>
	)
}

//[2]
const InsideOfEditorContext = () => {
	const editor = useEditor()

	useEffect(() => {
		let i = 0

		const interval = setInterval(() => {
			const selection = [...editor.getSelectedShapeIds()]
			editor.selectAll()
			editor.setStyleForSelectedShapes(DefaultColorStyle, i % 2 ? 'blue' : 'light-blue')
			editor.setStyleForNextShapes(DefaultColorStyle, i % 2 ? 'blue' : 'light-blue')
			editor.setSelectedShapes(selection)
			i++
		}, 1000)

		return () => {
			clearInterval(interval)
		}
	}, [editor])

	return null
}

/* 
Introduction: 

This example shows how to use the tldraw editor instance to make changes 
to the canvas. The editor instance is tldraw's "god object". You can use 
the app to do just about everything that's possible in tldraw. Internally, 
the canvas component and all shapes, tools, and UI components use this instance 
to send events, observe changes, and perform actions. 

There are two main ways to use the editor:

[1] 
The tldraw component shares its editor instance via its onMount callback prop.
When you define a function for the onMount callback, it receives the editor 
instance as an argument. You can use this to manipulate the canvas.


[2]
Another (sneakier) way to access the current app is through React context.
The Tldraw component provides the context, so you can add children to
the component and access the app through the useEditor hook. This is cool.

*/
```

## Canvas events

Keywords: cursor, pointer, mouse, click, keyboard, handler, input

Listen to events from tldraw's canvas.

These are the input events that the editor interprets. Try moving your cursor, dragging, using modifier keys, etc.

### App.tsx

```tsx
import { useCallback, useState } from 'react'
import { TLEventInfo, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

export default function CanvasEventsExample() {
	const [events, setEvents] = useState<any[]>([])

	const handleEvent = useCallback((data: TLEventInfo) => {
		setEvents((events) => {
			const newEvents = events.slice(0, 100)
			if (
				newEvents[newEvents.length - 1] &&
				newEvents[newEvents.length - 1].type === 'pointer' &&
				data.type === 'pointer' &&
				data.target === 'canvas'
			) {
				newEvents[newEvents.length - 1] = data
			} else {
				newEvents.unshift(data)
			}
			return newEvents
		})
	}, [])

	return (
		<div style={{ display: 'flex' }}>
			<div style={{ width: '50%', height: '100vh' }}>
				<Tldraw
					onMount={(editor) => {
						editor.on('event', (event) => handleEvent(event))
					}}
				/>
			</div>
			<div
				style={{
					width: '50%',
					height: '100vh',
					padding: 8,
					background: '#eee',
					border: 'none',
					fontFamily: 'monospace',
					fontSize: 12,
					borderLeft: 'solid 2px #333',
					display: 'flex',
					flexDirection: 'column-reverse',
					overflow: 'auto',
					whiteSpace: 'pre-wrap',
				}}
				onCopy={(event) => event.stopPropagation()}
			>
				<div>{JSON.stringify(events, undefined, 2)}</div>
			</div>
		</div>
	)
}

/* 
This example shows how to listen to canvas events. This includes things like pointer and 
keyboard events, but not things such as undo/redo, create/delete shapes, etc. Those are store events.

To listen to changes to the store, check out the store events example.
*/
```

## Snapshots

Keywords: 

Load a snapshot of the editor's contents.

Use `getSnapshot()` and `loadSnapshot()` to save and restore the editor's contents.

### App.tsx

```tsx
import { useCallback, useEffect, useState } from 'react'
import { TLEditorSnapshot, Tldraw, getSnapshot, loadSnapshot, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'
import _jsonSnapshot from './snapshot.json'

// There's a guide at the bottom of this file!

const jsonSnapshot = _jsonSnapshot as any as TLEditorSnapshot

// [1]
function SnapshotToolbar() {
	const editor = useEditor()

	const save = useCallback(() => {
		// [2]
		const { document, session } = getSnapshot(editor.store)
		// [3]
		localStorage.setItem('snapshot', JSON.stringify({ document, session }))
	}, [editor])

	const load = useCallback(() => {
		const snapshot = localStorage.getItem('snapshot')
		if (!snapshot) return

		// [4]
		loadSnapshot(editor.store, JSON.parse(snapshot))
	}, [editor])

	const [showCheckMark, setShowCheckMark] = useState(false)
	useEffect(() => {
		if (showCheckMark) {
			const timeout = setTimeout(() => {
				setShowCheckMark(false)
			}, 1000)
			return () => clearTimeout(timeout)
		}
		return
	})

	return (
		<div style={{ padding: 20, pointerEvents: 'all', display: 'flex', gap: '10px' }}>
			<span
				style={{
					display: 'inline-block',
					transition: 'transform 0.2s ease, opacity 0.2s ease',
					transform: showCheckMark ? `scale(1)` : `scale(0.5)`,
					opacity: showCheckMark ? 1 : 0,
				}}
			>
				Saved ✅
			</span>
			<button
				onClick={() => {
					save()
					setShowCheckMark(true)
				}}
			>
				Save Snapshot
			</button>
			<button onClick={load}>Load Snapshot</button>
		</div>
	)
}

export default function SnapshotExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// [5]
				snapshot={jsonSnapshot}
				components={{
					SharePanel: SnapshotToolbar,
				}}
			/>
		</div>
	)
}

/*

[1] We'll add a toolbar to the top-right of the editor viewport that allows the user to save and load snapshots.

[2] Call `getSnapshot(editor.store)` to get the current state of the editor

[3] The 'document' state is the set of shapes and pages and images etc.
The 'session' state is the state of the editor like the current page, camera positions, zoom level, etc.
You probably need to store these separately if you're building a multi-user app, so that you can store per-user session state.
For this example we'll just store them together in localStorage.

[4] Call `loadSnapshot()` to load a snapshot into the editor
You can omit the `session` state, or load it later on it's own.
e.g.
	loadSnapshot(editor.store, { document })
then optionally later
	loadSnapshot(editor.store, { session })

[5] You can load an initial snapshot into the editor by passing it to the `snapshot` prop.

*/
```
### snapshot.json

```json
{
	"document": {
		"store": {
			"document:document": {
				"gridSize": 10,
				"name": "",
				"meta": {},
				"id": "document:document",
				"typeName": "document"
			},
			"page:page": {
				"meta": {},
				"id": "page:page",
				"name": "Page 1",
				"index": "a1",
				"typeName": "page"
			},
			"asset:-2122303015": {
				"meta": {},
				"type": "image",
				"props": {
					"name": "tldrawFile",
					"src": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPIAAAB0CAYAAAC/gW9hAAAAAXNSR0IArs4c6QAAHGZJREFUeF7tXQdYFcf2P3kRsYAFsPeCICAg9gJYA0qxv6ixR001xacv7f3z0syL0cTYe4w9tsSCJXZRYxeUJsUACipWLKgRNf/vN7jr3r27d++FC7ksc77Pz8vulJ3fzG/OzDlndl8gor+IiHxatMZ/dObUcfY/F44AR6D4IPACJ3Lx6Sz+pBwBNQQ4kfnY4AjoAAFOZB10Im8CR4ATmY8BjoAOEOBE1kEn8iZwBDiR+RjgCOgAAU5kHXQibwJHgBOZjwGOgA4Q4ETWQSfyJnAEOJH5GOAI6AABTmQddCJvAkeAE5mPAY6ADhDgRNZBJ/ImmEbAwc2fHMM+IHu3jizh3S3fsP9vbM77Xw/CiayHXuRtUEWgxoQIkcDyRH8mHqLLU0N1gZ6uifzfzz6jniHKHRUXG0ujRo6wSidGHjpE9vZlFMuaN3cOLfnxR6vUwwuxDAHn8A/JMexDk5mgnfWgmXVN5M1bIqhV67xz1nK5d+8euTZqaNnIUEl96UoWvfACoDSW5cuW0r8nTrRKPbwQdQRAWqmUbtJRVRPLSxGW2riOfI+SDhU7cnMiW4EdnMhWADGfRcj3v/ksRjFbcdLWxYbIdnZ2FBAYSMHBwdS6TRuqU6cujRwxnA7s36/ad1wjW3NY215Z5iydC/rU16eG0b3EgwUtptDz2zSRK1euTPMWLCQvLy/Cb/nyddzbb9H6des4kQt9mNhmBfUXZhf6gxUXg5hNE9nDw4P27FPXuJzIhT6ObbaCotDGQuOLwxKbE9kKQ5Xvka0AooVFmHIrWViUZnJOZE2ITCfgGrmAAOo4O9fIhp3LNbIVBjvXyFYA0cIirElk7IOFqC+lx+Aa2cLOQfIPPvyQfH2bs5wOjo7UsmVL1VJSU1MpPS3N4P6CBfNp39697FpBrdYvDxxIPUNCyLuZN1WtVo3+8Y9/0KNHj+hCejrNmTObVq9axerJvHyF3VOSFcuX0cQJEwxuTZk6lWrXrmOU/OHDh8wSL8grQ4bSu++9R1WrViV7e3v65OOP6MfFixXrcXd3p48++YRcXZuQs5MTlStfnkqVKkV//fUX+5ednU1xcXEUeWA/LVywgP7880+jcv7v0/8SVkGK7VixnLZGRBjd+vyLL6hJEzej6zExMfT1pK+MroeEhtKQIUMV64iIiKCVK5abNWqsRWSBpKbKKw4GL5vTyMdPnqI6dYwHuVm9S0SzZs6kSV99WSAig5Rr16+nDh3yYnPV5I/z5yk0pCfFxidYROSUP1KpfPnyRsWCcDWrV6OyZcvS/siDVLduXYM0ixctov988rHBtV69etN/Pv2UateubS5EbDL68ovPadHChQZ5IrZtpxYtWiiWc+LECQoPDTG6pzaJ5ebmUt3atYzSb9m6TXVyPnXqFIX27KHZDmuTWKjQVLm2rpU5kWXDpmKlSrR7z16ziXHl8mVycnam0qVLK2syBY2sReS9+w9Q06ZNjcqTE/l/30ymESNHag58tQTy1cLrb7xJCGtVkuzsW9TUzVDzduzoT+s2bFCtv3u3rhQbE2NwPzEpmSpUrKiY5/PPPiOEtJoSaxm5lIipVbYta2ZOZNmo+eXXjdSufft8k0OeUWlpbYrI306ezLYXSiIl8oSJE+lfEwoW+okVQLcunSk+Pp5VB199/LlExbqRtk6tmvTkyRPxPrYIQ4YOU8Vq7pw59MXnzycGTHbpFzNU03u4u9GtW7dU7xeWJkaF5pZtqwEinMiSYVO9Rg06HRWtGjedH3ZbSmQMZCcnJ5NExqohNi6e7YELKpcuZVKL5nk2CQiIDEIrSf++fenw4UPircNHjlLDhurx6pggunbuJKbv1r07LV+xUrFstBtENiXmks2U8UpJq5pbLp7NVrWyzRH5y68mke+zgVWuXDlV4wtAxbI2IzNT7Pu/nj6l8ePfp5TkZHbNUmPXT8uWUVBQsMnBdD4lhbBfdHZxpsDATqpLaqEQS4isRUpBI0MTQyOrydWrV+mjDz+gXTt3krOLC61Zu1bRICXkb1i/Hj148ID9uWTpMhYGqyRyDXsx85LJyQR78Xp1nu/dv5n8LQ0foXzibMeOHTRyuLp2x/OYE8klLJkRg+0yYYtBMwpKYqGwtDGVtLqqyO/bHJGlCBS1H9mU9RnPJR/INWrWpMiDh8jBwUG14wqDyJO+/p/q3hhL306BAQRDnCCOjo6UmJyiutIY0K8fHTqUF08Mq/KixcrHLk+ePElhIT1ZOngTYLjSEv+OHcSJdffefeTp6amYZfSroxSt4tLEWkSW73vlZJYT0BJNLH0OTmStXpfdL0oiw1IOi7kpLefTzMvodv8BA2jmrNlWJzL2pHA1bd0aQSdPnBDLhzU4P2LKyAQ30cwZM1ixL774IkHTKh3LvJ2dTe5uTVi6ryZ9Ta+OHq35KNO+/46w74ecT00jrLLkorT/VipYyxiFPPI9rEBm+fX8kthWrddcIz8bMcE9etCSn5aqDszvpk6hqVOmKN5Pu3CR+XmVJD8aOTf3EfUIDia8/CC/gkmwTdu25OPjS27ubuTt7aPqItu0aSO9PnasWNXR4yeoXr16JgmHlynAZy0VEFI+AURHR1GPoCCqUKECWxUoSXp6OrVt3UqzqUrLZaVMWgap/JIYdXEia3aTcYKi1MjvvT9e1VqMJ+sVHkbHjx1TbMWxEyeNfL5CwvwQGS4YuGLMFUwi4955hzp36UqNGzUixwoVLDLYIYBm8KCBYnWm3FovD+hPkZGRdCEjk3C0VCrXrl2jKlWqGFzD3ht78L59+9HsuXMVm/TTkiVsT2+OmKOVlTSzULa5k4HSs9iqoQvPyjXysx6bPWcO9e3XX3UseXk0pRs3bijeNxVIYSmRnz59Sg3q1WVBG1pSq1Zt+mrSJII1uCAWbDmRvZo1o1279yhWj0lm/fr1zNcuFxjjlJbbLf386KOPP6Z+/ZXxVfI3m2q7uRpVbZmthavSfVvVxMKzciI/Q2Lp8uX00ktBqn0M66saudau30D+/v6KeS0lslLghVLBn/zn/+jtcePyMyaN8siJjATw9yoFuZw+fZqOHjlCb771lkE5WFa7uTampJTnRjYhAfbgAwcOooaNGhnVLbdsm9sgSzVzQTSxrZOYa2TJO7vg9ho9ZozqOAr096ekJOVgCbVILBRmKZFhbe7Qvp3J8QwXDlw5WnLn9m1KOX+eoqOiaOiwYUZLYSG/EpG37dhBzZv7GVVx8+ZNSk9PM7p34cIFatOqJUWfjaFq1aoZ5IPvuWXLVop2hKio09RTxd1lDa2MMqCZ5a4oLeyk9215Sa0LjfzBvyfSsqXqBipL/MjDhg+nyd8qG7MA1tgxo2nL5s2K/X8mJpYdbFASS4l84vhxCg8z/YrWmLh4cnFxUR2LKGPs2DHMzy5IXMI51UATJSJD20PrywWGuJs3bxmRdeXKFTRh/HiaO38+9e7dxyBbRkaGasgr4uIRH2+pmLu8trRcpfScyAVEUcvYpfWGSkuIrOUXhZ8V/la5QPtAC6mJpUQ+8vvv1LdPb9Xy4BNWWr4KGbBqwOpBLkrGKVMa2dnZmR0GURIsh+XLbkw+mEC6dutGK1bmnQoTBPt+tdNhpmwPpoYPJ7IhOja9R0bIZFT0GdX+xFG8Zp4edPfuXcU0lhAZJ47+SEtXrQuD0dvL08jgtWDhIgoLDy8yIvv5+dHW7TtU69u1aycNGzLE4D4itRCxpSb79+2jQQNfNrqdkJhIlSoph2tKE0tPOoGw8EOrEVeaz1x7gNJzF2TPa6l+4XtkSxFTSG/q0D6SQzscPXqUEKyAo4HQ0gj3g1hCZKQ/Gxtn5D6RPlJOTg5zQ8G/C9fLF19+pXn6yNoaubGrKx08dFgVWTxj44YNxPsIdMEe3lT0GfawiKOWi5YBUEifkJBAXToFitm1YrCFhDt3/kbDhyqfTTZn6Jhr8DKnLFNptPzSBS3fGvltWiOjgVhGYjlprhTkPDJO8uBEj5Y8fvyYRUCpvZRemt/aREbZWqGkwssPsq5mUZs2bTVdU2oGJ5x1nrdggRYcNGP6dPrf15PEdAghHfXqq5r5EISCYJT8SlFo5eKgjYGfzRNZyXhiquMLQuT8TBxag7AwiKxkGdZ6DlP35RpVSItVB9xQWhMWorIQnSWIt48P/bZzl8lHgrsKLr38hpwKhRfmXrm4kLhYEBl718TkZLKzUz64Lx8tBSWylvVaaXRiaar2NhElg5zaeWSUrWXsQprATp3o5zVrLeIu7AlqYaSwbjf39VEsT+uNLffv36dGDeob5b2QkWGyzy5evEitWyq/jcSihj1LDEILn3sR8mt990lIB6s0PhOD/ILc3TK5WLyYXnhem9fIeFAEaixcvFjzyCDSFpTIKAMRSDNmzjLLYIPwwszMDEVXDcoqDCKjXFNHAuVEQOgkIrLwTi4lUXstD9J+O2UKDR32/D1i8vwIW4XdQC6IDEOEmJpoeRzyQ2Z5HnO0dXHSuqYwKRZERgNwmH7p0mXk18LP5Ewv3a+tXLWaunTtqth+6UkepQQ+vr60avXPqr5XWFy/+Pxz9gK+wYNfoe+mTVOsB6eK5C+hM3USScnqrNaBcPVgwlF7EQH28r/t2EGvjR1D/gEBtPrnNapjAe/XUlrmIigEwSFq8t9PP6UF8+cZ3dY6M40gEOzNC1v4Z1ULG+EClI83RgYF92BBEXibxZnoaEpKTqL4uDiC9rGmYDkKwgQEBJJdaTu6lHmJjh09Kp7ftWZd+S3L08uLnQ/G3hR7z7t37hD2vRvWrzd4NU9+yy/u+YQvNQpLbSyli9vSWasPio1G1moIv88RKMkIcCKX5N7nbdcNApzIuulK3pCSjAAncknufd523SDAiaybruQNKckIcCKX5N7nbdcNApzIuulK3pCSjAAncknufd523SDAiaybruQNKckIcCKX5N7nbdcNApzIuulK3pCSjAAncknufd523SDAiaybruQNKckIcCKX5N7nbdcNApzIuulK3pCSjAAncknufd523SDAiaybruQNKckIcCKX5N7nbdcNApzIuulK3pCSjAAncknufd523SDAiaybruQNKckIcCJb0PvBoeHU1MOL5fh5xVK6fCnTgtzGSUN79yXXJu7sxsb1ayj1D+OPhBeoAp65xCDAiWxBV/fu/zI1aNiIE9kCzHjSokGg2BO5TJkyVKZMWcKnSx49+jNfqFWtVp3cm3pS/YYNadOGdXT7drZiOZzI+YKXZyoCBIodkWvWqk2+LVpSnbr1GIHl3+G9fz+HUlNSKOZstNlL3wGDhlDtOnUZ3CuWLKJr165yIhfB4ONVWA+BYkPkevUbUFDPMCrv4GDQ+txHj+jhw4dU2t7e6CNl+OLCpl/W0rWrysQUCuJEtt6A4iX9PQjYPJHxSc+OAZ2pZZu2DKGnT59SYnwcRZ0+SVezrrBPpEilRs1a5NHMmzw8m4nfBT64fw+dPH5MFWFO5L9n8PFarYeAzRNZailOT0uliI0bCB/y1pJy5ctTaK++VKt2HZZ0+5ZNdC4hTsxWtlw5Kv3sU60hvfpSterV2b1NG9bSjevXxXQ593PocW4u+zs/e2RnZxeqXrMmVahQka5ezaIL6WmEVQQE9TZxU7daIw8msgcPsP/Py4P9fK1atamUnR2dOHbECAYHB0eqVqMGVapYicqULcu+A4WtAv4J7ZBmwgqn1Iul2IR4585tRVhLly5NZcuWY/fwHHgeJUHd+AA85O7dO2zS5VI0CNg0kT28mrHlNOT4kcN0+OABi1EJ69OfGrs2YfmWLp5PN2/cYL+l100VCmL/cT7FYiI7OlYgTELC3ltax9WsLPpl3WoK7NJNdGfJ3U9Ozi40/NWxLFvk3t10Jvo0hfbuJ1rN8aXFmd9/KxZbqVJlCujSjRo1dlVsDtJjZXIm6rTBKmbc+H+LK5d5s36gB/eNSfpScAh5eud9PznryhVatexHozpgq0BZgs1i/qzpBHsFl6JBwGaJXL58eRr9xjg2MNJS/6Bf1/0sIoJrzVu0Ii9vX6pQsSI9ePCAUpITKe5sNNsPdw/qSXZ2dhS5fw/hA98jx7zB9tYJ8bG0I2JzoRMZpBo8fJTqh8XxAJhQsi5foqZeed8Q1iIy2unbopWIgZTITs7ONHjoSLIrbfgxeKQpVaqUwUg6HLmfjh/9XbwmXWUAG2Akl7FvvmNgm5g5bYqRdsfK55+Dh7Ks2bdu0ZKFc4tmBPNaGAI2S+S27TtSu44BhMG4cM4MZtASZNDQkVS9Rg2jLsRSbuumX5i2hSyYPZ1ycnLIq5kPde8RwpZ6c2d8z5aHlZ2cqVy5vOVi15eCydmlCvu9d9dvdF1itb5x/ZpYt7lL66EjR5NLlari80WdPE5Jiefofk4OVateg/w7dyVHR0eD5zdF5KSEeGrS1IOlx1I5PT2VLmdmUOzZM+yaFA/gtXN7BF1IS2NLYCyL23XwJ79WbcT6Fs2dxZa+EC9vH+oeHMJ+o56tWzYaPJdjhQo0+vW3TT4rbrYP6ERt2rZn6U6fOEYH9u3hFCtCBGyWyK+9/S6VK1eezpw+RXt3/yZCgsGCQQPBMu9w5D5GNGi25n4txXRSjYX95Fvv/otp9y2/rqeU5CQDiK1p7Gri3pRCwvuI5W/d/CslnUswqA+a8+XBw6hK1edkN0VkIXP0qRO0f+9ug6VxZScnGjH6dbH837ZtofjYGKMh1KvfP6lho8bs+u4d25h7DgKMgTUEq5c5078zyOvt68cmOsjdu3fZBHQ26hTt2fW8T3BvyIjRYnvWrFxGlzIzinAY86psksjS/aHUr1ulajUaMuJVcVD9OH+2gUFFqpmwxF7x0yKxhwUtGblvD506YWjBtiaR+wwYSPUbNGT1Zly8QOtWr1AcZVWrVaNXhue1BaJFZLWysGVo0CAv2iz3cS4lJsQr1ie1N8g1JrYelSpXZvmWLJhL2dm3xDKEVQiWy9euZbGQUqwKFs2bJabBNubt9yeyv7HqmfHdZCNvAqda4SJgk0RGGCQGEAbF9KnfiAh06RZEPn4t2N8gCAa3VKCRO3V7iV2KjTlDu7ZvFW8LGkmu4ZHAmkR+d8KHosFnw5pVzEqtJlItpkXkDWtW04X01HyPBgTQ9B/4Cst/PiWZNv+yTizLP7CL6N7bv3snc+1BYDF/518fsPbg2vWsLLZFgQjbFvwW+gu/YRiEgZBL0SJgk0T29WtBnbsFsaXcorkzRUQEjfvwwQOaO3OaEVLYfw4eNpJdlw5I/N0zvDe5uXtQTHQU7d653SCvtYhsb1+G3nx3vFj23BnT6OHDB6o9GhQSxvzdEC0iT/v2a7NGBvbEdevVZ26qys4u5OTkRBUrVjIwhOFwBuoTBL73gUOGsz/h4vtl7Wr2u3qNmjRo6Aj2G9dgOxj7Vt4yHPvwuJiz7Ld0gsXkiUmUS9EiYJNE7uAfSK3bdTBydQiuErVlJvaA0LyQtauWU2bGRRFNWFRhWYUx60zUqUIhMgxoI0a/JpatRT7BoKdFZLWJS9oIENevVWs2WcnDVuVDSk5k3BewlS6NhX7AfSyXnzx5wgxfMIDBS7Dl1w2s6FGvvckmCwh3OxUtgYXabJLIfi1aUWDX7gZ7MRiI3n5vAntu6SCSwiZoXVyb/cN3BocoBBeK0vFDa2lk7DOx3xREi8jtOwZQm/YdWXJTGhmacPmS5/t9+VCRakThHva0cG/duHGdbt28yYJDBKOVEpHD+vSjxq5uLPuqZUso68pl0YCF45rADdK1exB5N2/Bglpm/TCVBYq8Pu49do+7nf4eEqNWmyQyAjjgQpLvkYX9JyyisIxKxcHBgca8+Q67JAwy4X6VKlVpyMjR7E8MPiGySrhvLSJLJxumnWZPZy4nNekZ2ovcPDw1iSwlkrwsxKD3/ecg8TK2DoeeWfKlaaV7ZCUiN/X0ouCQcJblyKFIOnXyuDhxSn3P0v0wJhcXlyrUI6wXy3fq+FGK3L/37xvNJbhmmySy1KL706L5dOtmXjQW3Cxwt0CW/biQ4ONls9ELL1DP8D5iuCNcT7OmTREtp4IlWU1jWIvIeBZppBTCSZOTElWHl9RabEojmyJySFhv0cdsytDk69eSOj8zBMoDbPCAOEn2xjvvs2e9cvkynTh6WPTHg7CCbx0BJmgjBK4/J5cqVn3ZQgnmYoGabpNEBjHh94WGk1qZcWZYmP3RahhmrmVdoUaubozg0Eaubu5sGQntkJaaSj5+fuKSEQYb5JFLv5cHMwMRZMfWzZQQZxzdhHvSgBA1K7I09BMTDSYcJUHoJiYQQfJLZGHvj3JMHQ6RTlawHcCGIJdho8aIgTEx0aepma+f0eoGeQSjIyzysAvAtyyfPAs0KnlmixGwSSKjFZ27dmchifLIrq5BPcjbp7lRQxHyuHzJQvIP7GwQxSQkPHRgn+IhA9yXxhKb0mrSAxzScE/pw0gNbrj++8EDdOzIYYPnxYEOhFTCaFRQIgf1CGWnvSDJ5xIoYvOvRthIfci4qRYvLd2zw8CGCVHJHtGmXQdq7x/IAkjs7e1ZfXKXlsUjkWcoEAI2S2Sp4UiuQeAuwakhLOtuXLtGyUnn6MrlS2wpjSiuJk3cycvHlxwcHVns9cljR0y+ZEDqfwaamBQSE+JYnDL8pzn37jGQW7dtRx0COouA47kupKWywYx0d27nnR6Sh5BiT3ouPpYZ76pXr0FtOvizPFIi5Fcjezbzppd6hIrPhFDQ5HPxlJmZwSzJ3s392NJXWpfaFgOW71eGjzIYUEqRYvJgFmRQiygr0Ojkmc1GwGaJLCdO7Jlo5v+Vnz82u6UmEiIy6fVx7xsdMEAW6eknHH2E9VvJvbNty0YxqgpLTRyaQPijmsBHfuz3g9QtqCdLkl8iYxuCiUM4hqlUH4yG2Ociug3PLjciSvPAMyA9fKFmsJPaApB/3swfVI83WqOPeBmmEbBpIuPRpftXuFE2bljD3BxaggGL8EVoQXME2ii87wCjwwxSIqMc+KIRSy1/U4mUyEiH01uduweJb8mUPgNivXdui6DadetS+LMDHut/XkkXL6SLyaQrElPGLmRAIEpApy5sFSIXtH97xCbmU39j3PtsuQxRst7jemh4H3J1b8rSyEMxpWUDK+HIJPrlp0XzzIGZpykkBGyeyDiojrBL6b4YVtWYM6cpMyOD7t29Q7m5uexAO84AO7m4kLuHJyPQk8ePac6M7y064I7jgngZAE5I3c6+RfeeLavl+KMukA17eBzIF5bf8nTYD7u4VCW8JBBRXjjgr3Tm1xr9izoQpw5XHJ4rOzubbt54/pIEa9TBy7BNBGyeyAJsDRu7UpfuwUYa0xSs2BeuXbmMrj9zU9lmF/Cn4ggUHIFiQ2ShqYin9vH1oxq1arPlrWA1xX1YWnNy7lHW5csUF3vW6FBFweHiJXAEbBOBYkdkJRhhXcZSkgtHoKQioAsil9TO4+3mCAgIcCLzscAR0AECnMg66ETeBI4AJzIfAxwBHSDAiayDTuRN4AhwIvMxwBHQAQKcyDroRN4EjgAnMh8DHAEdIMCJrINO5E3gCHAi8zHAEdABApzIOuhE3gSOACcyHwMcAR0gwImsg07kTeAIcCLzMcAR0AECnMg66ETeBI4AJzIfAxwBHSDAiayDTuRN4AhwIvMxwBHQAQKcyDroRN4EjgAnMh8DHAEdIMCJrINO5E3gCPw/r4Gt4lbgcG8AAAAASUVORK5CYII=",
					"w": 242,
					"h": 116,
					"mimeType": "image/png",
					"isAnimated": false
				},
				"id": "asset:-2122303015",
				"typeName": "asset"
			},
			"shape:kxWzJDmOhhoa3eIMS_d_U": {
				"x": 439.91015625000006,
				"y": 408.14453125000006,
				"rotation": 0,
				"isLocked": false,
				"opacity": 1,
				"meta": {},
				"id": "shape:kxWzJDmOhhoa3eIMS_d_U",
				"type": "draw",
				"props": {
					"segments": [
						{
							"type": "free",
							"points": [
								{
									"x": 0,
									"y": 0,
									"z": 0.5
								},
								{
									"x": -0.13,
									"y": 0.13,
									"z": 0.5
								},
								{
									"x": -0.05,
									"y": 0.27,
									"z": 0.5
								},
								{
									"x": 0.89,
									"y": 0.27,
									"z": 0.5
								},
								{
									"x": 6.72,
									"y": 0.27,
									"z": 0.5
								},
								{
									"x": 19.89,
									"y": -2,
									"z": 0.5
								},
								{
									"x": 33.39,
									"y": -6.93,
									"z": 0.5
								},
								{
									"x": 45.85,
									"y": -14.57,
									"z": 0.5
								},
								{
									"x": 59.59,
									"y": -25.83,
									"z": 0.5
								},
								{
									"x": 69.66,
									"y": -38.32,
									"z": 0.5
								},
								{
									"x": 74.64,
									"y": -50.34,
									"z": 0.5
								},
								{
									"x": 76.25,
									"y": -61.21,
									"z": 0.5
								},
								{
									"x": 76.23,
									"y": -71.55,
									"z": 0.5
								},
								{
									"x": 74.98,
									"y": -79.2,
									"z": 0.5
								},
								{
									"x": 70.04,
									"y": -84.48,
									"z": 0.5
								},
								{
									"x": 64,
									"y": -88.11,
									"z": 0.5
								},
								{
									"x": 58.74,
									"y": -89.03,
									"z": 0.5
								},
								{
									"x": 52.9,
									"y": -88.88,
									"z": 0.5
								},
								{
									"x": 47.43,
									"y": -86.1,
									"z": 0.5
								},
								{
									"x": 42.63,
									"y": -80,
									"z": 0.5
								},
								{
									"x": 38.77,
									"y": -69.36,
									"z": 0.5
								},
								{
									"x": 36.81,
									"y": -51.13,
									"z": 0.5
								},
								{
									"x": 36.43,
									"y": -26.77,
									"z": 0.5
								},
								{
									"x": 40.13,
									"y": 3.13,
									"z": 0.5
								},
								{
									"x": 48.43,
									"y": 38.37,
									"z": 0.5
								},
								{
									"x": 55.57,
									"y": 69.78,
									"z": 0.5
								},
								{
									"x": 60.53,
									"y": 100.75,
									"z": 0.5
								},
								{
									"x": 63.42,
									"y": 133.8,
									"z": 0.5
								},
								{
									"x": 63.1,
									"y": 160.92,
									"z": 0.5
								},
								{
									"x": 58.09,
									"y": 180.57,
									"z": 0.5
								},
								{
									"x": 47.5,
									"y": 192.21,
									"z": 0.5
								},
								{
									"x": 33.36,
									"y": 197.42,
									"z": 0.5
								},
								{
									"x": 18.86,
									"y": 198.58,
									"z": 0.5
								},
								{
									"x": 6.95,
									"y": 197.67,
									"z": 0.5
								},
								{
									"x": -1.21,
									"y": 194.8,
									"z": 0.5
								},
								{
									"x": -5.55,
									"y": 190.55,
									"z": 0.5
								},
								{
									"x": -6.84,
									"y": 184.29,
									"z": 0.5
								},
								{
									"x": -0.86,
									"y": 173.8,
									"z": 0.5
								},
								{
									"x": 17.39,
									"y": 158.11,
									"z": 0.5
								},
								{
									"x": 45.72,
									"y": 137.57,
									"z": 0.5
								},
								{
									"x": 76.32,
									"y": 113.69,
									"z": 0.5
								},
								{
									"x": 102.73,
									"y": 87.41,
									"z": 0.5
								},
								{
									"x": 120.88,
									"y": 63.27,
									"z": 0.5
								},
								{
									"x": 131.73,
									"y": 39.67,
									"z": 0.5
								},
								{
									"x": 137.52,
									"y": 15.89,
									"z": 0.5
								},
								{
									"x": 138.82,
									"y": -0.14,
									"z": 0.5
								},
								{
									"x": 137.79,
									"y": -10.26,
									"z": 0.5
								},
								{
									"x": 134.94,
									"y": -17.39,
									"z": 0.5
								},
								{
									"x": 131.56,
									"y": -21.15,
									"z": 0.5
								},
								{
									"x": 128.66,
									"y": -22.95,
									"z": 0.5
								},
								{
									"x": 126.65,
									"y": -23.48,
									"z": 0.5
								},
								{
									"x": 125.56,
									"y": -23.35,
									"z": 0.5
								},
								{
									"x": 124.66,
									"y": -20.86,
									"z": 0.5
								},
								{
									"x": 123.36,
									"y": -9.53,
									"z": 0.5
								},
								{
									"x": 120.79,
									"y": 12.29,
									"z": 0.5
								},
								{
									"x": 116.39,
									"y": 41.36,
									"z": 0.5
								},
								{
									"x": 112.64,
									"y": 69.82,
									"z": 0.5
								},
								{
									"x": 111.43,
									"y": 96.55,
									"z": 0.5
								},
								{
									"x": 111.3,
									"y": 122.02,
									"z": 0.5
								},
								{
									"x": 113.43,
									"y": 138.52,
									"z": 0.5
								},
								{
									"x": 119.61,
									"y": 149.46,
									"z": 0.5
								},
								{
									"x": 126.6,
									"y": 156.13,
									"z": 0.5
								},
								{
									"x": 134.3,
									"y": 157.33,
									"z": 0.5
								},
								{
									"x": 144.39,
									"y": 154.1,
									"z": 0.5
								},
								{
									"x": 155.78,
									"y": 144.19,
									"z": 0.5
								},
								{
									"x": 166.99,
									"y": 129.98,
									"z": 0.5
								},
								{
									"x": 176.18,
									"y": 113.52,
									"z": 0.5
								},
								{
									"x": 182.1,
									"y": 96.91,
									"z": 0.5
								},
								{
									"x": 184.19,
									"y": 84.67,
									"z": 0.5
								},
								{
									"x": 184.39,
									"y": 75.84,
									"z": 0.5
								},
								{
									"x": 183.51,
									"y": 69.13,
									"z": 0.5
								},
								{
									"x": 181.32,
									"y": 65.31,
									"z": 0.5
								},
								{
									"x": 178.81,
									"y": 63.84,
									"z": 0.5
								},
								{
									"x": 175.82,
									"y": 63.95,
									"z": 0.5
								},
								{
									"x": 172.76,
									"y": 68.43,
									"z": 0.5
								},
								{
									"x": 170.66,
									"y": 80.02,
									"z": 0.5
								},
								{
									"x": 169.83,
									"y": 96.5,
									"z": 0.5
								},
								{
									"x": 171.36,
									"y": 115.16,
									"z": 0.5
								},
								{
									"x": 175.26,
									"y": 128.82,
									"z": 0.5
								},
								{
									"x": 180.67,
									"y": 136.26,
									"z": 0.5
								},
								{
									"x": 187.09,
									"y": 140.58,
									"z": 0.5
								},
								{
									"x": 193.12,
									"y": 140.88,
									"z": 0.5
								},
								{
									"x": 199.64,
									"y": 134.48,
									"z": 0.5
								},
								{
									"x": 207.02,
									"y": 120.32,
									"z": 0.5
								},
								{
									"x": 213.03,
									"y": 103.6,
									"z": 0.5
								},
								{
									"x": 216.17,
									"y": 90.35,
									"z": 0.5
								},
								{
									"x": 217.28,
									"y": 81.68,
									"z": 0.5
								},
								{
									"x": 217.74,
									"y": 76.23,
									"z": 0.5
								},
								{
									"x": 217.66,
									"y": 74.24,
									"z": 0.5
								},
								{
									"x": 217.05,
									"y": 74.53,
									"z": 0.5
								},
								{
									"x": 215.91,
									"y": 79.41,
									"z": 0.5
								},
								{
									"x": 215.21,
									"y": 90.56,
									"z": 0.5
								},
								{
									"x": 215.13,
									"y": 104.09,
									"z": 0.5
								},
								{
									"x": 215.88,
									"y": 113.92,
									"z": 0.5
								},
								{
									"x": 218.83,
									"y": 120,
									"z": 0.5
								},
								{
									"x": 223.3,
									"y": 124.19,
									"z": 0.5
								},
								{
									"x": 227.71,
									"y": 125.39,
									"z": 0.5
								},
								{
									"x": 232.17,
									"y": 123.21,
									"z": 0.5
								},
								{
									"x": 236.51,
									"y": 115.61,
									"z": 0.5
								},
								{
									"x": 240.17,
									"y": 103.63,
									"z": 0.5
								},
								{
									"x": 242.44,
									"y": 92.33,
									"z": 0.5
								},
								{
									"x": 243.3,
									"y": 83.07,
									"z": 0.5
								},
								{
									"x": 243.52,
									"y": 76.01,
									"z": 0.5
								},
								{
									"x": 243.52,
									"y": 72.19,
									"z": 0.5
								},
								{
									"x": 243.35,
									"y": 70.46,
									"z": 0.5
								},
								{
									"x": 243.19,
									"y": 70.11,
									"z": 0.5
								},
								{
									"x": 243.9,
									"y": 71.26,
									"z": 0.5
								},
								{
									"x": 249,
									"y": 75.84,
									"z": 0.5
								},
								{
									"x": 260.58,
									"y": 85.07,
									"z": 0.5
								},
								{
									"x": 276.09,
									"y": 98.02,
									"z": 0.5
								},
								{
									"x": 291.7,
									"y": 113.78,
									"z": 0.5
								},
								{
									"x": 302.66,
									"y": 132.02,
									"z": 0.5
								},
								{
									"x": 307.07,
									"y": 155.19,
									"z": 0.5
								},
								{
									"x": 301.63,
									"y": 180.46,
									"z": 0.5
								},
								{
									"x": 279.7,
									"y": 204.16,
									"z": 0.5
								},
								{
									"x": 251.84,
									"y": 221.13,
									"z": 0.5
								},
								{
									"x": 227.02,
									"y": 228.63,
									"z": 0.5
								},
								{
									"x": 207.41,
									"y": 230.88,
									"z": 0.5
								},
								{
									"x": 195.65,
									"y": 227.65,
									"z": 0.5
								},
								{
									"x": 190.99,
									"y": 216.82,
									"z": 0.5
								},
								{
									"x": 200.69,
									"y": 197.52,
									"z": 0.5
								},
								{
									"x": 229.42,
									"y": 170.67,
									"z": 0.5
								},
								{
									"x": 272.13,
									"y": 137.71,
									"z": 0.5
								},
								{
									"x": 318.65,
									"y": 101.51,
									"z": 0.5
								},
								{
									"x": 352.09,
									"y": 71.88,
									"z": 0.5
								},
								{
									"x": 368.29,
									"y": 50.72,
									"z": 0.5
								},
								{
									"x": 374.72,
									"y": 33.76,
									"z": 0.5
								},
								{
									"x": 370.11,
									"y": 22.56,
									"z": 0.5
								},
								{
									"x": 352.23,
									"y": 17.24,
									"z": 0.5
								},
								{
									"x": 328.26,
									"y": 16.93,
									"z": 0.5
								},
								{
									"x": 308.98,
									"y": 20.41,
									"z": 0.5
								},
								{
									"x": 295.36,
									"y": 25.56,
									"z": 0.5
								},
								{
									"x": 287.54,
									"y": 29.66,
									"z": 0.5
								},
								{
									"x": 285.12,
									"y": 33.56,
									"z": 0.5
								}
							]
						}
					],
					"color": "black",
					"fill": "none",
					"dash": "draw",
					"size": "m",
					"isComplete": true,
					"isClosed": false,
					"isPen": false
				},
				"parentId": "page:page",
				"index": "a1",
				"typeName": "shape"
			},
			"shape:spF8FvYHC4kgqB47r37mK": {
				"x": 785.953125,
				"y": 500.17968750000006,
				"rotation": 0,
				"isLocked": false,
				"opacity": 1,
				"meta": {},
				"id": "shape:spF8FvYHC4kgqB47r37mK",
				"type": "text",
				"props": {
					"color": "black",
					"size": "m",
					"w": 133.484375,
					"text": "It worked!",
					"font": "draw",
					"textAlign": "middle",
					"autoSize": true,
					"scale": 1
				},
				"parentId": "page:page",
				"index": "a2",
				"typeName": "shape"
			},
			"shape:KJLXYWg4MhLdEC8kVQQ75": {
				"x": 818.50390625,
				"y": 544.7734375,
				"rotation": 0,
				"isLocked": false,
				"opacity": 1,
				"meta": {},
				"id": "shape:KJLXYWg4MhLdEC8kVQQ75",
				"type": "draw",
				"props": {
					"segments": [
						{
							"type": "free",
							"points": [
								{
									"x": 0,
									"y": 0,
									"z": 0.5
								}
							]
						}
					],
					"color": "black",
					"fill": "none",
					"dash": "draw",
					"size": "m",
					"isComplete": true,
					"isClosed": false,
					"isPen": false
				},
				"parentId": "page:page",
				"index": "a3",
				"typeName": "shape"
			},
			"shape:GwMBhbVosBM4LgbieiieF": {
				"x": 860.21484375,
				"y": 544.7734375,
				"rotation": 0,
				"isLocked": false,
				"opacity": 1,
				"meta": {},
				"id": "shape:GwMBhbVosBM4LgbieiieF",
				"type": "draw",
				"props": {
					"segments": [
						{
							"type": "free",
							"points": [
								{
									"x": 0,
									"y": 0,
									"z": 0.5
								},
								{
									"x": 0.3,
									"y": 0,
									"z": 0.5
								}
							]
						}
					],
					"color": "black",
					"fill": "none",
					"dash": "draw",
					"size": "m",
					"isComplete": true,
					"isClosed": false,
					"isPen": false
				},
				"parentId": "page:page",
				"index": "a4",
				"typeName": "shape"
			},
			"shape:nRD0YHPlKTcnKbruTutgN": {
				"x": 831.80078125,
				"y": 551.25390625,
				"rotation": 0,
				"isLocked": false,
				"opacity": 1,
				"meta": {},
				"id": "shape:nRD0YHPlKTcnKbruTutgN",
				"type": "draw",
				"props": {
					"segments": [
						{
							"type": "free",
							"points": [
								{
									"x": 0,
									"y": 0,
									"z": 0.5
								},
								{
									"x": -0.27,
									"y": 0,
									"z": 0.5
								},
								{
									"x": -0.53,
									"y": 0.21,
									"z": 0.5
								},
								{
									"x": -0.64,
									"y": 0.55,
									"z": 0.5
								},
								{
									"x": -1.63,
									"y": 1.37,
									"z": 0.5
								},
								{
									"x": -3.02,
									"y": 2.95,
									"z": 0.5
								},
								{
									"x": -4.45,
									"y": 4.56,
									"z": 0.5
								},
								{
									"x": -5.67,
									"y": 5.6,
									"z": 0.5
								},
								{
									"x": -6.29,
									"y": 6.38,
									"z": 0.5
								},
								{
									"x": -6.71,
									"y": 6.99,
									"z": 0.5
								},
								{
									"x": -6.83,
									"y": 7.24,
									"z": 0.5
								},
								{
									"x": -6.66,
									"y": 7.36,
									"z": 0.5
								},
								{
									"x": -6.21,
									"y": 7.36,
									"z": 0.5
								},
								{
									"x": -5.64,
									"y": 7.36,
									"z": 0.5
								},
								{
									"x": -5.07,
									"y": 7.36,
									"z": 0.5
								},
								{
									"x": -4.51,
									"y": 7.36,
									"z": 0.5
								},
								{
									"x": -3.95,
									"y": 7.36,
									"z": 0.5
								},
								{
									"x": -3.42,
									"y": 7.36,
									"z": 0.5
								},
								{
									"x": -2.86,
									"y": 7.36,
									"z": 0.5
								},
								{
									"x": -2.35,
									"y": 7.36,
									"z": 0.5
								},
								{
									"x": -2.07,
									"y": 7.36,
									"z": 0.5
								}
							]
						}
					],
					"color": "black",
					"fill": "none",
					"dash": "draw",
					"size": "m",
					"isComplete": true,
					"isClosed": false,
					"isPen": false
				},
				"parentId": "page:page",
				"index": "a5",
				"typeName": "shape"
			},
			"shape:3-lPfp0w5eiv_eBk9MINZ": {
				"x": 807.5390625,
				"y": 565.74609375,
				"rotation": 0,
				"isLocked": false,
				"opacity": 1,
				"meta": {},
				"id": "shape:3-lPfp0w5eiv_eBk9MINZ",
				"type": "draw",
				"props": {
					"segments": [
						{
							"type": "free",
							"points": [
								{
									"x": 0,
									"y": 0,
									"z": 0.5
								},
								{
									"x": 0.11,
									"y": 0,
									"z": 0.5
								},
								{
									"x": 1.04,
									"y": 0.44,
									"z": 0.5
								},
								{
									"x": 2.73,
									"y": 1.43,
									"z": 0.5
								},
								{
									"x": 6.05,
									"y": 2.77,
									"z": 0.5
								},
								{
									"x": 10.5,
									"y": 4.27,
									"z": 0.5
								},
								{
									"x": 15.84,
									"y": 5.84,
									"z": 0.5
								},
								{
									"x": 21.36,
									"y": 6.87,
									"z": 0.5
								},
								{
									"x": 26.98,
									"y": 7.38,
									"z": 0.5
								},
								{
									"x": 33.31,
									"y": 8.23,
									"z": 0.5
								},
								{
									"x": 40.36,
									"y": 9.04,
									"z": 0.5
								},
								{
									"x": 46.94,
									"y": 9.46,
									"z": 0.5
								},
								{
									"x": 52,
									"y": 9.61,
									"z": 0.5
								},
								{
									"x": 57.39,
									"y": 9.61,
									"z": 0.5
								},
								{
									"x": 63.11,
									"y": 9.11,
									"z": 0.5
								},
								{
									"x": 68.55,
									"y": 7.86,
									"z": 0.5
								},
								{
									"x": 73,
									"y": 6.53,
									"z": 0.5
								},
								{
									"x": 76.1,
									"y": 5.38,
									"z": 0.5
								},
								{
									"x": 77.62,
									"y": 4.19,
									"z": 0.5
								},
								{
									"x": 78.33,
									"y": 3.05,
									"z": 0.5
								},
								{
									"x": 78.68,
									"y": 1.89,
									"z": 0.5
								},
								{
									"x": 78.83,
									"y": 0.77,
									"z": 0.5
								},
								{
									"x": 78.96,
									"y": -0.21,
									"z": 0.5
								},
								{
									"x": 79.11,
									"y": -0.96,
									"z": 0.5
								},
								{
									"x": 79.39,
									"y": -1.52,
									"z": 0.5
								},
								{
									"x": 79.66,
									"y": -1.93,
									"z": 0.5
								},
								{
									"x": 79.79,
									"y": -2.2,
									"z": 0.5
								},
								{
									"x": 79.79,
									"y": -2.44,
									"z": 0.5
								},
								{
									"x": 79.79,
									"y": -2.64,
									"z": 0.5
								},
								{
									"x": 79.79,
									"y": -2.76,
									"z": 0.5
								}
							]
						}
					],
					"color": "black",
					"fill": "none",
					"dash": "draw",
					"size": "m",
					"isComplete": true,
					"isClosed": false,
					"isPen": false
				},
				"parentId": "page:page",
				"index": "a6",
				"typeName": "shape"
			},
			"shape:h0jgec1IGyVzAk9aCJ_-_": {
				"x": 750.671875,
				"y": 605.2578125,
				"rotation": 0,
				"isLocked": false,
				"opacity": 1,
				"meta": {},
				"id": "shape:h0jgec1IGyVzAk9aCJ_-_",
				"type": "image",
				"props": {
					"w": 121,
					"h": 58,
					"assetId": "asset:-2122303015",
					"playing": true,
					"url": "",
					"crop": null
				},
				"parentId": "page:page",
				"index": "a7",
				"typeName": "shape"
			}
		},
		"schema": {
			"schemaVersion": 2,
			"sequences": {
				"com.tldraw.store": 4,
				"com.tldraw.asset": 1,
				"com.tldraw.camera": 1,
				"com.tldraw.document": 2,
				"com.tldraw.instance": 25,
				"com.tldraw.instance_page_state": 5,
				"com.tldraw.page": 1,
				"com.tldraw.instance_presence": 5,
				"com.tldraw.pointer": 1,
				"com.tldraw.shape": 4,
				"com.tldraw.asset.bookmark": 1,
				"com.tldraw.asset.image": 3,
				"com.tldraw.asset.video": 3,
				"com.tldraw.shape.group": 0,
				"com.tldraw.shape.text": 2,
				"com.tldraw.shape.bookmark": 2,
				"com.tldraw.shape.draw": 1,
				"com.tldraw.shape.geo": 8,
				"com.tldraw.shape.note": 6,
				"com.tldraw.shape.line": 4,
				"com.tldraw.shape.frame": 0,
				"com.tldraw.shape.arrow": 4,
				"com.tldraw.shape.highlight": 0,
				"com.tldraw.shape.embed": 4,
				"com.tldraw.shape.image": 3,
				"com.tldraw.shape.video": 2,
				"com.tldraw.binding.arrow": 0
			}
		}
	},
	"session": {
		"version": 0,
		"currentPageId": "page:page",
		"exportBackground": true,
		"isFocusMode": false,
		"isDebugMode": true,
		"isToolLocked": false,
		"isGridMode": false,
		"pageStates": [
			{
				"pageId": "page:page",
				"camera": {
					"x": -367.0381641329634,
					"y": -293.85384513339864,
					"z": 1
				},
				"selectedShapeIds": [],
				"focusedGroupId": null
			}
		]
	}
}
```

## Store events

Keywords: listen, changes

Listen to changes from tldraw's store.

Try creating & deleting shapes, or switching pages. The changes will be logged next to the canvas.

### App.tsx

```tsx
import _ from 'lodash'
import { useCallback, useEffect, useState } from 'react'
import { Editor, TLEventMapHandler, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

export default function StoreEventsExample() {
	const [editor, setEditor] = useState<Editor>()

	const setAppToState = useCallback((editor: Editor) => {
		setEditor(editor)
	}, [])

	const [storeEvents, setStoreEvents] = useState<string[]>([])

	useEffect(() => {
		if (!editor) return

		function logChangeEvent(eventName: string) {
			setStoreEvents((events) => [...events, eventName])
		}

		//[1]
		const handleChangeEvent: TLEventMapHandler<'change'> = (change) => {
			// Added
			for (const record of Object.values(change.changes.added)) {
				if (record.typeName === 'shape') {
					logChangeEvent(`created shape (${record.type})\n`)
				}
			}

			// Updated
			for (const [from, to] of Object.values(change.changes.updated)) {
				if (
					from.typeName === 'instance' &&
					to.typeName === 'instance' &&
					from.currentPageId !== to.currentPageId
				) {
					logChangeEvent(`changed page (${from.currentPageId}, ${to.currentPageId})`)
				} else if (from.id.startsWith('shape') && to.id.startsWith('shape')) {
					let diff = _.reduce(
						from,
						(result: any[], value, key: string) =>
							_.isEqual(value, (to as any)[key]) ? result : result.concat([key, (to as any)[key]]),
						[]
					)
					if (diff?.[0] === 'props') {
						diff = _.reduce(
							(from as any).props,
							(result: any[], value, key) =>
								_.isEqual(value, (to as any).props[key])
									? result
									: result.concat([key, (to as any).props[key]]),
							[]
						)
					}
					logChangeEvent(`updated shape (${JSON.stringify(diff)})\n`)
				}
			}

			// Removed
			for (const record of Object.values(change.changes.removed)) {
				if (record.typeName === 'shape') {
					logChangeEvent(`deleted shape (${record.type})\n`)
				}
			}
		}

		// [2]
		const cleanupFunction = editor.store.listen(handleChangeEvent, { source: 'user', scope: 'all' })

		return () => {
			cleanupFunction()
		}
	}, [editor])

	return (
		<div style={{ display: 'flex' }}>
			<div style={{ width: '60%', height: '100vh' }}>
				<Tldraw onMount={setAppToState} />
			</div>
			<div
				style={{
					width: '40%',
					height: '100vh',
					padding: 8,
					background: '#eee',
					border: 'none',
					fontFamily: 'monospace',
					fontSize: 12,
					borderLeft: 'solid 2px #333',
					display: 'flex',
					flexDirection: 'column-reverse',
					overflow: 'auto',
				}}
				onCopy={(event) => event.stopPropagation()}
			>
				<pre>{storeEvents}</pre>
			</div>
		</div>
	)
}

/* 
This example shows how to listen to store events. This includes things creating/deleting shapes,
or moving between pages, but not things such as pointer and keyboard events. Those are canvas events.
To listen to changes to the canvas, check out the canvas events example.

[1]
This is the fire hose, it will be called at the end of every transaction. We're checking to see what 
kind of changes were made and logging a more readable message to the to our panel.

[2]
This is the function that subscribes to changes to the store. You pass in the callback function that 
you want to execute along with a handy filter object. In this case, we're only listening to changes
that were made by the user. It also returns a cleanup function that you can shove into the return of 
a useeffect hook.

*/
```

## Camera options

Keywords: api, fixed, constraints, camera bounds, pan speed, zoom speed

You can set the camera's options and constraints.

The `Tldraw` component provides a prop, `cameraOptions`, that can be used to set the camera's constraints, zoom behavior, and other options.

### App.tsx

```tsx
import { useEffect } from 'react'
import {
	BoxModel,
	TLCameraOptions,
	Tldraw,
	Vec,
	clamp,
	track,
	useEditor,
	useLocalStorageState,
} from 'tldraw'
import 'tldraw/tldraw.css'

const CAMERA_OPTIONS: TLCameraOptions = {
	isLocked: false,
	wheelBehavior: 'pan',
	panSpeed: 1,
	zoomSpeed: 1,
	zoomSteps: [0.1, 0.25, 0.5, 1, 2, 4, 8],
	constraints: {
		initialZoom: 'fit-max',
		baseZoom: 'fit-max',
		bounds: {
			x: 0,
			y: 0,
			w: 1600,
			h: 900,
		},
		behavior: { x: 'contain', y: 'contain' },
		padding: { x: 100, y: 100 },
		origin: { x: 0.5, y: 0.5 },
	},
}

const BOUNDS_SIZES: Record<string, BoxModel> = {
	a4: { x: 0, y: 0, w: 1050, h: 1485 },
	landscape: { x: 0, y: 0, w: 1600, h: 900 },
	portrait: { x: 0, y: 0, w: 900, h: 1600 },
	square: { x: 0, y: 0, w: 900, h: 900 },
}

export default function CameraOptionsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// persistenceKey="camera-options"
				components={components}
			>
				<CameraOptionsControlPanel />
			</Tldraw>
		</div>
	)
}

const PaddingDisplay = track(() => {
	const editor = useEditor()
	const cameraOptions = editor.getCameraOptions()

	if (!cameraOptions.constraints) return null

	const {
		constraints: {
			padding: { x: px, y: py },
		},
	} = cameraOptions

	return (
		<div
			style={{
				position: 'absolute',
				top: py,
				left: px,
				width: `calc(100% - ${px * 2}px)`,
				height: `calc(100% - ${py * 2}px)`,
				border: '1px dotted var(--color-text)',
				pointerEvents: 'none',
			}}
		/>
	)
})

const BoundsDisplay = track(() => {
	const editor = useEditor()
	const cameraOptions = editor.getCameraOptions()

	if (!cameraOptions.constraints) return null

	const {
		constraints: {
			bounds: { x, y, w, h },
		},
	} = cameraOptions

	const d = Vec.ToAngle({ x: w, y: h }) * (180 / Math.PI)
	const colB = '#00000002'
	const colA = '#0000001F'

	return (
		<>
			<div
				style={{
					position: 'absolute',
					top: y,
					left: x,
					width: w,
					height: h,
					// grey and white stripes
					border: '1px dashed var(--color-text)',
					backgroundImage: `
			
				`,
					backgroundSize: '200px 200px',
					backgroundPosition: '0 0, 0 100px, 100px -100px, -100px 0px',
				}}
			>
				<div
					style={{
						position: 'absolute',
						top: 0,
						left: 0,
						width: '100%',
						height: '100%',
						backgroundImage: `
						linear-gradient(0deg, ${colB} 0%, ${colA} 50%, ${colB} 50%, ${colA} 100%),
						linear-gradient(90deg, ${colB} 0%, ${colA} 50%, ${colB} 50%, ${colA} 100%),
						linear-gradient(${d}deg, ${colB} 0%, ${colA} 50%, ${colB} 50%, ${colA} 100%),
						linear-gradient(-${d}deg, ${colB} 0%, ${colA} 50%, ${colB} 50%, ${colA} 100%)`,
					}}
				></div>
			</div>
		</>
	)
})

const components = {
	// These components are just included for debugging / visualization!
	OnTheCanvas: BoundsDisplay,
	InFrontOfTheCanvas: PaddingDisplay,
}

const CameraOptionsControlPanel = track(() => {
	const editor = useEditor()

	const [cameraOptions, setCameraOptions] = useLocalStorageState('camera ex1', CAMERA_OPTIONS)

	useEffect(() => {
		if (!editor) return
		editor.run(() => {
			editor.setCameraOptions(cameraOptions)
			editor.setCamera(editor.getCamera(), {
				immediate: true,
			})
		})
	}, [editor, cameraOptions])

	const { constraints } = cameraOptions

	const updateOptions = (
		options: Partial<
			Omit<TLCameraOptions, 'constraints'> & {
				constraints: Partial<TLCameraOptions['constraints']>
			}
		>
	) => {
		const { constraints } = options
		const cameraOptions = editor.getCameraOptions()
		setCameraOptions({
			...cameraOptions,
			...options,
			constraints:
				constraints === undefined
					? cameraOptions.constraints
					: {
							...(cameraOptions.constraints! ?? CAMERA_OPTIONS.constraints),
							...constraints,
						},
		})
	}

	return (
		<div
			style={{
				pointerEvents: 'all',
				position: 'absolute',
				top: 50,
				left: 0,
				padding: 4,
				background: 'white',
				zIndex: 1000000,
			}}
		>
			<div
				style={{
					display: 'grid',
					gridTemplateColumns: 'auto 1fr',
					columnGap: 12,
					rowGap: 4,
					marginBottom: 12,
					alignItems: 'center',
					justifyContent: 'center',
				}}
			>
				<label htmlFor="lock">Lock</label>
				<select
					name="lock"
					value={cameraOptions.isLocked ? 'true' : 'false'}
					onChange={(e) => {
						const value = e.target.value
						updateOptions({
							...CAMERA_OPTIONS,
							isLocked: value === 'true',
						})
					}}
				>
					<option value="true">true</option>
					<option value="false">false</option>
				</select>
				<label htmlFor="wheelBehavior">Wheel behavior</label>
				<select
					name="wheelBehavior"
					value={cameraOptions.wheelBehavior}
					onChange={(e) => {
						const value = e.target.value
						updateOptions({
							...CAMERA_OPTIONS,
							wheelBehavior: value as 'zoom' | 'pan',
						})
					}}
				>
					<option>zoom</option>
					<option>pan</option>
				</select>
				<label htmlFor="panspeed">Pan Speed</label>
				<input
					name="panspeed"
					type="number"
					step={0.1}
					value={cameraOptions.panSpeed}
					onChange={(e) => {
						const val = clamp(Number(e.target.value), 0, 2)
						updateOptions({ panSpeed: val })
					}}
				/>
				<label htmlFor="zoomspeed">Zoom Speed</label>
				<input
					name="zoomspeed"
					type="number"
					step={0.1}
					value={cameraOptions.zoomSpeed}
					onChange={(e) => {
						const val = clamp(Number(e.target.value), 0, 2)
						updateOptions({ zoomSpeed: val })
					}}
				/>
				<label htmlFor="zoomsteps">Zoom Steps</label>
				<input
					name="zoomsteps"
					type="text"
					defaultValue={cameraOptions.zoomSteps.join(', ')}
					onChange={(e) => {
						try {
							const val = e.target.value.split(', ').map((v) => Number(v))
							if (val.every((v) => typeof v === 'number' && Number.isFinite(v))) {
								updateOptions({ zoomSteps: val })
							}
						} catch {
							// ignore
						}
					}}
				/>
				<label htmlFor="bounds">Bounds</label>
				<select
					name="bounds"
					value={
						Object.entries(BOUNDS_SIZES).find(([_, b]) => b.w === constraints?.bounds.w)?.[0] ??
						'none'
					}
					onChange={(e) => {
						const currentConstraints = constraints ?? CAMERA_OPTIONS.constraints
						const value = e.target.value

						if (value === 'none') {
							updateOptions({
								...CAMERA_OPTIONS,
								constraints: undefined,
							})
							return
						}

						updateOptions({
							...CAMERA_OPTIONS,
							constraints: {
								...currentConstraints,
								bounds: BOUNDS_SIZES[value] ?? BOUNDS_SIZES.a4,
							},
						})
					}}
				>
					<option value="none">none</option>
					<option value="a4">A4 Page</option>
					<option value="portrait">Portait</option>
					<option value="landscape">Landscape</option>
					<option value="square">Square</option>
				</select>
				{constraints ? (
					<>
						<label htmlFor="initialZoom">Initial Zoom</label>
						<select
							name="initialZoom"
							value={constraints.initialZoom}
							onChange={(e) => {
								updateOptions({
									constraints: {
										...constraints,
										initialZoom: e.target.value as any,
									},
								})
							}}
						>
							<option>fit-min</option>
							<option>fit-max</option>
							<option>fit-x</option>
							<option>fit-y</option>
							<option>fit-min-100</option>
							<option>fit-max-100</option>
							<option>fit-x-100</option>
							<option>fit-y-100</option>
							<option>default</option>
						</select>
						<label htmlFor="zoomBehavior">Base Zoom</label>
						<select
							name="zoomBehavior"
							value={constraints.baseZoom}
							onChange={(e) => {
								updateOptions({
									constraints: {
										...constraints,
										baseZoom: e.target.value as any,
									},
								})
							}}
						>
							<option>fit-min</option>
							<option>fit-max</option>
							<option>fit-x</option>
							<option>fit-y</option>
							<option>fit-min-100</option>
							<option>fit-max-100</option>
							<option>fit-x-100</option>
							<option>fit-y-100</option>
							<option>default</option>
						</select>
						<label htmlFor="originX">Origin X</label>
						<input
							name="originX"
							type="number"
							step={0.1}
							value={constraints.origin.x}
							onChange={(e) => {
								const val = clamp(Number(e.target.value), 0, 1)
								updateOptions({
									constraints: {
										origin: {
											...constraints.origin,
											x: val,
										},
									},
								})
							}}
						/>
						<label htmlFor="originY">Origin Y</label>
						<input
							name="originY"
							type="number"
							step={0.1}
							value={constraints.origin.y}
							onChange={(e) => {
								const val = clamp(Number(e.target.value), 0, 1)
								updateOptions({
									constraints: {
										...constraints,
										origin: {
											...constraints.origin,
											y: val,
										},
									},
								})
							}}
						/>
						<label htmlFor="paddingX">Padding X</label>
						<input
							name="paddingX"
							type="number"
							step={10}
							value={constraints.padding.x}
							onChange={(e) => {
								const val = clamp(Number(e.target.value), 0)
								updateOptions({
									constraints: {
										...constraints,
										padding: {
											...constraints.padding,
											x: val,
										},
									},
								})
							}}
						/>
						<label htmlFor="paddingY">Padding Y</label>
						<input
							name="paddingY"
							type="number"
							step={10}
							value={constraints.padding.y}
							onChange={(e) => {
								const val = clamp(Number(e.target.value), 0)
								updateOptions({
									constraints: {
										padding: {
											...constraints.padding,
											y: val,
										},
									},
								})
							}}
						/>
						<label htmlFor="behaviorX">Behavior X</label>
						<select
							name="behaviorX"
							value={(constraints.behavior as { x: any; y: any }).x}
							onChange={(e) => {
								setCameraOptions({
									...cameraOptions,
									constraints: {
										...constraints,
										behavior: {
											...(constraints.behavior as { x: any; y: any }),
											x: e.target.value as any,
										},
									},
								})
							}}
						>
							<option>free</option>
							<option>contain</option>
							<option>inside</option>
							<option>outside</option>
							<option>fixed</option>
						</select>
						<label htmlFor="behaviorY">Behavior Y</label>
						<select
							name="behaviorY"
							value={(constraints.behavior as { x: any; y: any }).y}
							onChange={(e) => {
								setCameraOptions({
									...cameraOptions,
									constraints: {
										...constraints,
										behavior: {
											...(constraints.behavior as { x: any; y: any }),
											y: e.target.value as any,
										},
									},
								})
							}}
						>
							<option>free</option>
							<option>contain</option>
							<option>inside</option>
							<option>outside</option>
							<option>fixed</option>
						</select>
					</>
				) : null}
			</div>
			<div style={{ display: 'flex', flexDirection: 'column', gap: 8 }}>
				<button
					onClick={() => {
						editor.setCamera(editor.getCamera(), { reset: true })
						// eslint-disable-next-line no-console
						console.log(editor.getCameraOptions())
					}}
				>
					Reset Camera
				</button>
				<button
					onClick={() => {
						updateOptions(CAMERA_OPTIONS)
					}}
				>
					Reset Camera Options
				</button>
			</div>
		</div>
	)
})
```

## Minimal

Keywords: select, tool, editor, bare, bones

Use the `<TldrawEditor/>` component to render a bare-bones editor with minimal built-in shapes and tools.

This example shows how the `<TldrawEditor/>` component can be used to render a bare-bones editor. It uses minimal built-in shapes and tools.

### App.tsx

```tsx
/* eslint-disable import/no-extraneous-dependencies */

import { Editor, TldrawEditor, createShapeId } from '@tldraw/editor'
import 'tldraw/tldraw.css'
import { MiniBoxShapeUtil } from './MiniBoxShape'
import { MiniSelectTool } from './MiniSelectTool'

// There's a guide at the bottom of this page!

// [1]
const myTools = [MiniSelectTool]
const myShapeUtils = [MiniBoxShapeUtil]

// [2]
export default function OnlyEditorExample() {
	return (
		<div className="tldraw__editor">
			<TldrawEditor
				tools={myTools}
				shapeUtils={myShapeUtils}
				initialState="select"
				onMount={(editor: Editor) => {
					editor
						.selectAll()
						.deleteShapes(editor.getSelectedShapeIds())
						.createShapes([
							{
								id: createShapeId(),
								type: 'box',
								x: 100,
								y: 100,
							},
						])
				}}
				components={{
					// [3]
					OnTheCanvas: () => {
						return (
							<div
								style={{
									position: 'absolute',
									transform: `translate(16px, 16px)`,
									width: '320px',
								}}
							>
								<p>Double click to create or delete shapes.</p>
								<p>Click or Shift+Click to select shapes.</p>
								<p>Click and drag to move shapes.</p>
							</div>
						)
					},
				}}
			/>
		</div>
	)
}

/*
This example shows how to use the TldrawEditor component on its own. This is useful if you want to
create your own custom UI, shape and tool interactions.

[1]
We create a custom tool and shape util arrays. These are arrays of classes that extend
the built-in state node and shape util classes. Check out MiniSelectTool.ts and
MiniBoxShapeUtil.tsx to see how they work. Or check out the custom config example for
a more in-depth look at how to create custom tools and shapes.

There is an even simpler implementation of the select tool in MicroSelectTool.tsx, but it
isn't used in this example.

[2]
We pass our custom tools and shape utils to the TldrawEditor component. We also pass in our custom
background component to the background prop and set the initial state to the 'select' tool.
*/
```
### MicroSelectTool.ts

```ts
import { StateNode, TLClickEventInfo, TLPointerEventInfo, createShapeId } from 'tldraw'

// There's a guide at the bottom of this file!

//[1]
export class MicroSelectTool extends StateNode {
	static override id = 'select'
	//[2]
	override onPointerDown(info: TLPointerEventInfo) {
		const { editor } = this

		switch (info.target) {
			case 'canvas': {
				const hitShape = editor.getShapeAtPoint(editor.inputs.currentPagePoint)

				if (hitShape) {
					this.onPointerDown({
						...info,
						shape: hitShape,
						target: 'shape',
					})
					return
				}

				editor.selectNone()
				break
			}
			case 'shape': {
				editor.select(info.shape.id)
				break
			}
		}
	}
	//[3]
	override onDoubleClick(info: TLClickEventInfo) {
		const { editor } = this

		if (info.phase !== 'up') return

		switch (info.target) {
			case 'canvas': {
				const hitShape = editor.getShapeAtPoint(editor.inputs.currentPagePoint)

				if (hitShape) {
					this.onDoubleClick({
						...info,
						shape: hitShape,
						target: 'shape',
					})
					return
				}
				const { currentPagePoint } = editor.inputs
				editor.createShapes([
					{
						id: createShapeId(),
						type: 'box',
						x: currentPagePoint.x - 50,
						y: currentPagePoint.y - 50,
						props: {
							w: 100,
							h: 100,
						},
					},
				])
				break
			}
			case 'shape': {
				editor.deleteShapes([info.shape.id])
				break
			}
		}
	}
}
/*
This is a very small example of a state node that implements a "select" tool. It
doesn't implement any children states. 

The state handles two events: onPointerDown [2] and onDoubleClick [2].

When the user points down on the canvas, it deselects all shapes; and when
they point a shape it selects that shape. When the user double clicks on the
canvas, it creates a new shape; and when they double click on a shape, it
deletes that shape.

[1]
This is where we define our state node by extending the StateNode class. Since 
there are no children states We can give it an id and define methods we
want to override to handle events.


[2] onPointerDown
	The user clicked on something, let's figure out what it was. We can
	access the editor via this.editor, and then use it to check if we hit
	a shape. If we did then we call the onPointerDown method again with the
	shape as the target, select the shape, and return. If we didn't hit a
	shape then we deselect all shapes.

[3] onDoubleClick
	The user double clicked on something, let's do the same as above. If we 
	hit a shape then we call the onDoubleClick method again with the shape as 
	the target, delete it, and return. If we didn't hit a shape then we create
	a new shape at the pointer's position.
*/
```
### MiniBoxShape.tsx

```tsx
import { BaseBoxShapeUtil, HTMLContainer, TLBaseShape } from 'tldraw'

// There's a guide at the bottom of this page!

// [1]
export type MiniBoxShape = TLBaseShape<'box', { w: number; h: number; color: string }>

// [2]
export class MiniBoxShapeUtil extends BaseBoxShapeUtil<MiniBoxShape> {
	//[a]
	static override type = 'box'
	//[b]
	override getDefaultProps(): MiniBoxShape['props'] {
		return { w: 100, h: 100, color: '#efefef' }
	}
	//[c]
	component(shape: MiniBoxShape) {
		return (
			<HTMLContainer>
				<div
					style={{
						width: shape.props.w,
						height: shape.props.h,
						border: '1px solid black',
						backgroundColor: shape.props.color,
						pointerEvents: 'all',
					}}
				/>
			</HTMLContainer>
		)
	}
	//[d]
	indicator(shape: MiniBoxShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}

/* 
This is our shape util, in tldraw all shapes extend the shape util class. In this
example we're extending the built-in BaseBoxShapeUtil class. This class provides
the functionality for our shape. 

[1]
The type for our shape, we can extend the built-in TLBaseShape generic to create ours.

[2]
The shape util itself. 
	[a] The type of shape this util is for, this should be the same as the first argument
		to the TLBaseShape generic.
	[b] The default props for our shape. These will be used when creating a new shape.
	[c] The component for our shape. This returns JSX and is what will be rendered on the 
		canvas. The HtmlContainer component is a div that provides some useful styles.
	[d] The indicator for our shape, this also returns JSX. This is what will be rendered 
		on the canvas when the shape is selected.
*/
```
### MiniSelectTool.ts

```ts
import {
	StateNode,
	TLClickEventInfo,
	TLPointerEventInfo,
	TLUnknownShape,
	createShapeId,
} from 'tldraw'
// There's a guide at the bottom of this file!

//[1]
export class MiniSelectTool extends StateNode {
	static override id = 'select'
	static override children() {
		return [IdleState, PointingState, DraggingState]
	}
	static override initial = 'idle'
}
//[2]
class IdleState extends StateNode {
	static override id = 'idle'
	//[a]
	override onPointerDown(info: TLPointerEventInfo) {
		const { editor } = this

		switch (info.target) {
			case 'canvas': {
				const hitShape = editor.getShapeAtPoint(editor.inputs.currentPagePoint)

				if (hitShape) {
					this.onPointerDown({
						...info,
						shape: hitShape,
						target: 'shape',
					})
					return
				}

				editor.selectNone()
				break
			}
			case 'shape': {
				if (editor.inputs.shiftKey) {
					editor.select(...editor.getSelectedShapeIds(), info.shape.id)
				} else {
					if (!editor.getSelectedShapeIds().includes(info.shape.id)) {
						editor.select(info.shape.id)
					}
					this.parent.transition('pointing', info)
				}
				break
			}
		}
	}
	//[b]
	override onDoubleClick(info: TLClickEventInfo) {
		const { editor } = this

		if (info.phase !== 'up') return

		switch (info.target) {
			case 'canvas': {
				const hitShape = editor.getShapeAtPoint(editor.inputs.currentPagePoint)

				if (hitShape) {
					this.onDoubleClick({
						...info,
						shape: hitShape,
						target: 'shape',
					})
					return
				}
				const { currentPagePoint } = editor.inputs
				editor.createShapes([
					{
						id: createShapeId(),
						type: 'box',
						x: currentPagePoint.x - 50,
						y: currentPagePoint.y - 50,
						props: {
							w: 100,
							h: 100,
						},
					},
				])
				break
			}
			case 'shape': {
				editor.deleteShapes([info.shape.id])
				break
			}
		}
	}
}

//[3]
class PointingState extends StateNode {
	static override id = 'pointing'
	//[a]
	override onPointerUp(info: TLPointerEventInfo) {
		this.parent.transition('idle', info)
	}
	//[b]
	override onPointerMove() {
		if (this.editor.inputs.isDragging) {
			this.parent.transition('dragging', { shapes: [...this.editor.getSelectedShapes()] })
		}
	}
}

//[4]
class DraggingState extends StateNode {
	static override id = 'dragging'
	//[a]
	private initialDraggingShapes = [] as TLUnknownShape[]
	//[b]
	override onEnter(info: { shapes: TLUnknownShape[] }) {
		this.initialDraggingShapes = info.shapes
	}
	//[c]
	override onPointerUp(info: TLPointerEventInfo) {
		this.parent.transition('idle', info)
	}
	//[d]
	override onPointerMove() {
		const { initialDraggingShapes } = this
		const { originPagePoint, currentPagePoint } = this.editor.inputs

		this.editor.updateShapes(
			initialDraggingShapes.map((shape) => {
				return {
					...shape,
					x: shape.x + (currentPagePoint.x - originPagePoint.x),
					y: shape.y + (currentPagePoint.y - originPagePoint.y),
				}
			})
		)
	}
}

/*
This is where we implement our select tool. In tldraw, tools are part of the
tldraw state chart. Check out the docs for more info: 
https://tldraw.dev/docs/editor#State-Chart


Our state node [1] has three children: idle [2], pointing [3], and dragging [4]. 
Only one child state can be "active" at a time. The parent state's initial active 
state is "idle". Certain events received by the child states will cause the parent
state to transition to another child state, making that state active instead.

Note that when `transition()` is called, the parent state will call the new
active state(s)'s `onEnter` method with the second argument passed to the
transition method. This is useful for passing data between states.

[1] 
This is where we define our state node by extending the StateNode class. We 
give it an id, a list of children states, and its initial active state.

[2]
The idle state is the tool's default state. This is where most of the action is.
We have some handy methods available to help us handle events:
	
	[a] onPointerDown
		The user clicked on something, let's figure out what it was. We can
		access the editor via this.editor, and then use it to check if we hit
		a shape. If we did then we call the onPointerDown method again with the
		shape as the target, select the shape and transition to the pointing state. 
		Otherwise we deselect everything.
	
	[b] onDoubleClick
		The user double clicked on something, let's do the same thing as above.
		If we hit a shape then we call the onDoubleClick method again with the
		shape as the target, and delete the shape. Otherwise we create a new shape.

[3]
The pointing state is something of a transitionary state. Its job is to transition 
to the dragging state when the user starts dragging, or go back to the idle state 
on pointer up.

	[a] onPointerUp
		The user let go of the mouse, let's go back to the idle state.
	[b] onPointerMove
		The user moved the mouse, let's double check they're dragging. If they are
		then let's transition to the dragging state and pass it the shapes that
		are being dragged.

[4]
The dragging state is where we actually move the shapes around. It's job is to
update the position of the shapes being dragged, and transition back to the idle
state when the user lets go of the mouse.

	[a] initialDraggingShapes
		We'll use this to keep track of the shapes being dragged when we enter
		the state.

	[b] onEnter
		When we enter the dragging state, we'll save the shapes being dragged.

	[c] onPointerUp
		The user let go of the mouse, let's go back to the idle state.

	[d] onPointerMove
		The user moved the mouse, let's update the position of the shapes being
		dragged using editor.updateShapes().
*/
```

## Sublibraries

Keywords: ui, components, utils

Tldraw is built from several sublibraries - like the editor, default shapes & tools, and UI.

For full customization, you can use these sublibraries directly, or replace them with your own.

### App.tsx

```tsx
import { useEffect } from 'react'
import {
	ContextMenu,
	DEFAULT_SUPPORTED_IMAGE_TYPES,
	DEFAULT_SUPPORT_VIDEO_TYPES,
	DefaultContextMenuContent,
	TldrawEditor,
	TldrawHandles,
	TldrawScribble,
	TldrawSelectionBackground,
	TldrawSelectionForeground,
	TldrawShapeIndicators,
	TldrawUi,
	defaultAddFontsFromNode,
	defaultBindingUtils,
	defaultShapeTools,
	defaultShapeUtils,
	defaultTools,
	registerDefaultExternalContentHandlers,
	registerDefaultSideEffects,
	tipTapDefaultExtensions,
	useEditor,
	useToasts,
	useTranslation,
} from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

// [1]
const defaultComponents = {
	Scribble: TldrawScribble,
	ShapeIndicators: TldrawShapeIndicators,
	CollaboratorScribble: TldrawScribble,
	SelectionForeground: TldrawSelectionForeground,
	SelectionBackground: TldrawSelectionBackground,
	Handles: TldrawHandles,
}

const allDefaultTools = [...defaultTools, ...defaultShapeTools]
const defaultTextOptions = {
	tipTapConfig: {
		extensions: tipTapDefaultExtensions,
	},
	addFontsFromNode: defaultAddFontsFromNode,
}

//[2]
export default function ExplodedExample() {
	return (
		<div className="tldraw__editor">
			<TldrawEditor
				initialState="select"
				shapeUtils={defaultShapeUtils}
				bindingUtils={defaultBindingUtils}
				tools={allDefaultTools}
				components={defaultComponents}
				persistenceKey="exploded-example"
				textOptions={defaultTextOptions}
			>
				<TldrawUi>
					<InsideEditorAndUiContext />
				</TldrawUi>
			</TldrawEditor>
		</div>
	)
}

function InsideEditorAndUiContext() {
	const editor = useEditor()
	const toasts = useToasts()
	const msg = useTranslation()

	// [3]
	useEffect(() => {
		registerDefaultExternalContentHandlers(editor, {
			maxImageDimension: 5000,
			maxAssetSize: 10 * 1024 * 1024, // 10mb
			acceptedImageMimeTypes: DEFAULT_SUPPORTED_IMAGE_TYPES,
			acceptedVideoMimeTypes: DEFAULT_SUPPORT_VIDEO_TYPES,
			toasts,
			msg,
		})

		const cleanupSideEffects = registerDefaultSideEffects(editor)

		return () => {
			cleanupSideEffects()
		}
	}, [editor, msg, toasts])

	return (
		<ContextMenu>
			<DefaultContextMenuContent />
		</ContextMenu>
	)
}

/* 
The tldraw library is built from many sublibraries. This example shows how to build the tldraw
component from its subcomponents for max customisation. You can edit, omit or add to these
subcomponents to create your app.

[1] Here we've imported some components from the tldraw library which we will later pass to the
TldrawEditor component. These components are not part of the more minimal defaults, so we need to
import them separately. For help creating your own components to pass into the components prop check
out the custom components example.

[2] Here we've passed the default components object to the TldrawEditor component. Along with
default tools and shapeutils, You could input your own custom shapes/tools here. For help creating
your own shapes/tools check out the custom config example.

We also set the initial state to 'select' and render the UI, context menu and canvas components. You
could add your own custom components here, omit these ones, and/or change the initial state of the
application to whatever you want. 

[3] Inside of the editor and UI context, we need to set up extra pieces to get the editor working
with our default shapes and tools. We register the default external content handlers, which sets up
handling for things like images and pasted content. We also register the default side effects, which
react to changes to the editor's store.

*/
```

## Text search

Keywords: zoom, pan, camera bounds, search, text

A simple example of how to use the API to search for text in shapes and display results in the `HelperButtons` part of the user interface.

### App.tsx

```tsx
import { TLComponents, TLUiOverrides, Tldraw, atom, track } from 'tldraw'
import 'tldraw/tldraw.css'
import { TextSearchPanel } from './TextSearchPanel'
import './text-search.css'

export const showSearch = atom('showSearch', false)

const components: TLComponents = {
	HelperButtons: TextSearchPanel,
}

const overrides: TLUiOverrides = {
	actions(_editor, actions) {
		return {
			...actions,
			'text-search': {
				id: 'text-search',
				label: 'Search',
				kbd: '$f',
				onSelect() {
					if (!showSearch.get()) {
						showSearch.set(true)
					}
				},
			},
		}
	},
}

const TextSearchExample = track(() => {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="text-search-example" overrides={overrides} components={components} />
		</div>
	)
})

export default TextSearchExample
```
### TextSearchPanel.tsx

```tsx
import { useEffect, useRef, useState } from 'react'
import {
	EASINGS,
	Editor,
	TLShape,
	TldrawUiButton,
	stopEventPropagation,
	track,
	useEditor,
} from 'tldraw'
import { showSearch } from './TextSearchExample'

interface SearchResult {
	text: string
	shape: TLShape
}

function moveToShape(editor: Editor, shape: TLShape) {
	const bounds = editor.getShapePageBounds(shape.id)
	if (!bounds) return
	editor.setSelectedShapes([shape.id])
	editor.zoomToSelection({
		animation: { duration: 500, easing: EASINGS.easeInOutCubic },
	})
}

function keyDown(e: React.KeyboardEvent) {
	if (e.key === 'Escape') {
		showSearch.set(false)
	}
}

function getShapesWithText(editor: Editor, text: string): SearchResult[] {
	if (!text || text.length === 0) return []
	const shapes = editor.getCurrentPageShapes()
	const result: SearchResult[] = []
	shapes.forEach((shape) => {
		const util = editor.getShapeUtil(shape)
		const shapeText = util.getText(shape)
		if (shapeText && shapeText.includes(text)) {
			result.push({ text: shapeText, shape })
		}
	})
	return result.sort((a, b) => a.text.localeCompare(b.text))
}

export const TextSearchPanel = track(() => {
	const editor = useEditor()
	const [searchText, setSearchText] = useState('')
	const inputRef = useRef<HTMLInputElement>(null)
	const isVisible = showSearch.get()

	useEffect(() => {
		if (isVisible) {
			setSearchText('')
			inputRef.current?.focus()
		}
	}, [isVisible])

	if (!isVisible) return null

	const results = getShapesWithText(editor, searchText)
	return (
		<div
			className="text-search-panel scroll-light"
			onPointerDown={(e) => stopEventPropagation(e)}
			onKeyDown={keyDown}
		>
			<input
				className="text-search-input"
				ref={inputRef}
				onChange={(e) => setSearchText(e.target.value)}
			></input>
			{results.map((result) => {
				return (
					<TldrawUiButton
						key={'text-search-panel-button:' + result.shape.id}
						type="normal"
						className="text-search-panel-button"
						onClick={() => moveToShape(editor, result.shape)}
					>
						{result.text}
					</TldrawUiButton>
				)
			})}
		</div>
	)
})
```
### text-search.css

```css
.text-search-panel {
	display: flex;
	flex-direction: column;
	gap: 4px;
	max-height: calc(100% - 110px);
	margin: 50px 0px;
	padding: 4px;
	background-color: var(--color-low);
	pointer-events: all;
	border-top-right-radius: var(--radius-4);
	border-bottom-right-radius: var(--radius-4);
	overflow: auto;
	border-right: 2px solid var(--color-background);
	border-bottom: 2px solid var(--color-background);
	border-top: 2px solid var(--color-background);
}

.text-search-panel-button {
	border-radius: var(--radius-4);
	outline-offset: -1px;
}

.text-search-shape-label {
	pointer-events: all;
	position: absolute;
	background: var(--color-low);
	padding: calc(12px * var(--tl-scale));
	border-bottom-right-radius: calc(var(--radius-4) * var(--tl-scale));
	font-size: calc(12px * var(--tl-scale));
	color: var(--color-text);
	white-space: nowrap;
}

.text-search-input {
	border-radius: var(--radius-2);
	margin: 4px;
}
```

## Before create/update shape

Keywords: handler, register, side effects, records

Register a handler to run before shapes are created or updated.

You can intercept the creation or update of any record in the store and return a new record to be
used in it place. In this example, we lock shapes to a circle in the center of the screen.

### App.tsx

```tsx
import { Box, Editor, SVGContainer, TLShape, Tldraw, Vec, isShapeId } from 'tldraw'
import 'tldraw/tldraw.css'

// This function takes a shape and returns a new shape where the x/y origin is within `radius`
// distance of the center of the page. If the shape is already within `radius` (or isn't parented to
// the page) it returns the same shape.
function constrainShapeToRadius(editor: Editor, shape: TLShape, radius: number) {
	// if the shape is parented to another shape (instead of the page) leave it as-is
	if (isShapeId(shape.parentId)) return shape

	// get the position of the shape
	const shapePoint = Vec.From(shape)
	const distanceFromCenter = shapePoint.len()

	// if the shape is outside the radius, move it to the edge of the radius:
	if (distanceFromCenter > radius) {
		const newPoint = shapePoint.norm().mul(radius)
		return {
			...shape,
			x: newPoint.x,
			y: newPoint.y,
		}
	}

	// otherwise, leave the shape as-is
	return shape
}

export default function BeforeCreateUpdateShapeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					// we can run our `constrainShapeToRadius` function before any shape is created
					// or changed. These `sideEffects` handlers let us take modify the shape that
					// will be created or updated by returning a new one to be used in its place.
					editor.sideEffects.registerBeforeCreateHandler('shape', (shape) => {
						return constrainShapeToRadius(editor, shape, 500)
					})
					editor.sideEffects.registerBeforeChangeHandler('shape', (prevShape, nextShape) => {
						return constrainShapeToRadius(editor, nextShape, 500)
					})

					// center the camera on the area we're constraining shapes to
					editor.zoomToBounds(new Box(-500, -500, 1000, 1000))

					// lock the camera on that area
					editor.setCameraOptions({ isLocked: true })
				}}
				components={{
					// to make it a little clearer what's going on in this example, we'll draw a
					// circle on the canvas showing where shapes are being constrained to.
					OnTheCanvas: () => (
						<SVGContainer>
							<circle cx={0} cy={0} r={500} fill="none" stroke="black" />
						</SVGContainer>
					),
				}}
			/>
		</div>
	)
}
```

## Before delete shape

Keywords: handler, register, side effects, records

Register a handler to run before shapes are deleted.

You can intercept the creation of any record in the store. This example intercepts arrow creation to
make sure each arrow has a label. You can do the same thing to change the props of any newly created
shape.

### App.tsx

```tsx
import { Editor, Tldraw, createShapeId, toRichText } from 'tldraw'
import 'tldraw/tldraw.css'

export default function BeforeDeleteShapeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					// register a handler to run before any shape is deleted:
					editor.sideEffects.registerBeforeDeleteHandler('shape', (shape) => {
						// if the shape is red, prevent the deletion:
						if ('color' in shape.props && shape.props.color === 'red') {
							return false
						}

						return
					})

					createDemoShapes(editor)
				}}
			/>
		</div>
	)
}

// create some shapes to demonstrate the side-effect we added
function createDemoShapes(editor: Editor) {
	editor
		.createShapes([
			{
				id: createShapeId(),
				type: 'text',
				props: {
					richText: toRichText("Red shapes can't be deleted"),
					color: 'red',
				},
			},
			{
				id: createShapeId(),
				type: 'text',
				y: 30,
				props: {
					richText: toRichText('but other shapes can'),
					color: 'black',
				},
			},
		])
		.zoomToFit({ animation: { duration: 0 } })
}
```

## After create/update shape

Keywords: handler, register, side effects, records

Register a handler to run after shapes are created or updated.

You can register handlers to run after any record is created or updated. This is most useful for
updating _other_ records in response to a particular record changing. In this example, we make sure
there's only ever one red shape on a page.

### App.tsx

```tsx
import { Editor, TLShape, TLShapeId, Tldraw, createShapeId, toRichText } from 'tldraw'

// this function takes a shape ID, and if that shape is red, sets all other red shapes on the same
// page to black.
function ensureOnlyOneRedShape(editor: Editor, shapeId: TLShapeId) {
	// grab the shape and check it's red:
	const shape = editor.getShape(shapeId)!
	if (!isRedShape(shape)) return

	// get the ID of the page that shape belongs to:
	const pageId = editor.getAncestorPageId(shape.id)!

	// find any other red shapes on the same page:
	const otherRedShapesOnPage = Array.from(editor.getPageShapeIds(pageId))
		.map((id) => editor.getShape(id)!)
		.filter((otherShape) => otherShape.id !== shape.id && isRedShape(otherShape))

	// set the color of all those shapes to black:
	editor.updateShapes(
		otherRedShapesOnPage.map((shape) => ({
			id: shape.id,
			type: shape.type,
			props: {
				color: 'black',
			},
		}))
	)
}

function isRedShape(shape: TLShape) {
	return 'color' in shape.props && shape.props.color === 'red'
}

export default function AfterCreateUpdateShapeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					// we can run our `ensureOnlyOneRedShape` function after any shape is created or
					// changed. this means we can enforce our "only one red shape at a time" rule,
					// while making sure that the shape most recently set to red is the one that
					// stays red.
					editor.sideEffects.registerAfterCreateHandler('shape', (shape) => {
						ensureOnlyOneRedShape(editor, shape.id)
					})
					editor.sideEffects.registerAfterChangeHandler('shape', (prevShape, nextShape) => {
						ensureOnlyOneRedShape(editor, nextShape.id)
					})

					createDemoShapes(editor)
				}}
			/>
		</div>
	)
}

// create some shapes to demonstrate the side-effects we added
function createDemoShapes(editor: Editor) {
	editor
		.createShapes(
			'there can only be one red shape'.split(' ').map((word, i) => ({
				id: createShapeId(),
				type: 'text',
				y: i * 30,
				props: {
					color: i === 5 ? 'red' : 'black',
					richText: toRichText(word),
				},
			}))
		)
		.zoomToFit({ animation: { duration: 0 } })
}
```

## After delete shape

Keywords: handler, register, side effects, records

Register a handler to run after shapes are deleted.

You can register handlers to run after any record is deleted. In this example, we delete frames
after the last shape inside them is deleted.

### App.tsx

```tsx
import { Editor, Tldraw, createShapeId, toRichText } from 'tldraw'
import 'tldraw/tldraw.css'

export default function AfterDeleteShapeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					// register a handler to run after any shape is deleted:
					editor.sideEffects.registerAfterDeleteHandler('shape', (shape) => {
						// grab the parent of the shape and check if it's a frame:
						const parentShape = editor.getShape(shape.parentId)
						if (parentShape && parentShape.type === 'frame') {
							// if it is, get the IDs of all its remaining children:
							const siblings = editor.getSortedChildIdsForParent(parentShape.id)

							// if there are none (so the frame is empty), delete the frame:
							if (siblings.length === 0) {
								editor.deleteShape(parentShape.id)
							}
						}
					})

					createDemoShapes(editor)
				}}
			/>
		</div>
	)
}

// crate some demo shapes to show off the new side-effect we added
function createDemoShapes(editor: Editor) {
	const frameId = createShapeId()
	editor.createShapes([
		{
			id: frameId,
			type: 'frame',
			props: { w: 400, h: 200 },
		},
		{
			id: createShapeId(),
			type: 'text',
			parentId: frameId,
			x: 50,
			y: 40,
			props: {
				richText: toRichText('Frames will be deleted when their last child is.'),
				w: 300,
				autoSize: false,
			},
		},
		...[50, 180, 310].map((x) => ({
			id: createShapeId(),
			type: 'geo',
			parentId: frameId,
			x,
			y: 120,
			props: { w: 40, h: 40 },
		})),
	])

	editor.zoomToFit({ animation: { duration: 0 } })
}
```

## Multiplayer sync

Keywords: basic, intro, simple, quick, start, multiplayer, sync, collaboration

The `useSyncDemo` hook can be used to quickly prototype multiplayer experiences in tldraw using a demo backend that we host. Data is wiped after one day.

### App.tsx

```tsx
import { useSyncDemo } from '@tldraw/sync'
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function SyncDemoExample({ roomId }: { roomId: string }) {
	const store = useSyncDemo({ roomId })
	return (
		<div className="tldraw__editor">
			<Tldraw store={store} deepLinks />
		</div>
	)
}
```

## …with a custom shape

Keywords: basic, intro, simple, quick, start, multiplayer, sync, collaboration, custom shape

This example shows a custom shape in combination with tldraw sync.

### App.tsx

```tsx
import { useSyncDemo } from '@tldraw/sync'
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import { CounterShapeTool, CounterShapeUtil } from './CounterShape'
import { components, uiOverrides } from './ui'

const customShapes = [CounterShapeUtil]
const customTools = [CounterShapeTool]

export default function SyncDemoShapeExample({ roomId }: { roomId: string }) {
	const store = useSyncDemo({ roomId, shapeUtils: customShapes })
	return (
		<div className="tldraw__editor">
			<Tldraw
				store={store}
				shapeUtils={customShapes}
				tools={customTools}
				overrides={uiOverrides}
				components={components}
				deepLinks
			/>
		</div>
	)
}
```
### CounterShape.tsx

```tsx
import { MouseEvent } from 'react'
import {
	BaseBoxShapeTool,
	BaseBoxShapeUtil,
	HTMLContainer,
	T,
	TLBaseShape,
	stopEventPropagation,
} from 'tldraw'

type CounterShape = TLBaseShape<'counter', { w: number; h: number; count: number }>

export class CounterShapeUtil extends BaseBoxShapeUtil<CounterShape> {
	static override type = 'counter' as const
	static override props = {
		w: T.positiveNumber,
		h: T.positiveNumber,
		count: T.number,
	}

	override getDefaultProps() {
		return {
			w: 200,
			h: 200,
			count: 0,
		}
	}

	override component(shape: CounterShape) {
		const onClick = (event: MouseEvent, change: number) => {
			event.stopPropagation()
			this.editor.updateShape({
				id: shape.id,
				type: 'counter',
				props: { count: shape.props.count + change },
			})
		}

		return (
			<HTMLContainer
				style={{
					pointerEvents: 'all',
					background: '#efefef',
					display: 'flex',
					alignItems: 'center',
					justifyContent: 'center',
					gap: 8,
				}}
			>
				<button onClick={(e) => onClick(e, -1)} onPointerDown={stopEventPropagation}>
					-
				</button>
				<span>{shape.props.count}</span>
				<button onClick={(e) => onClick(e, 1)} onPointerDown={stopEventPropagation}>
					+
				</button>
			</HTMLContainer>
		)
	}

	override indicator(shape: CounterShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}

export class CounterShapeTool extends BaseBoxShapeTool {
	static override id = 'counter'
	override shapeType = 'counter'
}
```
### ui.tsx

```tsx
import {
	DefaultToolbar,
	DefaultToolbarContent,
	TLComponents,
	TLUiOverrides,
	TldrawUiMenuItem,
	useIsToolSelected,
	useTools,
} from 'tldraw'

export const uiOverrides: TLUiOverrides = {
	tools(editor, tools) {
		// Create a tool item in the ui's context.
		tools.counter = {
			id: 'counter',
			icon: 'color',
			label: 'counter',
			kbd: 'c',
			onSelect: () => {
				editor.setCurrentTool('counter')
			},
		}
		return tools
	},
}

export const components: TLComponents = {
	Toolbar: (props) => {
		const tools = useTools()
		const isCounterSelected = useIsToolSelected(tools['counter'])
		return (
			<DefaultToolbar {...props}>
				<TldrawUiMenuItem {...tools['counter']} isSelected={isCounterSelected} />
				<DefaultToolbarContent />
			</DefaultToolbar>
		)
	},
}
```

## …with custom presence

Keywords: basic, intro, simple, quick, start, multiplayer, sync, collaboration, presence

This example shows how to customize the presence data synced between different tldraw instances.

### App.tsx

```tsx
import { useSyncDemo } from '@tldraw/sync'
import { useEffect } from 'react'
import { Tldraw, getDefaultUserPresence, useAtom } from 'tldraw'
import 'tldraw/tldraw.css'

export default function SyncCustomUserExample({ roomId }: { roomId: string }) {
	// [1]
	const timer = useAtom('timer', Date.now())
	useEffect(() => {
		const tick = () => {
			timer.set(Date.now())
			frame = requestAnimationFrame(tick)
		}
		let frame = requestAnimationFrame(tick)
		return () => cancelAnimationFrame(frame)
	}, [timer])

	// [2]
	const store = useSyncDemo({
		roomId,
		getUserPresence(store, user) {
			// [2.1]
			const defaults = getDefaultUserPresence(store, user)
			if (!defaults) return null

			return {
				...defaults,

				// [2.2]
				camera: undefined,

				// [2.3]
				cursor: {
					...defaults.cursor,
					x: (defaults.cursor.x ?? 0) + 20 * Math.sin(timer.get() / 200),
					y: (defaults.cursor.y ?? 0) + 20 * Math.cos(timer.get() / 200),
				},
			}
		},
	})

	// [3]
	return (
		<div className="tldraw__editor">
			<Tldraw store={store} deepLinks />
		</div>
	)
}

/**
 * # Sync Custom User
 *
 * This example demonstrates how to use the sync demo server with custom presence state. The
 * presence state is synchronized to all other clients and used for multiplayer features like
 * cursors and viewport following. You can use custom presence state to change the data that's
 * synced to other clients, or remove parts you don't need for your app.
 *
 * 1. We create a timer that updates every frame. You don't need to do this in your app, it's just
 *    to power an animation. We store it in an `atom` so that changes to it will cause the presence
 *    info to update.
 *
 * 2. We create a multiplayer store using the userSyncDemo hook, and pass in a custom
 *    `getUserPresence` function to change the presence state that gets sent.
 *
 * 2.1. We get the default presence state using the `getDefaultUserPresence` function. If you wanted
 *    to send a very minimal set of presence data, you could avoid this part.
 *
 * 2.2. We remove the camera from the presence state. This means that the camera position won't be
 *    sent to other clients. Attempting to follow this users viewport will not work.
 *
 * 2.3. We update the cursor position and rotation based on the current time. This will make the
 *    cursor spin around in a circle.
 *
 * 3. We create a Tldraw component and pass in the multiplayer store. This will render the editor.
 */
```

## …with custom user data

Keywords: basic, intro, simple, quick, start, multiplayer, sync, collaboration, custom shape

This example shows how to integrate your own user data into tldraw sync.

### App.tsx

```tsx
import { useSyncDemo } from '@tldraw/sync'
import { useState } from 'react'
import { TLUserPreferences, Tldraw, useTldrawUser } from 'tldraw'
import 'tldraw/tldraw.css'

export default function SyncCustomUserExample({ roomId }: { roomId: string }) {
	// [1]
	const [userPreferences, setUserPreferences] = useState<TLUserPreferences>({
		id: 'user-' + Math.random(),
		name: 'Jimmothy',
		color: 'palevioletred',
		colorScheme: 'dark',
	})

	// [2]
	const store = useSyncDemo({ roomId, userInfo: userPreferences })

	// [3]
	const user = useTldrawUser({ userPreferences, setUserPreferences })

	// [4]
	return (
		<div className="tldraw__editor">
			<Tldraw store={store} user={user} deepLinks />
		</div>
	)
}

/**
 * # Sync Custom User
 *
 * This example demonstrates how to use the sync demo server with a custom user.
 *
 * You need access to two things to do this integration:
 *
 * - The user info
 * - A function to set the user info
 *
 * In this example we create an in-memory state for the user info, but in your system it's probably synchronized with a backend database somehow.
 *
 * 1. We get our user info and a function to set it from a `useState` hook. In your app this might come from a context provider or you might hook it up manually to your backend.
 * 2. We use the `useSyncDemo` hook to create the multiplayer store, and pass in the current user state as `userInfo`, which is a subset of the `userPreferences` type.
 * 3. We use the `useTLUser` hook to create a TLUser object, which allows the Editor to both read and update the user info and preferences.
 * 4. We render the `Tldraw` component with the multiplayer store and the user object.
 *
 * You can pass the same `user` object into the `useSync` hook if you're using your own server.
 */
```

## ... with private content

Keywords: basic, intro, simple, quick, start, multiplayer, sync, collaboration

Showing a simple example of how to show and hide private content in a multiplayer session based on a simple
data ownership model. Try it out by opening the example in two different tabs, toggling the private mode, and
drawing some shapes.

### App.tsx

```tsx
import { useSyncDemo } from '@tldraw/sync'
import React from 'react'
import {
	Atom,
	TLComponents,
	Tldraw,
	react,
	useAtom,
	useEditor,
	useIsToolSelected,
	useTools,
	useValue,
} from 'tldraw'
import 'tldraw/tldraw.css'
import { VisibilityOff, VisibilityOn } from '../../icons/icons'
import { Toggle } from './Toggle'
import './style.css'

// There's a guide at the bottom of this file!

// [1]
const PrivateModeContext = React.createContext<null | Atom<boolean>>(null)

const components: TLComponents = {
	// [2]
	InFrontOfTheCanvas: () => {
		const editor = useEditor()
		const isInSelectTool = useIsToolSelected(useTools().select)
		const userId = useValue('userId', () => editor.user.getId(), [])
		const myPrivateSelectedShapes = useValue(
			'private shapes',
			() =>
				editor
					.getSelectedShapes()
					.filter((shape) => !!shape.meta.private && shape.meta.ownerId === userId),
			[editor, userId]
		)

		// [3]
		const isPrivateMode$ = React.useContext(PrivateModeContext)!
		const isPrivateMode = useValue(isPrivateMode$)

		return (
			<>
				{isInSelectTool && myPrivateSelectedShapes.length > 0 ? (
					<div className="toggle-panel">
						<div>
							Make {myPrivateSelectedShapes.length} selected shape
							{myPrivateSelectedShapes.length > 1 ? 's' : ''} public?{' '}
						</div>
						<button
							onClick={() => {
								editor.markHistoryStoppingPoint()
								// [7]
								const allAffectedShapes = [
									...editor.getShapeAndDescendantIds(myPrivateSelectedShapes.map((s) => s.id)),
								].map((id) => editor.getShape(id)!)
								editor.updateShapes(
									allAffectedShapes.map((shape) => ({
										...shape,
										meta: { ...shape.meta, private: false },
									}))
								)
							}}
						>
							Yes
						</button>
					</div>
				) : (
					<div className="toggle-panel pointer" onClick={() => isPrivateMode$.update((v) => !v)}>
						{isPrivateMode ? <VisibilityOff fill="#444" /> : <VisibilityOn fill="#444" />}
						<div>Private mode</div>
						<Toggle isChecked={isPrivateMode} />
					</div>
				)}
			</>
		)
	},
}
function App({ roomId }: { roomId: string }) {
	const store = useSyncDemo({ roomId })
	const isPrivateMode$ = React.useContext(PrivateModeContext)!
	return (
		<div className="tldraw__editor">
			<Tldraw
				store={store}
				deepLinks
				// [4]
				isShapeHidden={(shape, editor) => {
					const userId = editor.user.getId()
					return !!shape.meta.private && shape.meta.ownerId !== userId
				}}
				onMount={(editor) => {
					// [5]
					editor.store.sideEffects.registerBeforeCreateHandler('shape', (shape) => {
						if ('private' in shape.meta) return shape
						return {
							...shape,
							meta: {
								...shape.meta,
								private: isPrivateMode$.get(),
								ownerId: editor.user.getId(),
							},
						}
					})

					// [6]
					return react('clean up selection', () => {
						const selectedShapes = editor.getSelectedShapes()
						const filteredSelectedShapes = selectedShapes.filter((s) => !editor.isShapeHidden(s))
						if (filteredSelectedShapes.length !== selectedShapes.length) {
							editor.select(...filteredSelectedShapes)
						}
					})
				}}
				components={components}
			/>
		</div>
	)
}

export default function SyncPrivateContentExample({ roomId }: { roomId: string }) {
	return (
		<PrivateModeContext.Provider value={useAtom('isPrivateDrawingMode', false)}>
			<App roomId={roomId} />
		</PrivateModeContext.Provider>
	)
}

/**
 * This example demonstrates how to create a 'private' drawing mode where any shapes created by one person cannot be seen by another.
 * It sets up a simple ownership system where each shape created is tagged with the id of the user who created it.
 * It also adds a boolean flag to each shape called 'private' which is set to true if the shape is created in private mode.
 * If the user selects one or more private shapes, they will be given the option to make them public.
 *
 * 1. We create a context to store the atom that will hold the state of the private drawing mode. We are using signals here but you can use any state management library you like.
 * 2. We override the `InFrontOfTheCanvas` component to add a tool panel at the top of the screen that allows the user to toggle private drawing mode on and off, and to make private shapes public.
 * 3. We use the context to get the atom that holds the state of the private drawing mode. We then have to call 'useValue' on the atom to get the current value in a reactive way.
 * 4. We override the `isShapeHidden` function to hide shapes that are private and not owned by the current user.
 * 5. We register a side effect that adds the 'private' and 'ownerId' meta fields to each shape created. We set the 'private' field to the current value of the private drawing mode atom.
 * 6. We register a side effect that cleans up the selection by removing any hidden shapes from the selection. This re-runs whenever the selection or the hidden state of a selected shape changes.
 * 7. Child shapes (e.g inside groups and frames) do not inherit the 'private' meta property from their parent. So when making a shape public, we decide to also make all descendant shapes public since this is most likely what the user intended.
 */
```
### Toggle.tsx

```tsx
export function Toggle({ isChecked }: { isChecked: boolean }) {
	const height = 20
	const width = 40
	const pillSize = height - 4
	return (
		<div
			style={{
				cursor: 'pointer',
				width,
				height,
				borderRadius: height / 2,
				backgroundColor: isChecked ? '#4bb05e' : '#999',
				display: 'flex',
				alignItems: 'center',
				justifyContent: isChecked ? 'flex-end' : 'flex-start',
				padding: 2,
			}}
		>
			{isChecked && (
				<div
					style={{ fontSize: 9, fontWeight: 600, color: 'white', position: 'relative', left: -3 }}
				>
					ON
				</div>
			)}
			<div
				style={{
					width: pillSize,
					height: pillSize,
					borderRadius: pillSize / 2,
					backgroundColor: 'white',
				}}
			/>
			{!isChecked && (
				<div
					style={{ fontSize: 9, fontWeight: 600, color: 'white', position: 'relative', right: -1 }}
				>
					OFF
				</div>
			)}
		</div>
	)
}
```
### style.css

```css
.toggle-panel {
	position: absolute;
	top: 10px;
	left: 50%;
	transform: translateX(-50%);
	border-radius: 8px;
	background: #efefef;
	box-shadow:
		0 0 0 1px rgba(0, 0, 0, 0.1),
		0 4px 8px rgba(0, 0, 0, 0.1);
	padding: 9px 10px 9px 15px;
	display: flex;
	align-items: center;
	gap: 10px;
}

.toggle-panel button {
	cursor: pointer;
}

.toggle-panel.pointer {
	cursor: pointer;
}
```

## Canvas mask

Keywords: mask, window, clip

This example shows how you can mask the canvas.

The canvas has a white overlay. When you have a shape selected, the shape's bounds will be used as a mask through the overlay.

### App.tsx

```tsx
import { useEffect, useRef } from 'react'
import { TLComponents, TLShape, Tldraw, createShapeId, useEditor, useQuickReactor } from 'tldraw'
import 'tldraw/tldraw.css'
import './mask-window.css'

function MaskWindow() {
	const editor = useEditor()
	const ref = useRef<HTMLDivElement>(null)

	useQuickReactor(
		'clip',
		() => {
			const elm = ref.current
			if (!elm) return

			const rotation = editor.getSelectionRotation()
			const box = editor.getSelectionRotatedScreenBounds()

			if (!box) {
				// If there's nothing selected, clear the clip path
				elm.style.clipPath = ''
				return
			}

			// Expand the box and get the corners
			const { corners } = box.clone().expandBy(20)

			// Account for rotation by rotating the points of the rectangle
			const [tl, tr, br, bl] = corners.map((p) => p.rotWith(box.point, rotation))

			// Since there's no reliable "reverse clip path", we wind around the corners in order to turn our clip into a mask
			elm.style.clipPath = `polygon(0% 0%, ${tl.x}px 0%, ${tl.x}px ${tl.y}px, ${bl.x}px ${bl.y}px, ${br.x}px ${br.y}px, ${tr.x}px ${tr.y}px, ${tl.x}px ${tl.y}px, ${tl.x}px 0%, 100% 0%, 100% 100%, 0% 100%)`
		},
		[editor]
	)

	useExtraBonusStuff()

	return <div ref={ref} className="mask-fg" />
}

const components: TLComponents = {
	InFrontOfTheCanvas: () => {
		return <MaskWindow />
	},
}

export default function MaskWindowExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="mask" components={components} />
		</div>
	)
}

// Some extra stuff that isnt necessary but good for this demo
function useExtraBonusStuff() {
	const editor = useEditor()

	useEffect(() => {
		if (editor.getCurrentPageShapeIds().size === 0) {
			const vpb = editor.getViewportPageBounds()

			// if the canvas is empty, create some shapes for the demo
			for (let i = 0; i < 50; i++) {
				const x = vpb.x + Math.random() * vpb.w
				const y = vpb.y + Math.random() * vpb.h
				editor.createShape({ type: 'geo', x, y })
			}

			const id = createShapeId()
			const { center } = editor.getViewportPageBounds()
			editor.createShape({
				id,
				type: 'geo',
				x: center.x - 100,
				y: center.y - 100,
				props: {
					w: 200,
					h: 200,
				},
			})
			editor.select(id)
		}

		// As a (fragile) treat, press J to save positions for the selected shape, then press Ctrl+J to animate between positions
		const positions: TLShape[] = []

		const handleKeydown = (e: any) => {
			if (e.key === 'j') {
				e.preventDefault()
				e.stopPropagation()
				if (e.metaKey || e.ctrlKey) {
					const shape = positions.shift()
					if (!shape) return
					editor.animateShape(shape, { animation: { duration: 1000 } })
				} else {
					const shape = editor.getOnlySelectedShape()
					if (!shape) return
					positions.push(shape)
				}
			}
		}
		document.addEventListener('keydown', handleKeydown)
		return () => {
			document.removeEventListener('keydown', handleKeydown)
		}
	}, [editor])
}
```
### mask-window.css

```css
.mask-svg {
	position: absolute;
	top: 0px;
	left: 0px;
}

.mask-fg {
	position: absolute;
	top: 0px;
	left: 0px;
	width: 100%;
	height: 100%;
	pointer-events: none;
	background-color: rgba(255, 255, 255, 0.9);
	/* -webkit-mask:
		url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200" preserveAspectRatio="none"><rect x="100" y="100" width="20" height="20"/></svg>')
			0/100% 100%,
		linear-gradient(#fff, #fff);
	-webkit-mask-composite: destination-out;
	mask-composite: exclude; */
}
```

## Fog of war

Keywords: ui, fog, overlay

This example shows how you might keep an HTML canvas in sync with canvas content. It implements a simple "fog of war" effect, where the canvas is covered by a black overlay that can be cleared by drawing shapes on the canvas.

### App.tsx

```tsx
import { useEffect, useRef } from 'react'
import { Box, TLComponents, Tldraw, Vec, useEditor, useReactor } from 'tldraw'
import 'tldraw/tldraw.css'

const CELL_SIZE = 32
const COUNT = 100

const boxes: Box[][] = []
const cells: boolean[][] = []
for (let i = 0; i < COUNT; i++) {
	cells[i] = []
	boxes[i] = []
	for (let j = 0; j < COUNT; j++) {
		cells[i].push(false)
		boxes[i].push(
			new Box((i - COUNT / 2) * CELL_SIZE, (j - COUNT / 2) * CELL_SIZE, CELL_SIZE, CELL_SIZE)
		)
	}
}

export function Fog() {
	const rCanvas = useRef<HTMLCanvasElement>(null)
	const rVisibility = useRef<boolean[][]>(cells)
	const editor = useEditor()

	useEffect(() => {
		const cvs = rCanvas.current!
		const rect = cvs.getBoundingClientRect()
		cvs.width = rect.width
		cvs.height = rect.height
	}, [editor])

	useReactor(
		'update fog',
		() => {
			const cells = rVisibility.current
			const shapes = editor.getCurrentPageShapes()
			for (const shape of shapes) {
				const point = editor.getShapePageBounds(shape)!.point
				const geometry = editor.getShapeGeometry(shape)
				const adjustedPoint = Vec.Sub(point, geometry.bounds.point)
				for (let i = 0; i < boxes.length; i++) {
					for (let j = 0; j < boxes[i].length; j++) {
						const box = boxes[i][j]
						box.translate(Vec.Neg(adjustedPoint))
						if (geometry.bounds.collides(box)) {
							cells[i][j] = true
						}
						box.translate(adjustedPoint)
					}
				}
			}
			const cvs = rCanvas.current!
			const ctx = cvs.getContext('2d')!

			cvs.style.filter = `blur(${editor.getCamera().z * 15}px)`

			ctx.resetTransform()
			const camera = editor.getCamera()

			ctx.clearRect(0, 0, cvs.width, cvs.height)
			ctx.fillStyle = 'rgba(0,0,0,0.9)'
			ctx.fillRect(0, 0, cvs.width, cvs.height)

			ctx.translate(100, 100)
			ctx.scale(camera.z, camera.z)
			ctx.translate(camera.x, camera.y)

			for (let i = 0; i < boxes.length; i++) {
				for (let j = 0; j < boxes[i].length; j++) {
					if (!cells[i][j]) continue
					const box = boxes[i][j]
					ctx.clearRect(box.x, box.y, box.width, box.height)
				}
			}
		},
		[editor]
	)

	return (
		<canvas
			ref={rCanvas}
			style={{
				position: 'absolute',
				top: -100,
				left: -100,
				width: 'calc(100% + 200px)',
				height: 'calc(100% + 200px)',
				WebkitFilter: 'blur(15px)',
				filter: 'blur(15px)',
				pointerEvents: 'none',
			}}
		/>
	)
}

const components: TLComponents = {
	InFrontOfTheCanvas: Fog,
}

export default function BasicExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example" components={components} />
		</div>
	)
}
```

## Slideshow with Camera

Keywords: annotation, camera options, constraints, zoom, pan, camera bounds, pan speed, zoom speed, scroll, slides, presentation

The `Tldraw` component provides the tldraw editor as a regular React component. You can put this component anywhere in your React project. In this example, we make the component take up the height and width of the container.

By default, the component does not persist between refreshes or sync locally between tabs. To keep your work after a refresh, check the [`persistenceKey`](/peristence-key) example.

### App.tsx

```tsx
import { useEffect, useState } from 'react'
import {
	Editor,
	TLFrameShape,
	Tldraw,
	createShapeId,
	stopEventPropagation,
	transact,
	useValue,
} from 'tldraw'
import 'tldraw/tldraw.css'
import { SLIDE_MARGIN, SLIDE_SIZE, SlidesProvider, useSlides } from './SlidesManager'

export default function SlideShowExample() {
	return (
		<div className="tldraw__editor">
			<SlidesProvider>
				<InsideSlidesContext />
			</SlidesProvider>
		</div>
	)
}

function InsideSlidesContext() {
	const [editor, setEditor] = useState<Editor | null>(null)
	const slides = useSlides()

	const currentSlide = useValue('currentSlide', () => slides.getCurrentSlide(), [slides])

	useEffect(() => {
		if (!editor) return

		const nextBounds = {
			x: currentSlide.index * (SLIDE_SIZE.w + SLIDE_MARGIN),
			y: 0,
			w: SLIDE_SIZE.w,
			h: SLIDE_SIZE.h,
		}

		editor.setCameraOptions({
			constraints: {
				bounds: nextBounds,
				behavior: 'contain',
				initialZoom: 'fit-max',
				baseZoom: 'fit-max',
				origin: { x: 0.5, y: 0.5 },
				padding: { x: 50, y: 50 },
			},
		})

		editor.zoomToBounds(nextBounds, { force: true, animation: { duration: 500 } })
	}, [editor, currentSlide])

	const currentSlides = useValue('slides', () => slides.getCurrentSlides(), [slides])

	useEffect(() => {
		if (!editor) return

		const ids = currentSlides.map((slide) => createShapeId(slide.id))

		transact(() => {
			for (let i = 0; i < currentSlides.length; i++) {
				const shapeId = ids[i]
				const slide = currentSlides[i]
				const shape = editor.getShape(shapeId)
				if (shape) {
					if (shape.x === slide.index * (SLIDE_SIZE.w + SLIDE_MARGIN)) continue

					// if name is still Slide and number, e.g Slide 1, update it. Use regex to test

					const regex = /Slide \d+/
					let name = (shape as TLFrameShape).props.name
					if (regex.test((shape as TLFrameShape).props.name)) {
						name = `Slide ${slide.index + 1}`
					}

					editor.updateShape<TLFrameShape>({
						id: shapeId,
						type: 'frame',
						x: slide.index * (SLIDE_SIZE.w + SLIDE_MARGIN),
						props: {
							name,
						},
					})
				} else {
					editor.createShape<TLFrameShape>({
						id: shapeId,
						parentId: editor.getCurrentPageId(),
						type: 'frame',
						x: slide.index * (SLIDE_SIZE.w + SLIDE_MARGIN),
						y: 0,
						props: {
							name: `Slide ${slide.index + 1}`,
							w: SLIDE_SIZE.w,
							h: SLIDE_SIZE.h,
						},
					})
				}
			}
		})

		const unsubs = [] as (() => void)[]

		unsubs.push(
			editor.sideEffects.registerBeforeChangeHandler('shape', (prev, next) => {
				if (
					ids.includes(next.id) &&
					(next as TLFrameShape).props.name === (prev as TLFrameShape).props.name
				)
					return prev
				return next
			})
		)

		unsubs.push(
			editor.sideEffects.registerBeforeChangeHandler('instance_page_state', (prev, next) => {
				next.selectedShapeIds = next.selectedShapeIds.filter((id) => !ids.includes(id))
				if (next.hoveredShapeId && ids.includes(next.hoveredShapeId)) next.hoveredShapeId = null
				return next
			})
		)

		return () => {
			unsubs.forEach((fn) => fn())
		}
	}, [currentSlides, editor])

	const handleMount = (editor: Editor) => {
		setEditor(editor)
	}

	return <Tldraw onMount={handleMount} components={components} />
}

function Slides() {
	const slides = useSlides()
	const currentSlides = useValue('slides', () => slides.getCurrentSlides(), [slides])
	const lowestIndex = currentSlides[0].index
	const highestIndex = currentSlides[currentSlides.length - 1].index

	return (
		<>
			{/* {currentSlides.map((slide) => (
				<div
					key={slide.id}
					style={{
						position: 'absolute',
						top: 0,
						left: (SLIDE_SIZE.w + SLIDE_MARGIN) * slide.index,
						width: SLIDE_SIZE.w,
						height: SLIDE_SIZE.h,
						backgroundColor: 'white',
						border: '1px solid black',
						pointerEvents: 'all',
					}}
					onPointerDown={(e) => {
						if (slide.id !== slides.getCurrentSlideId()) {
							stopEventPropagation(e)
							slides.setCurrentSlide(slide.id)
						}
					}}
				/>
			))} */}
			{currentSlides.slice(0, -1).map((slide) => (
				<button
					key={slide.id + 'between'}
					style={{
						position: 'absolute',
						top: SLIDE_SIZE.h / 2,
						left: (slide.index + 1) * (SLIDE_SIZE.w + SLIDE_MARGIN) - (SLIDE_MARGIN + 40) / 2,
						width: 40,
						height: 40,
						pointerEvents: 'all',
					}}
					onPointerDown={stopEventPropagation}
					onClick={() => {
						const newSlide = slides.newSlide(slide.index + 1)
						slides.setCurrentSlide(newSlide.id)
					}}
				>
					|
				</button>
			))}
			<button
				style={{
					position: 'absolute',
					top: SLIDE_SIZE.h / 2,
					left: lowestIndex * (SLIDE_SIZE.w + SLIDE_MARGIN) - (40 + SLIDE_MARGIN * 0.1),
					width: 40,
					height: 40,
					pointerEvents: 'all',
				}}
				onPointerDown={stopEventPropagation}
				onClick={() => {
					const slide = slides.newSlide(lowestIndex - 1)
					slides.setCurrentSlide(slide.id)
				}}
			>
				{`+`}
			</button>
			<button
				style={{
					position: 'absolute',
					top: SLIDE_SIZE.h / 2,
					left: highestIndex * (SLIDE_SIZE.w + SLIDE_MARGIN) + (SLIDE_SIZE.w + SLIDE_MARGIN * 0.1),
					width: 40,
					height: 40,
					pointerEvents: 'all',
				}}
				onPointerDown={stopEventPropagation}
				onClick={() => {
					const slide = slides.newSlide(highestIndex + 1)
					slides.setCurrentSlide(slide.id)
				}}
			>
				{`+`}
			</button>
		</>
	)
}

function SlideControls() {
	const slides = useSlides()

	return (
		<>
			<button
				style={{
					pointerEvents: 'all',
					position: 'absolute',
					top: '50%',
					left: 0,
					width: 50,
					height: 50,
				}}
				onPointerDown={stopEventPropagation}
				onClick={() => slides.prevSlide()}
			>
				{`<`}
			</button>
			<button
				style={{
					pointerEvents: 'all',
					position: 'absolute',
					top: '50%',
					right: 0,
					width: 50,
					height: 50,
				}}
				onPointerDown={stopEventPropagation}
				onClick={() => slides.nextSlide()}
			>
				{`>`}
			</button>
		</>
	)
}

const components = {
	OnTheCanvas: Slides,
	InFrontOfTheCanvas: SlideControls,
}
```
### SlidesManager.tsx

```tsx
import { createContext, ReactNode, useContext, useState } from 'react'
import { atom, computed, structuredClone, uniqueId } from 'tldraw'

export const SLIDE_SIZE = { x: 0, y: 0, w: 1600, h: 900 }
export const SLIDE_MARGIN = 100

interface Slide {
	id: string
	index: number
	name: string
}

class SlidesManager {
	private _slides = atom<Slide[]>('slide', [
		{
			id: '1',
			index: 0,
			name: 'Slide 1',
		},
		{
			id: '2',
			index: 1,
			name: 'Slide 2',
		},
		{
			id: '3',
			index: 2,
			name: 'Slide 3',
		},
	])

	@computed getCurrentSlides() {
		return this._slides.get().sort((a, b) => (a.index < b.index ? -1 : 1))
	}

	private _currentSlideId = atom('currentSlide', '1')

	@computed getCurrentSlideId() {
		return this._currentSlideId.get()
	}

	@computed getCurrentSlide() {
		return this._slides.get().find((slide) => slide.id === this.getCurrentSlideId())!
	}

	setCurrentSlide(id: string) {
		this._currentSlideId.set(id)
	}

	moveBy(delta: number) {
		const slides = this.getCurrentSlides()
		const currentIndex = slides.findIndex((slide) => slide.id === this.getCurrentSlideId())
		const next = slides[currentIndex + delta]
		if (!next) return
		this._currentSlideId.set(next.id)
	}

	nextSlide() {
		this.moveBy(1)
	}

	prevSlide() {
		this.moveBy(-1)
	}

	newSlide(index: number) {
		const slides = structuredClone(this.getCurrentSlides())

		let bumping = false
		for (const slide of slides) {
			if (slide.index === index) {
				bumping = true
			}
			if (bumping) {
				slide.index++
			}
		}

		const newSlide = {
			id: uniqueId(),
			index,
			name: `Slide ${slides.length + 1}`,
		}

		this._slides.set([...slides, newSlide])

		return newSlide
	}
}

const slidesContext = createContext({} as SlidesManager)

export const SlidesProvider = ({ children }: { children: ReactNode }) => {
	const [slideManager] = useState(() => new SlidesManager())
	return <slidesContext.Provider value={slideManager}>{children}</slidesContext.Provider>
}

export function useSlides() {
	return useContext(slidesContext)
}
```

## Snow Storm

Keywords: snowstorm, front

This example shows how you can display a snowstorm in front of the canvas.

### App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import { SnowStorm } from './SnowStorm'
import './snowstorm.css'

export default function BasicExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example">
				<SnowStorm />
			</Tldraw>
		</div>
	)
}
```
### SnowStorm.tsx

```tsx
import { useEffect, useRef } from 'react'
import { Vec, useEditor, usePrefersReducedMotion } from 'tldraw'

const MAX_GUST_SPEED = 2
const GUST_ROTATION_DURATION = 30_000

const MAX_PIXELS_SCROLL_EFFECT = 18
const MAX_SCROLL_SPEED = 2

const MIN_POINTER_DISTANCE_SQUARED = 10_000
const SNOWFLAKE_VELOCITY_DECAY = 0.82

interface Snowflake {
	element: HTMLElement
	x: number
	y: number
	vx: number
	vy: number
	pvx: number
	pvy: number
	size: number
}

function rnd(min: number, max: number): number {
	return Math.random() * (max - min) + min
}

class Snowstorm {
	private flakes: Snowflake[] = []
	private active: boolean = false
	private container: HTMLElement
	private width: number
	private height: number

	windX = 0
	windY = 0

	baseWindX = 0

	// Configuration options
	private readonly config = {
		flakesMax: 128,
		flakeSizeMin: 2,
		flakeSizeMax: 5,
		flakeSpeedMinY: 1,
		flakeSpeedMaxY: 3,
		flakeSpeedX: 2,
	}

	constructor(container: HTMLElement = document.body) {
		this.container = container
		this.width = container.clientWidth
		this.height = container.clientHeight
	}

	private createSnowflake(): Snowflake {
		const element = document.createElement('div')
		element.classList.add('snowflake')
		this.container.appendChild(element)

		return {
			element,
			x: 0,
			y: 0,
			vx: 0,
			vy: 0,
			pvx: 0,
			pvy: 0,
			size: 1,
		}
	}

	configureSnowflake(flake: Snowflake) {
		const size = rnd(this.config.flakeSizeMin, this.config.flakeSizeMax)
		flake.x = rnd(0, this.width)
		flake.y = rnd(-this.height, 0)
		flake.vx = rnd(-this.config.flakeSpeedX, this.config.flakeSpeedX)
		flake.vy = rnd(this.config.flakeSpeedMinY, this.config.flakeSpeedMaxY)
		flake.element.style.width = `${size}px`
		flake.element.style.height = `${size}px`
		flake.element.style.opacity = rnd(0.5, 1).toString()
	}

	// Main render loop
	render(screenPoint: Vec, pointerVelocity: Vec, time: number) {
		if (!this.active) return

		const q = Math.sin(time / GUST_ROTATION_DURATION)

		// make wind gradually cycle between 0 and 10, maybe a bit randomly, like gusts of wind
		this.baseWindX = q * MAX_GUST_SPEED

		const pointerLen = pointerVelocity.len2()

		for (const flake of this.flakes) {
			const dist2 = Vec.Dist2(screenPoint, new Vec(flake.x, flake.y))

			// if the pointer is moving quickly, give nearby snowflakes a little boost based on the pointer velocity
			if (dist2 < MIN_POINTER_DISTANCE_SQUARED) {
				if (pointerLen > 1) {
					flake.pvx = pointerVelocity.x
					flake.pvy = pointerVelocity.y < 0 ? pointerVelocity.y / 2 : pointerVelocity.y // don't push up as easily
				}
			} else {
				// otherwise, declay down other snowflakes that have been boosted
				if (flake.pvx !== 0) {
					flake.pvx *= SNOWFLAKE_VELOCITY_DECAY
					if (Math.abs(flake.pvx) < 0.01) {
						flake.pvx = 0
					}

					if (flake.pvy !== 0) {
						flake.pvy *= SNOWFLAKE_VELOCITY_DECAY
						if (Math.abs(flake.pvy) < 0.01) {
							flake.pvy = 0
						}
					}
				}
			}

			// Move the flake based on the wind, the base wind, the pointer velocity, and some random wobble
			flake.x += flake.vx + this.windX + this.baseWindX + flake.pvx
			flake.y += flake.vy + this.windY + flake.pvy

			// Wrap the snowflakes around the screen horizontally
			if (flake.x < 0) {
				flake.x += this.width
				flake.pvx = 0
			} else if (flake.x > this.width) {
				flake.x -= this.width
				flake.pvx = 0
			}

			// Wrap the snowflakes around the screen vertically
			if (flake.y < 0) {
				flake.y += this.height
				flake.pvy = 0
			} else if (flake.y > this.height) {
				flake.y -= this.height
				flake.pvy = 0
			}

			flake.element.style.transform = `translate(${flake.x}px, ${flake.y}px)`
		}
	}

	resize() {
		this.width = this.container.clientWidth
		this.height = this.container.clientHeight
	}

	start() {
		this.active = true
		while (this.flakes.length < this.config.flakesMax) {
			const flake = this.createSnowflake()
			this.configureSnowflake(flake)
			this.flakes.push(flake)
		}
		window.addEventListener('resize', this.resize)
	}

	stop() {
		this.active = false
		for (const flake of this.flakes) {
			this.container.removeChild(flake.element)
		}
		this.flakes = []
	}

	dispose() {
		this.stop()
		window.removeEventListener('resize', this.resize)
	}
}

export function SnowStorm() {
	const editor = useEditor()
	const rElm = useRef<HTMLDivElement>(null)
	const prefersReducedMotion = usePrefersReducedMotion()

	useEffect(() => {
		if (prefersReducedMotion) return
		if (!rElm.current) return
		const snowstorm = new Snowstorm(rElm.current)
		const velocity = new Vec(0, 0)
		const camera = Vec.From(editor.getCamera())

		const start = Date.now()

		function updateOnTick() {
			const time = Date.now() - start

			const newCamera = editor.getCamera()

			// Apply camera movement effect only when zoom isn't changing
			if (newCamera.z === camera.z) {
				const dx = (newCamera.x - camera.x) * camera.z
				const dy = (newCamera.y - camera.y) * camera.z

				// add the camera movement to the velocity
				velocity.addXY(
					Math.min(dx / MAX_PIXELS_SCROLL_EFFECT, MAX_SCROLL_SPEED),
					Math.min(dy / MAX_PIXELS_SCROLL_EFFECT, MAX_SCROLL_SPEED)
				)

				// decay velocity
				velocity.mul(SNOWFLAKE_VELOCITY_DECAY)

				// stop the snowflakes from moving if the camera is not moving
				if (velocity.len2() < 1) {
					velocity.x = 0
					velocity.y = 0
				}

				snowstorm.windX = velocity.x
				snowstorm.windY = velocity.y
			}

			camera.setTo(newCamera)
			snowstorm.render(editor.inputs.currentScreenPoint, editor.inputs.pointerVelocity, time)
		}

		snowstorm.start()
		editor.on('tick', updateOnTick)

		return () => {
			editor.off('tick', updateOnTick)
			snowstorm.dispose()
		}
	}, [editor, prefersReducedMotion])

	return <div ref={rElm} className="snowstorm" />
}
```
### snowstorm.css

```css
.snowflake {
	position: absolute;
	background-color: #ccc;
	border-radius: 100%;
	pointer-events: none;
}

.snowstorm {
	position: absolute;
	width: 100%;
	height: 100%;
	pointer-events: none;
}
```

## Image annotator

Keywords: annotation, camera options, constraints, zoom, pan, camera bounds, pan speed, zoom speed

An image annotator built with tldraw



### App.tsx

```tsx
import { useState } from 'react'
import 'tldraw/tldraw.css'
import { ImageAnnotationEditor } from './ImageAnnotationEditor'
import { ImageExport } from './ImageExport'
import { ImagePicker } from './ImagePicker'
import './image-annotator.css'
import { AnnotatorImage } from './types'

type State =
	| {
			phase: 'pick'
	  }
	| {
			phase: 'annotate'
			id: string
			image: AnnotatorImage
	  }
	| {
			phase: 'export'
			result: Blob
	  }

export default function ImageAnnotatorWrapper() {
	const [state, setState] = useState<State>({ phase: 'pick' })

	switch (state.phase) {
		case 'pick':
			return (
				<div className="ImageAnnotator">
					<ImagePicker
						onChooseImage={(image) =>
							setState({ phase: 'annotate', image, id: Math.random().toString(36) })
						}
					/>
				</div>
			)
		case 'annotate':
			return (
				<div className="ImageAnnotator">
					<ImageAnnotationEditor
						// remount tldraw if the image/id changes:
						key={state.id}
						image={state.image}
						onDone={(result) => setState({ phase: 'export', result })}
					/>
				</div>
			)
		case 'export':
			return (
				<div className="ImageAnnotator">
					<ImageExport result={state.result} onStartAgain={() => setState({ phase: 'pick' })} />
				</div>
			)
	}
}
```
### ImageAnnotationEditor.tsx

```tsx
import { useCallback, useEffect, useState } from 'react'
import {
	AssetRecordType,
	Editor,
	SVGContainer,
	TLImageShape,
	TLShapeId,
	Tldraw,
	createShapeId,
	track,
	useEditor,
} from 'tldraw'
import { AnnotatorImage } from './types'

// TODO:
// - prevent changing pages (create page, change page, move shapes to new page)
// - prevent locked shape context menu
// - inertial scrolling for constrained camera
export function ImageAnnotationEditor({
	image,
	onDone,
}: {
	image: AnnotatorImage
	onDone(result: Blob): void
}) {
	const [imageShapeId, setImageShapeId] = useState<TLShapeId | null>(null)
	const [editor, setEditor] = useState(null as Editor | null)

	function onMount(editor: Editor) {
		setEditor(editor)
	}

	useEffect(() => {
		if (!editor) return

		// Create the asset and image shape
		const assetId = AssetRecordType.createId()
		editor.createAssets([
			{
				id: assetId,
				typeName: 'asset',
				type: 'image',
				meta: {},
				props: {
					w: image.width,
					h: image.height,
					mimeType: image.type,
					src: image.src,
					name: 'image',
					isAnimated: false,
				},
			},
		])
		const shapeId = createShapeId()
		editor.createShape<TLImageShape>({
			id: shapeId,
			type: 'image',
			x: 0,
			y: 0,
			isLocked: true,
			props: {
				w: image.width,
				h: image.height,
				assetId,
			},
		})

		// Make sure the shape is at the bottom of the page
		function makeSureShapeIsAtBottom() {
			if (!editor) return

			const shape = editor.getShape(shapeId)
			if (!shape) return

			const pageId = editor.getCurrentPageId()

			// The shape should always be the child of the current page
			if (shape.parentId !== pageId) {
				editor.moveShapesToPage([shape], pageId)
			}

			// The shape should always be at the bottom of the page's children
			const siblings = editor.getSortedChildIdsForParent(pageId)
			const currentBottomShape = editor.getShape(siblings[0])!
			if (currentBottomShape.id !== shapeId) {
				editor.sendToBack([shape])
			}
		}

		makeSureShapeIsAtBottom()

		const removeOnCreate = editor.sideEffects.registerAfterCreateHandler(
			'shape',
			makeSureShapeIsAtBottom
		)

		const removeOnChange = editor.sideEffects.registerAfterChangeHandler(
			'shape',
			makeSureShapeIsAtBottom
		)

		// The shape should always be locked
		const cleanupKeepShapeLocked = editor.sideEffects.registerBeforeChangeHandler(
			'shape',
			(prev, next) => {
				if (next.id !== shapeId) return next
				if (next.isLocked) return next
				return { ...prev, isLocked: true }
			}
		)

		// Reset the history
		editor.clearHistory()
		setImageShapeId(shapeId)

		return () => {
			removeOnChange()
			removeOnCreate()
			cleanupKeepShapeLocked()
		}
	}, [image, editor])

	useEffect(() => {
		if (!editor) return
		if (!imageShapeId) return

		/**
		 * We don't want the user to be able to scroll away from the image, or zoom it all the way out. This
		 * component hooks into camera updates to keep the camera constrained - try uploading a very long,
		 * thin image and seeing how the camera behaves.
		 */
		editor.setCameraOptions({
			constraints: {
				initialZoom: 'fit-max',
				baseZoom: 'default',
				bounds: { w: image.width, h: image.height, x: 0, y: 0 },
				padding: { x: 32, y: 64 },
				origin: { x: 0.5, y: 0.5 },
				behavior: 'contain',
			},
			zoomSteps: [1, 2, 4, 8],
			zoomSpeed: 1,
			panSpeed: 1,
			isLocked: false,
		})
		editor.setCamera(editor.getCamera(), { reset: true })
	}, [editor, imageShapeId, image])

	return (
		<Tldraw
			onMount={onMount}
			components={{
				// we don't need pages for this use-case
				PageMenu: null,
				// grey-out the area outside of the image
				InFrontOfTheCanvas: useCallback(() => {
					if (!imageShapeId) return null
					return <ImageBoundsOverlay imageShapeId={imageShapeId} />
				}, [imageShapeId]),
				// add a "done" button in the top right for when the user is ready to export
				SharePanel: useCallback(() => {
					if (!imageShapeId) return null
					return <DoneButton imageShapeId={imageShapeId} onClick={onDone} />
				}, [imageShapeId, onDone]),
			}}
		/>
	)
}

/**
 * When we export, we'll only include the bounds of the image itself, so show an overlay on top of
 * the canvas to make it clear what will/won't be included. Check `image-annotator.css` for more on
 * how this works.
 */
const ImageBoundsOverlay = track(function ImageBoundsOverlay({
	imageShapeId,
}: {
	imageShapeId: TLShapeId
}) {
	const editor = useEditor()
	const image = editor.getShape(imageShapeId) as TLImageShape
	if (!image) return null

	const imagePageBounds = editor.getShapePageBounds(imageShapeId)!
	const viewport = editor.getViewportScreenBounds()
	const topLeft = editor.pageToViewport(imagePageBounds)
	const bottomRight = editor.pageToViewport({ x: imagePageBounds.maxX, y: imagePageBounds.maxY })

	const path = [
		// start by tracing around the viewport itself:
		`M ${-10} ${-10}`,
		`L ${viewport.maxX + 10} ${-10}`,
		`L ${viewport.maxX + 10} ${viewport.maxY + 10}`,
		`L ${-10} ${viewport.maxY + 10}`,
		`Z`,

		// then cut out a hole for the image:
		`M ${topLeft.x} ${topLeft.y}`,
		`L ${bottomRight.x} ${topLeft.y}`,
		`L ${bottomRight.x} ${bottomRight.y}`,
		`L ${topLeft.x} ${bottomRight.y}`,
		`Z`,
	].join(' ')

	return (
		<SVGContainer className="ImageOverlayScreen">
			<path d={path} fillRule="evenodd" />
		</SVGContainer>
	)
})

function DoneButton({
	imageShapeId,
	onClick,
}: {
	imageShapeId: TLShapeId
	onClick(result: Blob): void
}) {
	const editor = useEditor()
	return (
		<button
			className="DoneButton"
			onClick={async () => {
				const { blob } = await editor.toImage([...editor.getCurrentPageShapeIds()], {
					format: 'png',
					background: true,
					bounds: editor.getShapePageBounds(imageShapeId)!,
					padding: 0,
					scale: 1,
				})

				onClick(blob)
			}}
		>
			Done
		</button>
	)
}
```
### ImageExport.tsx

```tsx
import { useEffect, useLayoutEffect, useState } from 'react'

export function ImageExport({ result, onStartAgain }: { result: Blob; onStartAgain(): void }) {
	const [src, setSrc] = useState<string | null>(null)
	useLayoutEffect(() => {
		const url = URL.createObjectURL(result)
		setSrc(url)
		return () => URL.revokeObjectURL(url)
	}, [result])

	function onDownload() {
		if (!src) return

		const a = document.createElement('a')
		a.href = src
		a.download = 'annotated-image.png'
		a.click()
	}

	const [didCopy, setDidCopy] = useState(false)
	function onCopy() {
		navigator.clipboard.write([new ClipboardItem({ [result.type]: result })])
		setDidCopy(true)
	}
	useEffect(() => {
		if (!didCopy) return
		const t = setTimeout(() => setDidCopy(false), 2000)
		return () => clearTimeout(t)
	}, [didCopy])

	return (
		<div className="ImageExport">
			{src && <img src={src} />}
			<div className="ImageExport-buttons">
				<button onClick={onCopy}>{didCopy ? 'Copied!' : 'Copy'}</button>
				<button onClick={onDownload}>Download</button>
			</div>
			<button onClick={onStartAgain}>Start Again</button>
		</div>
	)
}
```
### ImagePicker.tsx

```tsx
import { useState } from 'react'
import { DEFAULT_SUPPORTED_MEDIA_TYPE_LIST, FileHelpers, MediaHelpers } from 'tldraw'
import anakin from './assets/anakin.jpeg'
import distractedBf from './assets/distracted-bf.jpeg'
import expandingBrain from './assets/expanding-brain.png'

export function ImagePicker({
	onChooseImage,
}: {
	onChooseImage(image: { src: string; width: number; height: number; type: string }): void
}) {
	const [isLoading, setIsLoading] = useState(false)
	function onClickChooseImage() {
		const input = window.document.createElement('input')
		input.type = 'file'
		input.accept = DEFAULT_SUPPORTED_MEDIA_TYPE_LIST
		input.addEventListener('change', async (e) => {
			const fileList = (e.target as HTMLInputElement).files
			if (!fileList || fileList.length === 0) return
			const file = fileList[0]

			setIsLoading(true)
			try {
				const dataUrl = await FileHelpers.blobToDataUrl(file)
				const { w, h } = await MediaHelpers.getImageSize(file)
				onChooseImage({ src: dataUrl, width: w, height: h, type: file.type })
			} finally {
				setIsLoading(false)
			}
		})
		input.click()
	}

	async function onChooseExample(src: string) {
		setIsLoading(true)
		try {
			const image = await fetch(src)
			const blob = await image.blob()
			const { w, h } = await MediaHelpers.getImageSize(blob)
			onChooseImage({ src, width: w, height: h, type: blob.type })
		} finally {
			setIsLoading(false)
		}
	}

	if (isLoading) {
		return <div className="ImagePicker">Loading...</div>
	}

	return (
		<div className="ImagePicker">
			<button onClick={onClickChooseImage}>Choose an image</button>
			<div className="ImagePicker-exampleLabel">or use an example:</div>
			<div className="ImagePicker-examples">
				<img src={anakin} alt="anakin" onClick={() => onChooseExample(anakin)} />
				<img
					src={distractedBf}
					alt="distracted boyfriend"
					onClick={() => onChooseExample(distractedBf)}
				/>
				<img
					src={expandingBrain}
					alt="expanding brain"
					onClick={() => onChooseExample(expandingBrain)}
				/>
			</div>
		</div>
	)
}
```
### image-annotator.css

```css
.ImageAnnotator {
	position: absolute;
	inset: 0;
}

.ImageAnnotator .ImagePicker {
	position: absolute;
	inset: 1rem;
	display: flex;
	align-items: center;
	justify-content: center;
	text-align: center;
	flex-direction: column;
	gap: 1rem;
}
.ImageAnnotator .ImagePicker button {
	padding: 0.5rem 1rem;
	border: none;
	background: #eee;
	cursor: pointer;
	font: inherit;
}
.ImageAnnotator .ImagePicker button:hover {
	opacity: 0.9;
}
.ImageAnnotator .ImagePicker-exampleLabel {
	padding-top: 1rem;
	opacity: 0.7;
	font-size: 14px;
}
.ImageAnnotator .ImagePicker-examples {
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	width: 100%;
	max-width: 780px;
	gap: 1rem;
}
.ImageAnnotator .ImagePicker-examples img {
	width: 100%;
	height: auto;
	object-fit: contain;
	aspect-ratio: 1;
	cursor: pointer;
}
.ImageAnnotator .ImagePicker-examples img:hover {
	opacity: 0.9;
}

.ImageAnnotator .ImageOverlayScreen {
	pointer-events: none;
	z-index: -1;
	fill: var(--color-background);
	fill-opacity: 0.8;
	stroke: none;
}

.ImageAnnotator .DoneButton {
	font: inherit;
	background: var(--color-primary);
	border: none;
	color: var(--color-selected-contrast);
	font-size: 1rem;
	padding: 0.5rem 1rem;
	border-radius: 6px;
	margin: 6px;
	pointer-events: all;
	z-index: var(--layer-panels);
	border: 2px solid var(--color-background);
	cursor: pointer;
}
.ImageAnnotator .DoneButton:hover {
	filter: brightness(1.1);
}

.ImageAnnotator .ImageExport {
	padding: 1rem;
	display: flex;
	flex-direction: column;
	gap: 1rem;
	align-items: center;
	height: 100%;
}
.ImageAnnotator .ImageExport img {
	width: 100%;
	max-height: 50vh;
	object-fit: contain;
}
.ImageAnnotator .ImageExport button {
	padding: 0.5rem 1rem;
	border: none;
	background: #eee;
	cursor: pointer;
	font: inherit;
}
.ImageAnnotator .ImageExport button:hover {
	opacity: 0.9;
}
.ImageAnnotator .ImageExport-buttons {
	display: flex;
	gap: 1rem;
	align-items: center;
	justify-content: center;
	margin-bottom: auto;
}
.ImageAnnotator .ImageExport-buttons button {
	background-color: hsl(214, 84%, 56%);
	color: white;
}
```
### types.tsx

```tsx
export interface AnnotatorImage {
	src: string
	width: number
	height: number
	type: string
}
```

## PDF editor

Keywords: annotation, camera options, constraints, zoom, pan, camera bounds, pan speed, zoom speed, scroll

A very basic PDF editor built with tldraw



### App.tsx

```tsx
import { useState } from 'react'
import 'tldraw/tldraw.css'
import { PdfEditor } from './PdfEditor'
import { Pdf, PdfPicker } from './PdfPicker'
import './pdf-editor.css'

type State =
	| {
			phase: 'pick'
	  }
	| {
			phase: 'edit'
			pdf: Pdf
	  }

export default function PdfEditorWrapper() {
	const [state, setState] = useState<State>({ phase: 'pick' })

	switch (state.phase) {
		case 'pick':
			return (
				<div className="PdfEditor">
					<PdfPicker onOpenPdf={(pdf) => setState({ phase: 'edit', pdf })} />
				</div>
			)
		case 'edit':
			return (
				<div className="PdfEditor">
					<PdfEditor pdf={state.pdf} />
				</div>
			)
	}
}
```
### ExportPdfButton.tsx

```tsx
import { PDFDocument } from 'pdf-lib'
import { useState } from 'react'
import { Editor, useEditor } from 'tldraw'
import { Pdf } from './PdfPicker'

export function ExportPdfButton({ pdf }: { pdf: Pdf }) {
	const [exportProgress, setExportProgress] = useState<number | null>(null)
	const editor = useEditor()

	return (
		<button
			className="ExportPdfButton"
			onClick={async () => {
				setExportProgress(0)
				try {
					await exportPdf(editor, pdf, setExportProgress)
				} finally {
					setExportProgress(null)
				}
			}}
		>
			{exportProgress ? `Exporting... ${Math.round(exportProgress * 100)}%` : 'Export PDF'}
		</button>
	)
}

async function exportPdf(
	editor: Editor,
	{ name, source, pages }: Pdf,
	onProgress: (progress: number) => void
) {
	const totalThings = pages.length * 2 + 2
	let progressCount = 0
	const tickProgress = () => {
		progressCount++
		onProgress(progressCount / totalThings)
	}

	const pdf = await PDFDocument.load(source)
	tickProgress()

	const pdfPages = pdf.getPages()
	if (pdfPages.length !== pages.length) {
		throw new Error('PDF page count mismatch')
	}

	const pageShapeIds = new Set(pages.map((page) => page.shapeId))
	const allIds = Array.from(editor.getCurrentPageShapeIds()).filter((id) => !pageShapeIds.has(id))

	for (let i = 0; i < pages.length; i++) {
		const page = pages[i]
		const pdfPage = pdfPages[i]

		const bounds = page.bounds
		const shapesInBounds = allIds.filter((id) => {
			const shapePageBounds = editor.getShapePageBounds(id)
			if (!shapePageBounds) return false
			return shapePageBounds.collides(bounds)
		})

		if (shapesInBounds.length === 0) {
			tickProgress()
			tickProgress()
			continue
		}

		const exportedPng = await editor.toImage(allIds, {
			format: 'png',
			background: false,
			bounds: page.bounds,
			padding: 0,
			scale: 1,
		})
		tickProgress()

		pdfPage.drawImage(await pdf.embedPng(await exportedPng.blob.arrayBuffer()), {
			x: 0,
			y: 0,
			width: pdfPage.getWidth(),
			height: pdfPage.getHeight(),
		})
		tickProgress()
	}

	const url = URL.createObjectURL(new Blob([await pdf.save()], { type: 'application/pdf' }))
	tickProgress()
	const a = document.createElement('a')
	a.href = url
	a.download = name
	a.click()
	URL.revokeObjectURL(url)
}
```
### PdfEditor.tsx

```tsx
import { useMemo } from 'react'
import {
	Box,
	SVGContainer,
	TLComponents,
	TLImageShape,
	TLShapePartial,
	Tldraw,
	getIndicesBetween,
	react,
	sortByIndex,
	track,
	useEditor,
} from 'tldraw'
import { ExportPdfButton } from './ExportPdfButton'
import { Pdf } from './PdfPicker'

// TODO:
// - prevent changing pages (create page, change page, move shapes to new page)
// - prevent locked shape context menu
// - inertial scrolling for constrained camera
// - render pages on-demand instead of all at once.
export function PdfEditor({ pdf }: { pdf: Pdf }) {
	const components = useMemo<TLComponents>(
		() => ({
			PageMenu: null,
			InFrontOfTheCanvas: () => <PageOverlayScreen pdf={pdf} />,
			SharePanel: () => <ExportPdfButton pdf={pdf} />,
		}),
		[pdf]
	)

	return (
		<Tldraw
			onMount={(editor) => {
				editor.createAssets(
					pdf.pages.map((page) => ({
						id: page.assetId,
						typeName: 'asset',
						type: 'image',
						meta: {},
						props: {
							w: page.bounds.w,
							h: page.bounds.h,
							mimeType: 'image/png',
							src: page.src,
							name: 'page',
							isAnimated: false,
						},
					}))
				)
				editor.createShapes(
					pdf.pages.map(
						(page): TLShapePartial<TLImageShape> => ({
							id: page.shapeId,
							type: 'image',
							x: page.bounds.x,
							y: page.bounds.y,
							isLocked: true,
							props: {
								assetId: page.assetId,
								w: page.bounds.w,
								h: page.bounds.h,
							},
						})
					)
				)

				const shapeIds = pdf.pages.map((page) => page.shapeId)
				const shapeIdSet = new Set(shapeIds)

				// Don't let the user unlock the pages
				editor.sideEffects.registerBeforeChangeHandler('shape', (prev, next) => {
					if (!shapeIdSet.has(next.id)) return next
					if (next.isLocked) return next
					return { ...prev, isLocked: true }
				})

				// Make sure the shapes are below any of the other shapes
				function makeSureShapesAreAtBottom() {
					const shapes = shapeIds.map((id) => editor.getShape(id)!).sort(sortByIndex)
					const pageId = editor.getCurrentPageId()

					const siblings = editor.getSortedChildIdsForParent(pageId)
					const currentBottomShapes = siblings
						.slice(0, shapes.length)
						.map((id) => editor.getShape(id)!)

					if (currentBottomShapes.every((shape, i) => shape.id === shapes[i].id)) return

					const otherSiblings = siblings.filter((id) => !shapeIdSet.has(id))
					const bottomSibling = otherSiblings[0]
					const lowestIndex = editor.getShape(bottomSibling)!.index

					const indexes = getIndicesBetween(undefined, lowestIndex, shapes.length)
					editor.updateShapes(
						shapes.map((shape, i) => ({
							id: shape.id,
							type: shape.type,
							isLocked: shape.isLocked,
							index: indexes[i],
						}))
					)
				}

				makeSureShapesAreAtBottom()
				editor.sideEffects.registerAfterCreateHandler('shape', makeSureShapesAreAtBottom)
				editor.sideEffects.registerAfterChangeHandler('shape', makeSureShapesAreAtBottom)

				// Constrain the camera to the bounds of the pages
				const targetBounds = pdf.pages.reduce(
					(acc, page) => acc.union(page.bounds),
					pdf.pages[0].bounds.clone()
				)

				function updateCameraBounds(isMobile: boolean) {
					editor.setCameraOptions({
						constraints: {
							bounds: targetBounds,
							padding: { x: isMobile ? 16 : 164, y: 64 },
							origin: { x: 0.5, y: 0 },
							initialZoom: 'fit-x-100',
							baseZoom: 'default',
							behavior: 'contain',
						},
					})
					editor.setCamera(editor.getCamera(), { reset: true })
				}

				let isMobile = editor.getViewportScreenBounds().width < 840

				react('update camera', () => {
					const isMobileNow = editor.getViewportScreenBounds().width < 840
					if (isMobileNow === isMobile) return
					isMobile = isMobileNow
					updateCameraBounds(isMobile)
				})

				updateCameraBounds(isMobile)
			}}
			components={components}
		/>
	)
}

const PageOverlayScreen = track(function PageOverlayScreen({ pdf }: { pdf: Pdf }) {
	const editor = useEditor()

	const viewportPageBounds = editor.getViewportPageBounds()
	const viewportScreenBounds = editor.getViewportScreenBounds()

	const relevantPageBounds = pdf.pages
		.map((page) => {
			if (!viewportPageBounds.collides(page.bounds)) return null
			const topLeft = editor.pageToViewport(page.bounds)
			const bottomRight = editor.pageToViewport({ x: page.bounds.maxX, y: page.bounds.maxY })
			return new Box(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y)
		})
		.filter((bounds): bounds is Box => bounds !== null)

	function pathForPageBounds(bounds: Box) {
		return `M ${bounds.x} ${bounds.y} L ${bounds.maxX} ${bounds.y} L ${bounds.maxX} ${bounds.maxY} L ${bounds.x} ${bounds.maxY} Z`
	}

	const viewportPath = `M 0 0 L ${viewportScreenBounds.w} 0 L ${viewportScreenBounds.w} ${viewportScreenBounds.h} L 0 ${viewportScreenBounds.h} Z`

	return (
		<>
			<SVGContainer className="PageOverlayScreen-screen">
				<path
					d={`${viewportPath} ${relevantPageBounds.map(pathForPageBounds).join(' ')}`}
					fillRule="evenodd"
				/>
			</SVGContainer>
			{relevantPageBounds.map((bounds, i) => (
				<div
					key={i}
					className="PageOverlayScreen-outline"
					style={{
						width: bounds.w,
						height: bounds.h,
						transform: `translate(${bounds.x}px, ${bounds.y}px)`,
					}}
				/>
			))}
		</>
	)
})
```
### PdfPicker.tsx

```tsx
import { useState } from 'react'
import { AssetRecordType, Box, TLAssetId, TLShapeId, createShapeId } from 'tldraw'
import tldrawPdf from './assets/tldraw.pdf'

export interface PdfPage {
	src: string
	bounds: Box
	assetId: TLAssetId
	shapeId: TLShapeId
}

export interface Pdf {
	name: string
	pages: PdfPage[]
	source: string | ArrayBuffer
}

const pageSpacing = 32

export function PdfPicker({ onOpenPdf }: { onOpenPdf(pdf: Pdf): void }) {
	const [isLoading, setIsLoading] = useState(false)

	async function loadPdf(name: string, source: ArrayBuffer): Promise<Pdf> {
		const PdfJS = await import('pdfjs-dist')
		PdfJS.GlobalWorkerOptions.workerSrc = new URL(
			'pdfjs-dist/build/pdf.worker.min.mjs',
			import.meta.url
		).toString()
		const pdf = await PdfJS.getDocument(source.slice(0)).promise
		const pages: PdfPage[] = []

		const canvas = window.document.createElement('canvas')
		const context = canvas.getContext('2d')
		if (!context) throw new Error('Failed to create canvas context')

		const visualScale = 1.5
		const scale = window.devicePixelRatio

		let top = 0
		let widest = 0
		for (let i = 1; i <= pdf.numPages; i++) {
			const page = await pdf.getPage(i)
			const viewport = page.getViewport({ scale: scale * visualScale })
			canvas.width = viewport.width
			canvas.height = viewport.height
			const renderContext = {
				canvasContext: context,
				viewport,
			}
			await page.render(renderContext).promise

			const width = viewport.width / scale
			const height = viewport.height / scale
			pages.push({
				src: canvas.toDataURL(),
				bounds: new Box(0, top, width, height),
				assetId: AssetRecordType.createId(),
				shapeId: createShapeId(),
			})
			top += height + pageSpacing
			widest = Math.max(widest, width)
		}
		canvas.width = 0
		canvas.height = 0

		for (const page of pages) {
			page.bounds.x = (widest - page.bounds.width) / 2
		}

		return {
			name,
			pages,
			source,
		}
	}

	function onClickOpenPdf() {
		const input = window.document.createElement('input')
		input.type = 'file'
		input.accept = 'application/pdf'
		input.addEventListener('change', async (e) => {
			const fileList = (e.target as HTMLInputElement).files
			if (!fileList || fileList.length === 0) return
			const file = fileList[0]

			setIsLoading(true)
			try {
				const pdf = await loadPdf(file.name, await file.arrayBuffer())
				onOpenPdf(pdf)
			} finally {
				setIsLoading(false)
			}
		})
		input.click()
	}

	async function onClickUseExample() {
		setIsLoading(true)
		try {
			const result = await fetch(tldrawPdf)
			const pdf = await loadPdf('tldraw.pdf', await result.arrayBuffer())
			onOpenPdf(pdf)
		} finally {
			setIsLoading(false)
		}
	}

	if (isLoading) {
		return <div className="PdfPicker">Loading...</div>
	}

	return (
		<div className="PdfPicker">
			<button onClick={onClickOpenPdf}>Open PDF</button>
			<div>or</div>
			<button onClick={onClickUseExample}>Use an example</button>
		</div>
	)
}
```
### pdf-editor.css

```css
.PdfEditor {
	position: absolute;
	inset: 0;
}

.PdfEditor .PdfPicker {
	position: absolute;
	inset: 1rem;
	display: flex;
	align-items: center;
	justify-content: center;
	text-align: center;
	flex-direction: column;
	gap: 1rem;
}
.PdfEditor .PdfPicker button {
	padding: 0.5rem 1rem;
	border: none;
	background: #eee;
	cursor: pointer;
	font: inherit;
}
.PdfEditor .PdfPicker button:hover {
	opacity: 0.9;
}

.PdfEditor .PdfBgRenderer {
	position: absolute;
	pointer-events: none;
}
.PdfEditor .PdfBgRenderer img {
	position: absolute;
}

.PdfEditor .PageOverlayScreen-screen {
	pointer-events: none;
	z-index: -1;
	fill: var(--color-background);
	fill-opacity: 0.8;
	stroke: none;
}
.PdfEditor .PageOverlayScreen-outline {
	position: absolute;
	pointer-events: none;
	z-index: -1;
	/* border: 1px solid var(--color-overlay); */
	box-shadow: var(--shadow-2);
}
.PdfEditor .ExportPdfButton {
	font: inherit;
	background: var(--color-primary);
	border: none;
	color: var(--color-selected-contrast);
	font-size: 1rem;
	padding: 0.5rem 1rem;
	border-radius: 6px;
	margin: 6px;
	margin-bottom: 0;
	pointer-events: all;
	z-index: var(--layer-panels);
	border: 2px solid var(--color-background);
	cursor: pointer;
}
.PdfEditor .ExportPdfButton:hover {
	filter: brightness(1.1);
}
```

## Slideshow

Keywords: annotation, camera options, constraints, zoom, pan, camera bounds, pan speed, zoom speed, scroll, slides, presentation

Slideshow example.

Make slides for a presentation.

### App.tsx

```tsx
import {
	DefaultKeyboardShortcutsDialog,
	DefaultKeyboardShortcutsDialogContent,
	DefaultToolbar,
	DefaultToolbarContent,
	TLComponents,
	TLUiOverrides,
	Tldraw,
	TldrawUiMenuItem,
	computed,
	track,
	useIsToolSelected,
	useTools,
} from 'tldraw'
import 'tldraw/tldraw.css'
import { SlideShapeTool } from './SlideShapeTool'
import { SlideShapeUtil } from './SlideShapeUtil'
import { SlidesPanel } from './SlidesPanel'
import './slides.css'
import { $currentSlide, getSlides, moveToSlide } from './useSlides'

const components: TLComponents = {
	HelperButtons: SlidesPanel,
	Minimap: null,
	Toolbar: (props) => {
		const tools = useTools()
		const isSlideSelected = useIsToolSelected(tools['slide'])
		return (
			<DefaultToolbar {...props}>
				<TldrawUiMenuItem {...tools['slide']} isSelected={isSlideSelected} />
				<DefaultToolbarContent />
			</DefaultToolbar>
		)
	},
	KeyboardShortcutsDialog: (props) => {
		const tools = useTools()
		return (
			<DefaultKeyboardShortcutsDialog {...props}>
				<TldrawUiMenuItem {...tools['slide']} />
				<DefaultKeyboardShortcutsDialogContent />
			</DefaultKeyboardShortcutsDialog>
		)
	},
}

const overrides: TLUiOverrides = {
	actions(editor, actions) {
		const $slides = computed('slides', () => getSlides(editor))
		return {
			...actions,
			'next-slide': {
				id: 'next-slide',
				label: 'Next slide',
				kbd: 'right',
				onSelect() {
					const slides = $slides.get()
					const currentSlide = $currentSlide.get()
					const index = slides.findIndex((s) => s.id === currentSlide?.id)
					const nextSlide = slides[index + 1] ?? currentSlide ?? slides[0]
					if (nextSlide) {
						editor.stopCameraAnimation()
						moveToSlide(editor, nextSlide)
					}
				},
			},
			'previous-slide': {
				id: 'previous-slide',
				label: 'Previous slide',
				kbd: 'left',
				onSelect() {
					const slides = $slides.get()
					const currentSlide = $currentSlide.get()
					const index = slides.findIndex((s) => s.id === currentSlide?.id)
					const previousSlide = slides[index - 1] ?? currentSlide ?? slides[slides.length - 1]
					if (previousSlide) {
						editor.stopCameraAnimation()
						moveToSlide(editor, previousSlide)
					}
				},
			},
		}
	},
	tools(editor, tools) {
		tools.slide = {
			id: 'slide',
			icon: 'group',
			label: 'Slide',
			kbd: 's',
			onSelect: () => editor.setCurrentTool('slide'),
		}
		return tools
	},
}

const SlidesExample = track(() => {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="slideshow_example"
				shapeUtils={[SlideShapeUtil]}
				tools={[SlideShapeTool]}
				components={components}
				overrides={overrides}
			/>
		</div>
	)
})

export default SlidesExample
```
### SlideShapeTool.tsx

```tsx
import { BaseBoxShapeTool } from 'tldraw'

export class SlideShapeTool extends BaseBoxShapeTool {
	static override id = 'slide'
	static override initial = 'idle'
	override shapeType = 'slide'
}
```
### SlideShapeUtil.tsx

```tsx
import { useCallback } from 'react'
import {
	Geometry2d,
	RecordProps,
	Rectangle2d,
	SVGContainer,
	ShapeUtil,
	T,
	TLBaseShape,
	TLResizeInfo,
	getPerfectDashProps,
	resizeBox,
	useValue,
} from 'tldraw'
import { moveToSlide, useSlides } from './useSlides'

export type SlideShape = TLBaseShape<
	'slide',
	{
		w: number
		h: number
	}
>

export class SlideShapeUtil extends ShapeUtil<SlideShape> {
	static override type = 'slide' as const
	static override props: RecordProps<SlideShape> = {
		w: T.number,
		h: T.number,
	}

	override canBind() {
		return false
	}
	override hideRotateHandle() {
		return true
	}

	getDefaultProps(): SlideShape['props'] {
		return {
			w: 720,
			h: 480,
		}
	}

	getGeometry(shape: SlideShape): Geometry2d {
		return new Rectangle2d({
			width: shape.props.w,
			height: shape.props.h,
			isFilled: false,
		})
	}

	override onRotate(initial: SlideShape) {
		return initial
	}

	override onResize(shape: SlideShape, info: TLResizeInfo<SlideShape>) {
		return resizeBox(shape, info)
	}

	override onDoubleClick(shape: SlideShape) {
		moveToSlide(this.editor, shape)
		this.editor.selectNone()
	}

	override onDoubleClickEdge(shape: SlideShape) {
		moveToSlide(this.editor, shape)
		this.editor.selectNone()
	}

	component(shape: SlideShape) {
		const bounds = this.editor.getShapeGeometry(shape).bounds

		// eslint-disable-next-line react-hooks/rules-of-hooks
		const zoomLevel = useValue('zoom level', () => this.editor.getZoomLevel(), [this.editor])

		// eslint-disable-next-line react-hooks/rules-of-hooks
		const slides = useSlides()
		const index = slides.findIndex((s) => s.id === shape.id)

		// eslint-disable-next-line react-hooks/rules-of-hooks
		const handleLabelPointerDown = useCallback(() => this.editor.select(shape.id), [shape.id])

		if (!bounds) return null

		return (
			<>
				<div onPointerDown={handleLabelPointerDown} className="slide-shape-label">
					{`Slide ${index + 1}`}
				</div>
				<SVGContainer>
					<g
						style={{
							stroke: 'var(--color-text)',
							strokeWidth: 'calc(1px * var(--tl-scale))',
							opacity: 0.25,
						}}
						pointerEvents="none"
						strokeLinecap="round"
						strokeLinejoin="round"
					>
						{bounds.sides.map((side, i) => {
							const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
								side[0].dist(side[1]),
								1 / zoomLevel,
								{
									style: 'dashed',
									lengthRatio: 6,
									forceSolid: zoomLevel < 0.2,
								}
							)

							return (
								<line
									key={i}
									x1={side[0].x}
									y1={side[0].y}
									x2={side[1].x}
									y2={side[1].y}
									strokeDasharray={strokeDasharray}
									strokeDashoffset={strokeDashoffset}
								/>
							)
						})}
					</g>
				</SVGContainer>
			</>
		)
	}

	indicator(shape: SlideShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}
```
### SlidesPanel.tsx

```tsx
import { TldrawUiButton, stopEventPropagation, track, useEditor, useValue } from 'tldraw'
import { moveToSlide, useCurrentSlide, useSlides } from './useSlides'

export const SlidesPanel = track(() => {
	const editor = useEditor()
	const slides = useSlides()
	const currentSlide = useCurrentSlide()
	const selectedShapes = useValue('selected shapes', () => editor.getSelectedShapes(), [editor])

	if (slides.length === 0) return null
	return (
		<div className="slides-panel scroll-light" onPointerDown={(e) => stopEventPropagation(e)}>
			{slides.map((slide, i) => {
				const isSelected = selectedShapes.includes(slide)
				return (
					<TldrawUiButton
						key={'slides-panel-button:' + slide.id}
						type="normal"
						className="slides-panel-button"
						onClick={() => moveToSlide(editor, slide)}
						style={{
							background: currentSlide?.id === slide.id ? 'var(--color-background)' : 'transparent',
							outline: isSelected ? 'var(--color-selection-stroke) solid 1.5px' : 'none',
						}}
					>
						{`Slide ${i + 1}`}
					</TldrawUiButton>
				)
			})}
		</div>
	)
})
```
### slides.css

```css
.slides-panel {
	display: flex;
	flex-direction: column;
	gap: 4px;
	max-height: calc(100% - 110px);
	margin: 50px 0px;
	padding: 4px;
	background-color: var(--color-low);
	pointer-events: all;
	border-top-right-radius: var(--radius-4);
	border-bottom-right-radius: var(--radius-4);
	overflow: auto;
	border-right: 2px solid var(--color-background);
	border-bottom: 2px solid var(--color-background);
	border-top: 2px solid var(--color-background);
}

.slides-panel-button {
	border-radius: var(--radius-4);
	outline-offset: -1px;
}

.slide-shape-label {
	pointer-events: all;
	position: absolute;
	background: var(--color-low);
	padding: calc(12px * var(--tl-scale));
	border-bottom-right-radius: calc(var(--radius-4) * var(--tl-scale));
	font-size: calc(12px * var(--tl-scale));
	color: var(--color-text);
	white-space: nowrap;
}
```
### useSlides.tsx

```tsx
import { EASINGS, Editor, atom, useEditor, useValue } from 'tldraw'
import { SlideShape } from './SlideShapeUtil'

export const $currentSlide = atom<SlideShape | null>('current slide', null)

export function moveToSlide(editor: Editor, slide: SlideShape) {
	const bounds = editor.getShapePageBounds(slide.id)
	if (!bounds) return
	$currentSlide.set(slide)
	editor.selectNone()
	editor.zoomToBounds(bounds, {
		inset: 0,
		animation: { duration: 500, easing: EASINGS.easeInOutCubic },
	})
}

export function useSlides() {
	const editor = useEditor()
	return useValue<SlideShape[]>('slide shapes', () => getSlides(editor), [editor])
}

export function useCurrentSlide() {
	return useValue($currentSlide)
}

export function getSlides(editor: Editor) {
	return editor
		.getSortedChildIdsForParent(editor.getCurrentPageId())
		.map((id) => editor.getShape(id))
		.filter((s) => s?.type === 'slide') as SlideShape[]
}
```

# tldraw SDK Documentation

## Editor

The [`Editor`](/reference/editor/Editor) class is the main way of controlling tldraw's editor. You can use it to manage the editor's internal state, make changes to the document, or respond to changes that have occurred.

By design, the [`Editor`](/reference/editor/Editor)'s surface area is very large. Almost everything is available through it. Need to create some shapes? Use [`Editor.createShapes`](/reference/editor/Editor#createShapes). Need to delete them? Use [`Editor.deleteShapes`](/reference/editor/Editor#deleteShapes). Need a sorted array of every shape on the current page? Use [`Editor.getCurrentPageShapesSorted`](/reference/editor/Editor#getCurrentPageShapesSorted).

This page gives a broad idea of how the [`Editor`](/reference/editor/Editor) class is organized and some of the architectural concepts involved. The full reference is available in the [`Editor`](/reference/editor/Editor) API.

## Using the editor

You can access the editor in two ways:

1. From the [`Tldraw`](/reference/tldraw/Tldraw) component's `onMount` callback, where the editor is provided as the first argument in the callback.

```tsx
function App() {
	return (
		<Tldraw
			onMount={(editor) => {
				// your editor code here
			}}
		/>
	)
}
```

2. Via the [`useEditor`](/reference/editor/useEditor) hook. This must be called from within the JSX of the [`Tldraw`](/reference/tldraw/Tldraw) component.

```tsx
function InsideOfContext() {
	const editor = useEditor()
	// your editor code here
	return null // or whatever
}

function App() {
	return (
		<Tldraw>
			<InsideOfContext />
		</Tldraw>
	)
}
```

> If you are using the subcomponents as shown in [this example](/examples/editor-api/exploded), the editor instance is provided by the [`TldrawEditor`](/reference/editor/TldrawEditor) component.

## Store

The editor holds the raw state of the document in its [`Editor.store`](/reference/editor/Editor#store) property. Data is kept here as a table of JSON serializable records.

For example, the store contains a [`TLPage`](/reference/tlschema/TLPage) record for each page in the current document, as well as an [`TLInstancePageState`](/reference/tlschema/TLInstancePageState) record for each page that stores information about the editor's state for that page, and a single [`TLInstance`](/reference/tlschema/TLInstance) for each editor instance which stores the id of the user's current page.

The editor also exposes many _computed_ values which are derived from other records in the store. For example, [`Editor.getSelectedShapeIds`](/reference/editor/Editor#getSelectedShapeIds) is a method that returns the editor's current selected shape ids for its current page.

You can use these properties directly or you can use them in signals.

```tsx
import { track, useEditor } from 'tldraw'

export const SelectedShapeIdsCount = track(() => {
	const editor = useEditor()

	return <div>{editor.getSelectedShapeIds().length}</div>
})
```

### Changing the state

The [`Editor`](/reference/editor/Editor) class has many methods for updating its state. For example, you can change the current page's selection using [`Editor.setSelectedShapes`](/reference/editor/Editor#setSelectedShapes). You can also use other convenience methods, such as [`Editor.select`](/reference/editor/Editor#select), [`Editor.selectAll`](/reference/editor/Editor#selectAll), or [`Editor.selectNone`](/reference/editor/Editor#selectNone).

```ts
editor.selectNone()
editor.select(myShapeId, myOtherShapeId)
editor.getSelectedShapeIds() // [myShapeId, myOtherShapeId]
```

Each change to the state happens within a transaction. You can batch changes into a single transaction using the [`Editor.batch`](/reference/editor/Editor#batch) method. It's a good idea to batch wherever possible, as this reduces the overhead for persisting or distributing those changes.

### Listening for changes, and merging changes from other sources

For information about how to synchronize the store with other processes, i.e. how to get data out and put data in, see the [Persistence](/docs/persistence) page.

### Undo and redo

The history stack in tldraw contains two types of data:

- "diffs" the changes you make to the store
- "marks" undo/redo stopping points, created by calling [`Editor.markHistoryStoppingPoint`](/reference/editor/Editor#markHistoryStoppingPoint)

When you call [`Editor.undo`](/reference/editor/Editor#undo), the editor will undo each diff until it finds either a mark or the start of the stack. When you call [`Editor.redo`](/reference/editor/Editor#redo), the editor will redo each diff until it finds either a mark or the end of the stack.

```ts
editor.createShapes(...)
// A
editor.markHistoryStoppingPoint()
editor.selectAll()
editor.duplicateShapes(editor.getSelectedShapeIds())
// B

editor.undo() // will return to A
editor.redo() // will return to B
```

You can call [`Editor.bail`](/reference/editor/Editor#bail) to undo and delete all the diffs to the nearest mark, so they cannot be redone.

```ts
editor.createShapes(...)
// A
editor.markHistoryStoppingPoint()
editor.selectAll()
editor.duplicateShapes(editor.getSelectedShapeIds())
// B

editor.bail() // will return to A
editor.redo() // will do nothing
```

[`Editor.markHistoryStoppingPoint`](/reference/editor/Editor#markHistoryStoppingPoint) returns an id that you can use with [`Editor.bailToMark`](/reference/editor/Editor#bailToMark) to bail to a specific mark.

```ts
// A
const firstMark = editor.markHistoryStoppingPoint()
editor.selectAll()
// B
const secondMark = editor.markHistoryStoppingPoint()
editor.duplicateShapes(editor.getSelectedShapeIds())
// C

editor.bailToMark(firstMark) // will return to A
```

## Running code in context

You can use the [`Editor.run`](/reference/editor/Editor#run) method to run a function inside of a transaction. All changes made during the transaction will be settled at once. This improves performance and avoids unnecessary renders in the user interface.

```ts
editor.run(() => {
	editor.createShapes(myShapes)
	editor.sendToBack(myShapes)
	editor.selectNone()
})
```

You can also use [`Editor.run`](/reference/editor/Editor#run) to execute code with contextual options.

For example, you can use the options to perform actions without effecting the undo / redo history:

```ts
editor.run(
	() => {
		editor.createShapes(myShapes)
		editor.sendToBack(myShapes)
		editor.selectNone()
	},
	{ history: 'ignore' }
)
```

You can also use the options to make changes to locked shapes.

```ts
editor.run(
	() => {
		editor.updateShapes(myLockedShapes)
	},
	{ ignoreShapeLock: true }
)
```

## Events

The [`Editor`](/reference/editor/Editor) class receives events from its [`Editor.dispatch`](/reference/editor/Editor#dispatch) method. When the [`Editor`](/reference/editor/Editor) receives an event, it is first handled internally to update [`Editor.inputs`](/reference/editor/Editor#inputs) and other state before, and then sent into to the editor's state chart.

You shouldn't need to use the [`Editor.dispatch`](/reference/editor/Editor#dispatch) method directly, however you may write code in the state chart that responds to these events. See the [Tools page](/docs/tools) to learn how to do that, or read below for a more detailed information about the state chart itself.

### State Chart

The [`Editor`](/reference/editor/Editor) class has a "state chart", or a tree of [`StateNode`](/reference/editor/StateNode) instances, that contain the logic for the editor's tools such as the select tool or the draw tool. User interactions such as moving the cursor will produce different changes to the state depending on which nodes are active.

Each node can be active or inactive. Each state node may also have zero or more children. When a state is active, and if the state has children, one (and only one) of its children must also be active. When a state node receives an event from its parent, it has the opportunity to handle the event before passing the event to its active child. The node can handle an event in any way: it can ignore the event, update records in the store, or run a _transition_ that changes which states nodes are active.

When a user interaction is sent to the editor via its [`Editor.dispatch`](/reference/editor/Editor#dispatch) method, this event is sent to the editor's root state node ([`Editor.root`](/reference/editor/Editor#root)) and passed then down through the chart's active states until either it reaches a leaf node or until one of those nodes produces a transaction.

<Image
	src="/images/api/events.png"
	alt="A diagram showing an event being sent to the editor and handled in the state chart."
	title="The editor passes an event into the state start where it is handled by each active state in order."
/>

### Path

You can get the editor's current "path" of active states via `editor.root.path`. In the above example, the value would be `"root.select.idle"`.

You can check whether a path is active via [`Editor.isIn`](/reference/editor/Editor#isIn), or else check whether multiple paths are active via [`Editor.isInAny`](/reference/editor/Editor#isInAny).

```ts
editor.store.path // 'root.select.idle'

editor.isIn('root.select') // true
editor.isIn('root.select.idle') // true
editor.isIn('root.select.pointing_shape') // false
editor.isInAny('editor.select.idle', 'editor.select.pointing_shape') // true
```

Note that the paths you pass to [`Editor.isIn`](/reference/editor/Editor#isIn) or [`Editor.isInAny`](/reference/editor/Editor#isInAny) can be the full path or a partial of the start of the path. For example, if the full path is `root.select.idle`, then [`Editor.isIn`](/reference/editor/Editor#isIn) would return true for the paths `root`, `root.select`, or `root.select.idle`.

> If all you're interested in is the state below `root`, there is a convenience method, [`Editor.getCurrentToolId`](/reference/editor/Editor#getCurrentToolId), that can help with the editor's currently selected tool.

```tsx
import { track, useEditor } from 'tldraw'

export const BubbleToolUi = track(() => {
	const editor = useEditor()

	// Only show the UI if the bubble tool is active
	if (!editor.getCurrentToolId() === 'bubble') return null
	return <div>Creating bubble</div>
})
```

## Side effects

The [`Editor.sideEffects`](/reference/editor/Editor#sideEffects) object lets you register callbacks for key parts of the lifecycle of records in the [Store](#Store).
You can register callbacks for before or after a record is created, changed, or deleted.
These callbacks are useful for applying constraints, maintaining relationships, or checking the integrity of different records in the document.
For example, we use side effects to create a new [`TLCamera`](/reference/tlschema/TLCamera) record every time a new page is made.

The "before" callbacks allow you to modify the record itself, but shouldn't be used for modifying other records.
You can create a different record in the place of what was asked, prevent a change (or make a different one) to an existing record, or stop something from being deleted.

The "after" callbacks let you make changes to other records in response to something happening.
You could create, update, or delete any related record, but you should avoid changing the same record that triggered the change.

For example, if you wanted to know every time a new arrow is created, you could register a handler like this:

```ts
editor.sideEffects.registerAfterCreateHandler('shape', (newShape) => {
	if (newShape.type === 'arrow') {
		console.log('A new arrow shape was created', newShape)
	}
})
```

Side effect handlers are also given a `source` argument - either `"user"` or `"remote"`.
This indicates whether the change originated from the current user, or from another remote user in the same multiplayer room.
You could use this to e.g. prevent the current user from deleting shapes, but allow deletions from others in the same room.

## Inputs

The [`Editor.inputs`](/reference/editor/Editor#inputs) object holds information about the user's current input state, including their cursor position (in page space _and_ screen space), which keys are pressed, what their multi-click state is, and whether they are dragging, pointing, pinching, and so on.

Note that the modifier keys include a short delay after being released in order to prevent certain errors when modeling interactions. For example, when a user releases the "Shift" key, `editor.inputs.shiftKey` will remain `true` for another 100 milliseconds or so.

This property is stored as regular data. It is not reactive.

## Editor instance state

The [`Editor.getInstanceState`](/reference/editor/Editor#getInstanceState) method returns settings that relate to each individual instance of the editor. In the case that the user has the same editor open in multiple tabs, or if there are multiple editors on the same page, then each editor will have its own instance state. See the [`TLInstance`](/reference/tlschema/TLInstance) docs to learn more about the record itself.

## User preferences

The editor's user preferences are shared between all instances. See the the [`UserPreferencesManager`](/reference/editor/UserPreferencesManager) for more about the user preferences.

# Camera and coordinates

The editor offers many methods and properties relating to the part of the infinite canvas that is displayed in the component. This section includes key concepts and methods that you can use to change or control which parts of the canvas are visible.

## Viewport

The viewport is the rectangular area contained by the editor.

| Method                              | Description                                                                                                        |
| ----------------------------------- | ------------------------------------------------------------------------------------------------------------------ |
| [`Editor.getViewportScreenBounds`](/reference/editor/Editor#getViewportScreenBounds) | A [`Box`](/reference/editor/Box) that describes the size and position of the component's canvas in actual screen pixels.                 |
| [`Editor.getViewportPageBounds`](/reference/editor/Editor#getViewportPageBounds)   | A [`Box`](/reference/editor/Box) that describes the size and position of the part of the current page that is displayed in the viewport. |

## Screen vs. page coordinates

In tldraw, coordinates can either be in page or screen space.

A "screen point" refers to the point's distance from the top left corner of the component.

A "page point" refers to the point's distance from the "zero point" of the canvas.

When the camera is at `{x: 0, y: 0, z: 0}`, the screen point and page point will be identical. As the camera moves, however, the viewport will display a different part of the page; and so a screen point will correspond to a different page point.

| Method                   | Description                                    |
| ------------------------ | ---------------------------------------------- |
| [`Editor.screenToPage`](/reference/editor/Editor#screenToPage) | Convert a point in screen space to page space. |
| [`Editor.pageToScreen`](/reference/editor/Editor#pageToScreen) | Convert a point in page space to screen space. |

You can get the user's pointer position in both screen and page space.

```ts
const {
	// The user's most recent page / screen points
	currentPagePoint,
	currentScreenPoint,
	// The user's previous page / screen points
	previousPagePoint,
	previousScreenPoint,
	// The last place where the most recent pointer down occurred
	originPagePoint,
	originScreenPoint,
} = editor.inputs
```

## Camera options

You can use the editor's camera options to configure the behavior of the editor's camera. There are many options available.

### `wheelBehavior`

When set to `'pan'`, scrolling the mousewheel will pan the camera. When set to `'zoom'`, scrolling the mousewheel will zoom the camera. When set to `none`, it will have no effect.

### `panSpeed`

The speed at which the camera pans. A pan can occur when the user holds the spacebar and drags, holds the middle mouse button and drags, drags while using the hand tool, or scrolls the mousewheel. The default value is `1`. A value of `0.5` would be twice as slow as default. A value of `2` would be twice as fast. When set to `0`, the camera will not pan.

### `zoomSpeed`

The speed at which the camera zooms. A zoom can occur when the user pinches or scrolls the mouse wheel. The default value is `1`. A value of `0.5` would be twice as slow as default. A value of `2` would be twice as fast. When set to `0`, the camera will not zoom.

### `zoomSteps`

The camera's "zoom steps" are an array of discrete zoom levels that the camera will move between when using the "zoom in" or "zoom out" controls.

The first number in the `zoomSteps` array defines the camera's minimum zoom level. The last number in the `zoomSteps` array defines the camera's maximum zoom level.

If the `constraints` are provided, then the actual value for the camera's zoom will be be calculated by multiplying the value from the `zoomSteps` array with the value from the `baseZoom`. See the `baseZoom` property for more information.

### `isLocked`

Whether the camera is locked. When the camera is locked, the camera will not move.

### `constraints`

By default the camera is free to move anywhere on the infinite canvas. However, you may provide the camera with a `constraints` object that constrains the camera based on a relationship between `bounds` (in page space) and the `viewport` (in screen space).

### `constraints.bounds`

A box model describing the bounds in page space.

### `constraints.padding`

An object with padding to apply to the `x` and `y` dimensions of the viewport. The padding is in screen space.

### `constraints.origin`

An object with an origin for the `x` and `y` dimensions. Depending on the `behavior`, the origin may be used to position the bounds within the viewport.

For example, when the `behavior` is `fixed` and the `origin.x` is `0`, the bounds will be placed with its left side touching the left side of the viewport. When `origin.x` is `1` the bounds will be placed with its right side touching the right side of the viewport. By default the origin for each dimension is .5. This places the bounds in the center of the viewport.

### `constraints.initialZoom`

The `initialZoom` option defines the camera's initial zoom level and what the zoom should be when when the camera is reset. The zoom it produces is based on the value provided:

| Value         | Description                                                                                    |
| ------------- | ---------------------------------------------------------------------------------------------- |
| `default`     | Sets the initial zoom to 100%.                                                                 |
| `fit-x`       | The x axis will completely fill the viewport bounds.                                           |
| `fit-y`       | The y axis will completely fill the viewport bounds.                                           |
| `fit-min`     | The smaller axis will completely fill the viewport bounds.                                     |
| `fit-max`     | The larger axis will completely fill the viewport bounds.                                      |
| `fit-x-100`   | The x axis will completely fill the viewport bounds, or 100% zoom, whichever is smaller.       |
| `fit-y-100`   | The y axis will completely fill the viewport bounds, or 100% zoom, whichever is smaller.       |
| `fit-min-100` | The smaller axis will completely fill the viewport bounds, or 100% zoom, whichever is smaller. |
| `fit-max-100` | The larger axis will completely fill the viewport bounds, or 100% zoom, whichever is smaller.  |

### `constraints.baseZoom`

The `baseZoom` property defines the base property for the camera's zoom steps. It accepts the same values as `initialZoom`.

When `constraints` are provided, then the actual value for the camera's zoom will be be calculated by multiplying the value from the `zoomSteps` array with the value from the `baseZoom`.

For example, if the `baseZoom` is set to `default`, then a zoom step of 2 will be 200%. However, if the `baseZoom` is set to `fit-x`, then a zoom step value of 2 will be twice the zoom level at which the bounds width exactly fits within the viewport.

### `constraints.behavior`

The `behavior` property defines which logic should be used when calculating the bounds position.

| Value     | Description                                                                                                                                 |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------- |
| 'free'    | The bounds may be placed anywhere relative to the viewport. This is the default "infinite canvas" experience.                               |
| 'inside'  | The bounds must stay entirely within the viewport.                                                                                          |
| 'outside' | The bounds may partially leave the viewport but must never leave it completely.                                                             |
| 'fixed'   | The bounds are placed in the viewport at a fixed location according to the `'origin'`.                                                      |
| 'contain' | When the zoom is below the "fit zoom" for an axis, the bounds use the `'fixed'` behavior; when above, the bounds use the `inside` behavior. |

## Controlling the camera

There are several `Editor` methods available for controlling the camera.

| Method                          | Description                                                                                         |
| ------------------------------- | --------------------------------------------------------------------------------------------------- |
| [`Editor.setCamera`](/reference/editor/Editor#setCamera)           | Moves the camera to the provided coordinates.                                                       |
| [`Editor.zoomIn`](/reference/editor/Editor#zoomIn)              | Zooms the camera in to the nearest zoom step. See the `constraints.zoomSteps` for more information. |
| [`Editor.zoomOut`](/reference/editor/Editor#zoomOut)             | Zooms the camera in to the nearest zoom step. See the `constraints.zoomSteps` for more information. |
| [`Editor.zoomToFit`](/reference/editor/Editor#zoomToFit)           | Zooms the camera in to the nearest zoom step. See the `constraints.zoomSteps` for more information. |
| [`Editor.zoomToBounds`](/reference/editor/Editor#zoomToBounds)        | Moves the camera to fit the given bounding box.                                                     |
| [`Editor.zoomToSelection`](/reference/editor/Editor#zoomToSelection)     | Moves the camera to fit the current selection.                                                      |
| [`Editor.zoomToUser`](/reference/editor/Editor#zoomToUser)          | Moves the camera to center on a user's cursor.                                                      |
| [`Editor.resetZoom`](/reference/editor/Editor#resetZoom)           | Resets the zoom to 100% or to the `initialZoom` zoom level.                                         |
| [`Editor.centerOnPoint`](/reference/editor/Editor#centerOnPoint)       | Centers the camera on the given point.                                                              |
| [`Editor.stopCameraAnimation`](/reference/editor/Editor#stopCameraAnimation) | Stops any camera animation.                                                                         |

## Camera state

The camera may be in two states, `idle` or `moving`.

You can get the current camera state with [`Editor.getCameraState`](/reference/editor/Editor#getCameraState).

# Bindings

A binding is a relationship from one [shape](/docs/shapes) to another. They're used to connect
shapes so they can update together or depend on one and other. For example: tldraw's default arrow
shape uses bindings to connect the ends of the arrows to the shapes they're pointing to, one binding
for each end of the arrow.

You can create different types of binding that do all sorts of different things with relationships
between shapes. For example, you could create a [sticker
shape](/examples/shapes/tools/sticker-bindings) that sticks to any other shape it's dropped onto.

## The binding object

Bindings are records (JSON objects) that live in the [store](/docs/editor#store). For example,
here's a binding record for one end of an arrow shape:

```json
{
    "id": "binding:someId",
    "typeName": "binding"
    "type": "arrow",
    "fromId": "shape:arrowId",
    "toId": "shape:someOtherShapeId",
    "props": {
        "terminal": "end"
        "isPrecise": true,
        "isExact": false,
        "normalizedAnchor": {
            "x": 0.5,
            "y": 0.5
        },
    },
    "meta": {},
}
```

Every binding contains some base information - its ID & the type of binding, as well as the ID of
the shape that a binding comes _from_ and the ID of the shape that the binding goes _to_. These two
properties work the same way, but it's often useful to have an explicit direction in a binding
relationship. For example, an arrow binding always goes _from_ an arrow _to_ another shape.

Bindings contain their own type-specific information in the `props` object. Each type of binding can
have different props.

Bindings also have a `meta` property which can be used by your application to add data to bindings
you haven't built yourself. You can read more about the meta property
[here](/docs/shapes#Meta-information).

## Custom bindings

To create a binding of your own, you can define a custom binding.

### The binding type

First, you need to create a type that describes what the binding object will look like:

```ts
import { TLBaseBinding } from 'tldraw'

type StickerBinding = TLBaseBinding<'sticker', { x: number; y: number }>
```

With [`TLBaseBinding`](/reference/tlschema/TLBaseBinding) we define the binding's type (`sticker`) and `props` property (`{x: number,
y: number}`). The type can be any string, and the props must be a plain JSON object (ie not a class
instance).

The [`TLBaseBinding`](/reference/tlschema/TLBaseBinding) helper adds the other base properties like `id`, `toId`, and `fromId`.

### The `BindingUtil` class

While bindings themselves are plain JSON objects, we use
[`BindingUtil`](/reference/editor/BindingUtil) classes to define how bindings should work. They tell
tldraw the structure of a binding, and what to do when it or the shapes it involves are created,
updated, or deleted.

```ts
import { BindingUtil } from 'tldraw'

class StickerBindingUtil extends BindingUtil<StickerBinding> {
	static override type = 'sticker' as const

	override getDefaultProps() {
		return { x: 0.5, y: 0.5 }
	}

	override onAfterChangeToShape({ binding }) {
		const sticker = this.editor.getShape(binding.fromShape)

		// move the sticker so it stays attached to the to shape
	}
}
```

Each binding util needs a `type` and `getDefaultProps` to define its basic structure. You can also
define a number of different callbacks describing how the binding should behave. See the
[`BindingUtil`](/reference/editor/BindingUtil) reference or a [complete example of a
binding](/examples/shapes/tools/sticker-bindings) for details.

If the structure of your binding needs to change over time, you can provide
[migrations](/docs/persistence#Shape-props-migrations) describing how old stored bindings can be
brought up to date.

## Image exports

You can export the contents of the canvas to an image with [`Editor.toImage`](/reference/editor/Editor#toImage).

Image exports draw your shapes as an SVG, then convert the SVG to another format (like a PNG) if needed. Use [`Editor.getSvgElement`](/reference/editor/Editor#getSvgElement) or [`Editor.getSvgString`](/reference/editor/Editor#getSvgString) if you want to work with the SVG directly.

### Exporting custom shapes

By default, custom shape exports use the [`ShapeUtil.component`](/reference/editor/ShapeUtil#component) method that's used to render your shape normally. We embed the result in a [`<foreignObject>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/foreignObject) element. This works well for most shapes, but isn't perfect (see [below](#Export-limitations)). For more control over exports, you can implement [`ShapeUtil.toSvg`](/reference/editor/ShapeUtil#toSvg) to properly convert your shape to an SVG.

Use the [`useSvgExportContext`](/reference/editor/useSvgExportContext) hook to check if your shape is being rendered for an SVG export. If you need to load data or assets asynchronously, use the [`useDelaySvgExport`](/reference/editor/useDelaySvgExport) hook to delay the export until you're ready.

SVGs can't refer to any external assets like images, fonts, or CSS. Everything needs to be included inline in the SVG, with images and fonts converted to data URLs. `<foreignObject>` exports that use the `component` methods try to handle this automatically, but if you implement `toSvg` you'll need to do it yourself. You can use [`SvgExportContext.addExportDef`](/reference/editor/SvgExportContext#addExportDef) to add definitions to the SVG that can be shared by multiple shapes.

### Export limitations

Hand-authored `toSvg` are typically very reliable and have good compatibility with other SVG tools. However, most SVG editors (and even some viewers) don't support the `<foreignObject>` element, so the default `component` based exports don't work as well outside of the browser. If you want to make sure that your exports look the same in all viewers, either implement `toSvg` or convert directly to a PNG or other raster format.

Even within browsers though, `<foreignObject>`s and the method we use to create them aren't always 100% reliable. Chromium based browsers tend to work well, but Firefox occasionally has layout issues, and Safari has rendering quirks with effects like box shadows. It's sometimes useful to apply different styles during exports in certain browsers.

We can only embed external assets such as images and font files if they're either hosted on the same origin as tldraw, or have [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) headers set. If external assets are missing from your export, check your browser's network tab to see if these are being requested and if anything is going wrong with them.

# Common things to do with the editor

### Create a shape id

To create an id for a shape (a [`TLShapeId`](/reference/tlschema/TLShapeId)), use the libary's [`createShapeId`](/reference/tlschema/createShapeId) helper.

```ts
import { createShapeId } from 'tldraw'

createShapeId() // `shape:some-random-uuid`
createShapeId('kyle') // `shape:kyle`
```

The `id` property of any record in tldraw is "branded" with the type of that record. For shapes, that means that all shape ids are formatted as `shape:{id}`. The TypeScript type of a record's `id` also includes a reference to the type of the record that it belongs to. TypeScript will complain if you use a regular `shape:some-id` string, but the [`createShapeId`](/reference/tlschema/createShapeId) helper will provide the type.

### Create shapes

To create shapes, use the [`Editor.createShape`](/reference/editor/Editor#createShape) or [`Editor.createShapes`](/reference/editor/Editor#createShapes) methods.

```ts
editor.createShapes([
	{
		id,
		type: 'geo',
		x: 0,
		y: 0,
		props: {
			geo: 'rectangle',
			w: 100,
			h: 100,
			dash: 'draw',
			color: 'blue',
			size: 'm',
		},
	},
])
```

A shape must be a partial of the full shape (a [`TLShapePartial`](/reference/tlschema/TLShapePartial)). All props are optional except for the `type` of the shape. The shape's corresponding [`ShapeUtil`](/reference/editor/ShapeUtil) will provide the default props for any props not provided. The `id` will be created if not provided.

### Update shapes

To update shapes, use the [`Editor.updateShape`](/reference/editor/Editor#updateShape) or [`Editor.updateShapes`](/reference/editor/Editor#updateShapes) methods.

```ts
editor.updateShapes([
	{
		id: shape.id, // required
		type: shape.type, // required
		x: 100,
		y: 100,
		props: {
			w: 200,
		},
	},
])
```

The update must be a partial of the full shape (a [`TLShapePartial`](/reference/tlschema/TLShapePartial)). All props are optional except for the `type` of the shape and its `id`.

### Delete shapes

To delete shapes, use the [`Editor.deleteShape`](/reference/editor/Editor#deleteShape) or [`Editor.deleteShapes`](/reference/editor/Editor#deleteShapes) methods.

```ts
editor.deleteShapes([shape.id])
editor.deleteShapes([shape])
```

You can delete a shape using the shape's `id` or the shape record itself.

### Get a shape

You can get a shape with the [`Editor.getShape`](/reference/editor/Editor#getShape) method.

```ts
editor.getShape(myShapeId)
editor.getShape(myShape)
```

You can get a shape using the shape's `id` or the shape record itself.

### Turn on read only mode

You can use the [`Editor.updateInstanceState`](/reference/editor/Editor#updateInstanceState) method to turn on read only mode.

```ts
editor.updateInstanceState({ isReadonly: true })
```

### Move the camera

You can set the camera to a specific x, y, and zoom with the [`Editor.setCamera`](/reference/editor/Editor#setCamera) method.

```ts
editor.setCamera({ x: 0, y: 0, z: 1 })
```

### Freeze the camera

You can prevent the user from changing the camera using the `Editor.setCameraOptions` method.

```ts
editor.setCameraOptions({ isLocked: true })
```

### Turn on dark mode

You can turn on or off dark mode via the [`UserPreferencesManager`](/reference/editor/UserPreferencesManager). Note that this effects all editor instances that share the same user—even instances in other tabs.

```ts
editor.user.updateUserPreferences({ colorScheme: 'dark' })
```

### Using the system color scheme

You can also use the system color scheme via the [`UserPreferencesManager`](/reference/editor/UserPreferencesManager).

```ts
editor.user.updateUserPreferences({ colorScheme: 'system' })
```

### Make changes without effecting the history

You can use the [`Editor.run`](/reference/editor/Editor#run) method to make changes without effecting the undo redo history.

```ts
editor.run(
	() => {
		editor.deleteShapes(myLockedShapes)
	},
	{ history: 'ignore' }
)
```

### Make changes to locked shape

You can use the [`Editor.run`](/reference/editor/Editor#run) method to make changes to locked shapes without having to unlock them first.

```ts
editor.run(
	() => {
		editor.deleteShapes(myLockedShapes)
	},
	{ ignoreShapeLock: true }
)
```

### Hiding shapes

You can pass a `isShapeHidden` predicate when configuring tldraw. This predicate will be called for each shape to determine if it should be hidden.

Hidden shapes will still be present in the store, but

- They will not be shown on the canvas
- They will not be included in hit test results via `editor.getShapeAtPoint` and `editor.getShapesAtPoint`
- They will be excluded from the arrays returned by `editor.getRenderingShapes` and `editor.getCurrentPageRenderingShapesSorted`
- They will not be exported in image exports or rendered when printing.

Otherwise, they will behave as normal.

One place where this might be problematic for you, depending on what features you're using `isShapeHidden` to implement, is that hidden shapes will still be selectable, e.g. via the `select-all` action (`Cmd+A` or `Ctrl+A`).

You can prevent that by cleaning up the selection in a signal reaction that is set up in the `onMount` callback:

```tsx
<Tldraw
	isShapeHidden={(shape) => shape.meta.hidden}
	onMount={(editor) => {
		// We don't prevent hidden shapes from being selected out of the box, because there are some situations where it's desirable.
		// If you want to prevent hidden shapes from being selected, you can do so like this:
		return react('clean up selection', () => {
			const selectedShapeIds = editor.getSelectedShapeIds()
			const filteredSelectedShapeIds = selectedShapeIds.filter((id) => !editor.isShapeHidden(id))
			if (selectedShapeIds.length !== filteredSelectedShapeIds.length) {
				editor.setSelectedShapes(filteredSelectedShapeIds)
			}
		})
	}}
/>
```

For example usages, see the [collaboration private content example](/examples/collaboration/sync-private-content) and the [layer panel example](/examples/ui/layer-panel).

---

See the [tldraw repository](https://github.com/tldraw/tldraw/tree/main/apps/examples) for an example of how to use tldraw's Editor API to control the editor.
## Shapes

In tldraw, a shape is something that can exist on the page, like an arrow, an image, or some text.

This article is about shapes: what they are, how they work, and how to create your own shapes. If you'd prefer to see an example, see the tldraw repository's [examples app](https://github.com/tldraw/tldraw/tree/main/apps/examples) for examples of how to create custom shapes in tldraw.

## Types of shape

We make a distinction between three types of shapes: "core", "default", and "custom".

### Core shapes

The editor's core shapes are shapes that are built in and always present. At the moment the only core shape is the [group shape](/reference/tlschema/TLGroupShape).

### Default shapes

The default shapes are all of the shapes that are included by default in the [`Tldraw`](/reference/tldraw/Tldraw) component, such as the [`TLArrowShape`](/reference/tlschema/TLArrowShape) or [`TLDrawShape`](/reference/tlschema/TLDrawShape). They are exported from the `tldraw` library as [`defaultShapeUtils`](/reference/tldraw/defaultShapeUtils).

### Custom shapes

Custom shapes are shapes that were created by you or someone you love. Find more information about custom shapes [below](#Custom-shapes-1).

## The shape object

Shapes are just records (JSON objects) that sit in the [store](/docs/editor#Store). For example, here's a shape record for a rectangle geo shape:

```ts
{
    "parentId": "page:somePage",
    "id": "shape:someId",
    "typeName": "shape",
    "type": "geo",
    "x": 106,
    "y": 294,
    "rotation": 0,
    "index": "a28",
    "opacity": 1,
    "isLocked": false,
    "props": {
        "w": 200,
        "h": 200,
        "geo": "rectangle",
        "color": "black",
        "labelColor": "black",
        "fill": "none",
        "dash": "draw",
        "size": "m",
        "font": "draw",
        "text": "diagram",
        "align": "middle",
        "verticalAlign": "middle",
        "growY": 0,
        "url": ""
    },
    "meta": {},
}
```

### Base properties

Every shape contains some base information. These include the shape's type, position, rotation, opacity, and more. You can find the full list of base properties [here](/reference/tlschema/TLBaseShape).

### Props

Every shape also contains some shape-specific information, called `props`. Each type of shape can have different props. For example, the `props` of a text shape are much different than the props of an arrow shape.

### Meta

Meta information is information that is not used by tldraw but is instead used by your application. For example, you might want to store the name of the user who created a shape, or the date that the shape was created. You can find more information about meta information [below](#Meta-information).

## The `ShapeUtil` class

While tldraw's shapes themselves are simple JSON objects, we use [`ShapeUtil`](/reference/editor/ShapeUtil) classes to answer questions about shapes. For example, when the editor needs to render a text shape, it will find the [`TextShapeUtil`](/reference/tldraw/TextShapeUtil) and call its [`ShapeUtil.component`](/reference/editor/ShapeUtil#component) method, passing in the text shape object as an argument.

---

## Custom shapes

You can create your own custom shapes. In the examples below, we will create a custom "card" shape. It'll be a simple rectangle with some text inside.

> For an example of how to create custom shapes, see our [custom shapes example](/examples/shapes/tools/custom-shape).

### Shape type

In tldraw's data model, each shape is represented by a JSON object. Let's first create a type that describes what this object will look like.

```ts
import { TLBaseShape } from 'tldraw'

type CardShape = TLBaseShape<'card', { w: number; h: number }>
```

With the [`TLBaseShape`](/reference/tlschema/TLBaseShape) helper, we define the shape's `type` property (`card`) and the shape's `props` property (`{ w: number, h: number }`). The type can be any string but the props must be a regular [JSON-serializable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#description) JavaScript object.

The [`TLBaseShape`](/reference/tlschema/TLBaseShape) helper adds the other base properties of a shape, such as `x`, `y`, `rotation`, and `opacity`.

### Shape Util

While tldraw's shapes themselves are simple JSON objects, we use [`ShapeUtil`](/reference/editor/ShapeUtil) classes to answer questions about shapes.

Let's create a [`ShapeUtil`](/reference/editor/ShapeUtil) class for the shape.

```tsx
import { HTMLContainer, ShapeUtil } from 'tldraw'

class CardShapeUtil extends ShapeUtil<CardShape> {
	static override type = 'card' as const

	getDefaultProps(): CardShape['props'] {
		return {
			w: 100,
			h: 100,
		}
	}

	getGeometry(shape: CardShape) {
		return new Rectangle2d({
			width: shape.props.w,
			height: shape.props.h,
			isFilled: true,
		})
	}

	component(shape: CardShape) {
		return <HTMLContainer>Hello</HTMLContainer>
	}

	indicator(shape: CardShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}
```

This is a minimal [`ShapeUtil`](/reference/editor/ShapeUtil). We've given it a static property `type` that matches the type of our shape, we've provided implementations for the abstract methods [`ShapeUtil.getDefaultProps`](/reference/editor/ShapeUtil#getDefaultProps), [`ShapeUtil.getBounds`](/reference/editor/ShapeUtil#getBounds), [`ShapeUtil.component`](/reference/editor/ShapeUtil#component), and [`ShapeUtil.indicator`](/reference/editor/ShapeUtil#indicator).

We still have work to do on the `CardShapeUtil` class, but we'll come back to it later. For now, let's put the shape onto the canvas by passing it to the [`Tldraw`](/reference/tldraw/Tldraw) component.

### The `shapeUtils` prop

We pass an array of our shape utils into the [`Tldraw`](/reference/tldraw/Tldraw) component's `shapeUtils` prop.

```tsx
const MyCustomShapes = [CardShapeUtil]

export default function () {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw shapeUtils={MyCustomShapes} />
		</div>
	)
}
```

We can create one of our custom card shapes using the [`Editor`](/reference/editor/Editor) API. We'll do this by setting the `onMount` prop of the [`Tldraw`](/reference/tldraw/Tldraw) component.

```tsx
export default function () {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw
				shapeUtils={MyCustomShapes}
				onMount={(editor) => {
					editor.createShapes([{ type: 'card' }])
				}}
			/>
		</div>
	)
}
```

Once the page refreshes, we should now have our custom shape on the canvas.

### Meta information

Shapes also have a `meta` property (see [`TLBaseShape.meta`](/reference/tlschema/TLBaseShape#meta)) that you can fill with your own data. This should feel like a bit of a hack, however it's intended to be an escape hatch for applications where you want to use tldraw's existing shapes but also want to attach a bit of extra data to the shape.

Note that tldraw's regular shape definitions have an unknown object for the shape's `meta` property. To type your shape's meta, use a union like this:

```ts
type MyShapeWithMeta = TLGeoShape & { meta: { createdBy: string } }

const shape = editor.getShape<MyShapeWithMeta>(myGeoShape.id)
```

You can update a shape's `meta` property in the same way you would update its props, using [`Editor.updateShapes`](/reference/editor/Editor#updateShapes).

```ts
editor.updateShapes<MyShapeWithMeta>([
	{
		id: myGeoShape.id,
		type: 'geo',
		meta: {
			createdBy: 'Steve',
		},
	},
])
```

Like [`TLBaseShape.props`](/reference/tlschema/TLBaseShape#props), the data in a [`TLBaseShape.meta`](/reference/tlschema/TLBaseShape#meta) object must be JSON serializable.

In addition to setting meta properties this way, you can also set the default meta data for shapes using the Editor's [`Editor.getInitialMetaForShape`](/reference/editor/Editor#getInitialMetaForShape) method.

```tsx
editor.getInitialMetaForShape = (shape: TLShape) => {
	if (shape.type === 'text') {
		return { createdBy: currentUser.id, lastModified: Date.now() }
	} else {
		return { createdBy: currentUser.id }
	}
}
```

Whenever new shapes are created using the [`Editor.createShapes`](/reference/editor/Editor#createShapes) method, the shape's meta property will be set using the [`Editor.getInitialMetaForShape`](/reference/editor/Editor#getInitialMetaForShape) method. By default this method returns an empty object.

### Using starter shapes

You can use "starter" shape utils like [`BaseBoxShapeUtil`](/reference/editor/BaseBoxShapeUtil) to get regular rectangular shape behavior.

### Flags

You can use flags like [`ShapeUtil.hideRotateHandle`](/reference/editor/ShapeUtil#hideRotateHandle) to hide different parts of the UI when the shape is selected, or else to control different behaviors of the shape.

### Interaction

You can turn on `pointer-events` to allow users to interact inside of the shape.

### Editing

You can make shapes "editable" to help decide when they're interactive or not.

### Labels (plain text and rich text)

Our shapes have the ability to have include labels. Those labels can either have plain text (the `text` prop) or rich text (`richText`), as desired.
For rich text, the tldraw editor provides first-class support for [TipTap](https://tiptap.dev/) out of the box. The underlying document for the richText is
a TipTap JSON-stringified document that is stored within the `richText` property. (For that reason, we don't do character-by-character synchronization of
the text within a shape. This was a design choice as much of tldraw's text ends up being short-form).

If you would like to use rich text within your shape you can use our [`RichTextLabel`](/reference/tldraw/RichTextLabel) component to help you get started with rendering rich text. Under the hood
this uses [`RichTextArea`](/reference/tldraw/RichTextArea) which loads a TipTap instance and to handle the editing of rich text.

If you would like to use plain text you would use the corresponding [`PlainTextLabel`](/reference/tldraw/PlainTextLabel) and [`PlainTextArea`](/reference/tldraw/PlainTextArea) components.

#### Text measurement

One of the challenges with our shapes is getting an accurate measurement of the bounds of the shape.
Traditionally you could have used our [`TextManager.measureText`](/reference/editor/TextManager#measureText). However, because rich text is HTML, the API to use for that is [`TextManager.measureHtml`](/reference/editor/TextManager#measureHtml)

#### Extending TipTap

Here's a simple example of how you could add a custom extension (in this case `FontFamily`) to the editor:

```ts
const textOptions = {
	tipTapConfig: {
		extensions: [...tipTapDefaultExtensions, FontFamily],
	},
}

export default function RichTextCustomExtensionExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="rich-text-custom-extension"
				components={components}
				textOptions={textOptions}
			/>
		</div>
	)
}
```

On our [examples site](https://examples.tldraw.com/) please filter by "rich text" and you will find examples on how to add custom extensions or UI to tailor the rich text.

#### Exports for rich text

One of the other challenges right now with rich text is the exports. We use the SVG `foreignObject` to insert rich text into the shapes.
This isn't ideal and we're looking in the future to help improve this.

### Migrations

You can add migrations for your shape props by adding a `migrations` property to your shape's util class. See [the persistence docs](/docs/persistence#Shape-props-migrations) for more information.
## Tools

In tldraw, a **tool** is what we call any top-level state in our state chart. For example, the select tool, the draw tool, and the arrow tool are all top-level states that the user can be in.

<Image
	title="Tools"
	src="/images/api/tools.png"
	alt="A diagram showing the state chart of tldraw. The top row of states (apart from the Root state) are annotated as tools."
	title="The first level of states in the start chart are known as tools."
/>

For more detailed information about the state chart, and how it works, go to the [Editor page](/docs/editor). Or read below for more information about tools, and how to make your own.

## Types of tool

The tldraw editor comes with some in-built **core tools**: the [select tool](/reference/tldraw/SelectTool), the [zoom tool](/reference/tldraw/ZoomTool), and the [text tool](/reference/tldraw/TextShapeTool). These are always added to the state chart.

There are also some **default tools** available, like the [draw tool](/reference/tldraw/DrawShapeTool), the [hand tool](/reference/tldraw/HandTool), the [arrow tool](/reference/tldraw/ArrowShapeTool), and more. The `<Tldraw>` component automatically adds these tools to the state chart.

You can also create your own **custom tools**. You can add them to the state chart by passing an array of them to the [`Tldraw`](/reference/tldraw/Tldraw) component's `tools` prop.

Note: You might also want to add a tool to the user interface in various ways, such as the toolbar. See the [User Interface](/docs/user-interface) section for more on changing the menus.

## Transitioning

You can change the current active tool using [editor.setCurrentTool](/reference/editor/Editor#setCurrentTool).

```ts
editor.setCurrentTool('select')
```

You can "deep transition" by using a path of active tool ids.

```ts
editor.setCurrentTool('select.eraser.pointing')
```

## Inside a tool

Every tool has an **id**. This is used to identify it in the state chart.

```ts
class MyTool extends StateNode {
	static override id = 'my-tool'
}
```

Tools can contain **children**. For example, the [hand tool](/reference/tldraw/HandTool) has three children, `Idle`, `Pointing` and `Dragging`. If a state has children, it must also have an `initial` state, so that it knows which state to start in.

```ts
class MyIdleState extends StateNode {
	static override id = 'my-idle-state'
}

class MyPointingState extends StateNode {
	static override id = 'my-pointing-state'
}

class MyTool extends StateNode {
	static override id = 'my-tool'
	static override initial = 'my-idle-state'
	static override children() {
		return [MyIdleState, MyPointingState]
	}
}
```

### Handling events

When the editor receives an [event](/reference/editor/TLEventHandlers) via its [`Editor.dispatch`](/reference/editor/Editor#dispatch) method, the event is first processed in order to update its inputs, then passed to the editor's state chart.

Beginning at the root, each node will first handle the event and then pass the event to its current active child state. This continues until either: the event is handled on a state without any children; or the event is handled in a way that produces a transition.

### Parents handle events before children

```ts
class MyIdleState extends StateNode {
	static override id = 'my-idle-state'

	onPointerDown(info: TLPointerEventInfo) {
		console.log('world')
	}
}

class MyTool extends StateNode {
	static override id = 'my-tool'
	static override initial = 'my-idle-state'
	static override children() {
		return [MyIdleState]
	}

	onPointerDown(info: TLPointerEventInfo) {
		console.log('hello')
	}
}
```

Using the example above, if a `pointer_down` event is passed to the editor while the `MyTool` state is active, `MyTool`'s `onPointerDown` method will be called first, then `MyIdleState`'s `onPointerDown` method will be called second.

### Transitions stop the process

```ts
class MyIdleState extends StateNode {
	static override id = 'my-idle-state'

	onPointerDown(info: TLPointerEventInfo) {
		console.log("this won't run")
	}
}

class MyTool extends StateNode {
	static override id = 'my-tool'
	static override initial = 'my-idle-state'
	static override children = [MyIdleState]

	onPointerDown(info: TLPointerEventInfo) {
		editor.setCurrentTool('select')
	}
}
```

If `MyTool`'s `onPointerDown` handler produced a transition (changing anything about which states are active) then the chain would stop and the event would not be handled on `MyIdleState`.
## User interface

The user interface in tldraw includes the menus, toolbars, keyboard shortcuts, and analytics events in the editor.

## Hiding the UI

You can hide the default tldraw user interface entirely using the `hideUi` prop. This turns off both the visuals as well as the keyboard shortcuts.

```tsx
function Example() {
	return <Tldraw hideUi />
}
```

Here's [an example](https://examples.tldraw.com/hide-ui) of what that looks like. Note that while you can't select any other tools using the keyboard shortcuts, you can still use the `setCurrentTool` method to change the tool. If you open the console and enter:

```ts
editor.setCurrentTool('draw')
```

...then you can start drawing.

All of our user interface works by controlling the editor via its `Editor` methods. If you hide the user interface, you can still use these same editor's methods to control the editor. Our [custom user interface example](https://examples.tldraw.com/custom-ui) shows this in action.

The source for these examples are available in the [tldraw repository](https://github.com/tldraw/tldraw/blob/main/apps/examples/src) or on [our website](https://tldraw.dev/examples/basic/basic).

## Events

The [`Tldraw`](/reference/tldraw/Tldraw) component has a prop, `onUiEvent`, that the user interface will call when certain events occur.

```tsx
function Example() {
	function handleEvent(name, data) {
		// do something with the event
	}

	return <Tldraw onUiEvent={handleEvent} />
}
```

The `onUiEvent` callback is called with the name of the event as a string and an object with information about the event's source (e.g. `menu` or `context-menu`) and possibly other data specific to each event, such as the direction in an `align-shapes` event.

Note that `onUiEvent` is only called when interacting with the user interface. It is not called when running commands manually against the app, e.g. calling [`Editor.alignShapes`](/reference/editor/Editor#alignShapes) will not call `onUiEvent`.

See the [tldraw repository](https://github.com/tldraw/tldraw/tree/main/apps/examples) for an example of how to customize tldraw's user interface.

## Overrides

The content of tldraw's menus can be controlled via the `overrides` prop. This prop accepts a [TLUiOverrides](/reference/tldraw/TLUiOverrides) object, which has methods for each part of the user interface, such as the `toolbar` or `keyboardShortcutsMenu`.

### Actions

The user interface has a set of shared `actions` that are used in the menus and keyboard shortcuts. These actions can be overridden by passing a new set of actions to the `overrides.actions` method.

To create, update, or delete actions, provide an `actions` method that receives both the editor and the [default actions](https://github.com/tldraw/tldraw/blob/main/packages/tldraw/src/lib/ui/context/actions.tsx) and returns a mutated actions object.

```ts
const myOverrides: TLUiOverrides = {
	actions(editor, actions) {
		// You can delete actions, but remember to
		// also delete the menu items that reference them!
		delete actions['insert-embed']

		// Create a new action or replace an existing one
		actions['my-new-action'] = {
			id: 'my-new-action',
			label: 'My new action',
			readonlyOk: true,
			kbd: '$u',
			onSelect(source: any) {
				// Whatever you want to happen when the action is run
				window.alert('My new action just happened!')
			},
		}
		return actions
	},
}
```

The `actions` object is a map of [TLUiActionItem](/reference/tldraw/TLUiActionItem)s, with each item keyed under its `id`.

### Tools

Tools work in the same manner as actions. You can override the default tools by passing a `tools` method that accepts the [default tools object](https://github.com/tldraw/tldraw/blob/main/packages/tldraw/src/lib/ui/hooks/useTools.tsx) and returns a mutated version of that object.

```ts
const myOverrides: TLUiOverrides = {
	tools(editor, tools) {
		// Create a tool item in the ui's context.
		tools.card = {
			id: 'card',
			icon: 'color',
			label: 'tools.card',
			kbd: 'c',
			onSelect: () => {
				// Whatever you want to happen when the tool is selected.
				editor.setCurrentTool('card')
			},
		}
		return tools
	},
}
```

The `tools` object is a map of [TLUiToolItem](/reference/tldraw/TLUiToolItem)s, with each item keyed under its `id`.

### Translations

The `translations` method accepts a table of new translations. For example, if you wanted a tool to reference a key `"tools.card"`, then you should at minimum provide an english translation for this key.

```ts
const myOverrides: TLUiOverrides = {
	translations: {
		en: {
			'tools.card': 'Card',
		},
	},
}
```
## Persistence

In tldraw, persistence means storing information about the editor's state to a database and then restoring it later.

The simplest implementation is the browser's local storage. But this also provides the hooks for a sync engine, which can send realtime incremental updates of the canvas to your backend server, allowing multiple people to collaborate on the canvas.

## The `"persistenceKey"` prop

Both the `<Tldraw>` or `<TldrawEditor>` components support local persistence and cross-tab synchronization via the `persistenceKey` prop. Passing a value to this prop will persist the contents of the editor locally to the browser's IndexedDb.

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function () {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw persistenceKey="my-persistence-key" />
		</div>
	)
}
```

Using a `persistenceKey` will synchronize data automatically with any other tldraw component with the same `persistenceKey` prop, even if that component is in a different browser tab.

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function () {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<div style={{ width: '50%', height: '100%' }}>
				<Tldraw persistenceKey="my-persistence-key" />
			</div>
			<div style={{ width: '50%', height: '100%' }}>
				<Tldraw persistenceKey="my-persistence-key" />
			</div>
		</div>
	)
}
```

In the example above, both editors would synchronize their document locally. They would still have two independent instance states (e.g. selections) but the document would be kept in sync and persisted under the same key.

## State Snapshots

You can get a JSON snapshot of the document content and the user 'session' state using the [`getSnapshot`](/reference/editor/getSnapshot) function.

```tsx
function SaveButton({ documentId, userId }) {
	const editor = useEditor()
	return (
		<button
			onClick={() => {
				const { document, session } = getSnapshot(editor.store)
				// If you are building a multi-user app, you probably want to store
				// the document and session states separately because the
				// session state is user-specific and normally shouldn't be shared.
				await saveDocumentState(documentId, document)
				await saveSessionState(documentId, userId, session)
			}}
		>
			Save
		</button>
	)
}
```

To load the snapshot back into an existing editor, use the [`loadSnapshot`](/reference/editor/loadSnapshot) function.

```tsx
function LoadButton({ documentId, userId }) {
	const editor = useEditor()
	return (
		<button
			onClick={() => {
				const document = await loadDocumentState(documentId)
				const session = await loadSessionState(documentId, userId)
				editor.setCurrentTool('select') // need to reset tool state separately
				loadSnapshot(editor.store, { document, session })
			}}
		>
			Load
		</button>
	)
}
```

You can also pass a snapshot as a prop to set the initial editor state.

```tsx
function MyApp({ userId, documentId }) {
	const [snapshot, setSnapshot] = useState(null)

	useEffect(() => {
		async function load() {
			const document = await getDocumentState(documentId)
			const session = await getSessionState(documentId, userId)
			setSnapshot({ document, session })
		}

		load()
	}, [documentId, userId])

	return snapshot ? <Tldraw snapshot={snapshot} /> : null
}
```

When tldraw loads a snapshot, it will run any necessary migrations to bring the data up to the latest tldraw schema version.

## The `"store"` prop

While it's possible to load the editor and then load data into its store, we've found it best to create the store, set its data, and then pass the store into the editor.

The `store` property of the `<Tldraw>` / `<TldrawEditor>` components accepts a store that you've defined outside of the component.

```tsx
export default function () {
	const [store] = useState(() => {
		// Create the store
		const newStore = createTLStore()

		// Get the snapshot
		const stringified = localStorage.getItem('my-editor-snapshot')
		const snapshot = JSON.parse(stringified)

		// Load the snapshot
		loadSnapshot(newStore, snapshot)

		return newStore
	})

	return <Tldraw persistenceKey="my-persistence-key" store={store} />
}
```

Sometimes you won't be able to access the store's data synchronously. To handle this case, the `store` property also accepts a [`TLStoreWithStatus`](/reference/editor/TLStoreWithStatus).

```tsx
export default function () {
	const [storeWithStatus, setStoreWithStatus] = useState<TLStoreWithStatus>({
		status: 'loading',
	})

	useEffect(() => {
		let cancelled = false
		async function loadRemoteSnapshot() {
			// Get the snapshot
			const snapshot = await getRemoteSnapshot()
			if (cancelled) return

			// Create the store
			const newStore = createTLStore()

			// Load the snapshot
			loadSnapshot(newStore, snapshot)

			// Update the store with status
			setStoreWithStatus({
				store: newStore,
				status: 'ready',
			})
		}

		loadRemoteSnapshot()

		return () => {
			cancelled = true
		}
	})

	return <Tldraw persistenceKey="my-persistence-key" store={storeWithStatus} />
}
```

For a good example of this pattern, see the [yjs-example](https://github.com/tldraw/tldraw-yjs-example).

## Listening for changes

You can listen for incremental updates to the document state by calling `editor.store.listen`, e.g.

```ts
const unlisten = editor.store.listen(
	(update) => {
		console.log('update', update)
	},
	{ scope: 'document', source: 'user' }
)
```

These updates contain information about which records were added, removed, and updated. See [`HistoryEntry`](/reference/store/HistoryEntry)

The `scope` filter can be used to listen for changes to a specific record scope, e.g. `document`, `session`, `presence`, or `all`.

The `source` filter can be used to listen for changes from a specific source, e.g. `user`, `remote`, or `all`. (See [`Store.mergeRemoteChanges`](/reference/store/Store#mergeRemoteChanges) for more information on remote changes.)

Note that these incremental updates do not include the schema version. You should make sure that you keep a record of the latest schema version for your snapshots.

You can get the schema version by calling `editor.store.schema.serialize()` and the returned value can replace the `schema` property in the snapshot next time you need to load a snapshot. The schema does not change at runtime so you only need to do this once per session.

## Handling remote changes

If you need to synchronize changes from a remote source, e.g. a multiplayer backend, you can use the `editor.store.mergeRemoteChanges` method. This will 'tag' the changes with the `source` property as `'remote'` so you can filter them out when listening for changes.

```ts
myRemoteSource.on('change', (changes) => {
	editor.store.mergeRemoteChanges(() => {
		changes.forEach((change) => {
			// Apply the changes to the store
			editor.store.put(/* ... */)
		})
	})
})
```

## Migrations

Tldraw uses migrations to bring data from old snapshots up to date. These run automatically when calling [`loadSnapshot`](/reference/editor/loadSnapshot).

### Running migrations manually

If you need to run migrations on a snapshot without loading it into the store, you can call [`StoreSchema.migrateStoreSnapshot`](/reference/store/StoreSchema#migrateStoreSnapshot) directly.

```ts
import { createTLSchema } from 'tldraw'

const snapshot = await getSnapshotFromSomewhere()
const migrationResult = createTLSchema().migrateStoreSnapshot(snapshot)
if (migrationResult.type === 'success') {
	console.log('Migrated snapshot', migrationResult.value)
} else {
	console.error('Migration failed', migrationResult.reason)
}
```

### Custom migrations

Tldraw supports a couple of ways of adding custom data types to the tldraw store:

- [Custom shape types](/docs/shapes#Custom-shapes-1)
- [`meta` properties](/docs/shapes#Meta-information) on all of our built-in record types.

You might wish to migrate your custom data types over time as you make changes to them.

To enable this, tldraw provides two ways to add custom migrations:

1. **Shape props migrations**, specifically for migrating the shape.props objects on your custom shape types.
2. **The `migrations` config option**, which is more general purpose but much less commonly needed. This will allow you to migrate any data in the store.

#### Shape props migrations

If you have a custom shape type, you can define a `migrations` property on the shape util class. Use the `createShapePropsMigrationSequence` helper to define this property.

```ts
import { createShapePropsMigrationSequence, createShapePropsMigrationIds, ShapeUtil } from 'tldraw'

// Migrations must start a 1 and be sequential integers.
const Versions = createShapePropMigrationIds('custom-shape', {
	AddColor: 1,
})

class MyCustomShapeUtil extends ShapeUtil {
	static type = 'custom-shape'
	static migrations = createShapePropsMigrationSequence({
		sequence: [
			{
				id: Versions.AddColor,
				up(props) {
					// set the default color
					props.color = 'black'
				},
			},
		],
	})

	// ...
}
```

#### The `migrations` config option

First create a set of migration ids.

```ts
import { createMigrationIds } from 'tldraw'

// The first argument is a unique namespace for your migration sequence.
// We recommend using a reverse domain name, e.g. we use 'com.tldraw.foo.bar'
const SEQUENCE_ID = 'com.example.my-app'

const Versions = createMigrationIds(SEQUENCE_ID, {
	// Migrations must start at 1 and be sequential integers.
	AddColor: 1,
})
```

Then create a migration sequence.

```ts
import { createMigrationSequence, isShape } from 'tldraw'

const myMigrations = createMigrationSequence({
	sequenceId: SEQUENCE_ID,
	sequence: [
		{
			id: Versions.AddColor,
			// Scope can be one of
			// - 'store' to have the up function called on the whole snapshot at once
			// - 'record' to have the up function called on each record individually
			scope: 'record',
			// if scope is 'record', you can filter which records the migration runs on
			filter: (record) => isShape(record) && record.type === 'custom-shape',
			up(record) {
				record.props.color = 'black'
			},
		},
	],
})
```

And finally pass your migrations in to tldraw via the `migrations` config option. There are a few places where you might need to do this, depending on how specialized your usage of Tldraw is:

```tsx
// When rendering the Tldraw component
<Tldraw
  ...
	migrations={[myMigrations]}
	/>

// or when creating the store
store = createTLStore({
	...
	migrations: [myMigrations],
})

// or when creating the schema
schema = createTLSchema({
	...
	migrations: [myMigrations],
})
```

### Updating legacy shape migrations (defineMigrations)

You can convert your legacy migrations to the new migrations format by the following process:

1. Wrap your version numbers in `createShapePropsMigrationIds`

```diff
- const Versions = {
+ const Versions = createShapePropMigrationIds('custom-shape', {
    AddColor: 1
- }
+ })
```

2. Replace your `defineMigrations` call with `createShapePropsMigrationSequence`

```ts
const migrations = defineMigrations({
	currentVersion: Versions.AddColor,
	migrators: {
		[Versions.AddColor]: {
			up: (shape: any) => ({ ...shape, props: { ...shape.props, color: 'black' } }),
			down: ({ props: { color, ...props }, ...shape }: any) => ({ ...shape, props }),
		},
	},
})
```

Becomes

```ts
const migrations = createShapePropsMigrationSequence({
	sequence: [
		{
			id: Versions.AddColor,
			// [!!!] You no longer have access to the top-level shape object.
			// Only the shape.props object is passed in to the migrator function.
			up(props) {
				// [!!!] You no longer need to return a new copy of the shape object.
				// Instead, you can modify the props object in place.
				props.color = 'black'
			},
			// [!!!] You no longer need to specify a down migration.
		},
	],
})
```

## Examples

### Local persistence

Tldraw ships with a local-only sync engine based on `IndexedDb` and `BroadcastChannel` called [`TLLocalSyncClient`](https://github.com/tldraw/tldraw/blob/main/packages/editor/src/lib/utils/sync/TLLocalSyncClient.ts).

### Shape props migrations example

Our [custom-config example](/examples/shapes/tools/custom-config) shows how to add custom shape props migrations to the tldraw store.

### Meta properties migrations example

Our [custom-config example](/examples/shapes/tools/custom-config) shows how to add custom migrations to the tldraw store.
## Assets

Assets are dynamic records that store data about a shared asset. For example, our image and video
shapes refer to assets rather than embedding their source files directly. Asset storage and
retrieval is controlled by [`TLAssetStore`](/reference/tlschema/TLAssetStore). Different [`TLStore`](/reference/tlschema/TLStore) setups require different asset setups:

- By default, the store is in-memory only, so [`inlineBase64AssetStore`](/reference/editor/inlineBase64AssetStore) converts images to data
  URLs.
- When using the [`persistenceKey` prop](/docs/persistence#The-persistenceKey-prop), the store is
  synced to the browser's local
  [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API), so we store images
  there too.
- When using a [multiplayer sync server](/docs/sync), you would implement TLAssetStore to upload
  images to e.g. an S3 bucket.

## Examples

While we're working on docs for this part of the project, please refer to the examples below:

- [Using images
  hosted](/examples/data/assets/hosted-images)
- [Customizing the default asset
  options](/examples/data/assets/asset-props)
- [Handling pasted / dropped external
  content](/examples/data/assets/external-content-sources)
- [A simple asset store that uploads content to a remote
  server](https://github.com/tldraw/tldraw/blob/main/templates/simple-server-example/src/client/App.tsx)
- [A more complex asset store that optimizes images when retrieving
  them](https://github.com/tldraw/tldraw/blob/main/packages/sync/src/useSyncDemo.ts#L87)
## Collaboration

The tldraw SDK includes deep support for real-time collaboration. The easiest way to add collaboration to your project is with our [tldraw sync](#tldraw-sync) library. Or you can use our low-level data APIs to integrate [other backends](#Using-other-collaboration-backends).

<div className="article__image" style={{ border: 'none' }}>
	<img
		alt="Multiplayer example using tldraw sync"
		src="/images/multiplayer.gif"
		style={{
			// learn this one weird trick for transparent animated gifs. doctors hate her!!!
			mask: 'url(/images/multiplayer_mask.png) luminance center 100% / 100% no-repeat',
			WebkitMask: 'url(/images/multiplayer_mask.png) luminance center 100% / 100% no-repeat',
		}}
	/>
</div>

## tldraw sync

[tldraw sync](/docs/sync) is our library for fast multi-user collaboration. It's purpose-built for the tldraw canvas and it's what we use to power collaboration on our flagship app tldraw.com.

You can read our full article on [tldraw sync](/docs/sync).

### tldraw sync demo

To make it easier to get started with collaboration in tldraw, we've included a "demo" hook in the sync library that connects to a hosted backend. You can see a working example at [this sandbox](https://stackblitz.com/edit/vitejs-vite-ahoswhus?file=src%2FApp.tsx?file=%2Fsrc%2FApp.tsx%3A9%2C50).

Let's say you have an app running locally that looks like this:

```tsx
import { Tldraw } from 'tldraw'

function MyApp() {
	return <Tldraw />
}
```

To make this app collaborative, first install the `@tldraw/sync` library:

```bash
npm install @tldraw/sync
```

Back in your code, import the `useSyncDemo` hook from the `@tldraw/sync` library. In the `MyApp` component, call the `useSyncDemo` hook with a room ID. Pass the [`store`](/docs/persistence#The-store-prop) returned by `useSyncDemo` to the tldraw component's `store` prop.

```tsx
import { Tldraw } from 'tldraw'
import { useSyncDemo } from '@tldraw/sync'

function MyApp() {
	const store = useSyncDemo({ roomId: 'my-unique-room-id' })
	return <Tldraw store={store} />
}
```

In your browser, open an incognito window and visit your project's URL. You can also use a different browser or different device. The key is the room ID: any apps connecting to the same room ID will enter into a shared collaboration session.

### Limitations of the demo

The sync demo is great for prototyping but you should not use it in production. Data on the demo server only lasts for up to 24 hours, and anyone using the same room id will be able to edit the same room's project.

### Using tldraw sync in production

To use tldraw sync in production, you will need to self-host the tldraw sync server. To learn more, see our article on [tldraw sync](/docs/sync).

> We don't offer a hosted solution for tldraw sync in production, but if you're interested in that please let us know at hello@tldraw.com.

## Using other collaboration backends

While tldraw sync is our recommended and best-supported backend for tldraw, we designed the tldraw SDK to work with any data solution.

As a reference, our [tldraw-yjs example](https://github.com/tldraw/tldraw-yjs-example) shows an integration between tldraw and the [Yjs](https://yjs.dev) CRDT library.

Whichever backend you choose, adding collaboration to tldraw will involve synchronizing data, sharing user presence, and handling user assets.

### Synchronizing data

For more information about how to synchronize the tldraw editor's store with other processes (i.e. how to get data out and put data in, including from remote sources) see the [Persistence](/docs/persistence) page.

### User presence

The tldraw SDK has support for displaying the 'presence' of other users. Presence information consists of the user id, name, and color, as well as their canvas context, such as their current page, pointer position, selection, viewport.

A user's presence is stored as `instance_presence` ([`TLInstancePresence`](/reference/tlschema/TLInstancePresence))records in the editor's store, however the data itself may be derived from other sources.

We provide a helper, [`createPresenceStateDerivation`](/reference/tlschema/createPresenceStateDerivation), for constructing a reactive signal for an `instance_presence` record locally, which can then be sent to other clients somehow.

To the editor, any `instance_presence` records that belong to other users (i.e. those with a different user id than the editor's configured user id) are considered "collaborators". The editor has two methods, `getCollaborators` and `getCollaboratorsOnCurrentPage`, which return reactive signals about the current collaborators.

See the [yjs-example](https://github.com/tldraw/tldraw-yjs-example/blob/45dfe7589ae44e4aaf9bb7359d0372f3a88bd597/src/useYjsStore.ts) for an example of how these records may be created, shared, and updated.

### Collaboration UI

The `tldraw` library includes several components specifically designed for collaboration.
You can remove, replace, or customize these using the editor's `components` prop. See [`TLComponents`](/reference/tldraw/TLComponents) for more info.

- Collaborator cursors: [`TLComponents.CollaboratorCursor`](/reference/tldraw/TLComponents#CollaboratorCursor)
- Cursor chat: [`TLComponents.CursorChatBubble`](/reference/tldraw/TLComponents#CursorChatBubble)
- Offline indicator: [`TLComponents.TopPanel`](/reference/tldraw/TLComponents#TopPanel)
- Collaborator list: [`TLComponents.SharePanel`](/reference/tldraw/TLComponents#SharePanel)
## tldraw sync

You can add realtime multi-user collaboration to your tldraw app by using **tldraw sync**. It's our library for fast, fault-tolerant shared document syncing, and is used in production on our flagship app [tldraw.com](https://tldraw.com).

We offer a [hosted demo](/docs/collaboration#tldraw-sync-demo) of tldraw sync which is suitable for prototyping. To use tldraw sync in production, you will need to host it yourself.

## Deploying tldraw sync

There are two main ways to go about hosting tldraw sync:

1. Deploy a full backend to Cloudflare using our template (recommended).
2. Integrate tldraw sync into your own JavaScript backend using our examples and docs as a guide.

### Use our Cloudflare template

The best way to get started hosting your own backend is to clone and deploy [our Cloudflare template](https://github.com/tldraw/tldraw-sync-cloudflare). The template provides a production-grade minimal setup of the system that runs on tldraw.com.

It uses:

- [Durable Objects](https://developers.cloudflare.com/durable-objects/) to provide a unique WebSocket server per room.
- [R2](https://developers.cloudflare.com/r2/) to persist document snapshots and store large binary assets like images and videos.

There are some features that we have not provided and you might want to add yourself:

- Authentication and authorization.
- Rate limiting and size limiting for asset uploads.
- Storing snapshots of documents over time for long-term history.
- Listing and searching for rooms.

Make sure you also read the section below about [deployment concerns](#deployment-concerns).

[Get started with the Cloudflare template](https://github.com/tldraw/tldraw-sync-cloudflare).

### Integrate tldraw sync into your own backend

The `@tldraw/sync-core` library can be used to integrate tldraw sync into any JavaScript server environment that supports WebSockets.

We have a [simple server example](https://github.com/tldraw/tldraw/tree/main/templates/simple-server-example), supporting both NodeJS and Bun, to use as a reference for how things should be stitched together.

## What does a tldraw sync backend do?

A backend for tldraw sync consists of two or three parts:

- A **WebSocket server** that provides rooms for each shared document, and is responsible for synchronizing and persisting document state.
- An **asset storage** provider for large binary files like images and videos.
- (If using the built-in bookmark shape) An **unfurling service** to extract metadata about bookmark URLs.

On the frontend, there is just one part: the **sync client**, created using the [`useSync`](/reference/sync/useSync) hook from the `@tldraw/sync` package.

Pulling all four of these together, here's what a simple client implementation might look like:

```tsx
import { Tldraw, TLAssetStore, Editor } from 'tldraw'
import { useSync } from '@tldraw/sync'
import { uploadFileAndReturnUrl } from './assets'
import { convertUrlToBookmarkAsset } from './unfurl'

function MyEditorComponent({myRoomId}) {
	// This hook creates a sync client that manages the websocket connection to the server
	// and coordinates updates to the document state.
	const store = useSync({
		// This is how you tell the sync client which server and room to connect to.
		uri: `wss://my-custom-backend.com/connect/${myRoomId}`,
		// This is how you tell the sync client how to store and retrieve blobs.
		assets: myAssetStore,
	})
	// When the tldraw Editor mounts, you can register an asset handler for the bookmark URLs.
	return <Tldraw store={store} onMount={registerUrlHandler} />
}

const myAssetStore: TLAssetStore {
	upload(file, asset) {
		return uploadFileAndReturnUrl(file)
	},
	resolve(asset) {
		return asset.props.src
	},
}

function registerUrlHandler(editor: Editor) {
	editor.registerExternalAssetHandler('url', async ({url}) => {
		return await convertUrlToBookmarkAsset(url)
	})
}
```

And [here's a full working example](https://github.com/tldraw/tldraw/blob/main/templates/simple-server-example/src/client/App.tsx) of the client-side code.

### WebSocket server

The `@tldraw/sync-core` package exports a class called [`TLSocketRoom`](/reference/sync-core/TLSocketRoom) that should be created server-side on a per-document basis.

`TLSocketRoom` is used to

- Store an authoritative in-memory copy of the document state
- Transparently set up communication between multiple sync clients via WebSockets.
- Provide hooks for persisting the document state when it changes.

<Callout type="info">
	You should make sure that there's only ever one `TLSocketRoom` globally for each room in your app.
	If there's more than one, users won't see each other and will overwrite others' changes. We use
	[Durable Objects](https://developers.cloudflare.com/durable-objects/) to achieve this on
	tldraw.com.
</Callout>

Read the reference docs for [`TLSocketRoom`](/reference/sync-core/TLSocketRoom), and see an example of how to use it in the [simple server example](https://github.com/tldraw/tldraw/blob/main/templates/simple-server-example/src/server/rooms.ts).

### Asset storage

As well as synchronizing the rapidly-changing document data, tldraw also needs a way to store and
retrieve large binary assets like images or videos.

You'll need to make sure your backend can handle asset uploads & downloads, then implement
[`TLAssetStore`](/reference/tlschema/TLAssetStore) to connect it to tldraw.

- Read about [how assets work in tldraw](/docs/assets).
- Read the [`TLAssetStore`](/reference/tlschema/TLAssetStore) reference docs.
- See a complete example of an asset store in the
  [`tldraw-sync-cloudflare`](https://github.com/tldraw/tldraw/blob/main/templates/sync-cloudflare/client/multiplayerAssetStore.tsx)
  template.

### Unfurling service

If you want to use the built-in bookmark shape, you'll need to use or implement an unfurling service that returns metadata about URLs.

This should be registered with the [`Editor`](/reference/editor/Editor) when it loads.

```tsx
<Tldraw
	store={store}
	onMount={(editor) => {
		editor.registerExternalAssetHandler('url', unfurlBookmarkUrl)
	}}
/>
```

Refer to the simple server example for example [client](https://github.com/tldraw/tldraw/blob/main/templates/simple-server-example/src/client/App.tsx) and [server](https://github.com/tldraw/tldraw/blob/main/templates/simple-server-example/src/server/unfurl.ts) code.

## Using tldraw sync in your app

### Custom shapes & bindings

`@tldraw/sync` validates the contents of your document and runs migrations to make sure clients of
different versions can collaborate without issue. To support this, you need to make sure that both
the sync client and server know about any custom shapes or bindings you've added.

#### On the client

You can pass `shapeUtils` and `bindingUtils` props to `useSync`. Unlike `<Tldraw />`,
these don't automatically include tldraw's default shapes like arrows and rectangles. You should
pass those in explicitly if you're using them:

```tsx
import { Tldraw, defaultShapeUtils, defaultBindingUtils } from 'tldraw'
import { useSync } from '@tldraw/sync'

function MyApp() {
	const store = useSync({
		uri: '...',
		assets: myAssetStore,
		shapeUtils: useMemo(() => [...customShapeUtils, ...defaultShapeUtils], []),
		bindingUtils: useMemo(() => [...customBindingUtils, ...defaultBindingUtils], []),
	})

	return <Tldraw store={store} shapeUtils={customShapeUtils} bindingUtils={customBindingUtils} />
}
```

#### On the server

Use [`createTLSchema`](/reference/tlschema/createTLSchema) to create a store schema, and pass that into [`TLSocketRoom`](/reference/sync-core/TLSocketRoom). You can
use shape/binding utils here, but schema will only look at two properties:
[`props`](/reference/editor/ShapeUtil#props) and
[`migrations`](/docs/persistence#Shape-props-migrations). You need to provide the default shape
schemas if you're using them.

```tsx
import { createTLSchema, defaultShapeSchemas, defaultBindingSchemas } from '@tldraw/tlschema'
import { TLSocketRoom } from '@tldraw/sync-core'

const schema = createTLSchema({
	shapes: {
		...defaultShapeSchemas,

		myCustomShape: {
			// Validations for this shapes `props`.
			props: myCustomShapeProps,
			// Migrations between versions of this shape.
			migrations: myCustomShapeMigrations,
		},

		// The schema knows about this shape, but it has no migrations or validation.
		mySimpleShape: {},
	},
	bindings: defaultBindingSchemas,
})

// Later, in your app server:
const room = new TLSocketRoom({
	schema: schema,
	// ...
})
```

Both `props` and `migration` are optional. If you omit `props`, you won't have any server-side
validation for your shape, which could result in bad data being stored. If you omit `migrations`,
clients on different versions won't be able to collaborate without errors.

### Deployment concerns

<Callout type="warning">
	You must make sure that the tldraw version in your client matches the version on the server. We
	don't guarantee server backwards compatibility forever, and very occasionally we might release a
	version where the backend cannot meaningfully support older clients, in which case tldraw will
	display a "please refresh the page" message. So you should make sure that the backend is updated
	at the same time as the client, and that the new backend is up and running just before the new
	client rolls out.
</Callout>

### Migrating data from a legacy system

If you have been using some other solution for data sync, you can migrate your existing data to the tldraw sync format.

[`TLSocketRoom`](/reference/sync-core/TLSocketRoom) supports loading [`TLStoreSnapshot`](/reference/tlschema/TLStoreSnapshot) snapshots, so in your data loading code you can add a backwards-compatibility layer that lazily imports data from your old system and converts it to a `TLStoreSnapshot`.

Something like

```tsx
import { TLSocketRoom } from '@tldraw/sync-core'

async function loadOrMakeRoom(roomId: string) {
	const data = await loadRoomDataFromCurrentStore(roomId)
	if (data) {
		return new TLSocketRoom({ initialSnapshot: data })
	}
	const legacyData = await loadRoomDataFromLegacyStore(roomId)
	if (legacyData) {
		// Convert your old data to a TLStoreSnapshot.
		const snapshot = convertOldDataToSnapshot(legacyData)
		// Load it into the room.
		const room = new TLSocketRoom({ initialSnapshot: snapshot })
		// Save an updated copy of the snapshot in the new place
		// so that next time we can load it directly.
		await saveRoomData(roomId, room.getCurrentSnapshot())
		// Optionally delete the old data.
		await deleteLegacyRoomData(roomId)
		// And finally return the room.
		return room
	}
	// If there's no data at all, just make a new blank room.
	return new TLSocketRoom()
}
```