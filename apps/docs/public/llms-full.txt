# tldraw SDK Documentation

--------

# Quick Start

Have five minutes? Let's try out the tldraw SDK in a React project. If you're new to React, we recommend using a [Vite template](https://vitejs.dev/guide/#scaffolding-your-first-vite-project) as a starter. We'll assume your project is already running locally.

Prefer to jump straight to some code? Try this [sandbox](https://stackblitz.com/edit/vitejs-vite-ahoswhus?file=src%2FApp.tsx).

## Getting started

First, install the `tldraw` package from NPM:

```bash
npm install tldraw
```

Next, in your React project, import the `Tldraw` component and tldraw's CSS styles. Then render the `Tldraw` component inside a full screen container:

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw />
		</div>
	)
}
```

That's pretty much it! At this point, you should have a complete working single-user canvas. You can draw and write on the canvas, add images and video, zoom and pan, copy and paste, undo and redo, and do just about everything else you'd expect to do on a canvas.

You'll be starting from our default [shapes](/docs/shapes), [tools](/docs/tools), and [user interface](/docs/user-interface), but you can customize all of these things for your project if you wish. For now, let's show off a few more features.

## Local persistence

Let's add local persistence by passing a `persistenceKey` prop to the `Tldraw` component:

<FocusLines lines={[4]}>

```tsx
export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw persistenceKey="example" />
		</div>
	)
}
```

</FocusLines>

Using a `persistenceKey` will use your browser's storage to ensure that your project can survive a browser refresh. It will also synchronize the project between other instances that share the same `persistenceKey`â€”including in other browser tabs! Give it a try by opening your app in a second window.

## Real-time collaboration

To add support for multiple users collaborating in realtime, you can use the [**tldraw sync**](/docs/sync) demo library. This library is a simple way to try out real-time collaboration in tldraw using temporary projects called rooms.

First, install the `@tldraw/sync` package:

```bash
npm install @tldraw/sync
```

Next, import the `useSyncDemo` hook from the `@tldraw/sync` package. Call it in your component with a unique ID and pass the store that it returns to the `Tldraw` component:

<FocusLines lines={[2,6,10]}>

```tsx
import { Tldraw } from 'tldraw'
import { useSyncDemo } from '@tldraw/sync'
import 'tldraw/tldraw.css'

export default function App() {
	const store = useSyncDemo({ roomId: 'insert-any-string-here' })

	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw store={store} />
		</div>
	)
}
```

</FocusLines>

Try it out by opening your project in a second incognito window, or else access it from another device. You should see all of tldraw's multiplayer features: live cursors, user names, viewport following, cursor chat, and more.

If you want to go further with real-time collaboration, be sure to check out our guide to the [**tldraw sync**](/docs/sync) library.

## Controlling the canvas

One of the best parts of tldraw is its [editor](/docs/editor)'s runtime JavaScript API. Almost everything that can happen in tldraw can be done programmatically through the [`Editor`](/reference/editor/Editor) instance.

For simplicity's sake, let's roll back our persistence and sync code. We can then use the `Tldraw` component's `onMount` callback to get access to the [`Editor`](/reference/editor/Editor) instance. We'll use the editor to create a new shape on the canvas, select it, then slowly zoom to it.

```tsx
import { Tldraw, toRichText } from 'tldraw'
import 'tldraw/tldraw.css'

export default function App() {
	const handleMount = (editor) => {
		editor.createShape({
			type: 'text',
			x: 200,
			y: 200,
			props: {
				richText: toRichText('Hello world!'),
			},
		})

		editor.selectAll()

		editor.zoomToSelection({
			animation: { duration: 5000 },
		})
	}

	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw onMount={handleMount} />
		</div>
	)
}
```

The [`Editor`](/reference/editor/Editor) is tldraw's huge god object for controlling the canvas. Be sure to check out the [`Editor`](/reference/editor/Editor) API documentation for more information on what you can do with it, as well as our guide on using the [editor](/docs/editor).

## Next Steps

Now that you've seen how the tldraw canvas works, you can:

- Create your own [shapes](/docs/shapes) and [tools](/docs/tools)
- Customize the [user interface](/docs/user-interface)
- Learn more about the [editor](/docs/editor)

You can do a lot with the tldraw SDK. In addition to our long-form docs, we have dozens of examples in our [examples section](/examples) that cover more of its functionality. You can run these locally with the tldraw [GitHub repository](https://github.com/tldraw/tldraw).

Remember: if you build something incredible, please share it with us in our [#show-and-tell](https://discord.tldraw.com/?utm_source=docs&utm_medium=organic&utm_campaign=sociallink) channel on Discord. Good luck!

--------

# Installation

To use the tldraw SDK, first install the `tldraw` package:

```bash
npm install tldraw
```

Now import and use the [`Tldraw`](/reference/tldraw/Tldraw) component inside of any React component.

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function () {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw />
		</div>
	)
}
```

### Wrapper

It's important that the [`Tldraw`](/reference/tldraw/Tldraw) component is wrapped in a parent container that has an explicit size. Its height and width are set to `100%`, so it will fill its parent container.

### CSS

In addition to the [`Tldraw`](/reference/tldraw/Tldraw) component itself, you should also import the `tldraw.css` file from the `tldraw` package.

```tsx
import 'tldraw/tldraw.css'
```

You can alternatively import this file inside of another CSS file using the `@import` syntax.

```css
@import url('tldraw/tldraw.css');
```

If you'd like to deeply change the way that tldraw looks, you can copy the `tldraw.css` file into a new CSS file, make your changes, and import that instead.

### Fonts

We also use Inter as the default tldraw font. You can import this font however you like (or use a different font!) but here's the CSS import from Google fonts that we use:

```css
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@500;700&display=swap');
```

### HTML

If you're using the [`Tldraw`](/reference/tldraw/Tldraw) component in a full-screen app, you probably also want to update your `index.html`'s meta viewport element as shown below.

```html
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
```

This may not be critical to [`Tldraw`](/reference/tldraw/Tldraw) performing correctly, however some features (such as safe area positioning) will only work correctly if these viewport options are set.

## License

If you have purchased a [business license](https://tldraw.dev/#pricing), you can register your license key using the [`Tldraw`](/reference/tldraw/Tldraw) component's `licenseKey` prop. This will disable the "Made with tldraw" link while your license is active.

```tsx
<Tldraw licenseKey={YOUR_LICENSE_KEY} />
```

To learn more about the license and license key, visit [our pricing page](https://tldraw.dev/#pricing).

## Static Assets

In order to use the [`Tldraw`](/reference/tldraw/Tldraw) component, the app must be able to find certain assets. These are contained in the `embed-icons`, `fonts`, `icons`, and `translations` folders. We offer a few different ways of making these assets available to your app.

### Using a bundler

If you're using a bundler like webpack or rollup, you can import the assets directly from the `@tldraw/assets` package. Your bundler should be able to copy across the assets with your bundle, and insert the correct URLs in their place.

There are three options:

- `import {getAssetUrlsByImport} from '@tldraw/assets/imports'`: import asset files using import statements. You'll need to configure your bundler to treat imports of .svg, .png, .json, and .woff2 files as external assets.
- `import {getAssetUrlsByImport} from '@tldraw/assets/imports.vite'`: import asset files, appending `?url` to the asset path. This works correctly with [vite](https://vitejs.dev/guide/assets#explicit-url-imports) without any extra configuration needed.
- `import {getAssetUrlsByMeta} from '@tldraw/assets/urls'`: get asset urls using `new URL(path, import.meta.url)`. This is a standards-based approach that works natively in most modern browsers & bundlers.

Call the function, and pass the resulting `assetUrls` into the `Tldraw` component:

```tsx
import { getAssetUrlsByMetaUrl } from '@tldraw/assets/urls'

const assetUrls = getAssetUrlsByMetaUrl()

<Tldraw assetUrls={assetUrls} />
```

### Using a public CDN

By default we serve these assets from a public CDN. Everything should work out of the box and is a good way to get started.

If you would like to customize some of the assets you can pass the customizations to our [`Tldraw`](/reference/tldraw/Tldraw) component. For example, to use a custom icon for the `hand` tool you can do the following:

```tsx
const assetUrls = {
    icons: {
        'tool-hand': './custom-tool-hand.svg',
    },
}

<Tldraw assetUrls={assetUrls} />
```

This will use the custom icon for the `hand` tool and the default assets for everything else.

### Self-hosting static assets

If you want more flexibility you can also host these assets yourself:

1. Download the `embed-icons`, `fonts`, `icons`, and `translations` folders from the [assets folder](https://github.com/tldraw/tldraw/tree/main/assets) of the tldraw repository.
2. Place the folders in your project's public path.
3. Pass `assetUrls` prop to our `<Tldraw/>` component to let the component know where the assets live.

You can use our `getAssetUrls` helper function from the `@tldraw/assets` package to generate these urls for you.

```tsx
import { getAssetUrls } from '@tldraw/assets/selfHosted'

const assetUrls = getAssetUrls()

<Tldraw assetUrls={assetUrls} />
```

While these files must be available, you can overwrite the individual files: for example, by placing different icons under the same name or modifying / adding translations.

If you use a CDN for hosting these files you can specify the base url of your assets. To recreate the above option of serving the assets from our CDN you would do the following:

```ts
import { getDefaultCdnBaseUrl } from 'tldraw'

const assetUrls = getAssetUrls({
	baseUrl: getDefaultCdnBaseUrl(),
})
```

## Subcomponents

The [`Tldraw`](/reference/tldraw/Tldraw) component combines two lower-level components: [`TldrawEditor`](/reference/editor/TldrawEditor) and TldrawUi. If you want to have more granular control, you can use those lower-level components directly. See [this example](https://github.com/tldraw/tldraw/blob/main/apps/examples/src/examples/exploded/ExplodedExample.tsx) for reference.

### Customize the default components

You can customize the appearance of the tldraw editor and ui using the [`Tldraw`](/reference/tldraw/Tldraw) (or [`TldrawEditor`](/reference/editor/TldrawEditor)) component's `components` prop.

```tsx

const components: TLComponents = {
	Background: YourCustomBackground,
	SvgDefs: YourCustomSvgDefs,
	Brush: YourCustomBrush,
	ZoomBrush: YourCustomBrush,
	CollaboratorBrush: YourCustomBrush,
	Cursor: YourCustomCursor,
	CollaboratorCursor: YourCustomCursor,
	CollaboratorHint: YourCustomCollaboratorHint,
	CollaboratorShapeIndicator: YourCustomdicator,
	Grid: YourCustomGrid,
	Scribble: YourCustomScribble,
	SnapLine: YourCustomSnapLine,
	Handles: YourCustomHandles,
	Handle: YourCustomHandle,
	CollaboratorScribble: YourCustomScribble,
	ErrorFallback: YourCustomErrorFallback,
	ShapeErrorFallback: YourCustomShapeErrorFallback,
	ShapeIndicatorErrorFallback: YourCustomShapeIndicatorErrorFallback,
	Spinner: YourCustomSpinner,
	SelectionBackground: YourCustomSelectionBackground,
	SelectionForeground: YourCustomSelectionForeground,
	HoveredShapeIndicator: YourCustomHoveredShapeIndicator,
	// ...
}

<Tldraw components={components}/>
```

## Versioning

The tldraw SDK does not follow semantic versioning. To learn more, read about how we do [release versioning](/releases-versioning).

--------

# Releases

## How tldraw is versioned

Unlike many JavaScript packages distributed on [NPM](https://www.npmjs.com/), the tldraw SDK does not follow [semantic versioning](https://semver.org/) in its release versions. Here's what we do instead:

- Major version bumps are very rare and we reserve them for special changes that signify a paradigm shift of some kind.
- Minor version bumps are released on a regular cadence - approximately monthly. **They may contain breaking changes**. We aim to make breaking changes as minimally disruptive as possible, but tldraw is actively evolving as we add new features. We recommend updating tldraw at a similar pace to our release cadence, and be sure to check the release notes.
- Patch version bumps are for bugfixes and hotfixes that can't wait for the next cadence release.



{/* START AUTO-GENERATED CHANGELOG */}

## Current release: [v3.15.0](/releases/v3.15.0)

This release adds `npm create tldraw` to bootstrap new tldraw projects. It also includes several small API additions, accessibility improvements, performance optimizations, and various bug fixes.

### `npm create tldraw`

You can now run `npm create tldraw` in your terminal to bootstrap a new tldraw project from our starter templates.

![npm create tldraw](https://github.com/user-attachments/assets/7141d2cc-fb24-44c4-b440-2e6e00d3606b)

## Breaking changes

There are no breaking changes in this release.

## User-facing changes

- Improve the 'Select All' action to select within the common parent of the current selection. For example, if you select a shape within a frame, it will select all the shapes within that frame but not the frame itself. ([#6386](https://github.com/tldraw/tldraw/pull/6386))

- Add a user preference option to turn off keyboard shortcuts. ([#6363](https://github.com/tldraw/tldraw/pull/6363))

## API additions

- Add several new `ShapeUtil` callbacks for handle interactions. ([#6489](https://github.com/tldraw/tldraw/pull/6489))
  - Handle drag start and end callbacks: `onHandleDragStart` and `onHandleDragEnd`.
  - Interaction cancellation callbacks: `onTranslateCancel`, `onResizeCancel`, `onRotateCancel`, and `onHandleDragCancel`.

- Allow custom JSX for icons in UI components. ([#6486](https://github.com/tldraw/tldraw/pull/6486))

  This applies to tool and action overrides as well as our button and menu item components.

- Add the `StateNode.addChild` method for dynamically adding functionality to tools. ([#6485](https://github.com/tldraw/tldraw/pull/6485))

- The `DefaultSpinner` component is now an SVG, and accepts SVG props like `width`, `height`, and `className`. ([#6459](https://github.com/tldraw/tldraw/pull/6459))

- Add a missing export of `HeartToolbarItem`. ([#6438](https://github.com/tldraw/tldraw/pull/6438))

## Bug fixes

- Fix HTML entities escaping in pasted content. ([#6396](https://github.com/tldraw/tldraw/pull/6396))

- Fix measurement of fixed-size text shapes and labels. ([#6423](https://github.com/tldraw/tldraw/pull/6423))

- Fix an issue where text measurement could be wrong due to styles being leaked between measurements. ([#6419](https://github.com/tldraw/tldraw/pull/6419))

- Fix an issue that would cause arrows between circles to sometimes render incorrectly. ([#6417](https://github.com/tldraw/tldraw/pull/6417))

- Fix text outline rendering in exported SVGs. ([#6371](https://github.com/tldraw/tldraw/pull/6371))

- Fix some edge cases where errors were thrown after reaching the maximum number of shapes. ([#6359](https://github.com/tldraw/tldraw/pull/6359))

- Fix image toolbar reacting to camera movement. ([#6375](https://github.com/tldraw/tldraw/pull/6375))

- Update `fractional-indexing-jittered` to address an issue with certain null values. See [this PR](https://github.com/TMeerhof/fractional-indexing-jittered/pull/5). ([#6479](https://github.com/tldraw/tldraw/pull/6479))

## Performance improvements

- Prevent unnecessarily dropped frames. ([#6464](https://github.com/tldraw/tldraw/pull/6464)) ([#6409](https://github.com/tldraw/tldraw/pull/6409))

- Optimize the `useValue` hook. ([#6405](https://github.com/tldraw/tldraw/pull/6405))

- Optimize the `useReactor` hook. ([#6383](https://github.com/tldraw/tldraw/pull/6383))

- Optimize frame rendering performance. ([#6415](https://github.com/tldraw/tldraw/pull/6415))

## Accessibility improvements

- Apply `aria-hidden` to more elements, and in more intelligent ways. ([#6471](https://github.com/tldraw/tldraw/pull/6471)) ([#6437](https://github.com/tldraw/tldraw/pull/6437))

- Improve keyboard navigation. ([#6446](https://github.com/tldraw/tldraw/pull/6446))

- Set `role="radiogroup"` on the `ToggleGroup` component. ([#6435](https://github.com/tldraw/tldraw/pull/6435))

- Fix aria slider values and make dialogs scrollable via keyboard. ([#6431](https://github.com/tldraw/tldraw/pull/6431))

- Fix several other minor accessibility issues. ([#6358](https://github.com/tldraw/tldraw/pull/6358))

## Other improvements

- Show max shapes alert when duplicating shapes. ([#6411](https://github.com/tldraw/tldraw/pull/6411))

- Hide cropping toolbar while cropping. ([#6376](https://github.com/tldraw/tldraw/pull/6376))

						
## Previous releases

- [v3.14.0](/releases/v3.14.0)

- [v3.13.0](/releases/v3.13.0)

- [v3.12.0](/releases/v3.12.0)

- [v3.11.0](/releases/v3.11.0)

- [v3.10.0](/releases/v3.10.0)

- [v3.9.0](/releases/v3.9.0)

- [v3.8.0](/releases/v3.8.0)

- [v3.7.0](/releases/v3.7.0)

- [v3.6.0](/releases/v3.6.0)

- [v3.5.0](/releases/v3.5.0)

- [v3.4.0](/releases/v3.4.0)

- [v3.3.0](/releases/v3.3.0)

- [v3.2.0](/releases/v3.2.0)

- [v3.1.0](/releases/v3.1.0)

- [v3.0.0](/releases/v3.0.0)

- [v2.4.0](/releases/v2.4.0)

- [v2.3.0](/releases/v2.3.0)

- [v2.2.0](/releases/v2.2.0)

- [v2.1.0](/releases/v2.1.0)

- [v2.0.0](/releases/v2.0.0)

{/* END AUTO-GENERATED CHANGELOG */}

--------

# Editor

The [`Editor`](/reference/editor/Editor) class is the main way of controlling tldraw's editor. You can use it to manage the editor's internal state, make changes to the document, or respond to changes that have occurred.

By design, the [`Editor`](/reference/editor/Editor)'s surface area is very large. Almost everything is available through it. Need to create some shapes? Use [`Editor.createShapes`](/reference/editor/Editor#createShapes). Need to delete them? Use [`Editor.deleteShapes`](/reference/editor/Editor#deleteShapes). Need a sorted array of every shape on the current page? Use [`Editor.getCurrentPageShapesSorted`](/reference/editor/Editor#getCurrentPageShapesSorted).

This page gives a broad idea of how the [`Editor`](/reference/editor/Editor) class is organized and some of the architectural concepts involved. The full reference is available in the [`Editor`](/reference/editor/Editor) API.

## Using the editor

You can access the editor in two ways:

1. From the [`Tldraw`](/reference/tldraw/Tldraw) component's `onMount` callback, where the editor is provided as the first argument in the callback.

```tsx
function App() {
	return (
		<Tldraw
			onMount={(editor) => {
				// your editor code here
			}}
		/>
	)
}
```

2. Via the [`useEditor`](/reference/editor/useEditor) hook. This must be called from within the JSX of the [`Tldraw`](/reference/tldraw/Tldraw) component.

```tsx
function InsideOfContext() {
	const editor = useEditor()
	// your editor code here
	return null // or whatever
}

function App() {
	return (
		<Tldraw>
			<InsideOfContext />
		</Tldraw>
	)
}
```

> If you are using the subcomponents as shown in [this example](/examples/editor-api/exploded), the editor instance is provided by the [`TldrawEditor`](/reference/editor/TldrawEditor) component.

## Store

The editor holds the raw state of the document in its [`Editor.store`](/reference/editor/Editor#store) property. Data is kept here as a table of JSON serializable records.

For example, the store contains a [`TLPage`](/reference/tlschema/TLPage) record for each page in the current document, as well as an [`TLInstancePageState`](/reference/tlschema/TLInstancePageState) record for each page that stores information about the editor's state for that page, and a single [`TLInstance`](/reference/tlschema/TLInstance) for each editor instance which stores the id of the user's current page.

The editor also exposes many _computed_ values which are derived from other records in the store. For example, [`Editor.getSelectedShapeIds`](/reference/editor/Editor#getSelectedShapeIds) is a method that returns the editor's current selected shape ids for its current page.

You can use these properties directly or you can use them in signals.

```tsx
import { track, useEditor } from 'tldraw'

export const SelectedShapeIdsCount = track(() => {
	const editor = useEditor()

	return <div>{editor.getSelectedShapeIds().length}</div>
})
```

### Changing the state

The [`Editor`](/reference/editor/Editor) class has many methods for updating its state. For example, you can change the current page's selection using [`Editor.setSelectedShapes`](/reference/editor/Editor#setSelectedShapes). You can also use other convenience methods, such as [`Editor.select`](/reference/editor/Editor#select), [`Editor.selectAll`](/reference/editor/Editor#selectAll), or [`Editor.selectNone`](/reference/editor/Editor#selectNone).

```ts
editor.selectNone()
editor.select(myShapeId, myOtherShapeId)
editor.getSelectedShapeIds() // [myShapeId, myOtherShapeId]
```

Each change to the state happens within a transaction. You can batch changes into a single transaction using the [`Editor.batch`](/reference/editor/Editor#batch) method. It's a good idea to batch wherever possible, as this reduces the overhead for persisting or distributing those changes.

### Listening for changes and merging changes from other sources

For information about how to synchronize the store with other processes, i.e. how to get data out and put data in, see the [Persistence](/docs/persistence) page.

### Undo and redo

The history stack in tldraw contains two types of data:

- "diffs" the changes you make to the store
- "marks" undo/redo stopping points, created by calling [`Editor.markHistoryStoppingPoint`](/reference/editor/Editor#markHistoryStoppingPoint)

When you call [`Editor.undo`](/reference/editor/Editor#undo), the editor will undo each diff until it finds either a mark or the start of the stack. When you call [`Editor.redo`](/reference/editor/Editor#redo), the editor will redo each diff until it finds either a mark or the end of the stack.

```ts
editor.createShapes(...)
// A
editor.markHistoryStoppingPoint()
editor.selectAll()
editor.duplicateShapes(editor.getSelectedShapeIds())
// B

editor.undo() // will return to A
editor.redo() // will return to B
```

You can call [`Editor.bail`](/reference/editor/Editor#bail) to undo and delete all the diffs to the nearest mark, so they cannot be redone.

```ts
editor.createShapes(...)
// A
editor.markHistoryStoppingPoint()
editor.selectAll()
editor.duplicateShapes(editor.getSelectedShapeIds())
// B

editor.bail() // will return to A
editor.redo() // will do nothing
```

[`Editor.markHistoryStoppingPoint`](/reference/editor/Editor#markHistoryStoppingPoint) returns an id that you can use with [`Editor.bailToMark`](/reference/editor/Editor#bailToMark) to bail to a specific mark.

```ts
// A
const firstMark = editor.markHistoryStoppingPoint()
editor.selectAll()
// B
const secondMark = editor.markHistoryStoppingPoint()
editor.duplicateShapes(editor.getSelectedShapeIds())
// C

editor.bailToMark(firstMark) // will return to A
```

## Running code in context

You can use the [`Editor.run`](/reference/editor/Editor#run) method to run a function inside of a transaction. All changes made during the transaction will be settled at once. This improves performance and avoids unnecessary renders in the user interface.

```ts
editor.run(() => {
	editor.createShapes(myShapes)
	editor.sendToBack(myShapes)
	editor.selectNone()
})
```

You can also use [`Editor.run`](/reference/editor/Editor#run) to execute code with contextual options.

For example, you can use the options to perform actions without effecting the undo / redo history:

```ts
editor.run(
	() => {
		editor.createShapes(myShapes)
		editor.sendToBack(myShapes)
		editor.selectNone()
	},
	{ history: 'ignore' }
)
```

You can also use the options to make changes to locked shapes.

```ts
editor.run(
	() => {
		editor.updateShapes(myLockedShapes)
	},
	{ ignoreShapeLock: true }
)
```

## Events

The [`Editor`](/reference/editor/Editor) class receives events from its [`Editor.dispatch`](/reference/editor/Editor#dispatch) method. When the [`Editor`](/reference/editor/Editor) receives an event, it is first handled internally to update [`Editor.inputs`](/reference/editor/Editor#inputs) and other state before, and then sent into to the editor's state chart.

You shouldn't need to use the [`Editor.dispatch`](/reference/editor/Editor#dispatch) method directly, however you may write code in the state chart that responds to these events. See the [Tools page](/docs/tools) to learn how to do that, or read below for a more detailed information about the state chart itself.

### State Chart

The [`Editor`](/reference/editor/Editor) class has a "state chart", or a tree of [`StateNode`](/reference/editor/StateNode) instances, that contain the logic for the editor's tools such as the select tool or the draw tool. User interactions such as moving the cursor will produce different changes to the state depending on which nodes are active.

Each node can be active or inactive. Each state node may also have zero or more children. When a state is active, and if the state has children, one (and only one) of its children must also be active. When a state node receives an event from its parent, it has the opportunity to handle the event before passing the event to its active child. The node can handle an event in any way: it can ignore the event, update records in the store, or run a _transition_ that changes which states nodes are active.

When a user interaction is sent to the editor via its [`Editor.dispatch`](/reference/editor/Editor#dispatch) method, this event is sent to the editor's root state node ([`Editor.root`](/reference/editor/Editor#root)) and passed then down through the chart's active states until either it reaches a leaf node or until one of those nodes produces a transaction.

<Image
	src="/images/api/events.png"
	alt="A diagram showing an event being sent to the editor and handled in the state chart."
	title="The editor passes an event into the state start where it is handled by each active state in order."
/>

### Path

You can get the editor's current "path" of active states via `editor.root.path`. In the above example, the value would be `"root.select.idle"`.

You can check whether a path is active via [`Editor.isIn`](/reference/editor/Editor#isIn), or else check whether multiple paths are active via [`Editor.isInAny`](/reference/editor/Editor#isInAny).

```ts
editor.store.path // 'root.select.idle'

editor.isIn('root.select') // true
editor.isIn('root.select.idle') // true
editor.isIn('root.select.pointing_shape') // false
editor.isInAny('editor.select.idle', 'editor.select.pointing_shape') // true
```

Note that the paths you pass to [`Editor.isIn`](/reference/editor/Editor#isIn) or [`Editor.isInAny`](/reference/editor/Editor#isInAny) can be the full path or a partial of the start of the path. For example, if the full path is `root.select.idle`, then [`Editor.isIn`](/reference/editor/Editor#isIn) would return true for the paths `root`, `root.select`, or `root.select.idle`.

> If all you're interested in is the state below `root`, there is a convenience method, [`Editor.getCurrentToolId`](/reference/editor/Editor#getCurrentToolId), that can help with the editor's currently selected tool.

```tsx
import { track, useEditor } from 'tldraw'

export const BubbleToolUi = track(() => {
	const editor = useEditor()

	// Only show the UI if the bubble tool is active
	if (!editor.getCurrentToolId() === 'bubble') return null
	return <div>Creating bubble</div>
})
```

## Side effects

The [`Editor.sideEffects`](/reference/editor/Editor#sideEffects) object lets you register callbacks for key parts of the lifecycle of records in the [Store](#Store).
You can register callbacks for before or after a record is created, changed, or deleted.
These callbacks are useful for applying constraints, maintaining relationships, or checking the integrity of different records in the document.
For example, we use side effects to create a new [`TLCamera`](/reference/tlschema/TLCamera) record every time a new page is made.

The "before" callbacks allow you to modify the record itself, but shouldn't be used for modifying other records.
You can create a different record in the place of what was asked, prevent a change (or make a different one) to an existing record, or stop something from being deleted.

The "after" callbacks let you make changes to other records in response to something happening.
You could create, update, or delete any related record, but you should avoid changing the same record that triggered the change.

For example, if you wanted to know every time a new arrow is created, you could register a handler like this:

```ts
editor.sideEffects.registerAfterCreateHandler('shape', (newShape) => {
	if (newShape.type === 'arrow') {
		console.log('A new arrow shape was created', newShape)
	}
})
```

Side effect handlers are also given a `source` argument - either `"user"` or `"remote"`.
This indicates whether the change originated from the current user, or from another remote user in the same multiplayer room.
You could use this to e.g. prevent the current user from deleting shapes, but allow deletions from others in the same room.

## Inputs

The [`Editor.inputs`](/reference/editor/Editor#inputs) object holds information about the user's current input state, including their cursor position (in page space _and_ screen space), which keys are pressed, what their multi-click state is, and whether they are dragging, pointing, pinching, and so on.

Note that the modifier keys include a short delay after being released in order to prevent certain errors when modeling interactions. For example, when a user releases the "Shift" key, `editor.inputs.shiftKey` will remain `true` for another 100 milliseconds or so.

This property is stored as regular data. It is not reactive.

## Editor instance state

The [`Editor.getInstanceState`](/reference/editor/Editor#getInstanceState) method returns settings that relate to each individual instance of the editor. In the case that the user has the same editor open in multiple tabs, or if there are multiple editors on the same page, then each editor will have its own instance state. See the [`TLInstance`](/reference/tlschema/TLInstance) docs to learn more about the record itself.

## User preferences

The editor's user preferences are shared between all instances. See the the [`UserPreferencesManager`](/reference/editor/UserPreferencesManager) for more about the user preferences.

## Camera and coordinates

The editor offers many methods and properties relating to the part of the infinite canvas that is displayed in the component. This section includes key concepts and methods that you can use to change or control which parts of the canvas are visible.

### Viewport

The viewport is the rectangular area contained by the editor.

| Method                              | Description                                                                                                        |
| ----------------------------------- | ------------------------------------------------------------------------------------------------------------------ |
| [`Editor.getViewportScreenBounds`](/reference/editor/Editor#getViewportScreenBounds) | A [`Box`](/reference/editor/Box) that describes the size and position of the component's canvas in actual screen pixels.                 |
| [`Editor.getViewportPageBounds`](/reference/editor/Editor#getViewportPageBounds)   | A [`Box`](/reference/editor/Box) that describes the size and position of the part of the current page that is displayed in the viewport. |

### Screen vs. page coordinates

In tldraw, coordinates can either be in page or screen space.

A "screen point" refers to the point's distance from the top left corner of the component.

A "page point" refers to the point's distance from the "zero point" of the canvas.

When the camera is at `{x: 0, y: 0, z: 0}`, the screen point and page point will be identical. As the camera moves, however, the viewport will display a different part of the page; and so a screen point will correspond to a different page point.

| Method                   | Description                                    |
| ------------------------ | ---------------------------------------------- |
| [`Editor.screenToPage`](/reference/editor/Editor#screenToPage) | Convert a point in screen space to page space. |
| [`Editor.pageToScreen`](/reference/editor/Editor#pageToScreen) | Convert a point in page space to screen space. |

You can get the user's pointer position in both screen and page space.

```ts
const {
	// The user's most recent page / screen points
	currentPagePoint,
	currentScreenPoint,
	// The user's previous page / screen points
	previousPagePoint,
	previousScreenPoint,
	// The last place where the most recent pointer down occurred
	originPagePoint,
	originScreenPoint,
} = editor.inputs
```

### Camera options

You can use the editor's camera options to configure the behavior of the editor's camera. There are many options available.

#### `wheelBehavior`

When set to `'pan'`, scrolling the mousewheel will pan the camera. When set to `'zoom'`, scrolling the mousewheel will zoom the camera. When set to `none`, it will have no effect.

#### `panSpeed`

The speed at which the camera pans. A pan can occur when the user holds the spacebar and drags, holds the middle mouse button and drags, drags while using the hand tool, or scrolls the mousewheel. The default value is `1`. A value of `0.5` would be twice as slow as default. A value of `2` would be twice as fast. When set to `0`, the camera will not pan.

#### `zoomSpeed`

The speed at which the camera zooms. A zoom can occur when the user pinches or scrolls the mouse wheel. The default value is `1`. A value of `0.5` would be twice as slow as default. A value of `2` would be twice as fast. When set to `0`, the camera will not zoom.

#### `zoomSteps`

The camera's "zoom steps" are an array of discrete zoom levels that the camera will move between when using the "zoom in" or "zoom out" controls.

The first number in the `zoomSteps` array defines the camera's minimum zoom level. The last number in the `zoomSteps` array defines the camera's maximum zoom level.

If the `constraints` are provided, then the actual value for the camera's zoom will be be calculated by multiplying the value from the `zoomSteps` array with the value from the `baseZoom`. See the `baseZoom` property for more information.

#### `isLocked`

Whether the camera is locked. When the camera is locked, the camera will not move.

#### `constraints`

By default the camera is free to move anywhere on the infinite canvas. However, you may provide the camera with a `constraints` object that constrains the camera based on a relationship between `bounds` (in page space) and the `viewport` (in screen space).

#### `constraints.bounds`

A box model describing the bounds in page space.

#### `constraints.padding`

An object with padding to apply to the `x` and `y` dimensions of the viewport. The padding is in screen space.

#### `constraints.origin`

An object with an origin for the `x` and `y` dimensions. Depending on the `behavior`, the origin may be used to position the bounds within the viewport.

For example, when the `behavior` is `fixed` and the `origin.x` is `0`, the bounds will be placed with its left side touching the left side of the viewport. When `origin.x` is `1` the bounds will be placed with its right side touching the right side of the viewport. By default the origin for each dimension is .5. This places the bounds in the center of the viewport.

#### `constraints.initialZoom`

The `initialZoom` option defines the camera's initial zoom level and what the zoom should be when when the camera is reset. The zoom it produces is based on the value provided:

| Value         | Description                                                                                    |
| ------------- | ---------------------------------------------------------------------------------------------- |
| `default`     | Sets the initial zoom to 100%.                                                                 |
| `fit-x`       | The x axis will completely fill the viewport bounds.                                           |
| `fit-y`       | The y axis will completely fill the viewport bounds.                                           |
| `fit-min`     | The smaller axis will completely fill the viewport bounds.                                     |
| `fit-max`     | The larger axis will completely fill the viewport bounds.                                      |
| `fit-x-100`   | The x axis will completely fill the viewport bounds, or 100% zoom, whichever is smaller.       |
| `fit-y-100`   | The y axis will completely fill the viewport bounds, or 100% zoom, whichever is smaller.       |
| `fit-min-100` | The smaller axis will completely fill the viewport bounds, or 100% zoom, whichever is smaller. |
| `fit-max-100` | The larger axis will completely fill the viewport bounds, or 100% zoom, whichever is smaller.  |

#### `constraints.baseZoom`

The `baseZoom` property defines the base property for the camera's zoom steps. It accepts the same values as `initialZoom`.

When `constraints` are provided, then the actual value for the camera's zoom will be be calculated by multiplying the value from the `zoomSteps` array with the value from the `baseZoom`.

For example, if the `baseZoom` is set to `default`, then a zoom step of 2 will be 200%. However, if the `baseZoom` is set to `fit-x`, then a zoom step value of 2 will be twice the zoom level at which the bounds width exactly fits within the viewport.

#### `constraints.behavior`

The `behavior` property defines which logic should be used when calculating the bounds position.

| Value     | Description                                                                                                                                 |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------- |
| 'free'    | The bounds may be placed anywhere relative to the viewport. This is the default "infinite canvas" experience.                               |
| 'inside'  | The bounds must stay entirely within the viewport.                                                                                          |
| 'outside' | The bounds may partially leave the viewport but must never leave it completely.                                                             |
| 'fixed'   | The bounds are placed in the viewport at a fixed location according to the `'origin'`.                                                      |
| 'contain' | When the zoom is below the "fit zoom" for an axis, the bounds use the `'fixed'` behavior; when above, the bounds use the `inside` behavior. |

### Controlling the camera

There are several `Editor` methods available for controlling the camera.

| Method                          | Description                                                                                         |
| ------------------------------- | --------------------------------------------------------------------------------------------------- |
| [`Editor.setCamera`](/reference/editor/Editor#setCamera)           | Moves the camera to the provided coordinates.                                                       |
| [`Editor.zoomIn`](/reference/editor/Editor#zoomIn)              | Zooms the camera in to the nearest zoom step. See the `constraints.zoomSteps` for more information. |
| [`Editor.zoomOut`](/reference/editor/Editor#zoomOut)             | Zooms the camera in to the nearest zoom step. See the `constraints.zoomSteps` for more information. |
| [`Editor.zoomToFit`](/reference/editor/Editor#zoomToFit)           | Zooms the camera in to the nearest zoom step. See the `constraints.zoomSteps` for more information. |
| [`Editor.zoomToBounds`](/reference/editor/Editor#zoomToBounds)        | Moves the camera to fit the given bounding box.                                                     |
| [`Editor.zoomToSelection`](/reference/editor/Editor#zoomToSelection)     | Moves the camera to fit the current selection.                                                      |
| [`Editor.zoomToUser`](/reference/editor/Editor#zoomToUser)          | Moves the camera to center on a user's cursor.                                                      |
| [`Editor.resetZoom`](/reference/editor/Editor#resetZoom)           | Resets the zoom to 100% or to the `initialZoom` zoom level.                                         |
| [`Editor.centerOnPoint`](/reference/editor/Editor#centerOnPoint)       | Centers the camera on the given point.                                                              |
| [`Editor.stopCameraAnimation`](/reference/editor/Editor#stopCameraAnimation) | Stops any camera animation.                                                                         |

### Camera state

The camera may be in two states, `idle` or `moving`.

You can get the current camera state with [`Editor.getCameraState`](/reference/editor/Editor#getCameraState).

## Bindings

A binding is a relationship from one [shape](/docs/shapes) to another. They're used to connect
shapes so they can update together or depend on one and other. For example: tldraw's default arrow
shape uses bindings to connect the ends of the arrows to the shapes they're pointing to, one binding
for each end of the arrow.

You can create different types of binding that do all sorts of different things with relationships
between shapes. For example, you could create a [sticker
shape](/examples/shapes/tools/sticker-bindings) that sticks to any other shape it's dropped onto.

### The binding object

Bindings are records (JSON objects) that live in the [store](/docs/editor#store). For example,
here's a binding record for one end of an arrow shape:

```json
{
    "id": "binding:someId",
    "typeName": "binding"
    "type": "arrow",
    "fromId": "shape:arrowId",
    "toId": "shape:someOtherShapeId",
    "props": {
        "terminal": "end"
        "isPrecise": true,
        "isExact": false,
        "normalizedAnchor": {
            "x": 0.5,
            "y": 0.5
        },
    },
    "meta": {},
}
```

Every binding contains some base information - its ID & the type of binding, as well as the ID of
the shape that a binding comes _from_ and the ID of the shape that the binding goes _to_. These two
properties work the same way, but it's often useful to have an explicit direction in a binding
relationship. For example, an arrow binding always goes _from_ an arrow _to_ another shape.

Bindings contain their own type-specific information in the `props` object. Each type of binding can
have different props.

Bindings also have a `meta` property which can be used by your application to add data to bindings
you haven't built yourself. You can read more about the meta property
[here](/docs/shapes#Meta-information).

### Custom bindings

To create a binding of your own, you can define a custom binding.

#### The binding type

First, you need to create a type that describes what the binding object will look like:

```ts
import { TLBaseBinding } from 'tldraw'

type StickerBinding = TLBaseBinding<'sticker', { x: number; y: number }>
```

With [`TLBaseBinding`](/reference/tlschema/TLBaseBinding) we define the binding's type (`sticker`) and `props` property (`{x: number,
y: number}`). The type can be any string, and the props must be a plain JSON object (ie not a class
instance).

The [`TLBaseBinding`](/reference/tlschema/TLBaseBinding) helper adds the other base properties like `id`, `toId`, and `fromId`.

#### The `BindingUtil` class

While bindings themselves are plain JSON objects, we use
[`BindingUtil`](/reference/editor/BindingUtil) classes to define how bindings should work. They tell
tldraw the structure of a binding, and what to do when it or the shapes it involves are created,
updated, or deleted.

```ts
import { BindingUtil } from 'tldraw'

class StickerBindingUtil extends BindingUtil<StickerBinding> {
	static override type = 'sticker' as const

	override getDefaultProps() {
		return { x: 0.5, y: 0.5 }
	}

	override onAfterChangeToShape({ binding }) {
		const sticker = this.editor.getShape(binding.fromShape)

		// move the sticker so it stays attached to the to shape
	}
}
```

Each binding util needs a `type` and `getDefaultProps` to define its basic structure. You can also
define a number of different callbacks describing how the binding should behave. See the
[`BindingUtil`](/reference/editor/BindingUtil) reference or a [complete example of a
binding](/examples/shapes/tools/sticker-bindings) for details.

If the structure of your binding needs to change over time, you can provide
[migrations](/docs/persistence#Shape-props-migrations) describing how old stored bindings can be
brought up to date.

## Image exports

You can export the contents of the canvas to an image with [`Editor.toImage`](/reference/editor/Editor#toImage).

Image exports draw your shapes as an SVG, then convert the SVG to another format (like a PNG) if needed. Use [`Editor.getSvgElement`](/reference/editor/Editor#getSvgElement) or [`Editor.getSvgString`](/reference/editor/Editor#getSvgString) if you want to work with the SVG directly.

### Exporting custom shapes

By default, custom shape exports use the [`ShapeUtil.component`](/reference/editor/ShapeUtil#component) method that's used to render your shape normally. We embed the result in a [`<foreignObject>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/foreignObject) element. This works well for most shapes, but isn't perfect (see [below](#Export-limitations)). For more control over exports, you can implement [`ShapeUtil.toSvg`](/reference/editor/ShapeUtil#toSvg) to properly convert your shape to an SVG.

Use the [`useSvgExportContext`](/reference/editor/useSvgExportContext) hook to check if your shape is being rendered for an SVG export. If you need to load data or assets asynchronously, use the [`useDelaySvgExport`](/reference/editor/useDelaySvgExport) hook to delay the export until you're ready.

SVGs can't refer to any external assets like images, fonts, or CSS. Everything needs to be included inline in the SVG, with images and fonts converted to data URLs. `<foreignObject>` exports that use the `component` methods try to handle this automatically, but if you implement `toSvg` you'll need to do it yourself. You can use [`SvgExportContext.addExportDef`](/reference/editor/SvgExportContext#addExportDef) to add definitions to the SVG that can be shared by multiple shapes.

### Export limitations

Hand-authored `toSvg` are typically very reliable and have good compatibility with other SVG tools. However, most SVG editors (and even some viewers) don't support the `<foreignObject>` element, so the default `component` based exports don't work as well outside of the browser. If you want to make sure that your exports look the same in all viewers, either implement `toSvg` or convert directly to a PNG or other raster format.

Even within browsers though, `<foreignObject>`s and the method we use to create them aren't always 100% reliable. Chromium based browsers tend to work well, but Firefox occasionally has layout issues, and Safari has rendering quirks with effects like box shadows. It's sometimes useful to apply different styles during exports in certain browsers.

We can only embed external assets such as images and font files if they're either hosted on the same origin as tldraw, or have [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) headers set. If external assets are missing from your export, check your browser's network tab to see if these are being requested and if anything is going wrong with them.

## Common things to do with the editor

### Create a shape id

To create an id for a shape (a [`TLShapeId`](/reference/tlschema/TLShapeId)), use the libary's [`createShapeId`](/reference/tlschema/createShapeId) helper.

```ts
import { createShapeId } from 'tldraw'

createShapeId() // `shape:some-random-uuid`
createShapeId('kyle') // `shape:kyle`
```

The `id` property of any record in tldraw is "branded" with the type of that record. For shapes, that means that all shape ids are formatted as `shape:{id}`. The TypeScript type of a record's `id` also includes a reference to the type of the record that it belongs to. TypeScript will complain if you use a regular `shape:some-id` string, but the [`createShapeId`](/reference/tlschema/createShapeId) helper will provide the type.

### Create shapes

To create shapes, use the [`Editor.createShape`](/reference/editor/Editor#createShape) or [`Editor.createShapes`](/reference/editor/Editor#createShapes) methods.

```ts
editor.createShapes([
	{
		id,
		type: 'geo',
		x: 0,
		y: 0,
		props: {
			geo: 'rectangle',
			w: 100,
			h: 100,
			dash: 'draw',
			color: 'blue',
			size: 'm',
		},
	},
])
```

A shape must be a partial of the full shape (a [`TLShapePartial`](/reference/tlschema/TLShapePartial)). All props are optional except for the `type` of the shape. The shape's corresponding [`ShapeUtil`](/reference/editor/ShapeUtil) will provide the default props for any props not provided. The `id` will be created if not provided.

### Update shapes

To update shapes, use the [`Editor.updateShape`](/reference/editor/Editor#updateShape) or [`Editor.updateShapes`](/reference/editor/Editor#updateShapes) methods.

```ts
editor.updateShapes([
	{
		id: shape.id, // required
		type: shape.type, // required
		x: 100,
		y: 100,
		props: {
			w: 200,
		},
	},
])
```

The update must be a partial of the full shape (a [`TLShapePartial`](/reference/tlschema/TLShapePartial)). All props are optional except for the `type` of the shape and its `id`.

### Delete shapes

To delete shapes, use the [`Editor.deleteShape`](/reference/editor/Editor#deleteShape) or [`Editor.deleteShapes`](/reference/editor/Editor#deleteShapes) methods.

```ts
editor.deleteShapes([shape.id])
editor.deleteShapes([shape])
```

You can delete a shape using the shape's `id` or the shape record itself.

### Get a shape

You can get a shape with the [`Editor.getShape`](/reference/editor/Editor#getShape) method.

```ts
editor.getShape(myShapeId)
editor.getShape(myShape)
```

You can get a shape using the shape's `id` or the shape record itself.

### Turn on read only mode

You can use the [`Editor.updateInstanceState`](/reference/editor/Editor#updateInstanceState) method to turn on read only mode.

```ts
editor.updateInstanceState({ isReadonly: true })
```

### Move the camera

You can set the camera to a specific x, y, and zoom with the [`Editor.setCamera`](/reference/editor/Editor#setCamera) method.

```ts
editor.setCamera({ x: 0, y: 0, z: 1 })
```

### Freeze the camera

You can prevent the user from changing the camera using the `Editor.setCameraOptions` method.

```ts
editor.setCameraOptions({ isLocked: true })
```

### Turn on dark mode

You can turn on or off dark mode via the [`UserPreferencesManager`](/reference/editor/UserPreferencesManager). Note that this effects all editor instances that share the same userâ€”even instances in other tabs.

```ts
editor.user.updateUserPreferences({ colorScheme: 'dark' })
```

### Using the system color scheme

You can also use the system color scheme via the [`UserPreferencesManager`](/reference/editor/UserPreferencesManager).

```ts
editor.user.updateUserPreferences({ colorScheme: 'system' })
```

### Make changes without effecting the history

You can use the [`Editor.run`](/reference/editor/Editor#run) method to make changes without effecting the undo redo history.

```ts
editor.run(
	() => {
		editor.deleteShapes(myLockedShapes)
	},
	{ history: 'ignore' }
)
```

### Make changes to locked shape

You can use the [`Editor.run`](/reference/editor/Editor#run) method to make changes to locked shapes without having to unlock them first.

```ts
editor.run(
	() => {
		editor.deleteShapes(myLockedShapes)
	},
	{ ignoreShapeLock: true }
)
```

### Hiding shapes

You can pass a `getShapeVisibility` function when configuring tldraw. This will be called for each shape to determine whether it should be hidden.

`getShapeVisibility` can return one of the following values

- `'inherit' | undefined` - (default) The shape will be visible unless its parent is hidden.
- `'hidden'` - The shape will be hidden.
- `'visible'` - The shape will be visible.

Hidden shapes will still be present in the store, but

- They will not be shown on the canvas
- They will not be included in hit test results via `editor.getShapeAtPoint` and `editor.getShapesAtPoint`
- They will be excluded from the arrays returned by `editor.getRenderingShapes` and `editor.getCurrentPageRenderingShapesSorted`
- They will not be exported in image exports or rendered when printing.

Otherwise, they will behave as normal.

One place where this might be problematic for you, depending on what features you're using `getShapeVisibility` to implement, is that hidden shapes will still be selectable, e.g. via the `select-all` action (`Cmd+A` or `Ctrl+A`).

You can prevent that by cleaning up the selection in a signal reaction that is set up in the `onMount` callback:

```tsx
<Tldraw
	getShapeVisibility={(shape) => (shape.meta.hidden ? 'hidden' : 'inherit')}
	onMount={(editor) => {
		// We don't prevent hidden shapes from being selected out of the box, because there are some situations where it's desirable.
		// If you want to prevent hidden shapes from being selected, you can do so like this:
		return react('clean up selection', () => {
			const selectedShapeIds = editor.getSelectedShapeIds()
			const filteredSelectedShapeIds = selectedShapeIds.filter((id) => !editor.isShapeHidden(id))
			if (selectedShapeIds.length !== filteredSelectedShapeIds.length) {
				editor.setSelectedShapes(filteredSelectedShapeIds)
			}
		})
	}}
/>
```

For example usages, see the [collaboration private content example](/examples/collaboration/sync-private-content) and the [layer panel example](/examples/ui/layer-panel).

---

See the [tldraw repository](https://github.com/tldraw/tldraw/tree/main/apps/examples) for an example of how to use tldraw's Editor API to control the editor.

--------

# Shapes

In tldraw, a shape is something that can exist on the page, like an arrow, an image, or some text.

This article is about shapes: what they are, how they work, and how to create your own shapes. If you'd prefer to see an example, see the tldraw repository's [examples app](https://github.com/tldraw/tldraw/tree/main/apps/examples) for examples of how to create custom shapes in tldraw.

## Types of shape

We make a distinction between three types of shapes: "core", "default", and "custom".

### Core shapes

The editor's core shapes are shapes that are built in and always present. At the moment the only core shape is the [group shape](/reference/tlschema/TLGroupShape).

### Default shapes

The default shapes are all of the shapes that are included by default in the [`Tldraw`](/reference/tldraw/Tldraw) component, such as the [`TLArrowShape`](/reference/tlschema/TLArrowShape) or [`TLDrawShape`](/reference/tlschema/TLDrawShape). They are exported from the `tldraw` library as [`defaultShapeUtils`](/reference/tldraw/defaultShapeUtils).

### Custom shapes

Custom shapes are shapes that were created by you or someone you love. Find more information about custom shapes [below](#Custom-shapes-1).

## The shape object

Shapes are just records (JSON objects) that sit in the [store](/docs/editor#Store). For example, here's a shape record for a rectangle geo shape:

```ts
{
    "parentId": "page:somePage",
    "id": "shape:someId",
    "typeName": "shape",
    "type": "geo",
    "x": 106,
    "y": 294,
    "rotation": 0,
    "index": "a28",
    "opacity": 1,
    "isLocked": false,
    "props": {
        "w": 200,
        "h": 200,
        "geo": "rectangle",
        "color": "black",
        "labelColor": "black",
        "fill": "none",
        "dash": "draw",
        "size": "m",
        "font": "draw",
        "text": "diagram",
        "align": "middle",
        "verticalAlign": "middle",
        "growY": 0,
        "url": ""
    },
    "meta": {},
}
```

### Base properties

Every shape contains some base information. These include the shape's type, position, rotation, opacity, and more. You can find the full list of base properties [here](/reference/tlschema/TLBaseShape).

### Props

Every shape also contains some shape-specific information, called `props`. Each type of shape can have different props. For example, the `props` of a text shape are much different than the props of an arrow shape.

### Meta

Meta information is information that is not used by tldraw but is instead used by your application. For example, you might want to store the name of the user who created a shape, or the date that the shape was created. You can find more information about meta information [below](#Meta-information).

## The `ShapeUtil` class

While tldraw's shapes themselves are simple JSON objects, we use [`ShapeUtil`](/reference/editor/ShapeUtil) classes to answer questions about shapes. For example, when the editor needs to render a text shape, it will find the [`TextShapeUtil`](/reference/tldraw/TextShapeUtil) and call its [`ShapeUtil.component`](/reference/editor/ShapeUtil#component) method, passing in the text shape object as an argument.

---

## Custom shapes

You can create your own custom shapes. In the examples below, we will create a custom "card" shape. It'll be a simple rectangle with some text inside.

> For an example of how to create custom shapes, see our [custom shapes example](/examples/shapes/tools/custom-shape).

### Shape type

In tldraw's data model, each shape is represented by a JSON object. Let's first create a type that describes what this object will look like.

```ts
import { TLBaseShape } from 'tldraw'

type CardShape = TLBaseShape<'card', { w: number; h: number }>
```

With the [`TLBaseShape`](/reference/tlschema/TLBaseShape) helper, we define the shape's `type` property (`card`) and the shape's `props` property (`{ w: number, h: number }`). The type can be any string but the props must be a regular [JSON-serializable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#description) JavaScript object.

The [`TLBaseShape`](/reference/tlschema/TLBaseShape) helper adds the other base properties of a shape, such as `x`, `y`, `rotation`, and `opacity`.

### Shape Util

While tldraw's shapes themselves are simple JSON objects, we use [`ShapeUtil`](/reference/editor/ShapeUtil) classes to answer questions about shapes.

Let's create a [`ShapeUtil`](/reference/editor/ShapeUtil) class for the shape.

```tsx
import { HTMLContainer, ShapeUtil } from 'tldraw'

class CardShapeUtil extends ShapeUtil<CardShape> {
	static override type = 'card' as const

	getDefaultProps(): CardShape['props'] {
		return {
			w: 100,
			h: 100,
		}
	}

	getGeometry(shape: CardShape) {
		return new Rectangle2d({
			width: shape.props.w,
			height: shape.props.h,
			isFilled: true,
		})
	}

	component(shape: CardShape) {
		return <HTMLContainer>Hello</HTMLContainer>
	}

	indicator(shape: CardShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}
```

This is a minimal [`ShapeUtil`](/reference/editor/ShapeUtil). We've given it a static property `type` that matches the type of our shape, we've provided implementations for the abstract methods [`ShapeUtil.getDefaultProps`](/reference/editor/ShapeUtil#getDefaultProps), [`ShapeUtil.getBounds`](/reference/editor/ShapeUtil#getBounds), [`ShapeUtil.component`](/reference/editor/ShapeUtil#component), and [`ShapeUtil.indicator`](/reference/editor/ShapeUtil#indicator).

We still have work to do on the `CardShapeUtil` class, but we'll come back to it later. For now, let's put the shape onto the canvas by passing it to the [`Tldraw`](/reference/tldraw/Tldraw) component.

### The `shapeUtils` prop

We pass an array of our shape utils into the [`Tldraw`](/reference/tldraw/Tldraw) component's `shapeUtils` prop.

```tsx
const MyCustomShapes = [CardShapeUtil]

export default function () {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw shapeUtils={MyCustomShapes} />
		</div>
	)
}
```

We can create one of our custom card shapes using the [`Editor`](/reference/editor/Editor) API. We'll do this by setting the `onMount` prop of the [`Tldraw`](/reference/tldraw/Tldraw) component.

```tsx
export default function () {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw
				shapeUtils={MyCustomShapes}
				onMount={(editor) => {
					editor.createShapes([{ type: 'card' }])
				}}
			/>
		</div>
	)
}
```

Once the page refreshes, we should now have our custom shape on the canvas.

### Meta information

Shapes also have a `meta` property (see [`TLBaseShape.meta`](/reference/tlschema/TLBaseShape#meta)) that you can fill with your own data. This should feel like a bit of a hack, however it's intended to be an escape hatch for applications where you want to use tldraw's existing shapes but also want to attach a bit of extra data to the shape.

Note that tldraw's regular shape definitions have an unknown object for the shape's `meta` property. To type your shape's meta, use a union like this:

```ts
type MyShapeWithMeta = TLGeoShape & { meta: { createdBy: string } }

const shape = editor.getShape<MyShapeWithMeta>(myGeoShape.id)
```

You can update a shape's `meta` property in the same way you would update its props, using [`Editor.updateShapes`](/reference/editor/Editor#updateShapes).

```ts
editor.updateShapes<MyShapeWithMeta>([
	{
		id: myGeoShape.id,
		type: 'geo',
		meta: {
			createdBy: 'Steve',
		},
	},
])
```

Like [`TLBaseShape.props`](/reference/tlschema/TLBaseShape#props), the data in a [`TLBaseShape.meta`](/reference/tlschema/TLBaseShape#meta) object must be JSON serializable.

In addition to setting meta properties this way, you can also set the default meta data for shapes using the Editor's [`Editor.getInitialMetaForShape`](/reference/editor/Editor#getInitialMetaForShape) method.

```tsx
editor.getInitialMetaForShape = (shape: TLShape) => {
	if (shape.type === 'text') {
		return { createdBy: currentUser.id, lastModified: Date.now() }
	} else {
		return { createdBy: currentUser.id }
	}
}
```

Whenever new shapes are created using the [`Editor.createShapes`](/reference/editor/Editor#createShapes) method, the shape's meta property will be set using the [`Editor.getInitialMetaForShape`](/reference/editor/Editor#getInitialMetaForShape) method. By default this method returns an empty object.

### Using starter shapes

You can use "starter" shape utils like [`BaseBoxShapeUtil`](/reference/editor/BaseBoxShapeUtil) to get regular rectangular shape behavior.

### Flags

You can use flags like [`ShapeUtil.hideRotateHandle`](/reference/editor/ShapeUtil#hideRotateHandle) to hide different parts of the UI when the shape is selected, or else to control different behaviors of the shape.

### Interaction

You can turn on `pointer-events` to allow users to interact inside of the shape.

### Editing

You can make shapes "editable" to help decide when they're interactive or not.

### Labels (plain text and rich text)

Our shapes have the ability to have include labels. Those labels can either have plain text (the `text` prop) or rich text (`richText`), as desired.
For rich text, the tldraw editor provides first-class support for [TipTap](https://tiptap.dev/) out of the box. The underlying document for the richText is
a TipTap JSON-stringified document that is stored within the `richText` property. (For that reason, we don't do character-by-character synchronization of
the text within a shape. This was a design choice as much of tldraw's text ends up being short-form).

If you would like to use rich text within your shape you can use our [`RichTextLabel`](/reference/tldraw/RichTextLabel) component to help you get started with rendering rich text. Under the hood
this uses [`RichTextArea`](/reference/tldraw/RichTextArea) which loads a TipTap instance and to handle the editing of rich text.

If you would like to use plain text you would use the corresponding [`PlainTextLabel`](/reference/tldraw/PlainTextLabel) and [`PlainTextArea`](/reference/tldraw/PlainTextArea) components.

#### Text measurement

One of the challenges with our shapes is getting an accurate measurement of the bounds of the shape.
Traditionally you could have used our [`TextManager.measureText`](/reference/editor/TextManager#measureText). However, because rich text is HTML, the API to use for that is [`TextManager.measureHtml`](/reference/editor/TextManager#measureHtml)

#### Extending TipTap

Here's a simple example of how you could add a custom extension (in this case `FontFamily`) to the editor:

```ts
const textOptions = {
	tipTapConfig: {
		extensions: [...tipTapDefaultExtensions, FontFamily],
	},
}

export default function RichTextCustomExtensionExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="rich-text-custom-extension"
				components={components}
				textOptions={textOptions}
			/>
		</div>
	)
}
```

Check out our [rich text examples](/examples/rich-text-custom-extension) to see how to add custom extensions or UI to tailor the rich text.

### Migrations

You can add migrations for your shape props by adding a `migrations` property to your shape's util class. See [the persistence docs](/docs/persistence#Shape-props-migrations) for more information.

--------

# Tools

In tldraw, a **tool** is what we call any top-level state in our state chart. For example, the select tool, the draw tool, and the arrow tool are all top-level states that the user can be in.

<Image
	title="Tools"
	src="/images/api/tools.png"
	alt="A diagram showing the state chart of tldraw. The top row of states (apart from the Root state) are annotated as tools."
	title="The first level of states in the start chart are known as tools."
/>

For more detailed information about the state chart, and how it works, go to the [Editor page](/docs/editor). Or read below for more information about tools, and how to make your own.

## Types of tool

The tldraw editor comes with some in-built **core tools**: the [select tool](/reference/tldraw/SelectTool), the [zoom tool](/reference/tldraw/ZoomTool), and the [text tool](/reference/tldraw/TextShapeTool). These are always added to the state chart.

There are also some **default tools** available, like the [draw tool](/reference/tldraw/DrawShapeTool), the [hand tool](/reference/tldraw/HandTool), the [arrow tool](/reference/tldraw/ArrowShapeTool), and more. The `<Tldraw>` component automatically adds these tools to the state chart.

You can also create your own **custom tools**. You can add them to the state chart by passing an array of them to the [`Tldraw`](/reference/tldraw/Tldraw) component's `tools` prop.

Note: You might also want to add a tool to the user interface in various ways, such as the toolbar. See the [User Interface](/docs/user-interface) section for more on changing the menus.

## Transitioning

You can change the current active tool using [editor.setCurrentTool](/reference/editor/Editor#setCurrentTool).

```ts
editor.setCurrentTool('select')
```

You can "deep transition" by using a path of active tool ids.

```ts
editor.setCurrentTool('select.eraser.pointing')
```

## Inside a tool

Every tool has an **id**. This is used to identify it in the state chart.

```ts
class MyTool extends StateNode {
	static override id = 'my-tool'
}
```

Tools can contain **children**. For example, the [hand tool](/reference/tldraw/HandTool) has three children, `Idle`, `Pointing` and `Dragging`. If a state has children, it must also have an `initial` state, so that it knows which state to start in.

```ts
class MyIdleState extends StateNode {
	static override id = 'my-idle-state'
}

class MyPointingState extends StateNode {
	static override id = 'my-pointing-state'
}

class MyTool extends StateNode {
	static override id = 'my-tool'
	static override initial = 'my-idle-state'
	static override children() {
		return [MyIdleState, MyPointingState]
	}
}
```

### Handling events

When the editor receives an [event](/reference/editor/TLEventHandlers) via its [`Editor.dispatch`](/reference/editor/Editor#dispatch) method, the event is first processed in order to update its inputs, then passed to the editor's state chart.

Beginning at the root, each node will first handle the event and then pass the event to its current active child state. This continues until either: the event is handled on a state without any children; or the event is handled in a way that produces a transition.

### Parents handle events before children

```ts
class MyIdleState extends StateNode {
	static override id = 'my-idle-state'

	onPointerDown(info: TLPointerEventInfo) {
		console.log('world')
	}
}

class MyTool extends StateNode {
	static override id = 'my-tool'
	static override initial = 'my-idle-state'
	static override children() {
		return [MyIdleState]
	}

	onPointerDown(info: TLPointerEventInfo) {
		console.log('hello')
	}
}
```

Using the example above, if a `pointer_down` event is passed to the editor while the `MyTool` state is active, `MyTool`'s `onPointerDown` method will be called first, then `MyIdleState`'s `onPointerDown` method will be called second.

### Transitions stop the process

```ts
class MyIdleState extends StateNode {
	static override id = 'my-idle-state'

	onPointerDown(info: TLPointerEventInfo) {
		console.log("this won't run")
	}
}

class MyTool extends StateNode {
	static override id = 'my-tool'
	static override initial = 'my-idle-state'
	static override children() {
		return [MyIdleState]
	}

	onPointerDown(info: TLPointerEventInfo) {
		editor.setCurrentTool('select')
	}
}
```

If `MyTool`'s `onPointerDown` handler produced a transition (changing anything about which states are active) then the chain would stop and the event would not be handled on `MyIdleState`.

--------

# User interface

The user interface in tldraw includes the menus, toolbars, keyboard shortcuts, and analytics events in the editor.

## Hiding the UI

You can hide the default tldraw user interface entirely using the `hideUi` prop. This turns off both the visuals as well as the keyboard shortcuts.

```tsx
function Example() {
	return <Tldraw hideUi />
}
```

Here's [an example](/examples/hide-ui) of what that looks like. Note that while you can't select any other tools using the keyboard shortcuts, you can still use the `setCurrentTool` method to change the tool. If you open the console and enter:

```ts
editor.setCurrentTool('draw')
```

...then you can start drawing.

All of our user interface works by controlling the editor via its `Editor` methods. If you hide the user interface, you can still use these same editor's methods to control the editor. Our [custom user interface example](/examples/custom-ui) shows this in action.

The source for these examples are available in the [tldraw repository](https://github.com/tldraw/tldraw/blob/main/apps/examples/src) or on [our website](https://tldraw.dev/examples).

## Events

The [`Tldraw`](/reference/tldraw/Tldraw) component has a prop, `onUiEvent`, that the user interface will call when certain events occur.

```tsx
function Example() {
	function handleEvent(name, data) {
		// do something with the event
	}

	return <Tldraw onUiEvent={handleEvent} />
}
```

The `onUiEvent` callback is called with the name of the event as a string and an object with information about the event's source (e.g. `menu` or `context-menu`) and possibly other data specific to each event, such as the direction in an `align-shapes` event.

Note that `onUiEvent` is only called when interacting with the user interface. It is not called when running commands manually against the app, e.g. calling [`Editor.alignShapes`](/reference/editor/Editor#alignShapes) will not call `onUiEvent`.

See the [tldraw repository](https://github.com/tldraw/tldraw/tree/main/apps/examples) for an example of how to customize tldraw's user interface.

## Overrides

The content of tldraw's menus can be controlled via the `overrides` prop. This prop accepts a [TLUiOverrides](/reference/tldraw/TLUiOverrides) object, which has methods for each part of the user interface, such as the `toolbar` or `keyboardShortcutsMenu`.

### Actions

The user interface has a set of shared `actions` that are used in the menus and keyboard shortcuts. These actions can be overridden by passing a new set of actions to the `overrides.actions` method.

To create, update, or delete actions, provide an `actions` method that receives both the editor and the [default actions](https://github.com/tldraw/tldraw/blob/main/packages/tldraw/src/lib/ui/context/actions.tsx) and returns a mutated actions object.

```ts
const myOverrides: TLUiOverrides = {
	actions(editor, actions) {
		// You can delete actions, but remember to
		// also delete the menu items that reference them!
		delete actions['insert-embed']

		// Create a new action or replace an existing one
		actions['my-new-action'] = {
			id: 'my-new-action',
			label: 'My new action',
			readonlyOk: true,
			kbd: 'cmd+u,ctrl+u',
			onSelect(source: any) {
				// Whatever you want to happen when the action is run
				window.alert('My new action just happened!')
			},
		}
		return actions
	},
}
```

The `actions` object is a map of [TLUiActionItem](/reference/tldraw/TLUiActionItem)s, with each item keyed under its `id`.

### Tools

Tools work in the same manner as actions. You can override the default tools by passing a `tools` method that accepts the [default tools object](https://github.com/tldraw/tldraw/blob/main/packages/tldraw/src/lib/ui/hooks/useTools.tsx) and returns a mutated version of that object.

```ts
const myOverrides: TLUiOverrides = {
	tools(editor, tools) {
		// Create a tool item in the ui's context.
		tools.card = {
			id: 'card',
			icon: 'color',
			label: 'tools.card',
			kbd: 'c',
			onSelect: () => {
				// Whatever you want to happen when the tool is selected.
				editor.setCurrentTool('card')
			},
		}
		return tools
	},
}
```

The `tools` object is a map of [TLUiToolItem](/reference/tldraw/TLUiToolItem)s, with each item keyed under its `id`.

### Translations

The `translations` method accepts a table of new translations. For example, if you wanted a tool to reference a key `"tools.card"`, then you should at minimum provide an english translation for this key.

```ts
const myOverrides: TLUiOverrides = {
	translations: {
		en: {
			'tools.card': 'Card',
		},
	},
}
```

--------

# Persistence

In tldraw, persistence means storing information about the editor's state to a database and then restoring it later.

The simplest implementation is the browser's local storage. But this also provides the hooks for a sync engine, which can send realtime incremental updates of the canvas to your backend server, allowing multiple people to collaborate on the canvas.

## The `"persistenceKey"` prop

Both the `<Tldraw>` or `<TldrawEditor>` components support local persistence and cross-tab synchronization via the `persistenceKey` prop. Passing a value to this prop will persist the contents of the editor locally to the browser's IndexedDb.

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function () {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw persistenceKey="my-persistence-key" />
		</div>
	)
}
```

Using a `persistenceKey` will synchronize data automatically with any other tldraw component with the same `persistenceKey` prop, even if that component is in a different browser tab.

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function () {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<div style={{ width: '50%', height: '100%' }}>
				<Tldraw persistenceKey="my-persistence-key" />
			</div>
			<div style={{ width: '50%', height: '100%' }}>
				<Tldraw persistenceKey="my-persistence-key" />
			</div>
		</div>
	)
}
```

In the example above, both editors would synchronize their document locally. They would still have two independent instance states (e.g. selections) but the document would be kept in sync and persisted under the same key.

## State Snapshots

You can get a JSON snapshot of the document content and the user 'session' state using the [`getSnapshot`](/reference/editor/getSnapshot) function.

```tsx
function SaveButton({ documentId, userId }) {
	const editor = useEditor()
	return (
		<button
			onClick={() => {
				const { document, session } = getSnapshot(editor.store)
				// If you are building a multi-user app, you probably want to store
				// the document and session states separately because the
				// session state is user-specific and normally shouldn't be shared.
				await saveDocumentState(documentId, document)
				await saveSessionState(documentId, userId, session)
			}}
		>
			Save
		</button>
	)
}
```

To load the snapshot back into an existing editor, use the [`loadSnapshot`](/reference/editor/loadSnapshot) function.

```tsx
function LoadButton({ documentId, userId }) {
	const editor = useEditor()
	return (
		<button
			onClick={() => {
				const document = await loadDocumentState(documentId)
				const session = await loadSessionState(documentId, userId)
				editor.setCurrentTool('select') // need to reset tool state separately
				loadSnapshot(editor.store, { document, session })
			}}
		>
			Load
		</button>
	)
}
```

You can also pass a snapshot as a prop to set the initial editor state.

```tsx
function MyApp({ userId, documentId }) {
	const [snapshot, setSnapshot] = useState(null)

	useEffect(() => {
		async function load() {
			const document = await getDocumentState(documentId)
			const session = await getSessionState(documentId, userId)
			setSnapshot({ document, session })
		}

		load()
	}, [documentId, userId])

	return snapshot ? <Tldraw snapshot={snapshot} /> : null
}
```

When tldraw loads a snapshot, it will run any necessary migrations to bring the data up to the latest tldraw schema version.

## The `"store"` prop

While it's possible to load the editor and then load data into its store, we've found it best to create the store, set its data, and then pass the store into the editor.

The `store` property of the `<Tldraw>` / `<TldrawEditor>` components accepts a store that you've defined outside of the component.

```tsx
export default function () {
	const [store] = useState(() => {
		// Create the store
		const newStore = createTLStore()

		// Get the snapshot
		const stringified = localStorage.getItem('my-editor-snapshot')
		const snapshot = JSON.parse(stringified)

		// Load the snapshot
		loadSnapshot(newStore, snapshot)

		return newStore
	})

	return <Tldraw persistenceKey="my-persistence-key" store={store} />
}
```

Sometimes you won't be able to access the store's data synchronously. To handle this case, the `store` property also accepts a [`TLStoreWithStatus`](/reference/editor/TLStoreWithStatus).

```tsx
export default function () {
	const [storeWithStatus, setStoreWithStatus] = useState<TLStoreWithStatus>({
		status: 'loading',
	})

	useEffect(() => {
		let cancelled = false
		async function loadRemoteSnapshot() {
			// Get the snapshot
			const snapshot = await getRemoteSnapshot()
			if (cancelled) return

			// Create the store
			const newStore = createTLStore()

			// Load the snapshot
			loadSnapshot(newStore, snapshot)

			// Update the store with status
			setStoreWithStatus({
				store: newStore,
				status: 'ready',
			})
		}

		loadRemoteSnapshot()

		return () => {
			cancelled = true
		}
	})

	return <Tldraw persistenceKey="my-persistence-key" store={storeWithStatus} />
}
```

## Listening for changes

You can listen for incremental updates to the document state by calling `editor.store.listen`, e.g.

```ts
const unlisten = editor.store.listen(
	(update) => {
		console.log('update', update)
	},
	{ scope: 'document', source: 'user' }
)
```

These updates contain information about which records were added, removed, and updated. See [`HistoryEntry`](/reference/store/HistoryEntry)

The `scope` filter can be used to listen for changes to a specific record scope, e.g. `document`, `session`, `presence`, or `all`.

The `source` filter can be used to listen for changes from a specific source, e.g. `user`, `remote`, or `all`. (See [`Store.mergeRemoteChanges`](/reference/store/Store#mergeRemoteChanges) for more information on remote changes.)

Note that these incremental updates do not include the schema version. You should make sure that you keep a record of the latest schema version for your snapshots.

You can get the schema version by calling `editor.store.schema.serialize()` and the returned value can replace the `schema` property in the snapshot next time you need to load a snapshot. The schema does not change at runtime so you only need to do this once per session.

## Handling remote changes

If you need to synchronize changes from a remote source, e.g. a multiplayer backend, you can use the `editor.store.mergeRemoteChanges` method. This will 'tag' the changes with the `source` property as `'remote'` so you can filter them out when listening for changes.

```ts
myRemoteSource.on('change', (changes) => {
	editor.store.mergeRemoteChanges(() => {
		changes.forEach((change) => {
			// Apply the changes to the store
			editor.store.put(/* ... */)
		})
	})
})
```

## Migrations

Tldraw uses migrations to bring data from old snapshots up to date. These run automatically when calling [`loadSnapshot`](/reference/editor/loadSnapshot).

### Running migrations manually

If you need to run migrations on a snapshot without loading it into the store, you can call [`StoreSchema.migrateStoreSnapshot`](/reference/store/StoreSchema#migrateStoreSnapshot) directly.

```ts
import { createTLSchema } from 'tldraw'

const snapshot = await getSnapshotFromSomewhere()
const migrationResult = createTLSchema().migrateStoreSnapshot(snapshot)
if (migrationResult.type === 'success') {
	console.log('Migrated snapshot', migrationResult.value)
} else {
	console.error('Migration failed', migrationResult.reason)
}
```

### Custom migrations

Tldraw supports a couple of ways of adding custom data types to the tldraw store:

- [Custom shape types](/docs/shapes#Custom-shapes-1)
- [`meta` properties](/docs/shapes#Meta-information) on all of our built-in record types.

You might wish to migrate your custom data types over time as you make changes to them.

To enable this, tldraw provides two ways to add custom migrations:

1. **Shape props migrations**, specifically for migrating the shape.props objects on your custom shape types.
2. **The `migrations` config option**, which is more general purpose but much less commonly needed. This will allow you to migrate any data in the store.

#### Shape props migrations

If you have a custom shape type, you can define a `migrations` property on the shape util class. Use the `createShapePropsMigrationSequence` helper to define this property.

```ts
import { createShapePropsMigrationSequence, createShapePropsMigrationIds, ShapeUtil } from 'tldraw'

// Migrations must start a 1 and be sequential integers.
const Versions = createShapePropMigrationIds('custom-shape', {
	AddColor: 1,
})

class MyCustomShapeUtil extends ShapeUtil {
	static type = 'custom-shape'
	static migrations = createShapePropsMigrationSequence({
		sequence: [
			{
				id: Versions.AddColor,
				up(props) {
					// set the default color
					props.color = 'black'
				},
			},
		],
	})

	// ...
}
```

#### The `migrations` config option

First create a set of migration ids.

```ts
import { createMigrationIds } from 'tldraw'

// The first argument is a unique namespace for your migration sequence.
// We recommend using a reverse domain name, e.g. we use 'com.tldraw.foo.bar'
const SEQUENCE_ID = 'com.example.my-app'

const Versions = createMigrationIds(SEQUENCE_ID, {
	// Migrations must start at 1 and be sequential integers.
	AddColor: 1,
})
```

Then create a migration sequence.

```ts
import { createMigrationSequence, isShape } from 'tldraw'

const myMigrations = createMigrationSequence({
	sequenceId: SEQUENCE_ID,
	sequence: [
		{
			id: Versions.AddColor,
			// Scope can be one of
			// - 'store' to have the up function called on the whole snapshot at once
			// - 'record' to have the up function called on each record individually
			scope: 'record',
			// if scope is 'record', you can filter which records the migration runs on
			filter: (record) => isShape(record) && record.type === 'custom-shape',
			up(record) {
				record.props.color = 'black'
			},
		},
	],
})
```

And finally pass your migrations in to tldraw via the `migrations` config option. There are a few places where you might need to do this, depending on how specialized your usage of Tldraw is:

```tsx
// When rendering the Tldraw component
<Tldraw
  ...
	migrations={[myMigrations]}
	/>

// or when creating the store
store = createTLStore({
	...
	migrations: [myMigrations],
})

// or when creating the schema
schema = createTLSchema({
	...
	migrations: [myMigrations],
})
```

### Updating legacy shape migrations (defineMigrations)

You can convert your legacy migrations to the new migrations format by the following process:

1. Wrap your version numbers in `createShapePropsMigrationIds`

```diff
- const Versions = {
+ const Versions = createShapePropMigrationIds('custom-shape', {
    AddColor: 1
- }
+ })
```

2. Replace your `defineMigrations` call with `createShapePropsMigrationSequence`

```ts
const migrations = defineMigrations({
	currentVersion: Versions.AddColor,
	migrators: {
		[Versions.AddColor]: {
			up: (shape: any) => ({ ...shape, props: { ...shape.props, color: 'black' } }),
			down: ({ props: { color, ...props }, ...shape }: any) => ({ ...shape, props }),
		},
	},
})
```

Becomes

```ts
const migrations = createShapePropsMigrationSequence({
	sequence: [
		{
			id: Versions.AddColor,
			// [!!!] You no longer have access to the top-level shape object.
			// Only the shape.props object is passed in to the migrator function.
			up(props) {
				// [!!!] You no longer need to return a new copy of the shape object.
				// Instead, you can modify the props object in place.
				props.color = 'black'
			},
			// [!!!] You no longer need to specify a down migration.
		},
	],
})
```

## Examples

### Local persistence

Tldraw ships with a local-only sync engine based on `IndexedDb` and `BroadcastChannel` called [`TLLocalSyncClient`](https://github.com/tldraw/tldraw/blob/main/packages/editor/src/lib/utils/sync/TLLocalSyncClient.ts).

### Shape props migrations example

Our [custom-config example](/examples/shapes/tools/custom-config) shows how to add custom shape props migrations to the tldraw store.

### Meta properties migrations example

Our [custom-config example](/examples/shapes/tools/custom-config) shows how to add custom migrations to the tldraw store.

--------

# Assets

Assets are dynamic records that store data about a shared asset. For example, our image and video
shapes refer to assets rather than embedding their source files directly. Asset storage and
retrieval is controlled by [`TLAssetStore`](/reference/tlschema/TLAssetStore). Different [`TLStore`](/reference/tlschema/TLStore) setups require different asset setups:

- By default, the store is in-memory only, so [`inlineBase64AssetStore`](/reference/editor/inlineBase64AssetStore) converts images to data
  URLs.
- When using the [`persistenceKey` prop](/docs/persistence#The-persistenceKey-prop), the store is
  synced to the browser's local
  [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API), so we store images
  there too.
- When using a [multiplayer sync server](/docs/sync), you would implement TLAssetStore to upload
  images to e.g. an S3 bucket.

## Examples

While we're working on docs for this part of the project, please refer to the examples below:

- [Using hosted images](/examples/data/assets/hosted-images)
- [Customizing the default asset
  options](/examples/data/assets/asset-props)
- [Handling pasted / dropped external
  content](/examples/data/assets/external-content-sources)
- [A simple asset store that uploads content to a remote
  server](https://github.com/tldraw/tldraw/blob/main/templates/simple-server-example/src/client/App.tsx)
- [A more complex asset store that optimizes images when retrieving
  them](https://github.com/tldraw/tldraw/blob/main/packages/sync/src/useSyncDemo.ts#L87)

--------

# Collaboration

The tldraw SDK includes deep support for real-time collaboration. The easiest way to add collaboration to your project is with our [tldraw sync](#tldraw-sync) library. Or you can use our low-level data APIs to integrate [other backends](#Using-other-collaboration-backends).

<div className="article__image" style={{ border: 'none' }}>
	<img
		alt="Multiplayer example using tldraw sync"
		src="/images/multiplayer.gif"
		style={{
			// learn this one weird trick for transparent animated gifs. doctors hate her!!!
			mask: 'url(/images/multiplayer_mask.png) luminance center 100% / 100% no-repeat',
			WebkitMask: 'url(/images/multiplayer_mask.png) luminance center 100% / 100% no-repeat',
		}}
	/>
</div>

## tldraw sync

[tldraw sync](/docs/sync) is our library for fast multi-user collaboration. It's purpose-built for the tldraw canvas and it's what we use to power collaboration on our flagship app tldraw.com.

You can read our full article on [tldraw sync](/docs/sync).

### tldraw sync demo

To make it easier to get started with collaboration in tldraw, we've included a "demo" hook in the sync library that connects to a hosted backend. You can see a working example at [this sandbox](https://stackblitz.com/edit/vitejs-vite-ahoswhus?file=src%2FApp.tsx?file=%2Fsrc%2FApp.tsx%3A9%2C50).

Let's say you have an app running locally that looks like this:

```tsx
import { Tldraw } from 'tldraw'

function MyApp() {
	return <Tldraw />
}
```

To make this app collaborative, first install the `@tldraw/sync` library:

```bash
npm install @tldraw/sync
```

Back in your code, import the `useSyncDemo` hook from the `@tldraw/sync` library. In the `MyApp` component, call the `useSyncDemo` hook with a room ID. Pass the [`store`](/docs/persistence#The-store-prop) returned by `useSyncDemo` to the tldraw component's `store` prop.

```tsx
import { Tldraw } from 'tldraw'
import { useSyncDemo } from '@tldraw/sync'

function MyApp() {
	const store = useSyncDemo({ roomId: 'my-unique-room-id' })
	return <Tldraw store={store} />
}
```

In your browser, open an incognito window and visit your project's URL. You can also use a different browser or different device. The key is the room ID: any apps connecting to the same room ID will enter into a shared collaboration session.

### Limitations of the demo

The sync demo is great for prototyping but you should not use it in production. Data on the demo server only lasts for up to 24 hours, and anyone using the same room id will be able to edit the same room's project.

### Using tldraw sync in production

To use tldraw sync in production, you will need to self-host the tldraw sync server. To learn more, see our article on [tldraw sync](/docs/sync).

> We don't offer a hosted solution for tldraw sync in production, but if you're interested in that please let us know at hello@tldraw.com.

## Using other collaboration backends

While tldraw sync is our recommended and best-supported backend for tldraw, we designed the tldraw SDK to work with any data solution.

Whichever backend you choose, adding collaboration to tldraw will involve synchronizing data, sharing user presence, and handling user assets.

### Third-party backends

- **[Liveblocks](https://liveblocks.io/multiplayer-editing)**: Hosted tldraw with DevTools, webhooks, REST API, Node.js library. Get started with [Storage](https://liveblocks.io/examples/tldraw-whiteboard) and [Yjs](https://liveblocks.io/examples/tldraw-whiteboard/nextjs-tldraw-whiteboard-yjs) examples.

### Manual setup

#### Synchronizing data

For more information about how to synchronize the tldraw editor's store with other processes (i.e. how to get data out and put data in, including from remote sources) see the [Persistence](/docs/persistence) page.

#### User presence

The tldraw SDK has support for displaying the 'presence' of other users. Presence information consists of the user id, name, and color, as well as their canvas context, such as their current page, pointer position, selection, viewport.

A user's presence is stored as `instance_presence` ([`TLInstancePresence`](/reference/tlschema/TLInstancePresence))records in the editor's store, however the data itself may be derived from other sources.

We provide a helper, [`createPresenceStateDerivation`](/reference/tlschema/createPresenceStateDerivation), for constructing a reactive signal for an `instance_presence` record locally, which can then be sent to other clients somehow.

To the editor, any `instance_presence` records that belong to other users (i.e. those with a different user id than the editor's configured user id) are considered "collaborators". The editor has two methods, `getCollaborators` and `getCollaboratorsOnCurrentPage`, which return reactive signals about the current collaborators.

#### Collaboration UI

The `tldraw` library includes several components specifically designed for collaboration.
You can remove, replace, or customize these using the editor's `components` prop. See [`TLComponents`](/reference/tldraw/TLComponents) for more info.

- Collaborator cursors: [`TLComponents.CollaboratorCursor`](/reference/tldraw/TLComponents#CollaboratorCursor)
- Cursor chat: [`TLComponents.CursorChatBubble`](/reference/tldraw/TLComponents#CursorChatBubble)
- Offline indicator: [`TLComponents.TopPanel`](/reference/tldraw/TLComponents#TopPanel)
- Collaborator list: [`TLComponents.SharePanel`](/reference/tldraw/TLComponents#SharePanel)

--------

# tldraw sync

You can add realtime multi-user collaboration to your tldraw app by using **tldraw sync**. It's our library for fast, fault-tolerant shared document syncing, and is used in production on our flagship app [tldraw.com](https://tldraw.com).

We offer a [hosted demo](/docs/collaboration#tldraw-sync-demo) of tldraw sync which is suitable for prototyping. To use tldraw sync in production, you will need to host it yourself.

## Deploying tldraw sync

There are two main ways to go about hosting tldraw sync:

1. Deploy a full backend to Cloudflare using our template (recommended).
2. Integrate tldraw sync into your own JavaScript backend using our examples and docs as a guide.

### Use our Cloudflare template

The best way to get started hosting your own backend is to clone and deploy [our Cloudflare template](https://github.com/tldraw/tldraw-sync-cloudflare). The template provides a production-grade minimal setup of the system that runs on tldraw.com.

It uses:

- [Durable Objects](https://developers.cloudflare.com/durable-objects/) to provide a unique WebSocket server per room.
- [R2](https://developers.cloudflare.com/r2/) to persist document snapshots and store large binary assets like images and videos.

There are some features that we have not provided and you might want to add yourself:

- Authentication and authorization.
- Rate limiting and size limiting for asset uploads.
- Storing snapshots of documents over time for long-term history.
- Listing and searching for rooms.

Make sure you also read the section below about [deployment concerns](#deployment-concerns).

[Get started with the Cloudflare template](https://github.com/tldraw/tldraw-sync-cloudflare).

### Integrate tldraw sync into your own backend

We recommend using Cloudflare, but the `@tldraw/sync-core` library can be used to integrate tldraw sync into any JavaScript server environment that supports WebSockets.

We have a [simple server example](https://github.com/tldraw/tldraw/tree/main/templates/simple-server-example), supporting both NodeJS and Bun, to use as a reference for how things should be stitched together.

## What does a tldraw sync backend do?

A backend for tldraw sync consists of two or three parts:

- A **WebSocket server** that provides rooms for each shared document, and is responsible for synchronizing and persisting document state.
- An **asset storage** provider for large binary files like images and videos.
- (If using the built-in bookmark shape) An **unfurling service** to extract metadata about bookmark URLs.

On the frontend, there is just one part: the **sync client**, created using the [`useSync`](/reference/sync/useSync) hook from the `@tldraw/sync` package.

Pulling all four of these together, here's what a simple client implementation might look like:

```tsx
import { Tldraw, TLAssetStore, Editor } from 'tldraw'
import { useSync } from '@tldraw/sync'
import { uploadFileAndReturnUrl } from './assets'
import { convertUrlToBookmarkAsset } from './unfurl'

function MyEditorComponent({myRoomId}) {
	// This hook creates a sync client that manages the websocket connection to the server
	// and coordinates updates to the document state.
	const store = useSync({
		// This is how you tell the sync client which server and room to connect to.
		uri: `wss://my-custom-backend.com/connect/${myRoomId}`,
		// This is how you tell the sync client how to store and retrieve blobs.
		assets: myAssetStore,
	})
	// When the tldraw Editor mounts, you can register an asset handler for the bookmark URLs.
	return <Tldraw store={store} onMount={registerUrlHandler} />
}

const myAssetStore: TLAssetStore {
	upload(file, asset) {
		return uploadFileAndReturnUrl(file)
	},
	resolve(asset) {
		return asset.props.src
	},
}

function registerUrlHandler(editor: Editor) {
	editor.registerExternalAssetHandler('url', async ({url}) => {
		return await convertUrlToBookmarkAsset(url)
	})
}
```

And [here's a full working example](https://github.com/tldraw/tldraw/blob/main/templates/simple-server-example/src/client/App.tsx) of the client-side code.

### WebSocket server

The `@tldraw/sync-core` package exports a class called [`TLSocketRoom`](/reference/sync-core/TLSocketRoom) that should be created server-side on a per-document basis.

`TLSocketRoom` is used to

- Store an authoritative in-memory copy of the document state
- Transparently set up communication between multiple sync clients via WebSockets.
- Provide hooks for persisting the document state when it changes.

<Callout type="info">
	You should make sure that there's only ever one `TLSocketRoom` globally for each room in your app.
	If there's more than one, users won't see each other and will overwrite others' changes. We use
	[Durable Objects](https://developers.cloudflare.com/durable-objects/) to achieve this on
	tldraw.com.
</Callout>

Read the reference docs for [`TLSocketRoom`](/reference/sync-core/TLSocketRoom), and see an example of how to use it in the [simple server example](https://github.com/tldraw/tldraw/blob/main/templates/simple-server-example/src/server/rooms.ts).

### Asset storage

As well as synchronizing the rapidly-changing document data, tldraw also needs a way to store and
retrieve large binary assets like images or videos.

You'll need to make sure your backend can handle asset uploads & downloads, then implement
[`TLAssetStore`](/reference/tlschema/TLAssetStore) to connect it to tldraw.

- Read about [how assets work in tldraw](/docs/assets).
- Read the [`TLAssetStore`](/reference/tlschema/TLAssetStore) reference docs.
- See a complete example of an asset store in the
  [`tldraw-sync-cloudflare`](https://github.com/tldraw/tldraw/blob/main/templates/sync-cloudflare/client/multiplayerAssetStore.tsx)
  template.

### Unfurling service

If you want to use the built-in bookmark shape, you'll need to use or implement an unfurling service that returns metadata about URLs.

This should be registered with the [`Editor`](/reference/editor/Editor) when it loads.

```tsx
<Tldraw
	store={store}
	onMount={(editor) => {
		editor.registerExternalAssetHandler('url', unfurlBookmarkUrl)
	}}
/>
```

Refer to the simple server example for example [client](https://github.com/tldraw/tldraw/blob/main/templates/simple-server-example/src/client/App.tsx) and [server](https://github.com/tldraw/tldraw/blob/main/templates/simple-server-example/src/server/unfurl.ts) code.

## Using tldraw sync in your app

### Custom shapes & bindings

`@tldraw/sync` validates the contents of your document and runs migrations to make sure clients of
different versions can collaborate without issue. To support this, you need to make sure that both
the sync client and server know about any custom shapes or bindings you've added.

#### On the client

You can pass `shapeUtils` and `bindingUtils` props to `useSync`. Unlike `<Tldraw />`,
these don't automatically include tldraw's default shapes like arrows and rectangles. You should
pass those in explicitly if you're using them:

```tsx
import { Tldraw, defaultShapeUtils, defaultBindingUtils } from 'tldraw'
import { useSync } from '@tldraw/sync'

function MyApp() {
	const store = useSync({
		uri: '...',
		assets: myAssetStore,
		shapeUtils: useMemo(() => [...customShapeUtils, ...defaultShapeUtils], []),
		bindingUtils: useMemo(() => [...customBindingUtils, ...defaultBindingUtils], []),
	})

	return <Tldraw store={store} shapeUtils={customShapeUtils} bindingUtils={customBindingUtils} />
}
```

#### On the server

Use [`createTLSchema`](/reference/tlschema/createTLSchema) to create a store schema, and pass that into [`TLSocketRoom`](/reference/sync-core/TLSocketRoom). You can
use shape/binding utils here, but schema will only look at two properties:
[`props`](/reference/editor/ShapeUtil#props) and
[`migrations`](/docs/persistence#Shape-props-migrations). You need to provide the default shape
schemas if you're using them.

```tsx
import { createTLSchema, defaultShapeSchemas, defaultBindingSchemas } from '@tldraw/tlschema'
import { TLSocketRoom } from '@tldraw/sync-core'

const schema = createTLSchema({
	shapes: {
		...defaultShapeSchemas,

		myCustomShape: {
			// Validations for this shapes `props`.
			props: myCustomShapeProps,
			// Migrations between versions of this shape.
			migrations: myCustomShapeMigrations,
		},

		// The schema knows about this shape, but it has no migrations or validation.
		mySimpleShape: {},
	},
	bindings: defaultBindingSchemas,
})

// Later, in your app server:
const room = new TLSocketRoom({
	schema: schema,
	// ...
})
```

Both `props` and `migration` are optional. If you omit `props`, you won't have any server-side
validation for your shape, which could result in bad data being stored. If you omit `migrations`,
clients on different versions won't be able to collaborate without errors.

### Deployment concerns

<Callout type="warning">
	You must make sure that the tldraw version in your client matches the version on the server. We
	don't guarantee server backwards compatibility forever, and very occasionally we might release a
	version where the backend cannot meaningfully support older clients, in which case tldraw will
	display a "please refresh the page" message. So you should make sure that the backend is updated
	at the same time as the client, and that the new backend is up and running just before the new
	client rolls out.
</Callout>

### Migrating data from a legacy system

If you have been using some other solution for data sync, you can migrate your existing data to the tldraw sync format.

[`TLSocketRoom`](/reference/sync-core/TLSocketRoom) supports loading [`TLStoreSnapshot`](/reference/tlschema/TLStoreSnapshot) snapshots, so in your data loading code you can add a backwards-compatibility layer that lazily imports data from your old system and converts it to a `TLStoreSnapshot`.

Something like

```tsx
import { TLSocketRoom } from '@tldraw/sync-core'

async function loadOrMakeRoom(roomId: string) {
	const data = await loadRoomDataFromCurrentStore(roomId)
	if (data) {
		return new TLSocketRoom({ initialSnapshot: data })
	}
	const legacyData = await loadRoomDataFromLegacyStore(roomId)
	if (legacyData) {
		// Convert your old data to a TLStoreSnapshot.
		const snapshot = convertOldDataToSnapshot(legacyData)
		// Load it into the room.
		const room = new TLSocketRoom({ initialSnapshot: snapshot })
		// Save an updated copy of the snapshot in the new place
		// so that next time we can load it directly.
		await saveRoomData(roomId, room.getCurrentSnapshot())
		// Optionally delete the old data.
		await deleteLegacyRoomData(roomId)
		// And finally return the room.
		return room
	}
	// If there's no data at all, just make a new blank room.
	return new TLSocketRoom()
}
```

--------------------------------

# tldraw SDK Examples

--------

# Tldraw component

Category: Getting started

Keywords: basic, intro, simple, quick, start, hello world, installation

The simplest way to use the `Tldraw` component.

The `Tldraw` component provides the tldraw editor as a regular React component. You can put this component anywhere in your React project. In this example, we make the component take up the height and width of the container.

By default, the component does not persist between refreshes or sync locally between tabs. To keep your work after a refresh, check the [persistence key example](https://tldraw.dev/examples/persistence-key).

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function BasicExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw />
		</div>
	)
}
```

--------

# Editor options

Category: Configuration

Keywords: 

Override default editor options like max number of pages and animation speed.

Use the `options` property to override tldraw's options. In this example, we limit the maximum number of pages to 3, and slow down camera animations like zoom in and zoom out.

## App.tsx

```tsx
import { Tldraw, TldrawOptions } from 'tldraw'
import 'tldraw/tldraw.css'

const options: Partial<TldrawOptions> = {
	maxPages: 3,
	animationMediumMs: 5000,
}

export default function CustomOptionsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example" options={options} />
		</div>
	)
}
```

--------

# Shape options

Category: Configuration

Keywords: config, configure, shape, util, frame

Change the behavior of built-in shapes by setting their options.

Some of the builtin tldraw shapes can be customized to behave differently based on your needs. This is done via the `ShapeUtil.configure` function which returns a new version of the shape's util class with custom options specified.

You can see a shape's options by looking at the `options` property of its `ShapeUtil`. For example, the note shape's options are listed at [`NoteShapeOptions`](https://tldraw.dev/reference/tldraw/NoteShapeOptions).

## App.tsx

```tsx
import { FrameShapeUtil, NoteShapeUtil, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

const shapeUtils = [
	// Enable colors for frame shapes
	FrameShapeUtil.configure({ showColors: true }),

	// Enable resizing for note shapes
	NoteShapeUtil.configure({ resizeMode: 'scale' }),
]

export default function ConfigureShapeUtilExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw shapeUtils={shapeUtils}></Tldraw>
		</div>
	)
}
```

--------

# Camera options

Category: Configuration

Keywords: api, fixed, constraints, camera bounds, pan speed, zoom speed

Configure the camera's options and constraints.

The `Tldraw` component provides a prop, `cameraOptions`, that can be used to set the camera's constraints, zoom behavior, and other options. This example lets you modify those options to see how they affect the camera's behavior.

## App.tsx

```tsx
import { useEffect } from 'react'
import {
	BoxModel,
	TLCameraOptions,
	Tldraw,
	Vec,
	clamp,
	track,
	useEditor,
	useLocalStorageState,
} from 'tldraw'
import 'tldraw/tldraw.css'

const CAMERA_OPTIONS: TLCameraOptions = {
	isLocked: false,
	wheelBehavior: 'pan',
	panSpeed: 1,
	zoomSpeed: 1,
	zoomSteps: [0.1, 0.25, 0.5, 1, 2, 4, 8],
	constraints: {
		initialZoom: 'fit-max',
		baseZoom: 'fit-max',
		bounds: {
			x: 0,
			y: 0,
			w: 1600,
			h: 900,
		},
		behavior: { x: 'contain', y: 'contain' },
		padding: { x: 100, y: 100 },
		origin: { x: 0.5, y: 0.5 },
	},
}

const BOUNDS_SIZES: Record<string, BoxModel> = {
	a4: { x: 0, y: 0, w: 1050, h: 1485 },
	landscape: { x: 0, y: 0, w: 1600, h: 900 },
	portrait: { x: 0, y: 0, w: 900, h: 1600 },
	square: { x: 0, y: 0, w: 900, h: 900 },
}

export default function CameraOptionsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// persistenceKey="camera-options"
				components={components}
			>
				<CameraOptionsControlPanel />
			</Tldraw>
		</div>
	)
}

const PaddingDisplay = track(() => {
	const editor = useEditor()
	const cameraOptions = editor.getCameraOptions()

	if (!cameraOptions.constraints) return null

	const {
		constraints: {
			padding: { x: px, y: py },
		},
	} = cameraOptions

	return (
		<div
			style={{
				position: 'absolute',
				top: py,
				left: px,
				width: `calc(100% - ${px * 2}px)`,
				height: `calc(100% - ${py * 2}px)`,
				border: '1px dotted var(--color-text)',
				pointerEvents: 'none',
			}}
		/>
	)
})

const BoundsDisplay = track(() => {
	const editor = useEditor()
	const cameraOptions = editor.getCameraOptions()

	if (!cameraOptions.constraints) return null

	const {
		constraints: {
			bounds: { x, y, w, h },
		},
	} = cameraOptions

	const d = Vec.ToAngle({ x: w, y: h }) * (180 / Math.PI)
	const colB = '#00000002'
	const colA = '#0000001F'

	return (
		<>
			<div
				style={{
					position: 'absolute',
					top: y,
					left: x,
					width: w,
					height: h,
					// grey and white stripes
					border: '1px dashed var(--color-text)',
					backgroundImage: `
			
				`,
					backgroundSize: '200px 200px',
					backgroundPosition: '0 0, 0 100px, 100px -100px, -100px 0px',
				}}
			>
				<div
					style={{
						position: 'absolute',
						top: 0,
						left: 0,
						width: '100%',
						height: '100%',
						backgroundImage: `
						linear-gradient(0deg, ${colB} 0%, ${colA} 50%, ${colB} 50%, ${colA} 100%),
						linear-gradient(90deg, ${colB} 0%, ${colA} 50%, ${colB} 50%, ${colA} 100%),
						linear-gradient(${d}deg, ${colB} 0%, ${colA} 50%, ${colB} 50%, ${colA} 100%),
						linear-gradient(-${d}deg, ${colB} 0%, ${colA} 50%, ${colB} 50%, ${colA} 100%)`,
					}}
				></div>
			</div>
		</>
	)
})

const components = {
	// These components are just included for debugging / visualization!
	OnTheCanvas: BoundsDisplay,
	InFrontOfTheCanvas: PaddingDisplay,
}

const CameraOptionsControlPanel = track(() => {
	const editor = useEditor()

	const [cameraOptions, setCameraOptions] = useLocalStorageState('camera ex1', CAMERA_OPTIONS)

	useEffect(() => {
		if (!editor) return
		editor.run(() => {
			editor.setCameraOptions(cameraOptions)
			editor.setCamera(editor.getCamera(), {
				immediate: true,
			})
		})
	}, [editor, cameraOptions])

	const { constraints } = cameraOptions

	const updateOptions = (
		options: Partial<
			Omit<TLCameraOptions, 'constraints'> & {
				constraints: Partial<TLCameraOptions['constraints']>
			}
		>
	) => {
		const { constraints } = options
		const cameraOptions = editor.getCameraOptions()
		setCameraOptions({
			...cameraOptions,
			...options,
			constraints:
				constraints === undefined
					? cameraOptions.constraints
					: {
							...(cameraOptions.constraints! ?? CAMERA_OPTIONS.constraints),
							...constraints,
						},
		})
	}

	return (
		<div
			style={{
				pointerEvents: 'all',
				position: 'absolute',
				top: 50,
				left: 0,
				padding: 4,
				background: 'white',
				zIndex: 1000000,
			}}
		>
			<div
				style={{
					display: 'grid',
					gridTemplateColumns: 'auto 1fr',
					columnGap: 12,
					rowGap: 4,
					marginBottom: 12,
					alignItems: 'center',
					justifyContent: 'center',
				}}
			>
				<label htmlFor="lock">Lock</label>
				<select
					name="lock"
					value={cameraOptions.isLocked ? 'true' : 'false'}
					onChange={(e) => {
						const value = e.target.value
						updateOptions({
							...CAMERA_OPTIONS,
							isLocked: value === 'true',
						})
					}}
				>
					<option value="true">true</option>
					<option value="false">false</option>
				</select>
				<label htmlFor="wheelBehavior">Wheel behavior</label>
				<select
					name="wheelBehavior"
					value={cameraOptions.wheelBehavior}
					onChange={(e) => {
						const value = e.target.value
						updateOptions({
							...CAMERA_OPTIONS,
							wheelBehavior: value as 'zoom' | 'pan',
						})
					}}
				>
					<option>zoom</option>
					<option>pan</option>
				</select>
				<label htmlFor="panspeed">Pan Speed</label>
				<input
					name="panspeed"
					type="number"
					step={0.1}
					value={cameraOptions.panSpeed}
					onChange={(e) => {
						const val = clamp(Number(e.target.value), 0, 2)
						updateOptions({ panSpeed: val })
					}}
				/>
				<label htmlFor="zoomspeed">Zoom Speed</label>
				<input
					name="zoomspeed"
					type="number"
					step={0.1}
					value={cameraOptions.zoomSpeed}
					onChange={(e) => {
						const val = clamp(Number(e.target.value), 0, 2)
						updateOptions({ zoomSpeed: val })
					}}
				/>
				<label htmlFor="zoomsteps">Zoom Steps</label>
				<input
					name="zoomsteps"
					type="text"
					defaultValue={cameraOptions.zoomSteps.join(', ')}
					onChange={(e) => {
						try {
							const val = e.target.value.split(', ').map((v) => Number(v))
							if (val.every((v) => typeof v === 'number' && Number.isFinite(v))) {
								updateOptions({ zoomSteps: val })
							}
						} catch {
							// ignore
						}
					}}
				/>
				<label htmlFor="bounds">Bounds</label>
				<select
					name="bounds"
					value={
						Object.entries(BOUNDS_SIZES).find(([_, b]) => b.w === constraints?.bounds.w)?.[0] ??
						'none'
					}
					onChange={(e) => {
						const currentConstraints = constraints ?? CAMERA_OPTIONS.constraints
						const value = e.target.value

						if (value === 'none') {
							updateOptions({
								...CAMERA_OPTIONS,
								constraints: undefined,
							})
							return
						}

						updateOptions({
							...CAMERA_OPTIONS,
							constraints: {
								...currentConstraints,
								bounds: BOUNDS_SIZES[value] ?? BOUNDS_SIZES.a4,
							},
						})
					}}
				>
					<option value="none">none</option>
					<option value="a4">A4 Page</option>
					<option value="portrait">Portait</option>
					<option value="landscape">Landscape</option>
					<option value="square">Square</option>
				</select>
				{constraints ? (
					<>
						<label htmlFor="initialZoom">Initial Zoom</label>
						<select
							name="initialZoom"
							value={constraints.initialZoom}
							onChange={(e) => {
								updateOptions({
									constraints: {
										...constraints,
										initialZoom: e.target.value as any,
									},
								})
							}}
						>
							<option>fit-min</option>
							<option>fit-max</option>
							<option>fit-x</option>
							<option>fit-y</option>
							<option>fit-min-100</option>
							<option>fit-max-100</option>
							<option>fit-x-100</option>
							<option>fit-y-100</option>
							<option>default</option>
						</select>
						<label htmlFor="zoomBehavior">Base Zoom</label>
						<select
							name="zoomBehavior"
							value={constraints.baseZoom}
							onChange={(e) => {
								updateOptions({
									constraints: {
										...constraints,
										baseZoom: e.target.value as any,
									},
								})
							}}
						>
							<option>fit-min</option>
							<option>fit-max</option>
							<option>fit-x</option>
							<option>fit-y</option>
							<option>fit-min-100</option>
							<option>fit-max-100</option>
							<option>fit-x-100</option>
							<option>fit-y-100</option>
							<option>default</option>
						</select>
						<label htmlFor="originX">Origin X</label>
						<input
							name="originX"
							type="number"
							step={0.1}
							value={constraints.origin.x}
							onChange={(e) => {
								const val = clamp(Number(e.target.value), 0, 1)
								updateOptions({
									constraints: {
										origin: {
											...constraints.origin,
											x: val,
										},
									},
								})
							}}
						/>
						<label htmlFor="originY">Origin Y</label>
						<input
							name="originY"
							type="number"
							step={0.1}
							value={constraints.origin.y}
							onChange={(e) => {
								const val = clamp(Number(e.target.value), 0, 1)
								updateOptions({
									constraints: {
										...constraints,
										origin: {
											...constraints.origin,
											y: val,
										},
									},
								})
							}}
						/>
						<label htmlFor="paddingX">Padding X</label>
						<input
							name="paddingX"
							type="number"
							step={10}
							value={constraints.padding.x}
							onChange={(e) => {
								const val = clamp(Number(e.target.value), 0)
								updateOptions({
									constraints: {
										...constraints,
										padding: {
											...constraints.padding,
											x: val,
										},
									},
								})
							}}
						/>
						<label htmlFor="paddingY">Padding Y</label>
						<input
							name="paddingY"
							type="number"
							step={10}
							value={constraints.padding.y}
							onChange={(e) => {
								const val = clamp(Number(e.target.value), 0)
								updateOptions({
									constraints: {
										padding: {
											...constraints.padding,
											y: val,
										},
									},
								})
							}}
						/>
						<label htmlFor="behaviorX">Behavior X</label>
						<select
							name="behaviorX"
							value={(constraints.behavior as { x: any; y: any }).x}
							onChange={(e) => {
								setCameraOptions({
									...cameraOptions,
									constraints: {
										...constraints,
										behavior: {
											...(constraints.behavior as { x: any; y: any }),
											x: e.target.value as any,
										},
									},
								})
							}}
						>
							<option>free</option>
							<option>contain</option>
							<option>inside</option>
							<option>outside</option>
							<option>fixed</option>
						</select>
						<label htmlFor="behaviorY">Behavior Y</label>
						<select
							name="behaviorY"
							value={(constraints.behavior as { x: any; y: any }).y}
							onChange={(e) => {
								setCameraOptions({
									...cameraOptions,
									constraints: {
										...constraints,
										behavior: {
											...(constraints.behavior as { x: any; y: any }),
											y: e.target.value as any,
										},
									},
								})
							}}
						>
							<option>free</option>
							<option>contain</option>
							<option>inside</option>
							<option>outside</option>
							<option>fixed</option>
						</select>
					</>
				) : null}
			</div>
			<div style={{ display: 'flex', flexDirection: 'column', gap: 8 }}>
				<button
					onClick={() => {
						editor.setCamera(editor.getCamera(), { reset: true })
						// eslint-disable-next-line no-console
						console.log(editor.getCameraOptions())
					}}
				>
					Reset Camera
				</button>
				<button
					onClick={() => {
						updateOptions(CAMERA_OPTIONS)
					}}
				>
					Reset Camera Options
				</button>
			</div>
		</div>
	)
})
```

--------

# Asset options

Category: Configuration

Keywords: images, videos, gif, dimensions, accepted image types

Control the assets (images, videos, etc.) that can be added to the canvas.

This example demonstrates the `<Tldraw/>` component's props that give you control over assets: which types are allowed, the maximum size, and maximum dimensions.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function AssetPropsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// only allow jpegs
				acceptedImageMimeTypes={['image/jpeg']}
				// don't allow any videos
				acceptedVideoMimeTypes={[]}
				// accept images of any dimension
				maxImageDimension={Infinity}
				// ...but only accept assets up to 1mb
				maxAssetSize={1 * 1024 * 1024}
			/>
		</div>
	)
}

/* 
This example shows how to use props on the Tldraw component to control what types of
assets can be uploaded.

*/
```

--------

# Persistence key

Category: Configuration

Keywords: local storage

Persist the editor's content between sessions by using a persistence key.

If the `persistenceKey` prop is provided to the `<Tldraw/>` component, the editor will persist its data locally under that key.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function PersistenceKeyExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example" />
		</div>
	)
}
```

--------

# Read-only

Category: Configuration

Keywords: read, only mode

Use the editor in read-only mode.

This example shows how to make the editor read-only. This will disable all editing
functionality and show only the select tool, hand tool and laser pointer on the
toolbar.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function ReadOnlyExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="example"
				onMount={(editor) => {
					editor.updateInstanceState({ isReadonly: true })
				}}
			/>
		</div>
	)
}

/* 
This example shows how to make the editor read-only. We use the `onMount` prop to
set the editor's `isReadonly` state to `true`. This will disable all editing
functionality and show only the select tool, hand tool and laser pointer on the
toolbar.
*/
```

--------

# Custom embeds

Category: Configuration

Keywords: embed, custom

Allow custom embeds.

tldraw comes with support for many types of embeds out of the box, but it also comes with the ability to create custom embeds. In this example we'll remove some of the built in embeds and also create a JSFiddle embed.

## App.tsx

```tsx
import {
	CustomEmbedDefinition,
	DEFAULT_EMBED_DEFINITIONS,
	DefaultEmbedDefinitionType,
	Tldraw,
} from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

// [1]
const defaultEmbedTypesToKeep: DefaultEmbedDefinitionType[] = ['tldraw', 'youtube']
const defaultEmbedsToKeep = DEFAULT_EMBED_DEFINITIONS.filter((embed) =>
	defaultEmbedTypesToKeep.includes(embed.type)
)

// [2]
const customEmbed: CustomEmbedDefinition = {
	type: 'jsfiddle',
	title: 'JSFiddle',
	hostnames: ['jsfiddle.net'],
	minWidth: 300,
	minHeight: 300,
	width: 720,
	height: 500,
	doesResize: true,
	toEmbedUrl: (url) => {
		const urlObj = new URL(url)
		const matches = urlObj.pathname.match(/\/([^/]+)\/([^/]+)\/(\d+)\/embedded/)
		if (matches) {
			return `https://jsfiddle.net/${matches[1]}/${matches[2]}/embedded/`
		}
		return
	},
	fromEmbedUrl: (url) => {
		const urlObj = new URL(url)
		const matches = urlObj.pathname.match(/\/([^/]+)\/([^/]+)\/(\d+)\/embedded/)
		if (matches) {
			return `https://jsfiddle.net/${matches[1]}/${matches[2]}/`
		}
		return
	},
	icon: 'https://jsfiddle.net/img/favicon.png',
}

// [3]
const embeds = [...defaultEmbedsToKeep, customEmbed]

export default function CustomEmbedExample() {
	return (
		<div className="tldraw__editor">
			{/* [4] */}
			<Tldraw embeds={embeds} />
		</div>
	)
}

/**

[1]
tldraw has built-in support for embedding content from several popular apps. In this example, we extract the definitions for handling 'tldraw' and 'youtube' content, and discard the rest.

[2]
We will also add support for embedding JSFiddles. Please note that you have to specify an icon that will be displayed in the `EmbedDialog` component.

[3]
We concatenate the filtered embed definitions with our custom JSFiddle one. 

[4]
We now pass the custom embed definitions to the `Tldraw` component. 

*/
```

--------

# Custom stroke and font sizes

Category: Configuration

Keywords: stroke, font, size, style

Customize the available stroke and font sizes in tldraw.

Override the `STROKE_SIZES`, and `FONT_SIZES` constants to override the default values.

Note that this will change the stroke and font sizes for ALL instances of tldraw. For example, if you run this example locally, and then open another example, the changes will be present there too until you reload!

## App.tsx

```tsx
import { FONT_SIZES, STROKE_SIZES, Tldraw } from 'tldraw'

// Mutate the built-in stroke sizes
STROKE_SIZES.s = 1
STROKE_SIZES.m = 2
STROKE_SIZES.l = 4
STROKE_SIZES.xl = 8

// Mutate the built-in font sizes
FONT_SIZES.s = 12
FONT_SIZES.m = 16
FONT_SIZES.l = 20
FONT_SIZES.xl = 24

export default function StrokeAndFontSizesExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw />
		</div>
	)
}
```

--------

# Deep links

Category: Configuration

Keywords: basic, intro, simple, quick, start

Allow linking to specific parts of a tldraw canvas.

Deep Links are URLs which point to a specific part of a document. We provide a comprehensive set of tools to help you create and manage deep links in your application.

## The `deepLinks` prop

The highest-level API for managing deep links is the `deepLinks` prop on the `<Tldraw />` component. This prop is designed for manipulating `window.location` to add a search param which tldraw can use to navigate to a specific part of the document.

e.g. `https://my-app.com/document-name?d=v1234.-234.3.21`

If you set `deepLinks` to `true` e.g. `<Tldraw deepLinks />` the following default behavior will be enabled:

1. When the editor initializes, before the initial render, it will check the current `window.location` for a search param called `d`. If found, it will try to parse the value of this param as a deep link and navigate to that part of the document.
2. 500 milliseconds after every time the editor finishes navigating to a new part of the document, it will update `window.location` to add the latest version of the `d` param.

You can customize this behavior by passing a configuration object as the `deepLinks` prop. e.g.

```tsx
<Tldraw
	deepLinks={{
		// change the param name to `page`
		paramName: 'page',
		// only link to the current page
		getTarget(editor) {
			return { type: 'page', pageId: editor.getCurrentPageId() }
		},
		// log the new search params to the console instead of updating `window.location`
		onChange(url) {
			console.log('the new search params are', url.searchParams)
		},
		// set the debounce interval to 100ms instead of 500ms
		debounceMs: 100,
	}}
/>
```

For full options see the [`TLDeepLinkOptions`](/reference/editor/TLDeepLinkOptions) API reference.

## Handling deep links manually

We expose the core functionality for managing deep links as a set of methods and utilities. This gives you more control e.g. if you prefer not to use search params in the URL.

### Creating a deep link

You can create an isolated deep link string using the [`createDeepLinkString`](/reference/editor/createDeepLinkString) helper which takes a [`TLDeepLink`](/reference/editor/TLDeepLink) descriptor object.

```tsx
createDeepLinkString({ type: 'page', pageId: 'page:abc123' })
// => 'pabc123'
createDeepLinkString({ type: 'shapes', shapeIds: ['shape:foo', 'shape:bar'] })
// => 'sfoo.bar'
createDeepLinkString({
	type: 'viewport',
	pageId: 'page:abc123',
	bounds: {
		x: 0,
		y: 0,
		w: 1024,
		h: 768,
	},
})
// => 'v0.0.1024.768.abc123'
```

If you do prefer to put this in a URL as a query param, you can use the [`Editor.createDeepLink`](/reference/editor/Editor#createDeepLink) method.

```tsx
editor.createDeepLink({ to: { type: 'page', pageId: 'page:abc123' } })
// => 'https://my-app.com/document-name?d=pabc123'
```

### Handling a deep link

You can parse a deep link string with [`parseDeepLinkString`](/reference/editor/parseDeepLinkString) which returns a [`TLDeepLink`](/reference/editor/TLDeepLink) descriptor object.

You can then call [`Editor.navigateToDeepLink`](/reference/editor/Editor#navigateToDeepLink) with this descriptor to navigate to the part of the document described by the deep link.

`Editor#navigateToDeepLink` also can take a plain URL if the deep link is encoded as a query param.

```tsx
editor.navigateToDeepLink(parseDeepLinkString('pabc123'))
// or pass in a url
editor.navigateToDeepLink({ url: 'https://my-app.com/document-name?d=pabc123' })
// or call without options to use the current `window.location`
editor.navigateToDeepLink()
```

### Listening for deep link changes

You can listen for deep link changes with the [`Editor.registerDeepLinkListener`](/reference/editor/Editor#registerDeepLinkListener) method, which takes the same options as the `deepLinks` prop.

```tsx
useEffect(() => {
	const unlisten = editor.registerDeepLinkListener({
		paramName: 'page',
		getTarget(editor) {
			return { type: 'page', pageId: editor.getCurrentPageId() }
		},
		onChange(url) {
			console.log('the new search params are', url.searchParams)
		},
		debounceMs: 100,
	})
	return () => {
		unlisten()
	}
}, [])
```

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function DeepLinksExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example" deepLinks />
		</div>
	)
}
```

--------

# Frame colors

Category: Configuration

Keywords: frame, color

Use the `showColors` option to display colored fills and headings on frame shapes.

Use the `showColors` option to display colored fills and headings on frame shapes.

Create a frame (keyboard shortcut **F**) and see how it looks with the `showColors` option enabled.

## App.tsx

```tsx
import { FrameShapeUtil, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

const ConfiguredFrameShapeUtil = FrameShapeUtil.configure({ showColors: true })

export default function FrameColorsExample() {
	return (
		<>
			<div className="tldraw__editor">
				<Tldraw persistenceKey="example" shapeUtils={[ConfiguredFrameShapeUtil]}></Tldraw>
			</div>
		</>
	)
}
```

--------

# Note resizing

Category: Configuration

Keywords: note, resize, sticky

Make the note shape resizable.

The editor's options include alternative resizing behavior for note shapes. Set `resizeMode` to either `none` for the default behavior or `scale` to allow a user to scale the note.

## App.tsx

```tsx
import { NoteShapeUtil, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// Configure the note shape util to allow scaling to resize
const shapeUtils = [NoteShapeUtil.configure({ resizeMode: 'scale' })]

export default function ResizeNoteExample() {
	return (
		<>
			<div className="tldraw__editor">
				{/* pass the configured shape utils to the editor */}
				<Tldraw persistenceKey="resize-note" shapeUtils={shapeUtils}></Tldraw>
			</div>
		</>
	)
}
```

--------

# Disable pages

Category: Configuration

Keywords: basic, intro, simple, quick, start, page

Disabling page-related UI for single-page use cases.

You can set the `maxPages` option to `1` to disable the page selector and other UI related to managing pages.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// You can set the `maxPages` option to 1 to disable UI related to managing multiple pages.

export default function DisablePagesExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="disable-pages" options={{ maxPages: 1 }} />
		</div>
	)
}
```

--------

# Minimal

Category: Configuration

Keywords: select, tool, editor, bare, bones

Use the `<TldrawEditor/>` component to render a bare-bones editor with minimal built-in shapes and tools.

This example shows how the `<TldrawEditor/>` component can be used to render a bare-bones editor. It uses minimal built-in shapes and tools.

## App.tsx

```tsx
/* eslint-disable import/no-extraneous-dependencies */

import { Editor, TldrawEditor, createShapeId } from '@tldraw/editor'
import 'tldraw/tldraw.css'
import { MiniBoxShapeUtil } from './MiniBoxShape'
import { MiniSelectTool } from './MiniSelectTool'

// There's a guide at the bottom of this page!

// [1]
const myTools = [MiniSelectTool]
const myShapeUtils = [MiniBoxShapeUtil]

// [2]
export default function OnlyEditorExample() {
	return (
		<div className="tldraw__editor">
			<TldrawEditor
				tools={myTools}
				shapeUtils={myShapeUtils}
				initialState="select"
				onMount={(editor: Editor) => {
					editor
						.selectAll()
						.deleteShapes(editor.getSelectedShapeIds())
						.createShapes([
							{
								id: createShapeId(),
								type: 'box',
								x: 100,
								y: 100,
							},
						])
				}}
				components={{
					// [3]
					OnTheCanvas: () => {
						return (
							<div
								style={{
									position: 'absolute',
									transform: `translate(16px, 16px)`,
									width: '320px',
								}}
							>
								<p>Double click to create or delete shapes.</p>
								<p>Click or Shift+Click to select shapes.</p>
								<p>Click and drag to move shapes.</p>
							</div>
						)
					},
				}}
			/>
		</div>
	)
}

/*
This example shows how to use the TldrawEditor component on its own. This is useful if you want to
create your own custom UI, shape and tool interactions.

[1]
We create a custom tool and shape util arrays. These are arrays of classes that extend
the built-in state node and shape util classes. Check out MiniSelectTool.ts and
MiniBoxShapeUtil.tsx to see how they work. Or check out the custom config example for
a more in-depth look at how to create custom tools and shapes.

There is an even simpler implementation of the select tool in MicroSelectTool.tsx, but it
isn't used in this example.

[2]
We pass our custom tools and shape utils to the TldrawEditor component. We also pass in our custom
background component to the background prop and set the initial state to the 'select' tool.
*/
```

## MicroSelectTool.ts

```ts
import { StateNode, TLClickEventInfo, TLPointerEventInfo, createShapeId } from 'tldraw'

// There's a guide at the bottom of this file!

//[1]
export class MicroSelectTool extends StateNode {
	static override id = 'select'
	//[2]
	override onPointerDown(info: TLPointerEventInfo) {
		const { editor } = this

		switch (info.target) {
			case 'canvas': {
				const hitShape = editor.getShapeAtPoint(editor.inputs.currentPagePoint)

				if (hitShape) {
					this.onPointerDown({
						...info,
						shape: hitShape,
						target: 'shape',
					})
					return
				}

				editor.selectNone()
				break
			}
			case 'shape': {
				editor.select(info.shape.id)
				break
			}
		}
	}
	//[3]
	override onDoubleClick(info: TLClickEventInfo) {
		const { editor } = this

		if (info.phase !== 'up') return

		switch (info.target) {
			case 'canvas': {
				const hitShape = editor.getShapeAtPoint(editor.inputs.currentPagePoint)

				if (hitShape) {
					this.onDoubleClick({
						...info,
						shape: hitShape,
						target: 'shape',
					})
					return
				}
				const { currentPagePoint } = editor.inputs
				editor.createShapes([
					{
						id: createShapeId(),
						type: 'box',
						x: currentPagePoint.x - 50,
						y: currentPagePoint.y - 50,
						props: {
							w: 100,
							h: 100,
						},
					},
				])
				break
			}
			case 'shape': {
				editor.deleteShapes([info.shape.id])
				break
			}
		}
	}
}
/*
This is a very small example of a state node that implements a "select" tool. It
doesn't implement any children states. 

The state handles two events: onPointerDown [2] and onDoubleClick [2].

When the user points down on the canvas, it deselects all shapes; and when
they point a shape it selects that shape. When the user double clicks on the
canvas, it creates a new shape; and when they double click on a shape, it
deletes that shape.

[1]
This is where we define our state node by extending the StateNode class. Since 
there are no children states We can give it an id and define methods we
want to override to handle events.


[2] onPointerDown
	The user clicked on something, let's figure out what it was. We can
	access the editor via this.editor, and then use it to check if we hit
	a shape. If we did then we call the onPointerDown method again with the
	shape as the target, select the shape, and return. If we didn't hit a
	shape then we deselect all shapes.

[3] onDoubleClick
	The user double clicked on something, let's do the same as above. If we 
	hit a shape then we call the onDoubleClick method again with the shape as 
	the target, delete it, and return. If we didn't hit a shape then we create
	a new shape at the pointer's position.
*/
```

## MiniBoxShape.tsx

```tsx
import { BaseBoxShapeUtil, HTMLContainer, TLBaseShape } from 'tldraw'

// There's a guide at the bottom of this page!

// [1]
export type MiniBoxShape = TLBaseShape<'box', { w: number; h: number; color: string }>

// [2]
export class MiniBoxShapeUtil extends BaseBoxShapeUtil<MiniBoxShape> {
	//[a]
	static override type = 'box'
	//[b]
	override getDefaultProps(): MiniBoxShape['props'] {
		return { w: 100, h: 100, color: '#efefef' }
	}
	//[c]
	component(shape: MiniBoxShape) {
		return (
			<HTMLContainer>
				<div
					style={{
						width: shape.props.w,
						height: shape.props.h,
						border: '1px solid black',
						backgroundColor: shape.props.color,
						pointerEvents: 'all',
					}}
				/>
			</HTMLContainer>
		)
	}
	//[d]
	indicator(shape: MiniBoxShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}

/* 
This is our shape util, in tldraw all shapes extend the shape util class. In this
example we're extending the built-in BaseBoxShapeUtil class. This class provides
the functionality for our shape. 

[1]
The type for our shape, we can extend the built-in TLBaseShape generic to create ours.

[2]
The shape util itself. 
	[a] The type of shape this util is for, this should be the same as the first argument
		to the TLBaseShape generic.
	[b] The default props for our shape. These will be used when creating a new shape.
	[c] The component for our shape. This returns JSX and is what will be rendered on the 
		canvas. The HtmlContainer component is a div that provides some useful styles.
	[d] The indicator for our shape, this also returns JSX. This is what will be rendered 
		on the canvas when the shape is selected.
*/
```

## MiniSelectTool.ts

```ts
import {
	StateNode,
	TLClickEventInfo,
	TLPointerEventInfo,
	TLUnknownShape,
	createShapeId,
} from 'tldraw'
// There's a guide at the bottom of this file!

//[1]
export class MiniSelectTool extends StateNode {
	static override id = 'select'
	static override children() {
		return [IdleState, PointingState, DraggingState]
	}
	static override initial = 'idle'
}
//[2]
class IdleState extends StateNode {
	static override id = 'idle'
	//[a]
	override onPointerDown(info: TLPointerEventInfo) {
		const { editor } = this

		switch (info.target) {
			case 'canvas': {
				const hitShape = editor.getShapeAtPoint(editor.inputs.currentPagePoint)

				if (hitShape) {
					this.onPointerDown({
						...info,
						shape: hitShape,
						target: 'shape',
					})
					return
				}

				editor.selectNone()
				break
			}
			case 'shape': {
				if (editor.inputs.shiftKey) {
					editor.select(...editor.getSelectedShapeIds(), info.shape.id)
				} else {
					if (!editor.getSelectedShapeIds().includes(info.shape.id)) {
						editor.select(info.shape.id)
					}
					this.parent.transition('pointing', info)
				}
				break
			}
		}
	}
	//[b]
	override onDoubleClick(info: TLClickEventInfo) {
		const { editor } = this

		if (info.phase !== 'up') return

		switch (info.target) {
			case 'canvas': {
				const hitShape = editor.getShapeAtPoint(editor.inputs.currentPagePoint)

				if (hitShape) {
					this.onDoubleClick({
						...info,
						shape: hitShape,
						target: 'shape',
					})
					return
				}
				const { currentPagePoint } = editor.inputs
				editor.createShapes([
					{
						id: createShapeId(),
						type: 'box',
						x: currentPagePoint.x - 50,
						y: currentPagePoint.y - 50,
						props: {
							w: 100,
							h: 100,
						},
					},
				])
				break
			}
			case 'shape': {
				editor.deleteShapes([info.shape.id])
				break
			}
		}
	}
}

//[3]
class PointingState extends StateNode {
	static override id = 'pointing'
	//[a]
	override onPointerUp(info: TLPointerEventInfo) {
		this.parent.transition('idle', info)
	}
	//[b]
	override onPointerMove() {
		if (this.editor.inputs.isDragging) {
			this.parent.transition('dragging', { shapes: [...this.editor.getSelectedShapes()] })
		}
	}
}

//[4]
class DraggingState extends StateNode {
	static override id = 'dragging'
	//[a]
	private initialDraggingShapes = [] as TLUnknownShape[]
	//[b]
	override onEnter(info: { shapes: TLUnknownShape[] }) {
		this.initialDraggingShapes = info.shapes
	}
	//[c]
	override onPointerUp(info: TLPointerEventInfo) {
		this.parent.transition('idle', info)
	}
	//[d]
	override onPointerMove() {
		const { initialDraggingShapes } = this
		const { originPagePoint, currentPagePoint } = this.editor.inputs

		this.editor.updateShapes(
			initialDraggingShapes.map((shape) => {
				return {
					...shape,
					x: shape.x + (currentPagePoint.x - originPagePoint.x),
					y: shape.y + (currentPagePoint.y - originPagePoint.y),
				}
			})
		)
	}
}

/*
This is where we implement our select tool. In tldraw, tools are part of the
tldraw state chart. Check out the docs for more info: 
https://tldraw.dev/docs/editor#State-Chart


Our state node [1] has three children: idle [2], pointing [3], and dragging [4]. 
Only one child state can be "active" at a time. The parent state's initial active 
state is "idle". Certain events received by the child states will cause the parent
state to transition to another child state, making that state active instead.

Note that when `transition()` is called, the parent state will call the new
active state(s)'s `onEnter` method with the second argument passed to the
transition method. This is useful for passing data between states.

[1] 
This is where we define our state node by extending the StateNode class. We 
give it an id, a list of children states, and its initial active state.

[2]
The idle state is the tool's default state. This is where most of the action is.
We have some handy methods available to help us handle events:
	
	[a] onPointerDown
		The user clicked on something, let's figure out what it was. We can
		access the editor via this.editor, and then use it to check if we hit
		a shape. If we did then we call the onPointerDown method again with the
		shape as the target, select the shape and transition to the pointing state. 
		Otherwise we deselect everything.
	
	[b] onDoubleClick
		The user double clicked on something, let's do the same thing as above.
		If we hit a shape then we call the onDoubleClick method again with the
		shape as the target, and delete the shape. Otherwise we create a new shape.

[3]
The pointing state is something of a transitionary state. Its job is to transition 
to the dragging state when the user starts dragging, or go back to the idle state 
on pointer up.

	[a] onPointerUp
		The user let go of the mouse, let's go back to the idle state.
	[b] onPointerMove
		The user moved the mouse, let's double check they're dragging. If they are
		then let's transition to the dragging state and pass it the shapes that
		are being dragged.

[4]
The dragging state is where we actually move the shapes around. It's job is to
update the position of the shapes being dragged, and transition back to the idle
state when the user lets go of the mouse.

	[a] initialDraggingShapes
		We'll use this to keep track of the shapes being dragged when we enter
		the state.

	[b] onEnter
		When we enter the dragging state, we'll save the shapes being dragged.

	[c] onPointerUp
		The user let go of the mouse, let's go back to the idle state.

	[d] onPointerMove
		The user moved the mouse, let's update the position of the shapes being
		dragged using editor.updateShapes().
*/
```

--------

# Sublibraries

Category: Configuration

Keywords: ui, components, utils

Tldraw is built from several sublibraries - like the editor, default shapes & tools, and UI.

Tldraw is built from several sublibraries - like the editor, default shapes & tools, and UI. For full customization, you can use these sublibraries directly, or replace them with your own.

## App.tsx

```tsx
import { useEffect } from 'react'
import {
	ContextMenu,
	DEFAULT_SUPPORTED_IMAGE_TYPES,
	DEFAULT_SUPPORT_VIDEO_TYPES,
	DefaultContextMenuContent,
	TldrawEditor,
	TldrawHandles,
	TldrawOverlays,
	TldrawScribble,
	TldrawSelectionForeground,
	TldrawShapeIndicators,
	TldrawUi,
	defaultAddFontsFromNode,
	defaultBindingUtils,
	defaultEditorAssetUrls,
	defaultShapeTools,
	defaultShapeUtils,
	defaultTools,
	registerDefaultExternalContentHandlers,
	registerDefaultSideEffects,
	tipTapDefaultExtensions,
	useEditor,
	useToasts,
	useTranslation,
} from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

// [1]
const defaultComponents = {
	Scribble: TldrawScribble,
	ShapeIndicators: TldrawShapeIndicators,
	CollaboratorScribble: TldrawScribble,
	SelectionForeground: TldrawSelectionForeground,
	Handles: TldrawHandles,
	Overlays: TldrawOverlays,
}

const allDefaultTools = [...defaultTools, ...defaultShapeTools]
const defaultTextOptions = {
	tipTapConfig: {
		extensions: tipTapDefaultExtensions,
	},
	addFontsFromNode: defaultAddFontsFromNode,
}

//[2]
export default function ExplodedExample() {
	return (
		<div className="tldraw__editor">
			<TldrawEditor
				initialState="select"
				shapeUtils={defaultShapeUtils}
				bindingUtils={defaultBindingUtils}
				tools={allDefaultTools}
				components={defaultComponents}
				persistenceKey="exploded-example"
				textOptions={defaultTextOptions}
				assetUrls={defaultEditorAssetUrls}
			>
				<TldrawUi>
					<InsideEditorAndUiContext />
				</TldrawUi>
			</TldrawEditor>
		</div>
	)
}

function InsideEditorAndUiContext() {
	const editor = useEditor()
	const toasts = useToasts()
	const msg = useTranslation()

	// [3]
	useEffect(() => {
		registerDefaultExternalContentHandlers(editor, {
			maxImageDimension: 5000,
			maxAssetSize: 10 * 1024 * 1024, // 10mb
			acceptedImageMimeTypes: DEFAULT_SUPPORTED_IMAGE_TYPES,
			acceptedVideoMimeTypes: DEFAULT_SUPPORT_VIDEO_TYPES,
			toasts,
			msg,
		})

		const cleanupSideEffects = registerDefaultSideEffects(editor)

		return () => {
			cleanupSideEffects()
		}
	}, [editor, msg, toasts])

	return (
		<ContextMenu>
			<DefaultContextMenuContent />
		</ContextMenu>
	)
}

/* 
The tldraw library is built from many sublibraries. This example shows how to build the tldraw
component from its subcomponents for max customisation. You can edit, omit or add to these
subcomponents to create your app.

[1] Here we've imported some components from the tldraw library which we will later pass to the
TldrawEditor component. These components are not part of the more minimal defaults, so we need to
import them separately. For help creating your own components to pass into the components prop check
out the custom components example.

[2] Here we've passed the default components object to the TldrawEditor component. Along with
default tools and shapeutils, You could input your own custom shapes/tools here. For help creating
your own shapes/tools check out the custom config example.

We also set the initial state to 'select' and render the UI, context menu and canvas components. You
could add your own custom components here, omit these ones, and/or change the initial state of the
application to whatever you want. 

[3] Inside of the editor and UI context, we need to set up extra pieces to get the editor working
with our default shapes and tools. We register the default external content handlers, which sets up
handling for things like images and pasted content. We also register the default side effects, which
react to changes to the editor's store.

*/
```

--------

# Controlling the canvas

Category: Editor API

Keywords: api, create shape, update shape, mount, context

Manipulate the contents of the canvas using the editor API.

You can manipulate the contents of the canvas using the editor API. This example creates and updates shapes, selects and rotates them, and zooms the camera.

## App.tsx

```tsx
import {
	DefaultColorStyle,
	Editor,
	TLGeoShape,
	TLShapePartial,
	Tldraw,
	toRichText,
	createShapeId,
	useEditor,
} from 'tldraw'
import 'tldraw/tldraw.css'
import { useEffect } from 'react'

// There's a guide at the bottom of this file!

//[1]
export default function APIExample() {
	const handleMount = (editor: Editor) => {
		// Create a shape id
		const id = createShapeId('hello')

		// Create a shape
		editor.createShapes<TLGeoShape>([
			{
				id,
				type: 'geo',
				x: 128 + Math.random() * 500,
				y: 128 + Math.random() * 500,
				props: {
					geo: 'rectangle',
					w: 120,
					h: 100,
					dash: 'draw',
					color: 'blue',
					size: 'm',
				},
			},
		])

		// Get the created shape
		const shape = editor.getShape<TLGeoShape>(id)!

		// Update the shape
		editor.updateShape<TLGeoShape>({
			id,
			type: 'geo',
			props: {
				h: shape.props.h * 3,
				richText: toRichText('hello world!'),
			},
		})

		// Rotate the shape around its center
		editor.rotateShapesBy([id], Math.PI / 8)

		// Zoom the camera to fit the shape
		editor.zoomToFit()

		// Select the shape
		editor.select(id) 
	}

	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="api-example" onMount={handleMount}>
				<InsideOfEditorContext />
			</Tldraw>
		</div>
	)
}

//[2]
const InsideOfEditorContext = () => {
	const editor = useEditor()

	useEffect(() => {
		let i = 0

		const interval = setInterval(() => {
			const selection = [...editor.getSelectedShapeIds()]
			editor.selectAll()
			editor.setStyleForSelectedShapes(DefaultColorStyle, i % 2 ? 'blue' : 'light-blue')
			editor.setStyleForNextShapes(DefaultColorStyle, i % 2 ? 'blue' : 'light-blue')
			editor.setSelectedShapes(selection)
			i++
		}, 1000)

		return () => {
			clearInterval(interval)
		}
	}, [editor])

	return null
}

/* 
Introduction: 

This example shows how to use the tldraw editor instance to make changes 
to the canvas. The editor instance is tldraw's "god object". You can use 
the app to do just about everything that's possible in tldraw. Internally, 
the canvas component and all shapes, tools, and UI components use this instance 
to send events, observe changes, and perform actions. 

There are two main ways to use the editor:

[1] 
The tldraw component shares its editor instance via its onMount callback prop.
When you define a function for the onMount callback, it receives the editor 
instance as an argument. You can use this to manipulate the canvas.


[2]
Another (sneakier) way to access the current app is through React context.
The Tldraw component provides the context, so you can add children to
the component and access the app through the useEditor hook. This is cool.

*/
```

--------

# Save and load snapshots

Category: Editor API

Keywords: 

Sand and load a snapshot of the editor's contents.

Use `getSnapshot()` and `loadSnapshot()` to save and restore the editor's contents.

## App.tsx

```tsx
import { useCallback, useEffect, useState } from 'react'
import { TLEditorSnapshot, Tldraw, getSnapshot, loadSnapshot, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'
import _jsonSnapshot from './snapshot.json'

// There's a guide at the bottom of this file!

const jsonSnapshot = _jsonSnapshot as any as TLEditorSnapshot

// [1]
function SnapshotToolbar() {
	const editor = useEditor()

	const save = useCallback(() => {
		// [2]
		const { document, session } = getSnapshot(editor.store)
		// [3]
		localStorage.setItem('snapshot', JSON.stringify({ document, session }))
	}, [editor])

	const load = useCallback(() => {
		const snapshot = localStorage.getItem('snapshot')
		if (!snapshot) return

		// [4]
		loadSnapshot(editor.store, JSON.parse(snapshot))
	}, [editor])

	const [showCheckMark, setShowCheckMark] = useState(false)
	useEffect(() => {
		if (showCheckMark) {
			const timeout = setTimeout(() => {
				setShowCheckMark(false)
			}, 1000)
			return () => clearTimeout(timeout)
		}
		return
	})

	return (
		<div style={{ padding: 20, pointerEvents: 'all', display: 'flex', gap: '10px' }}>
			<span
				style={{
					display: 'inline-block',
					transition: 'transform 0.2s ease, opacity 0.2s ease',
					transform: showCheckMark ? `scale(1)` : `scale(0.5)`,
					opacity: showCheckMark ? 1 : 0,
				}}
			>
				Saved âœ…
			</span>
			<button
				onClick={() => {
					save()
					setShowCheckMark(true)
				}}
			>
				Save Snapshot
			</button>
			<button onClick={load}>Load Snapshot</button>
		</div>
	)
}

export default function SnapshotExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// [5]
				snapshot={jsonSnapshot}
				components={{
					SharePanel: SnapshotToolbar,
				}}
			/>
		</div>
	)
}

/*

[1] We'll add a toolbar to the top-right of the editor viewport that allows the user to save and load snapshots.

[2] Call `getSnapshot(editor.store)` to get the current state of the editor

[3] The 'document' state is the set of shapes and pages and images etc.
The 'session' state is the state of the editor like the current page, camera positions, zoom level, etc.
You probably need to store these separately if you're building a multi-user app, so that you can store per-user session state.
For this example we'll just store them together in localStorage.

[4] Call `loadSnapshot()` to load a snapshot into the editor
You can omit the `session` state, or load it later on its own.
e.g.
	loadSnapshot(editor.store, { document })
then optionally later
	loadSnapshot(editor.store, { session })

[5] You can load an initial snapshot into the editor by passing it to the `snapshot` prop.

*/
```

--------

# Create an arrow

Category: Editor API

Keywords: arrow, between

Create an arrow between two shapes.

This example shows how you can use the Editor API to create an arrow between two shapes.

## App.tsx

```tsx
import { createShapeId, Editor, TLArrowBinding, TLArrowShape, Tldraw, TLShapeId, Vec } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

export default function CreateArrowExample() {
	return (
		<>
			<div className="tldraw__editor">
				<Tldraw
					onMount={(editor) => {
						// Only do this on an empty canvas
						if (editor.getCurrentPageShapeIds().size > 0) return

						const shapeAId = createShapeId()
						const shapeBId = createShapeId()

						editor.createShapes([
							{
								id: shapeAId,
								type: 'geo',
								x: 100,
								y: 100,
							},
							{
								id: shapeBId,
								type: 'geo',
								x: 400,
								y: 400,
							},
						])

						createArrowBetweenShapes(editor, shapeAId, shapeBId)
					}}
				/>
			</div>
		</>
	)
}

function createArrowBetweenShapes(
	editor: Editor,
	startShapeId: TLShapeId,
	endShapeId: TLShapeId,
	options = {} as {
		parentId?: TLShapeId
		start?: Partial<Omit<TLArrowBinding['props'], 'terminal'>>
		end?: Partial<Omit<TLArrowBinding['props'], 'terminal'>>
	}
) {
	const { start = {}, end = {}, parentId } = options

	// [1]
	const {
		normalizedAnchor: startNormalizedAnchor = { x: 0.5, y: 0.5 },
		isExact: startIsExact = false,
		isPrecise: startIsPrecise = false,
	} = start
	const {
		normalizedAnchor: endNormalizedAnchor = { x: 0.5, y: 0.5 },
		isExact: endIsExact = false,
		isPrecise: endIsPrecise = false,
	} = end

	const startTerminalNormalizedPosition = Vec.From(startNormalizedAnchor)
	const endTerminalNormalizedPosition = Vec.From(endNormalizedAnchor)

	const parent = parentId ? editor.getShape(parentId) : undefined
	if (parentId && !parent) throw Error(`Parent shape with id ${parentId} not found`)

	const startShapePageBounds = editor.getShapePageBounds(startShapeId)
	const endShapePageBounds = editor.getShapePageBounds(endShapeId)

	const startShapePageRotation = editor.getShapePageTransform(startShapeId).rotation()
	const endShapePageRotation = editor.getShapePageTransform(endShapeId).rotation()

	if (!startShapePageBounds || !endShapePageBounds) return

	const startTerminalPagePosition = Vec.Add(
		startShapePageBounds.point,
		Vec.MulV(
			startShapePageBounds.size,
			Vec.Rot(startTerminalNormalizedPosition, startShapePageRotation)
		)
	)
	const endTerminalPagePosition = Vec.Add(
		endShapePageBounds.point,
		Vec.MulV(
			startShapePageBounds.size,
			Vec.Rot(endTerminalNormalizedPosition, endShapePageRotation)
		)
	)

	const arrowPointInParentSpace = Vec.Min(startTerminalPagePosition, endTerminalPagePosition)
	if (parent) {
		arrowPointInParentSpace.setTo(
			editor.getShapePageTransform(parent.id)!.applyToPoint(arrowPointInParentSpace)
		)
	}

	const arrowId = createShapeId()
	editor.run(() => {
		editor.markHistoryStoppingPoint('creating_arrow')
		editor.createShape<TLArrowShape>({
			id: arrowId,
			type: 'arrow',
			// [2]
			x: arrowPointInParentSpace.x,
			y: arrowPointInParentSpace.y,
			props: {
				// [3]
				start: {
					x: arrowPointInParentSpace.x - startTerminalPagePosition.x,
					y: arrowPointInParentSpace.x - startTerminalPagePosition.x,
				},
				end: {
					x: arrowPointInParentSpace.x - endTerminalPagePosition.x,
					y: arrowPointInParentSpace.x - endTerminalPagePosition.x,
				},
			},
		})

		editor.createBindings<TLArrowBinding>([
			{
				fromId: arrowId,
				toId: startShapeId,
				type: 'arrow',
				props: {
					terminal: 'start',
					normalizedAnchor: startNormalizedAnchor,
					isExact: startIsExact,
					isPrecise: startIsPrecise,
				},
			},
			{
				fromId: arrowId,
				toId: endShapeId,
				type: 'arrow',
				props: {
					terminal: 'end',
					normalizedAnchor: endNormalizedAnchor,
					isExact: endIsExact,
					isPrecise: endIsPrecise,
				},
			},
		])
	})
}

/*
Introduction:

This example shows how to create an arrow between two shapes.

[1] 
The normalized anchor is the position inside the shape that the arrow connects to, where 0 0 is the
top left corner and 1 1 is the bottom right. `isPrecise` needs to be enabled for this position to be
used, otherwise it targets the center of the shape.

By default, arrows don't intersect shapes they're connected to, and instead gracefully touch the
outside of the shape's geometry. You can turn this off and make an arrow intersect a shape by
setting `isExact` to true.

[2]
The arrow shape's position is in parent space, which in this case means the page.

[3]
The arrow's start and end positions are "local", which means they're relative to the arrow's
position. Note: You don't need to set the arrow's start and end positions if they're bound to
another shape, as it gets calculated automatically.

*/
```

--------

# Create a video shape

Category: Editor API

Keywords: asset, video

Create a video shape using a local asset.

This example shows how to create a `TLVideoAsset` for a video file that's hosted locally and add a `VideoShape` referencing that asset to the canvas.

## App.tsx

```tsx
import { useCallback } from 'react'
import { AssetRecordType, Editor, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function LocalVideosExample() {
	const handleMount = useCallback((editor: Editor) => {
		const assetId = AssetRecordType.createId()
		const videoWidth = 640
		const videoHeight = 360

		editor.createAssets([
			{
				id: assetId,
				type: 'video',
				typeName: 'asset',
				props: {
					name: 'fluid.mp4',
					src: '/fluid.mp4',
					w: videoWidth,
					h: videoHeight,
					mimeType: 'video/mp4',
					isAnimated: true,
				},
				meta: {},
			},
		])

		editor.createShape({
			type: 'video',
			x: (window.innerWidth - videoWidth) / 2,
			y: (window.innerHeight - videoHeight) / 2,
			props: {
				assetId,
				w: videoWidth,
				h: videoHeight,
			},
		})
	}, [])

	return (
		<div className="tldraw__editor">
			<Tldraw onMount={handleMount} />
		</div>
	)
}
```

--------

# Create an image shape

Category: Editor API

Keywords: asset, record, create asset

Create an image shape using a local asset.

This example shows how to use local images in the built-in `ImageShape` shape. You must first create an asset that holds the source of the image, then create a shape that references the asset.

## App.tsx

```tsx
import { useCallback } from 'react'
import { AssetRecordType, Editor, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
// There's a guide at the bottom of this file!

export default function LocalImagesExample() {
	// [1]
	const handleMount = useCallback((editor: Editor) => {
		//[2]
		const assetId = AssetRecordType.createId()
		const imageWidth = 1200
		const imageHeight = 675
		//[2]
		editor.createAssets([
			{
				id: assetId,
				type: 'image',
				typeName: 'asset',
				props: {
					name: 'tldraw.png',
					src: '/tldraw.png', // You could also use a base64 encoded string here
					w: imageWidth,
					h: imageHeight,
					mimeType: 'image/png',
					isAnimated: false,
				},
				meta: {},
			},
		])
		//[3]
		editor.createShape({
			type: 'image',
			// Let's center the image in the editor
			x: (window.innerWidth - imageWidth) / 2,
			y: (window.innerHeight - imageHeight) / 2,
			props: {
				assetId,
				w: imageWidth,
				h: imageHeight,
			},
		})
	}, [])

	return (
		<div className="tldraw__editor">
			<Tldraw onMount={handleMount} />
		</div>
	)
}

/* 
This is an example of how you can add a locally hosted image to the editor.
We need to first create an asset that holds the source image [2], and then 
create the Image shape itself [3].

Because this is a Next.js app, we can use the `public` folder to store the 
image locally, your framework may have a different way of serving static
assets. 

If you want to allow users to upload the images please take a look at the 
hosted images example.

[1] 
We'll access the editor instance via the `onMount` callback. Check out the API 
example for another way to do this.

[2]
Assets are records that store data about shared assets like images, videos, etc. 
Each image has an associated asset record, so we'll create that first. We need an 
`assetId` so that we can later associate it with the image.

[3]
We create the image shape and pass in the `assetId` that we created earlier. This
will link our image shape to the asset record. Notice that we create the shape with
the same dimensions as the image, later on the user may resize the image, but we 
don't want to resize our asset, this is one of the reasons why it's important to 
keep assets and shapes separate.
*/
```

--------

# Focus the editor

Category: Editor API

Keywords: instance, state, keyboard shortcuts

Manually manage the editor's focus to enable or disable keyboard shortcuts.

In this example, we drive the editor's focus in order to turn on and off keyboard shortcuts.

The editor's focus is different fromâ€”but usually corresponds toâ€”the browser's concept of "focus", which is related to the document's [active element](https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement).

Unfortunately, the browser's focus cannot be relied on to determine whether the editor's keyboard shortcuts should work. While its possible to detect whether the document's active element is a descendant of the Tldraw component's own element, it's not 100% reliable. For example, iframes are not considered descendants of their parents, and many menus are portalled into different parts of the document tree.

For these reasons, the responsibility falls to you, dear developer, to manage focus for your Tldraw editor, especially in cases where there are more than one editor on the same page.

## App.tsx

```tsx
import { useRef } from 'react'
import { Editor, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import './editor-focus.css'

export default function EditorFocusExample() {
	const editorRef = useRef<Editor | null>(null)
	return (
		<div style={{ padding: 32 }}>
			<input type="text" placeholder="Test me" />
			<p>
				You should be able to type in this text input without worrying about triggering editor
				shortcuts even when the editor is focused.
			</p>
			<div>
				<h2>Controlled Focus</h2>
				<div style={{ display: 'flex', gap: 4 }}>
					<input
						id="focus"
						type="checkbox"
						onChange={(e) => {
							if (e.target.checked) {
								editorRef.current?.focus()
							} else {
								editorRef.current?.blur()
							}
						}}
					/>
					<label htmlFor="focus">Focus</label>
				</div>
			</div>
			<p>The checkbox focuses and blurs the editor.</p>
			<p>
				When the editor is â€œfocusedâ€, its keyboard shortcuts will work. When it is not focused, the
				keyboard shortcuts will not work.
			</p>
			<div style={{ width: 800, maxWidth: '100%', height: 500 }}>
				<Tldraw
					autoFocus={false}
					onMount={(editor) => {
						editorRef.current = editor
					}}
				/>
			</div>
		</div>
	)
}
```

## editor-focus.css

```css
.tl-container__focused {
	outline: 1px solid var(--color-primary);
}
```

--------

# Lock camera zoom

Category: Editor API

Keywords: camera, lock, zoom

Lock the camera at a specific zoom level.

Need to lock the camera at its current zoom level? You can use the camera controls API to keep the zoom level from changing.

In this example, press Shift+K to lock the camera at its current zoom level. Press Shift+L to unlock the camera and allow it to zoom again.

## App.tsx

```tsx
import { Tldraw, TLUiOverrides } from 'tldraw'
import 'tldraw/tldraw.css'

const DEFAULT_CAMERA_STEPS = [0.05, 0.1, 0.25, 0.5, 1, 2, 4, 8]

const overrides: TLUiOverrides = {
	actions(editor, actions) {
		actions.lockCameraZoom = {
			id: 'lock-camera-zoom',
			kbd: 'shift+k',
			onSelect() {
				const isCameraZoomLockedAlready = editor.getCameraOptions().zoomSteps.length === 1
				editor.setCameraOptions({
					zoomSteps: isCameraZoomLockedAlready ? DEFAULT_CAMERA_STEPS : [editor.getZoomLevel()],
				})
			},
		}

		return actions
	},
}

export default function BasicExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example" overrides={overrides} />
		</div>
	)
}
```

--------

# Search text on the canvas

Category: Editor API

Keywords: zoom, pan, camera bounds, search, text

Search through all the text on the canvas.

A simple example of how to use the API to search for text in shapes and display results in the `HelperButtons` part of the user interface. Press Ctrl+F or Cmd+F to open the search bar.

## App.tsx

```tsx
import { TLComponents, TLUiOverrides, Tldraw, atom, track } from 'tldraw'
import 'tldraw/tldraw.css'
import { TextSearchPanel } from './TextSearchPanel'
import './text-search.css'

export const showSearch = atom('showSearch', false)

const components: TLComponents = {
	HelperButtons: TextSearchPanel,
}

const overrides: TLUiOverrides = {
	actions(_editor, actions) {
		return {
			...actions,
			'text-search': {
				id: 'text-search',
				label: 'Search',
				kbd: 'cmd+f,ctrl+f',
				onSelect() {
					if (!showSearch.get()) {
						showSearch.set(true)
					}
				},
			},
		}
	},
}

const TextSearchExample = track(() => {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="text-search-example" overrides={overrides} components={components} />
		</div>
	)
})

export default TextSearchExample
```

## TextSearchPanel.tsx

```tsx
import { useEffect, useRef, useState } from 'react'
import {
	EASINGS,
	Editor,
	TLShape,
	TldrawUiButton,
	stopEventPropagation,
	track,
	useEditor,
} from 'tldraw'
import { showSearch } from './TextSearchExample'

interface SearchResult {
	text: string
	shape: TLShape
}

function moveToShape(editor: Editor, shape: TLShape) {
	const bounds = editor.getShapePageBounds(shape.id)
	if (!bounds) return
	editor.setSelectedShapes([shape.id])
	editor.zoomToSelection({
		animation: { duration: 500, easing: EASINGS.easeInOutCubic },
	})
}

function keyDown(e: React.KeyboardEvent) {
	if (e.key === 'Escape') {
		showSearch.set(false)
	}
}

function getShapesWithText(editor: Editor, text: string): SearchResult[] {
	if (!text || text.length === 0) return []
	const shapes = editor.getCurrentPageShapes()
	const result: SearchResult[] = []
	shapes.forEach((shape) => {
		const util = editor.getShapeUtil(shape)
		const shapeText = util.getText(shape)
		if (shapeText && shapeText.includes(text)) {
			result.push({ text: shapeText, shape })
		}
	})
	return result.sort((a, b) => a.text.localeCompare(b.text))
}

export const TextSearchPanel = track(() => {
	const editor = useEditor()
	const [searchText, setSearchText] = useState('')
	const inputRef = useRef<HTMLInputElement>(null)
	const isVisible = showSearch.get()

	useEffect(() => {
		if (isVisible) {
			setSearchText('')
			inputRef.current?.focus()
		}
	}, [isVisible])

	if (!isVisible) return null

	const results = getShapesWithText(editor, searchText)
	return (
		<div
			className="text-search-panel scroll-light"
			onPointerDown={(e) => stopEventPropagation(e)}
			onKeyDown={keyDown}
		>
			<input
				className="text-search-input"
				ref={inputRef}
				onChange={(e) => setSearchText(e.target.value)}
			></input>
			{results.map((result) => {
				return (
					<TldrawUiButton
						key={'text-search-panel-button:' + result.shape.id}
						type="normal"
						className="text-search-panel-button"
						onClick={() => moveToShape(editor, result.shape)}
					>
						{result.text}
					</TldrawUiButton>
				)
			})}
		</div>
	)
})
```

## text-search.css

```css
.text-search-panel {
	display: flex;
	flex-direction: column;
	gap: 4px;
	max-height: calc(100% - 110px);
	margin: 50px 0px;
	padding: 4px;
	background-color: var(--color-low);
	pointer-events: all;
	border-top-right-radius: var(--radius-4);
	border-bottom-right-radius: var(--radius-4);
	overflow: auto;
	border-right: 2px solid var(--color-background);
	border-bottom: 2px solid var(--color-background);
	border-top: 2px solid var(--color-background);
}

.text-search-panel-button {
	border-radius: var(--radius-4);
	outline-offset: -1px;
}

.text-search-shape-label {
	pointer-events: all;
	position: absolute;
	background: var(--color-low);
	padding: calc(12px * var(--tl-scale));
	border-bottom-right-radius: calc(var(--radius-4) * var(--tl-scale));
	font-size: calc(12px * var(--tl-scale));
	color: var(--color-text);
	white-space: nowrap;
}

.text-search-input {
	border-radius: var(--radius-2);
	margin: 4px;
}
```

--------

# Toggle focus mode

Category: Editor API

Keywords: focus, mode, editor, state, instance

How to enable focus mode by using the editor API.

This example demonstrates how to enable focus mode when the editor mounts. Focus mode provides a distraction-free environment by hiding the UI elements and focusing on the canvas content.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function FocusModeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					// [1]
					editor.updateInstanceState({ isFocusMode: true })
				}}
			/>
		</div>
	)
}

/**
 * This example demonstrates how to enable focus mode when the editor mounts.
 *
 * [1] The editor's instance state is updated on mount to enable focus mode.
 */
```

--------

# Inspector panel

Category: UI & theming

Keywords: inspector, properties, props, selection, panel

Display an inspector panel that shows the properties of the currently selected shape.

This example demonstrates how to create an inspector panel that displays all properties of the currently selected shape. When a single shape is selected, the panel shows the shape's type, position, dimensions, and all custom properties. The panel updates reactively as you select different shapes or modify their properties.

The inspector shows:

- Basic shape properties (id, type, position, rotation, etc.)
- Shape-specific props (dimensions, colors, styles, etc.)
- Meta information and other attributes

This is useful for debugging, educational purposes, or creating admin interfaces where you need to inspect shape data.

## App.tsx

```tsx
import { useState } from 'react'
import { Editor, EditorProvider, Tldraw, useEditor, useIsDarkMode, useValue } from 'tldraw'
import 'tldraw/tldraw.css'
import './inspector-panel.css'

// Inspector Panel Component that shows selected shape properties
function InspectorPanel() {
	const editor = useEditor()

	// Get the currently selected shapes, updates reactively
	const selectedShapes = useValue('selected shapes', () => editor.getSelectedShapes(), [editor])

	// Get shared styles when multiple shapes are selected
	const sharedStyles = useValue(
		'shared styles',
		() => {
			if (selectedShapes.length <= 1) return null
			return editor.getSharedStyles()
		},
		[editor, selectedShapes]
	)

	// Get bindings involving the selected shape (only for single selection)
	const bindings = useValue(
		'bindings',
		() => {
			if (selectedShapes.length !== 1) return []
			return editor.getBindingsInvolvingShape(selectedShapes[0].id)
		},
		[editor, selectedShapes]
	)

	const isDarkMode = useIsDarkMode()

	const selectedShape = selectedShapes.length === 1 ? selectedShapes[0] : null

	if (selectedShapes.length === 0) {
		return (
			<div
				className={`${isDarkMode ? 'inspector-panel inspector-panel-dark' : ''} inspector-panel`}
			>
				<h3>Inspector</h3>
				<p>No shape selected</p>
			</div>
		)
	}

	if (selectedShapes.length > 1) {
		return (
			<div
				className={`${isDarkMode ? 'inspector-panel inspector-panel-dark' : ''} inspector-panel`}
			>
				<h3>Inspector</h3>
				{sharedStyles && sharedStyles.size > 0 && (
					<div className="inspector-section">
						<h4>Shared Styles</h4>
						{Array.from(sharedStyles.entries()).map(([styleProp, sharedStyle]) => (
							<SharedStyleRow key={styleProp.id} styleProp={styleProp} sharedStyle={sharedStyle} />
						))}
					</div>
				)}
				<p>{selectedShapes.length} shapes selected</p>
			</div>
		)
	}

	// Single shape selected
	return (
		<div className={`${isDarkMode ? 'inspector-panel inspector-panel-dark' : ''} inspector-panel`}>
			<h3>Inspector</h3>
			<div className="inspector-section">
				{Object.entries(selectedShape!).map(([key, value]) => {
					if (key === 'props') return null // Skip props, we'll show them separately
					return <PropertyRow key={key} name={key} value={value} path={`basic.${key}`} />
				})}
			</div>

			{selectedShape!.props && Object.keys(selectedShape!.props).length > 0 && (
				<div className="inspector-section">
					<h4>Shape Props</h4>
					{Object.entries(selectedShape!.props).map(([key, value]) => (
						<PropertyRow key={key} name={key} value={value} path={`props.${key}`} />
					))}
				</div>
			)}

			{bindings.length > 0 && (
				<div className="inspector-section">
					<h4>Bindings ({bindings.length})</h4>
					{bindings.map((binding) => (
						<BindingRow key={binding.id} binding={binding} selectedShapeId={selectedShape!.id} />
					))}
				</div>
			)}
		</div>
	)
}

// Component to render a shared style row
function SharedStyleRow({ styleProp, sharedStyle }: { styleProp: any; sharedStyle: any }) {
	const formatStyleValue = (style: any): string => {
		if (style.type === 'mixed') {
			return '(mixed)'
		} else if (style.type === 'shared') {
			return typeof style.value === 'string' ? `"${style.value}"` : String(style.value)
		}
		return String(style)
	}

	const getStyleClass = (style: any): string => {
		return style.type === 'mixed' ? 'mixed-style' : 'shared-style'
	}

	return (
		<div className="property-row">
			<span className="property-name">{styleProp.id.replace('tldraw:', '')}:</span>
			<span className={`property-value ${getStyleClass(sharedStyle)}`}>
				{formatStyleValue(sharedStyle)}
			</span>
		</div>
	)
}

// Component to render an individual property row
function PropertyRow({ name, value, path: _path }: { name: string; value: any; path: string }) {
	const [isExpanded, setIsExpanded] = useState(false)

	const isObject = value !== null && value !== undefined && typeof value === 'object'

	const formatValue = (val: any): string => {
		if (val === null || val === undefined) return String(val)
		if (typeof val === 'string') return `"${val}"`
		if (typeof val === 'object') {
			if (Array.isArray(val)) return `Array(${val.length})`
			// Handle rich text objects
			if ('richText' in val && val.richText) {
				return `"${val.richText[0]?.children?.[0]?.text || ''}"`
			}
			return `Object(${Object.keys(val).length} keys)`
		}
		return String(val)
	}

	const formatJsonValue = (val: any): string => {
		try {
			return JSON.stringify(val, null, 2)
		} catch (_e) {
			return String(val)
		}
	}

	if (isObject) {
		return (
			<div className="property-row">
				<div className="property-row-header">
					<span className="property-name">{name}:</span>
					<button
						className="toggle-button"
						onClick={() => setIsExpanded(!isExpanded)}
						title={isExpanded ? 'Collapse' : 'Expand'}
					>
						{isExpanded ? 'âˆ’' : '+'}
					</button>
					<span className="property-value">{formatValue(value)}</span>
				</div>
				{isExpanded && (
					<div className="property-json">
						<pre>{formatJsonValue(value)}</pre>
					</div>
				)}
			</div>
		)
	}

	return (
		<div className="property-row">
			<span className="property-name">{name}:</span>
			<span className="property-value">{formatValue(value)}</span>
		</div>
	)
}

// Component to render a binding row
function BindingRow({ binding, selectedShapeId }: { binding: any; selectedShapeId: string }) {
	const editor = useEditor()

	// Determine the relationship
	const isFrom = binding.fromId === selectedShapeId
	const otherShapeId = isFrom ? binding.toId : binding.fromId
	const relationship = isFrom ? 'from' : 'to'

	// Get info about the other shape
	const otherShape = useValue(
		'other shape',
		() => {
			return editor.getShape(otherShapeId)
		},
		[editor, otherShapeId]
	)

	return (
		<div className="binding-row">
			<div className="binding-header">
				<span className="binding-type">{binding.type}</span>
				<span className="binding-direction">({relationship})</span>
			</div>
			<PropertyRow name="id" value={binding.id} path={`binding.${binding.id}.id`} />
			<PropertyRow
				name={relationship === 'from' ? 'toId' : 'fromId'}
				value={otherShapeId}
				path={`binding.${binding.id}.otherId`}
			/>
			{otherShape && (
				<PropertyRow
					name="shape"
					value={otherShape.type}
					path={`binding.${binding.id}.shapeType`}
				/>
			)}
			{binding.props && Object.keys(binding.props).length > 0 && (
				<PropertyRow name="props" value={binding.props} path={`binding.${binding.id}.props`} />
			)}
		</div>
	)
}

export default function InspectorPanelExample() {
	const [editor, setEditor] = useState<Editor | null>(null)

	return (
		<div className="example-container">
			<div className="canvas-container">
				<Tldraw persistenceKey="inspector-panel-example" onMount={setEditor} />
			</div>
			{editor && (
				<EditorProvider editor={editor}>
					<InspectorPanel />
				</EditorProvider>
			)}
		</div>
	)
}
```

## inspector-panel.css

```css
.example-container {
	display: flex;
	height: 100vh;
	width: 100%;
}

.canvas-container {
	flex: 1;
	height: 100vh;
}

.inspector-panel {
	width: 300px;
	background: white;
	border-left: 1px solid #ccc;
	padding: 16px;
	font-family: monospace;
	font-size: 12px;
	overflow-y: auto;
}

.inspector-panel h3 {
	margin: 0 0 16px 0;
	font-size: 14px;
	font-weight: bold;
}

.inspector-panel h4 {
	margin: 16px 0 8px 0;
	font-size: 12px;
	font-weight: bold;
	color: #666;
	text-transform: uppercase;
}

.inspector-panel h4:first-child {
	margin-top: 0;
}

.inspector-panel p {
	margin: 0;
	color: #666;
	font-style: italic;
}

.inspector-section {
	margin-bottom: 16px;
}

.inspector-section:last-child {
	margin-bottom: 0;
}

.property-row {
	margin-bottom: 4px;
	line-height: 1.4;
}

.property-row-header {
	display: flex;
	align-items: center;
}

.property-name {
	flex: 0 0 1;
	font-weight: bold;
	margin-right: 8px;
}

.property-value {
	flex: 1;
	word-break: break-all;
	color: #333;
}

/* Shared style indicators */
.shared-style {
	color: #0066cc;
}

.mixed-style {
	color: #ff6600;
	font-style: italic;
}

.toggle-button {
	background: #e0e0e0;
	border: 1px solid #ccc;
	border-radius: 2px;
	width: 18px;
	height: 18px;
	font-size: 12px;
	font-weight: bold;
	cursor: pointer;
	display: flex;
	align-items: center;
	justify-content: center;
	padding: 0;
	line-height: 1;
	margin-right: 8px;
}

.toggle-button:hover {
	background: #d0d0d0;
}

.toggle-button:active {
	background: #c0c0c0;
}

.property-json {
	margin-top: 4px;
	margin-left: 8px;
	background: #f8f8f8;
	border: 1px solid #e0e0e0;
	border-radius: 4px;
	padding: 8px;
	overflow-x: auto;
}

.property-json pre {
	margin: 0;
	font-size: 11px;
	line-height: 1.3;
	color: #444;
	white-space: pre-wrap;
	word-break: break-word;
}

/* Binding-specific styles */
.binding-row {
	margin-bottom: 12px;
	padding: 8px;
	background: #f9f9f9;
	border-radius: 4px;
	border-left: 3px solid #007acc;
}

.binding-header {
	display: flex;
	align-items: center;
	margin-bottom: 4px;
	gap: 8px;
}

.binding-type {
	font-weight: bold;
	color: #007acc;
	text-transform: uppercase;
	font-size: 11px;
}

.binding-direction {
	font-size: 10px;
	color: #666;
	background: #e0e0e0;
	padding: 2px 6px;
	border-radius: 2px;
}

.binding-props {
	margin-top: 4px;
}

.binding-prop {
	margin-left: 8px;
}

.binding-row:last-child {
	margin-bottom: 0;
}

/* Simple dark mode */
.inspector-panel-dark {
	background: #2a2a2a;
	border-color: #555;
	color: #e0e0e0;
}

.inspector-panel-dark h4 {
	color: #aaa;
}

.inspector-panel-dark p {
	color: #aaa;
}

.inspector-panel-dark .property-value {
	color: #ddd;
}

.inspector-panel-dark .toggle-button {
	background: #555;
	border-color: #666;
	color: #e0e0e0;
}

.inspector-panel-dark .toggle-button:hover {
	background: #666;
}

.inspector-panel-dark .toggle-button:active {
	background: #777;
}

.inspector-panel-dark .property-json {
	background: #1e1e1e;
	border-color: #555;
}

.inspector-panel-dark .property-json pre {
	color: #ddd;
}

.inspector-panel-dark .binding-row {
	background: #333;
	border-left-color: #4da6ff;
}

.inspector-panel-dark .binding-type {
	color: #4da6ff;
}

.inspector-panel-dark .binding-direction {
	background: #555;
	color: #ccc;
}
```

--------

# Add a tool to the toolbar

Category: UI & theming

Keywords: 

Add your custom tool to the toolbar.

You can make an icon for your custom tool appear on tldraw's toolbar. To do this you will need to override the toolbar component, pass in a custom component for the keyboard shortcuts dialog, and pass in an asset url for your icon. This example shows how to do that. For more information on how to implement custom tools, check out the custom tool example.

## App.tsx

```tsx
import {
	DefaultKeyboardShortcutsDialog,
	DefaultKeyboardShortcutsDialogContent,
	DefaultToolbar,
	DefaultToolbarContent,
	TLComponents,
	TLUiAssetUrlOverrides,
	TLUiOverrides,
	Tldraw,
	TldrawUiMenuItem,
	useIsToolSelected,
	useTools,
} from 'tldraw'
import 'tldraw/tldraw.css'
import { StickerTool } from './sticker-tool-util'

// There's a guide at the bottom of this file!

// [1]
const uiOverrides: TLUiOverrides = {
	tools(editor, tools) {
		// Create a tool item in the ui's context.
		tools.sticker = {
			id: 'sticker',
			icon: 'heart-icon',
			label: 'Sticker',
			kbd: 's',
			onSelect: () => {
				editor.setCurrentTool('sticker')
			},
		}
		return tools
	},
}

// [2]
const components: TLComponents = {
	Toolbar: (props) => {
		const tools = useTools()
		const isStickerSelected = useIsToolSelected(tools['sticker'])
		return (
			<DefaultToolbar {...props}>
				<TldrawUiMenuItem {...tools['sticker']} isSelected={isStickerSelected} />
				<DefaultToolbarContent />
			</DefaultToolbar>
		)
	},
	KeyboardShortcutsDialog: (props) => {
		const tools = useTools()
		return (
			<DefaultKeyboardShortcutsDialog {...props}>
				<DefaultKeyboardShortcutsDialogContent />
				{/* Ideally, we'd interleave this into the tools group */}
				<TldrawUiMenuItem {...tools['sticker']} />
			</DefaultKeyboardShortcutsDialog>
		)
	},
}

// [3]
export const customAssetUrls: TLUiAssetUrlOverrides = {
	icons: {
		'heart-icon': '/heart-icon.svg',
	},
}

// [4]
const customTools = [StickerTool]

export default function ToolInToolbarExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// Pass in the array of custom tool classes
				tools={customTools}
				// Set the initial state to the sticker tool
				initialState="sticker"
				// Pass in our ui overrides
				overrides={uiOverrides}
				// pass in our custom components
				components={components}
				// pass in our custom asset urls
				assetUrls={customAssetUrls}
			/>
		</div>
	)
}

/* 
Introduction:
You can make an icon for your custom tool appear on tldraw's toolbar. To do this 
you will need to override the toolbar component, pass in a custom component for 
the keyboard shortcuts dialog, and pass in an asset url for your icon. This 
example shows how to do that. For more information on how to implement custom 
tools, check out the custom tool example.

[1]
First, we define the uiOverrides object. We can override the tools function to
add our custom tool to the ui's context. We can also override the toolbar function
to add our custom tool to the toolbar. We are going to splice it into the toolbar
so it appears in between the eraser and arrow tools.

[2]
Next, we want to override the default keyboard shortcuts dialog so that the 
shortcut for our custom tool appears in the dialog. We don't want to change its 
appearance very much, so we can use the DefaultKeyboardShortcutsDialog component 
and pass in the DefaultKeyboardShortcutsDialogContent component. With the useTools 
hook, we can get the tools from context and pass in the sticker tool to the keyboard 
shortcuts dialog. This will make the keyboard shortcut for the sticker tool appear 
in the dialog.

[3]
We need to make sure the editor knows where to find the icon for our custom tool.
We do this by defining the customAssetUrls object and passing in the asset url for
our icon.

[4]
Finally, we define the customTools array. This array contains the custom tool
class. We then pass the customTools array, the uiOverrides object, the
components object, and the customAssetUrls object to the Tldraw component as
props. This will make the icon for the custom tool appear on the toolbar.

*/
```

## sticker-tool-util.tsx

```tsx
import { StateNode, TLTextShape, toRichText } from 'tldraw'

// Check out the custom tool example for a more detailed explanation of the tool class.

const OFFSET = 12
export class StickerTool extends StateNode {
	static override id = 'sticker'

	override onEnter() {
		this.editor.setCursor({ type: 'cross', rotation: 0 })
	}

	override onPointerDown() {
		const { currentPagePoint } = this.editor.inputs
		this.editor.createShape<TLTextShape>({
			type: 'text',
			x: currentPagePoint.x - OFFSET,
			y: currentPagePoint.y - OFFSET,
			props: { richText: toRichText('â¤ï¸') },
		})
	}
}
```

--------

# Remove a tool from the toolbar

Category: UI & theming

Keywords: remove, tool

You can remove a tool from the user interface.

Using overrides, you can remove a tool from the toolbar, keyboard shortcuts, and other parts of the user interface. The tool will still be present in the application but not accessible to the user.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function RemoveToolExample() {
	return (
		<>
			<div className="tldraw__editor">
				<Tldraw
					overrides={{
						tools: (_editor, tools) => {
							// Remove the text tool
							delete tools.text
							return tools
						},
					}}
				/>
			</div>
		</>
	)
}
```

--------

# Change default colors

Category: UI & theming

Keywords: colours, styles, palette, style panel

Change the tldraw theme colors.

While there's currently no way to add or remove our colors from our default shapes' colors, this example shows how you can adjust the values for the default color styles.

Note that this will change the colors for ALL instances of tldraw. For example, if you run this example locally, and then open another example, the changes will be present there too until you reload!

## App.tsx

```tsx
import { DefaultColorThemePalette, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

// [1]
DefaultColorThemePalette.lightMode.black.solid = 'aqua'

export default function ChangingDefaultColorsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example" />
		</div>
	)
}

/*

[1]
The default color theme is exported from the tldraw library. You can 
modify it directly outside of the React lifecycle, so that your changes
are used when the component mounts.

Remember that you can't add or remove colors here yet. These colors are
used by our default shapes and we need to make sure that we don't end
up with a color that we can't handle, or else this could get propagated
to other users in a multiplayer session.

At the moment, if you want to create new colors, you will need to create 
your own shapes that understand those colors. We're working on making 
this easier!
*/
```

--------

# Change default styles

Category: UI & theming

Keywords: size, styles, default

Change the default value for a style prop.

Want to set the default value for a property to something other than it's built-in default? In this example we make the size style have small as its default calue.

## App.tsx

```tsx
import { DefaultSizeStyle, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

DefaultSizeStyle.setDefaultValue('s')

export default function ChangingDefaultStyleExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example" />
		</div>
	)
}
```

--------

# Changing menus

Category: UI & theming

Keywords: menu, context menu, toolbar, main menu, page menu, panel

Customize tldraw's menus, including the toolbar, main menu, context menu, page menu, and more.

You can use the `components` prop to override tldraw's default menus. You can provide a React component of your own, import our default component and edit it, or return null to hide it completely. This example demonstrates how to do this with every menu in tldraw, including the following:

- Toolbar
- Main menu
- Context menu
- Page menu
- Actions menu
- Debug menu
- Help menu
- Keyboard shortcuts dialog
- Navigation panel
- Quick actions panel
- Style panel
- Zoom menu

## App.tsx

```tsx
import {
	DefaultActionsMenu,
	DefaultActionsMenuContent,
	DefaultColorStyle,
	DefaultContextMenu,
	DefaultContextMenuContent,
	DefaultDebugMenu,
	DefaultDebugMenuContent,
	DefaultHelpMenu,
	DefaultHelpMenuContent,
	DefaultKeyboardShortcutsDialog,
	DefaultKeyboardShortcutsDialogContent,
	DefaultMainMenu,
	DefaultMainMenuContent,
	DefaultPageMenu,
	DefaultQuickActions,
	DefaultQuickActionsContent,
	DefaultStylePanel,
	DefaultStylePanelContent,
	DefaultToolbar,
	DefaultToolbarContent,
	DefaultZoomMenu,
	DefaultZoomMenuContent,
	TLComponents,
	Tldraw,
	TldrawUiButton,
	TldrawUiButtonLabel,
	TldrawUiMenuGroup,
	TldrawUiMenuItem,
	TLUiContextMenuProps,
	TLUiKeyboardShortcutsDialogProps,
	TLUiStylePanelProps,
	useEditor,
	useIsToolSelected,
	useRelevantStyles,
	useTools,
} from 'tldraw'
import 'tldraw/tldraw.css'

//[1]

function CustomActionsMenu() {
	return (
		<div style={{ backgroundColor: 'thistle' }}>
			<DefaultActionsMenu>
				<div style={{ backgroundColor: 'thistle' }}>
					<TldrawUiMenuItem
						id="like"
						label="Like my posts"
						icon="external-link"
						readonlyOk
						onSelect={() => {
							window.open('https://x.com/tldraw', '_blank')
						}}
					/>
				</div>
				<DefaultActionsMenuContent />
			</DefaultActionsMenu>
		</div>
	)
}
//[2]
function CustomContextMenu(props: TLUiContextMenuProps) {
	return (
		<DefaultContextMenu {...props}>
			<TldrawUiMenuGroup id="example">
				<div style={{ backgroundColor: 'thistle' }}>
					<TldrawUiMenuItem
						id="like"
						label="Like my posts"
						icon="external-link"
						readonlyOk
						onSelect={() => {
							window.open('https://x.com/tldraw', '_blank')
						}}
					/>
				</div>
			</TldrawUiMenuGroup>
			<DefaultContextMenuContent />
		</DefaultContextMenu>
	)
}
//[3]
function CustomDebugMenu() {
	return (
		<div style={{ backgroundColor: 'thistle' }}>
			<DefaultDebugMenu>
				<DefaultDebugMenuContent />
				<div style={{ backgroundColor: 'thistle' }}>
					<TldrawUiMenuGroup id="example">
						<TldrawUiMenuItem
							id="like"
							label="Like my posts"
							icon="external-link"
							readonlyOk
							onSelect={() => {
								window.open('https://x.com/tldraw', '_blank')
							}}
						/>
					</TldrawUiMenuGroup>
				</div>
			</DefaultDebugMenu>
		</div>
	)
}
//[4]
function CustomHelpMenu() {
	return (
		<DefaultHelpMenu>
			<div style={{ backgroundColor: 'thistle' }}>
				<TldrawUiMenuGroup id="example">
					<TldrawUiMenuItem
						id="like"
						label="Like my posts"
						icon="external-link"
						readonlyOk
						onSelect={() => {
							window.open('https://x.com/tldraw', '_blank')
						}}
					/>
				</TldrawUiMenuGroup>
			</div>
			<DefaultHelpMenuContent />
		</DefaultHelpMenu>
	)
}
//[5]
function CustomKeyboardShortcutsDialog(props: TLUiKeyboardShortcutsDialogProps) {
	return (
		<DefaultKeyboardShortcutsDialog {...props}>
			<div style={{ backgroundColor: 'thistle' }}>
				<TldrawUiMenuItem
					id="like-my-posts"
					label="Like my posts"
					icon="external-link"
					readonlyOk
					kbd=":)"
					onSelect={() => {
						window.open('https://x.com/tldraw', '_blank')
					}}
				/>
			</div>
			<DefaultKeyboardShortcutsDialogContent />
		</DefaultKeyboardShortcutsDialog>
	)
}
//[6]
function CustomMainMenu() {
	return (
		<DefaultMainMenu>
			<div style={{ backgroundColor: 'thistle' }}>
				<TldrawUiMenuGroup id="example">
					<TldrawUiMenuItem
						id="like"
						label="Like my posts"
						icon="external-link"
						readonlyOk
						onSelect={() => {
							window.open('https://x.com/tldraw', '_blank')
						}}
					/>
				</TldrawUiMenuGroup>
			</div>
			<DefaultMainMenuContent />
		</DefaultMainMenu>
	)
}
//[7]
function CustomNavigationPanel() {
	return <div style={{ backgroundColor: 'thistle', padding: '14px' }}>here you are</div>
}
//[8]
function CustomPageMenu() {
	return (
		<div style={{ transform: 'rotate(3.14rad)', backgroundColor: 'thistle' }}>
			<DefaultPageMenu />
		</div>
	)
}
//[9]
function CustomQuickActions() {
	return (
		<DefaultQuickActions>
			<DefaultQuickActionsContent />
			<div style={{ backgroundColor: 'thistle' }}>
				<TldrawUiMenuItem id="code" icon="code" onSelect={() => window.alert('code')} />
			</div>
		</DefaultQuickActions>
	)
}
//[10]
function CustomStylePanel(props: TLUiStylePanelProps) {
	const editor = useEditor()

	// Styles are complex, sorry. Check our DefaultStylePanel for an example.

	const styles = useRelevantStyles()

	return (
		<DefaultStylePanel {...props}>
			<div style={{ backgroundColor: 'thistle' }}>
				<TldrawUiButton
					type="menu"
					onClick={() => {
						editor.setStyleForSelectedShapes(DefaultColorStyle, 'red')
					}}
				>
					<TldrawUiButtonLabel>Red</TldrawUiButtonLabel>
				</TldrawUiButton>
			</div>
			<div style={{ backgroundColor: 'thistle' }}>
				<TldrawUiButton
					type="menu"
					onClick={() => {
						editor.setStyleForSelectedShapes(DefaultColorStyle, 'green')
					}}
				>
					<TldrawUiButtonLabel>Green</TldrawUiButtonLabel>
				</TldrawUiButton>
			</div>
			<DefaultStylePanelContent styles={styles} />
		</DefaultStylePanel>
	)
}
//[11]
function CustomToolbar() {
	const editor = useEditor()
	const tools = useTools()
	const isScreenshotSelected = useIsToolSelected(tools['rhombus-2'])
	return (
		<div>
			<DefaultToolbar>
				<TldrawUiMenuItem {...tools['rhombus-2']} isSelected={isScreenshotSelected} />

				<DefaultToolbarContent />
				<button
					onClick={() => {
						editor.selectAll().deleteShapes(editor.getSelectedShapeIds())
					}}
					title="delete all"
				>
					ðŸ§¨
				</button>
			</DefaultToolbar>
		</div>
	)
}
//[12]
function CustomZoomMenu() {
	return (
		<DefaultZoomMenu>
			<div style={{ backgroundColor: 'thistle' }}>
				<TldrawUiMenuGroup id="example">
					<TldrawUiMenuItem
						id="like"
						label="Like my posts"
						icon="external-link"
						readonlyOk
						onSelect={() => {
							window.open('https://x.com/tldraw', '_blank')
						}}
					/>
				</TldrawUiMenuGroup>
			</div>
			<DefaultZoomMenuContent />
		</DefaultZoomMenu>
	)
}
const components: TLComponents = {
	ActionsMenu: CustomActionsMenu,
	ContextMenu: CustomContextMenu,
	DebugMenu: CustomDebugMenu,
	HelpMenu: CustomHelpMenu,
	KeyboardShortcutsDialog: CustomKeyboardShortcutsDialog,
	MainMenu: CustomMainMenu,
	NavigationPanel: CustomNavigationPanel,
	PageMenu: CustomPageMenu,
	QuickActions: CustomQuickActions,
	StylePanel: CustomStylePanel,
	Toolbar: CustomToolbar,
	ZoomMenu: CustomZoomMenu,
}

export default function CustomActionsMenuExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw components={components} />
		</div>
	)
}

/*
You can use the `components` prop to override tldraw's default menus. 
You can provide a React component of your own, import our default 
component and edit it, or return null to hide it completely. This 
example demonstrates how to do this with every menu in tldraw.

[1]
	The actions menu is a dropdown menu that can be found in the 
	top-left of the tldraw component, or just above the toolbar on 
	smaller screens. It contains actions related to editing shapes 
	such as grouping, rotating or changing shape order. 

[2]
	Create some shapes, select them and right click the selection to 
	see the custom context menu.

[3]
	The debug menu contains helpful menu items for debugging the tldraw 
	component. To show the debug menu, turn on debug mode in the 
	preferences.
[4]
	The help menu contains menu items to change the language of the
	application, and to open the keyboard shortcuts dialog.


[5]
	The keyboard shortcuts dialog is a modal that shows all the 
	keyboard shortcuts available in tldraw. You can open it via the help
	menu.

[6]
	The main menu contains important submenus: Edit, Shape, Preferences etc. 
	To open the main menu, click the hamburger icon in the top left corner 
	of the tldraw component.

[7]
	The navigation panel is in the bottom left of the tldraw component at 
	larger breakpoints. It contains zoom controls and a mini map.

[8]
	The page menu contains options for creating and editing pages. To open 
	the page menu, click the page name in the top left of the tldraw component.

[9]
	The quick actions menu is a dropdown menu that appears in the Main Menu,
	or above the toolbar on smaller screens.

[10]
	The style panel is a panel that appears on the right side of the tldraw
	component. It contains options to change the style of shapes, such as
	color, stroke width, and opacity.

[11]
	The toolbar contains tools to create shapes, select shapes, and more.

[12]
	The zoom menu is in the bottom left of the tldraw component, the button 
	to open it is labeled with a percentage indicating the editor's current 
	zoom level.

 */
```

--------

# Hide UI components

Category: UI & theming

Keywords: hide, ui, overrides

Hide individual UI components.

UI components can be hidden by providing `null` as their value within `components`. In this example, all configurable UI components are hidden.

## App.tsx

```tsx
import { TLUiComponents, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// The type here is include only to ensure this example contains all possible ui components,
const components: Required<TLUiComponents> = {
	ContextMenu: null,
	ActionsMenu: null,
	HelpMenu: null,
	ZoomMenu: null,
	MainMenu: null,
	Minimap: null,
	StylePanel: null,
	PageMenu: null,
	NavigationPanel: null,
	Toolbar: null,
	KeyboardShortcutsDialog: null,
	QuickActions: null,
	HelperButtons: null,
	DebugPanel: null,
	DebugMenu: null,
	SharePanel: null,
	MenuPanel: null,
	TopPanel: null,
	CursorChatBubble: null,
	RichTextToolbar: null,
	ImageToolbar: null,
	VideoToolbar: null,
	Dialogs: null,
	Toasts: null,
	A11y: null,
}

export default function UiComponentsHiddenExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw components={components} />
		</div>
	)
}
```

--------

# Things on the canvas

Category: UI & theming

Keywords: in front of the canvas, scale, zoom, ui

Add custom components to the canvas.

This example shows how to add custom components to the canvas.

Components can either float on top of the canvas unaffected by the camera, or be a part of the canvas itself.

## App.tsx

```tsx
import { useState } from 'react'
import { stopEventPropagation, Tldraw, TLEditorComponents, track, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

// [1]
function MyComponent() {
	const [state, setState] = useState(0)

	return (
		<>
			<div
				style={{
					position: 'absolute',
					top: 50,
					left: 50,
					width: 200,
					padding: 12,
					borderRadius: 8,
					backgroundColor: 'goldenrod',
					zIndex: 0,
					userSelect: 'unset',
					boxShadow: '0 0 0 1px rgba(0,0,0,0.1), 0 4px 8px rgba(0,0,0,0.1)',
				}}
				onPointerDown={stopEventPropagation}
				onPointerMove={stopEventPropagation}
			>
				<p>The count is {state}! </p>
				<button onClick={() => setState((s) => s - 1)}>-1</button>
				<p>These components are on the canvas. They will scale with camera zoom like shapes.</p>
			</div>
			<div
				style={{
					position: 'absolute',
					top: 210,
					left: 150,
					width: 200,
					padding: 12,
					borderRadius: 8,
					backgroundColor: 'pink',
					zIndex: 99999999,
					userSelect: 'unset',
					boxShadow: '0 0 0 1px rgba(0,0,0,0.1), 0 4px 8px rgba(0,0,0,0.1)',
				}}
				onPointerDown={stopEventPropagation}
				onPointerMove={stopEventPropagation}
			>
				<p>The count is {state}! </p>
				<button onClick={() => setState((s) => s + 1)}>+1</button>
				<p>Create and select a shape to see the in front of the canvas component</p>
			</div>
		</>
	)
}

//[2]
const MyComponentInFront = track(() => {
	const editor = useEditor()
	const selectionRotatedPageBounds = editor.getSelectionRotatedPageBounds()
	if (!selectionRotatedPageBounds) return null

	const pageCoordinates = editor.pageToViewport(selectionRotatedPageBounds.point)

	return (
		<div
			style={{
				position: 'absolute',
				top: Math.max(64, pageCoordinates.y - 64),
				left: Math.max(64, pageCoordinates.x),
				borderRadius: 8,
				paddingLeft: 10,
				paddingRight: 10,
				background: '#efefef',
				boxShadow: '0 0 0 1px rgba(0,0,0,0.1), 0 4px 8px rgba(0,0,0,0.1)',
			}}
		>
			<p>This wonâ€™t scale with zoom.</p>
		</div>
	)
})

// [3]
const components: TLEditorComponents = {
	OnTheCanvas: MyComponent,
	InFrontOfTheCanvas: MyComponentInFront,
}

// [4]
export default function OnTheCanvasExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="things-on-the-canvas-example" components={components} />
		</div>
	)
}

/* 
This example shows how you can use the onTheCanvas and inFrontOfTheCanvas components.
onTheCanvas components will behave similarly to shapes, they will scale with the zoom
and move when the page is panned. inFrontOfTheCanvas components don't scale with the
zoom, but still move when the page is panned. 

For another example that shows how to customize components, check out the custom
components example.

To have a component that ignores the camera entirely, you should check out the custom 
UI example.


[1]
This is our onTheCanvas component. We also stop event propagation on the pointer events 
so that we don't accidentally select shapes when interacting with the component.

[2]
This is our inFrontOfTheCanvas component. We want to render this next to a selected shape,
so we need to make sure it's reactive to changes in the editor. We use the track function
to make sure the component is re-rendered whenever the selection changes. Check out the
signals example for more info: https://tldraw.dev/examples/signals

Using the editor instance we can get the bounds of the selection box and convert them to
screen coordinates. We then render the component at those coordinates.


[3]
This is where we define the object that will be passed to the Tldraw component prop. 

[4]
This is where we render the Tldraw component. Let's pass the components object to the 
components prop.

*/
```

--------

# Toasts and dialogs

Category: UI & theming

Keywords: ui, components, dialogs, toasts

Add, remove and clear toasts and dialogs in your app using the `useToasts` and `useDialogs` hooks.

To control toasts and dialogs your app, you can use the `useToasts` and `useDialogs` hooks.
These hooks give you access to functions which allow you to add, remove and clear toasts
and dialogs.

Dialogs are especially customisable, allowing you to pass in a custom component to render
as the dialog content. Alternatively, you can use the `ExampleDialog` component which is
provided by the library.

## App.tsx

```tsx
import {
	TLComponents,
	Tldraw,
	TldrawUiButton,
	TldrawUiButtonLabel,
	TldrawUiDialogBody,
	TldrawUiDialogCloseButton,
	TldrawUiDialogFooter,
	TldrawUiDialogHeader,
	TldrawUiDialogTitle,
	useDialogs,
	useToasts,
} from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file

// [1]
function MyDialog({ onClose }: { onClose(): void }) {
	return (
		<>
			<TldrawUiDialogHeader>
				<TldrawUiDialogTitle>Title</TldrawUiDialogTitle>
				<TldrawUiDialogCloseButton />
			</TldrawUiDialogHeader>
			<TldrawUiDialogBody style={{ maxWidth: 350 }}>Description...</TldrawUiDialogBody>
			<TldrawUiDialogFooter className="tlui-dialog__footer__actions">
				<TldrawUiButton type="normal" onClick={onClose}>
					<TldrawUiButtonLabel>Cancel</TldrawUiButtonLabel>
				</TldrawUiButton>
				<TldrawUiButton type="primary" onClick={onClose}>
					<TldrawUiButtonLabel>Continue</TldrawUiButtonLabel>
				</TldrawUiButton>
			</TldrawUiDialogFooter>
		</>
	)
}

// [2]
function MySimpleDialog({ onClose }: { onClose(): void }) {
	return (
		<div style={{ padding: 16 }}>
			<h2>Title</h2>
			<p>Description...</p>
			<button onClick={onClose}>Okay</button>
		</div>
	)
}

const CustomSharePanel = () => {
	const { addToast } = useToasts()
	const { addDialog } = useDialogs()

	return (
		<div style={{ padding: 16, gap: 16, display: 'flex', pointerEvents: 'all' }}>
			<button
				onClick={() => {
					addToast({ title: 'Hello world!', severity: 'success' })
				}}
			>
				Show toast
			</button>
			<button
				onClick={() => {
					addDialog({
						component: MyDialog,
						onClose() {
							// You can do something after the dialog is closed
							void null
						},
					})
				}}
			>
				Show dialog
			</button>
			<button
				onClick={() => {
					addDialog({
						component: MySimpleDialog,
						onClose() {
							// You can do something after the dialog is closed
							void null
						},
					})
				}}
			>
				Show simple dialog
			</button>
		</div>
	)
}

const components: TLComponents = {
	SharePanel: CustomSharePanel,
}

export default function ToastsDialogsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw components={components} persistenceKey="example" />
		</div>
	)
}

/* 

To control toasts and dialogs your app, you can use the `useToasts` and `useDialogs` hooks. 
These hooks give you access to functions which allow you to add, remove and clear toasts 
and dialogs.

Dialogs are especially customisable, allowing you to pass in a custom component to render
as the dialog content. Alternatively, you can use the `ExampleDialog` component which is
provided by the library.

[1]
The tldraw library provides a set of components that you can use to build your dialogs. 
The `onClose` function passed to the dialog component runs when the dialog closes or 
is dismissed, but you can also call it from buttons to close the dialog.

[2]
...or you can build your own dialog component!
*/
```

--------

# UI zones

Category: UI & theming

Keywords: top zone, share zone

Inject custom components into tldraw's empty areas.

Our default UI has two empty areas that you can fill - the `TopPanel` (in the top-center of the screen) and `SharePanel` (in the top right).

You can set these zones to any React component you want.

## App.tsx

```tsx
import { TLComponents, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

const components: TLComponents = {
	SharePanel: CustomShareZone,
	TopPanel: CustomTopZone,
}

// [1]
export default function Example() {
	return (
		<div className="tldraw__editor">
			<Tldraw components={components} />
		</div>
	)
}

// [2]
function CustomTopZone() {
	return (
		<div
			style={{
				backgroundColor: 'thistle',
				width: '100%',
				textAlign: 'center',
				padding: '2px',
				minWidth: '80px',
			}}
		>
			<p>Top Zone</p>
		</div>
	)
}

// [3]
function CustomShareZone() {
	return (
		<div
			style={{
				backgroundColor: 'thistle',
				width: '100%',
				textAlign: 'center',
				minWidth: '80px',
			}}
		>
			<p>Share Zone</p>
		</div>
	)
}

/* 
This example shows how to pass in a custom component to the share panel and top panel.
The share panel is in the top right corner above the style menu, the top panel is in 
the top center.

[1]
We pass in our custom components to the Tldraw topZone and shareZone props.

[2]
This is the component that will be rendered in the top zone.

[3]
This is the component that will be rendered in the share zone.
*/
```

--------

# Hide the entire UI

Category: UI & theming

Keywords: 

Hide tldraw's UI with the `hideUi` prop.

Hide tldraw's UI with the `hideUi` prop.

This can be useful if you want a bare-bones editor, or if you want to build your own UI.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function HideUiExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="hide-ui-example" hideUi />
		</div>
	)
}

/* 
This example shows how to hide the UI of the editor. Simply pass the hideUi prop
to the Tldraw component. This is useful if you want to build your own UI around
the editor. See the custom ui example if you need help building your own UI.
*/
```

--------

# Replace the entire UI

Category: UI & theming

Keywords: hide, ui, event listener

Replace tldraw's UI with your own.

If you want, you can replace tldraw's entire UI and start your own from scratch.

This example shows how you might begin doing that, with keyboard shortcuts and buttons for selecting tools.

## App.tsx

```tsx
import { useEffect } from 'react'
import { Tldraw, track, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'
import './custom-ui.css'

// There's a guide at the bottom of this file!

// [1]
export default function CustomUiExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw hideUi>
				<CustomUi />
			</Tldraw>
		</div>
	)
}

// [2]
const CustomUi = track(() => {
	const editor = useEditor()

	useEffect(() => {
		const handleKeyUp = (e: KeyboardEvent) => {
			switch (e.key) {
				case 'Delete':
				case 'Backspace': {
					editor.deleteShapes(editor.getSelectedShapeIds())
					break
				}
				case 'v': {
					editor.setCurrentTool('select')
					break
				}
				case 'e': {
					editor.setCurrentTool('eraser')
					break
				}
				case 'x':
				case 'p':
				case 'b':
				case 'd': {
					editor.setCurrentTool('draw')
					break
				}
			}
		}

		window.addEventListener('keyup', handleKeyUp)
		return () => {
			window.removeEventListener('keyup', handleKeyUp)
		}
	})

	return (
		<div className="custom-layout">
			<div className="custom-toolbar">
				<button
					className="custom-button"
					data-isactive={editor.getCurrentToolId() === 'select'}
					onClick={() => editor.setCurrentTool('select')}
				>
					Select
				</button>
				<button
					className="custom-button"
					data-isactive={editor.getCurrentToolId() === 'draw'}
					onClick={() => editor.setCurrentTool('draw')}
				>
					Pencil
				</button>
				<button
					className="custom-button"
					data-isactive={editor.getCurrentToolId() === 'eraser'}
					onClick={() => editor.setCurrentTool('eraser')}
				>
					Eraser
				</button>
			</div>
		</div>
	)
})

/* 
This example shows how to create your own custom ui for the editor.

[1]
We render the Tldraw component with the `hideUi` prop. This will hide the default
toolbar, style menu and pages menu. We also render our custom ui component inside the 
Tldraw component. This gives us access to the editor instance via React context.

The context menu isn't hidden by the `hideUi` prop, if you want to hide it you can
render the parts that make up the Tldraw component separately and omit the context
menu. Check out the exploded example to see how to do this.

[2]
We use the `track` function to wrap our component. This makes our component reactive- it will
re-render when the signals it is tracking change. Check out the signals example for more info:
https://tldraw.dev/examples/signals

We gain access to the editor instance via the `useEditor` hook. We use the `useEffect` hook
to add event listeners for keyboard shortcuts. We use editor methods to change the current
tool and delete shapes.

*/
```

## custom-ui.css

```css
.custom-layout {
	position: absolute;
	inset: 0px;
	z-index: 300;
	pointer-events: none;
}

.custom-toolbar {
	position: absolute;
	top: 0px;
	left: 0px;
	width: 100%;
	display: flex;
	align-items: center;
	justify-content: center;
	padding: 8px;
	gap: 8px;
}

.custom-button {
	pointer-events: all;
	padding: 4px 12px;
	background: white;
	border: 1px solid black;
	border-radius: 64px;
}

.custom-button[data-isactive='true'] {
	background-color: black;
	color: white;
}
```

--------

# Contextual toolbar

Category: UI & theming

Keywords: in front of the canvas, contextual

Show a contextual toolbar above shapes when they are selected.

This is an example of how to show a contextual toolbar which appears on top of the selected shapes. It is displayed above the canvas, but below other UI elements.

Select shapes of different types and adjust the size of the shapes - this works just like adjusting the size from the Style panel on the right side.

## App.tsx

```tsx
import {
	Box,
	DefaultSizeStyle,
	Tldraw,
	TldrawUiButton,
	TldrawUiButtonIcon,
	TldrawUiContextualToolbar,
	TLEditorComponents,
	TLEditorSnapshot,
	track,
	useEditor,
} from 'tldraw'
import 'tldraw/tldraw.css'
import _jsonSnapshot from './snapshot.json'

// There's a guide at the bottom of this file!

const jsonSnapshot = _jsonSnapshot as any as TLEditorSnapshot

const SIZES = [
	{ value: 's', icon: 'size-small' },
	{ value: 'm', icon: 'size-medium' },
	{ value: 'l', icon: 'size-large' },
	{ value: 'xl', icon: 'size-extra-large' },
] as const

// [1]
const ContextualToolbarComponent = track(() => {
	const editor = useEditor()
	const showToolbar = editor.isIn('select.idle')

	// [2]
	const size = editor.getSharedStyles().get(DefaultSizeStyle)
	if (!size || !showToolbar) return null
	const currentSize = size.type === 'shared' ? size.value : undefined

	// [3]
	const getSelectionBounds = () => {
		const fullBounds = editor.getSelectionRotatedScreenBounds()
		if (!fullBounds) return undefined
		return new Box(fullBounds.x, fullBounds.y, fullBounds.width, 0)
	}

	return (
		<TldrawUiContextualToolbar getSelectionBounds={getSelectionBounds} label="Sizes">
			{SIZES.map(({ value, icon }) => {
				return (
					<TldrawUiButton
						key={value}
						title={value}
						type="icon"
						isActive={value === currentSize}
						onClick={() => editor.setStyleForSelectedShapes(DefaultSizeStyle, value)}
					>
						<TldrawUiButtonIcon small icon={icon} />
					</TldrawUiButton>
				)
			})}
		</TldrawUiContextualToolbar>
	)
})

const components: TLEditorComponents = {
	InFrontOfTheCanvas: ContextualToolbarComponent,
}

export default function ContextualToolbar() {
	return (
		<div className="tldraw__editor">
			<Tldraw components={components} snapshot={jsonSnapshot} />
		</div>
	)
}

/*
This example shows how you can use our contextual toolbar primitive that can show up when you
select a shape. It's using the `InFrontOfTheCanvas` component to render the toolbar. This allows us to render
the toolbar on top of the shapes, but behind the existing UI.
[1]
This is our context toolbar. It's positioned absolutely on top of the selected shapes.
[2]
Different shapes support different style properties and this is how we get the styles that are 
supported by all selected shapes. If none of the selected shapes supported the `DefaultSizeStyle`
we wouldn't show the toolbar at all.
We also get the current value of the size property. If all the shapes have the same size then the
type of the size property is `shared`. This will allow us to show the currently selected size in the
toolbar. If the shapes have different sizes then the type of the size property is `mixed` and none
of the sizes will be highlighted.
[3]
We pass in getSelectionBounds so that the toolbar knows where to position itself. You can use the
selection bounds of the current shapes or some other logic.
*/
```

--------

# Custom canvas components

Category: UI & theming

Keywords: custom, Background, SvgDefs, Brush, ZoomBrush, ShapeIndicator, Cursor, Canvas, CollaboratorBrush, CollaboratorCursor, CollaboratorHint, CollaboratorShapeIndicator, Grid, Scribble, CollaboratorScribble, SnapIndicator, Handles, Handle, Spinner, SelectionForeground, SelectionBackground, OnTheCanvas, InFrontOfTheCanvas, LoadingScreen

Replace tldraw's on-canvas UI with your own.

tldraw's on-canvas UI is built from replaceable React components.

This example shows how to replace these default components with your own. Try dragging to select or using the eraser tool to see the custom components in this example.

## App.tsx

```tsx
import { useRef } from 'react'
import { Tldraw, TLEditorComponents, toDomPrecision, useTransform } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

const components: TLEditorComponents = {
	Brush: function MyBrush({ brush }) {
		const rSvg = useRef<SVGSVGElement>(null)

		useTransform(rSvg, brush.x, brush.y)

		const w = toDomPrecision(Math.max(1, brush.w))
		const h = toDomPrecision(Math.max(1, brush.h))

		return (
			<svg ref={rSvg} className="tl-overlays__item">
				<rect className="tl-brush" stroke="red" fill="none" width={w} height={h} />
			</svg>
		)
	},
	Scribble: ({ scribble, opacity, color }) => {
		return (
			<svg className="tl-overlays__item">
				<polyline
					points={scribble.points.map((p) => `${p.x},${p.y}`).join(' ')}
					stroke={color ?? 'black'}
					opacity={opacity ?? '1'}
					fill="none"
				/>
			</svg>
		)
	},
	SnapIndicator: null,
}

export default function CustomComponentsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="custom-components-example" components={components} />
		</div>
	)
}

/* 
This example shows how to change the default components that tldraw uses on the canvas via the `components` prop.
Components include things like the background, the grid, handles, spinners etc. In this case we change the box 
that appears when drag-selecting shapes, and the scribble left behind when using the eraser and laser pointer.

*/
```

--------

# Custom error fallback

Category: UI & theming

Keywords: shape

Customize the error fallback that appears when a shape throws an error.

When something goes wrong in a shape, it won't crash the whole editor. An error fallback gets shown instead, which you can customize by overriding the `ShapeErrorFallback` component in the `components` prop.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import { ErrorShape, ErrorShapeUtil } from './ErrorShape'

// There's a guide at the bottom of this file!

// [1]
const shapes = [ErrorShapeUtil]

export default function ErrorBoundaryExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				shapeUtils={shapes}
				components={{
					// [2]
					ShapeErrorFallback: ({ error }) => <div>Shape error! {String(error)}</div>,
				}}
				onMount={(editor) => {
					// [3]
					editor.createShape<ErrorShape>({ type: 'error' })
				}}
			/>
		</div>
	)
}

/* 
This example shows how to customize the error fallback that appears when a shape throws an error. We
simulate this scenario by creating a shape that always throws an error when it renders.

[1] 
This is the custom shape that always throws an error when it renders. Check out ErrorShape.ts to see
how it works.

[2]
Pass in the custom error fallback component.

[3]
When the app starts, create our error shape so that we can see the custom error fallback. 

*/
```

## ErrorShape.ts

```ts
import { BaseBoxShapeUtil, TLBaseShape } from 'tldraw'

export type ErrorShape = TLBaseShape<'error', { w: number; h: number }>

export class ErrorShapeUtil extends BaseBoxShapeUtil<ErrorShape> {
	static override type = 'error' as const
	getDefaultProps() {
		return { w: 100, h: 100 }
	}
	component() {
		throw new Error('Error!')
	}
	indicator() {
		throw new Error('Error!')
	}
}
```

--------

# Custom grid

Category: UI & theming

Keywords: grid, background, ui, layout

Draw a custom grid on the canvas.

This example shows how to draw a custom grid on the canvas. It uses a 2d canvas context to draw major and minor grid lines.

## App.tsx

```tsx
import { useLayoutEffect, useRef } from 'react'
import { TLComponents, Tldraw, approximately, useEditor, useIsDarkMode, useValue } from 'tldraw'
import 'tldraw/tldraw.css'

/**
 * There's a guide at the bottom of this file!
 */

const components: TLComponents = {
	// [1]
	Grid: ({ size, ...camera }) => {
		const editor = useEditor()

		// [2]
		const screenBounds = useValue('screenBounds', () => editor.getViewportScreenBounds(), [])
		const devicePixelRatio = useValue('dpr', () => editor.getInstanceState().devicePixelRatio, [])
		const isDarkMode = useIsDarkMode()

		const canvas = useRef<HTMLCanvasElement>(null)

		useLayoutEffect(() => {
			if (!canvas.current) return
			// [3]
			const canvasW = screenBounds.w * devicePixelRatio
			const canvasH = screenBounds.h * devicePixelRatio
			canvas.current.width = canvasW
			canvas.current.height = canvasH

			const ctx = canvas.current?.getContext('2d')
			if (!ctx) return

			// [4]
			ctx.clearRect(0, 0, canvasW, canvasH)

			// [5]
			const pageViewportBounds = editor.getViewportPageBounds()

			const startPageX = Math.ceil(pageViewportBounds.minX / size) * size
			const startPageY = Math.ceil(pageViewportBounds.minY / size) * size
			const endPageX = Math.floor(pageViewportBounds.maxX / size) * size
			const endPageY = Math.floor(pageViewportBounds.maxY / size) * size
			const numRows = Math.round((endPageY - startPageY) / size)
			const numCols = Math.round((endPageX - startPageX) / size)

			ctx.strokeStyle = isDarkMode ? '#555' : '#BBB'

			// [6]
			for (let row = 0; row <= numRows; row++) {
				const pageY = startPageY + row * size
				// convert the page-space Y offset into our canvas' coordinate space
				const canvasY = (pageY + camera.y) * camera.z * devicePixelRatio
				const isMajorLine = approximately(pageY % (size * 10), 0)
				drawLine(ctx, 0, canvasY, canvasW, canvasY, isMajorLine ? 3 : 1)
			}
			for (let col = 0; col <= numCols; col++) {
				const pageX = startPageX + col * size
				// convert the page-space X offset into our canvas' coordinate space
				const canvasX = (pageX + camera.x) * camera.z * devicePixelRatio
				const isMajorLine = approximately(pageX % (size * 10), 0)
				drawLine(ctx, canvasX, 0, canvasX, canvasH, isMajorLine ? 3 : 1)
			}
		}, [screenBounds, camera, size, devicePixelRatio, editor, isDarkMode])

		// [7]
		return <canvas className="tl-grid" ref={canvas} />
	},
}

export default function CustomGridExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="custom-grid-example"
				components={components}
				onMount={(e) => {
					e.updateInstanceState({ isGridMode: true })
				}}
			/>
		</div>
	)
}

function drawLine(
	ctx: CanvasRenderingContext2D,
	x1: number,
	y1: number,
	x2: number,
	y2: number,
	width: number
) {
	ctx.beginPath()
	ctx.moveTo(x1, y1)
	ctx.lineTo(x2, y2)
	ctx.lineWidth = width
	ctx.stroke()
}

/**
 * This example demonstrates how to draw a custom grid component using a 2d canvas.
 *
 * 1. To add a custom grid you must override this Grid component. It is passed props for the camera position, along with the size of the grid in page space.
 * 2. In addition to updating when the camera moves, we want the grid to rerender if the screen bounds change, or if the devicePixelRatio changes, or if the theme changes.
 * 3. To avoid pixelation we want to render at the device's actual resolution, so we need to set the canvas size in terms of the devicePixelRatio.
 * 4. Start by clearing the canvas and making it transparent.
 * 5. Calculate the start and end offsets for the grid, in page space.
 * 6. Draw the grid lines. We draw major lines every 10 grid units.
 * 7. The 'tl-grid' class is important for correct rendering and interaction handling.
 */
```

--------

# Drag and drop tray

Category: UI & theming

Keywords: 

Create a drag and drop tray to create shapes on the canvas.

This example shows how to create a drag and drop tray with items that can be dragged onto the canvas to create shapes.

The tray is positioned as a fixed UI element using the `InFrontOfTheCanvas` component, and includes interactive items that can be dragged to create shapes on the canvas. The interaction can be cancelled by pressing the Escape key.

## App.tsx

```tsx
import { useMemo, useRef } from 'react'
import {
	Box,
	TLEditorComponents,
	Tldraw,
	Vec,
	useAtom,
	useEditor,
	useQuickReactor,
	useValue,
} from 'tldraw'
import 'tldraw/tldraw.css'
import './drag-and-drop-tray.css'
import { TRAY_ITEMS, TrayItem } from './trayitems'

// There's a guide at the bottom of this file!

// [1]
type DragState =
	| {
			name: 'idle'
	  }
	| {
			name: 'pointing_item'
			item: TrayItem
			startPosition: Vec
	  }
	| {
			name: 'dragging'
			item: TrayItem
			currentPosition: Vec
	  }

// [2]
const DragAndDropTray = () => {
	const rTrayContainer = useRef<HTMLDivElement>(null)
	const rDraggingImage = useRef<HTMLDivElement>(null)

	const editor = useEditor()

	// [3]
	const dragState = useAtom<DragState>('dragState', () => ({
		name: 'idle',
	}))

	// [4]
	const { handlePointerUp, handlePointerDown } = useMemo(() => {
		let target: HTMLDivElement | null = null

		function handlePointerMove(e: PointerEvent) {
			const current = dragState.get()
			const screenPoint = new Vec(e.clientX, e.clientY)

			switch (current.name) {
				case 'idle': {
					break
				}
				case 'pointing_item': {
					const dist = Vec.Dist(screenPoint, current.startPosition)
					if (dist > 10) {
						// [a]
						dragState.set({
							name: 'dragging',
							item: current.item,
							currentPosition: screenPoint,
						})
					}
					break
				}
				case 'dragging': {
					// [b]
					dragState.set({
						...current,
						currentPosition: screenPoint,
					})
					break
				}
			}
		}

		function handlePointerUp(e: React.PointerEvent) {
			const current = dragState.get()

			target = e.currentTarget as HTMLDivElement
			target.releasePointerCapture(e.pointerId)

			switch (current.name) {
				case 'idle': {
					break
				}
				case 'pointing_item': {
					dragState.set({
						name: 'idle',
					})
					break
				}
				case 'dragging': {
					// [c]
					const screenPoint = new Vec(e.clientX, e.clientY)
					const pagePoint = editor.screenToPage(screenPoint)

					editor.markHistoryStoppingPoint('create shape from tray')

					editor.createShape({
						type: current.item.shapeType,
						x: pagePoint.x - 50, // center on cursor at 100x100
						y: pagePoint.y - 50,
						props: current.item.shapeProps,
					})

					dragState.set({
						name: 'idle',
					})

					break
				}
			}

			removeEventListeners()
		}

		function handlePointerDown(e: React.PointerEvent) {
			e.preventDefault()
			target = e.currentTarget as HTMLDivElement
			target.setPointerCapture(e.pointerId)

			const itemIndex = target.dataset.drag_item_index!
			const item = TRAY_ITEMS[+itemIndex]

			if (!item) return

			const startPosition = new Vec(e.clientX, e.clientY)

			// [d]
			dragState.set({
				name: 'pointing_item',
				item,
				startPosition,
			})

			target.addEventListener('pointermove', handlePointerMove)
			document.addEventListener('keydown', handleKeyDown)
		}

		function handleKeyDown(e: KeyboardEvent) {
			const current = dragState.get()
			if (e.key === 'Escape' && current.name === 'dragging') {
				removeEventListeners()
			}
		}

		function removeEventListeners() {
			if (target) {
				target.removeEventListener('pointermove', handlePointerMove)
				document.removeEventListener('keydown', handleKeyDown)
			}

			dragState.set({
				name: 'idle',
			})
		}

		return {
			handlePointerDown,
			handlePointerUp,
		}
	}, [dragState, editor])

	const state = useValue('dragState', () => dragState.get(), [dragState])

	// [5]
	useQuickReactor(
		'drag-image-style',
		() => {
			const current = dragState.get()
			const imageRef = rDraggingImage.current
			const trayContainerRef = rTrayContainer.current
			if (!imageRef || !trayContainerRef) return

			switch (current.name) {
				case 'idle':
				case 'pointing_item': {
					imageRef.style.display = 'none'
					break
				}
				case 'dragging': {
					const trayContainerRect = trayContainerRef.getBoundingClientRect()
					const box = new Box(
						trayContainerRect.x,
						trayContainerRect.y,
						trayContainerRect.width,
						trayContainerRect.height
					)
					const viewportScreenBounds = editor.getViewportScreenBounds()
					const isInside = Box.ContainsPoint(box, current.currentPosition)
					if (isInside) {
						imageRef.style.display = 'none'
					} else {
						imageRef.style.display = 'block'
						imageRef.style.position = 'absolute'
						imageRef.style.pointerEvents = 'none'
						imageRef.style.left = '0px'
						imageRef.style.top = '0px'
						imageRef.style.transform = `translate(${current.currentPosition.x - viewportScreenBounds.x - 25}px, ${current.currentPosition.y - viewportScreenBounds.y - 25}px)`
						imageRef.style.width = '50px'
						imageRef.style.height = '50px'
						imageRef.style.fontSize = '40px'
						imageRef.style.display = 'flex'
						imageRef.style.alignItems = 'center'
					}
				}
			}
		},
		[dragState]
	)

	return (
		<>
			{/* [6] */}
			<div className="drag-tray" ref={rTrayContainer}>
				<div className="drag-tray-items">
					{TRAY_ITEMS.map((item, index) => (
						<div
							key={item.id}
							className="drag-tray-item"
							data-drag_item_index={index}
							onPointerDown={handlePointerDown}
							onPointerUp={handlePointerUp}
						>
							{item.emoji}
						</div>
					))}
				</div>
			</div>
			{/* [7] */}
			<div ref={rDraggingImage}>{state.name === 'dragging' && state.item.emoji}</div>
		</>
	)
}

// [8]
const components: TLEditorComponents = {
	InFrontOfTheCanvas: DragAndDropTray,
}

export default function DragAndDropTrayExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="drag-and-drop-tray-example" components={components} />
		</div>
	)
}

/*
Introduction:

This example demonstrates how to create a drag-and-drop tray component that allows users
to drag items from a custom UI tray and drop them onto the canvas as tldraw shapes. The
example uses a state machine pattern to manage the drag interaction states and creates
a custom UI component that renders in front of the canvas.

[1]
We define a union type `DragState` to represent the different states of our drag interaction:
- `idle`: Nothing is being dragged
- `pointing_item`: User has pressed down on an item but hasn't started dragging yet
- `dragging`: User is actively dragging an item

This state machine pattern helps us handle the complex drag interaction logic cleanly.

[2]
The main `DragAndDropTray` component uses two refs:
- `rTrayContainer`: References the tray container div for bounds checking
- `rDraggingImage`: References the dragging preview image that follows the cursor

We also get access to the tldraw editor instance to create shapes and handle coordinate
transformations.

[3]
We use tldraw's `useAtom` hook to create reactive state that can be observed and updated.
The `dragState` atom holds our current drag state and automatically triggers re-renders
when it changes.

[4]
The event handlers are memoized using `useMemo` to avoid recreating them on every render.
The main logic handles the drag interaction:

	[a] When transitioning from `pointing_item` to `dragging`, we check if the user has
	moved their pointer more than 10 pixels from the start position to avoid accidental
	drags from simple clicks.

	[b] During dragging, we continuously update the current position to track the cursor.

	[c] When the drag ends (pointer up during dragging), we convert the screen coordinates
	to page coordinates and create a new shape at that position using the editor API.

	[d] When starting a drag (pointer down), we capture the pointer, get the item data
	from the DOM, and transition to the `pointing_item` state.

[5]
The `useQuickReactor` hook efficiently manages the drag preview image styling. It:
- Hides the preview when not dragging
- Shows/hides the preview based on whether the cursor is inside the tray bounds
- Positions the preview image to follow the cursor during dragging
- Applies appropriate styling for the drag preview

[6]
The tray UI renders each item from `TRAY_ITEMS` with pointer event handlers attached.
We use `data-drag_item_index` to identify which item was clicked, allowing us to retrieve
the correct item data during drag operations.

[7]
The drag preview image is a separate div that shows the emoji being dragged. It's only
visible during the dragging state and follows the cursor position.

[8]
We configure the tldraw editor to include our custom tray component using the `components`
prop. The `InFrontOfTheCanvas` component renders on top of the canvas, making it perfect
for UI elements like our drag tray.
*/
```

## drag-and-drop-tray.css

```css
.drag-tray {
	position: absolute;
	left: 10px;
	top: 50px;
	background: var(--color-panel);
	border-radius: 9px;
	box-shadow: var(--shadow-1);
	z-index: 1000;
	pointer-events: all;
	overflow: hidden;
}

.drag-tray-items {
	display: flex;
	flex-direction: column;
	gap: 4px;
}

.drag-tray-item {
	display: flex;
	align-items: center;
	justify-content: center;
	gap: 12px;
	width: 40px;
	height: 40px;
	border-radius: 8px;
	cursor: grab;
	transition: all 0.2s ease;
	user-select: none;
	font-size: 18px;
}
```

## trayitems.ts

```ts
import { TLShape, toRichText } from 'tldraw'

// [1]
export interface TrayItem<T extends TLShape = TLShape> {
	id: string
	emoji: string
	label: string
	shapeType: T['type']
	shapeProps: Partial<T['props']>
}

export const TRAY_ITEMS: TrayItem<TLShape>[] = [
	{
		id: 'snowman',
		emoji: 'â›„',
		label: 'Snowman',
		shapeType: 'geo',
		shapeProps: {
			richText: toRichText('â›„'),
			size: 'm',
		},
	},
	{
		id: 'ice-cream',
		emoji: 'ðŸ¦',
		label: 'Ice Cream',
		shapeType: 'geo',
		shapeProps: {
			richText: toRichText('ðŸ¦'),
			size: 'm',
		},
	},
	{
		id: 'smiley',
		emoji: 'ðŸ˜Š',
		label: 'Smiley',
		shapeType: 'geo',
		shapeProps: {
			richText: toRichText('ðŸ˜Š'),
			size: 'm',
		},
	},
	{
		id: 'star',
		emoji: 'â­',
		label: 'Star',
		shapeType: 'geo',
		shapeProps: {
			richText: toRichText('â­'),
			size: 'm',
		},
	},
	{
		id: 'heart',
		emoji: 'â¤ï¸',
		label: 'Heart',
		shapeType: 'geo',
		shapeProps: {
			richText: toRichText('â¤ï¸'),
			size: 'm',
		},
	},
]
```

--------

# Selection UI

Category: UI & theming

Keywords: duplication controls, handles

Add extra UI elements around the user's selection.

You can use the `InFrontOfTheCanvas` component to show extra user interface elements around the user's selection.

## App.tsx

```tsx
import {
	TLComponents,
	Tldraw,
	Vec,
	intersectLineSegmentPolygon,
	stopEventPropagation,
	useEditor,
	useValue,
} from 'tldraw'
import 'tldraw/tldraw.css'

const components: TLComponents = {
	InFrontOfTheCanvas: () => {
		const editor = useEditor()

		const info = useValue(
			'selection bounds',
			() => {
				const screenBounds = editor.getViewportScreenBounds()
				const rotation = editor.getSelectionRotation()
				const rotatedScreenBounds = editor.getSelectionRotatedScreenBounds()
				if (!rotatedScreenBounds) return
				return {
					// we really want the position within the
					// tldraw component's bounds, not the screen itself
					x: rotatedScreenBounds.x - screenBounds.x,
					y: rotatedScreenBounds.y - screenBounds.y,
					width: rotatedScreenBounds.width,
					height: rotatedScreenBounds.height,
					rotation: rotation,
				}
			},
			[editor]
		)

		if (!info) return

		return (
			<div
				style={{
					position: 'absolute',
					top: 0,
					left: 0,
					transformOrigin: 'top left',
					transform: `translate(${info.x}px, ${info.y}px) rotate(${info.rotation}rad)`,
					pointerEvents: 'all',
				}}
				onPointerDown={stopEventPropagation}
			>
				<DuplicateInDirectionButton y={-40} x={info.width / 2 - 16} rotation={-(Math.PI / 2)} />
				<DuplicateInDirectionButton y={info.height / 2 - 16} x={info.width + 8} rotation={0} />
				<DuplicateInDirectionButton
					y={info.height + 8}
					x={info.width / 2 - 16}
					rotation={Math.PI / 3}
				/>
				<DuplicateInDirectionButton y={info.height / 2 - 16} x={-40} rotation={Math.PI} />
			</div>
		)
	},
}

export default function BasicExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example" components={components} />
		</div>
	)
}

/**
 * This button will duplicate the editor's current selected shapes in
 * a certain direction. Its rotation determines the appearance of the
 * button (its actual css rotation) as well as the direction in which
 * the duplicated shapes are offset from the original shapes. It's
 * zeroed to the right.
 */
function DuplicateInDirectionButton({
	x,
	y,
	rotation,
}: {
	x: number
	y: number
	rotation: number
}) {
	const editor = useEditor()

	return (
		<button
			style={{
				position: 'absolute',
				width: 32,
				height: 32,
				pointerEvents: 'all',
				transform: `translate(${x}px, ${y}px) rotate(${rotation}rad)`,
			}}
			onPointerDown={stopEventPropagation}
			onClick={() => {
				const selectionRotation = editor.getSelectionRotation() ?? 0
				const rotatedPageBounds = editor.getSelectionRotatedPageBounds()!
				const selectionPageBounds = editor.getSelectionPageBounds()!
				if (!(rotatedPageBounds && selectionPageBounds)) return

				editor.markHistoryStoppingPoint()

				const PADDING = 32

				// Find an intersection with the page bounds
				const center = Vec.Rot(rotatedPageBounds.center, selectionRotation)
				const int = intersectLineSegmentPolygon(
					center,
					Vec.Add(center, new Vec(100000, 0).rot(selectionRotation + rotation)),
					rotatedPageBounds
						.clone()
						.expandBy(PADDING)
						.corners.map((c) => c.rot(selectionRotation))
				)
				if (!int?.[0]) return

				// Get the direction and distance to the intersection
				const delta = Vec.Sub(int[0], center)
				const dist = delta.len()
				const dir = delta.uni()

				// Get the offset for the duplicated shapes
				const offset = dir.mul(dist * 2)

				editor.duplicateShapes(editor.getSelectedShapes(), offset)
			}}
		>
			â†’
		</button>
	)
}
```

--------

# Custom actions

Category: UI & theming

Keywords: keyboard, shortcut, copy, paste, group, align

Customize and override tldraw's actions.

This example shows how you can override tldraw's actions object to change keyboard shortcuts and add your own custom actions. In this case we've changed the delete action's shortcut to 'Shift + X', and we've added a new action that shows a toast when you press the 'S' key. For more information on keyboard shortcuts see the [keyboard shortcuts example](https://tldraw.dev/examples/keyboard-shortcuts).

## App.tsx

```tsx
import { Tldraw, TLUiActionItem, TLUiActionsContextType } from 'tldraw'
import 'tldraw/tldraw.css'

export default function BasicExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				overrides={{
					actions: (_editor, actions, helpers) => {
						const myCustomAction: TLUiActionItem = {
							id: 'my-action',
							label: 'My action',
							icon: 'circle',
							// [2]
							kbd: 's',
							onSelect(source) {
								// [3]
								helpers.addToast({ title: `My action was selected from ${source}!` })
							},
						}

						// [4]
						const newActions: TLUiActionsContextType = {
							...actions,
							'my-action': myCustomAction,
							delete: {
								...actions['delete'],
								kbd: 'shift+x',
							},
						}

						return newActions
					},
				}}
			/>
		</div>
	)
}

/* 
Tldraw's actions can be fired via keyboard shortcuts, or from anywhere in the user interface via 
the `useActions` hook. This example shows how you can override tldraw's actions object via the Tldraw
component's `overrides` prop. To learn more about using this actions via a customized menu, see the 
custom actions menu example.

[2]
For more information on keyboard shortcuts see the keyboard shortcuts example.

[3]
You can access UI helpers like addToast, removeToast, etc. from the helpers object.

[4]
Return a new object with the new actions added. You can also modify existing actions as shown here with the delete action.
*/
```

--------

# Custom indicators

Category: UI & theming

Keywords: indicators

Change when indicators are shown and how they appear.

This example shows how you can change when indicators are shown and how they appear.

## App.tsx

```tsx
import { TLComponents, Tldraw, useEditor, useEditorComponents, useValue } from 'tldraw'
import 'tldraw/tldraw.css'

const components: TLComponents = {
	OnTheCanvas: () => {
		const editor = useEditor()

		// [1]
		const renderingShapes = useValue(
			'rendering shapes',
			() => editor.getRenderingShapes().filter((_info) => true),
			[editor]
		)

		// [2]
		const { ShapeIndicator } = useEditorComponents()
		if (!ShapeIndicator) return null

		return (
			<div style={{ position: 'absolute', top: 0, left: 0, zIndex: 9999 }}>
				{renderingShapes.map(({ id }) => (
					<ShapeIndicator key={id + '_indicator'} shapeId={id} />
				))}
			</div>
		)
	},
	// [3]
	// ShapeIndicators: () => {
	// 	return <DefaultShapeIndicators showAll />
	// },
}

export default function IndicatorsLogicExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				components={components}
				onMount={(editor) => {
					if (editor.getCurrentPageShapeIds().size === 0) {
						editor.createShapes([
							{
								type: 'geo',
								x: 100,
								y: 100,
							},
							{
								type: 'geo',
								x: 500,
								y: 150,
							},
							{
								type: 'geo',
								x: 100,
								y: 500,
							},
							{
								type: 'geo',
								x: 500,
								y: 500,
							},
						])
					}
				}}
			/>
		</div>
	)
}

/*
[1]
Get which indicators to show (based on the shapes currently on screen).
You could include logic here using the filter to narrow down which shapes
you want to show the indicators for.

[2]
You could override the default ShapeIndicator component in this
same TLComponents object, but the default (DefaultIndicator.tsx)
has a lot of logic for where and how to display the indicator.

[3]
If all you want to do is show or hide all the indicators, you could 
create an override for the ShapeIndicators component that returns the
DefaultShapeIndicators component with `hideAll` or `showAll` props 
set to true.
*/
```

--------

# Custom keyboard shortcuts

Category: UI & theming

Keywords: dialog, overrides, actions, tools

Replace tldraw's default keyboard shortcuts with your own.

This example shows how you can replace tldraw's default keyboard shortcuts with your own,
or add a shortcut for an action that doesn't have one. An example of how to add shortcuts
for custom tools can be found in the custom-config example.

- Toggle show grid by pressing 'x'
- Select the Draw tool by pressing 'p'
- Copy as png by pressing 'ctrl/cmd + 1'

## App.tsx

```tsx
import { TLUiActionsContextType, TLUiOverrides, TLUiToolsContextType, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

// [1]
const overrides: TLUiOverrides = {
	//[a]
	actions(_editor, actions): TLUiActionsContextType {
		const newActions = {
			...actions,
			'toggle-grid': { ...actions['toggle-grid'], kbd: 'x' },
			'copy-as-png': { ...actions['copy-as-png'], kbd: 'cmd+1,ctrl+1' },
		}

		return newActions
	},
	//[b]
	tools(_editor, tools): TLUiToolsContextType {
		const newTools = { ...tools, draw: { ...tools.draw, kbd: 'p' } }
		return newTools
	},
}

// [2]
export default function KeyboardShortcuts() {
	return (
		<div className="tldraw__editor">
			<Tldraw overrides={overrides} />
		</div>
	)
}

/* 
This example shows how you can replace tldraw's default keyboard shortcuts with your own,
or add a shortcut for an action that doesn't have one. An example of how to add shortcuts
for custom tools can be found in the custom-config example.

In this case we are overriding the toggle grid and draw tool shortcuts, and creating a 
shortcut for copy-as-png. An override of an existing shortcut will automatically update 
the keyboard shortcuts dialog. However, adding a new shortcut won't, we'll need to add it 
ourselves.

You can describe modifier keys with the following syntax:
	
	shift: !
 ctrl/cmd: $
	  alt: ?

[1]
We start by defining our overrides, this is an object with functions that we can use to 
change the ui. Keyboard shortcuts are associated with either tools (draw, eraser, etc) or 
actions (group, undo/redo etc). We're going to override two actions [a], one tool [b], and 
add a new shortcut to the keyboard shortcuts dialog [c].

[a] actions
	There are two actions we're modifying here, copy-as-png and toggle-grid. copy-as-png
	doesn't have an existing shortcut, but we can still add the property and later add it
	to the keyboard shortcuts dialog [c].

[b] tools
	We're overriding the draw tool's shortcut to 'p', maybe we want to rename it to the pen
	tool or something.

[2]
Finally, we pass our overrides object into the Tldraw component's overrides prop. Now when
the component mounts, our overrides will be applied. If you open the keyboard shortcuts 
dialog, you'll see the changes we made.
*/
```

--------

# Force mobile layout

Category: UI & theming

Keywords: force, mobile, breakpoint

Force the editor UI to render as if it were on a mobile device.

This example shows how you can force the editor to use the mobile breakpoint's UI layout.
To do this, pass the `forceMobile` prop to the editor component.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function ForceMobileExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example" forceMobile />
		</div>
	)
}

/* 
This example shows how you can force the editor to use the mobile breakpoint.
Simply pass the `forceMobile` prop to the editor component.
*/
```

--------

# Infer dark mode

Category: UI & theming

Keywords: props

Infer dark mode based on system preferences.

When the `Tldraw` component's `inferDarkMode` is true, the editor will infer its initial theme based on the user's system preferences, if available. You can toggle the dark mode by pressing `Command + /`.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function InferDarkModeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw inferDarkMode />
		</div>
	)
}
```

--------

# Toggle dark mode

Category: UI & theming

Keywords: theme, dark mode

Toggle dark mode.

This example demonstrates how to change the user's current `colorScheme` preference back-and-forth between dark mode and light mode. Try it out by clicking the button at the top of the page.

## App.tsx

```tsx
import { Tldraw, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'

function DarkModeButton() {
	const editor = useEditor()

	const handleClick = () => {
		const isDark = editor.user.getIsDarkMode()
		editor.user.updateUserPreferences({ colorScheme: isDark ? 'light' : 'dark' })
	}

	return (
		<button style={{ pointerEvents: 'all' }} onClick={handleClick}>
			Toggle dark mode
		</button>
	)
}

export default function DarkModeToggleExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw components={{ TopPanel: DarkModeButton }} />
		</div>
	)
}
```

--------

# Layer panel

Category: UI & theming

Keywords: 

Implementing a minimal layers panel for tldraw.

This example adds a simple layers panel to show shapes, groups, and frames in a tree view. It also allows showing/hiding shapes and selecting shapes.

## App.tsx

```tsx
import { TLComponents, TLEditorSnapshot, Tldraw, useEditor, useValue } from 'tldraw'
import 'tldraw/tldraw.css'
import { ShapeList } from './ShapeList'
import './layer-panel.css'
import snapshot from './snapshot.json'

// There's a guide a the bottom of this file!

const components: TLComponents = {
	// [1]
	InFrontOfTheCanvas: () => {
		const editor = useEditor()
		const shapeIds = useValue(
			'shapeIds',
			() => editor.getSortedChildIdsForParent(editor.getCurrentPageId()),
			[editor]
		)
		return (
			<div className="layer-panel">
				<div className="layer-panel-title">Shapes</div>

				<ShapeList
					// [2]
					shapeIds={shapeIds}
					depth={0}
				/>
			</div>
		)
	},
}

export default function LayerPanelExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="layer-panel-example"
				components={components}
				// [3]
				getShapeVisibility={(s) =>
					s.meta.force_show ? 'visible' : s.meta.hidden ? 'hidden' : 'inherit'
				}
				// this is just to provide some initial content, so visitors can see the layer panel in action
				snapshot={snapshot as any as TLEditorSnapshot}
			/>
		</div>
	)
}

/*
Guide:

1. Here we override the `InFrontOfTheCanvas` component with a custom component that renders a simple layer panel.
2. We pass the root ids of the current page to the recursive ShapeList component. (see ShapeList.tsx)
3. This is a function that determines whether a shape is hidden. We use this to hide shapes that have the `hidden` meta property set to true.
*/
```

## ShapeList.tsx

```tsx
import { capitalize } from 'lodash'
import { useRef, useState } from 'react'
import { Editor, TLShapeId, useEditor, useValue } from 'tldraw'
import { VisibilityOff, VisibilityOn } from '../../icons/icons'

const selectedBg = '#E8F4FE'
const childSelectedBg = '#F3F9FE'
const childBg = '#00000006'

function ShapeItem({
	shapeId,
	depth,
	parentIsSelected,
	parentIsHidden,
}: {
	shapeId: TLShapeId
	depth: number
	parentIsSelected?: boolean
	parentIsHidden?: boolean
}) {
	const editor = useEditor()

	const shape = useValue('shape', () => editor.getShape(shapeId), [editor])
	const children = useValue('children', () => editor.getSortedChildIdsForParent(shapeId), [editor])
	const isHidden = useValue('isHidden', () => editor.isShapeHidden(shapeId), [editor])
	const isSelected = useValue('isSelected', () => editor.getSelectedShapeIds().includes(shapeId), [
		editor,
	])
	const shapeName = useValue('shapeName', () => getShapeName(editor, shapeId), [editor])

	const [isEditingName, setIsEditingName] = useState(false)

	const timeSinceLastVisibilityToggle = useRef(Date.now())

	if (!shape) return null

	return (
		<>
			{!!shape && (
				<div
					className="shape-item"
					onDoubleClick={() => {
						setIsEditingName(true)
					}}
					onClick={() => {
						// We synchronize the selection state of the layer panel items with the selection state of the shapes in the editor.
						if (editor.inputs.ctrlKey || editor.inputs.shiftKey) {
							if (isSelected) {
								editor.deselect(shape)
							} else {
								editor.select(...editor.getSelectedShapes(), shape)
							}
						} else {
							editor.select(shape)
						}
					}}
					style={{
						paddingLeft: 10 + depth * 20,
						opacity: isHidden ? 0.5 : 1,
						background: isSelected
							? selectedBg
							: parentIsSelected
								? childSelectedBg
								: depth > 0
									? childBg
									: undefined,
					}}
				>
					{isEditingName ? (
						<input
							autoFocus
							className="shape-name-input"
							defaultValue={shapeName}
							onBlur={() => setIsEditingName(false)}
							onChange={(ev) => {
								if (shape.type === 'frame') {
									editor.updateShape({ ...shape, props: { name: ev.target.value } })
								} else {
									editor.updateShape({ ...shape, meta: { name: ev.target.value } })
								}
							}}
							onKeyDown={(ev) => {
								// finish editing on enter
								if (ev.key === 'Enter' || ev.key === 'Escape') {
									ev.currentTarget.blur()
								}
							}}
						/>
					) : (
						<div className="shape-name">{shapeName}</div>
					)}
					<button
						className="shape-visibility-toggle"
						onClick={(ev) => {
							const now = Date.now()
							if (now - timeSinceLastVisibilityToggle.current < 200) {
								editor.updateShape({
									...shape,
									meta: { hidden: false, force_show: true },
								})
								timeSinceLastVisibilityToggle.current = 0
							} else {
								editor.updateShape({
									...shape,
									meta: { hidden: !shape.meta.hidden, force_show: false },
								})
								timeSinceLastVisibilityToggle.current = now
							}
							ev.preventDefault()
							ev.stopPropagation()
						}}
						onDoubleClickCapture={(ev) => {
							ev.stopPropagation()
						}}
					>
						{shape.meta.hidden ? <VisibilityOff /> : <VisibilityOn />}
					</button>
				</div>
			)}
			{!!children?.length && (
				<ShapeList
					shapeIds={children}
					depth={depth + 1}
					parentIsHidden={parentIsHidden || isHidden}
					parentIsSelected={parentIsSelected || isSelected}
				/>
			)}
		</>
	)
}

export function ShapeList({
	shapeIds,
	depth,
	parentIsSelected,
	parentIsHidden,
}: {
	shapeIds: TLShapeId[]
	depth: number
	parentIsSelected?: boolean
	parentIsHidden?: boolean
}) {
	if (!shapeIds.length) return null
	return (
		<div className="shape-tree">
			{shapeIds.map((shapeId) => (
				<ShapeItem
					key={shapeId}
					shapeId={shapeId}
					depth={depth}
					parentIsHidden={parentIsHidden}
					parentIsSelected={parentIsSelected}
				/>
			))}
		</div>
	)
}

function getShapeName(editor: Editor, shapeId: TLShapeId) {
	const shape = editor.getShape(shapeId)
	if (!shape) return 'Unknown shape'
	return (
		// meta.name is the first choice, then the shape's text, then the capitalized shape type
		(shape.meta.name as string) ||
		editor.getShapeUtil(shape).getText(shape) ||
		capitalize(shape.type + ' shape')
	)
}
```

## layer-panel.css

```css
.layer-panel {
	position: absolute;
	left: 0;
	top: 42px;
	width: 200px;
	height: calc(100% - 42px);
	background: white;
	display: flex;
	flex-direction: column;
}
.shape-tree {
	display: flex;
	flex-direction: column;
}
.shape-item {
	display: flex;
	align-items: center;
	justify-content: space-between;
	padding: 6px 10px;
}

.shape-visibility-toggle {
	padding: 3px 6px;
	border-radius: 3px;
	outline: none;
	border: none;
	background: none;
	flex-shrink: 0;
}
.shape-visibility-toggle:hover {
	cursor: pointer;
	background-color: #0000000b;
}

.layer-panel-title {
	padding: 10px;
	font-size: smaller;
	font-weight: bolder;
}

.shape-name-input {
	border: none;
	background: none;
	width: 0;
	flex-grow: 1;
	padding: 0;
}

.shape-name {
	overflow: hidden;
	text-overflow: ellipsis;
	text-wrap: nowrap;
}
```

--------

# Floaty window

Category: UI & theming

Keywords: 

Create an illusion of a floating window.

This example shows how to create a 'floating window' illusion that was [popular on social media](https://x.com/steveruizok/status/1727436505440981099) for a while.

## App.tsx

```tsx
import { useEffect } from 'react'
import { Tldraw, Vec, useContainer, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'

export default function FloatyExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="tldraw_floaty_example">
				<SneakyFloatyHook />
			</Tldraw>
		</div>
	)
}

function SneakyFloatyHook() {
	const editor = useEditor()
	const container = useContainer()

	useEffect(() => {
		if (!window.screenLeft) {
			window.screenLeft = window.screenX
			window.screenTop = window.screenY
		}

		let x = window.screenLeft ?? window.screenX
		let y = window.screenTop ?? window.screenY

		function updatePositions() {
			const sx = window.screenLeft ?? window.screenX
			const sy = window.screenTop ?? window.screenY

			if (sx !== x || sy !== y) {
				x = sx
				y = sy
				editor.setCamera(new Vec(-x, -y))
			}
		}

		editor.on('tick', updatePositions)

		return () => {
			editor.off('tick', updatePositions)
		}
	}, [editor, container])

	return null
}
```

--------

# Custom renderer

Category: UI & theming

Keywords: html, canvas, background, context

You can _sort of_ use a custom renderer with tldraw.

This example shows how you might use a custom renderer with tldraw.

## App.tsx

```tsx
import { useLayoutEffect } from 'react'
import { DefaultCanvas, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import { CustomRenderer } from './CustomRenderer'

export default function CustomRendererExample() {
	useLayoutEffect(() => {
		// Hide the regular shapes layer using CSS.
		const script = document.createElement('style')
		if (!script) return
		script.innerHTML = `.tl-shapes { display: none; }`
		document.body.appendChild(script)
		return () => {
			script.remove()
		}
	})

	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="example"
				components={{
					// We're replacing the Background component with our custom renderer
					Background: CustomRenderer,
					// Even though we're hiding the shapes, we'll still do a bunch of work
					// in react to figure out which shapes to create. In reality, you might
					// want to set the Canvas component to null and render it all yourself.
					Canvas: DefaultCanvas,
				}}
			/>
		</div>
	)
}
```

## CustomRenderer.tsx

```tsx
import { useLayoutEffect, useRef } from 'react'
import { TLDrawShape, TLGeoShape, getColorValue, getDefaultColorTheme, useEditor } from 'tldraw'

export function CustomRenderer() {
	const editor = useEditor()
	const rCanvas = useRef<HTMLCanvasElement>(null)

	useLayoutEffect(() => {
		const canvas = rCanvas.current
		if (!canvas) return

		canvas.style.width = '100%'
		canvas.style.height = '100%'

		const rect = canvas.getBoundingClientRect()

		canvas.width = rect.width
		canvas.height = rect.height

		const ctx = canvas.getContext('2d')!

		let raf = -1

		function render() {
			if (!canvas) return

			ctx.resetTransform()
			ctx.clearRect(0, 0, canvas.width, canvas.height)

			const camera = editor.getCamera()
			ctx.scale(camera.z, camera.z)
			ctx.translate(camera.x, camera.y)

			const renderingShapes = editor.getRenderingShapes()
			const theme = getDefaultColorTheme({ isDarkMode: editor.user.getIsDarkMode() })
			const currentPageId = editor.getCurrentPageId()

			for (const { shape, opacity } of renderingShapes) {
				const maskedPageBounds = editor.getShapeMaskedPageBounds(shape)
				if (!maskedPageBounds) continue
				ctx.save()

				if (shape.parentId !== currentPageId) {
					ctx.beginPath()
					ctx.rect(
						maskedPageBounds.minX,
						maskedPageBounds.minY,
						maskedPageBounds.width,
						maskedPageBounds.height
					)
					ctx.clip()
				}

				ctx.beginPath()

				ctx.globalAlpha = opacity

				const transform = editor.getShapePageTransform(shape.id)
				ctx.transform(transform.a, transform.b, transform.c, transform.d, transform.e, transform.f)

				if (editor.isShapeOfType<TLDrawShape>(shape, 'draw')) {
					// Draw a freehand shape
					for (const segment of shape.props.segments) {
						ctx.moveTo(segment.points[0].x, segment.points[0].y)
						if (segment.type === 'straight') {
							ctx.lineTo(segment.points[1].x, segment.points[1].y)
						} else {
							for (const point of segment.points.slice(1)) {
								ctx.lineTo(point.x, point.y)
							}
						}
					}
					ctx.strokeStyle = getColorValue(theme, shape.props.color, 'solid')
					ctx.lineWidth = 4
					ctx.stroke()
					if (shape.props.fill !== 'none' && shape.props.isClosed) {
						ctx.fillStyle = getColorValue(theme, shape.props.color, 'semi')
						ctx.fill()
					}
				} else if (editor.isShapeOfType<TLGeoShape>(shape, 'geo')) {
					// Draw a geo shape
					const bounds = editor.getShapeGeometry(shape).bounds
					ctx.strokeStyle = getColorValue(theme, shape.props.color, 'solid')
					ctx.lineWidth = 2
					ctx.strokeRect(bounds.minX, bounds.minY, bounds.width, bounds.height)
				} else {
					// Draw any other kind of shape
					const bounds = editor.getShapeGeometry(shape).bounds
					ctx.strokeStyle = 'black'
					ctx.lineWidth = 2
					ctx.strokeRect(bounds.minX, bounds.minY, bounds.width, bounds.height)
				}
				ctx.restore()
			}

			raf = requestAnimationFrame(render)
		}

		render()

		return () => {
			cancelAnimationFrame(raf)
		}
	}, [editor])

	return <canvas ref={rCanvas} />
}
```

--------

# Inset editor

Category: Page layout

Keywords: inline

Using the tldraw component in a non-fullscreen layout.

The `<Tldraw/>` component may be placed in any layout, even if it's not full-screen. In this example, the editor is inset within the screen layout. The component's interactions should still behave as you'd expect them to.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function InsetExample() {
	return (
		<div style={{ position: 'absolute', inset: 100 }}>
			<div className="tldraw__editor">
				<Tldraw />
			</div>
		</div>
	)
}
```

--------

# Inset editor (fixed sizes)

Category: Page layout

Keywords: focus, auto, focus, multiple, editors

Use the `Tldraw` component with a set height and width.

The `Tldraw` component can be used with a set height and width.
This example shows the editor's default appearance at various different sizes.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function InlineExample() {
	return (
		<>
			<InlineEditor width={400} height={300} />
			<InlineEditor width={500} height={300} />
			<InlineEditor width={600} height={400} />
			<InlineEditor width={700} height={500} />
			<InlineEditor width={900} height={600} />
		</>
	)
}

function InlineEditor({ width, height }: { width: number; height: number }) {
	const title = `${width} x ${height}`
	return (
		<section style={{ padding: '12px 32px' }}>
			<h2>{title}</h2>
			<div style={{ width, height }}>
				<Tldraw persistenceKey="inset-size-example" />
			</div>
		</section>
	)
}
```

--------

# Inset editor (common practices)

Category: Page layout

Keywords: focus, blur, multiple

Common practices for using the `Tldraw` component as a block within a larger page.

This example demonstrates some common best practices for using tldraw as a block within a larger page. It includes:

- Making sure that only one editor has focus at a time.
- Always defaulting to the hand tool when you click into an editor.
- Deselecting everything when an editor loses focus.
- Hiding the UI when an editor is not focused.
- Disabling edge scrolling by default.
- Using a stripped down UI to make the most of the available space.
- Removing actions from the context menu to match the stripped down UI.

## App.tsx

```tsx
import { createContext, useContext, useState } from 'react'
import { Editor, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this page!

// [1]
const focusedEditorContext = createContext(
	{} as {
		focusedEditor: Editor | null
		setFocusedEditor(id: Editor | null): void
	}
)

// [2]
function blurEditor(editor: Editor) {
	editor.blur({ blurContainer: false })
	editor.selectNone()
	editor.setCurrentTool('hand')
}

export default function InlineBehaviorExample() {
	const [focusedEditor, setFocusedEditor] = useState<Editor | null>(null)

	return (
		<focusedEditorContext.Provider value={{ focusedEditor, setFocusedEditor }}>
			<div
				style={{
					display: 'flex',
					flexDirection: 'column',
					padding: 20,
					gap: 20,
				}}
				// [3]
				onPointerDown={() => {
					if (!focusedEditor) return
					blurEditor(focusedEditor)
					setFocusedEditor(null)
				}}
			>
				<InlineBlock persistenceKey="block-a" />
				<InlineBlock persistenceKey="block-b" />
				<InlineBlock persistenceKey="block-c" />
			</div>
		</focusedEditorContext.Provider>
	)
}

function InlineBlock({ persistenceKey }: { persistenceKey: string }) {
	const { focusedEditor, setFocusedEditor } = useContext(focusedEditorContext)
	const [editor, setEditor] = useState<Editor>()

	return (
		<div
			style={{ width: 600, height: 400, maxWidth: '100%' }}
			// [4]
			onFocus={() => {
				if (!editor) return
				if (focusedEditor && focusedEditor !== editor) {
					blurEditor(focusedEditor)
				}
				editor.focus({ focusContainer: false })
				setFocusedEditor(editor)
			}}
		>
			<Tldraw
				persistenceKey={persistenceKey}
				autoFocus={false}
				// [5]
				hideUi={focusedEditor !== editor}
				// [6]
				options={{
					maxPages: 0,
					edgeScrollSpeed: 0,
				}}
				// [7]
				components={{
					HelpMenu: null,
					NavigationPanel: null,
					MainMenu: null,
				}}
				// [8]
				onMount={(editor) => {
					setEditor(editor)
					editor.setCurrentTool('hand')
				}}
			/>
		</div>
	)
}

/*
This example demonstrates some common best practices for using tldraw as an inline block within a
larger document editor.

It includes:

- Making sure that only one editor has focus at a time.
- Always defaulting to the hand tool when you click into an editor.
- Deselecting everything when an editor loses focus.
- Hiding the UI when an editor is not focused.
- Disabling edge scrolling by default.
- Using a stripped down UI to make the most of the available space.

[1]
We use a context to manage which editor is currently focused. This allows us to have multiple
editors on the same page, without them interfering with each other, or hijacking any keyboard
shortcuts. For more information about handling focus, check out the 'Multiple editors' and 'Editor
focus' examples.

[2]
We have a helper function that we call on any editor that loses focus. We deselect everything, and
switch back to the hand tool, essentially 'resetting' the user's tool state.

[3]
When the user clicks anywhere on the page outside of an editor, we blur the currently focused
editor.

[4]
When the user clicks into an editor, we focus it, and blur any other editor.

[5]
We hide the UI of any unfocused editor.

[6]
We disable pages to hide the pages menu. We disable edge scrolling, which can sometimes be too
easily triggered when the editor is in a small space. 

[7]
We disable many of tldraw's default UI components to make the most of the available space.

[8]
When an editor mounts, we default to the hand tool. We also store a reference to the editor so that
we can access it later.

*/
```

--------

# Inset canvas

Category: Page layout

Keywords: 

Handling events when the canvas is inset within the editor.

If for some reason you need to move the canvas around, that should still work.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import './inset-canvas.css'

export default function InsetCanvasExample() {
	return (
		<div className="tldraw__editor tldraw__editor-with-inset-canvas">
			<Tldraw />
		</div>
	)
}
```

## inset-canvas.css

```css
.tldraw__editor-with-inset-canvas .tl-canvas {
	position: absolute;
	inset: 25%;
	width: 50%;
	height: 50%;
}
```

--------

# Scrollable container

Category: Page layout

Keywords: focus, mouse wheel

Use the editor inside a scrollable container.

The `Tldraw` component can be used inside of any layout, including a scrollable container. Note that the editor will accept mousewheel events unless it is "unfocused".

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function ScrollExample() {
	return (
		<div
			style={{
				width: '150vw',
				height: '150vh',
				display: 'flex',
				justifyContent: 'center',
				alignItems: 'center',
				backgroundColor: '#fff',
			}}
		>
			<div style={{ width: '60vw', height: '80vh' }}>
				<Tldraw persistenceKey="scroll-example" autoFocus={true} />
			</div>
		</div>
	)
}

/*
This example shows how you can use the Tldraw component inside a scrollable container. 
The component will still accept mousewheel events while "focused". Try turning off the
autoFocus prop to see the difference.
*/
```

--------

# Multiple editors

Category: Page layout

Keywords: multiple, focus

Use multiple `<Tldraw/>` components on the same page.

This example shows how to use multiple `<Tldraw/>` components on the same page.

## App.tsx

```tsx
import { createContext, useCallback, useContext, useState } from 'react'
import { Editor, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this page!

// [1]
const focusedEditorContext = createContext(
	{} as {
		focusedEditor: Editor | null
		setFocusedEditor(id: Editor | null): void
	}
)

// [2]
export default function MultipleExample() {
	const [focusedEditor, _setFocusedEditor] = useState<Editor | null>(null)

	const setFocusedEditor = useCallback(
		(editor: Editor | null) => {
			if (focusedEditor !== editor) {
				if (focusedEditor) {
					focusedEditor.blur()
				}
				if (editor) {
					editor.focus()
				}
				_setFocusedEditor(editor)
			}
		},
		[focusedEditor]
	)

	const focusName =
		focusedEditor === (window as any).EDITOR_A
			? 'A'
			: focusedEditor === (window as any).EDITOR_B
				? 'B'
				: focusedEditor === (window as any).EDITOR_C
					? 'C'
					: 'none'

	return (
		<div
			style={{
				padding: 32,
			}}
			// Sorry you need to do this yourself
			onPointerDown={() => setFocusedEditor(null)}
		>
			<focusedEditorContext.Provider value={{ focusedEditor, setFocusedEditor }}>
				<h1>Focusing: {focusName}</h1>
				<EditorA />
				<textarea data-testid="textarea" placeholder="type in me" style={{ margin: 10 }} />
				<div
					style={{
						width: '100%',
						display: 'grid',
						gridTemplateColumns: 'repeat(auto-fit, minmax(420px, 1fr))',
						gap: 64,
					}}
				>
					<EditorB />
					<EditorC />
				</div>
				<p>
					These two editors share the same persistence key so they will share a (locally)
					synchronized document.
				</p>
				<ABunchOfText />
			</focusedEditorContext.Provider>
		</div>
	)
}

// [3]
function EditorA() {
	const { setFocusedEditor } = useContext(focusedEditorContext)

	return (
		<div style={{ padding: 32 }}>
			<h2>A</h2>
			<div
				tabIndex={-1}
				onFocus={() => setFocusedEditor((window as any).EDITOR_A)}
				style={{ height: 600 }}
			>
				<Tldraw
					persistenceKey="steve"
					className="A"
					autoFocus={false}
					onMount={(editor) => {
						;(window as any).EDITOR_A = editor
						setFocusedEditor(editor)
					}}
				/>
			</div>
		</div>
	)
}

// [4]
function EditorB() {
	const { setFocusedEditor } = useContext(focusedEditorContext)

	return (
		<div>
			<h2>B</h2>
			<div
				tabIndex={-1}
				onFocus={() => setFocusedEditor((window as any).EDITOR_B)}
				style={{ height: 600 }}
			>
				<Tldraw
					persistenceKey="david"
					className="B"
					autoFocus={false}
					onMount={(editor) => {
						;(window as any).EDITOR_B = editor
					}}
				/>
			</div>
		</div>
	)
}

function EditorC() {
	const { setFocusedEditor } = useContext(focusedEditorContext)

	return (
		<div>
			<h2>C</h2>
			<div
				tabIndex={-1}
				onFocus={() => setFocusedEditor((window as any).EDITOR_C)}
				style={{ height: 600 }}
			>
				<Tldraw
					persistenceKey="david"
					className="C"
					autoFocus={false}
					onMount={(editor) => {
						;(window as any).EDITOR_C = editor
					}}
				/>
			</div>
		</div>
	)
}

// [5]
function ABunchOfText() {
	return (
		<article style={{ maxWidth: 500 }}>
			<h1>White Board</h1>
			<h2>Chapter 1: The First Strokes</h2>
			<p>
				The fluorescent lights flickered overhead as John sat hunched over his desk, his fingers
				tapping rhythmically on the keyboard. He was a software developer, and tonight, he had a
				peculiar mission. A mission that would take him deep into the labyrinthine world of web
				development. John had stumbled upon a new whiteboard library called â€œtldrawâ€, a seemingly
				simple tool that promised to revolutionize collaborative drawing on the web. Little did he
				know that this discovery would set off a chain of events that would challenge his skills,
				test his perseverance, and blur the line between reality and imagination.
			</p>
			<p>
				With a newfound sense of excitement, John began integrating â€œtldrawâ€ into his latest
				project. As lines of code danced across his screen, he imagined the possibilities that lay
				ahead. The potential to create virtual spaces where ideas could be shared, concepts could be
				visualized, and teams could collaborate seamlessly from different corners of the world. It
				was a dream that seemed within reach, a vision of a future where creativity and technology
				merged into a harmonious symphony.
			</p>
			<p>
				As the night wore on, Johnâ€™s mind became consumed with the whiteboard library. He couldnâ€™t
				help but marvel at its elegance and simplicity. With each stroke of his keyboard, he felt a
				surge of inspiration, a connection to something greater than himself. It was as if the lines
				of code he was writing were transforming into a digital canvas, waiting to be filled with
				the strokes of imagination. In that moment, John realized that he was not just building a
				tool, but breathing life into a new form of expression. The whiteboard was no longer just a
				blank slate; it had become a portal to a world where ideas could flourish and dreams could
				take shape.
			</p>
			<p>
				Little did John know, this integration of â€œtldrawâ€ was only the beginning. It would lead him
				down a path filled with unforeseen challenges, where he would confront his own limitations
				and question the very nature of creation. The journey ahead would test his resolve, pushing
				him to the edge of his sanity. And as he embarked on this perilous adventure, he could not
				shake the feeling that the whiteboard held secrets far beyond his understanding. Secrets
				that would unfold before his eyes, one stroke at a time.
			</p>
		</article>
	)
}

/* 
This example shows how to use multiple editors on the same page. When doing this, you'll
need to make sure that only one editor is focused at a time. We can manage this using 
the autofocus prop on the tldraw component, along with React's context and set state 
APIs.

[1]
We first create a context that will hold the focused editor id and a setter for that id. 
We'll use this to keep track of which editor is focused.

[2]
Wrap the editors in the context provider. This will make the context available to all
of the editors.

[3]	
Get the focused editor id and the setter from the context. We'll use these to determine
if the editor should be focused or not. We wrap the Tldraw component in a div and use 
the onFocus event to set the focused editor id. 

[4]
Same again, but we're using the same persistence key for editors B and C. This means
that they will share a document. 

[5]
A long story that doesn't really go anywhere, clearly written by a computer. But it's	
a good way to test the scroll behavior of the page.
*/
```

--------

# External dialog

Category: Page layout

Keywords: css

Make dialogs open outside of the `Tldraw` component.

You can make dialogs open outside of the `Tldraw` component by overriding our default styles. To see this in action, open the Insert embed dialog through the menu or by pressing 'Cmd + I'.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// This CSS file overrides the default styles for dialogs
import './external-dialog.css'

export default function ExternalDialog() {
	return (
		<div style={{ margin: 32, width: 600, height: 400 }}>
			<Tldraw />
		</div>
	)
}
```

## external-dialog.css

```css
.tlui-dialog__overlay {
	position: fixed;
}
```

--------

# External UI (using context)

Category: Page layout

Keywords: outside, editor, context

This example shows how to control the tldraw editor from an external UI, using React context.

This example shows how to control the tldraw editor from an external UI, outside
of the `Tldraw` component. There are a few ways of doing thisâ€”for example, by putting the editor on the window object, passing it around via props, or using React context.

In this example, we use React context to distribute a reference to the editor to child components.

## App.tsx

```tsx
import { createContext, useContext, useState } from 'react'
import { Editor, GeoShapeGeoStyle, Tldraw, useValue } from 'tldraw'
import 'tldraw/tldraw.css'
import './external-ui.css'

// There's a guide at the bottom of this file!

// [1]
const editorContext = createContext({} as { editor: Editor })

export default function ExternalUiExample2() {
	const [editor, setEditor] = useState<Editor | null>(null)

	return (
		<div style={{ margin: 32, width: 600 }}>
			<div style={{ height: 400 }}>
				<Tldraw
					// [2]
					onMount={(editor) => setEditor(editor)}
					components={{ Toolbar: null }}
				/>
			</div>
			{/* [3] */}
			{editor && (
				<editorContext.Provider value={{ editor }}>
					<ExternalToolbar />
				</editorContext.Provider>
			)}
		</div>
	)
}

// [4]
const ExternalToolbar = () => {
	const { editor } = useContext(editorContext)

	const currentToolId = useValue('current tool id', () => editor?.getCurrentToolId(), [editor])

	return (
		<div>
			<div className="external-toolbar">
				<button
					className="external-button"
					data-isactive={currentToolId === 'select'}
					onClick={() => editor.setCurrentTool('select')}
				>
					Select
				</button>
				<button
					className="external-button"
					data-isactive={currentToolId === 'draw'}
					onClick={() => editor.setCurrentTool('draw')}
				>
					Pencil
				</button>
				<button
					className="external-button"
					data-isactive={
						currentToolId === 'geo' && editor?.getStyleForNextShape(GeoShapeGeoStyle) === 'oval'
					}
					onClick={() => {
						editor.run(() => {
							editor.setStyleForNextShapes(GeoShapeGeoStyle, 'oval')
							editor.setCurrentTool('geo')
						})
					}}
				>
					Oval
				</button>
			</div>
		</div>
	)
}

/*

[1] 
Use React context to store the editor at a higher place in the React component tree. 

[2] 
Use the `onMount` prop to get the editor instance and store it in state.

[3]
When we have an editor in state, render the context provider and its descendants.

[4]
You can access the editor from any of the provider's descendants.
*/
```

## external-ui.css

```css
.external-toolbar {
	display: flex;
	align-items: center;
	justify-content: center;
	padding: 8px;
	gap: 8px;
}

.external-button {
	pointer-events: all;
	padding: 4px 12px;
	background: white;
	border: 1px solid black;
	border-radius: 16px;
}

.external-button[data-isactive='true'] {
	background-color: black;
	color: white;
}
```

--------

# External UI (using state)

Category: Page layout

Keywords: outside, editor

This example shows how to control the tldraw editor from an external UI, using state.

This example shows how to control the tldraw editor from an external UI, outside
of the `Tldraw` component. There are a few ways of doing thisâ€”for example, by putting the editor on the window object, passing it around via props, or using React context.

In this example, we'll just put the editor instance in state and use it in the same component. See the [other External UI example](https://tldraw.dev/examples/external-ui-context) for an alternative (and more realistic) solution using React context.

## App.tsx

```tsx
import { useState } from 'react'
import { Editor, GeoShapeGeoStyle, Tldraw, useValue } from 'tldraw'
import 'tldraw/tldraw.css'
import './external-ui.css'

// There's a guide at the bottom of this file!

export default function ExternalUiExample() {
	// [1]
	const [editor, setEditor] = useState<Editor | null>(null)

	const currentToolId = useValue('current tool id', () => editor?.getCurrentToolId(), [editor])

	return (
		<div style={{ margin: 32, width: 600 }}>
			<div style={{ height: 400 }}>
				<Tldraw
					// [2]
					onMount={(editor) => setEditor(editor)}
					components={{ Toolbar: null }}
				/>
			</div>
			{/* [3] */}
			<div>
				<div className="external-toolbar">
					<button
						className="external-button"
						data-isactive={currentToolId === 'select'}
						onClick={() => editor?.setCurrentTool('select')}
					>
						Select
					</button>
					<button
						className="external-button"
						data-isactive={currentToolId === 'draw'}
						onClick={() => editor?.setCurrentTool('draw')}
					>
						Pencil
					</button>
					<button
						className="external-button"
						data-isactive={
							currentToolId === 'geo' && editor?.getStyleForNextShape(GeoShapeGeoStyle) === 'oval'
						}
						onClick={() => {
							if (!editor) return
							editor.run(() => {
								// [4]
								editor.setStyleForNextShapes(GeoShapeGeoStyle, 'oval')
								editor.setCurrentTool('geo')
							})
						}}
					>
						Oval
					</button>
				</div>
			</div>
		</div>
	)
}

/*
[1] 
Use React state to store the editor instance.

[2]
Use the `onMount` prop to get the editor instance and store it in state.

[3]
Use data from the editor instance or use the editor's methods to control the editor.
Note that these callbacks also need to work if the editor isn't mounted yet.

[4]
The geo tool is a bit special since it controls the creation of many geo shapes (oval, rectangle, etc).
This is why we first set the type of the shape we wish to add, then we set the tool to 'geo'.
You can see all the available geo shapes in the `GeoShapeGeoStyle` enum.
*/
```

## external-ui.css

```css
.external-toolbar {
	display: flex;
	align-items: center;
	justify-content: center;
	padding: 8px;
	gap: 8px;
}

.external-button {
	pointer-events: all;
	padding: 4px 12px;
	background: white;
	border: 1px solid black;
	border-radius: 16px;
}

.external-button[data-isactive='true'] {
	background-color: black;
	color: white;
}
```

--------

# Snapshot image component

Category: Page layout

Keywords: snapshot, export

Display a tldraw snapshot as an image by using the `TldrawImage` component.

The `TldrawImage` component is a simple way to display a tldraw snapshot as an image. This example shows how to use it.

## App.tsx

```tsx
import { useState } from 'react'
import {
	Box,
	Editor,
	StoreSnapshot,
	TLPageId,
	TLRecord,
	TLStoreSnapshot,
	Tldraw,
	TldrawImage,
	getSnapshot,
} from 'tldraw'
import 'tldraw/tldraw.css'
import initialSnapshot from './snapshot.json'

// There's a guide at the bottom of this file!

export default function TldrawImageExample() {
	const [editor, setEditor] = useState<Editor>()
	const [snapshot, setSnapshot] = useState<StoreSnapshot<TLRecord>>(
		initialSnapshot as TLStoreSnapshot
	)
	const [currentPageId, setCurrentPageId] = useState<TLPageId | undefined>()
	const [showBackground, setShowBackground] = useState(true)
	const [isDarkMode, setIsDarkMode] = useState(false)
	const [viewportPageBounds, setViewportPageBounds] = useState(new Box(0, 0, 600, 400))
	const [isEditing, setIsEditing] = useState(false)
	const [format, setFormat] = useState<'svg' | 'png'>('svg')

	return (
		<div style={{ padding: 30 }}>
			<div>
				<button
					style={{ cursor: 'pointer', marginRight: 8 }}
					onClick={() => {
						if (isEditing) {
							if (!editor) return
							setIsDarkMode(editor.user.getIsDarkMode())
							setShowBackground(editor.getInstanceState().exportBackground)
							setViewportPageBounds(editor.getViewportPageBounds())
							setCurrentPageId(editor.getCurrentPageId())
							setSnapshot(getSnapshot(editor.store).document)
							setIsEditing(false)
						} else {
							setIsEditing(true)
						}
					}}
				>
					{isEditing ? 'âœ“ Save drawing' : 'âœŽ Edit drawing'}
				</button>
				{!isEditing && (
					<>
						<label htmlFor="format" style={{ marginRight: 8 }}>
							Format
						</label>
						<select
							name="format"
							value={format}
							onChange={(e) => {
								setFormat(e.currentTarget.value as 'svg' | 'png')
							}}
						>
							<option value="svg">SVG</option>
							<option value="png">PNG</option>
						</select>
					</>
				)}
			</div>
			<div style={{ width: 600, height: 400, marginTop: 15 }}>
				{isEditing ? (
					<Tldraw
						snapshot={snapshot}
						onMount={(editor: Editor) => {
							setEditor(editor)
							editor.user.updateUserPreferences({ colorScheme: isDarkMode ? 'dark' : 'light' })
							if (currentPageId) {
								editor.setCurrentPage(currentPageId)
							}
							if (viewportPageBounds) {
								editor.zoomToBounds(viewportPageBounds, { inset: 0 })
							}
						}}
					/>
				) : (
					<TldrawImage
						//[1]
						snapshot={snapshot}
						// [2]
						pageId={currentPageId}
						// [3]
						background={showBackground}
						darkMode={isDarkMode}
						bounds={viewportPageBounds}
						padding={0}
						scale={1}
						format={format}
					/>
				)}
			</div>
		</div>
	)
}

/*

This example shows how to use the `TldrawImage` component to display a snapshot
as an image. The example also allows you to toggle between editing the snapshot
and viewing it.

[1] Pass your snapshot to the `snapshot` prop of the `TldrawImage` component.

[2] You can specify which page to display by using the `pageId` prop. By
    default, the first page is shown.

[3] You can customize the appearance of the image by passing other props to the
        `TldrawImage` component. For example, you can toggle the background, set
        the dark mode, and specify the viewport bounds.
 */
```

--------

# Unsaved changes

Category: Events & effects

Keywords: save, unsaved, changes, document, listen, state

Track unsaved changes and enable save functionality.

This example shows how to track when the document has unsaved changes by listening to document scope events. A save button is enabled only when there are unsaved changes, and clicking it clears the unsaved state. The example uses `Editor.store.listen` with the `document` scope to monitor changes to the tldraw document.

## App.tsx

```tsx
import { useCallback, useEffect, useRef, useState } from 'react'
import {
	RecordsDiff,
	TLComponents,
	TLEditorSnapshot,
	TLEventMapHandler,
	TLRecord,
	Tldraw,
	squashRecordDiffs,
	useEditor,
} from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

function SaveButton() {
	const editor = useEditor()
	const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false)

	const rUnsavedChanges = useRef<RecordsDiff<TLRecord>>({ added: {}, removed: {}, updated: {} })

	useEffect(() => {
		// [1]
		const handleDocumentChange: TLEventMapHandler<'change'> = (diff) => {
			squashRecordDiffs([rUnsavedChanges.current, diff.changes], { mutateFirstDiff: true })
			setHasUnsavedChanges(
				!isPlainObjectEmpty(rUnsavedChanges.current.added) ||
					!isPlainObjectEmpty(rUnsavedChanges.current.removed) ||
					!isPlainObjectEmpty(rUnsavedChanges.current.updated)
			)
		}

		// [2]
		return editor.store.listen(handleDocumentChange, { scope: 'document' })
	}, [editor])

	// [3]
	const handleSave = useCallback(() => {
		// The diff is the difference between the current document and the last saved document
		const diff = rUnsavedChanges.current

		// Maybe also get the current document / schema snapshot
		const snapshot = editor.getSnapshot()

		// Save everything somewhere...
		saveChanges(diff, snapshot)

		// Clear the unsaved changes state
		setHasUnsavedChanges(false)

		// Reset the diff
		rUnsavedChanges.current = {
			added: {},
			removed: {},
			updated: {},
		}
	}, [editor])

	return (
		<button
			onClick={handleSave}
			disabled={!hasUnsavedChanges}
			style={{
				pointerEvents: 'all',
				padding: '8px 16px',
				marginTop: '6px',
				backgroundColor: hasUnsavedChanges ? '#2d7d32' : '#ccc',
				color: hasUnsavedChanges ? 'white' : '#666',
				border: 'none',
				borderRadius: '4px',
				cursor: hasUnsavedChanges ? 'pointer' : 'not-allowed',
				fontWeight: '500',
			}}
		>
			{hasUnsavedChanges ? 'Save Changes' : 'No Changes'}
		</button>
	)
}

function saveChanges(_diff: RecordsDiff<TLRecord>, _snapshot: TLEditorSnapshot) {
	// todo: do something with the diff, or save the whole document snapshot somewhere
}

function isPlainObjectEmpty(obj: object) {
	for (const key in obj) return false
	return true
}

// [4]
const components: TLComponents = {
	TopPanel: SaveButton,
}

export default function UnsavedChangesExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw components={components} />
		</div>
	)
}

/*
This example shows how to track unsaved changes in a tldraw document using the store's 
listen method with document scope, and how to accumulate a diff of all changes since 
the last save.

[1]
We create a handler that will be called whenever there are changes to the document. 
The handler receives a diff of the changes that occurred. We use `squashRecordDiffs` 
to accumulate all changes since the last save into a single diff object. This gives 
us a complete picture of what has changed without storing redundant intermediate states.

[2]
We listen to store changes with the 'document' scope, which means we only get notified 
about changes to document content (shapes, pages, etc.) and not to instance data like 
camera position or selected shapes. 

[3]
The save function demonstrates how you might handle saving in a real application. We 
pass both the accumulated diff (showing exactly what changed since last save) and a 
complete snapshot of the current document state to our save function. After saving, 
we reset both the unsaved changes flag and the accumulated diff. In a real application, 
you might send just the diff to minimize bandwidth, or save the full snapshot for 
simpler server-side handling.

[4]
We define our component overrides outside of the React component to keep them static. 
This prevents unnecessary re-renders and follows React best practices. The SaveButton 
component is placed in the TopPanel to provide a prominent save interface.
*/
```

--------

# Signals

Category: Events & effects

Keywords: signia, state, store, side, effects, subscribe, track

React to changes by using signals.

tldraw uses signals to manage its state and store. You can subscribe to values in the store and run
side effects when they change. This example shows some ways of doing that.

## App.tsx

```tsx
import { TLComponents, Tldraw, track, useEditor, useReactor, useValue } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

// [1]
const InfoPanel = track(() => {
	const editor = useEditor()
	const tool = editor.getCurrentToolId()
	const zoom = editor.getZoomLevel().toFixed(2)
	useReactor(
		'change title',
		() => {
			const shapes = editor.getCurrentPageShapes()
			document.title = `shapes: ${shapes.length}`
		},
		[editor]
	)
	return (
		<div style={{ pointerEvents: 'all', backgroundColor: 'thistle', fontSize: 14, padding: 8 }}>
			<div>tool: {tool}</div>
			<div>zoom: {zoom}</div>
		</div>
	)
})

// [2]
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function AlternativeInfoPanel() {
	const editor = useEditor()
	const tool = useValue(
		'current tool',
		() => {
			if (!editor) throw new Error('No editor')
			return `Current Tool: ${editor.getCurrentToolId()}`
		},
		[editor]
	)
	const zoom = useValue(
		'zoom',
		() => {
			if (!editor) throw new Error('No editor')
			return `Zoom Level: ${editor.getZoomLevel().toFixed(2)}`
		},
		[editor]
	)

	return (
		<div style={{ pointerEvents: 'all', backgroundColor: 'thistle', fontSize: 14, padding: 8 }}>
			<div>{tool}</div>
			<div>{zoom}</div>
		</div>
	)
}

const components: TLComponents = {
	SharePanel: InfoPanel,
}

export default function StateStoreExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw components={components} />
		</div>
	)
}

/* 

tldraw uses signals to manage its state and store. You can subscribe to values in the store 
and run side effects when they change.

[1]
	Our InfoPanel component will display above the style panel. We want it to show the current
	selected tool and zoom level of the editor. In order to make sure it displays up-to-date
	information, we can wrap the component in the track function. This will track any signals
	used in the component and re-render it when they change. 
	
	We also use the useReactor hook to update the document title with the number of shapes. This 
	side effect will run whenever the shapes on the page change. We pass the editor as a 
	dependency to the useReactor hook so it will always have the latest editor instance. 
	useQuickReactor runs immediately, whereas useReactor runs on the next animation frame.

[2]
	We can also use the useValue hook to subscribe to a value in the store. You can pass it a 
	value or a function. Functions will be memoized and only re-run when the dependencies change.

*/
```

--------

# Canvas events

Category: Events & effects

Keywords: cursor, pointer, mouse, click, keyboard, handler, input

Listen to events from tldraw's canvas.

This example listens to events from tldraw's canvas and shows them on the right-hand-side. Try moving your cursor, dragging, using modifier keys, etc.

## App.tsx

```tsx
import { useCallback, useState } from 'react'
import { TLEventInfo, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

export default function CanvasEventsExample() {
	const [events, setEvents] = useState<any[]>([])

	const handleEvent = useCallback((data: TLEventInfo) => {
		setEvents((events) => {
			const newEvents = events.slice(0, 100)
			if (
				newEvents[newEvents.length - 1] &&
				newEvents[newEvents.length - 1].type === 'pointer' &&
				data.type === 'pointer' &&
				data.target === 'canvas'
			) {
				newEvents[newEvents.length - 1] = data
			} else {
				newEvents.unshift(data)
			}
			return newEvents
		})
	}, [])

	return (
		<div style={{ display: 'flex' }}>
			<div style={{ width: '50%', height: '100vh' }}>
				<Tldraw
					onMount={(editor) => {
						editor.on('event', (event) => handleEvent(event))
					}}
				/>
			</div>
			<div
				style={{
					width: '50%',
					height: '100vh',
					padding: 8,
					background: '#eee',
					border: 'none',
					fontFamily: 'monospace',
					fontSize: 12,
					borderLeft: 'solid 2px #333',
					display: 'flex',
					flexDirection: 'column-reverse',
					overflow: 'auto',
					whiteSpace: 'pre-wrap',
				}}
				onCopy={(event) => event.stopPropagation()}
			>
				<div>{JSON.stringify(events, undefined, 2)}</div>
			</div>
		</div>
	)
}

/* 
This example shows how to listen to canvas events. This includes things like pointer and 
keyboard events, but not things such as undo/redo, create/delete shapes, etc. Those are store events.

To listen to changes to the store, check out the store events example.
*/
```

--------

# Store events

Category: Events & effects

Keywords: listen, changes

Listen to changes from tldraw's store.

This example listens to changes from tldraw's store and shows them on the right-hand-side. Try creating & deleting shapes, or switching pages. The changes will be logged next to the canvas.

## App.tsx

```tsx
import _ from 'lodash'
import { useCallback, useEffect, useState } from 'react'
import { Editor, TLEventMapHandler, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

export default function StoreEventsExample() {
	const [editor, setEditor] = useState<Editor>()

	const setAppToState = useCallback((editor: Editor) => {
		setEditor(editor)
	}, [])

	const [storeEvents, setStoreEvents] = useState<string[]>([])

	useEffect(() => {
		if (!editor) return

		function logChangeEvent(eventName: string) {
			setStoreEvents((events) => [...events, eventName])
		}

		//[1]
		const handleChangeEvent: TLEventMapHandler<'change'> = (change) => {
			// Added
			for (const record of Object.values(change.changes.added)) {
				if (record.typeName === 'shape') {
					logChangeEvent(`created shape (${record.type})\n`)
				}
			}

			// Updated
			for (const [from, to] of Object.values(change.changes.updated)) {
				if (
					from.typeName === 'instance' &&
					to.typeName === 'instance' &&
					from.currentPageId !== to.currentPageId
				) {
					logChangeEvent(`changed page (${from.currentPageId}, ${to.currentPageId})`)
				} else if (from.id.startsWith('shape') && to.id.startsWith('shape')) {
					let diff = _.reduce(
						from,
						(result: any[], value, key: string) =>
							_.isEqual(value, (to as any)[key]) ? result : result.concat([key, (to as any)[key]]),
						[]
					)
					if (diff?.[0] === 'props') {
						diff = _.reduce(
							(from as any).props,
							(result: any[], value, key) =>
								_.isEqual(value, (to as any).props[key])
									? result
									: result.concat([key, (to as any).props[key]]),
							[]
						)
					}
					logChangeEvent(`updated shape (${JSON.stringify(diff)})\n`)
				}
			}

			// Removed
			for (const record of Object.values(change.changes.removed)) {
				if (record.typeName === 'shape') {
					logChangeEvent(`deleted shape (${record.type})\n`)
				}
			}
		}

		// [2]
		const cleanupFunction = editor.store.listen(handleChangeEvent, { source: 'user', scope: 'all' })

		return () => {
			cleanupFunction()
		}
	}, [editor])

	return (
		<div style={{ display: 'flex' }}>
			<div style={{ width: '60%', height: '100vh' }}>
				<Tldraw onMount={setAppToState} />
			</div>
			<div
				style={{
					width: '40%',
					height: '100vh',
					padding: 8,
					background: '#eee',
					border: 'none',
					fontFamily: 'monospace',
					fontSize: 12,
					borderLeft: 'solid 2px #333',
					display: 'flex',
					flexDirection: 'column-reverse',
					overflow: 'auto',
				}}
				onCopy={(event) => event.stopPropagation()}
			>
				<pre>{storeEvents}</pre>
			</div>
		</div>
	)
}

/* 
This example shows how to listen to store events. This includes things creating/deleting shapes,
or moving between pages, but not things such as pointer and keyboard events. Those are canvas events.
To listen to changes to the canvas, check out the canvas events example.

[1]
This is the fire hose, it will be called at the end of every transaction. We're checking to see what 
kind of changes were made and logging a more readable message to the to our panel.

[2]
This is the function that subscribes to changes to the store. You pass in the callback function that 
you want to execute along with a handy filter object. In this case, we're only listening to changes
that were made by the user. It also returns a cleanup function that you can shove into the return of 
a useeffect hook.

*/
```

--------

# UI events

Category: Events & effects

Keywords: ui, events, api, x-ray

Listen to UI events.

This example listens to UI events and shows them on the right-hand-side. Try creating & deleting shapes, or switching pages. The events will be logged next to the canvas.

Try selecting tools, using keyboard shortcuts, undo/redo, etc. Events will be logged next to the canvas.

## App.tsx

```tsx
import { Fragment, useCallback, useState } from 'react'
import { TLUiEventHandler, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import { getCodeSnippet } from './codeSnippets'

// There's a guide at the bottom of this file!

export default function UiEventsExample() {
	const [uiEvents, setUiEvents] = useState<string[]>([])

	const handleUiEvent = useCallback<TLUiEventHandler>((name, data: any) => {
		const codeSnippet = getCodeSnippet(name, data)
		setUiEvents((events) => [
			...events,
			`event: ${name} ${JSON.stringify(data)}${codeSnippet && `\ncode:  ${codeSnippet}`}`,
		])
	}, [])

	return (
		<div style={{ display: 'flex' }}>
			<div style={{ width: '60%', height: '100vh' }}>
				<Tldraw onUiEvent={handleUiEvent} />
			</div>
			<div
				style={{
					width: '40%',
					height: '100vh',
					padding: 8,
					background: '#eee',
					border: 'none',
					fontFamily: 'monospace',
					fontSize: 12,
					borderLeft: 'solid 2px #333',
					overflow: 'auto',
				}}
				onCopy={(event) => event.stopPropagation()}
			>
				{uiEvents.map((t, i) => (
					<Fragment key={i}>
						<pre style={{ borderBottom: '1px solid #000', marginBottom: 0, paddingBottom: '12px' }}>
							{t}
						</pre>
					</Fragment>
				))}
			</div>
		</div>
	)
}

/* 
This example shows how to listen to UI events. This includes includes things like selecting a tool,
grouping shapes, zooming etc. Events are included even if they are triggered by a keyboard shortcut.
However, interactions with the style panel are not included. For a full list of events and sources,
check out the TLUiEventSource and TLUiEventMap types.

It also shows the relevant code snippet for each event. This is useful for debugging and learning
the tldraw SDK.

We can pass a handler function to the onUiEvent prop of the Tldraw component. This handler function
will be called with the name of the event and the data associated with the event. We're going to 
display these events in a list on the right side of the screen.

To listen to canvas events or changes to the store, check out the canvas events and store events 
examples.

*/
```

## codeSnippets.ts

```ts
const STYLE_EVENT = {
	'tldraw:color': 'DefaultColorStyle',
	'tldraw:dash': 'DefaultDashStyle',
	'tldraw:fill': 'DefaultFillStyle',
	'tldraw:font': 'DefaultFontStyle',
	'tldraw:horizontalAlign': 'DefaultHorizontalAlignStyle',
	'tldraw:size': 'DefaultSizeStyle',
	'tldraw:verticalAlign': 'DefaultVerticalAlignStyle',
	'tldraw:geo': 'GeoShapeGeoStyle',
}

const REORDER_EVENT = {
	toFront: 'bringToFront',
	forward: 'bringForward',
	backward: 'sendBackward',
	toBack: 'sendToBack',
}

const SHAPES_META_EVENT = {
	'group-shapes': 'groupShapes',
	'ungroup-shapes': 'ungroupShapes',
	'delete-shapes': 'deleteShapes',
}

const SHAPES_EVENT = {
	'distribute-shapes': 'distributeShapes',
	'align-shapes': 'alignShapes',
	'stretch-shapes': 'stretchShapes',
	'flip-shapes': 'flipShapes',
}

const USER_PREFS_EVENT = {
	'toggle-snap-mode': 'isSnapMode',
	'toggle-dark-mode': 'isDarkMode',
	'toggle-reduce-motion': 'animationSpeed',
	'toggle-edge-scrolling': 'edgeScrollSpeed',
}

const PREFS_EVENT = {
	'toggle-transparent': 'exportBackground',
	'toggle-tool-lock': 'isToolLocked',
	'toggle-focus-mode': 'isFocusMode',
	'toggle-grid-mode': 'isGridMode',
	'toggle-debug-mode': 'isDebugMode',
}

const ZOOM_EVENT = {
	'zoom-in': 'zoomIn',
	'zoom-out': 'zoomOut',
	'reset-zoom': 'resetZoom',
	'zoom-to-fit': 'zoomToFit',
	'zoom-to-selection': 'zoomToSelection',
}

export function getCodeSnippet(name: string, data: any) {
	let codeSnippet = ''

	if (name === 'set-style') {
		if (data.id === 'opacity') {
			codeSnippet = `editor.setOpacityForNextShapes(${data.value});`
		} else {
			codeSnippet = `editor.setStyleForNextShapes(${
				STYLE_EVENT[data.id as keyof typeof STYLE_EVENT] ?? '?'
			}, '${data.value}');`
		}
	} else if (['rotate-ccw', 'rotate-cw'].includes(name)) {
		codeSnippet = 'editor.rotateShapesBy(editor.getSelectedShapeIds(), <number>)'
	} else if (name === 'edit-link') {
		codeSnippet =
			'editor.updateShapes([{ id: editor.getOnlySelectedShape().id, type: editor.getOnlySelectedShape().type, props: { url: <url> }, }, ])'
	} else if (name.startsWith('export-as')) {
		codeSnippet = `exportAs(editor.getSelectedShapeIds(), '${data.format}')`
	} else if (name.startsWith('copy-as')) {
		codeSnippet = `copyAs(editor.getSelectedShapeIds(), '${data.format}')`
	} else if (name === 'select-all-shapes') {
		codeSnippet = `editor.selectAll()`
	} else if (name === 'select-none-shapes') {
		codeSnippet = `editor.selectNone()`
	} else if (name === 'reorder-shapes') {
		codeSnippet = `editor.${
			REORDER_EVENT[data.operation as keyof typeof REORDER_EVENT] ?? '?'
		}(editor.getSelectedShapeIds())`
	} else if (['group-shapes', 'ungroup-shapes', 'delete-shapes'].includes(name)) {
		codeSnippet = `editor.${
			SHAPES_META_EVENT[name as keyof typeof SHAPES_META_EVENT] ?? '?'
		}(editor.getSelectedShapeIds())`
	} else if (name === 'stack-shapes') {
		codeSnippet = `editor.stackShapes(editor.getSelectedShapeIds(), '${data.operation}', 16)`
	} else if (name === 'pack-shapes') {
		codeSnippet = `editor.packShapes(editor.getSelectedShapeIds(), 16)`
	} else if (name === 'duplicate-shapes') {
		codeSnippet = `editor.duplicateShapes(editor.getSelectedShapeIds(), {x: <value>, y: <value>})`
	} else if (name.endsWith('-shapes')) {
		codeSnippet = `editor.${
			SHAPES_EVENT[name as keyof typeof SHAPES_EVENT] ?? '?'
		}(editor.getSelectedShapeIds(), '${data.operation}')`
	} else if (name === 'select-tool') {
		if (data.id === 'media') {
			codeSnippet = 'insertMedia()'
		} else if (data.id.startsWith('geo-')) {
			codeSnippet = `\n  editor.updateInstanceState({
  stylesForNextShape: {
    ...editor.getInstanceState().stylesForNextShape,
    [GeoShapeGeoStyle.id]: '${data.id.replace('geo-', '')}',
  },
}, { ephemeral: true });
editor.setCurrentTool('${data.id}')`
		} else {
			codeSnippet = `editor.setCurrentTool('${data.id}')`
		}
	} else if (name === 'print') {
		codeSnippet = 'printSelectionOrPages()'
	} else if (name === 'unlock-all') {
		codeSnippet = `\n  const updates = [] as TLShapePartial[]
for (const shape of editor.getCurrentPageShapes()) {
  if (shape.isLocked) {
    updates.push({ id: shape.id, type: shape.type, isLocked: false })
  }
}
if (updates.length > 0) {
  editor.updateShapes(updates)
}`
	} else if (['undo', 'redo'].includes(name)) {
		codeSnippet = `editor.${name}()`
	} else if (['cut', 'copy'].includes(name)) {
		codeSnippet = `\n  const { ${name} } = useMenuClipboardEvents();\n  ${name}()`
	} else if (name === 'paste') {
		codeSnippet = `\n  const { paste } = useMenuClipboardEvents();\n  navigator.clipboard?.read().then((clipboardItems) => {\n    paste(clipboardItems)\n  })`
	} else if (name === 'stop-following') {
		codeSnippet = `editor.stopFollowingUser()`
	} else if (name === 'exit-pen-mode') {
		codeSnippet = `editor.updateInstanceState({ isPenMode: false })`
	} else if (name === 'remove-frame') {
		codeSnippet = `removeFrame(editor, editor.getSelectedShapes().map((shape) => shape.id))`
	} else if (name === 'fit-frame-to-content') {
		codeSnippet = `fitFrameToContent(editor, editor.getOnlySelectedShape().id)`
	} else if (name.startsWith('zoom-') || name === 'reset-zoom') {
		codeSnippet = `editor.${ZOOM_EVENT[name as keyof typeof ZOOM_EVENT]}(${
			name !== 'zoom-to-fit' && name !== 'zoom-to-selection'
				? 'editor.getViewportScreenCenter(), '
				: ''
		}{ duration: 320 })`
	} else if (name.startsWith('toggle-')) {
		if (name === 'toggle-lock') {
			codeSnippet = `editor.toggleLock(editor.getSelectedShapeIds())`
		} else {
			const userPrefName = USER_PREFS_EVENT[name as keyof typeof USER_PREFS_EVENT]
			const prefName = PREFS_EVENT[name as keyof typeof PREFS_EVENT]
			codeSnippet = userPrefName
				? `editor.user.updateUserPreferences({ ${userPrefName}: <value> })`
				: `editor.updateInstanceState({ ${prefName}: !editor.getInstanceState().${prefName} })`
		}
	}

	return codeSnippet
}
```

--------

# Block events

Category: Events & effects

Keywords: event, block, propagation, stop, no, select, user-select

Stop events from reaching the canvas.

If you don't want the user's interactions to reach the canvas, you can call `stopPropagation` on the user's pointer events.

## App.tsx

```tsx
import { TLComponents, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

function WelcomeScreen() {
	return (
		<div
			style={{
				position: 'absolute',
				inset: 0,
				display: 'flex',
				alignItems: 'center',
				justifyContent: 'center',
				pointerEvents: 'none', // [1]
			}}
		>
			<div
				style={{
					padding: 32,
					borderRadius: 20,
					boxShadow: '2px 2px 12px rgba(0,0,0,.2)',
					backgroundColor: 'white',
					pointerEvents: 'all', // [2]
					width: 400,
				}}
			>
				<p
					style={{
						userSelect: 'text', // [3]
					}}
				>
					Notice that if you click on this box or start a drag from in here, you will not be
					interacting with the canvas. However, you can still interact with the canvas by clicking
					anywhere else!
				</p>
				<div>
					<button onClick={() => window.alert('Thanks')}>Click here</button>
				</div>
			</div>
		</div>
	)
}

const components: TLComponents = {
	InFrontOfTheCanvas: WelcomeScreen,
}

export default function EventBlockerExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example" components={components} />
		</div>
	)
}

/*
[1]
This div will overlay the whole canvas. We want the user's pointer events to
pass through this div rather than getting blocked by it div, so we turn
pointer events off.

[2]
This is the container that's centered on the screen. For this div, we want to
block pointer events so that the user can't interact with the canvas behind it,
so we turn pointer events on.

[3]
As a side note, we also turn off user-select for anything inside of the canvas.
If you want the user to be able to select text, you can set this style to 'all'.
*/
```

--------

# Prevent instance changes

Category: Events & effects

Keywords: side, effect, instance, grid, mode, prevent

Prevent a change to the "instance" record that would turn off grid mode.

You can use Editor's side effects API to prevent certain changes from occurring in the instance state. In this example, we prevent the user from changing the instance's `isGridMode` property.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this page!

export default function PreventInstanceChangeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					editor.updateInstanceState({ isGridMode: true })

					// [1]
					editor.sideEffects.registerBeforeChangeHandler('instance', (prev, next) => {
						if (!next.isGridMode) {
							return prev
						}
						return next
					})
				}}
			/>
		</div>
	)
}

/*
In this example, we want to prevent the user from changing the isGridMode property.

[1]
Here we register a handler that will run whenever a change is about to be made to
to an "instance" type record.

The logic we want is that: if the new instance has `isGridMode` set to `false`, then
we want to reject the change; otherwise, we want to allow it.

To reject the change, we return the previous record. To allow the change, we
return the next record.
*/
```

--------

# Prevent shape changes

Category: Events & effects

Keywords: side, effect, move, prevent

Prevent changes to a shape's properties.

You can use Editor's side effects API to prevent certain changes from occurring in a shape. In this example, we prevent any changes to the shape's position, rotation, or size.

## App.tsx

```tsx
import { TLGeoShape, Tldraw, toRichText } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this page!

export default function PreventMoveExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					editor.createShape<TLGeoShape>({
						type: 'geo',
						x: 100,
						y: 100,
						props: {
							w: 300,
							h: 300,
							richText: toRichText("style me but don't transform me"),
						},
					})

					// [1]
					editor.sideEffects.registerBeforeChangeHandler('shape', (prev, next) => {
						if (
							editor.isShapeOfType<TLGeoShape>(prev, 'geo') &&
							editor.isShapeOfType<TLGeoShape>(next, 'geo') &&
							next.props.geo === 'rectangle'
						) {
							if (
								next.x !== prev.x ||
								next.y !== prev.y ||
								next.rotation !== prev.rotation ||
								next.props.w !== prev.props.w ||
								next.props.h !== prev.props.h
							) {
								return prev
							}
						}
						return next
					})
				}}
			/>
		</div>
	)
}

/*
[1]
Here we register a handler that will run whenever a change is about to be made to
a shape's record.

The logic we want is that: if the shape is a geo shape and a rectangle, and then
if the x, y, or rotation properties would be different in the next version of
the shape record, or if the props.w, or props.h properties would change, then
we want to reject the change; otherwise, we want to allow it.

To reject the change, we return the previous record. To allow the change, we
return the next record.
*/
```

--------

# Prevent multi-shape selection

Category: Events & effects

Keywords: selection, editor, instance, state

This example demonstrates how to prevent users from selecting multiple shapes at once in tldraw.

You can prevent multiple shape selection by registering a before-change handler for the `instance_page_state` type. This handler intercepts selection changes and ensures only one shape can be selected at a time.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function PreventMultiShapeSelectionExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					// [1]
					editor.sideEffects.registerBeforeChangeHandler('instance_page_state', (prev, next) => {
						// [2]
						if (
							prev.selectedShapeIds !== next.selectedShapeIds &&
							next.selectedShapeIds.length > 1
						) {
							return {
								...next,
								selectedShapeIds: [next.selectedShapeIds[next.selectedShapeIds.length - 1]],
							}
						}
						return next
					})
				}}
			/>
		</div>
	)
}

/*
In this example, we want to prevent the user from selecting multiple shapes at once.

[1]
Here we register a handler that will run whenever a change is about to be made to
an "instance_page_state" type record, which contains the current selection state.

[2]
We check if this is a selection change and if it would result in multiple shapes being selected.
If both conditions are true, we modify the change to only select the most recently
selected shape by returning a new record with a single selected shape id.
*/
```

--------

# Before create/update shape

Category: Events & effects

Keywords: handler, register, side effects, records

Register a handler to run before shapes are created or updated.

You can intercept the creation or update of any record in the store and return a new record to be
used in it place. In this example, we lock shapes to a circle in the center of the screen.

## App.tsx

```tsx
import { Box, Editor, SVGContainer, TLShape, Tldraw, Vec, isShapeId } from 'tldraw'
import 'tldraw/tldraw.css'

// This function takes a shape and returns a new shape where the x/y origin is within `radius`
// distance of the center of the page. If the shape is already within `radius` (or isn't parented to
// the page) it returns the same shape.
function constrainShapeToRadius(editor: Editor, shape: TLShape, radius: number) {
	// if the shape is parented to another shape (instead of the page) leave it as-is
	if (isShapeId(shape.parentId)) return shape

	// get the position of the shape
	const shapePoint = Vec.From(shape)
	const distanceFromCenter = shapePoint.len()

	// if the shape is outside the radius, move it to the edge of the radius:
	if (distanceFromCenter > radius) {
		const newPoint = shapePoint.uni().mul(radius)
		return {
			...shape,
			x: newPoint.x,
			y: newPoint.y,
		}
	}

	// otherwise, leave the shape as-is
	return shape
}

export default function BeforeCreateUpdateShapeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					// we can run our `constrainShapeToRadius` function before any shape is created
					// or changed. These `sideEffects` handlers let us take modify the shape that
					// will be created or updated by returning a new one to be used in its place.
					editor.sideEffects.registerBeforeCreateHandler('shape', (shape) => {
						return constrainShapeToRadius(editor, shape, 500)
					})
					editor.sideEffects.registerBeforeChangeHandler('shape', (prevShape, nextShape) => {
						return constrainShapeToRadius(editor, nextShape, 500)
					})

					// center the camera on the area we're constraining shapes to
					editor.zoomToBounds(new Box(-500, -500, 1000, 1000))

					// lock the camera on that area
					editor.setCameraOptions({ isLocked: true })
				}}
				components={{
					// to make it a little clearer what's going on in this example, we'll draw a
					// circle on the canvas showing where shapes are being constrained to.
					OnTheCanvas: () => (
						<SVGContainer>
							<circle cx={0} cy={0} r={500} fill="none" stroke="black" />
						</SVGContainer>
					),
				}}
			/>
		</div>
	)
}
```

--------

# Before delete shape

Category: Events & effects

Keywords: handler, register, side effects, records

Register a handler to run before shapes are deleted.

You can intercept the creation of any record in the store. This example intercepts arrow creation to
make sure each arrow has a label. You can do the same thing to change the props of any newly created
shape.

## App.tsx

```tsx
import { Editor, Tldraw, createShapeId, toRichText } from 'tldraw'
import 'tldraw/tldraw.css'

export default function BeforeDeleteShapeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					// register a handler to run before any shape is deleted:
					editor.sideEffects.registerBeforeDeleteHandler('shape', (shape) => {
						// if the shape is red, prevent the deletion:
						if ('color' in shape.props && shape.props.color === 'red') {
							return false
						}

						return
					})

					createDemoShapes(editor)
				}}
			/>
		</div>
	)
}

// create some shapes to demonstrate the side-effect we added
function createDemoShapes(editor: Editor) {
	editor
		.createShapes([
			{
				id: createShapeId(),
				type: 'text',
				props: {
					richText: toRichText("Red shapes can't be deleted"),
					color: 'red',
				},
			},
			{
				id: createShapeId(),
				type: 'text',
				y: 30,
				props: {
					richText: toRichText('but other shapes can'),
					color: 'black',
				},
			},
		])
		.zoomToFit({ animation: { duration: 0 } })
}
```

--------

# Custom double-click behavior

Category: Events & effects

Keywords: double click, runtime override, state node, select tool, custom behavior

Override the default double-click behavior by replacing the SelectTool's Idle state method at runtime.

This example shows how to customize the double-click behavior on canvas by overriding the SelectTool's Idle state's `handleDoubleClickOnCanvas` method from the `onMount` callback.

The example demonstrates runtime method replacement, which is a powerful technique for customizing built-in tool behavior without creating entirely new tools. In this simplified version, double-clicking on the canvas shows an alert instead of creating a text shape, demonstrating the basic pattern for method override.

This pattern is useful when you want to extend existing tool behavior, add conditional logic, or customize built-in interactions without forking the entire tool.

## App.tsx

```tsx
import { StateNode, TLClickEventInfo, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

export default function CustomDoubleClickBehaviorExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// [1]
				onMount={(editor) => {
					// [2]
					type IdleStateNode = StateNode & {
						handleDoubleClickOnCanvas(info: TLClickEventInfo): void
					}

					// [3]
					const selectIdleState = editor.getStateDescendant<IdleStateNode>('select.idle')
					if (!selectIdleState) throw Error('SelectTool Idle state not found')

					// [4]
					function customDoubleClickOnCanvasHandler(_info: TLClickEventInfo) {
						// Your custom behavior goes here...
						window.alert('double clicked on the canvas')
					}

					// [5]
					selectIdleState.handleDoubleClickOnCanvas =
						customDoubleClickOnCanvasHandler.bind(selectIdleState)
				}}
			/>
		</div>
	)
}

/*
This example demonstrates how to customize the double-click behavior on canvas
by overriding the SelectTool's Idle state's handleDoubleClickOnCanvas method.

Key concepts:

[1] onMount callback:
    The onMount callback gives us access to the editor instance after it's 
    fully initialized. This is where we can access and modify built-in tools.

[2] Type definition for IdleStateNode:
    We create a type that extends StateNode and includes the handleDoubleClickOnCanvas
    method. This gives us proper TypeScript support when accessing the method.

[3] Getting the SelectTool's Idle state:
    We use `editor.getStateDescendant<IdleStateNode>('select.idle')` to get a 
    reference to the Idle state of the SelectTool. The path 'select.idle' 
    refers to the SelectTool's 'idle' child state.

[4] Custom handler function:
    We define our custom behavior in a separate function. This keeps the code
    clean and makes it easy to test or reuse the handler logic.

[5] Method replacement with binding:
    We replace the original handleDoubleClickOnCanvas method with our custom
    implementation, binding it to the selectIdleState context so that `this`
    refers to the correct state node when the function is called. This 
    completely overrides the default behavior.

The handleDoubleClickOnCanvas method is called when the user double-clicks on
the canvas (not on a shape). By overriding this method, we can customize what
happens when the user double-clicks on empty space.

Note: This approach completely replaces the original method. If you want to 
preserve the original behavior and add to it, you should store a reference
to the original method before replacing it, then call it from your custom
implementation when appropriate.
*/
```

--------

# After create/update shape

Category: Events & effects

Keywords: handler, register, side effects, records

Register a handler to run after shapes are created or updated.

You can register handlers to run after any record is created or updated. This is most useful for
updating _other_ records in response to a particular record changing. In this example, we make sure
there's only ever one red shape on a page.

## App.tsx

```tsx
import { Editor, TLShape, TLShapeId, Tldraw, createShapeId, toRichText } from 'tldraw'

// this function takes a shape ID, and if that shape is red, sets all other red shapes on the same
// page to black.
function ensureOnlyOneRedShape(editor: Editor, shapeId: TLShapeId) {
	// grab the shape and check it's red:
	const shape = editor.getShape(shapeId)!
	if (!isRedShape(shape)) return

	// get the ID of the page that shape belongs to:
	const pageId = editor.getAncestorPageId(shape.id)!

	// find any other red shapes on the same page:
	const otherRedShapesOnPage = Array.from(editor.getPageShapeIds(pageId))
		.map((id) => editor.getShape(id)!)
		.filter((otherShape) => otherShape.id !== shape.id && isRedShape(otherShape))

	// set the color of all those shapes to black:
	editor.updateShapes(
		otherRedShapesOnPage.map((shape) => ({
			id: shape.id,
			type: shape.type,
			props: {
				color: 'black',
			},
		}))
	)
}

function isRedShape(shape: TLShape) {
	return 'color' in shape.props && shape.props.color === 'red'
}

export default function AfterCreateUpdateShapeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					// we can run our `ensureOnlyOneRedShape` function after any shape is created or
					// changed. this means we can enforce our "only one red shape at a time" rule,
					// while making sure that the shape most recently set to red is the one that
					// stays red.
					editor.sideEffects.registerAfterCreateHandler('shape', (shape) => {
						ensureOnlyOneRedShape(editor, shape.id)
					})
					editor.sideEffects.registerAfterChangeHandler('shape', (prevShape, nextShape) => {
						ensureOnlyOneRedShape(editor, nextShape.id)
					})

					createDemoShapes(editor)
				}}
			/>
		</div>
	)
}

// create some shapes to demonstrate the side-effects we added
function createDemoShapes(editor: Editor) {
	editor
		.createShapes(
			'there can only be one red shape'.split(' ').map((word, i) => ({
				id: createShapeId(),
				type: 'text',
				y: i * 30,
				props: {
					color: i === 5 ? 'red' : 'black',
					richText: toRichText(word),
				},
			}))
		)
		.zoomToFit({ animation: { duration: 0 } })
}
```

--------

# After delete shape

Category: Events & effects

Keywords: handler, register, side effects, records

Register a handler to run after shapes are deleted.

You can register handlers to run after any record is deleted. In this example, we delete frames
after the last shape inside them is deleted.

## App.tsx

```tsx
import { Editor, Tldraw, createShapeId, toRichText } from 'tldraw'
import 'tldraw/tldraw.css'

export default function AfterDeleteShapeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					// register a handler to run after any shape is deleted:
					editor.sideEffects.registerAfterDeleteHandler('shape', (shape) => {
						// grab the parent of the shape and check if it's a frame:
						const parentShape = editor.getShape(shape.parentId)
						if (parentShape && parentShape.type === 'frame') {
							// if it is, get the IDs of all its remaining children:
							const siblings = editor.getSortedChildIdsForParent(parentShape.id)

							// if there are none (so the frame is empty), delete the frame:
							if (siblings.length === 0) {
								editor.deleteShape(parentShape.id)
							}
						}
					})

					createDemoShapes(editor)
				}}
			/>
		</div>
	)
}

// crate some demo shapes to show off the new side-effect we added
function createDemoShapes(editor: Editor) {
	const frameId = createShapeId()
	editor.createShapes([
		{
			id: frameId,
			type: 'frame',
			props: { w: 400, h: 200 },
		},
		{
			id: createShapeId(),
			type: 'text',
			parentId: frameId,
			x: 50,
			y: 40,
			props: {
				richText: toRichText('Frames will be deleted when their last child is.'),
				w: 300,
				autoSize: false,
			},
		},
		...[50, 180, 310].map((x) => ({
			id: createShapeId(),
			type: 'geo',
			parentId: frameId,
			x,
			y: 120,
			props: { w: 40, h: 40 },
		})),
	])

	editor.zoomToFit({ animation: { duration: 0 } })
}
```

--------

# Derived view

Category: Events & effects

Keywords: basic, intro, simple, quick, start

Derive data from the editor's document in an efficient way.

You can use incremental derivations to get a specific view of data.

## App.tsx

```tsx
import { isUninitialized, RESET_VALUE } from '@tldraw/state'
import { useMemo, useRef } from 'react'
import { computed, Editor, isShape, Tldraw, TLShapeId, useEditor, useValue } from 'tldraw'
import 'tldraw/tldraw.css'

export default function DerivedViewExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="derived-view">
				<ShowNumberOfDrawShapesOnPage />
			</Tldraw>
		</div>
	)
}

function ShowNumberOfDrawShapesOnPage() {
	const editor = useEditor()
	const rRenders = useRef(0)

	// Create a computed value that tracks the number of draw shapes in the document, returning a set of ids
	const computed = useMemo(() => deriveNumberOfDrawShapesInDocument(editor), [editor])
	// Get the size of the computed value whenever the computed value changes
	const value = useValue('computed value', () => computed.get().size, [computed])

	return (
		<div style={{ position: 'absolute', top: 50, left: 20, zIndex: 99999 }}>
			<p>{value} draw shapes in project</p>
			{/* Will go up by two in dev, NAB */}
			<p>{rRenders.current++} renders</p>
		</div>
	)
}

export const deriveNumberOfDrawShapesInDocument = (editor: Editor) => {
	const { store } = editor
	const shapesIndex = store.query.ids('shape')

	// Create an index of all the shape ids of all the draw shapes
	function fromScratch() {
		return new Set([...shapesIndex.get()].filter((id) => editor.getShape(id)!.type === 'draw'))
	}

	return computed<Set<TLShapeId>>('_shapeIdsInCurrentPage', (prevValue, lastComputedEpoch) => {
		// On first load, return the initial value
		if (isUninitialized(prevValue)) {
			return fromScratch()
		}

		// Get the changes since the last computed value
		const diff = store.history.getDiffSince(lastComputedEpoch)

		// Something caused the store to reset, compute a new value from scratch
		if (diff === RESET_VALUE) {
			return fromScratch()
		}

		// This will be the new set that includes the changes, if we find any
		let nextValue: Set<TLShapeId> | undefined

		for (const changes of diff) {
			// Check all of the added records for new draw shapes
			for (const record of Object.values(changes.added)) {
				if (isShape(record) && record.type === 'draw') {
					// If we haven't created the new set yet, do it now
					if (!nextValue) {
						nextValue = new Set(prevValue)
					}
					// mutate the new set
					nextValue.add(record.id)
				}
			}

			for (const record of Object.values(changes.removed)) {
				// Check all of the removed records for deleted draw shapes
				if (isShape(record) && record.type === 'draw') {
					// If we haven't created the new set yet, do it now
					if (!nextValue) {
						nextValue = new Set(prevValue)
					}
					// mutate the new set
					nextValue.delete(record.id)
				}
			}
		}

		// if something changed, return the new value
		if (nextValue) return nextValue

		// if nothing changed, return the previous value
		return prevValue
	})
}
```

--------

# Shape meta (on change)

Category: Events & effects

Keywords: side, effects, register, change, initial

Add custom metadata to shapes when they're changed.

We can update a shape's metadata whenever it changes. A UI displays the current selected shape's metadata. Create a shape, select it, and move it around. The metadata will updated any time the shape changes.

## App.tsx

```tsx
import { TLShape, Tldraw, track, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

export default function OnChangeShapeMetaExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="tldraw_change_meta_example"
				onMount={(editor) => {
					// [1]
					editor.getInitialMetaForShape = (_shape) => {
						return {
							updatedBy: editor.user.getId(),
							updatedAt: Date.now(),
						}
					}
					// [2]
					editor.sideEffects.registerBeforeChangeHandler('shape', (_prev, next, source) => {
						if (source !== 'user') return next
						return {
							...next,
							meta: {
								updatedBy: editor.user.getId(),
								updatedAt: Date.now(),
							},
						}
					})
				}}
			>
				<MetaUiHelper />
			</Tldraw>
		</div>
	)
}

// [3]
type ShapeWithMyMeta = TLShape & { meta: { updatedBy: string; updatedAt: string } }

// [4]
export const MetaUiHelper = track(function MetaUiHelper() {
	const editor = useEditor()
	const onlySelectedShape = editor.getOnlySelectedShape() as ShapeWithMyMeta | null

	return (
		<pre style={{ position: 'absolute', zIndex: 300, top: 64, left: 12, margin: 0 }}>
			{onlySelectedShape
				? JSON.stringify(onlySelectedShape.meta, null, '\t')
				: 'Select one shape to see its meta data.'}
		</pre>
	)
})

/* 
This example shows how to add meta data to shapes when they are created and
updated. In this case we are adding `updatedBy` and `updatedAt` fields.

[1]
getInitialMetaForShape is a method you can replace at runtime. Here we use 
a callback on the onMount prop to replace the default implementation with 
our own.

[2]
Here we're using the side effects API to add meta data to shapes when they are
updated. You can use the side effects API to do something on create, update or
delete, and you can target many things including: shapes, pages, the camera, 
the pointer etc.

[3]
All tldraw shapes have a meta property with a type of unknown. To type your 
meta data you can use a union like this.

[4]
A minimal ui component that displays the meta data of the selected shape. We 
use track to make sure that the component is re-rendered when the signals it's 
tracking change. Check out the signals example for more info: 
https://tldraw.dev/examples/signals
*/
```

--------

# Shape meta (on create)

Category: Events & effects

Keywords: side, effects, initial, meta, register

Add custom metadata to shapes when they're created.

We can update a shape's metadata whenever it is created. A UI displays the current selected shape's metadata. Create a shape and select it. The metadata will display its created at / created by data.

## App.tsx

```tsx
import { TLShape, Tldraw, track, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

export default function OnCreateShapeMetaExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="example"
				onMount={(editor) => {
					//[1]
					editor.getInitialMetaForShape = (_shape) => {
						return {
							createdBy: editor.user.getId(),
							createdAt: Date.now(),
						}
					}
				}}
			>
				<MetaUiHelper />
			</Tldraw>
		</div>
	)
}

// [2]
type ShapeWithMyMeta = TLShape & { meta: { updatedBy: string; updatedAt: string } }

// [3]
export const MetaUiHelper = track(function MetaUiHelper() {
	const editor = useEditor()
	const onlySelectedShape = editor.getOnlySelectedShape() as ShapeWithMyMeta | null

	return (
		<pre style={{ position: 'absolute', zIndex: 300, top: 64, left: 12, margin: 0 }}>
			{onlySelectedShape
				? JSON.stringify(onlySelectedShape.meta, null, '\t')
				: 'Select one shape to see its meta data.'}
		</pre>
	)
})

/* 
This example demonstrates how to add your own data to shapes using the meta property as they're
created. Check out the docs for a more detailed explanation of the meta property: 
https://tldraw.dev/docs/shapes#Meta-information

[1]
getInitialMetaForShape is a method you can replace at runtime. Here we use a callback on the onMount
prop to replace the default implementation with our own.

[2]
All tldraw shapes have a meta property with a type of unknown. To type your meta data you can use 
a union like this.

[3]
A minimal ui component that displays the meta data of the selected shape. We use track to make sure
that the component is re-rendered when the signals it's tracking change. Check out the signals example
for more info: https://tldraw.dev/examples/signals

*/
```

--------

# Permissions

Category: Events & effects

Keywords: permissions, effect, side, user

Create a hacky version of permissions in tldraw using `meta` properties and side effects.

While there isn't (yet) a permissions API in tldraw, you can achieve a similar effect using shape `meta` tags and side effects.

In this example, a shape can only be updated for five seconds after it is created. It can only be deleted _after_ five seconds. To achieve this, we'll store a `createdAt` time on each shape and then use this time to prevent certain changes or deletes. You might use a similar system to stash a `createdBy` properties on the shape's `meta` object and then prevent users from deleting or changing shapes that they didn't create.

## App.tsx

```tsx
import { JsonObject, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

interface MyMeta extends JsonObject {
	createdAt: number
}

export default function PermissionsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="permissions"
				onMount={(e) => {
					// [1]
					e.getInitialMetaForShape = (_shape) => {
						{
							return {
								createdAt: Date.now(),
							}
						}
					}

					// [1.5]
					// e.sideEffects.registerBeforeCreateHandler('shape', (shape, source) => {
					// 	if (source === 'remote') return shape
					// 	return { ...shape, meta: { createdAt: Date.now() } }
					// })

					// [2]
					e.sideEffects.registerBeforeDeleteHandler('shape', (shape, source) => {
						if (source === 'remote') return
						const meta = shape.meta as MyMeta
						if (Date.now() - meta.createdAt < 1000 * 5) return false
						return
					})

					// [3]
					e.sideEffects.registerBeforeChangeHandler('shape', (prev, next, source) => {
						if (source === 'remote') return next
						const meta = next.meta as MyMeta
						if (Date.now() - meta.createdAt > 1000 * 5) return prev
						return next
					})
				}}
			/>
		</div>
	)
}

/*
If you run this example, you'll see that you can't delete a shape that was created less than 5 seconds ago,
and you can't modify a shape that was created more than 5 seconds ago. This is a simple example of how you
can use permissions to control what users can do in the editor.

In your app, you probably have an ID that could be associated with a user. You could use this ID to prevent
users from modifying or deleting shapes that they didn't create. You could also use this ID to prevent users
from modifying, deleting, or perhaps even unlocking certain template shapes. This system could also be dynamic,
such as checking your user's permission level (something like "change-all", "change-own", "change-none") to 
determine what they can or can't do.

Remember that tldraw also has a readonly mode, which can be set on the editor component. (If you wanted to be
extra safe, you could also prevent changes in the client to the readonly mode using the side effect system).

[1]
When a user creates a shape, the editor calls the `getInitialMetaForShape` method. If we want to set the meta
automatically for a shape, we can override the editor's `getInitialMetaForShape` method.

[1.5]
Alternatively, you can use the `beforeCreate` side effect to set the meta for a shape. But be careful! 
This side effect runs whenever a shape record is created for any reason, including when a shape is 
re-created by undoing a deleted shape. If you only want to set the meta when a shape is first created, you
should use `getInitialMetaForShape`.

[2]
The `beforeDelete` side effect runs when a user tries to delete a shape. If we want to prevent a shape
from being deleted, we can return false from this method. If we return false, the shape will not be deleted.
If your app is multiplayer, you should check the `source` argument to see if the delete was caused by the user
or caused by a remote change.

[3]
A `beforeChange` side effect runs when a user tries to modify a shape. If we want to prevent a shape
from being modified, we can return the previous shape record from this method. Whatever we return from
this method will be the new version of the shape. Like with other side effects, if your app is multiplayer,
you should check the `source` argument to see if the delete was caused by the user or caused by a remote change.
*/
```

--------

# Custom shape wrapper

Category: Shapes & tools

Keywords: 

Customize the wrapper used for each shape in the DOM.

Use a custom shape wrapper to apply a special class names to shapes.

## App.tsx

```tsx
import { forwardRef } from 'react'
import {
	atom,
	DefaultShapeWrapper,
	Editor,
	TLComponents,
	Tldraw,
	TLShapeId,
	TLShapeWrapperProps,
	useValue,
} from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

// [1]
const specialShapeId = atom<TLShapeId | null>('special shape id', null)

// [2]
const CustomShapeWrapper = forwardRef(function CustomShapeWrapper(
	{ children, shape, isBackground }: TLShapeWrapperProps,
	ref: React.Ref<HTMLDivElement>
) {
	// [a]
	const isSpecial = useValue('is special', () => specialShapeId.get() === shape.id, [shape.id])

	// [b]
	return (
		<DefaultShapeWrapper
			ref={ref}
			shape={shape}
			isBackground={isBackground}
			className={isSpecial ? 'custom-special-shape' : undefined}
		>
			{children}
		</DefaultShapeWrapper>
	)
})

// [3]
const components: TLComponents = {
	ShapeWrapper: CustomShapeWrapper,
}

export default function BasicExample() {
	return (
		<div className="tldraw__editor">
			<style>{`
				.custom-special-shape {
					filter: drop-shadow(0 0 3px rgba(255, 0, 0));
				}
			`}</style>
			<Tldraw
				components={components}
				onMount={(editor) => {
					createSomeRandomShapes(editor)

					const timer = setInterval(() => {
						const allShapes = editor.getCurrentPageShapesSorted()
						const randomShape = allShapes[Math.floor(Math.random() * allShapes.length)]
						specialShapeId.set(randomShape.id)
					}, 1000)

					return () => {
						clearInterval(timer)
					}
				}}
			/>
		</div>
	)
}

function createSomeRandomShapes(editor: Editor) {
	const bounds = editor.getViewportPageBounds()
	for (let i = 0; i < 10; i++) {
		editor.createShape({
			type: 'geo',
			x: bounds.x + Math.random() * bounds.width,
			y: bounds.y + Math.random() * bounds.height,
		})
	}
}

/*
Introduction:

You can customize how shapes are wrapped in tldraw by creating a custom shape wrapper component and
passing it to the Tldraw component. In this example, we'll create a custom shape wrapper that adds a
red drop shadow to a randomly selected shape every second.

[1] We create an atom to store the ID of the currently "special" shape. Atoms are part of tldraw's
reactive state system and allow us to create reactive values that can be observed and updated. This
atom will hold the ID of the shape that should have the special styling applied to it.

[2] This is our custom shape wrapper component. Shape wrappers are React components that wrap around
every shape in the editor, allowing you to add custom styling, behavior, or data attributes to
shapes. We use forwardRef to properly forward the ref that tldraw passes to us.

    [a]
    We use the useValue hook to create a reactive value that checks if the current shape is the "special" shape.
    This will automatically update whenever the specialShapeId atom changes. We also check if the shape is filled
    by looking at its props.

    [b]
    We re-use the DefaultShapeWrapper component, but add a custom class to the shape when it's the "special" shape.

[3] We create a components object that tells tldraw to use our custom shape wrapper. The
TLComponents type allows us to override various parts of the tldraw UI, including the ShapeWrapper
component.

[4] In the main component, we add CSS that applies a red drop shadow to any element with the
'custom-special-shape' class. We also set up a timer that randomly selects a shape every second and
makes it the "special" shape by updating the specialShapeId atom.

The shape wrapper approach is useful when you want to:
- Add custom styling to all shapes or specific shapes
- Add data attributes for CSS targeting
- Implement custom behavior that affects how shapes are rendered
- Create visual effects that apply to the shape container rather than the shape content

This is different from custom shapes (like in the CustomShapeExample) because it doesn't change what
the shape is, only how it's wrapped and styled in the editor.
*/
```

--------

# Custom shape

Category: Shapes & tools

Keywords: util

A simple custom shape.

You can create custom shapes in tldraw by creating a shape util and passing it to the Tldraw component.
In this example, we'll create a custom shape that is a simple rectangle with some text inside of it.

## App.tsx

```tsx
import {
	Geometry2d,
	HTMLContainer,
	RecordProps,
	Rectangle2d,
	ShapeUtil,
	T,
	TLBaseShape,
	TLResizeInfo,
	Tldraw,
	resizeBox,
} from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

// [1]
type ICustomShape = TLBaseShape<
	'my-custom-shape',
	{
		w: number
		h: number
		text: string
	}
>

// [2]
export class MyShapeUtil extends ShapeUtil<ICustomShape> {
	// [a]
	static override type = 'my-custom-shape' as const
	static override props: RecordProps<ICustomShape> = {
		w: T.number,
		h: T.number,
		text: T.string,
	}

	// [b]
	getDefaultProps(): ICustomShape['props'] {
		return {
			w: 200,
			h: 200,
			text: "I'm a shape!",
		}
	}

	// [c]
	override canEdit() {
		return false
	}
	override canResize() {
		return true
	}
	override isAspectRatioLocked() {
		return false
	}

	// [d]
	getGeometry(shape: ICustomShape): Geometry2d {
		return new Rectangle2d({
			width: shape.props.w,
			height: shape.props.h,
			isFilled: true,
		})
	}

	// [e]
	override onResize(shape: any, info: TLResizeInfo<any>) {
		return resizeBox(shape, info)
	}

	// [f]
	component(shape: ICustomShape) {
		return <HTMLContainer style={{ backgroundColor: '#efefef' }}>{shape.props.text}</HTMLContainer>
	}

	// [g]
	indicator(shape: ICustomShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}

// [3]
const customShape = [MyShapeUtil]

export default function CustomShapeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				shapeUtils={customShape}
				onMount={(editor) => {
					editor.createShape({ type: 'my-custom-shape', x: 100, y: 100 })
				}}
			/>
		</div>
	)
}

/*
Introduction:

You can create custom shapes in tldraw by creating a shape util and passing it to the Tldraw component.
In this example, we'll create a custom shape that is a simple rectangle with some text inside of it. 

[1] 
Define the shape type. This is a type that extend the `TLBaseShape` generic and defines the shape's 
props. We need to pass in a unique string literal for the shape's type and an object that defines the
shape's props.

[2] 
This is our shape util. In tldraw shape utils are classes that define how a shape behaves and renders.
We can extend the ShapeUtil class and provide the shape type as a generic. If we extended the 
BaseBoxShapeUtil class instead, we wouldn't have define methods such as `getGeometry` and `onResize`.

	[a]
	This is where we define out shape's props and type for the editor. It's important to use the same
	string for the type as we did in [1]. We need to define the shape's props using tldraw's validator 
	library. The validator will help make sure the store always has shape data we can trust.

	[b]
	This is a method that returns the default props for our shape.

	[c]
	Some handy methods for controlling different shape behaviour. You don't have to define these, and 
	they're only shown here so you know they exist. Check out the editable shape example to learn more 
	about creating an editable shape.

	[d]
	The getGeometry method is what the editor uses for hit-testing, binding etc. We're using the
	Rectangle2d class from tldraw's geometry library to create a rectangle shape. If we extended the
	BaseBoxShapeUtil class, we wouldn't have to define this method.

	[e]
	We're using the resizeBox utility method to handle resizing our shape. If we extended the
	BaseBoxShapeUtil class, we wouldn't have to define this method.

	[f]
	The component method defines how our shape renders. We're returning an HTMLContainer here, which
	is a handy component that tldraw exports. It's essentially a div with some special css. There's a
	lot of flexibility here, and you can use any React hooks you want and return any valid JSX.

	[g]
	The indicator is the blue outline around a selected shape. We're just returning a rectangle with the
	same width and height as the shape here. You can return any valid JSX here.

[3]
This is where we render the Tldraw component with our custom shape. We're passing in our custom shape
util as an array to the shapeUtils prop. We're also using the onMount callback to create a shape on 
the canvas. If you want to learn how to add a tool for your shape, check out the custom config example. 
If you want to learn how to programmatically control the canvas, check out the Editor API examples.

*/
```

--------

# Custom tool (sticker)

Category: Shapes & tools

Keywords: state, machine, chart, node, sticker

A simple custom tool.

Tools are nodes in tldraw's state chart. They are responsible for handling user input.

You can create custom tools by extending the `StateNode` class and overriding its methods. In this example we make a very simple sticker tool that adds a heart emoji to the canvas when you click.

## App.tsx

```tsx
import { StateNode, TLTextShape, Tldraw, toRichText } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

const OFFSET = 12

// [1]
class StickerTool extends StateNode {
	static override id = 'sticker'

	// [a]
	override onEnter() {
		this.editor.setCursor({ type: 'cross', rotation: 0 })
	}

	// [b]
	override onPointerDown() {
		const { currentPagePoint } = this.editor.inputs
		this.editor.createShape<TLTextShape>({
			type: 'text',
			x: currentPagePoint.x - OFFSET,
			y: currentPagePoint.y - OFFSET,
			props: { richText: toRichText('â¤ï¸') },
		})
	}
}

// [2]
const customTools = [StickerTool]
export default function CustomToolExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// Pass in the array of custom tool classes
				tools={customTools}
				// Set the initial state to the sticker tool
				initialState="sticker"
				// hide the ui
				hideUi
				// Put some helpful text on the canvas
				onMount={(editor) => {
					editor.createShape<TLTextShape>({
						type: 'text',
						x: 100,
						y: 100,
						props: { richText: toRichText('Click anywhere to add a sticker') },
					})
				}}
			/>
		</div>
	)
}

/* 
Introduction:

Tools are nodes in tldraw's state machine. They are responsible for handling user input. 
You can create custom tools by extending the `StateNode` class and overriding its methods.
In this example we make a very simple sticker tool that adds a heart emoji to the canvas 
when you click. 

[1]
We extend the `StateNode` class to create a new tool called `StickerTool`. We set its id
to "sticker". We are not implementing any child states in this example, so we don't need
to set an initial state or define any children states. To see an example of a custom tool
with child states, check out the screenshot tool or minimal examples.

	[a] The onEnter method is called when the tool is activated. We use it to set the cursor
		to a crosshair.
	
	[b] The onPointerDown method is called when the user clicks on the canvas. We use it to
		create a new shape at the click location. We can get the click location from the
		editor's inputs.

[2]
We pass our custom tool to the Tldraw component using the `tools` prop. We also set the
initial state to our custom tool. We hide the ui and add some helpful text to the canvas 
using the `onMount` prop. This is not necessary for the tool to work but it helps make the 
example more visually clear.
*/
```

--------

# Custom tool (screenshot)

Category: Shapes & tools

Keywords: state chart, state machine, child states

A custom tool that takes a screenshot of the canvas.

Tools are the parts of tldraw's state chart. Most interactions in tldraw are tools.

This example shows how to create a custom tool that takes a screenshot of a specific area of the canvas.

## App.tsx

```tsx
import {
	Box,
	DefaultToolbar,
	DefaultToolbarContent,
	TLComponents,
	TLUiAssetUrlOverrides,
	TLUiOverrides,
	Tldraw,
	TldrawUiMenuItem,
	useEditor,
	useIsToolSelected,
	useTools,
	useValue,
} from 'tldraw'
import 'tldraw/tldraw.css'
import { ScreenshotTool } from './ScreenshotTool/ScreenshotTool'
import { ScreenshotDragging } from './ScreenshotTool/childStates/Dragging'

// There's a guide at the bottom of this file!

// [1]
const customTools = [ScreenshotTool]

// [2]
const customUiOverrides: TLUiOverrides = {
	tools: (editor, tools) => {
		return {
			...tools,
			screenshot: {
				id: 'screenshot',
				label: 'Screenshot',
				icon: 'tool-screenshot',
				kbd: 'j',
				onSelect() {
					editor.setCurrentTool('screenshot')
				},
			},
		}
	},
}

function CustomToolbar() {
	const tools = useTools()
	const isScreenshotSelected = useIsToolSelected(tools['screenshot'])
	return (
		<DefaultToolbar>
			<TldrawUiMenuItem {...tools['screenshot']} isSelected={isScreenshotSelected} />
			<DefaultToolbarContent />
		</DefaultToolbar>
	)
}

// [3]
const customAssetUrls: TLUiAssetUrlOverrides = {
	icons: {
		'tool-screenshot': '/tool-screenshot.svg',
	},
}

// [4]
function ScreenshotBox() {
	const editor = useEditor()

	const screenshotBrush = useValue(
		'screenshot brush',
		() => {
			// Check whether the screenshot tool (and its dragging state) is active
			if (editor.getPath() !== 'screenshot.dragging') return null

			// Get screenshot.dragging state node
			const draggingState = editor.getStateDescendant<ScreenshotDragging>('screenshot.dragging')!

			// Get the box from the screenshot.dragging state node
			const box = draggingState.screenshotBox.get()

			// The box is in "page space", i.e. panned and zoomed with the canvas, but we
			// want to show it in front of the canvas, so we'll need to convert it to
			// "page space", i.e. uneffected by scale, and relative to the tldraw
			// page's top left corner.
			const zoomLevel = editor.getZoomLevel()
			const { x, y } = editor.pageToViewport({ x: box.x, y: box.y })
			return new Box(x, y, box.w * zoomLevel, box.h * zoomLevel)
		},
		[editor]
	)

	if (!screenshotBrush) return null

	return (
		<div
			style={{
				position: 'absolute',
				top: 0,
				left: 0,
				transform: `translate(${screenshotBrush.x}px, ${screenshotBrush.y}px)`,
				width: screenshotBrush.w,
				height: screenshotBrush.h,
				border: '1px solid var(--color-text-0)',
				zIndex: 999,
			}}
		/>
	)
}

const customComponents: TLComponents = {
	InFrontOfTheCanvas: ScreenshotBox,
	Toolbar: CustomToolbar,
}

// [5]
export default function ScreenshotToolExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="tldraw_screenshot_example"
				tools={customTools}
				overrides={customUiOverrides}
				assetUrls={customAssetUrls}
				components={customComponents}
			/>
		</div>
	)
}

/*
Introduction:

This example shows how to create a custom tool. In tldraw, tools are parts of the
tldraw state chart. While the most common use for tools is creating shapes, you can
use tools to create other types of interactions too! In this example, we create a
"screenshot tool" that lets the user draw a box on the canvas. When the user finishes
drawing their box, we'll export (or copy) a screenshot of that area.

[1]
Our custom tool is a class that extends the StateNode class. See the ScreenshotTool
files for more about the too. We define an array (outside of any React component)
to hold the custom tools. We'll pass this into the Tldraw component's `tools` prop.

[2]
Here we make sure the UI knows about our new tool. We do this by adding it to the
`tools` object, which tells other parts of the UI a tool's label, icon, what should
happen when it's selected, etc. We'll pass our customUiOverrides object into the
Tldraw component's `overrides` prop.

[3]
Our toolbar item is using a custom icon, so we need to provide the asset url for it. 
We do this by providing a custom assetUrls object to the Tldraw component. 
This object is a map of icon ids to their urls. The icon ids are the same as the 
icon prop on the toolbar item. We'll pass our assetUrls object into the Tldraw
component's `assetUrls` prop.

[4]
We want to show a box on the canvas when the screenshot tool is active. We do this
by providing an override to the InFrontOfTheCanvas component. This component will be shown
in front of the canvas but behind any other UI elements, such as menus and the toolbar.
We'll pass our components object into the Tldraw component's `components` prop. 

[5]
Finally we pass all of our customizations into the Tldraw component. It's important
that the customizations are defined outside of the React component, otherwise they
will cause the Tldraw component to see them as new values on every render, which may
produce unexpected results.
*/
```

## ScreenshotTool.ts

```ts
import { StateNode } from 'tldraw'
import { ScreenshotDragging } from './childStates/Dragging'
import { ScreenshotIdle } from './childStates/Idle'
import { ScreenshotPointing } from './childStates/Pointing'

// There's a guide at the bottom of this file!

export class ScreenshotTool extends StateNode {
	// [1]
	static override id = 'screenshot'
	static override initial = 'idle'
	static override children() {
		return [ScreenshotIdle, ScreenshotPointing, ScreenshotDragging]
	}

	// [2]
	override onEnter() {
		this.editor.setCursor({ type: 'cross', rotation: 0 })
	}

	override onExit() {
		this.editor.setCursor({ type: 'default', rotation: 0 })
	}

	// [3]
	override onInterrupt() {
		this.complete()
	}

	override onCancel() {
		this.complete()
	}

	private complete() {
		this.parent.transition('select', {})
	}
}

/*
This file contains our screenshot tool. The tool is a StateNode with the `id` "screenshot".

[1]
It has three child state nodes, ScreenshotIdle, ScreenshotPointing, and ScreenshotDragging. 
Its initial state is `idle`.

[2]
When the screenshot tool is entered, we set the cursor to a crosshair. When it is exited, we
set the cursor back to the default cursor. 

[3]
When the screenshot tool is interrupted or cancelled, we transition back to the select tool.
*/
```

## Dragging.ts

```ts
import { Box, StateNode, atom, copyAs, exportAs } from 'tldraw'

// There's a guide at the bottom of this file!

export class ScreenshotDragging extends StateNode {
	static override id = 'dragging'

	// [1]
	screenshotBox = atom('screenshot brush', new Box())

	// [2]
	override onEnter() {
		this.update()
	}

	override onPointerMove() {
		this.update()
	}

	override onKeyDown() {
		this.update()
	}

	override onKeyUp() {
		this.update()
	}

	private update() {
		const {
			inputs: { shiftKey, altKey, originPagePoint, currentPagePoint },
		} = this.editor

		const box = Box.FromPoints([originPagePoint, currentPagePoint])

		if (shiftKey) {
			if (box.w > box.h * (16 / 9)) {
				box.h = box.w * (9 / 16)
			} else {
				box.w = box.h * (16 / 9)
			}

			if (currentPagePoint.x < originPagePoint.x) {
				box.x = originPagePoint.x - box.w
			}

			if (currentPagePoint.y < originPagePoint.y) {
				box.y = originPagePoint.y - box.h
			}
		}

		if (altKey) {
			box.w *= 2
			box.h *= 2
			box.x = originPagePoint.x - box.w / 2
			box.y = originPagePoint.y - box.h / 2
		}

		this.screenshotBox.set(box)
	}

	// [3]
	override onPointerUp() {
		const { editor } = this
		const box = this.screenshotBox.get()

		// get all shapes contained by or intersecting the box
		const shapes = editor.getCurrentPageShapes().filter((s) => {
			const pageBounds = editor.getShapeMaskedPageBounds(s)
			if (!pageBounds) return false
			return box.includes(pageBounds)
		})

		if (shapes.length) {
			if (editor.inputs.ctrlKey) {
				// Copy the shapes to the clipboard
				copyAs(
					editor,
					shapes.map((s) => s.id),
					{ format: 'png', bounds: box }
				)
			} else {
				// Export the shapes as a png
				exportAs(
					editor,
					shapes.map((s) => s.id),
					{
						format: 'png',
						name: 'Screenshot',
						bounds: box,
					}
				)
			}
		}

		this.editor.setCurrentTool('select')
	}

	// [4]
	override onCancel() {
		this.editor.setCurrentTool('select')
	}
}

/*
[1] 
This state has a reactive property (an Atom) called "screenshotBox". This is the box
that the user is drawing on the screen as they drag their pointer. We use an Atom here
so that our UI can subscribe to this property using `useValue` (see the ScreenshotBox
component in ScreenshotToolExample).

[2]
When the user enters this state, or when they move their pointer, we update the 
screenshotBox property to be drawn between the place where the user started pointing
and the place where their pointer is now. If the user is holding Shift, then we modify
the dimensions of this box so that it is in a 16:9 aspect ratio.

[3]
When the user makes a pointer up and stops dragging, we export the shapes contained by
the screenshot box as a png. If the user is holding the ctrl key, we copy the shapes
to the clipboard instead.

[4]
When the user cancels (esc key) or makes a pointer up event, we transition back to the
select tool.
*/
```

## Idle.ts

```ts
import { StateNode } from 'tldraw'

// There's a guide at the bottom of this file!

export class ScreenshotIdle extends StateNode {
	static override id = 'idle'

	// [1]
	override onPointerDown() {
		this.parent.transition('pointing')
	}
}

/*
[1]
When we the user makes a pointer down event, we transition to the pointing state.
*/
```

## Pointing.ts

```ts
import { StateNode } from 'tldraw'

// There's a guide at the bottom of this file!

export class ScreenshotPointing extends StateNode {
	static override id = 'pointing'

	// [1]
	override onPointerMove() {
		if (this.editor.inputs.isDragging) {
			this.parent.transition('dragging')
		}
	}

	// [2]
	override onPointerUp() {
		this.complete()
	}

	override onCancel() {
		this.complete()
	}

	private complete() {
		this.parent.transition('idle')
	}
}

/*
[1]
When the user makes a pointer move event, we check if they are dragging. If they are, 
we transition to the dragging state. If they are not yet dragging, we stay in this state.

[2]
When the user cancelles or makes a pointer up event (while this state is still active, 
so after the user has started pointing but before they've moved their pointer far enough 
to start dragging), then we transition back to the idle state.
*/
```

--------

# Custom shape and tool

Category: Shapes & tools

Keywords: toolbar, migrations, icon, util, ui overrides, card shape

A custom shape and tool.

This example shows how to define a custom shape, as well as a custom tool that can be used to create that shape.

In this case, the card tool (select âš«ï¸ in the toolbar) can be used to create a card shape.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import { CardShapeTool } from './CardShape/CardShapeTool'
import { CardShapeUtil } from './CardShape/CardShapeUtil'
import { components, uiOverrides } from './ui-overrides'

// There's a guide at the bottom of this file!

// [1]
const customShapeUtils = [CardShapeUtil]
const customTools = [CardShapeTool]

// [2]
export default function CustomConfigExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// Pass in the array of custom shape classes
				shapeUtils={customShapeUtils}
				// Pass in the array of custom tool classes
				tools={customTools}
				// Pass in any overrides to the user interface
				overrides={uiOverrides}
				// Pass in the new Keybaord Shortcuts component
				components={components}
			/>
		</div>
	)
}

/* 
Introduction:

This example shows how to create a custom shape, and add your own icon for it to the toolbar.
Check out CardShapeUtil.tsx and CardShapeTool.tsx to see how we define the shape util and tool. 
Check out ui-overrides.ts for more info on how to add your icon to the toolbar.

[1] 
We define an array to hold the custom shape util and custom tool. It's important to do this outside of
any React component so that this array doesn't get redefined on every render.

[2]
Now we'll pass these arrays into the Tldraw component's props, along with our ui overrides.


*/
```

## ui-overrides.tsx

```tsx
import {
	DefaultKeyboardShortcutsDialog,
	DefaultKeyboardShortcutsDialogContent,
	DefaultToolbar,
	DefaultToolbarContent,
	TLComponents,
	TLUiOverrides,
	TldrawUiMenuItem,
	useIsToolSelected,
	useTools,
} from 'tldraw'

// There's a guide at the bottom of this file!

export const uiOverrides: TLUiOverrides = {
	tools(editor, tools) {
		// Create a tool item in the ui's context.
		tools.card = {
			id: 'card',
			icon: 'color',
			label: 'Card',
			kbd: 'c',
			onSelect: () => {
				editor.setCurrentTool('card')
			},
		}
		return tools
	},
}

export const components: TLComponents = {
	Toolbar: (props) => {
		const tools = useTools()
		const isCardSelected = useIsToolSelected(tools['card'])
		return (
			<DefaultToolbar {...props}>
				<TldrawUiMenuItem {...tools['card']} isSelected={isCardSelected} />
				<DefaultToolbarContent />
			</DefaultToolbar>
		)
	},
	KeyboardShortcutsDialog: (props) => {
		const tools = useTools()
		return (
			<DefaultKeyboardShortcutsDialog {...props}>
				<TldrawUiMenuItem {...tools['card']} />
				<DefaultKeyboardShortcutsDialogContent />
			</DefaultKeyboardShortcutsDialog>
		)
	},
}

/* 

This file contains overrides for the Tldraw UI. These overrides are used to add your custom tools to
the toolbar and the keyboard shortcuts menu.

First we have to add our new tool to the tools object in the tools override. This is where we define
all the basic information about our new tool - its icon, label, keyboard shortcut, what happens when
we select it, etc.

Then, we replace the UI components for the toolbar and keyboard shortcut dialog with our own, that
add our new tool to the existing default content. Ideally, we'd interleave our new tool into the
ideal place among the default tools, but for now we're just adding it at the start to keep things
simple.
*/
```

## CardShapeTool.tsx

```tsx
import { BaseBoxShapeTool, TLClickEventInfo } from 'tldraw'
export class CardShapeTool extends BaseBoxShapeTool {
	static override id = 'card'
	static override initial = 'idle'
	override shapeType = 'card'

	override onDoubleClick(_info: TLClickEventInfo) {
		// you can handle events in handlers like this one;
		// check the BaseBoxShapeTool source as an example
	}
}

/*
This file contains our custom tool. The tool is a StateNode with the `id` "card".

We get a lot of functionality for free by extending the BaseBoxShapeTool. but we can
handle events in out own way by overriding methods like onDoubleClick. For an example 
of a tool with more custom functionality, check out the screenshot-tool example. 

*/
```

## CardShapeUtil.tsx

```tsx
import { useState } from 'react'
import {
	HTMLContainer,
	Rectangle2d,
	ShapeUtil,
	TLResizeInfo,
	getColorValue,
	getDefaultColorTheme,
	resizeBox,
} from 'tldraw'
import { cardShapeMigrations } from './card-shape-migrations'
import { cardShapeProps } from './card-shape-props'
import { ICardShape } from './card-shape-types'

// There's a guide at the bottom of this file!

export class CardShapeUtil extends ShapeUtil<ICardShape> {
	static override type = 'card' as const
	// [1]
	static override props = cardShapeProps
	// [2]
	static override migrations = cardShapeMigrations

	// [3]
	override isAspectRatioLocked(_shape: ICardShape) {
		return false
	}
	override canResize(_shape: ICardShape) {
		return true
	}

	// [4]
	getDefaultProps(): ICardShape['props'] {
		return {
			w: 300,
			h: 300,
			color: 'black',
		}
	}

	// [5]
	getGeometry(shape: ICardShape) {
		return new Rectangle2d({
			width: shape.props.w,
			height: shape.props.h,
			isFilled: true,
		})
	}

	// [6]
	component(shape: ICardShape) {
		const bounds = this.editor.getShapeGeometry(shape).bounds
		const theme = getDefaultColorTheme({ isDarkMode: this.editor.user.getIsDarkMode() })

		//[a]
		// eslint-disable-next-line react-hooks/rules-of-hooks
		const [count, setCount] = useState(0)

		return (
			<HTMLContainer
				id={shape.id}
				style={{
					border: '1px solid black',
					display: 'flex',
					flexDirection: 'column',
					alignItems: 'center',
					justifyContent: 'center',
					pointerEvents: 'all',
					backgroundColor: getColorValue(theme, shape.props.color, 'semi'),
					color: getColorValue(theme, shape.props.color, 'solid'),
				}}
			>
				<h2>Clicks: {count}</h2>
				<button
					// [b]
					onClick={() => setCount((count) => count + 1)}
					onPointerDown={(e) => e.stopPropagation()}
				>
					{bounds.w.toFixed()}x{bounds.h.toFixed()}
				</button>
			</HTMLContainer>
		)
	}

	// [7]
	indicator(shape: ICardShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}

	// [8]
	override onResize(shape: ICardShape, info: TLResizeInfo<ICardShape>) {
		return resizeBox(shape, info)
	}
}
/* 
A utility class for the card shape. This is where you define the shape's behavior, 
how it renders (its component and indicator), and how it handles different events.

[1]
A validation schema for the shape's props (optional)
Check out card-shape-props.ts for more info.

[2]
Migrations for upgrading shapes (optional)
Check out card-shape-migrations.ts for more info.

[3]
Letting the editor know if the shape's aspect ratio is locked, and whether it 
can be resized or bound to other shapes. 

[4]
The default props the shape will be rendered with when click-creating one.

[5]
We use this to calculate the shape's geometry for hit-testing, bindings and
doing other geometric calculations. 

[6]
Render method â€” the React component that will be rendered for the shape. It takes the 
shape as an argument. HTMLContainer is just a div that's being used to wrap our text 
and button. We can get the shape's bounds using our own getGeometry method.
	
- [a] Check it out! We can do normal React stuff here like using setState.
   Annoying: eslint sometimes thinks this is a class component, but it's not.

- [b] You need to stop the pointer down event on buttons, otherwise the editor will
	   think you're trying to select drag the shape.

[7]
Indicator â€” used when hovering over a shape or when it's selected; must return only SVG elements here

[8]
Resize handler â€” called when the shape is resized. Sometimes you'll want to do some 
custom logic here, but for our purposes, this is fine.
*/
```

## card-shape-migrations.ts

```ts
import { createShapePropsMigrationIds, createShapePropsMigrationSequence } from 'tldraw'

const versions = createShapePropsMigrationIds(
	// this must match the shape type in the shape definition
	'card',
	{
		AddSomeProperty: 1,
	}
)

// Migrations for the custom card shape (optional but very helpful)
export const cardShapeMigrations = createShapePropsMigrationSequence({
	sequence: [
		{
			id: versions.AddSomeProperty,
			up(props) {
				// it is safe to mutate the props object here
				props.someProperty = 'some value'
			},
			down(props) {
				delete props.someProperty
			},
		},
	],
})
```

## card-shape-props.ts

```ts
import { DefaultColorStyle, RecordProps, T } from 'tldraw'
import { ICardShape } from './card-shape-types'

// Validation for our custom card shape's props, using one of tldraw's default styles
export const cardShapeProps: RecordProps<ICardShape> = {
	w: T.number,
	h: T.number,
	color: DefaultColorStyle,
}

// To generate your own custom styles, check out the custom styles example.
```

## card-shape-types.ts

```ts
import { TLBaseShape, TLDefaultColorStyle } from 'tldraw'

// A type for our custom card shape
export type ICardShape = TLBaseShape<
	'card',
	{
		w: number
		h: number
		color: TLDefaultColorStyle
	}
>
```

--------

# Custom shape with custom styles

Category: Shapes & tools

Keywords: style panel, rating

Use the custom styles API with your custom shapes.

This example shows how to create your own styles and use them in your own shapes.

To use tldraw's existing styles with your shapes, check the [tldraw styles example](https://tldraw.dev/examples/shape-with-tldraw-styles).

## App.tsx

```tsx
import {
	BaseBoxShapeUtil,
	DefaultStylePanel,
	DefaultStylePanelContent,
	HTMLContainer,
	StyleProp,
	T,
	TLBaseShape,
	Tldraw,
	useEditor,
	useRelevantStyles,
} from 'tldraw'
import 'tldraw/tldraw.css'

// [1]
const myRatingStyle = StyleProp.defineEnum('example:rating', {
	defaultValue: 1,
	values: [1, 2, 3, 4, 5],
})

// [2]
type MyRatingStyle = T.TypeOf<typeof myRatingStyle>

type IMyShape = TLBaseShape<
	'myshape',
	{
		w: number
		h: number
		rating: MyRatingStyle
	}
>

class MyShapeUtil extends BaseBoxShapeUtil<IMyShape> {
	static override type = 'myshape' as const

	// [3]
	static override props = {
		w: T.number,
		h: T.number,
		rating: myRatingStyle,
	}

	getDefaultProps(): IMyShape['props'] {
		return {
			w: 300,
			h: 300,
			rating: 4, // [4]
		}
	}

	component(shape: IMyShape) {
		// [5]
		const stars = ['â˜†', 'â˜†', 'â˜†', 'â˜†', 'â˜†']
		for (let i = 0; i < shape.props.rating; i++) {
			stars[i] = 'â˜…'
		}

		return (
			<HTMLContainer
				id={shape.id}
				style={{ backgroundColor: 'var(--color-low-border)', overflow: 'hidden' }}
			>
				{stars}
			</HTMLContainer>
		)
	}

	indicator(shape: IMyShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}

// [6]
function CustomStylePanel() {
	const editor = useEditor()
	const styles = useRelevantStyles()
	if (!styles) return null

	const rating = styles.get(myRatingStyle)

	return (
		<DefaultStylePanel>
			<DefaultStylePanelContent styles={styles} />
			{rating !== undefined && (
				<div>
					<select
						style={{ width: '100%', padding: 4 }}
						value={rating.type === 'mixed' ? '' : rating.value}
						onChange={(e) => {
							editor.markHistoryStoppingPoint()
							const value = myRatingStyle.validate(+e.currentTarget.value)
							editor.setStyleForSelectedShapes(myRatingStyle, value)
						}}
					>
						{rating.type === 'mixed' ? <option value="">Mixed</option> : null}
						<option value={1}>1</option>
						<option value={2}>2</option>
						<option value={3}>3</option>
						<option value={4}>4</option>
						<option value={5}>5</option>
					</select>
				</div>
			)}
		</DefaultStylePanel>
	)
}

export default function ShapeWithTldrawStylesExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// [7]
				shapeUtils={[MyShapeUtil]}
				components={{
					StylePanel: CustomStylePanel,
				}}
				onMount={(editor) => {
					editor.createShape({ type: 'myshape', x: 100, y: 100 })
					editor.selectAll()
					editor.createShape({ type: 'myshape', x: 450, y: 250, props: { rating: 5 } })
				}}
			/>
		</div>
	)
}

/* 

This file shows a custom shape that uses a user-created styles 

For more on custom shapes, see our Custom Shape example.

[1]
In this example, our custom shape will use a new style called "rating".
We'll need to create the style so that we can pass it to the shape's props.

[2]
Here's we extract the type of the style's values. We use it below when
we define the shape's props.

[3]
We pass the style to the shape's props.

[4]
Since this property uses one a style, whatever value we put here in the
shape's default props will be overwritten by the editor's current value 
for that style, which will either be the default value or the most 
recent value the user has set. This is special behavior just for styles.

[5]
We can use the styles in the component just like any other prop.

[6]
Here we create a custom style panel that includes the default style panel
and also a dropdown for the rating style. We use the useRelevantStyles hook
to get the styles of the user's selected shapes, and the useEditor hook to
set the style for the selected shapes. For more on customizing the style
panel, see our custom style panel example.

[7]
We pass the custom shape util and custom components in as props.

[8]
And for this example, we create two shapes: the first does not specify a
rating, so it will use the editor's current style value (in this example,
this will be the style's default value of 4). The second specifies a 
rating of 5, so it will use that value.
*/
```

--------

# Custom shape with tldraw styles

Category: Shapes & tools

Keywords: default styles, style panel

Use the tldraw style panel with your custom shapes.

The default tldraw UI will display UI for the styles of your selection or your current tool. For example, when you have two shapes selected that both have the tldraw's "size" style, the size selector will be displayed. If all of your selected shapes have the same value for this style, that value will be shown as selected in the panel. If they have different values, the panel will show the value as "mixed".

You can use tldraw's default styles in your own shapes. This example shows how to do that.

To create your own custom styles, check the [custom styles example](https://tldraw.dev/examples/shape-with-custom-styles).

## App.tsx

```tsx
import {
	BaseBoxShapeUtil,
	DefaultColorStyle,
	DefaultSizeStyle,
	getColorValue,
	HTMLContainer,
	T,
	TLBaseShape,
	TLDefaultColorStyle,
	TLDefaultSizeStyle,
	Tldraw,
	useDefaultColorTheme,
} from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

const FONT_SIZES: Record<TLDefaultSizeStyle, number> = {
	s: 14,
	m: 25,
	l: 38,
	xl: 48,
}

type IMyShape = TLBaseShape<
	'myshape',
	{
		w: number
		h: number
		// [1]
		size: TLDefaultSizeStyle
		color: TLDefaultColorStyle
	}
>

class MyShapeUtil extends BaseBoxShapeUtil<IMyShape> {
	static override type = 'myshape' as const

	// [2]
	static override props = {
		w: T.number,
		h: T.number,
		size: DefaultSizeStyle,
		color: DefaultColorStyle,
	}

	getDefaultProps(): IMyShape['props'] {
		return {
			w: 300,
			h: 300,
			size: 'm',
			color: 'black',
		}
	}

	component(shape: IMyShape) {
		// eslint-disable-next-line react-hooks/rules-of-hooks
		const theme = useDefaultColorTheme()

		return (
			<HTMLContainer
				id={shape.id}
				style={{ backgroundColor: 'var(--color-low-border)', overflow: 'hidden' }}
			>
				<div
					style={{
						// [3]
						fontSize: FONT_SIZES[shape.props.size],
						color: getColorValue(theme, shape.props.color, 'solid'),
					}}
				>
					Select the shape and use the style panel to change the font size and color
				</div>
			</HTMLContainer>
		)
	}

	indicator(shape: IMyShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}

const customShapeUtils = [MyShapeUtil]

export default function ShapeWithTldrawStylesExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				shapeUtils={customShapeUtils}
				onMount={(editor) => {
					editor.createShape({ type: 'myshape', x: 100, y: 100 })
				}}
			/>
		</div>
	)
}

/* 

This file shows a custom shape that uses tldraw's default styles. 
For more on custom shapes, see our Custom Shape example.

[1]
In this example, our custom shape will use the size and color styles from the
default styles. When typing a custom shape, you can use our types for
these styles.

[2]
For the shape's props, we'll pass the DefaultSizeStyle and DefaultColorStyle
styles for the two properties, size and color. There's nothing special about
these styles except that the editor will notice when two shapes are selected
that share the same style. (You can use the useRelevantStyles hook to get the
styles of the user's selected shapes.)

[3]
Here in the component, we'll use the styles to change the way that our shape
appears. The style values themselves are just strings, like 'xl' or 'black',
so it's up to you to decide how to use them. In this example, we're using the
size to set the text's font-size property, and also using the default theme
(via the useDefaultColorTheme hook) to get the color for the text.
*/
```

--------

# Clickable custom shape

Category: Shapes & tools

Keywords: interaction, pointer events, stop propagation, click, input

A custom shape that has its own onClick interactions.

By default the editor handles pointer events, but sometimes you want to handle interactions on your shape in your own ways, for example via a button. You can do this by using the css property `pointer events: all` and stopping event propagation. In this example we want our todo shape to have a checkbox so the user can mark them as done.

Check out my-interactive-shape-util.tsx to see how we create the shape.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

import { myInteractiveShape } from './my-interactive-shape-util'

// There's a guide at the bottom of this file!

// [1]
const customShapeUtils = [myInteractiveShape]

// [2]
export default function InteractiveShapeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				shapeUtils={customShapeUtils}
				onMount={(editor) => {
					editor.createShape({ type: 'my-interactive-shape', x: 100, y: 100 })
				}}
			/>
		</div>
	)
}

/*
[1]
By default the editor handles pointer events, but sometimes you want to handle 
interactions on your shape in your own ways, for example via a button. You can do this 
by using the css property `pointer events: all` and stopping event propagation. In 
this example we want our todo shape to have a checkbox so the user can mark them as 
done.

[2]
Check out my-interactive-shape-util.tsx to see how we create the shape. 
 */
```

## my-interactive-shape-util.tsx

```tsx
import { BaseBoxShapeUtil, HTMLContainer, RecordProps, T, TLBaseShape } from 'tldraw'

// There's a guide at the bottom of this file!

type IMyInteractiveShape = TLBaseShape<
	'my-interactive-shape',
	{
		w: number
		h: number
		checked: boolean
		text: string
	}
>

export class myInteractiveShape extends BaseBoxShapeUtil<IMyInteractiveShape> {
	static override type = 'my-interactive-shape' as const
	static override props: RecordProps<IMyInteractiveShape> = {
		w: T.number,
		h: T.number,
		checked: T.boolean,
		text: T.string,
	}

	getDefaultProps(): IMyInteractiveShape['props'] {
		return {
			w: 230,
			h: 230,
			checked: false,
			text: '',
		}
	}

	// [1]
	component(shape: IMyInteractiveShape) {
		return (
			<HTMLContainer
				style={{
					padding: 16,
					height: shape.props.h,
					width: shape.props.w,
					// [a] This is where we allow pointer events on our shape
					pointerEvents: 'all',
					backgroundColor: '#efefef',
					overflow: 'hidden',
				}}
			>
				<input
					type="checkbox"
					checked={shape.props.checked}
					onChange={() =>
						this.editor.updateShape<IMyInteractiveShape>({
							id: shape.id,
							type: 'my-interactive-shape',
							props: { checked: !shape.props.checked },
						})
					}
					// [b] This is where we stop event propagation
					onPointerDown={(e) => e.stopPropagation()}
					onTouchStart={(e) => e.stopPropagation()}
					onTouchEnd={(e) => e.stopPropagation()}
				/>
				<input
					type="text"
					placeholder="Enter a todo..."
					readOnly={shape.props.checked}
					value={shape.props.text}
					onChange={(e) =>
						this.editor.updateShape<IMyInteractiveShape>({
							id: shape.id,
							type: 'my-interactive-shape',
							props: { text: e.currentTarget.value },
						})
					}
					// [c]
					onPointerDown={(e) => {
						if (!shape.props.checked) {
							e.stopPropagation()
						}
					}}
					onTouchStart={(e) => {
						if (!shape.props.checked) {
							e.stopPropagation()
						}
					}}
					onTouchEnd={(e) => {
						if (!shape.props.checked) {
							e.stopPropagation()
						}
					}}
				/>
			</HTMLContainer>
		)
	}

	// [5]
	indicator(shape: IMyInteractiveShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}

/* 
This is a custom shape, for a more in-depth look at how to create a custom shape,
see our custom shape example.

[1]
This is where we describe how our shape will render

	[a] We need to set pointer-events to all so that we can interact with our shape. This CSS property is
	set to "none" off by default. We need to manually opt-in to accepting pointer events by setting it to
	'all' or 'auto'. 

	[b] We need to stop event propagation so that the editor doesn't select the shape
		when we click on the checkbox. The 'canvas container' forwards events that it receives
		on to the editor, so stopping propagation here prevents the event from reaching the canvas.
	
	[c] If the shape is not checked, we stop event propagation so that the editor doesn't
		select the shape when we click on the input. If the shape is checked then we allow that event to
		propagate to the canvas and then get sent to the editor, triggering clicks or drags as usual.

*/
```

--------

# Custom shape with handles

Category: Shapes & tools

Keywords: handles, handle, geometry, interaction, text label

A speech bubble shape with custom handles.

This example shows how to create a custom shape with custom handles.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import { SpeechBubbleTool } from './SpeechBubble/SpeechBubbleTool'
import { SpeechBubbleUtil } from './SpeechBubble/SpeechBubbleUtil'
import { components, customAssetUrls, uiOverrides } from './SpeechBubble/ui-overrides'
import './customhandles.css'

// There's a guide at the bottom of this file!

// [1]
const shapeUtils = [SpeechBubbleUtil]
const tools = [SpeechBubbleTool]

// [2]
export default function CustomShapeWithHandles() {
	return (
		<div style={{ position: 'absolute', inset: 0 }}>
			<Tldraw
				shapeUtils={shapeUtils}
				tools={tools}
				overrides={uiOverrides}
				assetUrls={customAssetUrls}
				components={components}
				persistenceKey="whatever"
			/>
		</div>
	)
}

/*
Introduction:

This example shows how to create a custom shape using handles. You can use handles when you want
user interaction to alter the geometry of a shape. In this example, we create a speech bubble shape
with a handle on the tail so the user can alter its position and length. Most of the interesting stuff
is in SpeechBubbleUtil.tsx and helpers.tsx. 

[1]
We define an array to hold the custom shape util and cusom tool. It's important to do this outside of
any React component so that this array doesn't get redefined on every render. We'll pass this into the 
Tldraw component's `shapeUtils` and `tools` props.

Check out SpeechBubbleUtil.tsx and SpeechBubbleTool.tsx to see how we define the shape util and tool.

[2]
We pass the custom shape util and tool into the Tldraw component's `shapeUtils` and `tools` props.
We also pass in the custom ui overrides and asset urls to make sure our icons render where we want them to. 
Check out ui-overrides.ts for more details.

*/
```

## customhandles.css

```css
/* Resize handles are normally on top, but We're going to give shape handles priority */
.tl-user-handles {
	z-index: 101;
}

/* The text label doesn't normally deal with text that goes sideways,
 * so this accounts for that */
.tl-shape[data-shape-type='speech-bubble'] .tl-text-label {
	justify-content: flex-start !important;
}
```

## SpeechBubbleTool.tsx

```tsx
import { BaseBoxShapeTool } from 'tldraw'

export class SpeechBubbleTool extends BaseBoxShapeTool {
	static override id = 'speech-bubble'
	static override initial = 'idle'
	override shapeType = 'speech-bubble'
}

/*
This file contains our speech bubble tool. The tool is a StateNode with the `id` "speech-bubble".

We get a lot of functionality for free by extending the BaseBoxShapeTool. For an example of a tool
with more custom functionality, check out the screenshot-tool example. 

*/
```

## SpeechBubbleUtil.tsx

```tsx
import {
	DefaultColorStyle,
	DefaultFontStyle,
	DefaultHorizontalAlignStyle,
	DefaultSizeStyle,
	DefaultVerticalAlignStyle,
	FONT_FAMILIES,
	Geometry2d,
	LABEL_FONT_SIZES,
	PlainTextLabel,
	Polygon2d,
	RecordPropsType,
	ShapeUtil,
	T,
	TEXT_PROPS,
	TLBaseShape,
	TLHandle,
	TLHandleDragInfo,
	TLResizeInfo,
	Vec,
	ZERO_INDEX_KEY,
	getColorValue,
	resizeBox,
	structuredClone,
	useDefaultColorTheme,
	vecModelValidator,
} from 'tldraw'
import { getSpeechBubbleVertices, getTailIntersectionPoint } from './helpers'

// Copied from tldraw/tldraw
export const STROKE_SIZES = {
	s: 2,
	m: 3.5,
	l: 5,
	xl: 10,
}

// There's a guide at the bottom of this file!

// [1]

export const speechBubbleShapeProps = {
	w: T.number,
	h: T.number,
	size: DefaultSizeStyle,
	color: DefaultColorStyle,
	font: DefaultFontStyle,
	align: DefaultHorizontalAlignStyle,
	verticalAlign: DefaultVerticalAlignStyle,
	growY: T.positiveNumber,
	text: T.string,
	tail: vecModelValidator,
}

export type SpeechBubbleShapeProps = RecordPropsType<typeof speechBubbleShapeProps>
export type SpeechBubbleShape = TLBaseShape<'speech-bubble', SpeechBubbleShapeProps>

export class SpeechBubbleUtil extends ShapeUtil<SpeechBubbleShape> {
	static override type = 'speech-bubble' as const

	// [2]
	static override props = speechBubbleShapeProps

	override isAspectRatioLocked(_shape: SpeechBubbleShape) {
		return false
	}

	override canResize(_shape: SpeechBubbleShape) {
		return true
	}

	override canEdit() {
		return true
	}

	// [3]
	getDefaultProps(): SpeechBubbleShapeProps {
		return {
			w: 200,
			h: 130,
			color: 'black',
			size: 'm',
			font: 'draw',
			align: 'middle',
			verticalAlign: 'start',
			growY: 0,
			text: '',
			tail: { x: 0.5, y: 1.5 },
		}
	}

	getHeight(shape: SpeechBubbleShape) {
		return shape.props.h + shape.props.growY
	}

	getGeometry(shape: SpeechBubbleShape): Geometry2d {
		const speechBubbleGeometry = getSpeechBubbleVertices(shape)
		const body = new Polygon2d({
			points: speechBubbleGeometry,
			isFilled: true,
		})
		return body
	}

	// [4]
	override getHandles(shape: SpeechBubbleShape): TLHandle[] {
		const { tail, w } = shape.props

		return [
			{
				id: 'tail',
				type: 'vertex',
				label: 'Move tail',
				index: ZERO_INDEX_KEY,
				// props.tail coordinates are normalized
				// but here we need them in shape space
				x: tail.x * w,
				y: tail.y * this.getHeight(shape),
			},
		]
	}

	override onHandleDrag(shape: SpeechBubbleShape, { handle }: TLHandleDragInfo<SpeechBubbleShape>) {
		return {
			...shape,
			props: {
				tail: {
					x: handle.x / shape.props.w,
					y: handle.y / this.getHeight(shape),
				},
			},
		}
	}

	override onBeforeCreate(next: SpeechBubbleShape) {
		return this.getGrowY(next, next.props.growY)
	}

	// [5]
	override onBeforeUpdate(prev: SpeechBubbleShape, shape: SpeechBubbleShape) {
		const { w, tail } = shape.props
		const fullHeight = this.getHeight(shape)

		const { segmentsIntersection, insideShape } = getTailIntersectionPoint(shape)

		const slantedLength = Math.hypot(w, fullHeight)
		const MIN_DISTANCE = slantedLength / 5
		const MAX_DISTANCE = slantedLength / 1.5

		const tailInShapeSpace = new Vec(tail.x * w, tail.y * fullHeight)

		const distanceToIntersection = tailInShapeSpace.dist(segmentsIntersection)
		const center = new Vec(w / 2, fullHeight / 2)
		const tailDirection = Vec.Sub(tailInShapeSpace, center).uni()

		let newPoint = tailInShapeSpace

		if (insideShape) {
			newPoint = Vec.Add(segmentsIntersection, tailDirection.mul(MIN_DISTANCE))
		} else {
			if (distanceToIntersection <= MIN_DISTANCE) {
				newPoint = Vec.Add(segmentsIntersection, tailDirection.mul(MIN_DISTANCE))
			} else if (distanceToIntersection >= MAX_DISTANCE) {
				newPoint = Vec.Add(segmentsIntersection, tailDirection.mul(MAX_DISTANCE))
			}
		}

		const next = structuredClone(shape)
		next.props.tail.x = newPoint.x / w
		next.props.tail.y = newPoint.y / fullHeight

		return this.getGrowY(next, prev.props.growY)
	}

	component(shape: SpeechBubbleShape) {
		const {
			id,
			type,
			props: { color, font, size, align, text },
		} = shape
		const vertices = getSpeechBubbleVertices(shape)
		const pathData = 'M' + vertices[0] + 'L' + vertices.slice(1) + 'Z'
		const isSelected = shape.id === this.editor.getOnlySelectedShapeId()
		// eslint-disable-next-line react-hooks/rules-of-hooks
		const theme = useDefaultColorTheme()

		return (
			<>
				<svg className="tl-svg-container">
					<path
						d={pathData}
						strokeWidth={STROKE_SIZES[size]}
						stroke={getColorValue(theme, color, 'solid')}
						fill={'none'}
					/>
				</svg>
				<PlainTextLabel
					shapeId={id}
					type={type}
					font={font}
					textWidth={shape.props.w}
					fontSize={LABEL_FONT_SIZES[size]}
					lineHeight={TEXT_PROPS.lineHeight}
					align={align}
					verticalAlign="start"
					text={text}
					labelColor={getColorValue(theme, color, 'solid')}
					isSelected={isSelected}
					wrap
				/>
			</>
		)
	}

	indicator(shape: SpeechBubbleShape) {
		const vertices = getSpeechBubbleVertices(shape)
		const pathData = 'M' + vertices[0] + 'L' + vertices.slice(1) + 'Z'
		return <path d={pathData} />
	}

	override onResize(shape: SpeechBubbleShape, info: TLResizeInfo<SpeechBubbleShape>) {
		const resized = resizeBox(shape, info)
		const next = structuredClone(info.initialShape)
		next.x = resized.x
		next.y = resized.y
		next.props.w = resized.props.w
		next.props.h = resized.props.h
		return next
	}

	getGrowY(shape: SpeechBubbleShape, prevGrowY = 0) {
		const PADDING = 17

		const nextTextSize = this.editor.textMeasure.measureText(shape.props.text, {
			...TEXT_PROPS,
			fontFamily: FONT_FAMILIES[shape.props.font],
			fontSize: LABEL_FONT_SIZES[shape.props.size],
			maxWidth: shape.props.w - PADDING * 2,
		})

		const nextHeight = nextTextSize.h + PADDING * 2

		let growY = 0

		if (nextHeight > shape.props.h) {
			growY = nextHeight - shape.props.h
		} else {
			if (prevGrowY) {
				growY = 0
			}
		}

		return {
			...shape,
			props: {
				...shape.props,
				growY,
			},
		}
	}
}

/*
Introduction: This file contains our custom shape util. The shape util is a class that defines how
our shape behaves. Most of the logic for how the speech bubble shape works is in the onBeforeUpdate
handler [5]. Since this shape has a handle, we need to do some special stuff to make sure it updates
the way we want it to.

[1]
Here is where we define the shape's type. For the tail we can use the `VecModel` type from `tldraw`.

[2]
This is where we define the shape's props and a type validator for each key. tldraw exports a
bunch of handy validators for us to use. Props you define here will determine which style options
show up in the style menu, e.g. we define 'size' and 'color' props, but we could add 'dash', 'fill'
or any other of the default props.

[3]
Here is where we set the default props for our shape, this will determine how the shape looks
when we click-create it. You'll notice we don't store the tail's absolute position though, instead
we record its relative position. This is because we can also drag-create shapes. If we store the
tail's position absolutely it won't scale properly when drag-creating. Throughout the rest of the
util we'll need to convert the tail's relative position to an absolute position and vice versa.

[4]
`getHandles` tells tldraw how to turn our shape into a list of handles that'll show up when it's
selected. We only have one handle, the tail, which simplifies things for us a bit. In
`onHandleDrag`, we tell tldraw how our shape should be updated when the handle is dragged.

[5]
This is the last method that fires after a shape has been changed, we can use it to make sure
the tail stays the right length and position. Check out helpers.tsx to get into some of the more
specific geometry stuff.
*/
```

## helpers.tsx

```tsx
import { Vec, VecLike, lerp, pointInPolygon } from 'tldraw'
import { SpeechBubbleShape } from './SpeechBubbleUtil'

export const getSpeechBubbleVertices = (shape: SpeechBubbleShape): Vec[] => {
	const { w, tail } = shape.props

	const fullHeight = shape.props.h + shape.props.growY
	const tailInShapeSpace = new Vec(tail.x * w, tail.y * fullHeight)

	const [tl, tr, br, bl] = [
		new Vec(0, 0),
		new Vec(w, 0),
		new Vec(w, fullHeight),
		new Vec(0, fullHeight),
	]

	const offsetH = w / 10
	const offsetV = fullHeight / 10

	const { adjustedIntersection, intersectionSegmentIndex } = getTailIntersectionPoint(shape)

	let vertices: Vec[]

	// Inject the tail segments into the geometry of the shape
	switch (intersectionSegmentIndex) {
		case 0:
			// top
			vertices = [
				tl,
				new Vec(adjustedIntersection.x - offsetH, adjustedIntersection.y),
				new Vec(tailInShapeSpace.x, tailInShapeSpace.y),
				new Vec(adjustedIntersection.x + offsetH, adjustedIntersection.y),
				tr,
				br,
				bl,
			]
			break
		case 1:
			// right
			vertices = [
				tl,
				tr,
				new Vec(adjustedIntersection.x, adjustedIntersection.y - offsetV),
				new Vec(tailInShapeSpace.x, tailInShapeSpace.y),
				new Vec(adjustedIntersection.x, adjustedIntersection.y + offsetV),
				br,
				bl,
			]
			break
		case 2:
			// bottom
			vertices = [
				tl,
				tr,
				br,
				new Vec(adjustedIntersection.x + offsetH, adjustedIntersection.y),
				new Vec(tailInShapeSpace.x, tailInShapeSpace.y),
				new Vec(adjustedIntersection.x - offsetH, adjustedIntersection.y),
				bl,
			]
			break
		case 3:
			// left
			vertices = [
				tl,
				tr,
				br,
				bl,
				new Vec(adjustedIntersection.x, adjustedIntersection.y + offsetV),
				new Vec(tailInShapeSpace.x, tailInShapeSpace.y),
				new Vec(adjustedIntersection.x, adjustedIntersection.y - offsetV),
			]
			break
		default:
			throw Error("no intersection found, this shouldn't happen")
	}

	return vertices
}

export function getTailIntersectionPoint(shape: SpeechBubbleShape) {
	const { w, tail } = shape.props
	const fullHeight = shape.props.h + shape.props.growY
	const tailInShapeSpace = new Vec(tail.x * w, tail.y * fullHeight)

	const center = new Vec(w / 2, fullHeight / 2)
	const corners = [new Vec(0, 0), new Vec(w, 0), new Vec(w, fullHeight), new Vec(0, fullHeight)]
	const segments = [
		[corners[0], corners[1]],
		[corners[1], corners[2]],
		[corners[2], corners[3]],
		[corners[3], corners[0]],
	]

	let segmentsIntersection: Vec | null = null
	let intersectionSegment: Vec[] | null = null

	// If the point inside of the box's corners?
	const insideShape = pointInPolygon(tailInShapeSpace, corners)

	// We want to be sure we get an intersection, so if the point is
	// inside the shape, push it away from the center by a big distance
	const pointToCheck = insideShape
		? Vec.Add(tailInShapeSpace, Vec.Sub(tailInShapeSpace, center).uni().mul(1000000))
		: tailInShapeSpace

	// Test each segment for an intersection
	for (const segment of segments) {
		segmentsIntersection = intersectLineSegmentLineSegment(
			segment[0],
			segment[1],
			center,
			pointToCheck
		)

		if (segmentsIntersection) {
			intersectionSegment = segment
			break
		}
	}

	if (!(segmentsIntersection && intersectionSegment)) {
		throw Error("no intersection found, this shouldn't happen")
	}

	const [start, end] = intersectionSegment
	const intersectionSegmentIndex = segments.indexOf(intersectionSegment)

	// a normalised vector from start to end, so this can work in any direction
	const unit = Vec.Sub(end, start).uni()

	// Where is the intersection relative to the start?
	const totalDistance = Vec.Dist(start, end)
	const distance = Vec.Dist(segmentsIntersection, start)

	// make it stick to the middle
	const middleRelative = mapRange(0, totalDistance, -1, 1, distance) // absolute -> -1 to 1
	const squaredRelative = Math.abs(middleRelative) ** 2 * Math.sign(middleRelative) // square it and keep the sign
	const squared = mapRange(-1, 1, 0, totalDistance, squaredRelative) // -1 to 1 -> absolute

	//keep it away from the edges
	const offset = (segments.indexOf(intersectionSegment) % 2 === 0 ? w / 10 : fullHeight / 10) * 3
	const constrained = mapRange(0, totalDistance, offset, totalDistance - offset, distance)

	// combine the two
	const interpolated = lerp(constrained, squared, 0.5)

	const adjustedIntersection = unit.mul(interpolated).add(start)

	// We need the adjusted intersection to draw the tail, but the original intersection
	// for the onBeforeUpdate handler
	return {
		segmentsIntersection,
		adjustedIntersection,
		intersectionSegmentIndex,
		insideShape,
	}
}

// This function is copied from the tldraw codebase
function intersectLineSegmentLineSegment(a1: VecLike, a2: VecLike, b1: VecLike, b2: VecLike) {
	const ABx = a1.x - b1.x
	const ABy = a1.y - b1.y
	const BVx = b2.x - b1.x
	const BVy = b2.y - b1.y
	const AVx = a2.x - a1.x
	const AVy = a2.y - a1.y
	const ua_t = BVx * ABy - BVy * ABx
	const ub_t = AVx * ABy - AVy * ABx
	const u_b = BVy * AVx - BVx * AVy

	if (ua_t === 0 || ub_t === 0) return null // coincident

	if (u_b === 0) return null // parallel

	if (u_b !== 0) {
		const ua = ua_t / u_b
		const ub = ub_t / u_b
		if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
			return Vec.AddXY(a1, ua * AVx, ua * AVy)
		}
	}

	return null // no intersection
}

/**
 * Inverse linear interpolation
 */
function invLerp(a: number, b: number, v: number) {
	return (v - a) / (b - a)
}
/**
 * Maps a value from one range to another.
 * e.g. mapRange(10, 20, 50, 100, 15) => 75
 */
function mapRange(a1: number, b1: number, a2: number, b2: number, s: number) {
	return lerp(a2, b2, invLerp(a1, b1, s))
}
```

## ui-overrides.tsx

```tsx
import {
	DefaultKeyboardShortcutsDialog,
	DefaultKeyboardShortcutsDialogContent,
	DefaultToolbar,
	DefaultToolbarContent,
	TLComponents,
	TLUiAssetUrlOverrides,
	TLUiOverrides,
	TldrawUiMenuItem,
	useIsToolSelected,
	useTools,
} from 'tldraw'

// There's a guide at the bottom of this file!

// [1]
export const uiOverrides: TLUiOverrides = {
	tools(editor, tools) {
		tools.speech = {
			id: 'speech-bubble',
			icon: 'speech-bubble',
			label: 'Speech Bubble',
			kbd: 's',
			onSelect: () => {
				editor.setCurrentTool('speech-bubble')
			},
		}
		return tools
	},
}

// [2]
export const customAssetUrls: TLUiAssetUrlOverrides = {
	icons: {
		'speech-bubble': '/speech-bubble.svg',
	},
}

export const components: TLComponents = {
	Toolbar: (props) => {
		const tools = useTools()
		const isSpeechBubbleSelected = useIsToolSelected(tools['speech'])
		return (
			<DefaultToolbar {...props}>
				<TldrawUiMenuItem {...tools['speech']} isSelected={isSpeechBubbleSelected} />
				<DefaultToolbarContent />
			</DefaultToolbar>
		)
	},
	KeyboardShortcutsDialog: (props) => {
		const tools = useTools()
		return (
			<DefaultKeyboardShortcutsDialog {...props}>
				<TldrawUiMenuItem {...tools['speech']} />
				<DefaultKeyboardShortcutsDialogContent />
			</DefaultKeyboardShortcutsDialog>
		)
	},
}

/* 

This file contains overrides for the Tldraw UI. These overrides are used to add your custom tools
to the toolbar and the keyboard shortcuts menu.

[1]
Here we add our new tool to the UI's tools object in the tools override. This is where we define
all the basic information about our new tool - its icon, label, keyboard shortcut, what happens when
we select it, etc.


[2]
Our toolbar item is using a custom icon, so we need to provide the asset url for it. 
We do this by providing a custom assetUrls object to the Tldraw component. 
This object is a map of icon ids to their urls. The icon ids are the same as the 
icon prop on the toolbar item. We'll pass our assetUrls object into the Tldraw
component's `assetUrls` prop.

[3]
We replace the UI components for the toolbar and keyboard shortcut dialog with our own, that
add our new tool to the existing default content. Ideally, we'd interleave our new tool into the
ideal place among the default tools, but for now we're just adding it at the start to keep things
simple.

*/
```

--------

# Custom tool with child states

Category: Shapes & tools

Keywords: state machine, custom tool, state node, interactions

You can implement more complex behaviour in a custom tool by using child states

Tools are nodes in tldraw's state machine. They are responsible for handling user input. You can create custom tools by extending the StateNode class and overriding its methods. In this example we expand on the sticker tool from the [custom tool example](https://tldraw.dev/examples/custom-tool) to show how to create a tool that can handle more complex interactions by using child states.

## App.tsx

```tsx
import {
	StateNode,
	TLClickEventInfo,
	TLPointerEventInfo,
	TLShapePartial,
	TLTextShape,
	Tldraw,
	createShapeId,
	toRichText,
} from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

const OFFSET = -12

// [1]
class StickerTool extends StateNode {
	static override id = 'sticker'
	static override initial = 'idle'
	static override children() {
		return [Idle, Pointing, Dragging]
	}
}

// [2]
class Idle extends StateNode {
	static override id = 'idle'
	//[a]
	override onEnter() {
		this.editor.setCursor({ type: 'cross' })
	}
	//[b]
	override onPointerDown(info: TLPointerEventInfo) {
		const { editor } = this
		switch (info.target) {
			case 'canvas': {
				const hitShape = editor.getShapeAtPoint(editor.inputs.currentPagePoint)
				if (hitShape) {
					this.onPointerDown({
						...info,
						shape: hitShape,
						target: 'shape',
					})
					return
				}
				this.parent.transition('pointing', { shape: null })
				break
			}
			case 'shape': {
				if (editor.inputs.shiftKey) {
					editor.updateShape<TLTextShape>({
						id: info.shape.id,
						type: 'text',
						props: { richText: toRichText('ðŸ‘» boo!') },
					})
				} else {
					this.parent.transition('pointing', { shape: info.shape })
				}
				break
			}
		}
	}
	//[c]
	override onDoubleClick(info: TLClickEventInfo) {
		const { editor } = this
		if (info.phase !== 'up') return
		switch (info.target) {
			case 'canvas': {
				const hitShape = editor.getShapeAtPoint(editor.inputs.currentPagePoint)

				if (hitShape) {
					this.onDoubleClick({
						...info,
						shape: hitShape,
						target: 'shape',
					})
					return
				}
				const { currentPagePoint } = editor.inputs
				editor.createShape<TLTextShape>({
					type: 'text',
					x: currentPagePoint.x + OFFSET,
					y: currentPagePoint.y + OFFSET,
					props: { richText: toRichText('â¤ï¸') },
				})
				break
			}
			case 'shape': {
				editor.deleteShapes([info.shape.id])
				break
			}
		}
	}
}
// [3]
class Pointing extends StateNode {
	static override id = 'pointing'
	private shape: TLTextShape | null = null

	override onEnter(info: { shape: TLTextShape | null }) {
		this.shape = info.shape
	}
	override onPointerUp() {
		this.parent.transition('idle')
	}

	override onPointerMove() {
		if (this.editor.inputs.isDragging) {
			this.parent.transition('dragging', { shape: this.shape })
		}
	}
}

// [4]
class Dragging extends StateNode {
	static override id = 'dragging'
	// [a]
	private shape: TLShapePartial | null = null
	private emojiArray = ['â¤ï¸', 'ðŸ”¥', 'ðŸ‘', 'ðŸ‘Ž', 'ðŸ˜­', 'ðŸ¤£']

	// [b]
	override onEnter(info: { shape: TLShapePartial }) {
		const { currentPagePoint } = this.editor.inputs
		const newShape: TLShapePartial<TLTextShape> = {
			id: createShapeId(),
			type: 'text',
			x: currentPagePoint.x + OFFSET,
			y: currentPagePoint.y + OFFSET,
			props: { richText: toRichText('â¤ï¸') },
		}
		if (info.shape) {
			this.shape = info.shape
		} else {
			this.editor.createShape<TLTextShape>(newShape)
			this.shape = { ...newShape }
		}
	}
	//[c]
	override onPointerUp() {
		this.parent.transition('idle')
	}
	//[d]

	override onPointerMove() {
		const { shape } = this
		const { originPagePoint, currentPagePoint } = this.editor.inputs
		const distance = originPagePoint.dist(currentPagePoint)
		if (shape) {
			this.editor.updateShape<TLTextShape>({
				id: shape.id,
				type: 'text',
				props: {
					richText: toRichText(this.emojiArray[Math.floor(distance / 20) % this.emojiArray.length]),
				},
			})
		}
	}
}

// [5]
const customTools = [StickerTool]
export default function ToolWithChildStatesExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// Pass in the array of custom tool classes
				tools={customTools}
				// Set the initial state to the sticker tool
				initialState="sticker"
				// hide the ui
				hideUi
				// Put some helpful text on the canvas
				onMount={(editor) => {
					editor.createShape<TLTextShape>({
						type: 'text',
						x: 50,
						y: 50,
						props: {
							richText: toRichText(
								'-Double click the canvas to add a sticker\n-Double click a sticker to delete it\n-Click and drag on a sticker to change it\n-Click and drag on the canvas to create a sticker\n-Shift click a sticker for a surprise!'
							),
							size: 's',
							textAlign: 'start',
						},
					})
				}}
			/>
		</div>
	)
}

/* 
Introduction:

Tools are nodes in tldraw's state machine. They are responsible for handling user input. 
You can create custom tools by extending the `StateNode` class and overriding its 
methods. In this example we expand on the sticker tool from the custom tool example to 
show how to create a tool that can handle more complex interactions by using child states.

[1]
This is our custom tool. It has three child states: `Idle`, `Pointing`, and `Dragging`.
We need to define the `id` and `initial` properties, the id is a unique string that
identifies the tool to the editor, and the initial property is the initial state of the
tool. We also need to define a `children` method that returns an array of the tool's
child states.

[2]
This is our Idle state. It is the initial state of the tool. It's job is to figure out
what the user is trying to do and transition to the appropriate state. When transitioning 
between states we can use the second argument to pass data to the new state. It has three 
methods:

	[a] `onEnter` 
	When entering any state, the `onEnter` method is called. In this case, we set the cursor to 
	a crosshair.

	[b] `onPointerDown`
	This method is called when the user presses the mouse button. The target parameter is always
	the canvas, so we can use an editor method to check if we're over a shape, and call the 
	method again with the shape as the target. If we are over a shape, we transition to the
	`pointing` state with the shape in the info object. If we're over a shape and holding the 
	shift key, we update the shape's text. If we're over the canvas, we transition to the 
	`pointing` state with a null shape in the info object.
	
	[c] `onDoubleClick`
	This method is called when the user double clicks the mouse button. We're using some similar
	logic here to check if we're over a shape, and if we are, we delete it. If we're over the canvas,
	we create a new shape.

[3]
This is our `Pointing` state. It's a transitionary state, we use it to store the shape we're pointing
at, and transition to the dragging state if the user starts dragging. It has three methods:

	[a] `onEnter`
	When entering this state, we store the shape we're pointing at by getting it from the info object.

	[b] `onPointerUp`
	This method is called when the user releases the mouse button. We transition to the `idle` state.

	[c] `onPointerMove`
	This method is called when the user moves the mouse. If the user starts dragging, we transition to
	the `dragging` state and pass the shape we're pointing at.

[4]
This is our `Dragging` state. It's responsible for creating and updating the shape that the user is 
dragging.

	[a] `onEnter`
	When entering this state, we create a new shape if we're not dragging an existing one. If we are, 
	we store the shape we're dragging.

	[b] `onPointerUp`
	This method is called when the user releases the mouse button. We transition to the `idle` state.

	[c] `onPointerMove`
	This method is called when the user moves the mouse. We use the distance between the origin and 
	current mouse position to cycle through an array of emojis and update the shape's text.

[5]
We pass our custom tool to the `Tldraw` component as an array. We also set the initial state to our
custom tool. For the purposes of this demo, we're also hiding the UI and adding some helpful text to
the canvas.
*/
```

--------

# Editable custom shape

Category: Shapes & tools

Keywords: custom

A custom shape that you can edit by double-clicking it.

In tldraw, the Editor can have one editing shape at a time. When in its editing state, the editor will ignore events until the user exits the editing state by pressing Escape or clicking on the canvas.

Only shapes with a `canEdit` flag that returns true may become editable. A user may begin editing a shape by double clicking on the editable shape, or selecting the editable shape and pressing enter.

Many of our shapes use editing to allow for interactions inside of the shape. For example, a text shape behaves like a text graphic until the user begins editing itâ€”and only then can the user use their keyboard to edit the text. Note that a shape can be interactive regardless of whether it's the editor's editing shapeâ€”the "editing" mechanic is just a way of managing a common pattern in canvas applications.

In this example we'll create a shape that renders an emoji and allows the user to change the emoji when the shape is in the editing state.
Most of the relevant code for this is in the EditableShapeUtil.tsx file. If you want a more in-depth explanation of the shape util, check out the custom shape example.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import { EditableShapeUtil } from './EditableShapeUtil'

const customShapeUtils = [EditableShapeUtil]

export default function EditableShapeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// Pass in the array of custom shape classes
				shapeUtils={customShapeUtils}
				// Create a shape when the editor mounts
				onMount={(editor) => {
					editor.createShape({ type: 'my-editable-shape', x: 100, y: 100 })
				}}
			/>
		</div>
	)
}

/*
Introduction:

In tldraw, shapes can exist in an editing state. When shapes are in the editing state
they are focused and can't be dragged, resized or rotated. Shapes enter this state 
when they are double-clicked. In our default shapes we mostly use this for editing text. 
In this example we'll create a shape that renders an emoji and allows the user to change 
the emoji when the shape is in the editing state.

Most of the relevant code for this is in the EditableShapeUtil.tsx file. If you want a more
in-depth explanation of the shape util, check out the custom shape example.


 */
```

## EditableShapeUtil.tsx

```tsx
import {
	BaseBoxShapeUtil,
	HTMLContainer,
	RecordProps,
	T,
	TLBaseShape,
	stopEventPropagation,
} from 'tldraw'

// There's a guide at the bottom of this file!

const ANIMAL_EMOJIS = ['ðŸ¶', 'ðŸ±', 'ðŸ¨', 'ðŸ®', 'ðŸ´']

type IMyEditableShape = TLBaseShape<
	'my-editable-shape',
	{
		w: number
		h: number
		animal: number
	}
>

export class EditableShapeUtil extends BaseBoxShapeUtil<IMyEditableShape> {
	static override type = 'my-editable-shape' as const
	static override props: RecordProps<IMyEditableShape> = {
		w: T.number,
		h: T.number,
		animal: T.number,
	}

	// [1] !!!
	override canEdit() {
		return true
	}

	getDefaultProps(): IMyEditableShape['props'] {
		return {
			w: 200,
			h: 200,
			animal: 0,
		}
	}

	// [2]
	component(shape: IMyEditableShape) {
		// [a]
		const isEditing = this.editor.getEditingShapeId() === shape.id

		return (
			<HTMLContainer
				id={shape.id}
				// [b]
				onPointerDown={isEditing ? stopEventPropagation : undefined}
				style={{
					pointerEvents: isEditing ? 'all' : 'none',
					backgroundColor: '#efefef',
					fontSize: 24,
					padding: 16,
				}}
			>
				{ANIMAL_EMOJIS[shape.props.animal]}
				{/* [c] */}
				{isEditing ? (
					<button
						onClick={() => {
							this.editor.updateShape({
								id: shape.id,
								type: shape.type,
								props: {
									...shape.props,
									animal: (shape.props.animal + 1) % ANIMAL_EMOJIS.length,
								},
							})
						}}
					>
						Next
					</button>
				) : (
					// [d] when not editing...
					<p style={{ fontSize: 12 }}>Double Click to Edit</p>
				)}
			</HTMLContainer>
		)
	}

	indicator(shape: IMyEditableShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}

	// [3]
	override onEditEnd(shape: IMyEditableShape) {
		this.editor.animateShape(
			{ ...shape, rotation: shape.rotation + Math.PI * 2 },
			{ animation: { duration: 250 } }
		)
	}
}

/* 

This is our shape util, which defines how our shape renders and behaves. For 
more information on the shape util, check out the custom shape example.

[1]
We override the canEdit method to allow the shape to enter the editing state.

[2]
We want to conditionally render the component based on whether it is being 
edited or not.

	[a] We can check whether our shape is being edited by comparing the
		editing shape id to the shape's id.
	
	[b] We want to allow pointer events when the shape is being edited,
		and stop event propagation on pointer down. Check out the interactive
		shape example for more information on this.

	[c] We render a button to change the animal emoji when the shape is being
		edited. 
		
	[e]	We also render a message when the shape is not being edited.

[3]
The onEditEnd method is called when the shape exits the editing state. In this
case we rotate the shape 360 degrees.

*/
```

--------

# Custom shape geometry

Category: Shapes & tools

Keywords: svg, path, house, door

A shape with custom geometry.

This example demonstrates how to create a shape with custom geometry in tldraw. The
shape we're creating is a simple house shape with a door.

## App.tsx

```tsx
import {
	Group2d,
	Polygon2d,
	RecordPropsType,
	Rectangle2d,
	ShapeUtil,
	T,
	TLBaseShape,
	TLResizeInfo,
	Tldraw,
	Vec,
	resizeBox,
	structuredClone,
} from 'tldraw'
import 'tldraw/tldraw.css'

const houseShapeProps = {
	w: T.number,
	h: T.number,
}

type HouseShapeProps = RecordPropsType<typeof houseShapeProps>
type HouseShape = TLBaseShape<'house', HouseShapeProps>
class HouseShapeUtil extends ShapeUtil<HouseShape> {
	static override type = 'house' as const
	static override props = houseShapeProps

	override canResize() {
		return true
	}
	override getDefaultProps() {
		return {
			w: 100,
			h: 100,
		}
	}
	//[1]
	override getGeometry(shape: HouseShape) {
		const { house: houseGeometry } = getHouseVertices(shape)
		const house = new Polygon2d({
			points: houseGeometry,
			isFilled: true,
		})
		const door = new Rectangle2d({
			x: shape.props.w / 2 - shape.props.w / 10,
			y: shape.props.h - shape.props.h / 4,
			width: shape.props.w / 5,
			height: shape.props.h / 4,
			isFilled: true,
		})
		const geometry = new Group2d({
			children: [house, door],
		})
		return geometry
	}
	// [2]
	override component(shape: HouseShape) {
		const { house: houseVertices, door: doorVertices } = getHouseVertices(shape)
		const housePathData = 'M' + houseVertices[0] + 'L' + houseVertices.slice(1) + 'Z'
		const doorPathData = 'M' + doorVertices[0] + 'L' + doorVertices.slice(1) + 'Z'
		return (
			<svg className="tl-svg-container">
				<path strokeWidth={3} stroke="black" d={housePathData + doorPathData} fill="none" />
			</svg>
		)
	}
	// [3]
	override indicator(shape: HouseShape) {
		const { house: houseVertices, door: doorVertices } = getHouseVertices(shape)
		const housePathData = 'M' + houseVertices[0] + 'L' + houseVertices.slice(1) + 'Z'
		const doorPathData = 'M' + doorVertices[0] + 'L' + doorVertices.slice(1) + 'Z'
		return <path d={housePathData + doorPathData} />
	}
	override onResize(shape: HouseShape, info: TLResizeInfo<HouseShape>) {
		const resized = resizeBox(shape, info)
		const next = structuredClone(info.initialShape)
		next.x = resized.x
		next.y = resized.y
		next.props.w = resized.props.w
		next.props.h = resized.props.h
		return next
	}
}
// [4]
function getHouseVertices(shape: HouseShape): { house: Vec[]; door: Vec[] } {
	const { w, h } = shape.props
	const halfW = w / 2
	const roofStart = h / 2.5
	const house = [
		new Vec(0, roofStart), // Roof start (left)
		new Vec(w, roofStart), // Roof start (right)
		new Vec(w, h), // Bottom-right corner
		new Vec(0, h), // Bottom-left corner
		new Vec(0, roofStart), // Roof start (left)
		new Vec(halfW, 0), // Roof peak
		new Vec(w, roofStart), // Roof start (right)
	]
	const door = [
		new Vec(halfW - w / 10, h), // Bottom-left corner
		new Vec(halfW + w / 10, h), // Bottom-right corner
		new Vec(halfW + w / 10, h - h / 4), // Top-right corner
		new Vec(halfW - w / 10, h - h / 4), // Top-left corner
		new Vec(halfW - w / 10, h), // Bottom-left corner
	]
	return { house, door }
}

const shapeUtils = [HouseShapeUtil]

export default function ShapeWithGeometryExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					editor.createShape({
						type: 'house',
						x: 100,
						y: 100,
						props: {
							w: 100,
							h: 100,
						},
					})
				}}
				shapeUtils={shapeUtils}
			/>
		</div>
	)
}

/*
Introduction:
This file demonstrates how to create a shape with custom geometry in tldraw. The 
shape we're creating is a simple house shape with a door. The HouseShapeUtil class 
defines the behavior and appearance of our custom house shape.

[1]
The getGeometry method defines the geometric representation of our shape. This geometry
is used for hit-testing, intersection checking and other geometric calculations. We use 
Polygon2d for the house body and Rectangle2d for the door. These are combined into a 
Group2d to form the complete house geometry.

[2]
The component method determines how our shape is rendered. We create SVG paths for 
both the house body and the door, combining them into a single path element. This 
method is called when the shape needs to be drawn on the canvas. The tl-svg-container
class contains some helpful styles for rendering the svg correctly.

[3]
The indicator method renders the same path as a thin blue line when the shape is selected.

[4]
The getHouseVertices function calculates the vertices for both the house body and the door 
based on the shape's dimensions. This is used by both the geometry and rendering methods 
to ensure consistency in the shape's appearance.

*/
```

--------

# Custom shape migrations

Category: Shapes & tools

Keywords: version, update

Migrate your shapes and their data between versions

Sometimes you'll want to update the way a shape works in your application. When this happens there can be a risk of errors and bugs. For example, users with an old version of a shape in their documents might encounter errors when the editor tries to access a property that doesn't exist. This example shows how you can use our migrations system to preserve your users' data between versions. It uses a snapshot to load a document with a shape that is missing a "color" prop, and uses the migrations method of the shape util to update it.

## App.tsx

```tsx
import {
	BaseBoxShapeUtil,
	HTMLContainer,
	T,
	TLBaseShape,
	TLResizeInfo,
	TLStoreSnapshot,
	Tldraw,
	createShapePropsMigrationIds,
	createShapePropsMigrationSequence,
	resizeBox,
} from 'tldraw'
import 'tldraw/tldraw.css'
import snapshot from './snapshot.json'

// There's a guide at the bottom of this file!

export type IMyShape = TLBaseShape<
	'myshape',
	{
		w: number
		h: number
		color: string
	}
>

// [1]
const versions = createShapePropsMigrationIds(
	// this must match the shape type in the shape definition
	'myshape',
	{
		AddColor: 1,
	}
)

// [2]
export const cardShapeMigrations = createShapePropsMigrationSequence({
	sequence: [
		{
			id: versions.AddColor,
			up(props) {
				// it is safe to mutate the props object here
				props.color = 'lightblue'
			},
			down(props) {
				delete props.color
			},
		},
	],
})

export class MigratedShapeUtil extends BaseBoxShapeUtil<IMyShape> {
	static override type = 'myshape' as const

	static override props = {
		w: T.number,
		h: T.number,
		color: T.string,
	}

	// [3]
	static override migrations = cardShapeMigrations

	getDefaultProps(): IMyShape['props'] {
		return {
			w: 300,
			h: 300,
			color: 'lightblue',
		}
	}

	component(shape: IMyShape) {
		return (
			<HTMLContainer
				id={shape.id}
				style={{
					backgroundColor: shape.props.color,
					boxShadow: '0 0 10px rgba(0,0,0,0.5)',
				}}
			></HTMLContainer>
		)
	}

	indicator(shape: IMyShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}

	override onResize(shape: IMyShape, info: TLResizeInfo<IMyShape>) {
		return resizeBox(shape, info)
	}
}

const customShapeUtils = [MigratedShapeUtil]

export default function ShapeWithMigrationsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// Pass in the array of custom shape classes
				shapeUtils={customShapeUtils}
				// Use a snapshot to load an old version of the shape
				snapshot={snapshot as TLStoreSnapshot}
			/>
		</div>
	)
}

/* 
Introduction:

Sometimes you'll want to update the way a shape works in your application without breaking older
versions of the shape that a user may have stored or persisted in memory. 

This example shows how you can use our migrations system to upgrade (or downgrade) user's data
between different versions. Most of the code above is general "custom shape" codeâ€”see our custom
shape example for more details.

[1] First, we need IDs for each migration. List each change with its version number. Once you've
added a migration, it should not change again.

[2] Next, we create a migration sequence. This is where we actually write our migration logic. Each
migration had three parts: an `id` (created in [1]), an `up` migration and `down` migration. In this
case, the `up` migration adds the `color` prop to the shape, and the `down` migration removes it.

In some cases (mainly in multiplayer sessions) a peer or server may need to take a later version of
a shape and migrate it down to an older versionâ€”in this case, it would run the down migrations in
order to get it to the needed version.

[3] Finally, we add our migrations to the ShapeUtil. This tells tldraw about the migrations so they
can be used with your shapes.

How it works:

Each time the editor's store creates a snapshot (`editor.store.createSnapshot`), it serializes all
of the records (the snapshot's `store`) as well as versions of each record that it contains (the
snapshot's `schema`). When the editor loads a snapshot, it compares its current schema with the
snapshot's schema to determine which migrations to apply to each record.

In this example, we have a snapshot (snapshot.json) that we created in version 0, however our shape
now has a 'color' prop that was added in version 1. 

The snapshot looks something like this:

```json{
{
    "store": {
        "shape:BqG5uIAa9ig2-ukfnxwBX": {
            ...,
            "props": {
                "w": 300,
                "h": 300
            },
        },
	},
	"schema": {
		...,
		"sequences": {
			...,
			"com.tldraw.shape.arrow": 4,
			"com.tldraw.shape.myshape": 0
		}
	}
}
```

Note that the shape in the snapshot doesn't have a 'color' prop. 

Note also that the schema's version for this shape is 0.

When the editor loads the snapshot, it will compare the serialized schema's version with its current
schema's version for the shape, which is 1 as defined in our shape's migrations. Since the
serialized version is older than its current version, it will use our migration to bring it up to
date: it will run the migration's `up` function, which will add the 'color' prop to the shape.
*/
```

--------

# Custom shape SVG export

Category: Shapes & tools

Keywords: basic, svg, custom, export, copy

Determine how your custom shapes look when copied/exported as an image.

The "export as SVG/PNG" and "copy as SVG/PNG" actions use the `toSvg` or `toBackgroundSvg` methods of a shape util. If a shape does not have a `toSvg` or `toBackgroundSvg` method defined, it will default to placing the shape's component inside a `<foreignObject>` element.

## App.tsx

```tsx
import { ReactElement } from 'react'
import {
	Geometry2d,
	HTMLContainer,
	RecordProps,
	Rectangle2d,
	ShapeUtil,
	SvgExportContext,
	T,
	TLBaseShape,
	Tldraw,
} from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

type ICustomShape = TLBaseShape<
	'my-custom-shape',
	{
		w: number
		h: number
	}
>

const LIGHT_FILL = '#ff8888'
const DARK_FILL = '#ffcccc'

export class MyShapeUtil extends ShapeUtil<ICustomShape> {
	static override type = 'my-custom-shape' as const
	static override props: RecordProps<ICustomShape> = {
		w: T.number,
		h: T.number,
	}

	getDefaultProps(): ICustomShape['props'] {
		return {
			w: 200,
			h: 200,
		}
	}

	override canEdit() {
		return false
	}
	override canResize() {
		return false
	}
	override isAspectRatioLocked() {
		return false
	}

	getGeometry(shape: ICustomShape): Geometry2d {
		return new Rectangle2d({
			width: shape.props.w,
			height: shape.props.h,
			isFilled: true,
		})
	}

	component(_shape: ICustomShape) {
		const isDarkmode = this.editor.user.getIsDarkMode()
		return <HTMLContainer style={{ backgroundColor: isDarkmode ? DARK_FILL : LIGHT_FILL }} />
	}

	indicator(shape: ICustomShape) {
		return this.getSvgRect(shape)
	}

	// [1]
	override toSvg(
		shape: ICustomShape,
		ctx: SvgExportContext
	): ReactElement | null | Promise<ReactElement | null> {
		// ctx.addExportDef(getFontDef(shape))
		const isDarkmode = ctx.isDarkMode
		const fill = isDarkmode ? DARK_FILL : LIGHT_FILL
		return this.getSvgRect(shape, { fill })
	}

	getSvgRect(shape: ICustomShape, props?: { fill: string }) {
		return <rect width={shape.props.w} height={shape.props.h} {...props} />
	}

	// [2]

	// override toBackgroundSvg(
	// 	shape: ICustomShape,
	// 	ctx: SvgExportContext
	// ): ReactElement | null | Promise<ReactElement | null> {
	// 	const isDarkmode = ctx.isDarkMode
	// 	const fill = isDarkmode ? '#333' : '#efefef'
	// 	return <rect width={shape.props.w} height={shape.props.h} fill={fill} />
	// }
}

// [3]

// function getFontDef(shape: ICustomShape): SvgExportDef {
// 	//
// 	return {
// 		some unique key,
// 		key: 'my-custom-shape-font',
// 		getElement: async () => {
// 			return <style></style> element
// 			check out the defaultStyleDefs.tsx file for an example of how
// 			we do this for tldraw fonts
// 		},
// 	}
// }

const customShape = [MyShapeUtil]
export default function CustomShapeToSvgExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				shapeUtils={customShape}
				onMount={(editor) => {
					editor.createShape({ type: 'my-custom-shape', x: 100, y: 100 })
				}}
			/>
		</div>
	)
}
/*
 The "export as SVG/PNG" and "copy as SVG/PNG" actions use the `toSvg` or `toBackgroundSvg`
 methods of a shape util. If a shape does not have a `toSvg` or `toBackgroundSvg` method
 defined, it will default to an empty box.

 For more information on creating a custom shape, check out the custom shape example.

 [1]
    This method should return a React element that represents the shape as an SVG element.
    If your shape is HTML, then you will need to convert it to an SVG representation. In this
    example we've used a `rect` element to represent the shape. Other shapes may require more
    complex work to render them as SVGs, especially if they contain text. Check out [3] for more
	info.

[2]
    The `toBackgroundSvg` method is used to render a layer behind the shape when exporting as SVG.
    We use this in the tldraw codebase to make the highlighter shape. It's commented out here as
    we don't need it for this example.

[3]
	If your shape contains text, you may need to add a font definition to the SVG. This is done
	using the `addExportDef` method of the `SvgExportContext`. Your font def must contain a unique
	key and a function that returns a React element. Check out the `` function
	in the `defaultStyleDefs.tsx` file for an example of how this is done for tldraw fonts.

 */
```

--------

# Custom snapping

Category: Shapes & tools

Keywords: geometry, custom

Custom shapes with special bounds snapping behaviour.

This example shows how to create a shape with custom snapping geometry. When shapes are moved around in snap mode, they will snap to the bounds of other shapes by default. However, a shape can return custom snapping geometry to snap to instead.

In this case, we've created a custom playing card shape. The cards are designed to snap together so that the top-left icon remains visible when stacked, similar to a hand of cards in a game.

## App.tsx

```tsx
import { Editor, TLStoreSnapshot, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import { PlayingCardTool } from './PlayingCardShape/playing-card-tool'
import { PlayingCardUtil } from './PlayingCardShape/playing-card-util'
import snapshot from './snapshot.json'
import { components, uiOverrides } from './ui-overrides'
// There's a guide at the bottom of this file!

// [1]
const customShapes = [PlayingCardUtil]
const customTools = [PlayingCardTool]

export default function BoundsSnappingShapeExample() {
	// [2]
	const handleMount = (editor: Editor) => {
		editor.user.updateUserPreferences({ isSnapMode: true })
	}
	// [3]
	return (
		<div className="tldraw__editor">
			<Tldraw
				//[a]
				shapeUtils={customShapes}
				tools={customTools}
				// [b]
				overrides={uiOverrides}
				components={components}
				// [c]
				onMount={handleMount}
				// [d]
				snapshot={snapshot as TLStoreSnapshot}
			/>
		</div>
	)
}

/*
Introduction:

This example shows how to create a shape with custom snapping geometry. When shapes are moved around
in snap mode, they will snap to the bounds of other shapes by default. A shape can return custom
snapping geometry to snap to instead. This example creates a playing card shape. The cards are
designed to snap together so that the top-left icon remains visible when stacked, similar to a hand
of cards in a game. The most relevant code for this customisation is in playing-card-util.tsx.

[1]
We define the custom shape and util arrays we'll pass to the Tldraw component. It's important to do
this outside of the component so that the arrays don't change on every render.

This is where we define the Tldraw component and pass in all our customisations.

[2]

We define a handleMount function that will be called when the editor mounts. We're using it to set
the snap mode to true in the user preferences. This is just to help demonstrate the custom snapping
geometry feature. Without snap mode being set in this way the user can still enter it by holding
cmd/ctrl while dragging.

[3]
This is where we're passing in all our customisations to the Tldraw component. Check out the
associated files for more information on what's being passed in.

    [a] Firstly, our custom shape (playing-card-util.tsx) and tool (playing-card-tool.tsx)
        This tells the editor about our custom shape and tool.
    [b] Then our the uiOverrides and custom keyboard shortcuts component (ui-overrides.tsx),
        this makes sure that an icon for our tool appears in the toolbar and the shortcut
        for it appears in the dialog.
    [c] We pass in our handleMount function so that it's called when the editor mounts.

    [d] Finally we pass in a snapshot so that the editor starts with some shapes in it.
        This isn't necessary, it just makes the example clearer on first glance.

*/
```

## ui-overrides.tsx

```tsx
import {
	DefaultKeyboardShortcutsDialog,
	DefaultKeyboardShortcutsDialogContent,
	DefaultToolbar,
	DefaultToolbarContent,
	TLComponents,
	TLUiOverrides,
	TldrawUiMenuItem,
	useIsToolSelected,
	useTools,
} from 'tldraw'

// There's a guide at the bottom of this file!

export const uiOverrides: TLUiOverrides = {
	tools(editor, tools) {
		// Create a tool item in the ui's context.
		tools.PlayingCard = {
			id: 'PlayingCard',
			icon: <span style={{ fontSize: '2em' }}>ðŸƒ</span>,
			label: 'Playing Card',
			kbd: 'c',
			onSelect: () => {
				editor.setCurrentTool('PlayingCard')
			},
		}
		return tools
	},
}

export const components: TLComponents = {
	Toolbar: (props) => {
		const tools = useTools()
		const isCardSelected = useIsToolSelected(tools['PlayingCard'])
		return (
			<DefaultToolbar {...props}>
				<TldrawUiMenuItem {...tools['PlayingCard']} isSelected={isCardSelected} />
				<DefaultToolbarContent />
			</DefaultToolbar>
		)
	},
	KeyboardShortcutsDialog: (props) => {
		const tools = useTools()
		return (
			<DefaultKeyboardShortcutsDialog {...props}>
				<TldrawUiMenuItem {...tools['PlayingCard']} />
				<DefaultKeyboardShortcutsDialogContent />
			</DefaultKeyboardShortcutsDialog>
		)
	},
}

/* 

This file contains overrides for the Tldraw UI. These overrides are used to add your custom tools to
the toolbar and the keyboard shortcuts menu.

First we have to add our new tool to the tools object in the tools override. This is where we define
all the basic information about our new tool - its icon, label, keyboard shortcut, what happens when
we select it, etc.

Then, we replace the UI components for the toolbar and keyboard shortcut dialog with our own, that
add our new tool to the existing default content. Ideally, we'd interleave our new tool into the
ideal place among the default tools, but for now we're just adding it at the start to keep things
simple.
*/
```

## playing-card-tool.tsx

```tsx
import { BaseBoxShapeTool } from 'tldraw'
export class PlayingCardTool extends BaseBoxShapeTool {
	static override id = 'PlayingCard'
	static override initial = 'idle'
	override shapeType = 'PlayingCard'
}

/*
This file contains our custom tool. The tool is a StateNode with the `id` "PlayingCard".

We get a lot of functionality for free by extending the BaseBoxShapeTool. but we can
handle events in our own way by overriding methods like onDoubleClick. For an example 
of a tool with more custom functionality, check out the screenshot-tool example. 

*/
```

## playing-card-util.tsx

```tsx
import {
	BaseBoxShapeUtil,
	BoundsSnapGeometry,
	HTMLContainer,
	RecordProps,
	Rectangle2d,
	T,
	TLBaseShape,
} from 'tldraw'

// There's a guide at the bottom of this file!

// [1]
type IPlayingCard = TLBaseShape<
	'PlayingCard',
	{
		w: number
		h: number
		suit: string
	}
>

export class PlayingCardUtil extends BaseBoxShapeUtil<IPlayingCard> {
	// [2]
	static override type = 'PlayingCard' as const
	static override props: RecordProps<IPlayingCard> = {
		w: T.number,
		h: T.number,
		suit: T.string,
	}

	// [3]
	override isAspectRatioLocked(_shape: IPlayingCard) {
		return true
	}

	// [4]
	getDefaultProps(): IPlayingCard['props'] {
		const cardSuitsArray: string[] = ['â™ ï¸', 'â™£ï¸', 'â™¥ï¸', 'â™¦ï¸']
		const randomSuit = cardSuitsArray[Math.floor(Math.random() * cardSuitsArray.length)]
		return {
			w: 270,
			h: 370,
			suit: randomSuit,
		}
	}

	// [5]
	override getBoundsSnapGeometry(shape: IPlayingCard): BoundsSnapGeometry {
		return {
			points: new Rectangle2d({
				width: shape.props.h / 4.5,
				height: shape.props.h / 4.5,
				isFilled: true,
			}).bounds.cornersAndCenter,
		}
	}

	// [7]
	component(shape: IPlayingCard) {
		return (
			<HTMLContainer
				style={{
					height: shape.props.h,
					width: shape.props.w,
					backgroundColor: 'white',
					boxShadow: '0 0 10px 0 rgba(0, 0, 0, 0.2)',
					position: 'relative',
					display: 'flex',
					justifyContent: 'center',
					alignItems: 'center',
					padding: 8,
				}}
				id={shape.id}
			>
				<span
					style={{
						position: 'absolute',
						top: 0,
						left: 0,
						display: 'flex',
						justifyContent: 'center',
						alignItems: 'center',
						height: shape.props.h / 4.5,
						width: shape.props.h / 4.5,
						fontSize: shape.props.h / 5,
					}}
				>
					{shape.props.suit}
				</span>
				<div style={{ fontSize: shape.props.h / 3 }}>{shape.props.suit}</div>
			</HTMLContainer>
		)
	}

	// [7]
	indicator(shape: IPlayingCard) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}

/* 
This is a utility class for the PlayingCard shape. This is where you define the shape's behavior, 
how it renders (its component and indicator), and how it handles different events. The most relevant
part of the code to custom snapping can be found in [6].

[1]
This is where we define the shape's type for Typescript. We can extend the TLBaseShape type,
providing a unique string to identify the shape and the shape's props. We only need height
and width for this shape.

[2]
We define the shape's type and props for the editor. We can use tldraw's validator library to
make sure that the store always has shape data we can trust. In this case, we define the width 
and height properties as numbers and assign a validator from tldraw's library to them.

[3]
We're going to lock the aspect ratio of this shape.

[4]
getDefaultProps determines what our shape looks like when click-creating one. In this case, we
want the shape to be 270x370 pixels and generate a suit for the card at random.

[5]
This is the important part for custom snapping. We define the getBoundsSnapGeometry method. This
method returns the geometry that the shape will snap to. In this case, we want the shape to snap
to a rectangle in the top left that contains the suit of the card. We can use the Rectangle2d helper
again here and set it to the same width and height as the span containing the suit which is defined
in [6].

[6]
We define the component method. This controls what the shape looks like and it returns JSX. It
generates a random suit for the card and returns a div with the suit in the center and a span with
the suit in the top left. The HTMLContainer component is a helpful wrapper that the tldraw library
exports, it's a div that comes with a css class.

[7]
The indicator is the blue box that appears around the shape when it's selected. We're just returning
a rectangle with the same width and height as the shape here.


*/
```

--------

# Data grid shape

Category: Shapes & tools

Keywords: data grid ag grid

A custom shape that renders AG Grid.

This example shows how to create a custom shape that renders AG Grid.

## App.tsx

```tsx
/* eslint-disable react-hooks/rules-of-hooks */
import { AgGridReact } from 'ag-grid-react'
import { BaseBoxShapeUtil, TLBaseShape, Tldraw, createShapeId, useDelaySvgExport } from 'tldraw'

import 'ag-grid-community/styles/ag-grid.css'
import 'ag-grid-community/styles/ag-theme-quartz.css'
import 'tldraw/tldraw.css'

type AgGridShape = TLBaseShape<
	'ag-grid',
	{ w: number; h: number; rowData: any[]; columnDefs: any[] }
>
class AgGridShapeUtil extends BaseBoxShapeUtil<AgGridShape> {
	static override type = 'ag-grid'

	override canScroll(): boolean {
		return true
	}

	override canEdit(): boolean {
		return true
	}

	override getDefaultProps() {
		return {
			w: 300,
			h: 200,
			rowData: [],
			columnDefs: [],
		}
	}
	override component(shape: AgGridShape) {
		const isEditing = this.editor.getEditingShapeId() === shape.id
		const isReady = useDelaySvgExport()

		return (
			<div
				style={{
					width: shape.props.w,
					height: shape.props.h,
					pointerEvents: isEditing ? 'all' : undefined,
				}}
				className="ag-theme-quartz"
			>
				<AgGridReact
					onGridReady={isReady}
					rowData={shape.props.rowData}
					columnDefs={shape.props.columnDefs}
					// autoSizeStrategy={{ type: 'f', width: shape.props.w }}
				/>
			</div>
		)
	}
	override indicator(shape: AgGridShape) {
		return <rect width={shape.props.w} height={shape.props.h} rx={8} ry={8} />
	}
}

export default function DataGridExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="ag-grid-example"
				shapeUtils={[AgGridShapeUtil]}
				onMount={(editor) => {
					const agGridShapeId = createShapeId('ag-grid')

					if (!editor.getShape(agGridShapeId)) {
						editor.createShape<AgGridShape>({
							id: agGridShapeId,
							type: 'ag-grid',
							props: {
								w: 400,
								h: 300,
								rowData: [
									{ make: 'Tesla', model: 'Model Y', price: 64950, electric: true },
									{ make: 'Ford', model: 'F-Series', price: 33850, electric: false },
									{ make: 'Toyota', model: 'Corolla', price: 29600, electric: false },
								],
								columnDefs: [
									{ field: 'make', filter: true, floatingFilter: true, flex: 1 },
									{ field: 'model', flex: 1 },
									{ field: 'price', filter: true, floatingFilter: true, flex: 1 },
									{ field: 'electric', flex: 1 },
								],
							},
						})
						editor.select(agGridShapeId)
						editor.zoomToSelection()
					}
				}}
			/>
		</div>
	)
}
```

--------

# Drag and drop shape

Category: Shapes & tools

Keywords: reparent, shapes, grid, counter

Custom shapes that can be dragged and dropped onto each other.

This example shows how to create custom shapes that can be dragged and dropped onto each other.

## App.tsx

```tsx
import {
	Circle2d,
	Geometry2d,
	HTMLContainer,
	Rectangle2d,
	ShapeUtil,
	TLBaseShape,
	TLDragShapesOutInfo,
	TLShape,
	Tldraw,
} from 'tldraw'
import 'tldraw/tldraw.css'

// [1]
type MyGridShape = TLBaseShape<'my-grid-shape', Record<string, never>>
type MyCounterShape = TLBaseShape<'my-counter-shape', Record<string, never>>

// [2]
const SLOT_SIZE = 100
class MyCounterShapeUtil extends ShapeUtil<MyCounterShape> {
	static override type = 'my-counter-shape' as const

	override canResize() {
		return false
	}
	override hideResizeHandles() {
		return true
	}

	getDefaultProps(): MyCounterShape['props'] {
		return {}
	}

	getGeometry(): Geometry2d {
		return new Circle2d({ radius: SLOT_SIZE / 2 - 10, isFilled: true })
	}

	component() {
		return (
			<HTMLContainer
				style={{
					backgroundColor: '#e03131',
					border: '1px solid #ff8787',
					borderRadius: '50%',
				}}
			/>
		)
	}

	indicator() {
		return <circle r={SLOT_SIZE / 2 - 10} cx={SLOT_SIZE / 2 - 10} cy={SLOT_SIZE / 2 - 10} />
	}
}

// [3]
class MyGridShapeUtil extends ShapeUtil<MyGridShape> {
	static override type = 'my-grid-shape' as const

	getDefaultProps(): MyGridShape['props'] {
		return {}
	}

	getGeometry(): Geometry2d {
		return new Rectangle2d({
			width: SLOT_SIZE * 5,
			height: SLOT_SIZE * 2,
			isFilled: true,
		})
	}

	override canResize() {
		return false
	}
	override hideResizeHandles() {
		return true
	}

	// [5]
	override onDragShapesIn(shape: MyGridShape, draggingShapes: TLShape[]): void {
		const { editor } = this
		const reparentingShapes = draggingShapes.filter(
			(s) => s.parentId !== shape.id && s.type === 'my-counter-shape'
		)
		if (reparentingShapes.length === 0) return
		editor.reparentShapes(reparentingShapes, shape.id)
	}

	// [6]
	override onDragShapesOut(
		shape: MyGridShape,
		draggingShapes: TLShape[],
		info: TLDragShapesOutInfo
	): void {
		const { editor } = this
		const reparentingShapes = draggingShapes.filter((s) => s.parentId !== shape.id)
		if (!info.nextDraggingOverShapeId) {
			editor.reparentShapes(reparentingShapes, editor.getCurrentPageId())
		}
	}

	component() {
		return (
			<HTMLContainer
				style={{
					backgroundColor: '#efefef',
					borderRight: '1px solid #ccc',
					borderBottom: '1px solid #ccc',
					backgroundSize: `${SLOT_SIZE}px ${SLOT_SIZE}px`,
					backgroundImage: `
						linear-gradient(to right, #ccc 1px, transparent 1px),
						linear-gradient(to bottom, #ccc 1px, transparent 1px)
					`,
				}}
			/>
		)
	}

	indicator() {
		return <rect width={SLOT_SIZE * 5} height={SLOT_SIZE * 2} />
	}
}

export default function DragAndDropExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				shapeUtils={[MyGridShapeUtil, MyCounterShapeUtil]}
				onMount={(editor) => {
					if (editor.getCurrentPageShapeIds().size > 0) return
					editor.createShape({ type: 'my-grid-shape', x: 100, y: 100 })
					editor.createShape({ type: 'my-counter-shape', x: 700, y: 100 })
					editor.createShape({ type: 'my-counter-shape', x: 750, y: 200 })
					editor.createShape({ type: 'my-counter-shape', x: 770, y: 300 })
				}}
			/>
		</div>
	)
}

/*
[1]
Define custom shape types using TLBaseShape. Each shape type needs a unique identifier and can have custom 
properties. Here we use Record<string, never> since our shapes don't need any custom properties. These are 
very basic custom shapes: see the custom shape examples for more complex examples.

[2]
Create a ShapeUtil for the counter shape. This defines how the shape behaves and renders. We disable resizing 
and use Circle2d geometry for collision detection. The component renders as a red circle using HTMLContainer.

[3]
Create a ShapeUtil for the grid shape. This creates a rectangular grid that can accept dropped shapes. We use 
Rectangle2d geometry and render it with CSS grid lines using background gradients.

[5]
Override onDragShapesIn to handle when shapes are dragged into the grid. We filter for counter shapes that
aren't already children of this grid, then reparent them to become children. This makes them move with the grid. 

[6]
Override onDragShapesOut to handle when shapes are dragged out of the grid. If they're not being dragged to
another shape, we reparent them back to the page level, making them independent again.
*/
```

--------

# Attach shapes together (bindings)

Category: Shapes & tools

Keywords: attach

A sticker shape, using bindings to attach shapes to one and other

This example shows how to use bindings to attach shapes together. In this case, we've created a sticker that can be stuck onto other shapes.

## App.tsx

```tsx
import {
	BindingOnShapeChangeOptions,
	BindingOnShapeDeleteOptions,
	BindingUtil,
	Box,
	DefaultToolbar,
	DefaultToolbarContent,
	RecordProps,
	Rectangle2d,
	ShapeUtil,
	StateNode,
	TLBaseBinding,
	TLBaseShape,
	TLPointerEventInfo,
	TLUiComponents,
	TLUiOverrides,
	Tldraw,
	TldrawUiMenuItem,
	VecModel,
	createShapeId,
	invLerp,
	lerp,
	useIsToolSelected,
	useTools,
} from 'tldraw'
import 'tldraw/tldraw.css'

// eslint-disable-next-line @typescript-eslint/no-empty-object-type
type StickerShape = TLBaseShape<'sticker', {}>

const offsetX = -16
const offsetY = -26
class StickerShapeUtil extends ShapeUtil<StickerShape> {
	static override type = 'sticker' as const
	static override props: RecordProps<StickerShape> = {}

	override getDefaultProps() {
		return {}
	}

	override canBind() {
		// stickers can bind to anything
		return true
	}
	override canEdit() {
		return false
	}
	override canResize() {
		return false
	}
	override canSnap() {
		return false
	}
	override hideRotateHandle() {
		return true
	}
	override isAspectRatioLocked() {
		return true
	}

	override getGeometry() {
		return new Rectangle2d({
			width: 32,
			height: 32,
			x: offsetX,
			y: offsetY,
			isFilled: true,
		})
	}

	override component() {
		return (
			<div
				style={{
					width: '100%',
					height: '100%',
					marginLeft: offsetX,
					marginTop: offsetY,
					fontSize: '26px',
					textAlign: 'center',
				}}
			>
				â¤ï¸
			</div>
		)
	}

	override indicator() {
		return <rect width={32} height={32} x={offsetX} y={offsetY} />
	}

	override onTranslateStart(shape: StickerShape) {
		const bindings = this.editor.getBindingsFromShape(shape, 'sticker')
		this.editor.deleteBindings(bindings)
	}

	override onTranslateEnd(_initial: StickerShape, sticker: StickerShape) {
		const pageAnchor = this.editor.getShapePageTransform(sticker).applyToPoint({ x: 0, y: 0 })
		const target = this.editor.getShapeAtPoint(pageAnchor, {
			hitInside: true,
			filter: (shape) =>
				shape.id !== sticker.id &&
				this.editor.canBindShapes({ fromShape: sticker, toShape: shape, binding: 'sticker' }),
		})

		if (!target) return

		const targetBounds = Box.ZeroFix(this.editor.getShapeGeometry(target)!.bounds)
		const pointInTargetSpace = this.editor.getPointInShapeSpace(target, pageAnchor)

		const anchor = {
			x: invLerp(targetBounds.minX, targetBounds.maxX, pointInTargetSpace.x),
			y: invLerp(targetBounds.minY, targetBounds.maxY, pointInTargetSpace.y),
		}

		this.editor.createBinding({
			type: 'sticker',
			fromId: sticker.id,
			toId: target.id,
			props: {
				anchor,
			},
		})
	}
}

type StickerBinding = TLBaseBinding<
	'sticker',
	{
		anchor: VecModel
	}
>
class StickerBindingUtil extends BindingUtil<StickerBinding> {
	static override type = 'sticker' as const

	override getDefaultProps() {
		return {
			anchor: { x: 0.5, y: 0.5 },
		}
	}

	// when the shape we're stuck to changes, update the sticker's position
	override onAfterChangeToShape({
		binding,
		shapeAfter,
	}: BindingOnShapeChangeOptions<StickerBinding>): void {
		const sticker = this.editor.getShape<StickerShape>(binding.fromId)!

		const shapeBounds = this.editor.getShapeGeometry(shapeAfter)!.bounds
		const shapeAnchor = {
			x: lerp(shapeBounds.minX, shapeBounds.maxX, binding.props.anchor.x),
			y: lerp(shapeBounds.minY, shapeBounds.maxY, binding.props.anchor.y),
		}
		const pageAnchor = this.editor.getShapePageTransform(shapeAfter).applyToPoint(shapeAnchor)

		const stickerParentAnchor = this.editor
			.getShapeParentTransform(sticker)
			.invert()
			.applyToPoint(pageAnchor)

		this.editor.updateShape({
			id: sticker.id,
			type: 'sticker',
			x: stickerParentAnchor.x,
			y: stickerParentAnchor.y,
		})
	}

	// when the thing we're stuck to is deleted, delete the sticker too
	override onBeforeDeleteToShape({ binding }: BindingOnShapeDeleteOptions<StickerBinding>): void {
		this.editor.deleteShape(binding.fromId)
	}
}

class StickerTool extends StateNode {
	static override id = 'sticker'

	override onEnter() {
		this.editor.setCursor({ type: 'cross', rotation: 0 })
	}

	override onPointerDown(info: TLPointerEventInfo) {
		const { currentPagePoint } = this.editor.inputs
		const stickerId = createShapeId()
		this.editor.markHistoryStoppingPoint()
		this.editor.createShape({
			id: stickerId,
			type: 'sticker',
			x: currentPagePoint.x,
			y: currentPagePoint.y,
		})
		this.editor.setSelectedShapes([stickerId])
		this.editor.setCurrentTool('select.translating', {
			...info,
			target: 'shape',
			shape: this.editor.getShape(stickerId),
			isCreating: true,
			onInteractionEnd: 'sticker',
			onCreate: () => {
				this.editor.setCurrentTool('sticker')
			},
		})
	}
}

const overrides: TLUiOverrides = {
	tools(editor, schema) {
		schema['sticker'] = {
			id: 'sticker',
			label: 'Sticker',
			icon: 'heart-icon',
			kbd: 'p',
			onSelect: () => {
				editor.setCurrentTool('sticker')
			},
		}
		return schema
	},
}

const components: TLUiComponents = {
	Toolbar: (...props) => {
		const sticker = useTools().sticker
		const isStickerSelected = useIsToolSelected(sticker)
		return (
			<DefaultToolbar {...props}>
				<TldrawUiMenuItem {...sticker} isSelected={isStickerSelected} />
				<DefaultToolbarContent />
			</DefaultToolbar>
		)
	},
}

export default function StickerExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					;(window as any).editor = editor
				}}
				shapeUtils={[StickerShapeUtil]}
				bindingUtils={[StickerBindingUtil]}
				tools={[StickerTool]}
				overrides={overrides}
				components={components}
			/>
		</div>
	)
}
```

--------

# Layout constraints (bindings)

Category: Shapes & tools

Keywords: constraints, group, shape, custom, bindings, drag, drop, position

How to constrain shapes to a layout using bindings.

You can use bindings to make shapes respond to changes to other shapes. This is useful for enforcing layout constraints

## App.tsx

```tsx
import {
	BindingOnChangeOptions,
	BindingOnCreateOptions,
	BindingOnDeleteOptions,
	BindingOnShapeChangeOptions,
	BindingUtil,
	HTMLContainer,
	IndexKey,
	RecordProps,
	Rectangle2d,
	ShapeUtil,
	T,
	TLBaseBinding,
	TLBaseShape,
	Tldraw,
	Vec,
	clamp,
	createBindingId,
	getIndexBetween,
} from 'tldraw'
import 'tldraw/tldraw.css'
import snapShot from './snapshot.json'

// The container shapes that can contain element shapes

const CONTAINER_PADDING = 24

type ContainerShape = TLBaseShape<'element', { height: number; width: number }>

class ContainerShapeUtil extends ShapeUtil<ContainerShape> {
	static override type = 'container' as const
	static override props: RecordProps<ContainerShape> = { height: T.number, width: T.number }

	override getDefaultProps() {
		return {
			width: 100 + CONTAINER_PADDING * 2,
			height: 100 + CONTAINER_PADDING * 2,
		}
	}

	override canBind({
		fromShapeType,
		toShapeType,
		bindingType,
	}: {
		fromShapeType: string
		toShapeType: string
		bindingType: string
	}) {
		return fromShapeType === 'container' && toShapeType === 'element' && bindingType === 'layout'
	}
	override canEdit() {
		return false
	}
	override canResize() {
		return false
	}
	override hideRotateHandle() {
		return true
	}
	override isAspectRatioLocked() {
		return true
	}

	override getGeometry(shape: ContainerShape) {
		return new Rectangle2d({
			width: shape.props.width,
			height: shape.props.height,
			isFilled: true,
		})
	}

	override component(shape: ContainerShape) {
		return (
			<HTMLContainer
				style={{
					backgroundColor: '#efefef',
					width: shape.props.width,
					height: shape.props.height,
				}}
			/>
		)
	}

	override indicator(shape: ContainerShape) {
		return <rect width={shape.props.width} height={shape.props.height} />
	}
}

// The element shapes that can be placed inside the container shapes

type ElementShape = TLBaseShape<'element', { color: string }>

class ElementShapeUtil extends ShapeUtil<ElementShape> {
	static override type = 'element' as const
	static override props: RecordProps<ElementShape> = {
		color: T.string,
	}

	override getDefaultProps() {
		return {
			color: '#AEC6CF',
		}
	}

	override canBind({
		fromShapeType,
		toShapeType,
		bindingType,
	}: {
		fromShapeType: string
		toShapeType: string
		bindingType: string
	}) {
		return fromShapeType === 'container' && toShapeType === 'element' && bindingType === 'layout'
	}
	override canEdit() {
		return false
	}
	override canResize() {
		return false
	}
	override hideRotateHandle() {
		return true
	}
	override isAspectRatioLocked() {
		return true
	}

	override getGeometry() {
		return new Rectangle2d({
			width: 100,
			height: 100,
			isFilled: true,
		})
	}

	override component(shape: ElementShape) {
		return <HTMLContainer style={{ backgroundColor: shape.props.color }}></HTMLContainer>
	}

	override indicator() {
		return <rect width={100} height={100} />
	}

	private getTargetContainer(shape: ElementShape, pageAnchor: Vec) {
		// Find the container shape that the element is being dropped on
		return this.editor.getShapeAtPoint(pageAnchor, {
			hitInside: true,
			filter: (otherShape) =>
				this.editor.canBindShapes({ fromShape: otherShape, toShape: shape, binding: 'layout' }),
		}) as ContainerShape | undefined
	}

	getBindingIndexForPosition(shape: ElementShape, container: ContainerShape, pageAnchor: Vec) {
		// All the layout bindings from the container
		const allBindings = this.editor
			.getBindingsFromShape<LayoutBinding>(container, 'layout')
			.sort((a, b) => (a.props.index > b.props.index ? 1 : -1))

		// Those bindings that don't involve the element
		const siblings = allBindings.filter((b) => b.toId !== shape.id)

		// Get the relative x position of the element center in the container
		// Where should the element be placed? min index at left, max index + 1
		const order = clamp(
			Math.round((pageAnchor.x - container.x - CONTAINER_PADDING) / (100 + CONTAINER_PADDING)),
			0,
			siblings.length + 1
		)

		// Get a fractional index between the two siblings
		const belowSib = allBindings[order - 1]
		const aboveSib = allBindings[order]
		let index: IndexKey

		if (belowSib?.toId === shape.id) {
			index = belowSib.props.index
		} else if (aboveSib?.toId === shape.id) {
			index = aboveSib.props.index
		} else {
			index = getIndexBetween(belowSib?.props.index, aboveSib?.props.index)
		}

		return index
	}

	override onTranslateStart(shape: ElementShape) {
		// Update all the layout bindings for this shape to be placeholders
		this.editor.updateBindings(
			this.editor.getBindingsToShape<LayoutBinding>(shape, 'layout').map((binding) => ({
				...binding,
				props: { ...binding.props, placeholder: true },
			}))
		)
	}

	override onTranslate(_: ElementShape, shape: ElementShape) {
		// Find the center of the element shape
		const pageAnchor = this.editor.getShapePageTransform(shape).applyToPoint({ x: 50, y: 50 })

		// Find the container shape that the element is being dropped on
		const targetContainer = this.getTargetContainer(shape, pageAnchor)

		if (!targetContainer) {
			// Delete all the bindings to the element
			const bindings = this.editor.getBindingsToShape<LayoutBinding>(shape, 'layout')
			this.editor.deleteBindings(bindings)
			return
		}

		// Get the index for the new binding
		const index = this.getBindingIndexForPosition(shape, targetContainer, pageAnchor)

		// Is there an existing binding already between the container and the shape?
		const existingBinding = this.editor
			.getBindingsFromShape<LayoutBinding>(targetContainer, 'layout')
			.find((b) => b.toId === shape.id)

		if (existingBinding) {
			// If a binding already exists, update it
			if (existingBinding.props.index === index) return
			this.editor.updateBinding<LayoutBinding>({
				...existingBinding,
				props: {
					...existingBinding.props,
					placeholder: true,
					index,
				},
			})
		} else {
			// ...otherwise, create a new one
			this.editor.createBinding<LayoutBinding>({
				id: createBindingId(),
				type: 'layout',
				fromId: targetContainer.id,
				toId: shape.id,
				props: {
					index,
					placeholder: true,
				},
			})
		}
	}

	override onTranslateEnd(_: ElementShape, shape: ElementShape) {
		// Find the center of the element shape
		const pageAnchor = this.editor.getShapePageTransform(shape).applyToPoint({ x: 50, y: 50 })

		// Find the container shape that the element is being dropped on
		const targetContainer = this.getTargetContainer(shape, pageAnchor)

		// No target container? no problem
		if (!targetContainer) return

		// get the index for the new binding
		const index = this.getBindingIndexForPosition(shape, targetContainer, pageAnchor)

		// delete all the previous bindings for this shape
		this.editor.deleteBindings(this.editor.getBindingsToShape<LayoutBinding>(shape, 'layout'))

		// ...and then create a new one
		this.editor.createBinding<LayoutBinding>({
			id: createBindingId(),
			type: 'layout',
			fromId: targetContainer.id,
			toId: shape.id,
			props: {
				index,
				placeholder: false,
			},
		})
	}
}

// The binding between the element shapes and the container shapes

type LayoutBinding = TLBaseBinding<
	'layout',
	{
		index: IndexKey
		placeholder: boolean
	}
>

class LayoutBindingUtil extends BindingUtil<LayoutBinding> {
	static override type = 'layout' as const

	override getDefaultProps() {
		return {
			index: 'a1' as IndexKey,
			placeholder: true,
		}
	}

	override onAfterCreate({ binding }: BindingOnCreateOptions<LayoutBinding>): void {
		this.updateElementsForContainer(binding)
	}

	override onAfterChange({ bindingAfter }: BindingOnChangeOptions<LayoutBinding>): void {
		this.updateElementsForContainer(bindingAfter)
	}

	override onAfterChangeFromShape({ binding }: BindingOnShapeChangeOptions<LayoutBinding>): void {
		this.updateElementsForContainer(binding)
	}

	override onAfterDelete({ binding }: BindingOnDeleteOptions<LayoutBinding>): void {
		this.updateElementsForContainer(binding)
	}

	private updateElementsForContainer({
		props: { placeholder },
		fromId: containerId,
		toId,
	}: LayoutBinding) {
		// Get all of the bindings from the layout container
		const container = this.editor.getShape<ContainerShape>(containerId)
		if (!container) return

		const bindings = this.editor
			.getBindingsFromShape<LayoutBinding>(container, 'layout')
			.sort((a, b) => (a.props.index > b.props.index ? 1 : -1))
		if (bindings.length === 0) return

		for (let i = 0; i < bindings.length; i++) {
			const binding = bindings[i]

			if (toId === binding.toId && placeholder) continue

			const offset = new Vec(CONTAINER_PADDING + i * (100 + CONTAINER_PADDING), CONTAINER_PADDING)

			const shape = this.editor.getShape<ElementShape>(binding.toId)
			if (!shape) continue

			const point = this.editor.getPointInParentSpace(
				shape,
				this.editor.getShapePageTransform(container)!.applyToPoint(offset)
			)

			if (shape.x !== point.x || shape.y !== point.y) {
				this.editor.updateShape({
					id: binding.toId,
					type: 'element',
					x: point.x,
					y: point.y,
				})
			}
		}

		const width =
			CONTAINER_PADDING +
			(bindings.length * 100 + (bindings.length - 1) * CONTAINER_PADDING) +
			CONTAINER_PADDING

		const height = CONTAINER_PADDING + 100 + CONTAINER_PADDING

		if (width !== container.props.width || height !== container.props.height) {
			this.editor.updateShape({
				id: container.id,
				type: 'container',
				props: { width, height },
			})
		}
	}
}

export default function LayoutExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// @ts-ignore
				snapshot={snapShot}
				onMount={(editor) => {
					;(window as any).editor = editor
				}}
				shapeUtils={[ContainerShapeUtil, ElementShapeUtil]}
				bindingUtils={[LayoutBindingUtil]}
			/>
		</div>
	)
}
```

--------

# Pin (bindings)

Category: Shapes & tools

Keywords: 

A pin, using bindings to pin together networks of shapes.

This example shows how to use bindings to connect a network of shapes together.

To try it out, select the pin tool, then click over two overlapping shapes to pin them together.

## App.tsx

```tsx
import {
	BindingOnShapeChangeOptions,
	BindingOnShapeDeleteOptions,
	BindingUtil,
	Box,
	DefaultFillStyle,
	DefaultToolbar,
	DefaultToolbarContent,
	RecordProps,
	Rectangle2d,
	ShapeUtil,
	StateNode,
	TLBaseBinding,
	TLBaseShape,
	TLEditorComponents,
	TLPointerEventInfo,
	TLShapeId,
	TLShapeUtilCanBindOpts,
	TLUiComponents,
	TLUiOverrides,
	Tldraw,
	TldrawUiMenuItem,
	Vec,
	VecModel,
	createShapeId,
	invLerp,
	lerp,
	useIsToolSelected,
	useTools,
} from 'tldraw'
import 'tldraw/tldraw.css'

// eslint-disable-next-line @typescript-eslint/no-empty-object-type
type PinShape = TLBaseShape<'pin', {}>

const offsetX = -16
const offsetY = -26
class PinShapeUtil extends ShapeUtil<PinShape> {
	static override type = 'pin' as const
	static override props: RecordProps<PinShape> = {}

	override getDefaultProps() {
		return {}
	}

	override canBind({ toShapeType, bindingType }: TLShapeUtilCanBindOpts<PinShape>) {
		if (bindingType === 'pin') {
			// pins cannot bind to other pins!
			return toShapeType !== 'pin'
		}
		// Allow pins to participate in other bindings, e.g. arrows
		return true
	}
	override canEdit() {
		return false
	}
	override canResize() {
		return false
	}
	override hideRotateHandle() {
		return true
	}
	override isAspectRatioLocked() {
		return true
	}

	override getGeometry() {
		return new Rectangle2d({
			width: 32,
			height: 32,
			x: offsetX,
			y: offsetY,
			isFilled: true,
		})
	}

	override component() {
		return (
			<div
				style={{
					width: '100%',
					height: '100%',
					marginLeft: offsetX,
					marginTop: offsetY,
					fontSize: '26px',
					textAlign: 'center',
				}}
			>
				ðŸ“
			</div>
		)
	}

	override indicator() {
		return <rect width={32} height={32} x={offsetX} y={offsetY} />
	}

	override onTranslateStart(shape: PinShape) {
		const bindings = this.editor.getBindingsFromShape(shape, 'pin')
		this.editor.deleteBindings(bindings)
	}

	override onTranslateEnd(_initial: PinShape, pin: PinShape) {
		const pageAnchor = this.editor.getShapePageTransform(pin).applyToPoint({ x: 0, y: 0 })

		const targets = this.editor
			.getShapesAtPoint(pageAnchor, { hitInside: true })
			.filter(
				(shape) =>
					this.editor.canBindShapes({ fromShape: pin, toShape: shape, binding: 'pin' }) &&
					shape.parentId === pin.parentId &&
					shape.index < pin.index
			)

		for (const target of targets) {
			const targetBounds = Box.ZeroFix(this.editor.getShapeGeometry(target)!.bounds)
			const pointInTargetSpace = this.editor.getPointInShapeSpace(target, pageAnchor)

			const anchor = {
				x: invLerp(targetBounds.minX, targetBounds.maxX, pointInTargetSpace.x),
				y: invLerp(targetBounds.minY, targetBounds.maxY, pointInTargetSpace.y),
			}

			this.editor.createBinding({
				type: 'pin',
				fromId: pin.id,
				toId: target.id,
				props: {
					anchor,
				},
			})
		}
	}
}

type PinBinding = TLBaseBinding<
	'pin',
	{
		anchor: VecModel
	}
>
class PinBindingUtil extends BindingUtil<PinBinding> {
	static override type = 'pin' as const

	override getDefaultProps() {
		return {
			anchor: { x: 0.5, y: 0.5 },
		}
	}

	private changedToShapes = new Set<TLShapeId>()

	override onOperationComplete(): void {
		if (this.changedToShapes.size === 0) return

		const fixedShapes = this.changedToShapes
		const toCheck = [...this.changedToShapes]

		const initialPositions = new Map<TLShapeId, VecModel>()
		const targetDeltas = new Map<TLShapeId, Map<TLShapeId, VecModel>>()

		const addTargetDelta = (fromId: TLShapeId, toId: TLShapeId, delta: VecModel) => {
			if (!targetDeltas.has(fromId)) targetDeltas.set(fromId, new Map())
			targetDeltas.get(fromId)!.set(toId, delta)

			if (!targetDeltas.has(toId)) targetDeltas.set(toId, new Map())
			targetDeltas.get(toId)!.set(fromId, { x: -delta.x, y: -delta.y })
		}

		const allShapes = new Set<TLShapeId>()
		while (toCheck.length) {
			const shapeId = toCheck.pop()!

			const shape = this.editor.getShape(shapeId)
			if (!shape) continue

			if (allShapes.has(shapeId)) continue
			allShapes.add(shapeId)

			const bindings = this.editor.getBindingsToShape<PinBinding>(shape, 'pin')
			for (const binding of bindings) {
				if (allShapes.has(binding.fromId)) continue
				allShapes.add(binding.fromId)

				const pin = this.editor.getShape<PinShape>(binding.fromId)
				if (!pin) continue

				const pinPosition = this.editor.getShapePageTransform(pin).applyToPoint({ x: 0, y: 0 })
				initialPositions.set(pin.id, pinPosition)

				for (const binding of this.editor.getBindingsFromShape<PinBinding>(pin.id, 'pin')) {
					const shapeBounds = this.editor.getShapeGeometry(binding.toId)!.bounds
					const shapeAnchor = {
						x: lerp(shapeBounds.minX, shapeBounds.maxX, binding.props.anchor.x),
						y: lerp(shapeBounds.minY, shapeBounds.maxY, binding.props.anchor.y),
					}
					const currentPageAnchor = this.editor
						.getShapePageTransform(binding.toId)
						.applyToPoint(shapeAnchor)

					const shapeOrigin = this.editor
						.getShapePageTransform(binding.toId)
						.applyToPoint({ x: 0, y: 0 })
					initialPositions.set(binding.toId, shapeOrigin)

					addTargetDelta(pin.id, binding.toId, {
						x: currentPageAnchor.x - shapeOrigin.x,
						y: currentPageAnchor.y - shapeOrigin.y,
					})

					if (!allShapes.has(binding.toId)) toCheck.push(binding.toId)
				}
			}
		}

		const currentPositions = new Map(initialPositions)

		const iterations = 30
		for (let i = 0; i < iterations; i++) {
			const movements = new Map<TLShapeId, VecModel[]>()
			for (const [aId, deltas] of targetDeltas) {
				if (fixedShapes.has(aId)) continue
				const aPosition = currentPositions.get(aId)!
				for (const [bId, targetDelta] of deltas) {
					const bPosition = currentPositions.get(bId)!

					const adjustmentDelta = {
						x: targetDelta.x - (aPosition.x - bPosition.x),
						y: targetDelta.y - (aPosition.y - bPosition.y),
					}

					if (!movements.has(aId)) movements.set(aId, [])
					movements.get(aId)!.push(adjustmentDelta)
				}
			}

			for (const [shapeId, deltas] of movements) {
				const currentPosition = currentPositions.get(shapeId)!
				currentPositions.set(shapeId, Vec.Average(deltas).add(currentPosition))
			}
		}

		const updates = []
		for (const [shapeId, position] of currentPositions) {
			const delta = Vec.Sub(position, initialPositions.get(shapeId)!)
			if (delta.len2() <= 0.01) continue

			const newPosition = this.editor.getPointInParentSpace(shapeId, position)
			updates.push({
				id: shapeId,
				type: this.editor.getShape(shapeId)!.type,
				x: newPosition.x,
				y: newPosition.y,
			})
		}

		if (updates.length === 0) {
			this.changedToShapes.clear()
		} else {
			this.editor.updateShapes(updates)
		}
	}

	// when the shape we're stuck to changes, update the pin's position
	override onAfterChangeToShape({ binding }: BindingOnShapeChangeOptions<PinBinding>): void {
		this.changedToShapes.add(binding.toId)
	}

	// when the thing we're stuck to is deleted, delete the pin too
	override onBeforeDeleteToShape({ binding }: BindingOnShapeDeleteOptions<PinBinding>): void {
		this.editor.deleteShape(binding.fromId)
	}
}

class PinTool extends StateNode {
	static override id = 'pin'

	override onEnter() {
		this.editor.setCursor({ type: 'cross', rotation: 0 })
	}

	override onPointerDown(info: TLPointerEventInfo) {
		const { currentPagePoint } = this.editor.inputs
		const pinId = createShapeId()
		this.editor.markHistoryStoppingPoint()
		this.editor.createShape({
			id: pinId,
			type: 'pin',
			x: currentPagePoint.x,
			y: currentPagePoint.y,
		})
		this.editor.setSelectedShapes([pinId])
		this.editor.setCurrentTool('select.translating', {
			...info,
			target: 'shape',
			shape: this.editor.getShape(pinId),
			isCreating: true,
			onInteractionEnd: 'pin',
			onCreate: () => {
				this.editor.setCurrentTool('pin')
			},
		})
	}
}

const overrides: TLUiOverrides = {
	tools(editor, schema) {
		schema['pin'] = {
			id: 'pin',
			label: 'Pin',
			icon: 'heart-icon',
			kbd: 'p',
			onSelect: () => {
				editor.setCurrentTool('pin')
			},
		}
		return schema
	},
}

const components: TLUiComponents & TLEditorComponents = {
	Toolbar: (...props) => {
		const pin = useTools().pin
		const isPinSelected = useIsToolSelected(pin)
		return (
			<DefaultToolbar {...props}>
				<TldrawUiMenuItem {...pin} isSelected={isPinSelected} />
				<DefaultToolbarContent />
			</DefaultToolbar>
		)
	},
}

export default function PinExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="pin-example"
				onMount={(editor) => {
					;(window as any).editor = editor
					editor.setStyleForNextShapes(DefaultFillStyle, 'semi')
				}}
				shapeUtils={[PinShapeUtil]}
				bindingUtils={[PinBindingUtil]}
				tools={[PinTool]}
				overrides={overrides}
				components={components}
			/>
		</div>
	)
}
```

--------

# Rich text with custom extension and toolbar

Category: Shapes & tools

Keywords: text, tip, tap, extension, toolbar

Extend the TipTap text editor by adding a custom extension and toolbar.

This example shows how to add a custom extension and toolbar to the TipTap text editor by setting the `textOptions` prop.

## App.tsx

```tsx
import { Mark, mergeAttributes } from '@tiptap/core'
import StarterKit from '@tiptap/starter-kit'
import {
	DefaultRichTextToolbar,
	TLComponents,
	Tldraw,
	TldrawUiButton,
	preventDefault,
	useEditor,
	useValue,
} from 'tldraw'
import 'tldraw/tldraw.css'
import './RichTextCustomExtension.css'

interface WavyExtensionOptions {
	HTMLAttributes: object
}

declare module '@tiptap/core' {
	interface Commands<ReturnType> {
		wavy: {
			setWavy(): ReturnType
			toggleWavy(): ReturnType
			unsetWavy(): ReturnType
		}
	}
}

const Wavy = Mark.create<WavyExtensionOptions>({
	name: 'wavy',

	addOptions() {
		return {
			HTMLAttributes: {},
		}
	},

	parseHTML() {
		return [
			{
				tag: 'span.wavy',
			},
		]
	},

	renderHTML({ HTMLAttributes }) {
		return [
			'span',
			mergeAttributes(this.options.HTMLAttributes, { class: 'wavy' }, HTMLAttributes),
			0,
		]
	},

	addCommands() {
		return {
			setWavy:
				() =>
				({ commands }) =>
					commands.setMark(this.name),
			toggleWavy:
				() =>
				({ commands }: any) =>
					commands.toggleMark(this.name),
			unsetWavy:
				() =>
				({ commands }) =>
					commands.unsetMark(this.name),
		}
	},
})

const components: TLComponents = {
	RichTextToolbar: () => {
		const editor = useEditor()
		const textEditor = useValue('textEditor', () => editor.getRichTextEditor(), [editor])

		return (
			<DefaultRichTextToolbar>
				<TldrawUiButton
					type="icon"
					onClick={() => {
						textEditor?.chain().focus().toggleWavy().run()
					}}
					isActive={textEditor?.isActive('wavy')}
					onPointerDown={preventDefault}
				>
					ã€°ï¸
				</TldrawUiButton>
				{/* Add the DefaultRichTextToolbarContent if you want to add more items. */}
				{/* <DefaultRichTextToolbarContent textEditor={textEditor} onEditLinkIntent={() => {}} /> */}
			</DefaultRichTextToolbar>
		)
	},
}

const textOptions = {
	tipTapConfig: {
		extensions: [StarterKit, Wavy],
	},
}

export default function RichTextCustomExtensionExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="rich-text-custom-extension"
				components={components}
				textOptions={textOptions}
			/>
		</div>
	)
}

/*
This example shows how to set custom properties on the TipTap editor.
*/
```

## RichTextCustomExtension.css

```css
.wavy {
	text-decoration: wavy underline hotpink;
}
```

--------

# Rich text with font options

Category: Shapes & tools

Keywords: text, tip, tap, extension, toolbar, font

Extend the TipTap text editor by adding font-family and font-size options.

This example shows how to add font-family and font-size options to the TipTap text editor by setting the `textOptions` prop.

## App.tsx

```tsx
import { EditorEvents as TextEditorEvents } from '@tiptap/core'
import FontFamily from '@tiptap/extension-font-family'
import TextStyle from '@tiptap/extension-text-style'
import { EditorState as TextEditorState } from '@tiptap/pm/state'
import { useEffect, useState } from 'react'
import {
	DefaultRichTextToolbar,
	DefaultRichTextToolbarContent,
	Editor,
	TLComponents,
	TLTextOptions,
	Tldraw,
	defaultAddFontsFromNode,
	stopEventPropagation,
	tipTapDefaultExtensions,
	useEditor,
	useValue,
} from 'tldraw'
import 'tldraw/tldraw.css'
import { FontSize } from './FontSizeExtension'
import './RichTextFontExtension.css'
import { extensionFontFamilies } from './fonts'

const fontOptions = [
	{ label: 'Default', value: 'DEFAULT' },
	{ label: 'Inter', value: 'Inter' },
	{ label: 'Comic Sans MS', value: 'Comic Sans MS' },
	{ label: 'serif', value: 'serif' },
	{ label: 'monospace', value: 'monospace' },
	{ label: 'cursive', value: 'cursive' },
	{ label: 'Exo 2 (Google Font)', value: "'Exo 2'" },
]

const fontSizeOptions = [
	{ label: 'Small', value: '12px' },
	{ label: 'Normal', value: '16px' },
	{ label: 'Large', value: '20px' },
	{ label: 'X-Large', value: '24px' },
	{ label: 'XX-Large', value: '28px' },
	{ label: 'Huge', value: '32px' },
]

const components: TLComponents = {
	RichTextToolbar: () => {
		const editor = useEditor()
		const textEditor = useValue('textEditor', () => editor.getRichTextEditor(), [editor])
		const [_, setTextEditorState] = useState<TextEditorState | null>(textEditor?.state ?? null)

		// Set up text editor transaction listener.
		useEffect(() => {
			if (!textEditor) {
				setTextEditorState(null)
				return
			}

			const handleTransaction = ({ editor: textEditor }: TextEditorEvents['transaction']) => {
				setTextEditorState(textEditor.state)
			}

			textEditor.on('transaction', handleTransaction)
			return () => {
				textEditor.off('transaction', handleTransaction)
				setTextEditorState(null)
			}
		}, [textEditor])

		if (!textEditor) return null

		const currentFontFamily = textEditor?.getAttributes('textStyle').fontFamily ?? 'DEFAULT'
		const currentFontSize = textEditor?.getAttributes('textStyle').fontSize

		return (
			<DefaultRichTextToolbar>
				<select
					className="rich-text-font-extension-select"
					value={currentFontFamily}
					onPointerDown={stopEventPropagation}
					onChange={(e) => {
						textEditor?.chain().focus().setFontFamily(e.target.value).run()
					}}
				>
					{fontOptions.map((option) => (
						<option key={option.value} value={option.value}>
							{option.label}
						</option>
					))}
				</select>
				<select
					className="rich-text-font-extension-select"
					value={currentFontSize}
					onPointerDown={stopEventPropagation}
					onChange={(e) => {
						textEditor?.chain().focus().setFontSize(e.target.value).run()
					}}
				>
					{fontSizeOptions.map((option) => (
						<option key={option.value} value={option.value}>
							{option.label}
						</option>
					))}
				</select>
				{/* Add the DefaultRichTextToolbarContent if you want to add more items. */}
				<DefaultRichTextToolbarContent textEditor={textEditor} />
			</DefaultRichTextToolbar>
		)
	},
}

const textOptions: Partial<TLTextOptions> = {
	tipTapConfig: {
		extensions: [...tipTapDefaultExtensions, FontFamily, FontSize, TextStyle],
	},
	addFontsFromNode(node, state, addFont) {
		state = defaultAddFontsFromNode(node, state, addFont)

		// if we have a font-family attribute, keep track of that in the state so it applies to children
		for (const mark of node.marks) {
			if (
				mark.type.name === 'textStyle' &&
				mark.attrs.fontFamily &&
				mark.attrs.fontFamily !== 'DEFAULT' &&
				mark.attrs.fontFamily !== state.family
			) {
				state = { ...state, family: mark.attrs.fontFamily }
			}
		}

		// if one of our extension font families matches the current state, add that font to the document.
		const font = extensionFontFamilies[state.family]?.[state.style]?.[state.weight]
		if (font) addFont(font)

		return state
	},
}

export default function RichTextFontExtensionExample() {
	const fontFaces = Object.values(extensionFontFamilies)
		.map((fontFamily) => Object.values(fontFamily))
		.flat()
		.map((fontStyle) => Object.values(fontStyle))
		.flat()

	// We need to preload the fonts so that they are available when
	// making font changes. This is to avoid any FOUC as you change the
	// font families.
	const onMount = (editor: Editor) => {
		editor.fonts.requestFonts(fontFaces)
	}

	const exoFont = extensionFontFamilies["'Exo 2'"].normal.normal.src.url

	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="rich-text-font-extension"
				components={components}
				textOptions={textOptions}
				// If you want to override one of the custom fonts,
				// you can do so by providing an assetUrls prop.
				assetUrls={{
					fonts: {
						tldraw_mono: exoFont,
					},
				}}
				onMount={onMount}
			/>
		</div>
	)
}

/*
This example shows how to set font family and font size properties on the TipTap editor.
*/
```

## FontSizeExtension.ts

```ts
import '@tiptap/extension-text-style'

import { Extension } from '@tiptap/core'

export interface FontSizeOptions {
	/**
	 * A list of node names where the font size can be applied.
	 * @default ['textStyle']
	 * @example ['heading', 'paragraph']
	 */
	types: string[]
}

declare module '@tiptap/core' {
	interface Commands<ReturnType> {
		fontSize: {
			/**
			 * Set the font size
			 * @param fontSize The font size
			 * @example editor.commands.setFontSize('32px')
			 */
			setFontSize(fontSize: string): ReturnType
			/**
			 * Unset the font size
			 * @example editor.commands.unsetFontSize()
			 */
			unsetFontSize(): ReturnType
		}
	}
}

/**
 * This extension allows you to set a font size for text.
 */
export const FontSize = Extension.create<FontSizeOptions>({
	name: 'fontSize',

	addOptions() {
		return {
			types: ['textStyle'],
		}
	},

	addGlobalAttributes() {
		return [
			{
				types: this.options.types,
				attributes: {
					fontSize: {
						default: null,
						parseHTML: (element) => element.style.fontSize,
						renderHTML: (attributes) => {
							if (!attributes.fontSize) {
								return {}
							}

							return {
								style: `font-size: ${attributes.fontSize}`,
							}
						},
					},
				},
			},
		]
	},

	addCommands() {
		return {
			setFontSize:
				(fontSize) =>
				({ chain }) => {
					return chain().setMark('textStyle', { fontSize }).run()
				},
			unsetFontSize:
				() =>
				({ chain }) => {
					return chain().setMark('textStyle', { fontSize: null }).removeEmptyTextStyle().run()
				},
		}
	},
})
```

## RichTextFontExtension.css

```css
.rich-text-font-extension-select {
	border: 0;
	background: transparent;
	margin: 0 8px;
}
```

## fonts.ts

```ts
import { TLDefaultFont, TLFontFace } from 'tldraw'

// NOTE: these fonts only support the latin character set. To support other languages, you'll add
// each one as a new font-family, similar to how you would with @font-face.
export const extensionFontFamilies: {
	[key: string]: { [key: string]: { [key: string]: TLFontFace } }
} = {
	Inter: {
		normal: {
			normal: {
				family: 'Inter',
				src: {
					url: 'https://fonts.gstatic.com/s/inter/v18/UcCO3FwrK3iLTeHuS_nVMrMxCp50SjIw2boKoduKmMEVuI6fAZ9hiJ-Ek-_EeA.woff2',
					format: 'woff2',
				},
				weight: '500',
				style: 'normal',
			},
			bold: {
				family: 'Inter',
				src: {
					url: 'https://fonts.gstatic.com/s/inter/v18/UcCO3FwrK3iLTeHuS_nVMrMxCp50SjIw2boKoduKmMEVuFuYAZ9hiJ-Ek-_EeA.woff2',
					format: 'woff2',
				},
				weight: '700',
				style: 'normal',
			},
		},
		italic: {
			normal: {
				family: 'Inter',
				src: {
					url: 'https://fonts.gstatic.com/s/inter/v18/UcCM3FwrK3iLTcvneQg7Ca725JhhKnNqk4j1ebLhAm8SrXTc69tRipWFsevceSGM.woff2',
					format: 'woff2',
				},
				weight: '500',
				style: 'normal',
			},
			bold: {
				family: 'Inter',
				src: {
					url: 'https://fonts.gstatic.com/s/inter/v18/UcCM3FwrK3iLTcvneQg7Ca725JhhKnNqk4j1ebLhAm8SrXTcPtxRipWFsevceSGM.woff2',
					format: 'woff2',
				},
				weight: '700',
				style: 'normal',
			},
		},
	},
	"'Exo 2'": {
		normal: {
			normal: {
				family: 'Exo 2',
				src: {
					url: 'https://fonts.gstatic.com/s/exo2/v24/7cH1v4okm5zmbvwkAx_sfcEuiD8jjPKsOdC_jJ7bpAhL.woff2',
					format: 'woff2',
				},
				weight: '500',
				style: 'normal',
			},
			bold: {
				family: 'Exo 2',
				src: {
					url: 'https://fonts.gstatic.com/s/exo2/v24/7cH1v4okm5zmbvwkAx_sfcEuiD8jWfWsOdC_jJ7bpAhL.woff2',
					format: 'woff2',
				},
				weight: '700',
				style: 'normal',
			},
		},
		italic: {
			normal: {
				family: 'Exo 2',
				src: {
					url: 'https://fonts.gstatic.com/s/exo2/v24/7cH3v4okm5zmbtYtMeA0FKq0Jjg2drFGfeC9hp_5oBBKRrs.woff2',
					format: 'woff2',
				},
				weight: '500',
				style: 'normal',
			},
			bold: {
				family: 'Exo 2',
				src: {
					url: 'https://fonts.gstatic.com/s/exo2/v24/7cH3v4okm5zmbtYtMeA0FKq0Jjg2drGTeuC9hp_5oBBKRrs.woff2',
					format: 'woff2',
				},
				weight: '700',
				style: 'normal',
			},
		},
	},
} satisfies Record<string, TLDefaultFont>
```

--------

# Outlined text example

Category: Shapes & tools

Keywords: text, outline, stroke, extension, toolbar, styling

Add outlined text styling to the TipTap text editor with a custom extension.

This example shows how to add a text outline effect by creating a custom TipTap extension that applies CSS text-stroke styling to selected text. The example includes a custom toolbar button to toggle the outline effect on and off.

## App.tsx

```tsx
import { Mark, mergeAttributes } from '@tiptap/core'
import StarterKit from '@tiptap/starter-kit'
import {
	DefaultRichTextToolbar,
	TLComponents,
	Tldraw,
	TldrawUiButton,
	preventDefault,
	useEditor,
	useValue,
} from 'tldraw'
import 'tldraw/tldraw.css'
import './OutlinedTextExample.css'

interface OutlineExtensionOptions {
	HTMLAttributes: object
}

declare module '@tiptap/core' {
	interface Commands<ReturnType> {
		outline: {
			setOutline(): ReturnType
			toggleOutline(): ReturnType
			unsetOutline(): ReturnType
		}
	}
}

const Outline = Mark.create<OutlineExtensionOptions>({
	name: 'outline',

	addOptions() {
		return {
			HTMLAttributes: {},
		}
	},

	parseHTML() {
		return [
			{
				tag: 'span.outlined',
			},
		]
	},

	renderHTML({ HTMLAttributes }) {
		return [
			'span',
			mergeAttributes(this.options.HTMLAttributes, { class: 'outlined filled' }, HTMLAttributes),
			0,
		]
	},

	addCommands() {
		return {
			setOutline:
				() =>
				({ commands }) =>
					commands.setMark(this.name),
			toggleOutline:
				() =>
				({ commands }: any) =>
					commands.toggleMark(this.name),
			unsetOutline:
				() =>
				({ commands }) =>
					commands.unsetMark(this.name),
		}
	},

	onCreate() {
		this.editor.commands.toggleMark('outline')
	},
})

const components: TLComponents = {
	RichTextToolbar: () => {
		const editor = useEditor()
		const textEditor = useValue('textEditor', () => editor.getRichTextEditor(), [editor])

		return (
			<DefaultRichTextToolbar>
				<TldrawUiButton
					type="icon"
					onClick={() => {
						textEditor?.chain().focus().toggleOutline().run()
					}}
					isActive={textEditor?.isActive('outline')}
					onPointerDown={preventDefault}
					title="Toggle text outline"
				>
					â¬œ
				</TldrawUiButton>
			</DefaultRichTextToolbar>
		)
	},
}

const textOptions = {
	tipTapConfig: {
		extensions: [StarterKit, Outline],
	},
}

export default function OutlinedTextExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="outlined-text-example"
				components={components}
				textOptions={textOptions}
			/>
		</div>
	)
}

/*
This example shows how to add outlined text styling using a custom TipTap extension.
The outline effect is created using CSS text-stroke properties.
*/
```

## OutlinedTextExample.css

```css
.outlined {
	-webkit-text-stroke: 2px #000000;
	text-stroke: 2px #000000;
	color: transparent;
	font-weight: bold;
}

.outlined.filled {
	color: #ffffff;
}
```

--------

# Popup shape

Category: Shapes & tools

Keywords: dynamic shadows, css

Create a 3D illusion of depth with dynamic shadows and CSS transforms.

Create a 3D illusion of depth with dynamic shadows and CSS transforms.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import { PopupShapeUtil } from './PopupShapeUtil'

const customShapeUtils = [PopupShapeUtil]

export default function PopupShapeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				shapeUtils={customShapeUtils}
				onMount={(editor) => {
					for (let i = 0; i < 9; i++) {
						editor.createShape({
							type: 'my-popup-shape',
							x: (i % 3) * 220,
							y: Math.floor(i / 3) * 220,
						})
					}
					editor.zoomToBounds(editor.getCurrentPageBounds()!, { animation: { duration: 0 } })
				}}
			/>
		</div>
	)
}
```

## PopupShapeUtil.tsx

```tsx
/* eslint-disable react-hooks/rules-of-hooks */
import { useEffect, useRef, useState } from 'react'
import {
	BaseBoxShapeUtil,
	HTMLContainer,
	RecordProps,
	T,
	TLBaseShape,
	stopEventPropagation,
} from 'tldraw'

type IMyPopupShape = TLBaseShape<
	'my-popup-shape',
	{
		w: number
		h: number
		animal: number
	}
>

export class PopupShapeUtil extends BaseBoxShapeUtil<IMyPopupShape> {
	static override type = 'my-popup-shape' as const
	static override props: RecordProps<IMyPopupShape> = {
		w: T.number,
		h: T.number,
		animal: T.number,
	}

	getDefaultProps(): IMyPopupShape['props'] {
		return {
			w: 200,
			h: 200,
			animal: 0,
		}
	}

	component(shape: IMyPopupShape) {
		const [popped, setPopped] = useState(false)

		const ref = useRef<HTMLDivElement>(null)
		const ref2 = useRef<HTMLDivElement>(null)

		useEffect(() => {
			const elm = ref.current
			if (!elm) return
			const elm2 = ref2.current
			if (!elm2) return
			if (popped) {
				// man
				// elm2.style.transform = `rotateX(0deg) translateY(0px) translateZ(0px)`
				// note
				elm.style.transform = `rotateX(0deg) translateY(0px) translateZ(0px)`
			} else {
				// man
				// elm.style.transform = `rotateX(-50deg) translateY(5px) translateZ(0px)`
				// elm2.style.transform = `scaleY(.8)`
				// note
				elm.style.transform = `rotateX(20deg)`
			}
		}, [popped])

		const vpb = this.editor.getViewportPageBounds()
		const spb = this.editor.getShapePageBounds(shape)!
		const px = vpb.midX - spb.midX + spb.w / 2
		const py = vpb.midY - spb.midY + spb.h / 2

		return (
			<HTMLContainer
				style={{
					pointerEvents: 'all',
					perspective: `${Math.max(vpb.w, vpb.h)}px`,
					perspectiveOrigin: `${px}px ${py}px`,
				}}
				onPointerDown={stopEventPropagation}
				onDoubleClick={(e) => {
					setPopped((p) => !p)
					stopEventPropagation(e)
				}}
			>
				<div
					ref={ref2}
					style={{
						position: 'absolute',
						top: 0,
						left: 0,
						width: '100%',
						height: '100%',
						transition: `all .5s`,
						backgroundSize: 'contain',
						backgroundRepeat: 'no-repeat',
						backgroundPosition: 'center',
						// man
						// transformOrigin: 'bottom center',
						// backgroundImage: `url(/shadow-man.png)`,
						// note
						backgroundColor: 'rgba(0,0,0,.5)',
					}}
				/>
				<div
					ref={ref}
					style={{
						position: 'absolute',
						top: 0,
						left: 0,
						width: '100%',
						height: '100%',
						transition: `all .5s`,
						display: 'flex',
						alignItems: 'center',
						justifyContent: 'center',
						padding: 16,
						overflow: 'hidden',
						fontFamily: 'tldraw_draw',
						color: '#333',
						fontSize: 24,
						backgroundSize: 'contain',
						backgroundRepeat: 'no-repeat',
						backgroundPosition: 'center',
						transformOrigin: 'top center',
						// man
						// backgroundImage: `url(/man.png)`,
						// transformOrigin: 'bottom center',
						// transform: `rotateX(20deg) translateY(5px) translateZ(40px)`,
						// note
						background: `gold`,
						border: '1px solid goldenrod',
					}}
				>
					{/* {shape.id.slice(-1).toUpperCase()} */}
				</div>
			</HTMLContainer>
		)
	}

	indicator(shape: IMyPopupShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}
```

--------

# Multiplayer sync

Category: Collaboration

Keywords: basic, intro, simple, quick, start, multiplayer, sync, collaboration

Use tldraw sync for multiplayer collaboration.

The `useSyncDemo` hook can be used to quickly prototype multiplayer experiences in tldraw using a demo backend that we host. Data is wiped after one day.

## App.tsx

```tsx
import { useSyncDemo } from '@tldraw/sync'
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function SyncDemoExample({ roomId }: { roomId: string }) {
	const store = useSyncDemo({ roomId })
	return (
		<div className="tldraw__editor">
			<Tldraw store={store} deepLinks />
		</div>
	)
}
```

--------

# Multiplayer sync with a custom shape

Category: Collaboration

Keywords: basic, intro, simple, quick, start, multiplayer, sync, collaboration, custom shape

Use a custom shape in combination with tldraw sync.

This example shows a custom shape in combination with tldraw sync.

## App.tsx

```tsx
import { useSyncDemo } from '@tldraw/sync'
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import { CounterShapeTool, CounterShapeUtil } from './CounterShape'
import { components, uiOverrides } from './ui'

const customShapes = [CounterShapeUtil]
const customTools = [CounterShapeTool]

export default function SyncDemoShapeExample({ roomId }: { roomId: string }) {
	const store = useSyncDemo({ roomId, shapeUtils: customShapes })
	return (
		<div className="tldraw__editor">
			<Tldraw
				store={store}
				shapeUtils={customShapes}
				tools={customTools}
				overrides={uiOverrides}
				components={components}
				deepLinks
			/>
		</div>
	)
}
```

## CounterShape.tsx

```tsx
import { MouseEvent } from 'react'
import {
	BaseBoxShapeTool,
	BaseBoxShapeUtil,
	HTMLContainer,
	T,
	TLBaseShape,
	stopEventPropagation,
} from 'tldraw'

type CounterShape = TLBaseShape<'counter', { w: number; h: number; count: number }>

export class CounterShapeUtil extends BaseBoxShapeUtil<CounterShape> {
	static override type = 'counter' as const
	static override props = {
		w: T.positiveNumber,
		h: T.positiveNumber,
		count: T.number,
	}

	override getDefaultProps() {
		return {
			w: 200,
			h: 200,
			count: 0,
		}
	}

	override component(shape: CounterShape) {
		const onClick = (event: MouseEvent, change: number) => {
			event.stopPropagation()
			this.editor.updateShape({
				id: shape.id,
				type: 'counter',
				props: { count: shape.props.count + change },
			})
		}

		return (
			<HTMLContainer
				style={{
					pointerEvents: 'all',
					background: '#efefef',
					display: 'flex',
					alignItems: 'center',
					justifyContent: 'center',
					gap: 8,
				}}
			>
				<button onClick={(e) => onClick(e, -1)} onPointerDown={stopEventPropagation}>
					-
				</button>
				<span>{shape.props.count}</span>
				<button onClick={(e) => onClick(e, 1)} onPointerDown={stopEventPropagation}>
					+
				</button>
			</HTMLContainer>
		)
	}

	override indicator(shape: CounterShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}

export class CounterShapeTool extends BaseBoxShapeTool {
	static override id = 'counter'
	override shapeType = 'counter'
}
```

## ui.tsx

```tsx
import {
	DefaultToolbar,
	DefaultToolbarContent,
	TLComponents,
	TLUiOverrides,
	TldrawUiMenuItem,
	useIsToolSelected,
	useTools,
} from 'tldraw'

export const uiOverrides: TLUiOverrides = {
	tools(editor, tools) {
		// Create a tool item in the ui's context.
		tools.counter = {
			id: 'counter',
			icon: 'color',
			label: 'counter',
			kbd: 'c',
			onSelect: () => {
				editor.setCurrentTool('counter')
			},
		}
		return tools
	},
}

export const components: TLComponents = {
	Toolbar: (props) => {
		const tools = useTools()
		const isCounterSelected = useIsToolSelected(tools['counter'])
		return (
			<DefaultToolbar {...props}>
				<TldrawUiMenuItem {...tools['counter']} isSelected={isCounterSelected} />
				<DefaultToolbarContent />
			</DefaultToolbar>
		)
	},
}
```

--------

# Multiplayer sync with custom presence

Category: Collaboration

Keywords: basic, intro, simple, quick, start, multiplayer, sync, collaboration, presence

Customize the presence data synced between different tldraw instances.

This example shows how to customize the presence data synced between different tldraw instances.

## App.tsx

```tsx
import { useSyncDemo } from '@tldraw/sync'
import { useEffect } from 'react'
import { Tldraw, getDefaultUserPresence, useAtom } from 'tldraw'
import 'tldraw/tldraw.css'

export default function SyncCustomUserExample({ roomId }: { roomId: string }) {
	// [1]
	const timer = useAtom('timer', Date.now())
	useEffect(() => {
		const tick = () => {
			timer.set(Date.now())
			frame = requestAnimationFrame(tick)
		}
		let frame = requestAnimationFrame(tick)
		return () => cancelAnimationFrame(frame)
	}, [timer])

	// [2]
	const store = useSyncDemo({
		roomId,
		getUserPresence(store, user) {
			// [2.1]
			const defaults = getDefaultUserPresence(store, user)
			if (!defaults) return null

			return {
				...defaults,

				// [2.2]
				camera: undefined,

				// [2.3]
				cursor: {
					...defaults.cursor,
					x: (defaults.cursor.x ?? 0) + 20 * Math.sin(timer.get() / 200),
					y: (defaults.cursor.y ?? 0) + 20 * Math.cos(timer.get() / 200),
				},
			}
		},
	})

	// [3]
	return (
		<div className="tldraw__editor">
			<Tldraw store={store} deepLinks />
		</div>
	)
}

/**
 * # Sync Custom User
 *
 * This example demonstrates how to use the sync demo server with custom presence state. The
 * presence state is synchronized to all other clients and used for multiplayer features like
 * cursors and viewport following. You can use custom presence state to change the data that's
 * synced to other clients, or remove parts you don't need for your app.
 *
 * 1. We create a timer that updates every frame. You don't need to do this in your app, it's just
 *    to power an animation. We store it in an `atom` so that changes to it will cause the presence
 *    info to update.
 *
 * 2. We create a multiplayer store using the userSyncDemo hook, and pass in a custom
 *    `getUserPresence` function to change the presence state that gets sent.
 *
 * 2.1. We get the default presence state using the `getDefaultUserPresence` function. If you wanted
 *    to send a very minimal set of presence data, you could avoid this part.
 *
 * 2.2. We remove the camera from the presence state. This means that the camera position won't be
 *    sent to other clients. Attempting to follow this users viewport will not work.
 *
 * 2.3. We update the cursor position and rotation based on the current time. This will make the
 *    cursor spin around in a circle.
 *
 * 3. We create a Tldraw component and pass in the multiplayer store. This will render the editor.
 */
```

--------

# Multiplayer sync with custom user data

Category: Collaboration

Keywords: basic, intro, simple, quick, start, multiplayer, sync, collaboration, custom shape

Integrate your own user data into tldraw sync.

This example shows how to integrate your own user data into tldraw sync.

## App.tsx

```tsx
import { useSyncDemo } from '@tldraw/sync'
import { useState } from 'react'
import { TLUserPreferences, Tldraw, useTldrawUser } from 'tldraw'
import 'tldraw/tldraw.css'

export default function SyncCustomUserExample({ roomId }: { roomId: string }) {
	// [1]
	const [userPreferences, setUserPreferences] = useState<TLUserPreferences>({
		id: 'user-' + Math.random(),
		name: 'Jimmothy',
		color: 'palevioletred',
		colorScheme: 'dark',
	})

	// [2]
	const store = useSyncDemo({ roomId, userInfo: userPreferences })

	// [3]
	const user = useTldrawUser({ userPreferences, setUserPreferences })

	// [4]
	return (
		<div className="tldraw__editor">
			<Tldraw store={store} user={user} deepLinks />
		</div>
	)
}

/**
 * # Sync Custom User
 *
 * This example demonstrates how to use the sync demo server with a custom user.
 *
 * You need access to two things to do this integration:
 *
 * - The user info
 * - A function to set the user info
 *
 * In this example we create an in-memory state for the user info, but in your system it's probably synchronized with a backend database somehow.
 *
 * 1. We get our user info and a function to set it from a `useState` hook. In your app this might come from a context provider or you might hook it up manually to your backend.
 * 2. We use the `useSyncDemo` hook to create the multiplayer store, and pass in the current user state as `userInfo`, which is a subset of the `userPreferences` type.
 * 3. We use the `useTLUser` hook to create a TLUser object, which allows the Editor to both read and update the user info and preferences.
 * 4. We render the `Tldraw` component with the multiplayer store and the user object.
 *
 * You can pass the same `user` object into the `useSync` hook if you're using your own server.
 */
```

--------

# Multiplayer sync with private content

Category: Collaboration

Keywords: basic, intro, simple, quick, start, multiplayer, sync, collaboration

Show and hide private content in a multiplayer session.

This is a simple example of how to show and hide private content in a multiplayer session based on a simple
data ownership model. Try it out by opening the example in two different tabs, toggling the private mode, and
drawing some shapes.

## App.tsx

```tsx
import { useSyncDemo } from '@tldraw/sync'
import React from 'react'
import {
	Atom,
	TLComponents,
	Tldraw,
	react,
	useAtom,
	useEditor,
	useIsToolSelected,
	useTools,
	useValue,
} from 'tldraw'
import 'tldraw/tldraw.css'
import { VisibilityOff, VisibilityOn } from '../../icons/icons'
import { Toggle } from './Toggle'
import './style.css'

// There's a guide at the bottom of this file!

// [1]
const PrivateModeContext = React.createContext<null | Atom<boolean>>(null)

const components: TLComponents = {
	// [2]
	InFrontOfTheCanvas: () => {
		const editor = useEditor()
		const isInSelectTool = useIsToolSelected(useTools().select)
		const userId = useValue('userId', () => editor.user.getId(), [])
		const myPrivateSelectedShapes = useValue(
			'private shapes',
			() =>
				editor
					.getSelectedShapes()
					.filter((shape) => !!shape.meta.private && shape.meta.ownerId === userId),
			[editor, userId]
		)

		// [3]
		const isPrivateMode$ = React.useContext(PrivateModeContext)!
		const isPrivateMode = useValue(isPrivateMode$)

		return (
			<>
				{isInSelectTool && myPrivateSelectedShapes.length > 0 ? (
					<div className="toggle-panel">
						<div>
							Make {myPrivateSelectedShapes.length} selected shape
							{myPrivateSelectedShapes.length > 1 ? 's' : ''} public?{' '}
						</div>
						<button
							onClick={() => {
								editor.markHistoryStoppingPoint()
								// [7]
								const allAffectedShapes = [
									...editor.getShapeAndDescendantIds(myPrivateSelectedShapes.map((s) => s.id)),
								].map((id) => editor.getShape(id)!)
								editor.updateShapes(
									allAffectedShapes.map((shape) => ({
										...shape,
										meta: { ...shape.meta, private: false },
									}))
								)
							}}
						>
							Yes
						</button>
					</div>
				) : (
					<div className="toggle-panel pointer" onClick={() => isPrivateMode$.update((v) => !v)}>
						{isPrivateMode ? <VisibilityOff fill="#444" /> : <VisibilityOn fill="#444" />}
						<div>Private mode</div>
						<Toggle isChecked={isPrivateMode} />
					</div>
				)}
			</>
		)
	},
}
function App({ roomId }: { roomId: string }) {
	const store = useSyncDemo({ roomId })
	const isPrivateMode$ = React.useContext(PrivateModeContext)!
	return (
		<div className="tldraw__editor">
			<Tldraw
				store={store}
				deepLinks
				// [4]
				getShapeVisibility={(shape, editor) => {
					const userId = editor.user.getId()
					if (!!shape.meta.private && shape.meta.ownerId !== userId) {
						return 'hidden'
					}
					return 'inherit'
				}}
				onMount={(editor) => {
					// [5]
					editor.store.sideEffects.registerBeforeCreateHandler('shape', (shape) => {
						if ('private' in shape.meta) return shape
						return {
							...shape,
							meta: {
								...shape.meta,
								private: isPrivateMode$.get(),
								ownerId: editor.user.getId(),
							},
						}
					})

					// [6]
					return react('clean up selection', () => {
						const selectedShapes = editor.getSelectedShapes()
						const filteredSelectedShapes = selectedShapes.filter((s) => !editor.isShapeHidden(s))
						if (filteredSelectedShapes.length !== selectedShapes.length) {
							editor.select(...filteredSelectedShapes)
						}
					})
				}}
				components={components}
			/>
		</div>
	)
}

export default function SyncPrivateContentExample({ roomId }: { roomId: string }) {
	return (
		<PrivateModeContext.Provider value={useAtom('isPrivateDrawingMode', false)}>
			<App roomId={roomId} />
		</PrivateModeContext.Provider>
	)
}

/**
 * This example demonstrates how to create a 'private' drawing mode where any shapes created by one person cannot be seen by another.
 * It sets up a simple ownership system where each shape created is tagged with the id of the user who created it.
 * It also adds a boolean flag to each shape called 'private' which is set to true if the shape is created in private mode.
 * If the user selects one or more private shapes, they will be given the option to make them public.
 *
 * 1. We create a context to store the atom that will hold the state of the private drawing mode. We are using signals here but you can use any state management library you like.
 * 2. We override the `InFrontOfTheCanvas` component to add a tool panel at the top of the screen that allows the user to toggle private drawing mode on and off, and to make private shapes public.
 * 3. We use the context to get the atom that holds the state of the private drawing mode. We then have to call 'useValue' on the atom to get the current value in a reactive way.
 * 4. We override the `getShapeVisibility` function to hide shapes that are private and not owned by the current user.
 * 5. We register a side effect that adds the 'private' and 'ownerId' meta fields to each shape created. We set the 'private' field to the current value of the private drawing mode atom.
 * 6. We register a side effect that cleans up the selection by removing any hidden shapes from the selection. This re-runs whenever the selection or the hidden state of a selected shape changes.
 * 7. Child shapes (e.g inside groups and frames) do not inherit the 'private' meta property from their parent. So when making a shape public, we decide to also make all descendant shapes public since this is most likely what the user intended.
 */
```

## Toggle.tsx

```tsx
export function Toggle({ isChecked }: { isChecked: boolean }) {
	const height = 20
	const width = 40
	const pillSize = height - 4
	return (
		<div
			style={{
				cursor: 'pointer',
				width,
				height,
				borderRadius: height / 2,
				backgroundColor: isChecked ? '#4bb05e' : '#999',
				display: 'flex',
				alignItems: 'center',
				justifyContent: isChecked ? 'flex-end' : 'flex-start',
				padding: 2,
			}}
		>
			{isChecked && (
				<div
					style={{ fontSize: 9, fontWeight: 600, color: 'white', position: 'relative', left: -3 }}
				>
					ON
				</div>
			)}
			<div
				style={{
					width: pillSize,
					height: pillSize,
					borderRadius: pillSize / 2,
					backgroundColor: 'white',
				}}
			/>
			{!isChecked && (
				<div
					style={{ fontSize: 9, fontWeight: 600, color: 'white', position: 'relative', right: -1 }}
				>
					OFF
				</div>
			)}
		</div>
	)
}
```

## style.css

```css
.toggle-panel {
	position: absolute;
	top: 10px;
	left: 50%;
	transform: translateX(-50%);
	border-radius: 8px;
	background: #efefef;
	box-shadow:
		0 0 0 1px rgba(0, 0, 0, 0.1),
		0 4px 8px rgba(0, 0, 0, 0.1);
	padding: 9px 10px 9px 15px;
	display: flex;
	align-items: center;
	gap: 10px;
}

.toggle-panel button {
	cursor: pointer;
}

.toggle-panel.pointer {
	cursor: pointer;
}
```

--------

# Manually update user presence

Category: Collaboration

Keywords: cursor

Manually show other users editing the same document.

Here, we add fake `InstancePresence` records to the store to simulate other users. If you have your own presence system, you could add real records to the store in the same way.

## App.tsx

```tsx
import { useRef } from 'react'
import { InstancePresenceRecordType, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

// [1]
const USER_NAME = 'huppy da arrow'
const MOVING_CURSOR_SPEED = 0.25 // 0 is stopped, 1 is full send
const MOVING_CURSOR_RADIUS = 100
const CURSOR_CHAT_MESSAGE = 'Hey, I think this is just great.'

// [2]
export default function UserPresenceExample() {
	const rRaf = useRef<any>(-1)
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="user-presence-example"
				onMount={(editor) => {
					// [a]
					const peerPresence = InstancePresenceRecordType.create({
						id: InstancePresenceRecordType.createId(editor.store.id),
						currentPageId: editor.getCurrentPageId(),
						userId: 'peer-1',
						userName: USER_NAME,
						cursor: { x: 0, y: 0, type: 'default', rotation: 0 },
						chatMessage: CURSOR_CHAT_MESSAGE,
					})

					editor.store.mergeRemoteChanges(() => {
						editor.store.put([peerPresence])
					})

					// [b]
					const raf = rRaf.current
					cancelAnimationFrame(raf)

					if (MOVING_CURSOR_SPEED > 0 || CURSOR_CHAT_MESSAGE) {
						function loop() {
							let cursor = peerPresence.cursor
							if (!cursor) return
							let chatMessage = peerPresence.chatMessage

							const now = Date.now()

							if (MOVING_CURSOR_SPEED > 0) {
								const k = 1000 / MOVING_CURSOR_SPEED
								const t = (now % k) / k

								cursor = {
									...cursor,
									x: 150 + Math.cos(t * Math.PI * 2) * MOVING_CURSOR_RADIUS,
									y: 150 + Math.sin(t * Math.PI * 2) * MOVING_CURSOR_RADIUS,
								}
							}

							if (CURSOR_CHAT_MESSAGE) {
								const k = 1000
								const t = (now % (k * 3)) / k
								chatMessage =
									t < 1
										? ''
										: t > 2
											? CURSOR_CHAT_MESSAGE
											: CURSOR_CHAT_MESSAGE.slice(
													0,
													Math.ceil((t - 1) * CURSOR_CHAT_MESSAGE.length)
												)
							}

							editor.store.mergeRemoteChanges(() => {
								editor.store.put([
									{
										...peerPresence,
										cursor,
										chatMessage,
										lastActivityTimestamp: now,
									},
								])
							})

							rRaf.current = editor.timers.requestAnimationFrame(loop)
						}

						rRaf.current = editor.timers.requestAnimationFrame(loop)
					} else {
						editor.store.mergeRemoteChanges(() => {
							editor.store.put([{ ...peerPresence, lastActivityTimestamp: Date.now() }])
						})
						rRaf.current = editor.timers.setInterval(() => {
							editor.store.mergeRemoteChanges(() => {
								editor.store.put([{ ...peerPresence, lastActivityTimestamp: Date.now() }])
							})
						}, 1000)
					}
				}}
			/>
		</div>
	)
}

/* 
This example shows how to add instance presence records to the store to show other users' cursors.
It is not an example of how to implement user presence, check out the collaboration examples for that:
https://tldraw.dev/examples/sync-demo

[1]
We're going to a fake a user's cursor and chat message, these are the values we'll use.

[2]
This is where we'll render the Tldraw component. We'll use the onMount callback to access the editor 
instance.
	[a] For every connected peer we need to add an instance presence record to the store. We can do
		this using the InstancePresenceRecordType.create function and add it to the store using the
		store.put method.
	[b] We'll use the requestAnimationFrame function to update the cursor position and chat message.
		This is just for demonstration purposes.
*/
```

--------

# Persist to storage

Category: Data & assets

Keywords: store, snapshot, debounce

Manually persist the contents of the editor to storage.

In this example, we load the contents of the editor from your browser's `localStorage`, and save it there when you make changes.

## App.tsx

```tsx
import { throttle } from 'lodash'
import { useLayoutEffect, useMemo, useState } from 'react'
import { DefaultSpinner, Tldraw, createTLStore, getSnapshot, loadSnapshot } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

const PERSISTENCE_KEY = 'example-3'

export default function PersistenceExample() {
	//[1]
	const store = useMemo(() => createTLStore(), [])
	//[2]
	const [loadingState, setLoadingState] = useState<
		{ status: 'loading' } | { status: 'ready' } | { status: 'error'; error: string }
	>({
		status: 'loading',
	})
	//[3]
	useLayoutEffect(() => {
		setLoadingState({ status: 'loading' })

		// Get persisted data from local storage
		const persistedSnapshot = localStorage.getItem(PERSISTENCE_KEY)

		if (persistedSnapshot) {
			try {
				const snapshot = JSON.parse(persistedSnapshot)
				loadSnapshot(store, snapshot)
				setLoadingState({ status: 'ready' })
			} catch (error: any) {
				setLoadingState({ status: 'error', error: error.message }) // Something went wrong
			}
		} else {
			setLoadingState({ status: 'ready' }) // Nothing persisted, continue with the empty store
		}

		// Each time the store changes, run the (debounced) persist function
		const cleanupFn = store.listen(
			throttle(() => {
				const snapshot = getSnapshot(store)
				localStorage.setItem(PERSISTENCE_KEY, JSON.stringify(snapshot))
			}, 500)
		)

		return () => {
			cleanupFn()
		}
	}, [store])

	// [4]
	if (loadingState.status === 'loading') {
		return (
			<div className="tldraw__editor">
				<h2>
					<DefaultSpinner />
				</h2>
			</div>
		)
	}

	if (loadingState.status === 'error') {
		return (
			<div className="tldraw__editor">
				<h2>Error!</h2>
				<p>{loadingState.error}</p>
			</div>
		)
	}

	return (
		<div className="tldraw__editor">
			<Tldraw store={store} />
		</div>
	)
}

/*
This example shows how to implement persistence in the Tldraw component. We do
this by saving the editor's state to local storage each time it changes. You 
should replace this in your app with some sort of backend storage solution. If 
you just want to save to local storage, you can use the `persistenceKey` prop
instead. Simply pass any string to this prop and the editor will automatically 
save to local storage.

[1]
We create a new store using the `createTLStore` helper function. We pass in the 
default shape utils so that the store knows how to handle the built-in shapes. 

[2]
This is a cool pattern that uses Typescript to help keep track of our app's
loading state.

[3]
We use the `useLayoutEffect` hook to run our persistence code after the first
render. First we grab the persisted snapshot from local storage. If there is
one, we load it into the store and set the loading state to ready. If there
isn't one, we just set the loading state to ready.

Then we setup a listener on the store that will run our persistence code each
time the store changes. We use the `throttle` helper function to debounce the
listener so that it doesn't run too often. We also return a cleanup function
that will remove the listener when the component unmounts.

[4]
This is where we render our application depending on the loading state. If the
loading state is `loading`, we render a loading message. If the loading state
is `error`, we render an error message. If the loading state is `ready`, we
render the Tldraw component.
*/
```

--------

# Static assets

Category: Data & assets

Keywords: icons, fonts, pre-load

Use custom fonts, icons, and preload them using the `Tldraw` component.

The `Tldraw` component relies on static assets for fonts and icons. These must be pre-loaded in order that the component runs properly.

## App.tsx

```tsx
import { Tldraw, TldrawProps } from 'tldraw'
import 'tldraw/tldraw.css'

// [1]
const assetUrls: TldrawProps['assetUrls'] = {
	fonts: {
		tldraw_draw: '/ComicMono.woff',
	},
	icons: {
		'tool-arrow': '/custom-arrow-icon.svg',
	},
}

export default function StaticAssetsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="static-assets" assetUrls={assetUrls} />
		</div>
	)
}

/**
[1]
By default, the Tldraw component will pull in assets from tldraw's asset CDN.
You can override this behavior by providing your own asset URLs. These URLs can
be relative or absolute URLs.

In this case, we are using a relative URL to a custom arrow icon and a custom font. 
Because this is a Vite project, these files are stored in this project's public folder.
Check your framework documentation for how to serve static assets.

Important! This object needs to be created outside of a React component, or else 
memoized using a useMemo hook, otherwise it will cause the Tldraw component to
receive a new `asserUrls` object every time the component re-renders.

```tsx

export default function StaticAssetsExample() {
	const assetUrls = useMemo<TldrawProps['assetUrls']>(() => ({
		fonts: {
			tldraw_draw: '/ComicMono.woff',
		},
		icons: {
			'tool-arrow': '/custom-arrow-icon.svg',
		},
	}, [])

	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="static-assets" assetUrls={assetUrls} />
		</div>
	)
}
```
*/
```

--------

# Export canvas as image

Category: Data & assets

Keywords: basic, assets, svg, png, blob

Export the entire canvas as an image file.

This example shows how you can use the `Editor.toImage()` function to create an image of all shapes on the canvas and then download it. The easiest way to download an image is to use the download attribute of a link element.

## App.tsx

```tsx
import { Tldraw, TLUiComponents, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'

function ExportCanvasButton() {
	const editor = useEditor()
	return (
		<button
			style={{ pointerEvents: 'all', fontSize: 18, backgroundColor: 'thistle' }}
			onClick={async () => {
				const shapeIds = editor.getCurrentPageShapeIds()
				if (shapeIds.size === 0) return alert('No shapes on the canvas')
				const { blob } = await editor.toImage([...shapeIds], { format: 'png', background: false })

				const link = document.createElement('a')
				link.href = URL.createObjectURL(blob)
				link.download = 'every-shape-on-the-canvas.jpg'
				link.click()
				URL.revokeObjectURL(link.href)
			}}
		>
			Export canvas as image
		</button>
	)
}
const components: TLUiComponents = {
	SharePanel: ExportCanvasButton,
}
export default function ExportCanvasImageExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw components={components} />
		</div>
	)
}

/* 
This example shows how you can use the `Editor.toImage()` function to create an image with all the shapes 
on the canvas in it and then download it. The easiest way to download an image is to use the download 
attribute of a link element.

To learn more about overriding UI you can check out our various custom menu examples. For more on handling
assets, check out our Local/Hosted images examples.
*/
```

--------

# Export canvas as image (with settings)

Category: Data & assets

Keywords: basic, assets, svg, png, blob, image, settings

Export the entire canvas as an image file, with configurable settings.

This example shows how you can use the `Editor.toImage()` function to create an image of all shapes on the canvas and then download it. It also shows options for the different settings you can pass to the `toImage` function.

## App.tsx

```tsx
import { useState } from 'react'
import { Box, Tldraw, TLImageExportOptions, TLUiComponents, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'

const components: TLUiComponents = {
	SharePanel: ExportCanvasButton,
}

export default function ExportCanvasImageExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw components={components} />
		</div>
	)
}

function ExportCanvasButton() {
	const editor = useEditor()

	// [1]
	const [opts, setOpts] = useState<TLImageExportOptions>({
		scale: 1,
		background: false,
		padding: editor.options.defaultSvgPadding,
	})

	// [2]
	const [box, setBox] = useState({ x: 0, y: 0, w: 0, h: 0 })

	return (
		<div
			style={{
				pointerEvents: 'all',
				border: '1px solid black',
				borderRadius: 5,
				padding: 12,
				position: 'absolute',
				display: 'flex',
				flexDirection: 'column',
				right: 164,
				top: 8,
			}}
		>
			<div
				style={{
					display: 'grid',
					gridTemplateColumns: '1fr auto',
					gridAutoFlow: 'row',
					rowGap: 4,
					columnGap: 16,
				}}
			>
				<Control
					type="checkbox"
					name="background"
					checked={opts.background}
					onChange={(e) => {
						setOpts({ ...opts, background: e.target.checked })
					}}
				/>
				<Control
					type="checkbox"
					name="darkmode"
					checked={opts.darkMode}
					onChange={(e) => {
						setOpts({ ...opts, darkMode: e.target.checked })
					}}
				/>
				<Control
					type="number"
					name="padding"
					value={opts.padding}
					onChange={(e) => {
						setOpts({ ...opts, padding: Math.ceil(Number(e.target.value)) })
					}}
				/>
				<Control
					type="number"
					name="scale"
					value={opts.scale}
					onChange={(e) => {
						setOpts({ ...opts, scale: Math.ceil(Number(e.target.value)) })
					}}
				/>
				<p style={{ gridColumn: '1 / span 2' }}>Box</p>
				{['x', 'y', 'w', 'h'].map((key) => (
					<div key={key} style={{ display: 'flex', gap: 4 }}>
						<Control
							type="number"
							name={key}
							value={box[key as keyof typeof box]}
							onChange={(event) => {
								setBox({
									...box,
									[key]: Math.ceil(Number(event.target.value)),
								})
							}}
						/>
					</div>
				))}
			</div>
			<button
				style={{ pointerEvents: 'all', marginTop: 16 }}
				onClick={async () => {
					const shapeIds = editor.getCurrentPageShapeIds()
					if (shapeIds.size === 0) return alert('No shapes on the canvas')

					const { blob } = await editor.toImage([...shapeIds], {
						format: 'png',
						...opts,
						// If we have numbers for all of the box values, we can use them as bounds
						bounds: Object.values(box).every((b) => !Number.isNaN(b))
							? new Box(box.x, box.y, box.w, box.h)
							: undefined,
					})

					const link = document.createElement('a')
					link.href = window.URL.createObjectURL(blob)
					link.download = 'every-shape-on-the-canvas.jpg'
					link.click()
				}}
			>
				Export canvas as image
			</button>
		</div>
	)
}

const Control = ({
	name,
	type,
	value,
	checked,
	onChange,
}: {
	name: string
	type?: React.HTMLInputTypeAttribute
	value?: string | number | readonly string[]
	checked?: boolean
	onChange?: React.ChangeEventHandler<HTMLInputElement>
}) => {
	return (
		<>
			<label htmlFor={`opt-${name}`} style={{ flexGrow: 2 }}>
				{name}
			</label>
			<input
				id={`opt-${name}`}
				name={name}
				type={type}
				style={{ maxWidth: 64, justifySelf: 'flex-end' }}
				value={value ?? ''}
				checked={!!checked}
				onChange={onChange}
			/>
		</>
	)
}

/* 
This example shows how you can use the image export settings in tldraw when generating an image.

1.
These are our defaults, though the rest of export / copy features use the user preferences,
e.g. editor.user.getIsDarkMode() for whether the user has enabled dark mode or not. But if
you're calling the image functions yourself, you can provide whatever options you wish.

2.
The bounding box is an optional argument that you can use to export a specific part of the canvas
or selection.
*/
```

--------

# Hosted images

Category: Data & assets

Keywords: assets, video, image, png, jpg, file

How to handle images uploaded by the user.

This example shows how to handle images uploaded by the user. To do this we'll need to
create a `TLAssetStore`, which tells the editor how to handle uploaded assets.

## App.tsx

```tsx
import { TLAssetStore, Tldraw, uniqueId } from 'tldraw'
import 'tldraw/tldraw.css'

// [1]
const UPLOAD_URL = '/SOME_ENDPOINT'

// [2]
const myAssetStore: TLAssetStore = {
	// [a]
	async upload(asset, file) {
		const id = uniqueId()

		const objectName = `${id}-${file.name}`.replaceAll(/\W/g, '-')
		const url = `${UPLOAD_URL}/${objectName}`

		await fetch(url, {
			method: 'POST',
			body: file,
		})

		return { src: url }
	},

	// [b]
	resolve(asset) {
		return asset.props.src
	},
}

// [3]
export default function HostedImagesExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw assets={myAssetStore} />
		</div>
	)
}
/* 

Introduction: This example shows how to handle images uploaded by the user. to do this we'll need to
create a TLAssetStore, which tells the editor how to handle uploaded assets. 

[1] You'll want to have an endpoint on your server that accepts file uploads, and returns URLs.

[2] We define our asset store, which has two methods: upload for saving assets, and resolve for
retrieving them.

    [a] The upload method is called when the user creates a file. It should take a `File` object,
    and return a URL that can be used to reference the file in the future.

    [b] After the file has been uploaded, whenever we want to refer to it again the editor will
    call the `resolve` method with the asset. Here, we just do the default and return the `src`
    prop. If you wanted to, you could return a different URL - for example, to serve optimized
    images, or to add an authentication token. The implementation here is the default, and could 
	have been omitted.

[3] Finally, we have our actual instance. We pass our asset store to the `assets` prop of the
`Tldraw` component so it becomes part of the store.

*/
```

--------

# Custom paste behavior

Category: Data & assets

Keywords: 

Change how pasting works by registering an external content handler.

This example adds a special rule for pasting single frame shapes, so they'll try to find an empty space instead of always pasting in the location they were copied from.

## App.tsx

```tsx
import {
	defaultHandleExternalTldrawContent,
	Editor,
	Tldraw,
	TLFrameShape,
	TLTldrawExternalContent,
} from 'tldraw'

// this example adds special behavior when pasting a single frame shape, matching the behavior of figma
export default function CustomPasteExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					// on mount, override the default tldraw handler
					editor.registerExternalContentHandler('tldraw', (content) =>
						handleCustomTldrawPaste(editor, content)
					)
				}}
			/>
		</div>
	)
}

const SPACING_BETWEEN_FRAMES = 50

function handleCustomTldrawPaste(editor: Editor, { content, point }: TLTldrawExternalContent) {
	// find the only shape in the pasted content
	const onlyCopiedShape =
		content.rootShapeIds.length === 1
			? content.shapes.find((shape) => shape.id === content.rootShapeIds[0])
			: null

	// make sure that the shape is a frame. if it is, retrieve the current version of that frame
	// from the document.
	const onlyCopiedFrame =
		onlyCopiedShape?.type === 'frame' ? (onlyCopiedShape as TLFrameShape) : null

	// we only want to use our special behavior if the frame (current & pasted) will be a direct
	// descendant of the current page.
	const willPasteOnCurrentPage = onlyCopiedFrame
		? !editor.getShape(onlyCopiedFrame.parentId)
		: false

	// if the paste is happening at a specific point, or we didn't copy a single frame that belongs
	// to this page, fall back to the default paste behavior
	if (point || !onlyCopiedFrame || !willPasteOnCurrentPage) {
		defaultHandleExternalTldrawContent(editor, { content, point })
		return
	}

	// if we are pasting a single frame, and that frame is still in the document, we want to find a
	// free space to the right of the frame to put this one.
	editor.putContentOntoCurrentPage(content, { select: true })
	const newlyPastedFrame = editor.getOnlySelectedShape()
	if (!newlyPastedFrame || !editor.isShapeOfType<TLFrameShape>(newlyPastedFrame, 'frame')) return

	const siblingIds = editor.getSortedChildIdsForParent(newlyPastedFrame.parentId)
	const pastedBounds = editor.getShapePageBounds(newlyPastedFrame.id)!
	let targetPosition = pastedBounds.minX

	const siblingBounds = siblingIds
		.map((id) => ({ id, bounds: editor.getShapePageBounds(id)! }))
		.sort((a, b) => a.bounds.minX - b.bounds.minX)

	for (const sibling of siblingBounds) {
		if (sibling.id === newlyPastedFrame.id) continue

		// if this sibling is above or below the copied frame, we don't need to take it into account
		if (sibling.bounds.minY > pastedBounds.maxY || sibling.bounds.maxY < pastedBounds.minY) continue

		// if the sibling is to the left of the copied frame, we don't need to take it into account
		if (sibling.bounds.maxX < targetPosition) continue

		// if the sibling is to the right of where the pasted frame would end up, we don't care about it
		if (sibling.bounds.minX > targetPosition + pastedBounds.w) continue

		// otherwise, we need to shift our target right edge to the right of this sibling
		targetPosition = sibling.bounds.maxX + SPACING_BETWEEN_FRAMES
	}

	// translate the pasted frame into position:
	editor.nudgeShapes([newlyPastedFrame.id], {
		x: targetPosition - pastedBounds.minX,
		y: 0,
	})
}
```

--------

# External content sources

Category: Data & assets

Keywords: copy, paste, html

Handle different types of content when pasting into tldraw.

In this example, we register a special handler for when the user pastes in `'text/html'` content. We add it to a special shape type that renders the HTML content directly. Try copying and pasting some code from a VSCode file.

## App.tsx

```tsx
import { useCallback } from 'react'
import {
	BaseBoxShapeUtil,
	defaultHandleExternalTextContent,
	Editor,
	HTMLContainer,
	TLBaseShape,
	Tldraw,
} from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this page!

// [1]
export type IDangerousHtmlShape = TLBaseShape<
	'html',
	{
		w: number
		h: number
		html: string
	}
>

// [2]
class DangerousHtmlExample extends BaseBoxShapeUtil<IDangerousHtmlShape> {
	static override type = 'html' as const

	override getDefaultProps() {
		return {
			type: 'html',
			w: 500,
			h: 300,
			html: '<div>hello</div>',
		}
	}

	override component(shape: IDangerousHtmlShape) {
		return (
			<HTMLContainer style={{ overflow: 'auto' }}>
				<div dangerouslySetInnerHTML={{ __html: shape.props.html }}></div>
			</HTMLContainer>
		)
	}

	override indicator(shape: IDangerousHtmlShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}

// [3]

export default function ExternalContentSourcesExample() {
	const handleMount = useCallback((editor: Editor) => {
		// We will register a new handler for text content. When a user pastes `text/html` content into the editor,
		// we will create a new shape with that html content.
		// To test this copy some html content from VS Code or some other text editor.
		editor.registerExternalContentHandler('text', async (content) => {
			const htmlSource = content.sources?.find((s) => s.type === 'text' && s.subtype === 'html')

			if (htmlSource) {
				const center = content.point ?? editor.getViewportPageBounds().center

				editor.createShape({
					type: 'html',
					x: center.x - 250,
					y: center.y - 150,
					props: {
						html: htmlSource.data,
					},
				})
			} else {
				// otherwise, we'll fall back to the default handler
				await defaultHandleExternalTextContent(editor, content)
			}
		})
	}, [])

	return (
		<div className="tldraw__editor">
			<Tldraw onMount={handleMount} shapeUtils={[DangerousHtmlExample]} />
		</div>
	)
}

/* 
Introduction:
This example shows how to handle content pasted from external sources, this could be
embeds, files, svgs, text, images, or urls. In this case we will handle text/html content.

[1]
We want to render our html on the canvas, the best way to do that is to create a new shape util.
Here's where we define the type for our shape.

[2]
This is our shape util. It's a class that extends BaseBoxShapeUtil. For a more detailed
example of how to create a custom shape, see the custom config example.

[3]
We use the onMount prop to get access to the editor instance via 
the handleMount callback (check out the API example for a more detailed look at this). Then we 
call the registerExternalContentHandler method, we could choose to handle embeds, files, svgs, 
text, images, or urls. For this example we will handle text/html content. The handler is called
with the point where the user pasted the content and an array of sources. We will find and 
return the html source, then create a new shape with that html content.

*/
```

--------

# Meta migrations

Category: Data & assets

Keywords: records, snapshot, sequence

Create custom migrations for `meta` properties.

You can add arbitrary data migrations for tldraw snapshot data. This is mainly useful for updating the `meta` property of a record as your data types evolve.

## App.tsx

```tsx
import { Tldraw, createMigrationIds, createMigrationSequence } from 'tldraw'
import 'tldraw/tldraw.css'
import { snapshot } from './snapshot'
import { components } from './ui-overrides'

/**
 * This example demonstrates how to add custom migrations for `meta` properties, or any other
 * data in your store snapshots.
 *
 * If you have a custom shape type and you want to add migrations for its `props` object,
 * there is a simpler dedicated API for that. Check out [the docs](https://tldraw.dev/docs/persistence#Shape-props-migrations) for more info.
 */

/**
 * Let's say you added some page metadata, e.g. to allow setting the background color of a page independently.
 */
interface _PageMetaV1 {
	backgroundTheme?: 'red' | 'blue' | 'green' | 'purple'
}

/**
 * And then perhaps later on you decided to remove support for 'purple' because it's an ugly color.
 * So all purple pages will become blue.
 */
export interface PageMetaV2 {
	backgroundTheme?: 'red' | 'blue' | 'green'
}

/**
 * You would then create a migration to update the metadata from v1 to v2.
 */

// First pick a 'sequence id' that is unique to your app
const sequenceId = 'com.example.my-app'
// Then create a 'migration id' for each version of your metadata
const versions = createMigrationIds(sequenceId, {
	// the numbers must start at 1 and increment by 1
	RemovePurple: 1,
})
const migrations = createMigrationSequence({
	sequenceId,
	sequence: [
		{
			id: versions.RemovePurple,
			// `scope: 'record` tells the schema to call this migration on individual records.
			// `scope: 'store'` would call it on the entire snapshot, to allow for actions like deleting/creating records.
			scope: 'record',
			// When `scope` is 'record', you can specify a filter function to only apply the migration to records that match the filter.
			filter: (record) => record.typeName === 'page',
			// This up function will be called on all records that match the filter
			up(page: any) {
				if (page.meta.backgroundTheme === 'purple') {
					page.meta.backgroundTheme = 'blue'
					page.name += ' (was purple)'
				}
			},
		},
	],
})

export default function MetaMigrationsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// Pass in the custom migrations
				migrations={[migrations]}
				// When you load a snapshot from a previous version, the migrations will be applied automatically
				snapshot={snapshot}
				// This adds a dropdown to the canvas for changing the backgroundTheme property
				components={components}
			/>
		</div>
	)
}
```

## snapshot.ts

```ts
import { TLStoreSnapshot } from 'tldraw'

export const snapshot = {
	store: {
		'document:document': {
			gridSize: 10,
			name: '',
			meta: {},
			id: 'document:document',
			typeName: 'document',
		},
		'page:red': {
			meta: {
				backgroundTheme: 'red',
			},
			id: 'page:red',
			name: 'Red',
			index: 'a1',
			typeName: 'page',
		},
		'page:green': {
			meta: {
				backgroundTheme: 'green',
			},
			id: 'page:green',
			name: 'Green',
			index: 'a2',
			typeName: 'page',
		},
		'page:blue': {
			meta: {
				backgroundTheme: 'blue',
			},
			id: 'page:blue',
			name: 'Blue',
			index: 'a3',
			typeName: 'page',
		},
		'page:purple': {
			meta: {
				backgroundTheme: 'purple',
			},
			id: 'page:purple',
			name: 'Purple',
			index: 'a0',
			typeName: 'page',
		},
	},
	schema: {
		schemaVersion: 2,
		sequences: {
			'com.tldraw.store': 4,
			'com.tldraw.document': 2,
			'com.tldraw.page': 1,
		},
	},
} as TLStoreSnapshot
```

## ui-overrides.tsx

```tsx
import { useLayoutEffect } from 'react'
import { TLComponents, track, useEditor } from 'tldraw'
import { PageMetaV2 } from './MetaMigrations'

export const components: TLComponents = {
	TopPanel: track(() => {
		const editor = useEditor()
		const currentPage = editor.getCurrentPage()
		const meta: PageMetaV2 = currentPage.meta

		useLayoutEffect(() => {
			const elem = document.querySelector('.tl-background') as HTMLElement
			if (!elem) return
			elem.style.backgroundColor = meta.backgroundTheme ?? 'unset'
		}, [meta.backgroundTheme])

		return (
			<span style={{ pointerEvents: 'all', padding: '5px 15px', margin: 10, fontSize: 18 }}>
				bg: &nbsp;
				<select
					value={meta.backgroundTheme ?? 'none'}
					onChange={(e) => {
						if (e.currentTarget.value === 'none') {
							editor.updatePage({ ...currentPage, meta: {} })
						} else {
							editor.updatePage({
								...currentPage,
								meta: { backgroundTheme: e.currentTarget.value },
							})
						}
					}}
				>
					<option value="none">None</option>
					<option value="red">Red</option>
					<option value="blue">Blue</option>
					<option value="green">Green</option>
				</select>
			</span>
		)
	}),
}
```

--------

# Slideshow (fixed camera)

Category: Use cases

Keywords: annotation, camera options, constraints, zoom, pan, camera bounds, pan speed, zoom speed, scroll, slides, presentation

A simple slideshow app with a fixed camera.

This example shows one way of making a simple slideshow app with a fixed camera, using camera options.

## App.tsx

```tsx
import { useEffect, useState } from 'react'
import {
	Editor,
	TLFrameShape,
	Tldraw,
	createShapeId,
	stopEventPropagation,
	transact,
	useValue,
} from 'tldraw'
import 'tldraw/tldraw.css'
import { SLIDE_MARGIN, SLIDE_SIZE, SlidesProvider, useSlides } from './SlidesManager'

export default function SlideShowExample() {
	return (
		<div className="tldraw__editor">
			<SlidesProvider>
				<InsideSlidesContext />
			</SlidesProvider>
		</div>
	)
}

function InsideSlidesContext() {
	const [editor, setEditor] = useState<Editor | null>(null)
	const slides = useSlides()

	const currentSlide = useValue('currentSlide', () => slides.getCurrentSlide(), [slides])

	useEffect(() => {
		if (!editor) return

		const nextBounds = {
			x: currentSlide.index * (SLIDE_SIZE.w + SLIDE_MARGIN),
			y: 0,
			w: SLIDE_SIZE.w,
			h: SLIDE_SIZE.h,
		}

		editor.setCameraOptions({
			constraints: {
				bounds: nextBounds,
				behavior: 'contain',
				initialZoom: 'fit-max',
				baseZoom: 'fit-max',
				origin: { x: 0.5, y: 0.5 },
				padding: { x: 50, y: 50 },
			},
		})

		editor.zoomToBounds(nextBounds, { force: true, animation: { duration: 500 } })
	}, [editor, currentSlide])

	const currentSlides = useValue('slides', () => slides.getCurrentSlides(), [slides])

	useEffect(() => {
		if (!editor) return

		const ids = currentSlides.map((slide) => createShapeId(slide.id))

		transact(() => {
			for (let i = 0; i < currentSlides.length; i++) {
				const shapeId = ids[i]
				const slide = currentSlides[i]
				const shape = editor.getShape(shapeId)
				if (shape) {
					if (shape.x === slide.index * (SLIDE_SIZE.w + SLIDE_MARGIN)) continue

					// if name is still Slide and number, e.g Slide 1, update it. Use regex to test

					const regex = /Slide \d+/
					let name = (shape as TLFrameShape).props.name
					if (regex.test((shape as TLFrameShape).props.name)) {
						name = `Slide ${slide.index + 1}`
					}

					editor.updateShape<TLFrameShape>({
						id: shapeId,
						type: 'frame',
						x: slide.index * (SLIDE_SIZE.w + SLIDE_MARGIN),
						props: {
							name,
						},
					})
				} else {
					editor.createShape<TLFrameShape>({
						id: shapeId,
						parentId: editor.getCurrentPageId(),
						type: 'frame',
						x: slide.index * (SLIDE_SIZE.w + SLIDE_MARGIN),
						y: 0,
						props: {
							name: `Slide ${slide.index + 1}`,
							w: SLIDE_SIZE.w,
							h: SLIDE_SIZE.h,
						},
					})
				}
			}
		})

		const unsubs = [] as (() => void)[]

		unsubs.push(
			editor.sideEffects.registerBeforeChangeHandler('shape', (prev, next) => {
				if (
					ids.includes(next.id) &&
					(next as TLFrameShape).props.name === (prev as TLFrameShape).props.name
				)
					return prev
				return next
			})
		)

		unsubs.push(
			editor.sideEffects.registerBeforeChangeHandler('instance_page_state', (prev, next) => {
				next.selectedShapeIds = next.selectedShapeIds.filter((id) => !ids.includes(id))
				if (next.hoveredShapeId && ids.includes(next.hoveredShapeId)) next.hoveredShapeId = null
				return next
			})
		)

		return () => {
			unsubs.forEach((fn) => fn())
		}
	}, [currentSlides, editor])

	const handleMount = (editor: Editor) => {
		setEditor(editor)
	}

	return <Tldraw onMount={handleMount} components={components} />
}

function Slides() {
	const slides = useSlides()
	const currentSlides = useValue('slides', () => slides.getCurrentSlides(), [slides])
	const lowestIndex = currentSlides[0].index
	const highestIndex = currentSlides[currentSlides.length - 1].index

	return (
		<>
			{/* {currentSlides.map((slide) => (
				<div
					key={slide.id}
					style={{
						position: 'absolute',
						top: 0,
						left: (SLIDE_SIZE.w + SLIDE_MARGIN) * slide.index,
						width: SLIDE_SIZE.w,
						height: SLIDE_SIZE.h,
						backgroundColor: 'white',
						border: '1px solid black',
						pointerEvents: 'all',
					}}
					onPointerDown={(e) => {
						if (slide.id !== slides.getCurrentSlideId()) {
							stopEventPropagation(e)
							slides.setCurrentSlide(slide.id)
						}
					}}
				/>
			))} */}
			{currentSlides.slice(0, -1).map((slide) => (
				<button
					key={slide.id + 'between'}
					style={{
						position: 'absolute',
						top: SLIDE_SIZE.h / 2,
						left: (slide.index + 1) * (SLIDE_SIZE.w + SLIDE_MARGIN) - (SLIDE_MARGIN + 40) / 2,
						width: 40,
						height: 40,
						pointerEvents: 'all',
					}}
					onPointerDown={stopEventPropagation}
					onClick={() => {
						const newSlide = slides.newSlide(slide.index + 1)
						slides.setCurrentSlide(newSlide.id)
					}}
				>
					|
				</button>
			))}
			<button
				style={{
					position: 'absolute',
					top: SLIDE_SIZE.h / 2,
					left: lowestIndex * (SLIDE_SIZE.w + SLIDE_MARGIN) - (40 + SLIDE_MARGIN * 0.1),
					width: 40,
					height: 40,
					pointerEvents: 'all',
				}}
				onPointerDown={stopEventPropagation}
				onClick={() => {
					const slide = slides.newSlide(lowestIndex - 1)
					slides.setCurrentSlide(slide.id)
				}}
			>
				{`+`}
			</button>
			<button
				style={{
					position: 'absolute',
					top: SLIDE_SIZE.h / 2,
					left: highestIndex * (SLIDE_SIZE.w + SLIDE_MARGIN) + (SLIDE_SIZE.w + SLIDE_MARGIN * 0.1),
					width: 40,
					height: 40,
					pointerEvents: 'all',
				}}
				onPointerDown={stopEventPropagation}
				onClick={() => {
					const slide = slides.newSlide(highestIndex + 1)
					slides.setCurrentSlide(slide.id)
				}}
			>
				{`+`}
			</button>
		</>
	)
}

function SlideControls() {
	const slides = useSlides()

	return (
		<>
			<button
				style={{
					pointerEvents: 'all',
					position: 'absolute',
					top: '50%',
					left: 0,
					width: 50,
					height: 50,
				}}
				onPointerDown={stopEventPropagation}
				onClick={() => slides.prevSlide()}
			>
				{`<`}
			</button>
			<button
				style={{
					pointerEvents: 'all',
					position: 'absolute',
					top: '50%',
					right: 0,
					width: 50,
					height: 50,
				}}
				onPointerDown={stopEventPropagation}
				onClick={() => slides.nextSlide()}
			>
				{`>`}
			</button>
		</>
	)
}

const components = {
	OnTheCanvas: Slides,
	InFrontOfTheCanvas: SlideControls,
}
```

## SlidesManager.tsx

```tsx
import { createContext, ReactNode, useContext, useState } from 'react'
import { atom, computed, structuredClone, uniqueId } from 'tldraw'

export const SLIDE_SIZE = { x: 0, y: 0, w: 1600, h: 900 }
export const SLIDE_MARGIN = 100

interface Slide {
	id: string
	index: number
	name: string
}

class SlidesManager {
	private _slides = atom<Slide[]>('slide', [
		{
			id: '1',
			index: 0,
			name: 'Slide 1',
		},
		{
			id: '2',
			index: 1,
			name: 'Slide 2',
		},
		{
			id: '3',
			index: 2,
			name: 'Slide 3',
		},
	])

	@computed getCurrentSlides() {
		return this._slides.get().sort((a, b) => (a.index < b.index ? -1 : 1))
	}

	private _currentSlideId = atom('currentSlide', '1')

	@computed getCurrentSlideId() {
		return this._currentSlideId.get()
	}

	@computed getCurrentSlide() {
		return this._slides.get().find((slide) => slide.id === this.getCurrentSlideId())!
	}

	setCurrentSlide(id: string) {
		this._currentSlideId.set(id)
	}

	moveBy(delta: number) {
		const slides = this.getCurrentSlides()
		const currentIndex = slides.findIndex((slide) => slide.id === this.getCurrentSlideId())
		const next = slides[currentIndex + delta]
		if (!next) return
		this._currentSlideId.set(next.id)
	}

	nextSlide() {
		this.moveBy(1)
	}

	prevSlide() {
		this.moveBy(-1)
	}

	newSlide(index: number) {
		const slides = structuredClone(this.getCurrentSlides())

		let bumping = false
		for (const slide of slides) {
			if (slide.index === index) {
				bumping = true
			}
			if (bumping) {
				slide.index++
			}
		}

		const newSlide = {
			id: uniqueId(),
			index,
			name: `Slide ${slides.length + 1}`,
		}

		this._slides.set([...slides, newSlide])

		return newSlide
	}
}

const slidesContext = createContext({} as SlidesManager)

export const SlidesProvider = ({ children }: { children: ReactNode }) => {
	const [slideManager] = useState(() => new SlidesManager())
	return <slidesContext.Provider value={slideManager}>{children}</slidesContext.Provider>
}

export function useSlides() {
	return useContext(slidesContext)
}
```

--------

# Slideshow (free camera)

Category: Use cases

Keywords: annotation, camera options, constraints, zoom, pan, camera bounds, pan speed, zoom speed, scroll, slides, presentation

A simple slideshow app with a moving camera.

This example shows one way of making a simple slideshow app with a moving camera.

## App.tsx

```tsx
import {
	DefaultKeyboardShortcutsDialog,
	DefaultKeyboardShortcutsDialogContent,
	DefaultToolbar,
	DefaultToolbarContent,
	TLComponents,
	TLUiOverrides,
	Tldraw,
	TldrawUiMenuItem,
	computed,
	track,
	useIsToolSelected,
	useTools,
} from 'tldraw'
import 'tldraw/tldraw.css'
import { SlideShapeTool } from './SlideShapeTool'
import { SlideShapeUtil } from './SlideShapeUtil'
import { SlidesPanel } from './SlidesPanel'
import './slides.css'
import { $currentSlide, getSlides, moveToSlide } from './useSlides'

const components: TLComponents = {
	HelperButtons: SlidesPanel,
	Minimap: null,
	Toolbar: (props) => {
		const tools = useTools()
		const isSlideSelected = useIsToolSelected(tools['slide'])
		return (
			<DefaultToolbar {...props}>
				<TldrawUiMenuItem {...tools['slide']} isSelected={isSlideSelected} />
				<DefaultToolbarContent />
			</DefaultToolbar>
		)
	},
	KeyboardShortcutsDialog: (props) => {
		const tools = useTools()
		return (
			<DefaultKeyboardShortcutsDialog {...props}>
				<TldrawUiMenuItem {...tools['slide']} />
				<DefaultKeyboardShortcutsDialogContent />
			</DefaultKeyboardShortcutsDialog>
		)
	},
}

const overrides: TLUiOverrides = {
	actions(editor, actions) {
		const $slides = computed('slides', () => getSlides(editor))
		return {
			...actions,
			'next-slide': {
				id: 'next-slide',
				label: 'Next slide',
				kbd: 'right',
				onSelect() {
					const slides = $slides.get()
					const currentSlide = $currentSlide.get()
					const index = slides.findIndex((s) => s.id === currentSlide?.id)
					const nextSlide = slides[index + 1] ?? currentSlide ?? slides[0]
					if (nextSlide) {
						editor.stopCameraAnimation()
						moveToSlide(editor, nextSlide)
					}
				},
			},
			'previous-slide': {
				id: 'previous-slide',
				label: 'Previous slide',
				kbd: 'left',
				onSelect() {
					const slides = $slides.get()
					const currentSlide = $currentSlide.get()
					const index = slides.findIndex((s) => s.id === currentSlide?.id)
					const previousSlide = slides[index - 1] ?? currentSlide ?? slides[slides.length - 1]
					if (previousSlide) {
						editor.stopCameraAnimation()
						moveToSlide(editor, previousSlide)
					}
				},
			},
		}
	},
	tools(editor, tools) {
		tools.slide = {
			id: 'slide',
			icon: 'group',
			label: 'Slide',
			kbd: 's',
			onSelect: () => editor.setCurrentTool('slide'),
		}
		return tools
	},
}

const SlidesExample = track(() => {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="slideshow_example"
				shapeUtils={[SlideShapeUtil]}
				tools={[SlideShapeTool]}
				components={components}
				overrides={overrides}
			/>
		</div>
	)
})

export default SlidesExample
```

## SlideShapeTool.tsx

```tsx
import { BaseBoxShapeTool } from 'tldraw'

export class SlideShapeTool extends BaseBoxShapeTool {
	static override id = 'slide'
	static override initial = 'idle'
	override shapeType = 'slide'
}
```

## SlideShapeUtil.tsx

```tsx
import { useCallback } from 'react'
import {
	Geometry2d,
	RecordProps,
	Rectangle2d,
	SVGContainer,
	ShapeUtil,
	T,
	TLBaseShape,
	TLResizeInfo,
	getPerfectDashProps,
	resizeBox,
	useValue,
} from 'tldraw'
import { moveToSlide, useSlides } from './useSlides'

export type SlideShape = TLBaseShape<
	'slide',
	{
		w: number
		h: number
	}
>

export class SlideShapeUtil extends ShapeUtil<SlideShape> {
	static override type = 'slide' as const
	static override props: RecordProps<SlideShape> = {
		w: T.number,
		h: T.number,
	}

	override canBind() {
		return false
	}
	override hideRotateHandle() {
		return true
	}

	getDefaultProps(): SlideShape['props'] {
		return {
			w: 720,
			h: 480,
		}
	}

	getGeometry(shape: SlideShape): Geometry2d {
		return new Rectangle2d({
			width: shape.props.w,
			height: shape.props.h,
			isFilled: false,
		})
	}

	override onRotate(initial: SlideShape) {
		return initial
	}

	override onResize(shape: SlideShape, info: TLResizeInfo<SlideShape>) {
		return resizeBox(shape, info)
	}

	override onDoubleClick(shape: SlideShape) {
		moveToSlide(this.editor, shape)
		this.editor.selectNone()
	}

	override onDoubleClickEdge(shape: SlideShape) {
		moveToSlide(this.editor, shape)
		this.editor.selectNone()
	}

	component(shape: SlideShape) {
		const bounds = this.editor.getShapeGeometry(shape).bounds

		// eslint-disable-next-line react-hooks/rules-of-hooks
		const zoomLevel = useValue('zoom level', () => this.editor.getZoomLevel(), [this.editor])

		// eslint-disable-next-line react-hooks/rules-of-hooks
		const slides = useSlides()
		const index = slides.findIndex((s) => s.id === shape.id)

		// eslint-disable-next-line react-hooks/rules-of-hooks
		const handleLabelPointerDown = useCallback(() => this.editor.select(shape.id), [shape.id])

		if (!bounds) return null

		return (
			<>
				<div onPointerDown={handleLabelPointerDown} className="slide-shape-label">
					{`Slide ${index + 1}`}
				</div>
				<SVGContainer>
					<g
						style={{
							stroke: 'var(--color-text)',
							strokeWidth: 'calc(1px * var(--tl-scale))',
							opacity: 0.25,
						}}
						pointerEvents="none"
						strokeLinecap="round"
						strokeLinejoin="round"
					>
						{bounds.sides.map((side, i) => {
							const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
								side[0].dist(side[1]),
								1 / zoomLevel,
								{
									style: 'dashed',
									lengthRatio: 6,
									forceSolid: zoomLevel < 0.2,
								}
							)

							return (
								<line
									key={i}
									x1={side[0].x}
									y1={side[0].y}
									x2={side[1].x}
									y2={side[1].y}
									strokeDasharray={strokeDasharray}
									strokeDashoffset={strokeDashoffset}
								/>
							)
						})}
					</g>
				</SVGContainer>
			</>
		)
	}

	indicator(shape: SlideShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}
```

## SlidesPanel.tsx

```tsx
import { TldrawUiButton, stopEventPropagation, track, useEditor, useValue } from 'tldraw'
import { moveToSlide, useCurrentSlide, useSlides } from './useSlides'

export const SlidesPanel = track(() => {
	const editor = useEditor()
	const slides = useSlides()
	const currentSlide = useCurrentSlide()
	const selectedShapes = useValue('selected shapes', () => editor.getSelectedShapes(), [editor])

	if (slides.length === 0) return null
	return (
		<div className="slides-panel scroll-light" onPointerDown={(e) => stopEventPropagation(e)}>
			{slides.map((slide, i) => {
				const isSelected = selectedShapes.includes(slide)
				return (
					<TldrawUiButton
						key={'slides-panel-button:' + slide.id}
						type="normal"
						className="slides-panel-button"
						onClick={() => moveToSlide(editor, slide)}
						style={{
							background: currentSlide?.id === slide.id ? 'var(--color-background)' : 'transparent',
							outline: isSelected ? 'var(--color-selection-stroke) solid 1.5px' : 'none',
						}}
					>
						{`Slide ${i + 1}`}
					</TldrawUiButton>
				)
			})}
		</div>
	)
})
```

## slides.css

```css
.slides-panel {
	display: flex;
	flex-direction: column;
	gap: 4px;
	max-height: calc(100% - 110px);
	margin: 50px 0px;
	padding: 4px;
	background-color: var(--color-low);
	pointer-events: all;
	border-top-right-radius: var(--radius-4);
	border-bottom-right-radius: var(--radius-4);
	overflow: auto;
	border-right: 2px solid var(--color-background);
	border-bottom: 2px solid var(--color-background);
	border-top: 2px solid var(--color-background);
}

.slides-panel-button {
	border-radius: var(--radius-4);
	outline-offset: -1px;
}

.slide-shape-label {
	pointer-events: all;
	position: absolute;
	background: var(--color-low);
	padding: calc(12px * var(--tl-scale));
	border-bottom-right-radius: calc(var(--radius-4) * var(--tl-scale));
	font-size: calc(12px * var(--tl-scale));
	color: var(--color-text);
	white-space: nowrap;
}
```

## useSlides.tsx

```tsx
import { EASINGS, Editor, atom, useEditor, useValue } from 'tldraw'
import { SlideShape } from './SlideShapeUtil'

export const $currentSlide = atom<SlideShape | null>('current slide', null)

export function moveToSlide(editor: Editor, slide: SlideShape) {
	const bounds = editor.getShapePageBounds(slide.id)
	if (!bounds) return
	$currentSlide.set(slide)
	editor.selectNone()
	editor.zoomToBounds(bounds, {
		inset: 0,
		animation: { duration: 500, easing: EASINGS.easeInOutCubic },
	})
}

export function useSlides() {
	const editor = useEditor()
	return useValue<SlideShape[]>('slide shapes', () => getSlides(editor), [editor])
}

export function useCurrentSlide() {
	return useValue($currentSlide)
}

export function getSlides(editor: Editor) {
	return editor
		.getSortedChildIdsForParent(editor.getCurrentPageId())
		.map((id) => editor.getShape(id))
		.filter((s) => s?.type === 'slide') as SlideShape[]
}
```

--------

# Education Canvas

Category: Use cases

Keywords: education, math, geometry, GCSE, teaching, learning, canvas, fixed camera

An educational application template with a math question on the left and a drawing canvas on the right.

This example demonstrates how to create an educational application using tldraw. It features:

- **Split Layout**: Question panel on the left, drawing canvas on the right
- **Fixed Camera**: Canvas has constrained bounds to keep students focused on the drawing area
- **GCSE Math Question**: A geometry problem suitable for GCSE-level mathematics
- **Grid Background**: Coordinate grid to help with plotting points and shapes
- **Educational Styling**: Clean, professional styling suitable for educational environments

Perfect for creating interactive math worksheets, geometry exercises, or any educational content that requires visual problem-solving.

## App.tsx

```tsx
import { memo, useCallback, useEffect, useRef, useState } from 'react'
import { Box, Editor, TLCameraOptions, TLComponents, Tldraw, track, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'
import './education-canvas.css'

// Fixed camera options to prevent zooming/panning
const CAMERA_OPTIONS: Partial<TLCameraOptions> = {
	isLocked: false,
	constraints: {
		initialZoom: 'fit-max',
		baseZoom: 'fit-max',
		bounds: {
			x: 0,
			y: 0,
			w: 600,
			h: 600,
		},
		behavior: { x: 'contain', y: 'contain' },
		padding: { x: 100, y: 100 },
		origin: { x: 0.5, y: 0.5 },
	},
}

const CameraSetup = track(() => {
	const editor = useEditor()

	useEffect(() => {
		if (!editor) return
		editor.run(() => {
			editor.zoomToBounds(new Box(0, 0, 600, 600), {
				inset: 150,
			})
			editor.setCameraOptions(CAMERA_OPTIONS)
			editor.setCamera(editor.getCamera(), {
				immediate: true,
			})
			// editor.updateInstanceState({
			// 	isGridMode: true,
			// })
		})
	}, [editor])

	return null
})

const TICKS = 8

const CartesianGrid = memo(function CartesianGrid() {
	return (
		<svg
			className="cartesian-grid"
			width="600"
			height="600"
			viewBox="0 0 600 600"
			stroke="#aaa"
			color="#aaa"
		>
			{Array.from({ length: TICKS * 2 + 1 }).map((_, i) => {
				const step = 600 / (TICKS * 2)
				const opacity = i === TICKS ? 1 : 0.16
				return (
					<g key={i + '_line'}>
						<line x1={0} y1={i * step} x2={600} y2={i * step} strokeWidth="1" opacity={opacity} />
						<line x1={i * step} y1={0} x2={i * step} y2={600} strokeWidth="1" opacity={opacity} />
					</g>
				)
			})}
			<g>
				{Array.from({ length: TICKS * 2 + 1 }).map((_, i) => {
					const index = i
					if (i - TICKS === 0) return null
					const y = 600 - index * (600 / (TICKS * 2))
					return (
						<g key={i + '_textx'}>
							<text
								key={index}
								x={312}
								y={y}
								dy="0.3em"
								fontFamily="Arial"
								textAnchor="start"
								letterSpacing=".25em"
								stroke="none"
								fill="#aaa"
								fontWeight="bold"
							>
								{-TICKS + index}
							</text>
							<line x1={295} y1={y} x2={305} y2={y} strokeWidth="2" />
						</g>
					)
				})}
				{Array.from({ length: TICKS * 2 + 1 }).map((_, i) => {
					const index = i
					if (i - TICKS === 0) return null
					const x = index * (600 / (TICKS * 2))
					return (
						<g key={i + '_texty'}>
							<text
								key={index}
								x={x}
								y={320}
								dy="0.3em"
								fontFamily="Arial"
								textAnchor="middle"
								stroke="none"
								fill="#aaa"
								fontWeight="bold"
							>
								{-TICKS + index}
							</text>
							<line x1={x} y1={295} x2={x} y2={305} strokeWidth="2" strokeLinecap="round" />
						</g>
					)
				})}
			</g>
		</svg>
	)
})

const components: TLComponents = {
	OnTheCanvas: CartesianGrid,
}

export default function EducationCanvasExample() {
	const [answers, setAnswers] = useState({
		partB: '',
		partC: '',
	})

	const handleAnswerChange = (part: keyof typeof answers, value: string) => {
		setAnswers((prev) => ({ ...prev, [part]: value }))
	}

	const rEditor = useRef<Editor | null>(null)
	const handleMount = useCallback((editor: Editor) => {
		rEditor.current = editor
	}, [])

	const handleSubmit = useCallback(async () => {
		// Normalize answers for comparison
		const normalizeAnswer = (answer: string) => {
			return answer.toLowerCase().replace(/[^a-z0-9(),.-]/g, '')
		}

		// Check Part B - Area (accept 8, 8 square units, 8 unitsÂ², etc.)
		const normalizedB = normalizeAnswer(answers.partB)
		const isPartBCorrect =
			normalizedB.includes('8') &&
			(normalizedB.includes('square') || normalizedB.includes('unit') || normalizedB === '8')

		// Check Part C - Coordinates (accept (0,7), (0, 7), 0,7, etc.)
		const normalizedC = normalizeAnswer(answers.partC)
		const isPartCCorrect =
			normalizedC.includes('0') &&
			normalizedC.includes('7') &&
			(normalizedC.includes('(0,7)') ||
				normalizedC.includes('0,7') ||
				normalizedC.match(/0.*7/) ||
				normalizedC.match(/7.*0/))

		if (isPartBCorrect && isPartCCorrect) {
			alert('Good job! Both answers are correct!')
		} else if (isPartBCorrect || isPartCCorrect) {
			let message = 'Good progress! '
			if (isPartBCorrect) message += 'Part B is correct. '
			if (isPartCCorrect) message += 'Part C is correct. '
			if (!isPartBCorrect) message += 'Check your area calculation for Part B.'
			if (!isPartCCorrect) message += 'Check your coordinates for Part C.'
			alert(message)
		} else {
			alert('Please check your answers and try again.')
		}

		// Do something with the answers
		const editor = rEditor.current
		if (editor) {
			// For example, get the canvas content and the answers and send it to the server.
			// const result = {
			// 	answers: {
			// 		partA: await editor.toImage(editor.getCurrentPageShapes()),
			// 		partB: answers.partB,
			// 		partC: answers.partC,
			// 	},
			// }
			// console.log(result)
		}
	}, [answers])

	return (
		<div className="education-container">
			{/* Question Panel - Left Half */}
			<div className="question-panel">
				<div className="question-content">
					<h1 className="main-title">Mathematics - Geometry</h1>

					<div className="question-card">
						<h2 className="question-title">Question 1</h2>
						<p className="question-text">
							A triangle ABC has vertices at A(2, 3), B(6, 3), and C(4, 7).
						</p>

						<div className="question-part">
							<p className="question-text">
								<strong>Part A:</strong> Draw triangle ABC on the coordinate grid.
							</p>
						</div>

						<div className="question-part">
							<p className="question-text">
								<strong>Part B:</strong> Calculate the area of triangle ABC.
							</p>
							<div className="answer-input-group">
								<label className="answer-label">
									<strong>Answer:</strong>
								</label>
								<input
									type="text"
									className="answer-input"
									placeholder="Enter the area"
									value={answers.partB}
									onChange={(e) => handleAnswerChange('partB', e.target.value)}
								/>
							</div>
						</div>

						<div className="question-part">
							<p className="question-text">
								<strong>Part C:</strong> Find the coordinates of point D such that ABCD forms a
								parallelogram.
							</p>
							<div className="answer-input-group">
								<label className="answer-label">
									<strong>Answer:</strong>
								</label>
								<input
									type="text"
									className="answer-input"
									placeholder="Enter coordinates as (x, y)"
									value={answers.partC}
									onChange={(e) => handleAnswerChange('partC', e.target.value)}
								/>
							</div>
						</div>

						<button className="submit-button" onClick={handleSubmit}>
							Submit Answers
						</button>
					</div>

					<div className="instructions-card">
						<h3 className="instructions-title">Instructions:</h3>
						<ul className="instructions-list">
							<li>Use the drawing canvas on the right to sketch your solution</li>
							<li>
								You can use the draw tool <kbd>D</kbd> to draw points and the line tool <kbd>L</kbd>{' '}
								to draw lines
							</li>
							<li>
								Use the text tool <kbd>T</kbd> to label points and write calculations
							</li>
							<li>Show all your working clearly</li>
							<li>Enter your final answers in the answer boxes above</li>
						</ul>
					</div>
				</div>
			</div>

			{/* Canvas Panel - Right Half */}
			<div className="canvas-panel">
				<div className="canvas-container">
					<Tldraw
						options={{ maxPages: 1 }}
						persistenceKey="education-canvas"
						components={components}
						onMount={handleMount}
						overrides={{
							tools: (_editor, tools) => {
								// These are the tool ids that are allowed to be used in the education canvas...
								const allowedTools = ['select', 'hand', 'draw', 'eraser', 'line', 'text']
								// Tools are keyed by their id, so we can delete off all the tools that are not in the allowedTools array
								for (const key in tools) {
									if (!allowedTools.includes(key)) {
										delete tools[key]
									}
								}
								// Return the mutated tools
								return tools
							},
						}}
					>
						<CameraSetup />
					</Tldraw>
				</div>
			</div>
		</div>
	)
}
```

## education-canvas.css

```css
/* Education Canvas Example Styles */

.education-container {
	display: flex;
	min-height: 100vh;
	font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
	gap: 40px;
}

.question-panel {
	width: 100%;
	max-width: 500px;
	flex-shrink: 0;
	padding: 2rem;
	background-color: #f8fafc;
	border-right: 2px solid #e2e8f0;
	display: flex;
	flex-direction: column;
	justify-content: flex-start;
	overflow: auto;
}

.question-content {
	max-width: 500px;
}

.main-title {
	font-size: 1.5rem;
	font-weight: bold;
	margin-bottom: 1.5rem;
	color: #1e293b;
}

.question-card {
	background-color: white;
	padding: 1.5rem;
	border-radius: 8px;
	border: 1px solid #e2e8f0;
	margin-bottom: 1.5rem;
}

.question-title {
	font-size: 1.2rem;
	font-weight: 600;
	margin-bottom: 1rem;
	color: #374151;
}

.question-text {
	line-height: 1.6;
	margin-bottom: 1rem;
	color: #4b5563;
}

.question-text:last-child {
	margin-bottom: 0;
}

.instructions-card {
	background-color: #e0f2fe;
	padding: 1rem;
	border-radius: 6px;
	border: 1px solid #0284c7;
}

.instructions-title {
	margin: 0;
	font-size: 1rem;
	font-weight: 600;
	margin-bottom: 0.5rem;
	color: #0c4a6e;
}

.instructions-list {
	margin: 0;
	padding-left: 1.2rem;
	color: #0c4a6e;
}

.hint-card {
	background-color: #fef3c7;
	padding: 1rem;
	border-radius: 6px;
	border: 1px solid #f59e0b;
	margin-top: 1rem;
}

.hint-text {
	margin: 0;
	font-size: 0.9rem;
	color: #92400e;
}

.canvas-panel {
	flex: 1;
	position: relative;
	background-color: #ffffff;
	min-width: 0; /* Allows flex item to shrink below content size */
}

.canvas-container {
	position: absolute;
	top: 1rem;
	left: 1rem;
	right: 1rem;
	bottom: 1rem;
	border: 2px solid #e2e8f0;
	border-radius: 8px;
	overflow: hidden;
}

.cartesian-grid {
	position: absolute;
	top: 0px;
	left: 0px;
	right: 0;
	bottom: 0;
	width: 600px;
	height: 600px;
	overflow: visible;
}

.mask-fg {
	position: absolute;
	inset: 0px;
	background-color: black;
	opacity: 0.5;
	pointer-events: none;
}

/* Answer Section Styles */
.answer-section {
	padding: 1rem;
	background-color: #f8fafc;
	border-top: 2px solid #e2e8f0;
	max-height: 300px;
	overflow-y: auto;
}

.answer-title {
	font-size: 1.1rem;
	font-weight: 600;
	margin-bottom: 1rem;
	color: #374151;
}

.answer-input-group {
	margin-bottom: 1rem;
}

.answer-input-group:last-child {
	margin-bottom: 0;
}

.answer-label {
	display: block;
	font-size: 0.9rem;
	font-weight: 500;
	margin-bottom: 0.5rem;
	color: #4b5563;
}

.answer-input {
	width: 100%;
	padding: 0.5rem;
	border: 1px solid #d1d5db;
	border-radius: 4px;
	font-size: 0.9rem;
	color: #374151;
	background-color: white;
	box-sizing: border-box;
}

.answer-input:focus {
	outline: none;
	border-color: #3b82f6;
	box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

.answer-input::placeholder {
	color: #9ca3af;
}

.submit-button {
	width: 100%;
	padding: 0.75rem;
	margin-top: 1rem;
	background-color: #3b82f6;
	color: white;
	border: none;
	border-radius: 6px;
	font-size: 1rem;
	font-weight: 600;
	cursor: pointer;
	transition: background-color 0.2s ease;
}

.submit-button:hover {
	background-color: #2563eb;
}

.submit-button:active {
	background-color: #1d4ed8;
}

/* Question Part Styles */
.question-part {
	margin-bottom: 1.5rem;
}

.question-part:last-of-type {
	margin-bottom: 1rem;
}

/* Answer input styles within question card */
.question-card .answer-input-group {
	margin-top: 0.75rem;
	margin-bottom: 0;
}

.question-card .answer-input {
	width: 100%;
	padding: 0.5rem;
	border: 1px solid #d1d5db;
	border-radius: 4px;
	font-size: 0.9rem;
	color: #374151;
	background-color: white;
	box-sizing: border-box;
}

.question-card .answer-input:focus {
	outline: none;
	border-color: #3b82f6;
	box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

.question-card .answer-input::placeholder {
	color: #9ca3af;
}

.question-card .submit-button {
	width: 100%;
	padding: 0.75rem;
	margin-top: 1rem;
	background-color: #3b82f6;
	color: white;
	border: none;
	border-radius: 6px;
	font-size: 1rem;
	font-weight: 600;
	cursor: pointer;
	transition: background-color 0.2s ease;
}

.question-card .submit-button:hover {
	background-color: #2563eb;
}

.question-card .submit-button:active {
	background-color: #1d4ed8;
}

/* Mobile responsiveness */
@media (max-width: 1000px) {
	.education-container {
		flex-direction: column;
		gap: 0;
		min-height: auto;
	}

	.question-panel {
		max-width: none;
		border-right: none;
		border-bottom: 2px solid #e2e8f0;
	}

	.canvas-panel {
		min-height: 60vh;
	}

	.canvas-container {
		overflow: hidden;
		position: relative !important;
		top: auto !important;
		left: auto !important;
		right: auto !important;
		bottom: auto !important;
		height: 60vh;
		margin: 1rem;
	}
}
```

--------

# Image annotator

Category: Use cases

Keywords: annotation, camera options, constraints, zoom, pan, camera bounds, pan speed, zoom speed

An image annotator built with tldraw.

This example shows how you might want to configure `cameraOptions` to make an image annotation app.

## App.tsx

```tsx
import { useState } from 'react'
import 'tldraw/tldraw.css'
import { ImageAnnotationEditor } from './ImageAnnotationEditor'
import { ImageExport } from './ImageExport'
import { ImagePicker } from './ImagePicker'
import './image-annotator.css'
import { AnnotatorImage } from './types'

type State =
	| {
			phase: 'pick'
	  }
	| {
			phase: 'annotate'
			id: string
			image: AnnotatorImage
	  }
	| {
			phase: 'export'
			result: Blob
	  }

export default function ImageAnnotatorWrapper() {
	const [state, setState] = useState<State>({ phase: 'pick' })

	switch (state.phase) {
		case 'pick':
			return (
				<div className="ImageAnnotator">
					<ImagePicker
						onChooseImage={(image) =>
							setState({ phase: 'annotate', image, id: Math.random().toString(36) })
						}
					/>
				</div>
			)
		case 'annotate':
			return (
				<div className="ImageAnnotator">
					<ImageAnnotationEditor
						// remount tldraw if the image/id changes:
						key={state.id}
						image={state.image}
						onDone={(result) => setState({ phase: 'export', result })}
					/>
				</div>
			)
		case 'export':
			return (
				<div className="ImageAnnotator">
					<ImageExport result={state.result} onStartAgain={() => setState({ phase: 'pick' })} />
				</div>
			)
	}
}
```

## ImageAnnotationEditor.tsx

```tsx
import { useCallback, useEffect, useState } from 'react'
import {
	AssetRecordType,
	Editor,
	SVGContainer,
	TLImageShape,
	TLShapeId,
	Tldraw,
	createShapeId,
	track,
	useEditor,
} from 'tldraw'
import { AnnotatorImage } from './types'

// TODO:
// - prevent changing pages (create page, change page, move shapes to new page)
// - prevent locked shape context menu
// - inertial scrolling for constrained camera
export function ImageAnnotationEditor({
	image,
	onDone,
}: {
	image: AnnotatorImage
	onDone(result: Blob): void
}) {
	const [imageShapeId, setImageShapeId] = useState<TLShapeId | null>(null)
	const [editor, setEditor] = useState(null as Editor | null)

	function onMount(editor: Editor) {
		setEditor(editor)
	}

	useEffect(() => {
		if (!editor) return

		// Create the asset and image shape
		const assetId = AssetRecordType.createId()
		editor.createAssets([
			{
				id: assetId,
				typeName: 'asset',
				type: 'image',
				meta: {},
				props: {
					w: image.width,
					h: image.height,
					mimeType: image.type,
					src: image.src,
					name: 'image',
					isAnimated: false,
				},
			},
		])
		const shapeId = createShapeId()
		editor.createShape<TLImageShape>({
			id: shapeId,
			type: 'image',
			x: 0,
			y: 0,
			isLocked: true,
			props: {
				w: image.width,
				h: image.height,
				assetId,
			},
		})

		// Make sure the shape is at the bottom of the page
		function makeSureShapeIsAtBottom() {
			if (!editor) return

			const shape = editor.getShape(shapeId)
			if (!shape) return

			const pageId = editor.getCurrentPageId()

			// The shape should always be the child of the current page
			if (shape.parentId !== pageId) {
				editor.moveShapesToPage([shape], pageId)
			}

			// The shape should always be at the bottom of the page's children
			const siblings = editor.getSortedChildIdsForParent(pageId)
			const currentBottomShape = editor.getShape(siblings[0])!
			if (currentBottomShape.id !== shapeId) {
				editor.sendToBack([shape])
			}
		}

		makeSureShapeIsAtBottom()

		const removeOnCreate = editor.sideEffects.registerAfterCreateHandler(
			'shape',
			makeSureShapeIsAtBottom
		)

		const removeOnChange = editor.sideEffects.registerAfterChangeHandler(
			'shape',
			makeSureShapeIsAtBottom
		)

		// The shape should always be locked
		const cleanupKeepShapeLocked = editor.sideEffects.registerBeforeChangeHandler(
			'shape',
			(prev, next) => {
				if (next.id !== shapeId) return next
				if (next.isLocked) return next
				return { ...prev, isLocked: true }
			}
		)

		// Reset the history
		editor.clearHistory()
		setImageShapeId(shapeId)

		return () => {
			removeOnChange()
			removeOnCreate()
			cleanupKeepShapeLocked()
		}
	}, [image, editor])

	useEffect(() => {
		if (!editor) return
		if (!imageShapeId) return

		/**
		 * We don't want the user to be able to scroll away from the image, or zoom it all the way out. This
		 * component hooks into camera updates to keep the camera constrained - try uploading a very long,
		 * thin image and seeing how the camera behaves.
		 */
		editor.setCameraOptions({
			constraints: {
				initialZoom: 'default',
				baseZoom: 'fit-min-100',
				bounds: { w: image.width, h: image.height, x: 0, y: 0 },
				padding: { x: 32, y: 64 },
				origin: { x: 0.5, y: 0.5 },
				behavior: 'contain',
			},
		})
		editor.setCamera(editor.getCamera(), { reset: true })
	}, [editor, imageShapeId, image])

	return (
		<Tldraw
			onMount={onMount}
			components={{
				// we don't need pages for this use-case
				PageMenu: null,
				// grey-out the area outside of the image
				InFrontOfTheCanvas: useCallback(() => {
					if (!imageShapeId) return null
					return <ImageBoundsOverlay imageShapeId={imageShapeId} />
				}, [imageShapeId]),
				// add a "done" button in the top right for when the user is ready to export
				SharePanel: useCallback(() => {
					if (!imageShapeId) return null
					return <DoneButton imageShapeId={imageShapeId} onClick={onDone} />
				}, [imageShapeId, onDone]),
			}}
		/>
	)
}

/**
 * When we export, we'll only include the bounds of the image itself, so show an overlay on top of
 * the canvas to make it clear what will/won't be included. Check `image-annotator.css` for more on
 * how this works.
 */
const ImageBoundsOverlay = track(function ImageBoundsOverlay({
	imageShapeId,
}: {
	imageShapeId: TLShapeId
}) {
	const editor = useEditor()
	const image = editor.getShape(imageShapeId) as TLImageShape
	if (!image) return null

	const imagePageBounds = editor.getShapePageBounds(imageShapeId)!
	const viewport = editor.getViewportScreenBounds()
	const topLeft = editor.pageToViewport(imagePageBounds)
	const bottomRight = editor.pageToViewport({ x: imagePageBounds.maxX, y: imagePageBounds.maxY })

	const path = [
		// start by tracing around the viewport itself:
		`M ${-10} ${-10}`,
		`L ${viewport.maxX + 10} ${-10}`,
		`L ${viewport.maxX + 10} ${viewport.maxY + 10}`,
		`L ${-10} ${viewport.maxY + 10}`,
		`Z`,

		// then cut out a hole for the image:
		`M ${topLeft.x} ${topLeft.y}`,
		`L ${bottomRight.x} ${topLeft.y}`,
		`L ${bottomRight.x} ${bottomRight.y}`,
		`L ${topLeft.x} ${bottomRight.y}`,
		`Z`,
	].join(' ')

	return (
		<SVGContainer className="ImageOverlayScreen">
			<path d={path} fillRule="evenodd" />
		</SVGContainer>
	)
})

function DoneButton({
	imageShapeId,
	onClick,
}: {
	imageShapeId: TLShapeId
	onClick(result: Blob): void
}) {
	const editor = useEditor()
	return (
		<button
			className="DoneButton"
			onClick={async () => {
				const { blob } = await editor.toImage([...editor.getCurrentPageShapeIds()], {
					format: 'png',
					background: true,
					bounds: editor.getShapePageBounds(imageShapeId)!,
					padding: 0,
					scale: 1,
				})

				onClick(blob)
			}}
		>
			Done
		</button>
	)
}
```

## ImageExport.tsx

```tsx
import { useEffect, useLayoutEffect, useState } from 'react'

export function ImageExport({ result, onStartAgain }: { result: Blob; onStartAgain(): void }) {
	const [src, setSrc] = useState<string | null>(null)
	useLayoutEffect(() => {
		const url = URL.createObjectURL(result)
		setSrc(url)
		return () => URL.revokeObjectURL(url)
	}, [result])

	function onDownload() {
		if (!src) return

		const a = document.createElement('a')
		a.href = src
		a.download = 'annotated-image.png'
		a.click()
	}

	const [didCopy, setDidCopy] = useState(false)
	function onCopy() {
		navigator.clipboard.write([new ClipboardItem({ [result.type]: result })])
		setDidCopy(true)
	}
	useEffect(() => {
		if (!didCopy) return
		const t = setTimeout(() => setDidCopy(false), 2000)
		return () => clearTimeout(t)
	}, [didCopy])

	return (
		<div className="ImageExport">
			{src && <img src={src} />}
			<div className="ImageExport-buttons">
				<button onClick={onCopy}>{didCopy ? 'Copied!' : 'Copy'}</button>
				<button onClick={onDownload}>Download</button>
			</div>
			<button onClick={onStartAgain}>Start Again</button>
		</div>
	)
}
```

## ImagePicker.tsx

```tsx
import { useState } from 'react'
import { DEFAULT_SUPPORTED_MEDIA_TYPE_LIST, FileHelpers, MediaHelpers } from 'tldraw'
import anakin from './assets/anakin.jpeg'
import distractedBf from './assets/distracted-bf.jpeg'
import expandingBrain from './assets/expanding-brain.png'

export function ImagePicker({
	onChooseImage,
}: {
	onChooseImage(image: { src: string; width: number; height: number; type: string }): void
}) {
	const [isLoading, setIsLoading] = useState(false)
	function onClickChooseImage() {
		const input = window.document.createElement('input')
		input.type = 'file'
		input.accept = DEFAULT_SUPPORTED_MEDIA_TYPE_LIST
		input.addEventListener('change', async (e) => {
			const fileList = (e.target as HTMLInputElement).files
			if (!fileList || fileList.length === 0) return
			const file = fileList[0]

			setIsLoading(true)
			try {
				const dataUrl = await FileHelpers.blobToDataUrl(file)
				const { w, h } = await MediaHelpers.getImageSize(file)
				onChooseImage({ src: dataUrl, width: w, height: h, type: file.type })
			} finally {
				setIsLoading(false)
			}
		})
		input.click()
	}

	async function onChooseExample(src: string) {
		setIsLoading(true)
		try {
			const image = await fetch(src)
			const blob = await image.blob()
			const { w, h } = await MediaHelpers.getImageSize(blob)
			onChooseImage({ src, width: w, height: h, type: blob.type })
		} finally {
			setIsLoading(false)
		}
	}

	if (isLoading) {
		return <div className="ImagePicker">Loading...</div>
	}

	return (
		<div className="ImagePicker">
			<button onClick={onClickChooseImage}>Choose an image</button>
			<div className="ImagePicker-exampleLabel">or use an example:</div>
			<div className="ImagePicker-examples">
				<img src={anakin} alt="anakin" onClick={() => onChooseExample(anakin)} />
				<img
					src={distractedBf}
					alt="distracted boyfriend"
					onClick={() => onChooseExample(distractedBf)}
				/>
				<img
					src={expandingBrain}
					alt="expanding brain"
					onClick={() => onChooseExample(expandingBrain)}
				/>
			</div>
		</div>
	)
}
```

## image-annotator.css

```css
.ImageAnnotator {
	position: absolute;
	inset: 0;
}

.ImageAnnotator .ImagePicker {
	position: absolute;
	inset: 1rem;
	display: flex;
	align-items: center;
	justify-content: center;
	text-align: center;
	flex-direction: column;
	gap: 1rem;
}
.ImageAnnotator .ImagePicker button {
	padding: 0.5rem 1rem;
	border: none;
	background: #eee;
	cursor: pointer;
	font: inherit;
}
.ImageAnnotator .ImagePicker button:hover {
	opacity: 0.9;
}
.ImageAnnotator .ImagePicker-exampleLabel {
	padding-top: 1rem;
	opacity: 0.7;
	font-size: 14px;
}
.ImageAnnotator .ImagePicker-examples {
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	width: 100%;
	max-width: 780px;
	gap: 1rem;
}
.ImageAnnotator .ImagePicker-examples img {
	width: 100%;
	height: auto;
	object-fit: contain;
	aspect-ratio: 1;
	cursor: pointer;
}
.ImageAnnotator .ImagePicker-examples img:hover {
	opacity: 0.9;
}

.ImageAnnotator .ImageOverlayScreen {
	pointer-events: none;
	fill: var(--color-background);
	fill-opacity: 0.8;
	stroke: none;
}

.ImageAnnotator .DoneButton {
	font: inherit;
	background: var(--color-primary);
	border: none;
	color: var(--color-selected-contrast);
	font-size: 1rem;
	padding: 0.5rem 1rem;
	border-radius: 6px;
	margin: 6px;
	pointer-events: all;
	z-index: var(--layer-panels);
	border: 2px solid var(--color-background);
	cursor: pointer;
}
.ImageAnnotator .DoneButton:hover {
	filter: brightness(1.1);
}

.ImageAnnotator .ImageExport {
	padding: 1rem;
	display: flex;
	flex-direction: column;
	gap: 1rem;
	align-items: center;
	height: 100%;
}
.ImageAnnotator .ImageExport img {
	width: 100%;
	max-height: 50vh;
	object-fit: contain;
}
.ImageAnnotator .ImageExport button {
	padding: 0.5rem 1rem;
	border: none;
	background: #eee;
	cursor: pointer;
	font: inherit;
}
.ImageAnnotator .ImageExport button:hover {
	opacity: 0.9;
}
.ImageAnnotator .ImageExport-buttons {
	display: flex;
	gap: 1rem;
	align-items: center;
	justify-content: center;
	margin-bottom: auto;
}
.ImageAnnotator .ImageExport-buttons button {
	background-color: hsl(214, 84%, 56%);
	color: white;
}
```

## types.tsx

```tsx
export interface AnnotatorImage {
	src: string
	width: number
	height: number
	type: string
}
```

--------

# PDF editor

Category: Use cases

Keywords: annotation, camera options, constraints, zoom, pan, camera bounds, pan speed, zoom speed, scroll

A very basic PDF editor built with tldraw.

This example shows how you might want to configure `cameraOptions` to make a PDF editor.

## App.tsx

```tsx
import { useState } from 'react'
import 'tldraw/tldraw.css'
import { PdfEditor } from './PdfEditor'
import { Pdf, PdfPicker } from './PdfPicker'
import './pdf-editor.css'

type State =
	| {
			phase: 'pick'
	  }
	| {
			phase: 'edit'
			pdf: Pdf
	  }

export default function PdfEditorWrapper() {
	const [state, setState] = useState<State>({ phase: 'pick' })

	switch (state.phase) {
		case 'pick':
			return (
				<div className="PdfEditor">
					<PdfPicker onOpenPdf={(pdf) => setState({ phase: 'edit', pdf })} />
				</div>
			)
		case 'edit':
			return (
				<div className="PdfEditor">
					<PdfEditor pdf={state.pdf} />
				</div>
			)
	}
}
```

## ExportPdfButton.tsx

```tsx
import { PDFDocument } from 'pdf-lib'
import { useState } from 'react'
import { Editor, useEditor } from 'tldraw'
import { Pdf } from './PdfPicker'

export function ExportPdfButton({ pdf }: { pdf: Pdf }) {
	const [exportProgress, setExportProgress] = useState<number | null>(null)
	const editor = useEditor()

	return (
		<button
			className="ExportPdfButton"
			onClick={async () => {
				setExportProgress(0)
				try {
					await exportPdf(editor, pdf, setExportProgress)
				} finally {
					setExportProgress(null)
				}
			}}
		>
			{exportProgress ? `Exporting... ${Math.round(exportProgress * 100)}%` : 'Export PDF'}
		</button>
	)
}

async function exportPdf(
	editor: Editor,
	{ name, source, pages }: Pdf,
	onProgress: (progress: number) => void
) {
	const totalThings = pages.length * 2 + 2
	let progressCount = 0
	const tickProgress = () => {
		progressCount++
		onProgress(progressCount / totalThings)
	}

	const pdf = await PDFDocument.load(source)
	tickProgress()

	const pdfPages = pdf.getPages()
	if (pdfPages.length !== pages.length) {
		throw new Error('PDF page count mismatch')
	}

	const pageShapeIds = new Set(pages.map((page) => page.shapeId))
	const allIds = Array.from(editor.getCurrentPageShapeIds()).filter((id) => !pageShapeIds.has(id))

	for (let i = 0; i < pages.length; i++) {
		const page = pages[i]
		const pdfPage = pdfPages[i]

		const bounds = page.bounds
		const shapesInBounds = allIds.filter((id) => {
			const shapePageBounds = editor.getShapePageBounds(id)
			if (!shapePageBounds) return false
			return shapePageBounds.collides(bounds)
		})

		if (shapesInBounds.length === 0) {
			tickProgress()
			tickProgress()
			continue
		}

		const exportedPng = await editor.toImage(allIds, {
			format: 'png',
			background: false,
			bounds: page.bounds,
			padding: 0,
			scale: 1,
		})
		tickProgress()

		pdfPage.drawImage(await pdf.embedPng(await exportedPng.blob.arrayBuffer()), {
			x: 0,
			y: 0,
			width: pdfPage.getWidth(),
			height: pdfPage.getHeight(),
		})
		tickProgress()
	}

	const url = URL.createObjectURL(new Blob([await pdf.save()], { type: 'application/pdf' }))
	tickProgress()
	const a = document.createElement('a')
	a.href = url
	a.download = name
	a.click()
	URL.revokeObjectURL(url)
}
```

## PdfEditor.tsx

```tsx
import { useMemo } from 'react'
import {
	Box,
	SVGContainer,
	TLComponents,
	TLImageShape,
	TLShapePartial,
	Tldraw,
	getIndicesBetween,
	react,
	sortByIndex,
	track,
	useEditor,
} from 'tldraw'
import { ExportPdfButton } from './ExportPdfButton'
import { Pdf } from './PdfPicker'

// TODO:
// - prevent changing pages (create page, change page, move shapes to new page)
// - prevent locked shape context menu
// - inertial scrolling for constrained camera
// - render pages on-demand instead of all at once.
export function PdfEditor({ pdf }: { pdf: Pdf }) {
	const components = useMemo<TLComponents>(
		() => ({
			PageMenu: null,
			InFrontOfTheCanvas: () => <PageOverlayScreen pdf={pdf} />,
			SharePanel: () => <ExportPdfButton pdf={pdf} />,
		}),
		[pdf]
	)

	return (
		<Tldraw
			onMount={(editor) => {
				editor.createAssets(
					pdf.pages.map((page) => ({
						id: page.assetId,
						typeName: 'asset',
						type: 'image',
						meta: {},
						props: {
							w: page.bounds.w,
							h: page.bounds.h,
							mimeType: 'image/png',
							src: page.src,
							name: 'page',
							isAnimated: false,
						},
					}))
				)
				editor.createShapes(
					pdf.pages.map(
						(page): TLShapePartial<TLImageShape> => ({
							id: page.shapeId,
							type: 'image',
							x: page.bounds.x,
							y: page.bounds.y,
							isLocked: true,
							props: {
								assetId: page.assetId,
								w: page.bounds.w,
								h: page.bounds.h,
							},
						})
					)
				)

				const shapeIds = pdf.pages.map((page) => page.shapeId)
				const shapeIdSet = new Set(shapeIds)

				// Don't let the user unlock the pages
				editor.sideEffects.registerBeforeChangeHandler('shape', (prev, next) => {
					if (!shapeIdSet.has(next.id)) return next
					if (next.isLocked) return next
					return { ...prev, isLocked: true }
				})

				// Make sure the shapes are below any of the other shapes
				function makeSureShapesAreAtBottom() {
					const shapes = shapeIds.map((id) => editor.getShape(id)!).sort(sortByIndex)
					const pageId = editor.getCurrentPageId()

					const siblings = editor.getSortedChildIdsForParent(pageId)
					const currentBottomShapes = siblings
						.slice(0, shapes.length)
						.map((id) => editor.getShape(id)!)

					if (currentBottomShapes.every((shape, i) => shape.id === shapes[i].id)) return

					const otherSiblings = siblings.filter((id) => !shapeIdSet.has(id))
					const bottomSibling = otherSiblings[0]
					const lowestIndex = editor.getShape(bottomSibling)!.index

					const indexes = getIndicesBetween(undefined, lowestIndex, shapes.length)
					editor.updateShapes(
						shapes.map((shape, i) => ({
							id: shape.id,
							type: shape.type,
							isLocked: shape.isLocked,
							index: indexes[i],
						}))
					)
				}

				makeSureShapesAreAtBottom()
				editor.sideEffects.registerAfterCreateHandler('shape', makeSureShapesAreAtBottom)
				editor.sideEffects.registerAfterChangeHandler('shape', makeSureShapesAreAtBottom)

				// Constrain the camera to the bounds of the pages
				const targetBounds = pdf.pages.reduce(
					(acc, page) => acc.union(page.bounds),
					pdf.pages[0].bounds.clone()
				)

				function updateCameraBounds(isMobile: boolean) {
					editor.setCameraOptions({
						constraints: {
							bounds: targetBounds,
							padding: { x: isMobile ? 16 : 164, y: 64 },
							origin: { x: 0.5, y: 0 },
							initialZoom: 'fit-x-100',
							baseZoom: 'default',
							behavior: 'contain',
						},
					})
					editor.setCamera(editor.getCamera(), { reset: true })
				}

				let isMobile = editor.getViewportScreenBounds().width < 840

				react('update camera', () => {
					const isMobileNow = editor.getViewportScreenBounds().width < 840
					if (isMobileNow === isMobile) return
					isMobile = isMobileNow
					updateCameraBounds(isMobile)
				})

				updateCameraBounds(isMobile)
			}}
			components={components}
		/>
	)
}

const PageOverlayScreen = track(function PageOverlayScreen({ pdf }: { pdf: Pdf }) {
	const editor = useEditor()

	const viewportPageBounds = editor.getViewportPageBounds()
	const viewportScreenBounds = editor.getViewportScreenBounds()

	const relevantPageBounds = pdf.pages
		.map((page) => {
			if (!viewportPageBounds.collides(page.bounds)) return null
			const topLeft = editor.pageToViewport(page.bounds)
			const bottomRight = editor.pageToViewport({ x: page.bounds.maxX, y: page.bounds.maxY })
			return new Box(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y)
		})
		.filter((bounds): bounds is Box => bounds !== null)

	function pathForPageBounds(bounds: Box) {
		return `M ${bounds.x} ${bounds.y} L ${bounds.maxX} ${bounds.y} L ${bounds.maxX} ${bounds.maxY} L ${bounds.x} ${bounds.maxY} Z`
	}

	const viewportPath = `M 0 0 L ${viewportScreenBounds.w} 0 L ${viewportScreenBounds.w} ${viewportScreenBounds.h} L 0 ${viewportScreenBounds.h} Z`

	return (
		<>
			<SVGContainer className="PageOverlayScreen-screen">
				<path
					d={`${viewportPath} ${relevantPageBounds.map(pathForPageBounds).join(' ')}`}
					fillRule="evenodd"
				/>
			</SVGContainer>
			{relevantPageBounds.map((bounds, i) => (
				<div
					key={i}
					className="PageOverlayScreen-outline"
					style={{
						width: bounds.w,
						height: bounds.h,
						transform: `translate(${bounds.x}px, ${bounds.y}px)`,
					}}
				/>
			))}
		</>
	)
})
```

## PdfPicker.tsx

```tsx
import { useState } from 'react'
import { AssetRecordType, Box, TLAssetId, TLShapeId, createShapeId } from 'tldraw'
import tldrawPdf from './assets/tldraw.pdf'

export interface PdfPage {
	src: string
	bounds: Box
	assetId: TLAssetId
	shapeId: TLShapeId
}

export interface Pdf {
	name: string
	pages: PdfPage[]
	source: string | ArrayBuffer
}

const pageSpacing = 32

export function PdfPicker({ onOpenPdf }: { onOpenPdf(pdf: Pdf): void }) {
	const [isLoading, setIsLoading] = useState(false)

	async function loadPdf(name: string, source: ArrayBuffer): Promise<Pdf> {
		const PdfJS = await import('pdfjs-dist')
		PdfJS.GlobalWorkerOptions.workerSrc = new URL(
			'pdfjs-dist/build/pdf.worker.min.mjs',
			import.meta.url
		).toString()
		const pdf = await PdfJS.getDocument(source.slice(0)).promise
		const pages: PdfPage[] = []

		const canvas = window.document.createElement('canvas')
		const context = canvas.getContext('2d')
		if (!context) throw new Error('Failed to create canvas context')

		const visualScale = 1.5
		const scale = window.devicePixelRatio

		let top = 0
		let widest = 0
		for (let i = 1; i <= pdf.numPages; i++) {
			const page = await pdf.getPage(i)
			const viewport = page.getViewport({ scale: scale * visualScale })
			canvas.width = viewport.width
			canvas.height = viewport.height
			const renderContext = {
				canvasContext: context,
				viewport,
			}
			await page.render(renderContext).promise

			const width = viewport.width / scale
			const height = viewport.height / scale
			pages.push({
				src: canvas.toDataURL(),
				bounds: new Box(0, top, width, height),
				assetId: AssetRecordType.createId(),
				shapeId: createShapeId(),
			})
			top += height + pageSpacing
			widest = Math.max(widest, width)
		}
		canvas.width = 0
		canvas.height = 0

		for (const page of pages) {
			page.bounds.x = (widest - page.bounds.width) / 2
		}

		return {
			name,
			pages,
			source,
		}
	}

	function onClickOpenPdf() {
		const input = window.document.createElement('input')
		input.type = 'file'
		input.accept = 'application/pdf'
		input.addEventListener('change', async (e) => {
			const fileList = (e.target as HTMLInputElement).files
			if (!fileList || fileList.length === 0) return
			const file = fileList[0]

			setIsLoading(true)
			try {
				const pdf = await loadPdf(file.name, await file.arrayBuffer())
				onOpenPdf(pdf)
			} finally {
				setIsLoading(false)
			}
		})
		input.click()
	}

	async function onClickUseExample() {
		setIsLoading(true)
		try {
			const result = await fetch(tldrawPdf)
			const pdf = await loadPdf('tldraw.pdf', await result.arrayBuffer())
			onOpenPdf(pdf)
		} finally {
			setIsLoading(false)
		}
	}

	if (isLoading) {
		return <div className="PdfPicker">Loading...</div>
	}

	return (
		<div className="PdfPicker">
			<button onClick={onClickOpenPdf}>Open PDF</button>
			<div>or</div>
			<button onClick={onClickUseExample}>Use an example</button>
		</div>
	)
}
```

## pdf-editor.css

```css
.PdfEditor {
	position: absolute;
	inset: 0;
}

.PdfEditor .PdfPicker {
	position: absolute;
	inset: 1rem;
	display: flex;
	align-items: center;
	justify-content: center;
	text-align: center;
	flex-direction: column;
	gap: 1rem;
}
.PdfEditor .PdfPicker button {
	padding: 0.5rem 1rem;
	border: none;
	background: #eee;
	cursor: pointer;
	font: inherit;
}
.PdfEditor .PdfPicker button:hover {
	opacity: 0.9;
}

.PdfEditor .PdfBgRenderer {
	position: absolute;
	pointer-events: none;
}
.PdfEditor .PdfBgRenderer img {
	position: absolute;
}

.PdfEditor .PageOverlayScreen-screen {
	pointer-events: none;
	fill: var(--color-background);
	fill-opacity: 0.8;
	stroke: none;
}
.PdfEditor .PageOverlayScreen-outline {
	position: absolute;
	pointer-events: none;
	/* border: 1px solid var(--color-overlay); */
	box-shadow: var(--shadow-2);
}
.PdfEditor .ExportPdfButton {
	font: inherit;
	background: var(--color-primary);
	border: none;
	color: var(--color-selected-contrast);
	font-size: 1rem;
	padding: 0.5rem 1rem;
	border-radius: 6px;
	margin: 6px;
	margin-bottom: 0;
	pointer-events: all;
	z-index: var(--layer-panels);
	border: 2px solid var(--color-background);
	cursor: pointer;
}
.PdfEditor .ExportPdfButton:hover {
	filter: brightness(1.1);
}
```

--------

# Canvas mask

Category: Use cases

Keywords: mask, window, clip

This example shows how you can mask the canvas.

The canvas has a white overlay. When you have a shape selected, the shape's bounds will be used as a mask through the overlay.

## App.tsx

```tsx
import { useEffect, useRef } from 'react'
import { TLComponents, TLShape, Tldraw, createShapeId, useEditor, useQuickReactor } from 'tldraw'
import 'tldraw/tldraw.css'
import './mask-window.css'

function MaskWindow() {
	const editor = useEditor()
	const ref = useRef<HTMLDivElement>(null)

	useQuickReactor(
		'clip',
		() => {
			const elm = ref.current
			if (!elm) return

			const rotation = editor.getSelectionRotation()
			const box = editor.getSelectionRotatedScreenBounds()

			if (!box) {
				// If there's nothing selected, clear the clip path
				elm.style.clipPath = ''
				return
			}

			const vsb = editor.getViewportScreenBounds()

			// Expand the box, offset it by the viewport screen bounds, and get the corners
			const { corners } = box.clone().translate(vsb.point.clone().neg()).expandBy(20)

			// Account for rotation by rotating the points of the rectangle
			const [tl, tr, br, bl] = corners.map((p) => p.rotWith(box.point, rotation))

			// Since there's no reliable "reverse clip path", we wind around the corners in order to turn our clip into a mask
			elm.style.clipPath = `polygon(0% 0%, ${tl.x}px 0%, ${tl.x}px ${tl.y}px, ${bl.x}px ${bl.y}px, ${br.x}px ${br.y}px, ${tr.x}px ${tr.y}px, ${tl.x}px ${tl.y}px, ${tl.x}px 0%, 100% 0%, 100% 100%, 0% 100%)`
		},
		[editor]
	)

	useExtraBonusStuff()

	return <div ref={ref} className="mask-fg" />
}

const components: TLComponents = {
	InFrontOfTheCanvas: () => {
		return <MaskWindow />
	},
}

export default function MaskWindowExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="mask" components={components} />
		</div>
	)
}

// Some extra stuff that isnt necessary but good for this demo
function useExtraBonusStuff() {
	const editor = useEditor()

	useEffect(() => {
		if (editor.getCurrentPageShapeIds().size === 0) {
			const vpb = editor.getViewportPageBounds()

			// if the canvas is empty, create some shapes for the demo
			for (let i = 0; i < 50; i++) {
				const x = vpb.x + Math.random() * vpb.w
				const y = vpb.y + Math.random() * vpb.h
				editor.createShape({ type: 'geo', x, y })
			}

			const id = createShapeId()
			const { center } = editor.getViewportPageBounds()
			editor.createShape({
				id,
				type: 'geo',
				x: center.x - 100,
				y: center.y - 100,
				props: {
					w: 200,
					h: 200,
				},
			})
			editor.select(id)
		}

		// As a (fragile) treat, press J to save positions for the selected shape, then press Ctrl+J to animate between positions
		const positions: TLShape[] = []

		const handleKeydown = (e: any) => {
			if (e.key === 'j') {
				e.preventDefault()
				e.stopPropagation()
				if (e.metaKey || e.ctrlKey) {
					const shape = positions.shift()
					if (!shape) return
					editor.animateShape(shape, { animation: { duration: 1000 } })
				} else {
					const shape = editor.getOnlySelectedShape()
					if (!shape) return
					positions.push(shape)
				}
			}
		}
		document.addEventListener('keydown', handleKeydown)
		return () => {
			document.removeEventListener('keydown', handleKeydown)
		}
	}, [editor])
}
```

## mask-window.css

```css
.mask-svg {
	position: absolute;
	top: 0px;
	left: 0px;
}

.mask-fg {
	position: absolute;
	top: 0px;
	left: 0px;
	width: 100%;
	height: 100%;
	pointer-events: none;
	background-color: rgba(255, 255, 255, 0.9);
	/* -webkit-mask:
		url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200" preserveAspectRatio="none"><rect x="100" y="100" width="20" height="20"/></svg>')
			0/100% 100%,
		linear-gradient(#fff, #fff);
	-webkit-mask-composite: destination-out;
	mask-composite: exclude; */
}
```

--------

# Fog of war

Category: Use cases

Keywords: ui, fog, overlay

Create a fog of war effect by keeping an HTML canvas in sync with canvas content.

This example shows how you might keep an HTML canvas in sync with canvas content. It implements a simple "fog of war" effect, where the canvas is covered by a black overlay that can be cleared by drawing shapes on the canvas.

## App.tsx

```tsx
import { useEffect, useRef } from 'react'
import { Box, TLComponents, Tldraw, Vec, useEditor, useReactor } from 'tldraw'
import 'tldraw/tldraw.css'

const CELL_SIZE = 32
const COUNT = 100

const boxes: Box[][] = []
const cells: boolean[][] = []
for (let i = 0; i < COUNT; i++) {
	cells[i] = []
	boxes[i] = []
	for (let j = 0; j < COUNT; j++) {
		cells[i].push(false)
		boxes[i].push(
			new Box((i - COUNT / 2) * CELL_SIZE, (j - COUNT / 2) * CELL_SIZE, CELL_SIZE, CELL_SIZE)
		)
	}
}

export function Fog() {
	const rCanvas = useRef<HTMLCanvasElement>(null)
	const rVisibility = useRef<boolean[][]>(cells)
	const editor = useEditor()

	useEffect(() => {
		const cvs = rCanvas.current!
		const rect = cvs.getBoundingClientRect()
		cvs.width = rect.width
		cvs.height = rect.height
	}, [editor])

	useReactor(
		'update fog',
		() => {
			const cells = rVisibility.current
			const shapes = editor.getCurrentPageShapes()
			for (const shape of shapes) {
				const point = editor.getShapePageBounds(shape)!.point
				const geometry = editor.getShapeGeometry(shape)
				const adjustedPoint = Vec.Sub(point, geometry.bounds.point)
				for (let i = 0; i < boxes.length; i++) {
					for (let j = 0; j < boxes[i].length; j++) {
						const box = boxes[i][j]
						box.translate(Vec.Neg(adjustedPoint))
						if (geometry.bounds.collides(box)) {
							cells[i][j] = true
						}
						box.translate(adjustedPoint)
					}
				}
			}
			const cvs = rCanvas.current!
			const ctx = cvs.getContext('2d')!

			cvs.style.filter = `blur(${editor.getCamera().z * 15}px)`

			ctx.resetTransform()
			const camera = editor.getCamera()

			ctx.clearRect(0, 0, cvs.width, cvs.height)
			ctx.fillStyle = 'rgba(0,0,0,0.9)'
			ctx.fillRect(0, 0, cvs.width, cvs.height)

			ctx.translate(100, 100)
			ctx.scale(camera.z, camera.z)
			ctx.translate(camera.x, camera.y)

			for (let i = 0; i < boxes.length; i++) {
				for (let j = 0; j < boxes[i].length; j++) {
					if (!cells[i][j]) continue
					const box = boxes[i][j]
					ctx.clearRect(box.x, box.y, box.width, box.height)
				}
			}
		},
		[editor]
	)

	return (
		<canvas
			ref={rCanvas}
			style={{
				position: 'absolute',
				top: -100,
				left: -100,
				width: 'calc(100% + 200px)',
				height: 'calc(100% + 200px)',
				WebkitFilter: 'blur(15px)',
				filter: 'blur(15px)',
				pointerEvents: 'none',
			}}
		/>
	)
}

const components: TLComponents = {
	InFrontOfTheCanvas: Fog,
}

export default function BasicExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example" components={components} />
		</div>
	)
}
```

--------

# Snowstorm

Category: Use cases

Keywords: snowstorm, front

Show a visual effect in front of the canvas.

This example shows how you can display a visual effect (a snowstorm) in front of the canvas.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import { SnowStorm } from './SnowStorm'
import './snowstorm.css'

export default function BasicExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example">
				<SnowStorm />
			</Tldraw>
		</div>
	)
}
```

## SnowStorm.tsx

```tsx
import { useEffect, useRef } from 'react'
import { Vec, useEditor, usePrefersReducedMotion } from 'tldraw'

const MAX_GUST_SPEED = 2
const GUST_ROTATION_DURATION = 30_000

const MAX_PIXELS_SCROLL_EFFECT = 18
const MAX_SCROLL_SPEED = 2

const MIN_POINTER_DISTANCE_SQUARED = 10_000
const SNOWFLAKE_VELOCITY_DECAY = 0.82

interface Snowflake {
	element: HTMLElement
	x: number
	y: number
	vx: number
	vy: number
	pvx: number
	pvy: number
	size: number
}

function rnd(min: number, max: number): number {
	return Math.random() * (max - min) + min
}

class Snowstorm {
	private flakes: Snowflake[] = []
	private active: boolean = false
	private container: HTMLElement
	private width: number
	private height: number

	windX = 0
	windY = 0

	baseWindX = 0

	// Configuration options
	private readonly config = {
		flakesMax: 128,
		flakeSizeMin: 2,
		flakeSizeMax: 5,
		flakeSpeedMinY: 1,
		flakeSpeedMaxY: 3,
		flakeSpeedX: 2,
	}

	constructor(container: HTMLElement = document.body) {
		this.container = container
		this.width = container.clientWidth
		this.height = container.clientHeight
	}

	private createSnowflake(): Snowflake {
		const element = document.createElement('div')
		element.classList.add('snowflake')
		this.container.appendChild(element)

		return {
			element,
			x: 0,
			y: 0,
			vx: 0,
			vy: 0,
			pvx: 0,
			pvy: 0,
			size: 1,
		}
	}

	configureSnowflake(flake: Snowflake) {
		const size = rnd(this.config.flakeSizeMin, this.config.flakeSizeMax)
		flake.x = rnd(0, this.width)
		flake.y = rnd(-this.height, 0)
		flake.vx = rnd(-this.config.flakeSpeedX, this.config.flakeSpeedX)
		flake.vy = rnd(this.config.flakeSpeedMinY, this.config.flakeSpeedMaxY)
		flake.element.style.width = `${size}px`
		flake.element.style.height = `${size}px`
		flake.element.style.opacity = rnd(0.5, 1).toString()
	}

	// Main render loop
	render(screenPoint: Vec, pointerVelocity: Vec, time: number) {
		if (!this.active) return

		const q = Math.sin(time / GUST_ROTATION_DURATION)

		// make wind gradually cycle between 0 and 10, maybe a bit randomly, like gusts of wind
		this.baseWindX = q * MAX_GUST_SPEED

		const pointerLen = pointerVelocity.len2()

		for (const flake of this.flakes) {
			const dist2 = Vec.Dist2(screenPoint, new Vec(flake.x, flake.y))

			// if the pointer is moving quickly, give nearby snowflakes a little boost based on the pointer velocity
			if (dist2 < MIN_POINTER_DISTANCE_SQUARED) {
				if (pointerLen > 1) {
					flake.pvx = pointerVelocity.x
					flake.pvy = pointerVelocity.y < 0 ? pointerVelocity.y / 2 : pointerVelocity.y // don't push up as easily
				}
			} else {
				// otherwise, declay down other snowflakes that have been boosted
				if (flake.pvx !== 0) {
					flake.pvx *= SNOWFLAKE_VELOCITY_DECAY
					if (Math.abs(flake.pvx) < 0.01) {
						flake.pvx = 0
					}

					if (flake.pvy !== 0) {
						flake.pvy *= SNOWFLAKE_VELOCITY_DECAY
						if (Math.abs(flake.pvy) < 0.01) {
							flake.pvy = 0
						}
					}
				}
			}

			// Move the flake based on the wind, the base wind, the pointer velocity, and some random wobble
			flake.x += flake.vx + this.windX + this.baseWindX + flake.pvx
			flake.y += flake.vy + this.windY + flake.pvy

			// Wrap the snowflakes around the screen horizontally
			if (flake.x < 0) {
				flake.x += this.width
				flake.pvx = 0
			} else if (flake.x > this.width) {
				flake.x -= this.width
				flake.pvx = 0
			}

			// Wrap the snowflakes around the screen vertically
			if (flake.y < 0) {
				flake.y += this.height
				flake.pvy = 0
			} else if (flake.y > this.height) {
				flake.y -= this.height
				flake.pvy = 0
			}

			flake.element.style.transform = `translate(${flake.x}px, ${flake.y}px)`
		}
	}

	resize() {
		this.width = this.container.clientWidth
		this.height = this.container.clientHeight
	}

	start() {
		this.active = true
		while (this.flakes.length < this.config.flakesMax) {
			const flake = this.createSnowflake()
			this.configureSnowflake(flake)
			this.flakes.push(flake)
		}
		window.addEventListener('resize', this.resize)
	}

	stop() {
		this.active = false
		for (const flake of this.flakes) {
			this.container.removeChild(flake.element)
		}
		this.flakes = []
	}

	dispose() {
		this.stop()
		window.removeEventListener('resize', this.resize)
	}
}

export function SnowStorm() {
	const editor = useEditor()
	const rElm = useRef<HTMLDivElement>(null)
	const prefersReducedMotion = usePrefersReducedMotion()

	useEffect(() => {
		if (prefersReducedMotion) return
		if (!rElm.current) return
		const snowstorm = new Snowstorm(rElm.current)
		const velocity = new Vec(0, 0)
		const camera = Vec.From(editor.getCamera())

		const start = Date.now()

		function updateOnTick() {
			const time = Date.now() - start

			const newCamera = editor.getCamera()

			// Apply camera movement effect only when zoom isn't changing
			if (newCamera.z === camera.z) {
				const dx = (newCamera.x - camera.x) * camera.z
				const dy = (newCamera.y - camera.y) * camera.z

				// add the camera movement to the velocity
				velocity.addXY(
					Math.min(dx / MAX_PIXELS_SCROLL_EFFECT, MAX_SCROLL_SPEED),
					Math.min(dy / MAX_PIXELS_SCROLL_EFFECT, MAX_SCROLL_SPEED)
				)

				// decay velocity
				velocity.mul(SNOWFLAKE_VELOCITY_DECAY)

				// stop the snowflakes from moving if the camera is not moving
				if (velocity.len2() < 1) {
					velocity.x = 0
					velocity.y = 0
				}

				snowstorm.windX = velocity.x
				snowstorm.windY = velocity.y
			}

			camera.setTo(newCamera)
			snowstorm.render(editor.inputs.currentScreenPoint, editor.inputs.pointerVelocity, time)
		}

		snowstorm.start()
		editor.on('tick', updateOnTick)

		return () => {
			editor.off('tick', updateOnTick)
			snowstorm.dispose()
		}
	}, [editor, prefersReducedMotion])

	return <div ref={rElm} className="snowstorm" />
}
```

## snowstorm.css

```css
.snowflake {
	position: absolute;
	background-color: #ccc;
	border-radius: 100%;
	pointer-events: none;
}

.snowstorm {
	position: absolute;
	width: 100%;
	height: 100%;
	pointer-events: none;
}
```