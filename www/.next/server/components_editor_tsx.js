/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "components_editor_tsx";
exports.ids = ["components_editor_tsx"];
exports.modules = {

/***/ "./components/editor.tsx":
/*!*******************************!*\
  !*** ./components/editor.tsx ***!
  \*******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Editor; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _tldraw_tldraw__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tldraw/tldraw */ \"../packages/tldraw/dist/index.js\");\n/* harmony import */ var _tldraw_tldraw__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_tldraw_tldraw__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _hooks_usePersistence__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../hooks/usePersistence */ \"./hooks/usePersistence.tsx\");\n\nvar _jsxFileName = \"/Users/steve/Developer/Github/tldraw/www/components/editor.tsx\";\n\n\n\n\nconst initialDoc = {\n  id: 'doc',\n  pages: {\n    page1: {\n      id: 'page1',\n      shapes: {\n        rect1: {\n          id: 'rect1',\n          parentId: 'page1',\n          name: 'Rectangle',\n          childIndex: 1,\n          type: _tldraw_tldraw__WEBPACK_IMPORTED_MODULE_2__.TLDrawShapeType.Rectangle,\n          point: [32, 32],\n          size: [100, 100],\n          style: {\n            dash: _tldraw_tldraw__WEBPACK_IMPORTED_MODULE_2__.DashStyle.Draw,\n            size: _tldraw_tldraw__WEBPACK_IMPORTED_MODULE_2__.SizeStyle.Medium,\n            color: _tldraw_tldraw__WEBPACK_IMPORTED_MODULE_2__.ColorStyle.Blue\n          }\n        },\n        ellipse1: {\n          id: 'ellipse1',\n          parentId: 'page1',\n          name: 'Ellipse',\n          childIndex: 2,\n          type: _tldraw_tldraw__WEBPACK_IMPORTED_MODULE_2__.TLDrawShapeType.Ellipse,\n          point: [132, 132],\n          radius: [50, 50],\n          style: {\n            dash: _tldraw_tldraw__WEBPACK_IMPORTED_MODULE_2__.DashStyle.Draw,\n            size: _tldraw_tldraw__WEBPACK_IMPORTED_MODULE_2__.SizeStyle.Medium,\n            color: _tldraw_tldraw__WEBPACK_IMPORTED_MODULE_2__.ColorStyle.Cyan\n          }\n        },\n        draw1: {\n          id: 'draw1',\n          parentId: 'page1',\n          name: 'Draw',\n          childIndex: 3,\n          type: _tldraw_tldraw__WEBPACK_IMPORTED_MODULE_2__.TLDrawShapeType.Draw,\n          point: [232, 232],\n          points: [[50, 0], [100, 100], [0, 100], [50, 0], [100, 100], [0, 100], [50, 0], [56, 5]],\n          style: {\n            dash: _tldraw_tldraw__WEBPACK_IMPORTED_MODULE_2__.DashStyle.Draw,\n            size: _tldraw_tldraw__WEBPACK_IMPORTED_MODULE_2__.SizeStyle.Medium,\n            color: _tldraw_tldraw__WEBPACK_IMPORTED_MODULE_2__.ColorStyle.Green\n          }\n        }\n      },\n      bindings: {}\n    }\n  },\n  pageStates: {\n    page1: {\n      id: 'page1',\n      selectedIds: [],\n      currentParentId: 'page1',\n      camera: {\n        point: [0, 0],\n        zoom: 1\n      }\n    }\n  }\n};\nfunction Editor() {\n  const {\n    value,\n    setValue,\n    status\n  } = (0,_hooks_usePersistence__WEBPACK_IMPORTED_MODULE_3__.usePersistence)('doc', initialDoc);\n  const handleChange = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((tlstate, reason) => {\n    if (reason.startsWith('session')) {\n      return;\n    }\n\n    setValue(tlstate.document);\n  }, [setValue]);\n\n  if (status === 'loading' || value === null) {\n    return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 95,\n      columnNumber: 12\n    }, this);\n  }\n\n  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_tldraw_tldraw__WEBPACK_IMPORTED_MODULE_2__.TLDraw, {\n    document: value,\n    onChange: handleChange\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 98,\n    columnNumber: 10\n  }, this);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdGxkcmF3L3d3dy8uL2NvbXBvbmVudHMvZWRpdG9yLnRzeD84NWFkIl0sIm5hbWVzIjpbImluaXRpYWxEb2MiLCJpZCIsInBhZ2VzIiwicGFnZTEiLCJzaGFwZXMiLCJyZWN0MSIsInBhcmVudElkIiwibmFtZSIsImNoaWxkSW5kZXgiLCJ0eXBlIiwiVExEcmF3U2hhcGVUeXBlIiwicG9pbnQiLCJzaXplIiwic3R5bGUiLCJkYXNoIiwiRGFzaFN0eWxlIiwiU2l6ZVN0eWxlIiwiY29sb3IiLCJDb2xvclN0eWxlIiwiQmx1ZSIsImVsbGlwc2UxIiwicmFkaXVzIiwiQ3lhbiIsImRyYXcxIiwicG9pbnRzIiwiR3JlZW4iLCJiaW5kaW5ncyIsInBhZ2VTdGF0ZXMiLCJzZWxlY3RlZElkcyIsImN1cnJlbnRQYXJlbnRJZCIsImNhbWVyYSIsInpvb20iLCJFZGl0b3IiLCJ2YWx1ZSIsInNldFZhbHVlIiwic3RhdHVzIiwidXNlUGVyc2lzdGVuY2UiLCJoYW5kbGVDaGFuZ2UiLCJSZWFjdCIsInRsc3RhdGUiLCJyZWFzb24iLCJzdGFydHNXaXRoIiwiZG9jdW1lbnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBLE1BQU1BLFVBQTBCLEdBQUc7QUFDakNDLElBQUUsRUFBRSxLQUQ2QjtBQUVqQ0MsT0FBSyxFQUFFO0FBQ0xDLFNBQUssRUFBRTtBQUNMRixRQUFFLEVBQUUsT0FEQztBQUVMRyxZQUFNLEVBQUU7QUFDTkMsYUFBSyxFQUFFO0FBQ0xKLFlBQUUsRUFBRSxPQURDO0FBRUxLLGtCQUFRLEVBQUUsT0FGTDtBQUdMQyxjQUFJLEVBQUUsV0FIRDtBQUlMQyxvQkFBVSxFQUFFLENBSlA7QUFLTEMsY0FBSSxFQUFFQyxxRUFMRDtBQU1MQyxlQUFLLEVBQUUsQ0FBQyxFQUFELEVBQUssRUFBTCxDQU5GO0FBT0xDLGNBQUksRUFBRSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBUEQ7QUFRTEMsZUFBSyxFQUFFO0FBQ0xDLGdCQUFJLEVBQUVDLDBEQUREO0FBRUxILGdCQUFJLEVBQUVJLDREQUZEO0FBR0xDLGlCQUFLLEVBQUVDLDJEQUFlQztBQUhqQjtBQVJGLFNBREQ7QUFlTkMsZ0JBQVEsRUFBRTtBQUNSbkIsWUFBRSxFQUFFLFVBREk7QUFFUkssa0JBQVEsRUFBRSxPQUZGO0FBR1JDLGNBQUksRUFBRSxTQUhFO0FBSVJDLG9CQUFVLEVBQUUsQ0FKSjtBQUtSQyxjQUFJLEVBQUVDLG1FQUxFO0FBTVJDLGVBQUssRUFBRSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBTkM7QUFPUlUsZ0JBQU0sRUFBRSxDQUFDLEVBQUQsRUFBSyxFQUFMLENBUEE7QUFRUlIsZUFBSyxFQUFFO0FBQ0xDLGdCQUFJLEVBQUVDLDBEQUREO0FBRUxILGdCQUFJLEVBQUVJLDREQUZEO0FBR0xDLGlCQUFLLEVBQUVDLDJEQUFlSTtBQUhqQjtBQVJDLFNBZko7QUE2Qk5DLGFBQUssRUFBRTtBQUNMdEIsWUFBRSxFQUFFLE9BREM7QUFFTEssa0JBQVEsRUFBRSxPQUZMO0FBR0xDLGNBQUksRUFBRSxNQUhEO0FBSUxDLG9CQUFVLEVBQUUsQ0FKUDtBQUtMQyxjQUFJLEVBQUVDLGdFQUxEO0FBTUxDLGVBQUssRUFBRSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBTkY7QUFPTGEsZ0JBQU0sRUFBRSxDQUNOLENBQUMsRUFBRCxFQUFLLENBQUwsQ0FETSxFQUVOLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FGTSxFQUdOLENBQUMsQ0FBRCxFQUFJLEdBQUosQ0FITSxFQUlOLENBQUMsRUFBRCxFQUFLLENBQUwsQ0FKTSxFQUtOLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FMTSxFQU1OLENBQUMsQ0FBRCxFQUFJLEdBQUosQ0FOTSxFQU9OLENBQUMsRUFBRCxFQUFLLENBQUwsQ0FQTSxFQVFOLENBQUMsRUFBRCxFQUFLLENBQUwsQ0FSTSxDQVBIO0FBaUJMWCxlQUFLLEVBQUU7QUFDTEMsZ0JBQUksRUFBRUMsMERBREQ7QUFFTEgsZ0JBQUksRUFBRUksNERBRkQ7QUFHTEMsaUJBQUssRUFBRUMsNERBQWdCTztBQUhsQjtBQWpCRjtBQTdCRCxPQUZIO0FBdURMQyxjQUFRLEVBQUU7QUF2REw7QUFERixHQUYwQjtBQTZEakNDLFlBQVUsRUFBRTtBQUNWeEIsU0FBSyxFQUFFO0FBQ0xGLFFBQUUsRUFBRSxPQURDO0FBRUwyQixpQkFBVyxFQUFFLEVBRlI7QUFHTEMscUJBQWUsRUFBRSxPQUhaO0FBSUxDLFlBQU0sRUFBRTtBQUNObkIsYUFBSyxFQUFFLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FERDtBQUVOb0IsWUFBSSxFQUFFO0FBRkE7QUFKSDtBQURHO0FBN0RxQixDQUFuQztBQTBFZSxTQUFTQyxNQUFULEdBQWtCO0FBQy9CLFFBQU07QUFBRUMsU0FBRjtBQUFTQyxZQUFUO0FBQW1CQztBQUFuQixNQUE4QkMscUVBQWMsQ0FBQyxLQUFELEVBQVFwQyxVQUFSLENBQWxEO0FBRUEsUUFBTXFDLFlBQVksR0FBR0MsOENBQUEsQ0FDbkIsQ0FBQ0MsT0FBRCxFQUF1QkMsTUFBdkIsS0FBMEM7QUFDeEMsUUFBSUEsTUFBTSxDQUFDQyxVQUFQLENBQWtCLFNBQWxCLENBQUosRUFBa0M7QUFDaEM7QUFDRDs7QUFFRFAsWUFBUSxDQUFDSyxPQUFPLENBQUNHLFFBQVQsQ0FBUjtBQUNELEdBUGtCLEVBUW5CLENBQUNSLFFBQUQsQ0FSbUIsQ0FBckI7O0FBV0EsTUFBSUMsTUFBTSxLQUFLLFNBQVgsSUFBd0JGLEtBQUssS0FBSyxJQUF0QyxFQUE0QztBQUMxQyx3QkFBTztBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQVA7QUFDRDs7QUFFRCxzQkFBTyw4REFBQyxrREFBRDtBQUFRLFlBQVEsRUFBRUEsS0FBbEI7QUFBeUIsWUFBUSxFQUFFSTtBQUFuQztBQUFBO0FBQUE7QUFBQTtBQUFBLFVBQVA7QUFDRCIsImZpbGUiOiIuL2NvbXBvbmVudHMvZWRpdG9yLnRzeC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgQ29sb3JTdHlsZSwgRGFzaFN0eWxlLCBTaXplU3R5bGUsIFRMRHJhd1NoYXBlVHlwZSwgVExEcmF3U3RhdGUgfSBmcm9tICdAdGxkcmF3L3RsZHJhdydcbmltcG9ydCB7IFRMRHJhdywgVExEcmF3RG9jdW1lbnQgfSBmcm9tICdAdGxkcmF3L3RsZHJhdydcbmltcG9ydCB7IHVzZVBlcnNpc3RlbmNlIH0gZnJvbSAnLi4vaG9va3MvdXNlUGVyc2lzdGVuY2UnXG5cbmNvbnN0IGluaXRpYWxEb2M6IFRMRHJhd0RvY3VtZW50ID0ge1xuICBpZDogJ2RvYycsXG4gIHBhZ2VzOiB7XG4gICAgcGFnZTE6IHtcbiAgICAgIGlkOiAncGFnZTEnLFxuICAgICAgc2hhcGVzOiB7XG4gICAgICAgIHJlY3QxOiB7XG4gICAgICAgICAgaWQ6ICdyZWN0MScsXG4gICAgICAgICAgcGFyZW50SWQ6ICdwYWdlMScsXG4gICAgICAgICAgbmFtZTogJ1JlY3RhbmdsZScsXG4gICAgICAgICAgY2hpbGRJbmRleDogMSxcbiAgICAgICAgICB0eXBlOiBUTERyYXdTaGFwZVR5cGUuUmVjdGFuZ2xlLFxuICAgICAgICAgIHBvaW50OiBbMzIsIDMyXSxcbiAgICAgICAgICBzaXplOiBbMTAwLCAxMDBdLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBkYXNoOiBEYXNoU3R5bGUuRHJhdyxcbiAgICAgICAgICAgIHNpemU6IFNpemVTdHlsZS5NZWRpdW0sXG4gICAgICAgICAgICBjb2xvcjogQ29sb3JTdHlsZS5CbHVlLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGVsbGlwc2UxOiB7XG4gICAgICAgICAgaWQ6ICdlbGxpcHNlMScsXG4gICAgICAgICAgcGFyZW50SWQ6ICdwYWdlMScsXG4gICAgICAgICAgbmFtZTogJ0VsbGlwc2UnLFxuICAgICAgICAgIGNoaWxkSW5kZXg6IDIsXG4gICAgICAgICAgdHlwZTogVExEcmF3U2hhcGVUeXBlLkVsbGlwc2UsXG4gICAgICAgICAgcG9pbnQ6IFsxMzIsIDEzMl0sXG4gICAgICAgICAgcmFkaXVzOiBbNTAsIDUwXSxcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgZGFzaDogRGFzaFN0eWxlLkRyYXcsXG4gICAgICAgICAgICBzaXplOiBTaXplU3R5bGUuTWVkaXVtLFxuICAgICAgICAgICAgY29sb3I6IENvbG9yU3R5bGUuQ3lhbixcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBkcmF3MToge1xuICAgICAgICAgIGlkOiAnZHJhdzEnLFxuICAgICAgICAgIHBhcmVudElkOiAncGFnZTEnLFxuICAgICAgICAgIG5hbWU6ICdEcmF3JyxcbiAgICAgICAgICBjaGlsZEluZGV4OiAzLFxuICAgICAgICAgIHR5cGU6IFRMRHJhd1NoYXBlVHlwZS5EcmF3LFxuICAgICAgICAgIHBvaW50OiBbMjMyLCAyMzJdLFxuICAgICAgICAgIHBvaW50czogW1xuICAgICAgICAgICAgWzUwLCAwXSxcbiAgICAgICAgICAgIFsxMDAsIDEwMF0sXG4gICAgICAgICAgICBbMCwgMTAwXSxcbiAgICAgICAgICAgIFs1MCwgMF0sXG4gICAgICAgICAgICBbMTAwLCAxMDBdLFxuICAgICAgICAgICAgWzAsIDEwMF0sXG4gICAgICAgICAgICBbNTAsIDBdLFxuICAgICAgICAgICAgWzU2LCA1XSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBkYXNoOiBEYXNoU3R5bGUuRHJhdyxcbiAgICAgICAgICAgIHNpemU6IFNpemVTdHlsZS5NZWRpdW0sXG4gICAgICAgICAgICBjb2xvcjogQ29sb3JTdHlsZS5HcmVlbixcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIGJpbmRpbmdzOiB7fSxcbiAgICB9LFxuICB9LFxuICBwYWdlU3RhdGVzOiB7XG4gICAgcGFnZTE6IHtcbiAgICAgIGlkOiAncGFnZTEnLFxuICAgICAgc2VsZWN0ZWRJZHM6IFtdLFxuICAgICAgY3VycmVudFBhcmVudElkOiAncGFnZTEnLFxuICAgICAgY2FtZXJhOiB7XG4gICAgICAgIHBvaW50OiBbMCwgMF0sXG4gICAgICAgIHpvb206IDEsXG4gICAgICB9LFxuICAgIH0sXG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEVkaXRvcigpIHtcbiAgY29uc3QgeyB2YWx1ZSwgc2V0VmFsdWUsIHN0YXR1cyB9ID0gdXNlUGVyc2lzdGVuY2UoJ2RvYycsIGluaXRpYWxEb2MpXG5cbiAgY29uc3QgaGFuZGxlQ2hhbmdlID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKHRsc3RhdGU6IFRMRHJhd1N0YXRlLCByZWFzb246IHN0cmluZykgPT4ge1xuICAgICAgaWYgKHJlYXNvbi5zdGFydHNXaXRoKCdzZXNzaW9uJykpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHNldFZhbHVlKHRsc3RhdGUuZG9jdW1lbnQpXG4gICAgfSxcbiAgICBbc2V0VmFsdWVdXG4gIClcblxuICBpZiAoc3RhdHVzID09PSAnbG9hZGluZycgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gPGRpdiAvPlxuICB9XG5cbiAgcmV0dXJuIDxUTERyYXcgZG9jdW1lbnQ9e3ZhbHVlfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/editor.tsx\n");

/***/ }),

/***/ "./hooks/usePersistence.tsx":
/*!**********************************!*\
  !*** ./hooks/usePersistence.tsx ***!
  \**********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"usePersistence\": function() { return /* binding */ usePersistence; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! idb */ \"idb\");\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(idb__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nfunction getId(id) {\n  return '0.0.0-' + id;\n}\n\n/**\n * Persist a value in indexdb. This hook is designed to be used primarily through\n * its methods, `setValue` and `forceUpdate`. The `setValue` method will update the\n * value in the database, howeever it will NOT cause the hook's component to update.\n * The `forceUpdate` method will cause the component to update with the latest value\n * in the database.\n *\n * ### Example\n *\n *```ts\n * const {status, value, setValue, forceUpdate} = usePersistence()\n *```\n */\nfunction usePersistence(id, doc) {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const [status, setStatus] = react__WEBPACK_IMPORTED_MODULE_0__.useState('loading');\n  const [value, _setValue] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null); // A function that other parts of the program can use to manually update\n  // the state to the latest value in the database.\n\n  const forceUpdate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    _setValue(null);\n\n    setStatus('loading');\n    (0,idb__WEBPACK_IMPORTED_MODULE_1__.openDB)('db', 1).then(db => db.get('documents', id).then(v => {\n      if (!v) throw Error(`Could not find document with id: ${id}`);\n\n      _setValue(v);\n\n      setStatus('ready');\n    }));\n  }, [id]); // A function that other parts of the program can use to manually set the\n  // value in the database.\n\n  const setValue = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(doc => {\n    (0,idb__WEBPACK_IMPORTED_MODULE_1__.openDB)('db', 1).then(db => db.put('documents', doc, id));\n  }, [id]); // Whenever the id or doc changes, save the new value to the database and update\n  // the state.\n\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    async function handleLoad() {\n      const db = await (0,idb__WEBPACK_IMPORTED_MODULE_1__.openDB)('db', 1, {\n        upgrade(db) {\n          db.createObjectStore('documents');\n        }\n\n      });\n      let savedDoc;\n\n      try {\n        const restoredDoc = await db.get('documents', id);\n        if (!restoredDoc) throw Error('No document');\n        savedDoc = restoredDoc;\n      } catch (e) {\n        await db.put('documents', doc, id);\n        savedDoc = doc;\n      }\n\n      _setValue(savedDoc);\n\n      setStatus('ready');\n    }\n\n    handleLoad();\n  }, [id, doc]);\n  return {\n    value,\n    status,\n    setValue,\n    forceUpdate\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdGxkcmF3L3d3dy8uL2hvb2tzL3VzZVBlcnNpc3RlbmNlLnRzeD9hNWVlIl0sIm5hbWVzIjpbImdldElkIiwiaWQiLCJ1c2VQZXJzaXN0ZW5jZSIsImRvYyIsInN0YXR1cyIsInNldFN0YXR1cyIsIlJlYWN0IiwidmFsdWUiLCJfc2V0VmFsdWUiLCJmb3JjZVVwZGF0ZSIsIm9wZW5EQiIsInRoZW4iLCJkYiIsImdldCIsInYiLCJFcnJvciIsInNldFZhbHVlIiwicHV0IiwiaGFuZGxlTG9hZCIsInVwZ3JhZGUiLCJjcmVhdGVPYmplY3RTdG9yZSIsInNhdmVkRG9jIiwicmVzdG9yZWREb2MiLCJlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7O0FBR0EsU0FBU0EsS0FBVCxDQUFlQyxFQUFmLEVBQTJCO0FBQ3pCLFNBQU8sV0FBV0EsRUFBbEI7QUFDRDs7QUFTRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVNDLGNBQVQsQ0FBd0JELEVBQXhCLEVBQW9DRSxHQUFwQyxFQUF5RDtBQUM5RDtBQUNBLFFBQU0sQ0FBQ0MsTUFBRCxFQUFTQyxTQUFULElBQXNCQywyQ0FBQSxDQUFvQyxTQUFwQyxDQUE1QjtBQUNBLFFBQU0sQ0FBQ0MsS0FBRCxFQUFRQyxTQUFSLElBQXFCRiwyQ0FBQSxDQUFzQyxJQUF0QyxDQUEzQixDQUg4RCxDQUs5RDtBQUNBOztBQUNBLFFBQU1HLFdBQVcsR0FBR0gsOENBQUEsQ0FBa0IsTUFBTTtBQUMxQ0UsYUFBUyxDQUFDLElBQUQsQ0FBVDs7QUFDQUgsYUFBUyxDQUFDLFNBQUQsQ0FBVDtBQUVBSywrQ0FBTSxDQUFhLElBQWIsRUFBbUIsQ0FBbkIsQ0FBTixDQUE0QkMsSUFBNUIsQ0FBaUNDLEVBQUUsSUFDakNBLEVBQUUsQ0FBQ0MsR0FBSCxDQUFPLFdBQVAsRUFBb0JaLEVBQXBCLEVBQXdCVSxJQUF4QixDQUE2QkcsQ0FBQyxJQUFJO0FBQ2hDLFVBQUksQ0FBQ0EsQ0FBTCxFQUFRLE1BQU1DLEtBQUssQ0FBRSxvQ0FBbUNkLEVBQUcsRUFBeEMsQ0FBWDs7QUFDUk8sZUFBUyxDQUFDTSxDQUFELENBQVQ7O0FBQ0FULGVBQVMsQ0FBQyxPQUFELENBQVQ7QUFDRCxLQUpELENBREY7QUFPRCxHQVhtQixFQVdqQixDQUFDSixFQUFELENBWGlCLENBQXBCLENBUDhELENBb0I5RDtBQUNBOztBQUNBLFFBQU1lLFFBQVEsR0FBR1YsOENBQUEsQ0FDZEgsR0FBRCxJQUF5QjtBQUN2Qk8sK0NBQU0sQ0FBYSxJQUFiLEVBQW1CLENBQW5CLENBQU4sQ0FBNEJDLElBQTVCLENBQWlDQyxFQUFFLElBQUlBLEVBQUUsQ0FBQ0ssR0FBSCxDQUFPLFdBQVAsRUFBb0JkLEdBQXBCLEVBQXlCRixFQUF6QixDQUF2QztBQUNELEdBSGMsRUFJZixDQUFDQSxFQUFELENBSmUsQ0FBakIsQ0F0QjhELENBNkI5RDtBQUNBOztBQUNBSyw4Q0FBQSxDQUFnQixNQUFNO0FBQ3BCLG1CQUFlWSxVQUFmLEdBQTRCO0FBQzFCLFlBQU1OLEVBQUUsR0FBRyxNQUFNRiwyQ0FBTSxDQUFhLElBQWIsRUFBbUIsQ0FBbkIsRUFBc0I7QUFDM0NTLGVBQU8sQ0FBQ1AsRUFBRCxFQUFLO0FBQ1ZBLFlBQUUsQ0FBQ1EsaUJBQUgsQ0FBcUIsV0FBckI7QUFDRDs7QUFIMEMsT0FBdEIsQ0FBdkI7QUFNQSxVQUFJQyxRQUFKOztBQUVBLFVBQUk7QUFDRixjQUFNQyxXQUFXLEdBQUcsTUFBTVYsRUFBRSxDQUFDQyxHQUFILENBQU8sV0FBUCxFQUFvQlosRUFBcEIsQ0FBMUI7QUFDQSxZQUFJLENBQUNxQixXQUFMLEVBQWtCLE1BQU1QLEtBQUssQ0FBQyxhQUFELENBQVg7QUFDbEJNLGdCQUFRLEdBQUdDLFdBQVg7QUFDRCxPQUpELENBSUUsT0FBT0MsQ0FBUCxFQUFVO0FBQ1YsY0FBTVgsRUFBRSxDQUFDSyxHQUFILENBQU8sV0FBUCxFQUFvQmQsR0FBcEIsRUFBeUJGLEVBQXpCLENBQU47QUFDQW9CLGdCQUFRLEdBQUdsQixHQUFYO0FBQ0Q7O0FBRURLLGVBQVMsQ0FBQ2EsUUFBRCxDQUFUOztBQUNBaEIsZUFBUyxDQUFDLE9BQUQsQ0FBVDtBQUNEOztBQUVEYSxjQUFVO0FBQ1gsR0F4QkQsRUF3QkcsQ0FBQ2pCLEVBQUQsRUFBS0UsR0FBTCxDQXhCSDtBQTBCQSxTQUFPO0FBQUVJLFNBQUY7QUFBU0gsVUFBVDtBQUFpQlksWUFBakI7QUFBMkJQO0FBQTNCLEdBQVA7QUFDRCIsImZpbGUiOiIuL2hvb2tzL3VzZVBlcnNpc3RlbmNlLnRzeC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgb3BlbkRCLCBkZWxldGVEQiwgd3JhcCwgdW53cmFwLCBJREJQRGF0YWJhc2UsIERCU2NoZW1hIH0gZnJvbSAnaWRiJ1xuaW1wb3J0IHsgVExEcmF3RG9jdW1lbnQgfSBmcm9tICdAdGxkcmF3L3RsZHJhdydcblxuZnVuY3Rpb24gZ2V0SWQoaWQ6IHN0cmluZykge1xuICByZXR1cm4gJzAuMC4wLScgKyBpZFxufVxuXG5pbnRlcmZhY2UgVExEYXRhYmFzZSBleHRlbmRzIERCU2NoZW1hIHtcbiAgZG9jdW1lbnRzOiB7XG4gICAga2V5OiBzdHJpbmdcbiAgICB2YWx1ZTogVExEcmF3RG9jdW1lbnRcbiAgfVxufVxuXG4vKipcbiAqIFBlcnNpc3QgYSB2YWx1ZSBpbiBpbmRleGRiLiBUaGlzIGhvb2sgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBwcmltYXJpbHkgdGhyb3VnaFxuICogaXRzIG1ldGhvZHMsIGBzZXRWYWx1ZWAgYW5kIGBmb3JjZVVwZGF0ZWAuIFRoZSBgc2V0VmFsdWVgIG1ldGhvZCB3aWxsIHVwZGF0ZSB0aGVcbiAqIHZhbHVlIGluIHRoZSBkYXRhYmFzZSwgaG93ZWV2ZXIgaXQgd2lsbCBOT1QgY2F1c2UgdGhlIGhvb2sncyBjb21wb25lbnQgdG8gdXBkYXRlLlxuICogVGhlIGBmb3JjZVVwZGF0ZWAgbWV0aG9kIHdpbGwgY2F1c2UgdGhlIGNvbXBvbmVudCB0byB1cGRhdGUgd2l0aCB0aGUgbGF0ZXN0IHZhbHVlXG4gKiBpbiB0aGUgZGF0YWJhc2UuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKmBgYHRzXG4gKiBjb25zdCB7c3RhdHVzLCB2YWx1ZSwgc2V0VmFsdWUsIGZvcmNlVXBkYXRlfSA9IHVzZVBlcnNpc3RlbmNlKClcbiAqYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VQZXJzaXN0ZW5jZShpZDogc3RyaW5nLCBkb2M6IFRMRHJhd0RvY3VtZW50KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgY29uc3QgW3N0YXR1cywgc2V0U3RhdHVzXSA9IFJlYWN0LnVzZVN0YXRlPCdsb2FkaW5nJyB8ICdyZWFkeSc+KCdsb2FkaW5nJylcbiAgY29uc3QgW3ZhbHVlLCBfc2V0VmFsdWVdID0gUmVhY3QudXNlU3RhdGU8VExEcmF3RG9jdW1lbnQgfCBudWxsPihudWxsKVxuXG4gIC8vIEEgZnVuY3Rpb24gdGhhdCBvdGhlciBwYXJ0cyBvZiB0aGUgcHJvZ3JhbSBjYW4gdXNlIHRvIG1hbnVhbGx5IHVwZGF0ZVxuICAvLyB0aGUgc3RhdGUgdG8gdGhlIGxhdGVzdCB2YWx1ZSBpbiB0aGUgZGF0YWJhc2UuXG4gIGNvbnN0IGZvcmNlVXBkYXRlID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIF9zZXRWYWx1ZShudWxsKVxuICAgIHNldFN0YXR1cygnbG9hZGluZycpXG5cbiAgICBvcGVuREI8VExEYXRhYmFzZT4oJ2RiJywgMSkudGhlbihkYiA9PlxuICAgICAgZGIuZ2V0KCdkb2N1bWVudHMnLCBpZCkudGhlbih2ID0+IHtcbiAgICAgICAgaWYgKCF2KSB0aHJvdyBFcnJvcihgQ291bGQgbm90IGZpbmQgZG9jdW1lbnQgd2l0aCBpZDogJHtpZH1gKVxuICAgICAgICBfc2V0VmFsdWUodilcbiAgICAgICAgc2V0U3RhdHVzKCdyZWFkeScpXG4gICAgICB9KVxuICAgIClcbiAgfSwgW2lkXSlcblxuICAvLyBBIGZ1bmN0aW9uIHRoYXQgb3RoZXIgcGFydHMgb2YgdGhlIHByb2dyYW0gY2FuIHVzZSB0byBtYW51YWxseSBzZXQgdGhlXG4gIC8vIHZhbHVlIGluIHRoZSBkYXRhYmFzZS5cbiAgY29uc3Qgc2V0VmFsdWUgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoZG9jOiBUTERyYXdEb2N1bWVudCkgPT4ge1xuICAgICAgb3BlbkRCPFRMRGF0YWJhc2U+KCdkYicsIDEpLnRoZW4oZGIgPT4gZGIucHV0KCdkb2N1bWVudHMnLCBkb2MsIGlkKSlcbiAgICB9LFxuICAgIFtpZF1cbiAgKVxuXG4gIC8vIFdoZW5ldmVyIHRoZSBpZCBvciBkb2MgY2hhbmdlcywgc2F2ZSB0aGUgbmV3IHZhbHVlIHRvIHRoZSBkYXRhYmFzZSBhbmQgdXBkYXRlXG4gIC8vIHRoZSBzdGF0ZS5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBhc3luYyBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgY29uc3QgZGIgPSBhd2FpdCBvcGVuREI8VExEYXRhYmFzZT4oJ2RiJywgMSwge1xuICAgICAgICB1cGdyYWRlKGRiKSB7XG4gICAgICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoJ2RvY3VtZW50cycpXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBsZXQgc2F2ZWREb2M6IFRMRHJhd0RvY3VtZW50XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3RvcmVkRG9jID0gYXdhaXQgZGIuZ2V0KCdkb2N1bWVudHMnLCBpZClcbiAgICAgICAgaWYgKCFyZXN0b3JlZERvYykgdGhyb3cgRXJyb3IoJ05vIGRvY3VtZW50JylcbiAgICAgICAgc2F2ZWREb2MgPSByZXN0b3JlZERvY1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBhd2FpdCBkYi5wdXQoJ2RvY3VtZW50cycsIGRvYywgaWQpXG4gICAgICAgIHNhdmVkRG9jID0gZG9jXG4gICAgICB9XG5cbiAgICAgIF9zZXRWYWx1ZShzYXZlZERvYylcbiAgICAgIHNldFN0YXR1cygncmVhZHknKVxuICAgIH1cblxuICAgIGhhbmRsZUxvYWQoKVxuICB9LCBbaWQsIGRvY10pXG5cbiAgcmV0dXJuIHsgdmFsdWUsIHN0YXR1cywgc2V0VmFsdWUsIGZvcmNlVXBkYXRlIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./hooks/usePersistence.tsx\n");

/***/ }),

/***/ "../packages/core/dist/core.cjs.development.js":
/*!*****************************************************!*\
  !*** ../packages/core/dist/core.cjs.development.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar React = __webpack_require__(/*! react */ \"react\");\nvar reactErrorBoundary = __webpack_require__(/*! react-error-boundary */ \"react-error-boundary\");\nvar deepmerge = _interopDefault(__webpack_require__(/*! deepmerge */ \"deepmerge\"));\nvar reactUseGesture = __webpack_require__(/*! react-use-gesture */ \"react-use-gesture\");\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _taggedTemplateLiteralLoose(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n\n  strings.raw = raw;\n  return strings;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar TLContext = /*#__PURE__*/React.createContext({});\nfunction useTLContext() {\n  var context = React.useContext(TLContext);\n  return context;\n}\n\n(function (TLBoundsEdge) {\n  TLBoundsEdge[\"Top\"] = \"top_edge\";\n  TLBoundsEdge[\"Right\"] = \"right_edge\";\n  TLBoundsEdge[\"Bottom\"] = \"bottom_edge\";\n  TLBoundsEdge[\"Left\"] = \"left_edge\";\n})(exports.TLBoundsEdge || (exports.TLBoundsEdge = {}));\n\n(function (TLBoundsCorner) {\n  TLBoundsCorner[\"TopLeft\"] = \"top_left_corner\";\n  TLBoundsCorner[\"TopRight\"] = \"top_right_corner\";\n  TLBoundsCorner[\"BottomRight\"] = \"bottom_right_corner\";\n  TLBoundsCorner[\"BottomLeft\"] = \"bottom_left_corner\";\n})(exports.TLBoundsCorner || (exports.TLBoundsCorner = {}));\n/* -------------------------------------------------- */\n\n/*                   Shape Utility                    */\n\n/* -------------------------------------------------- */\n\n\nvar TLShapeUtil = /*#__PURE__*/function () {\n  function TLShapeUtil() {\n    this.boundsCache = new WeakMap();\n    this.isEditableText = false;\n    this.isAspectRatioLocked = false;\n    this.canEdit = false;\n  }\n\n  var _proto = TLShapeUtil.prototype;\n\n  _proto.transformSingle = function transformSingle(shape, bounds, info) {\n    return this.transform(shape, bounds, info);\n  };\n\n  _proto.shouldRender = function shouldRender(_prev, _next) {\n    return true;\n  };\n\n  _proto.shouldDelete = function shouldDelete(_shape) {\n    return false;\n  };\n\n  _proto.getCenter = function getCenter(shape) {\n    var bounds = this.getBounds(shape);\n    return [bounds.width / 2, bounds.height / 2];\n  };\n\n  _proto.create = function create(props) {\n    return _extends({}, this.defaultProps, props);\n  };\n\n  _proto.mutate = function mutate(shape, props) {\n    return _extends({}, shape, props);\n  };\n\n  _proto.updateChildren = function updateChildren(_shape, _children) {\n    return;\n  };\n\n  _proto.onChildrenChange = function onChildrenChange(_shape, _children) {\n    return;\n  };\n\n  _proto.onBindingChange = function onBindingChange(_shape, _binding, _target, _targetBounds) {\n    return;\n  };\n\n  _proto.onHandleChange = function onHandleChange(_shape, _handle, _info) {\n    return;\n  };\n\n  _proto.onRightPointHandle = function onRightPointHandle(_shape, _handle, _info) {\n    return;\n  };\n\n  _proto.onDoubleClickHandle = function onDoubleClickHandle(_shape, _handle, _info) {\n    return;\n  };\n\n  _proto.onSessionComplete = function onSessionComplete(_shape) {\n    return;\n  };\n\n  _proto.onBoundsReset = function onBoundsReset(_shape) {\n    return;\n  };\n\n  return TLShapeUtil;\n}();\n\n// A big collection of vector utilities. Collected into a class to improve logging / packaging.\n\n/* ----------------- Start Copy Here ---------------- */\nvar Vec = /*#__PURE__*/function () {\n  function Vec() {}\n\n  Vec.clamp = function clamp(n, min, max) {\n    return Math.max(min, typeof max !== 'undefined' ? Math.min(n, max) : n);\n  }\n  /**\r\n   * Negate a vector.\r\n   * @param A\r\n   */\n  ;\n\n  return Vec;\n}();\n\nVec.neg = function (A) {\n  return [-A[0], -A[1]];\n};\n\nVec.add = function (A, B) {\n  return [A[0] + B[0], A[1] + B[1]];\n};\n\nVec.addScalar = function (A, n) {\n  return [A[0] + n, A[1] + n];\n};\n\nVec.sub = function (A, B) {\n  return [A[0] - B[0], A[1] - B[1]];\n};\n\nVec.subScalar = function (A, n) {\n  return [A[0] - n, A[1] - n];\n};\n\nVec.vec = function (A, B) {\n  // A, B as vectors get the vector from A to B\n  return [B[0] - A[0], B[1] - A[1]];\n};\n\nVec.mul = function (A, n) {\n  return [A[0] * n, A[1] * n];\n};\n\nVec.mulV = function (A, B) {\n  return [A[0] * B[0], A[1] * B[1]];\n};\n\nVec.div = function (A, n) {\n  return [A[0] / n, A[1] / n];\n};\n\nVec.divV = function (A, B) {\n  return [A[0] / B[0], A[1] / B[1]];\n};\n\nVec.per = function (A) {\n  return [A[1], -A[0]];\n};\n\nVec.dpr = function (A, B) {\n  return A[0] * B[0] + A[1] * B[1];\n};\n\nVec.cpr = function (A, B) {\n  return A[0] * B[1] - B[0] * A[1];\n};\n\nVec.len2 = function (A) {\n  return A[0] * A[0] + A[1] * A[1];\n};\n\nVec.len = function (A) {\n  return Math.hypot(A[0], A[1]);\n};\n\nVec.pry = function (A, B) {\n  return Vec.dpr(A, B) / Vec.len(B);\n};\n\nVec.uni = function (A) {\n  return Vec.div(A, Vec.len(A));\n};\n\nVec.normalize = function (A) {\n  return Vec.uni(A);\n};\n\nVec.tangent = function (A, B) {\n  return Vec.normalize(Vec.sub(A, B));\n};\n\nVec.dist2 = function (A, B) {\n  return Vec.len2(Vec.sub(A, B));\n};\n\nVec.dist = function (A, B) {\n  return Math.hypot(A[1] - B[1], A[0] - B[0]);\n};\n\nVec.fastDist = function (A, B) {\n  var V = [B[0] - A[0], B[1] - A[1]];\n  var aV = [Math.abs(V[0]), Math.abs(V[1])];\n  var r = 1 / Math.max(aV[0], aV[1]);\n  r = r * (1.29289 - (aV[0] + aV[1]) * r * 0.29289);\n  return [V[0] * r, V[1] * r];\n};\n\nVec.ang = function (A, B) {\n  return Math.atan2(Vec.cpr(A, B), Vec.dpr(A, B));\n};\n\nVec.angle = function (A, B) {\n  return Math.atan2(B[1] - A[1], B[0] - A[0]);\n};\n\nVec.med = function (A, B) {\n  return Vec.mul(Vec.add(A, B), 0.5);\n};\n\nVec.rot = function (A, r) {\n  return [A[0] * Math.cos(r) - A[1] * Math.sin(r), A[0] * Math.sin(r) + A[1] * Math.cos(r)];\n};\n\nVec.rotWith = function (A, C, r) {\n  if (r === 0) return A;\n  var s = Math.sin(r);\n  var c = Math.cos(r);\n  var px = A[0] - C[0];\n  var py = A[1] - C[1];\n  var nx = px * c - py * s;\n  var ny = px * s + py * c;\n  return [nx + C[0], ny + C[1]];\n};\n\nVec.isEqual = function (A, B) {\n  return A[0] === B[0] && A[1] === B[1];\n};\n\nVec.lrp = function (A, B, t) {\n  return Vec.add(A, Vec.mul(Vec.vec(A, B), t));\n};\n\nVec[\"int\"] = function (A, B, from, to, s) {\n  if (s === void 0) {\n    s = 1;\n  }\n\n  var t = (Vec.clamp(from, to) - from) / (to - from);\n  return Vec.add(Vec.mul(A, 1 - t), Vec.mul(B, s));\n};\n\nVec.ang3 = function (p1, pc, p2) {\n  // this,\n  var v1 = Vec.vec(pc, p1);\n  var v2 = Vec.vec(pc, p2);\n  return Vec.ang(v1, v2);\n};\n\nVec.abs = function (A) {\n  return [Math.abs(A[0]), Math.abs(A[1])];\n};\n\nVec.rescale = function (a, n) {\n  var l = Vec.len(a);\n  return [n * a[0] / l, n * a[1] / l];\n};\n\nVec.isLeft = function (p1, pc, p2) {\n  //  isLeft: >0 for counterclockwise\n  //          =0 for none (degenerate)\n  //          <0 for clockwise\n  return (pc[0] - p1[0]) * (p2[1] - p1[1]) - (p2[0] - p1[0]) * (pc[1] - p1[1]);\n};\n\nVec.clockwise = function (p1, pc, p2) {\n  return Vec.isLeft(p1, pc, p2) > 0;\n};\n\nVec.round = function (a, d) {\n  if (d === void 0) {\n    d = 5;\n  }\n\n  return a.map(function (v) {\n    return +v.toPrecision(d);\n  });\n};\n\nVec.nearestPointOnLineThroughPoint = function (A, u, P) {\n  return Vec.add(A, Vec.mul(u, Vec.pry(Vec.sub(P, A), u)));\n};\n\nVec.distanceToLineThroughPoint = function (A, u, P) {\n  return Vec.dist(P, Vec.nearestPointOnLineThroughPoint(A, u, P));\n};\n\nVec.nearestPointOnLineSegment = function (A, B, P, clamp) {\n  if (clamp === void 0) {\n    clamp = true;\n  }\n\n  var delta = Vec.sub(B, A);\n  var length = Vec.len(delta);\n  var u = Vec.div(delta, length);\n  var pt = Vec.add(A, Vec.mul(u, Vec.pry(Vec.sub(P, A), u)));\n\n  if (clamp) {\n    var da = Vec.dist(A, pt);\n    var db = Vec.dist(B, pt);\n    if (db < da && da > length) return B;\n    if (da < db && db > length) return A;\n  }\n\n  return pt;\n};\n\nVec.distanceToLineSegment = function (A, B, P, clamp) {\n  if (clamp === void 0) {\n    clamp = true;\n  }\n\n  return Vec.dist(P, Vec.nearestPointOnLineSegment(A, B, P, clamp));\n};\n\nVec.nudge = function (A, B, d) {\n  return Vec.add(A, Vec.mul(Vec.uni(Vec.vec(A, B)), d));\n};\n\nVec.nudgeAtAngle = function (A, a, d) {\n  return [Math.cos(a) * d + A[0], Math.sin(a) * d + A[1]];\n};\n\nVec.toPrecision = function (a, n) {\n  if (n === void 0) {\n    n = 4;\n  }\n\n  return [+a[0].toPrecision(n), +a[1].toPrecision(n)];\n};\n\nVec.pointsBetween = function (a, b, steps) {\n  if (steps === void 0) {\n    steps = 6;\n  }\n\n  return Array.from(Array(steps)).map(function (_, i) {\n    var t = i / steps;\n    return t * t * t;\n  }).map(function (t) {\n    return Vec.round([].concat(Vec.lrp(a, b, t), [(1 - t) / 2]));\n  });\n};\n\n/* eslint-disable @typescript-eslint/ban-ts-comment */\n\n/* eslint-disable no-extend-native */\n\n/**\r\n * String.prototype.replaceAll() polyfill\r\n * https://gomakethings.com/how-to-replace-a-section-of-a-string-with-another-one-with-vanilla-js/\r\n * @author Chris Ferdinandi\r\n * @license MIT\r\n */\nif (!String.prototype.replaceAll) {\n  // @ts-ignore\n  String.prototype.replaceAll = function (str, newStr) {\n    // If a regex pattern\n    if (Object.prototype.toString.call(str).toLowerCase() === '[object regexp]') {\n      return this.replace(str, newStr);\n    } // If a string\n\n\n    return this.replace(new RegExp(str, 'g'), newStr);\n  };\n}\n\nvar Utils = /*#__PURE__*/function () {\n  function Utils() {}\n\n  /* -------------------------------------------------- */\n\n  /*                    Math & Geometry                 */\n\n  /* -------------------------------------------------- */\n  Utils.filterObject = function filterObject(obj, fn) {\n    return Object.fromEntries(Object.entries(obj).filter(fn));\n  };\n\n  Utils.deepMerge = function deepMerge(a, b) {\n    return deepmerge(a, b, {\n      arrayMerge: function arrayMerge(_a, b) {\n        return b;\n      }\n    });\n  }\n  /**\r\n   * Linear interpolation betwen two numbers.\r\n   * @param y1\r\n   * @param y2\r\n   * @param mu\r\n   */\n  ;\n\n  Utils.lerp = function lerp(y1, y2, mu) {\n    mu = Utils.clamp(mu, 0, 1);\n    return y1 * (1 - mu) + y2 * mu;\n  }\n  /**\r\n   * Linear interpolation between two colors.\r\n   *\r\n   * ### Example\r\n   *\r\n   *```ts\r\n   * lerpColor(\"#000000\", \"#0099FF\", .25)\r\n   *```\r\n   */\n  ;\n\n  Utils.lerpColor = function lerpColor(color1, color2, factor) {\n    if (factor === void 0) {\n      factor = 0.5;\n    }\n\n    function h2r(hex) {\n      var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n      return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : null;\n    }\n\n    function r2h(rgb) {\n      return '#' + ((1 << 24) + (rgb[0] << 16) + (rgb[1] << 8) + rgb[2]).toString(16).slice(1);\n    }\n\n    var c1 = h2r(color1);\n    var c2 = h2r(color2);\n    if (!(c1 && c2)) return;\n    var result = c1.slice();\n\n    for (var i = 0; i < 3; i++) {\n      result[i] = Math.round(result[i] + factor * (c2[i] - c1[i]));\n    }\n\n    return r2h(result);\n  }\n  /**\r\n   * Modulate a value between two ranges.\r\n   * @param value\r\n   * @param rangeA from [low, high]\r\n   * @param rangeB to [low, high]\r\n   * @param clamp\r\n   */\n  ;\n\n  Utils.modulate = function modulate(value, rangeA, rangeB, clamp) {\n    if (clamp === void 0) {\n      clamp = false;\n    }\n\n    var fromLow = rangeA[0],\n        fromHigh = rangeA[1];\n    var v0 = rangeB[0],\n        v1 = rangeB[1];\n    var result = v0 + (value - fromLow) / (fromHigh - fromLow) * (v1 - v0);\n    return clamp ? v0 < v1 ? Math.max(Math.min(result, v1), v0) : Math.max(Math.min(result, v0), v1) : result;\n  };\n\n  Utils.clamp = function clamp(n, min, max) {\n    return Math.max(min, typeof max !== 'undefined' ? Math.min(n, max) : n);\n  } // TODO: replace with a string compression algorithm\n  ;\n\n  Utils.compress = function compress(s) {\n    return s;\n  } // TODO: replace with a string decompression algorithm\n  ;\n\n  Utils.decompress = function decompress(s) {\n    return s;\n  }\n  /**\r\n   * Recursively clone an object or array.\r\n   * @param obj\r\n   */\n  ;\n\n  Utils.deepClone = function deepClone(obj) {\n    if (obj === null) return obj;\n\n    if (Array.isArray(obj)) {\n      return [].concat(obj);\n    }\n\n    if (typeof obj === 'object') {\n      var clone = _extends({}, obj);\n\n      Object.keys(clone).forEach(function (key) {\n        return clone[key] = typeof obj[key] === 'object' ? Utils.deepClone(obj[key]) : obj[key];\n      });\n      return clone;\n    }\n\n    return obj;\n  }\n  /**\r\n   * Seeded random number generator, using [xorshift](https://en.wikipedia.org/wiki/Xorshift).\r\n   * The result will always be betweeen -1 and 1.\r\n   *\r\n   * Adapted from [seedrandom](https://github.com/davidbau/seedrandom).\r\n   */\n  ;\n\n  Utils.rng = function rng(seed) {\n    if (seed === void 0) {\n      seed = '';\n    }\n\n    var x = 0;\n    var y = 0;\n    var z = 0;\n    var w = 0;\n\n    function next() {\n      var t = x ^ x << 11;\n      x = y;\n      y = z;\n      z = w;\n      w ^= (w >>> 19 ^ t ^ t >>> 8) >>> 0;\n      return w / 0x100000000;\n    }\n\n    for (var k = 0; k < seed.length + 64; k++) {\n      x ^= seed.charCodeAt(k) | 0;\n      next();\n    }\n\n    return next;\n  }\n  /* ---------------------- Boxes --------------------- */\n  ;\n\n  Utils.getRectangleSides = function getRectangleSides(point, size) {\n    var tl = point;\n    var tr = Vec.add(point, [size[0], 0]);\n    var br = Vec.add(point, size);\n    var bl = Vec.add(point, [0, size[1]]);\n    return [['top', [tl, tr]], ['right', [tr, br]], ['bottom', [br, bl]], ['left', [bl, tl]]];\n  };\n\n  Utils.getBoundsSides = function getBoundsSides(bounds) {\n    return this.getRectangleSides([bounds.minX, bounds.minY], [bounds.width, bounds.height]);\n  };\n\n  Utils.shallowEqual = function shallowEqual(objA, objB) {\n    if (objA === objB) return true;\n    if (!objA || !objB) return false;\n    var aKeys = Object.keys(objA);\n    var bKeys = Object.keys(objB);\n    var len = aKeys.length;\n    if (bKeys.length !== len) return false;\n\n    for (var i = 0; i < len; i++) {\n      var key = aKeys[i];\n\n      if (objA[key] !== objB[key] || !Object.prototype.hasOwnProperty.call(objB, key)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /* --------------- Circles and Angles --------------- */\n\n  /**\r\n   * Get the outer of between a circle and a point.\r\n   * @param C The circle's center.\r\n   * @param r The circle's radius.\r\n   * @param P The point.\r\n   * @param side\r\n   */\n  ;\n\n  Utils.getCircleTangentToPoint = function getCircleTangentToPoint(C, r, P, side) {\n    var B = Vec.lrp(C, P, 0.5);\n    var r1 = Vec.dist(C, B);\n    var delta = Vec.sub(B, C);\n    var d = Vec.len(delta);\n\n    if (!(d <= r + r1 && d >= Math.abs(r - r1))) {\n      return null;\n    }\n\n    var a = (r * r - r1 * r1 + d * d) / (2.0 * d);\n    var n = 1 / d;\n    var p = Vec.add(C, Vec.mul(delta, a * n));\n    var h = Math.sqrt(r * r - a * a);\n    var k = Vec.mul(Vec.per(delta), h * n);\n    return side === 0 ? Vec.add(p, k) : Vec.sub(p, k);\n  }\n  /**\r\n   * Get outer tangents of two circles.\r\n   * @param x0\r\n   * @param y0\r\n   * @param r0\r\n   * @param x1\r\n   * @param y1\r\n   * @param r1\r\n   * @returns [lx0, ly0, lx1, ly1, rx0, ry0, rx1, ry1]\r\n   */\n  ;\n\n  Utils.getOuterTangentsOfCircles = function getOuterTangentsOfCircles(C0, r0, C1, r1) {\n    var a0 = Vec.angle(C0, C1);\n    var d = Vec.dist(C0, C1); // Circles are overlapping, no tangents\n\n    if (d < Math.abs(r1 - r0)) {\n      return null;\n    }\n\n    var a1 = Math.acos((r0 - r1) / d);\n    var t0 = a0 + a1;\n    var t1 = a0 - a1;\n    return [[C0[0] + r0 * Math.cos(t1), C0[1] + r0 * Math.sin(t1)], [C1[0] + r1 * Math.cos(t1), C1[1] + r1 * Math.sin(t1)], [C0[0] + r0 * Math.cos(t0), C0[1] + r0 * Math.sin(t0)], [C1[0] + r1 * Math.cos(t0), C1[1] + r1 * Math.sin(t0)]];\n  }\n  /**\r\n   * Get the closest point on the perimeter of a circle to a given point.\r\n   * @param C The circle's center.\r\n   * @param r The circle's radius.\r\n   * @param P The point.\r\n   */\n  ;\n\n  Utils.getClosestPointOnCircle = function getClosestPointOnCircle(C, r, P) {\n    var v = Vec.sub(C, P);\n    return Vec.sub(C, Vec.mul(Vec.div(v, Vec.len(v)), r));\n  }\n  /**\r\n   * Get a circle from three points.\r\n   * @param A\r\n   * @param B\r\n   * @param C\r\n   * @returns [x, y, r]\r\n   */\n  ;\n\n  Utils.circleFromThreePoints = function circleFromThreePoints(A, B, C) {\n    var x1 = A[0],\n        y1 = A[1];\n    var x2 = B[0],\n        y2 = B[1];\n    var x3 = C[0],\n        y3 = C[1];\n    var a = x1 * (y2 - y3) - y1 * (x2 - x3) + x2 * y3 - x3 * y2;\n    var b = (x1 * x1 + y1 * y1) * (y3 - y2) + (x2 * x2 + y2 * y2) * (y1 - y3) + (x3 * x3 + y3 * y3) * (y2 - y1);\n    var c = (x1 * x1 + y1 * y1) * (x2 - x3) + (x2 * x2 + y2 * y2) * (x3 - x1) + (x3 * x3 + y3 * y3) * (x1 - x2);\n    var x = -b / (2 * a);\n    var y = -c / (2 * a);\n    return [x, y, Math.hypot(x - x1, y - y1)];\n  }\n  /**\r\n   * Find the approximate perimeter of an ellipse.\r\n   * @param rx\r\n   * @param ry\r\n   */\n  ;\n\n  Utils.perimeterOfEllipse = function perimeterOfEllipse(rx, ry) {\n    var h = Math.pow(rx - ry, 2) / Math.pow(rx + ry, 2);\n    var p = Math.PI * (rx + ry) * (1 + 3 * h / (10 + Math.sqrt(4 - 3 * h)));\n    return p;\n  }\n  /**\r\n   * Get the short angle distance between two angles.\r\n   * @param a0\r\n   * @param a1\r\n   */\n  ;\n\n  Utils.shortAngleDist = function shortAngleDist(a0, a1) {\n    var max = Math.PI * 2;\n    var da = (a1 - a0) % max;\n    return 2 * da % max - da;\n  }\n  /**\r\n   * Get the long angle distance between two angles.\r\n   * @param a0\r\n   * @param a1\r\n   */\n  ;\n\n  Utils.longAngleDist = function longAngleDist(a0, a1) {\n    return Math.PI * 2 - Utils.shortAngleDist(a0, a1);\n  }\n  /**\r\n   * Interpolate an angle between two angles.\r\n   * @param a0\r\n   * @param a1\r\n   * @param t\r\n   */\n  ;\n\n  Utils.lerpAngles = function lerpAngles(a0, a1, t) {\n    return a0 + Utils.shortAngleDist(a0, a1) * t;\n  }\n  /**\r\n   * Get the short distance between two angles.\r\n   * @param a0\r\n   * @param a1\r\n   */\n  ;\n\n  Utils.angleDelta = function angleDelta(a0, a1) {\n    return Utils.shortAngleDist(a0, a1);\n  }\n  /**\r\n   * Get the \"sweep\" or short distance between two points on a circle's perimeter.\r\n   * @param C\r\n   * @param A\r\n   * @param B\r\n   */\n  ;\n\n  Utils.getSweep = function getSweep(C, A, B) {\n    return Utils.angleDelta(Vec.angle(C, A), Vec.angle(C, B));\n  }\n  /**\r\n   * Rotate a point around a center.\r\n   * @param x The x-axis coordinate of the point.\r\n   * @param y The y-axis coordinate of the point.\r\n   * @param cx The x-axis coordinate of the point to rotate round.\r\n   * @param cy The y-axis coordinate of the point to rotate round.\r\n   * @param angle The distance (in radians) to rotate.\r\n   */\n  ;\n\n  Utils.rotatePoint = function rotatePoint(A, B, angle) {\n    var s = Math.sin(angle);\n    var c = Math.cos(angle);\n    var px = A[0] - B[0];\n    var py = A[1] - B[1];\n    var nx = px * c - py * s;\n    var ny = px * s + py * c;\n    return [nx + B[0], ny + B[1]];\n  }\n  /**\r\n   * Clamp radians within 0 and 2PI\r\n   * @param r\r\n   */\n  ;\n\n  Utils.clampRadians = function clampRadians(r) {\n    return (Math.PI * 2 + r) % (Math.PI * 2);\n  }\n  /**\r\n   * Clamp rotation to even segments.\r\n   * @param r\r\n   * @param segments\r\n   */\n  ;\n\n  Utils.clampToRotationToSegments = function clampToRotationToSegments(r, segments) {\n    var seg = Math.PI * 2 / segments;\n    return Math.floor((Utils.clampRadians(r) + seg / 2) / seg) * seg;\n  }\n  /**\r\n   * Is angle c between angles a and b?\r\n   * @param a\r\n   * @param b\r\n   * @param c\r\n   */\n  ;\n\n  Utils.isAngleBetween = function isAngleBetween(a, b, c) {\n    if (c === a || c === b) return true;\n    var PI2 = Math.PI * 2;\n    var AB = (b - a + PI2) % PI2;\n    var AC = (c - a + PI2) % PI2;\n    return AB <= Math.PI !== AC > AB;\n  }\n  /**\r\n   * Convert degrees to radians.\r\n   * @param d\r\n   */\n  ;\n\n  Utils.degreesToRadians = function degreesToRadians(d) {\n    return d * Math.PI / 180;\n  }\n  /**\r\n   * Convert radians to degrees.\r\n   * @param r\r\n   */\n  ;\n\n  Utils.radiansToDegrees = function radiansToDegrees(r) {\n    return r * 180 / Math.PI;\n  }\n  /**\r\n   * Get the length of an arc between two points on a circle's perimeter.\r\n   * @param C\r\n   * @param r\r\n   * @param A\r\n   * @param B\r\n   */\n  ;\n\n  Utils.getArcLength = function getArcLength(C, r, A, B) {\n    var sweep = Utils.getSweep(C, A, B);\n    return r * (2 * Math.PI) * (sweep / (2 * Math.PI));\n  }\n  /**\r\n   * Get a dash offset for an arc, based on its length.\r\n   * @param C\r\n   * @param r\r\n   * @param A\r\n   * @param B\r\n   * @param step\r\n   */\n  ;\n\n  Utils.getArcDashOffset = function getArcDashOffset(C, r, A, B, step) {\n    var del0 = Utils.getSweep(C, A, B);\n    var len0 = Utils.getArcLength(C, r, A, B);\n    var off0 = del0 < 0 ? len0 : 2 * Math.PI * C[2] - len0;\n    return -off0 / 2 + step;\n  }\n  /**\r\n   * Get a dash offset for an ellipse, based on its length.\r\n   * @param A\r\n   * @param step\r\n   */\n  ;\n\n  Utils.getEllipseDashOffset = function getEllipseDashOffset(A, step) {\n    var c = 2 * Math.PI * A[2];\n    return -c / 2 + -step;\n  }\n  /* --------------- Curves and Splines --------------- */\n\n  /**\r\n   * Get bezier curve segments that pass through an array of points.\r\n   * @param points\r\n   * @param tension\r\n   */\n  ;\n\n  Utils.getTLBezierCurveSegments = function getTLBezierCurveSegments(points, tension) {\n    if (tension === void 0) {\n      tension = 0.4;\n    }\n\n    var len = points.length;\n    var cpoints = [].concat(points);\n\n    if (len < 2) {\n      throw Error('Curve must have at least two points.');\n    }\n\n    for (var i = 1; i < len - 1; i++) {\n      var p0 = points[i - 1];\n      var p1 = points[i];\n      var p2 = points[i + 1];\n      var pdx = p2[0] - p0[0];\n      var pdy = p2[1] - p0[1];\n      var pd = Math.hypot(pdx, pdy);\n      var nx = pdx / pd; // normalized x\n\n      var ny = pdy / pd; // normalized y\n\n      var dp = Math.hypot(p1[0] - p0[0], p1[1] - p0[1]); // Distance to previous\n\n      var dn = Math.hypot(p1[0] - p2[0], p1[1] - p2[1]); // Distance to next\n\n      cpoints[i] = [// tangent start\n      p1[0] - nx * dp * tension, p1[1] - ny * dp * tension, // tangent end\n      p1[0] + nx * dn * tension, p1[1] + ny * dn * tension, // normal\n      nx, ny];\n    } // TODO: Reflect the nearest control points, not average them\n\n\n    var d0 = Math.hypot(points[0][0] + cpoints[1][0]);\n    cpoints[0][2] = (points[0][0] + cpoints[1][0]) / 2;\n    cpoints[0][3] = (points[0][1] + cpoints[1][1]) / 2;\n    cpoints[0][4] = (cpoints[1][0] - points[0][0]) / d0;\n    cpoints[0][5] = (cpoints[1][1] - points[0][1]) / d0;\n    var d1 = Math.hypot(points[len - 1][1] + cpoints[len - 1][1]);\n    cpoints[len - 1][0] = (points[len - 1][0] + cpoints[len - 2][2]) / 2;\n    cpoints[len - 1][1] = (points[len - 1][1] + cpoints[len - 2][3]) / 2;\n    cpoints[len - 1][4] = (cpoints[len - 2][2] - points[len - 1][0]) / -d1;\n    cpoints[len - 1][5] = (cpoints[len - 2][3] - points[len - 1][1]) / -d1;\n    var results = [];\n\n    for (var _i = 1; _i < cpoints.length; _i++) {\n      results.push({\n        start: points[_i - 1].slice(0, 2),\n        tangentStart: cpoints[_i - 1].slice(2, 4),\n        normalStart: cpoints[_i - 1].slice(4, 6),\n        pressureStart: 2 + ((_i - 1) % 2 === 0 ? 1.5 : 0),\n        end: points[_i].slice(0, 2),\n        tangentEnd: cpoints[_i].slice(0, 2),\n        normalEnd: cpoints[_i].slice(4, 6),\n        pressureEnd: 2 + (_i % 2 === 0 ? 1.5 : 0)\n      });\n    }\n\n    return results;\n  }\n  /**\r\n   * Find a point along a curve segment, via pomax.\r\n   * @param t\r\n   * @param points [cpx1, cpy1, cpx2, cpy2, px, py][]\r\n   */\n  ;\n\n  Utils.computePointOnCurve = function computePointOnCurve(t, points) {\n    // shortcuts\n    if (t === 0) {\n      return points[0];\n    }\n\n    var order = points.length - 1;\n\n    if (t === 1) {\n      return points[order];\n    }\n\n    var mt = 1 - t;\n    var p = points; // constant?\n\n    if (order === 0) {\n      return points[0];\n    } // linear?\n\n\n    if (order === 1) {\n      return [mt * p[0][0] + t * p[1][0], mt * p[0][1] + t * p[1][1]];\n    } // quadratic/cubic curve?\n    // if (order < 4) {\n\n\n    var mt2 = mt * mt;\n    var t2 = t * t;\n    var a;\n    var b;\n    var c;\n    var d = 0;\n\n    if (order === 2) {\n      p = [p[0], p[1], p[2], [0, 0]];\n      a = mt2;\n      b = mt * t * 2;\n      c = t2; // } else if (order === 3) {\n    } else {\n      a = mt2 * mt;\n      b = mt2 * t * 3;\n      c = mt * t2 * 3;\n      d = t * t2;\n    }\n\n    return [a * p[0][0] + b * p[1][0] + c * p[2][0] + d * p[3][0], a * p[0][1] + b * p[1][1] + c * p[2][1] + d * p[3][1]]; // } // higher order curves: use de Casteljau's computation\n  }\n  /**\r\n   * Evaluate a 2d cubic bezier at a point t on the x axis.\r\n   * @param tx\r\n   * @param x1\r\n   * @param y1\r\n   * @param x2\r\n   * @param y2\r\n   */\n  ;\n\n  Utils.cubicBezier = function cubicBezier(tx, x1, y1, x2, y2) {\n    // Inspired by Don Lancaster's two articles\n    // http://www.tinaja.com/glib/cubemath.pdf\n    // http://www.tinaja.com/text/bezmath.html\n    // Set start and end point\n    var x0 = 0;\n    var y0 = 0;\n    var x3 = 1;\n    var y3 = 1; // Convert the coordinates to equation space\n\n    var A = x3 - 3 * x2 + 3 * x1 - x0;\n    var B = 3 * x2 - 6 * x1 + 3 * x0;\n    var C = 3 * x1 - 3 * x0;\n    var D = x0;\n    var E = y3 - 3 * y2 + 3 * y1 - y0;\n    var F = 3 * y2 - 6 * y1 + 3 * y0;\n    var G = 3 * y1 - 3 * y0;\n    var H = y0; // Variables for the loop below\n\n    var iterations = 5;\n    var i;\n    var slope;\n    var x;\n    var t = tx; // Loop through a few times to get a more accurate time value, according to the Newton-Raphson method\n    // http://en.wikipedia.org/wiki/Newton's_method\n\n    for (i = 0; i < iterations; i++) {\n      // The curve's x equation for the current time value\n      x = A * t * t * t + B * t * t + C * t + D; // The slope we want is the inverse of the derivate of x\n\n      slope = 1 / (3 * A * t * t + 2 * B * t + C); // Get the next estimated time value, which will be more accurate than the one before\n\n      t -= (x - tx) * slope;\n      t = t > 1 ? 1 : t < 0 ? 0 : t;\n    } // Find the y value through the curve's y equation, with the now more accurate time value\n\n\n    return Math.abs(E * t * t * t + F * t * t + G * t * H);\n  }\n  /**\r\n   * Get a bezier curve data for a spline that fits an array of points.\r\n   * @param points An array of points formatted as [x, y]\r\n   * @param k Tension\r\n   */\n  ;\n\n  Utils.getSpline = function getSpline(pts, k) {\n    if (k === void 0) {\n      k = 0.5;\n    }\n\n    var p0;\n    var p1 = pts[0],\n        p2 = pts[1],\n        p3 = pts[2];\n    var results = [];\n\n    for (var i = 1, len = pts.length; i < len; i++) {\n      p0 = p1;\n      p1 = p2;\n      p2 = p3;\n      p3 = pts[i + 2] ? pts[i + 2] : p2;\n      results.push({\n        cp1x: p1[0] + (p2[0] - p0[0]) / 6 * k,\n        cp1y: p1[1] + (p2[1] - p0[1]) / 6 * k,\n        cp2x: p2[0] - (p3[0] - p1[0]) / 6 * k,\n        cp2y: p2[1] - (p3[1] - p1[1]) / 6 * k,\n        px: pts[i][0],\n        py: pts[i][1]\n      });\n    }\n\n    return results;\n  }\n  /**\r\n   * Get a bezier curve data for a spline that fits an array of points.\r\n   * @param pts\r\n   * @param tension\r\n   * @param isClosed\r\n   * @param numOfSegments\r\n   */\n  ;\n\n  Utils.getCurvePoints = function getCurvePoints(pts, tension, isClosed, numOfSegments) {\n    if (tension === void 0) {\n      tension = 0.5;\n    }\n\n    if (isClosed === void 0) {\n      isClosed = false;\n    }\n\n    if (numOfSegments === void 0) {\n      numOfSegments = 3;\n    }\n\n    var _pts = [].concat(pts);\n\n    var len = pts.length;\n    var res = []; // results\n\n    var t1x, // tension vectors\n    t2x, t1y, t2y, c1, // cardinal points\n    c2, c3, c4, st, st2, st3; // The algorithm require a previous and next point to the actual point array.\n    // Check if we will draw closed or open curve.\n    // If closed, copy end points to beginning and first points to end\n    // If open, duplicate first points to befinning, end points to end\n\n    if (isClosed) {\n      _pts.unshift(_pts[len - 1]);\n\n      _pts.push(_pts[0]);\n    } else {\n      // copy 1. point and insert at beginning\n      _pts.unshift(_pts[0]);\n\n      _pts.push(_pts[len - 1]); // _pts.push(_pts[len - 1])\n\n    } // For each point, calculate a segment\n\n\n    for (var i = 1; i < _pts.length - 2; i++) {\n      // Calculate points along segment and add to results\n      for (var t = 0; t <= numOfSegments; t++) {\n        // Step\n        st = t / numOfSegments;\n        st2 = Math.pow(st, 2);\n        st3 = Math.pow(st, 3); // Cardinals\n\n        c1 = 2 * st3 - 3 * st2 + 1;\n        c2 = -(2 * st3) + 3 * st2;\n        c3 = st3 - 2 * st2 + st;\n        c4 = st3 - st2; // Tension\n\n        t1x = (_pts[i + 1][0] - _pts[i - 1][0]) * tension;\n        t2x = (_pts[i + 2][0] - _pts[i][0]) * tension;\n        t1y = (_pts[i + 1][1] - _pts[i - 1][1]) * tension;\n        t2y = (_pts[i + 2][1] - _pts[i][1]) * tension; // Control points\n\n        res.push([c1 * _pts[i][0] + c2 * _pts[i + 1][0] + c3 * t1x + c4 * t2x, c1 * _pts[i][1] + c2 * _pts[i + 1][1] + c3 * t1y + c4 * t2y]);\n      }\n    }\n\n    res.push(pts[pts.length - 1]);\n    return res;\n  }\n  /**\r\n   * Simplify a line (using Ramer-Douglas-Peucker algorithm).\r\n   * @param points An array of points as [x, y, ...][]\r\n   * @param tolerance The minimum line distance (also called epsilon).\r\n   * @returns Simplified array as [x, y, ...][]\r\n   */\n  ;\n\n  Utils.simplify = function simplify(points, tolerance) {\n    if (tolerance === void 0) {\n      tolerance = 1;\n    }\n\n    var len = points.length;\n    var a = points[0];\n    var b = points[len - 1];\n    var x1 = a[0],\n        y1 = a[1];\n    var x2 = b[0],\n        y2 = b[1];\n\n    if (len > 2) {\n      var distance = 0;\n      var index = 0;\n      var max = Math.hypot(y2 - y1, x2 - x1);\n\n      for (var i = 1; i < len - 1; i++) {\n        var _points$i = points[i],\n            x0 = _points$i[0],\n            y0 = _points$i[1];\n        var d = Math.abs((y2 - y1) * x0 - (x2 - x1) * y0 + x2 * y1 - y2 * x1) / max;\n        if (distance > d) continue;\n        distance = d;\n        index = i;\n      }\n\n      if (distance > tolerance) {\n        var l0 = Utils.simplify(points.slice(0, index + 1), tolerance);\n        var l1 = Utils.simplify(points.slice(index + 1), tolerance);\n        return l0.concat(l1.slice(1));\n      }\n    }\n\n    return [a, b];\n  }\n  /**\r\n   * Get whether a point is inside of a circle.\r\n   * @param A\r\n   * @param b\r\n   * @returns\r\n   */\n  ;\n\n  Utils.pointInCircle = function pointInCircle(A, C, r) {\n    return Vec.dist(A, C) <= r;\n  }\n  /**\r\n   * Get whether a point is inside of an ellipse.\r\n   * @param point\r\n   * @param center\r\n   * @param rx\r\n   * @param ry\r\n   * @param rotation\r\n   * @returns\r\n   */\n  ;\n\n  Utils.pointInEllipse = function pointInEllipse(A, C, rx, ry, rotation) {\n    if (rotation === void 0) {\n      rotation = 0;\n    }\n\n    rotation = rotation || 0;\n    var cos = Math.cos(rotation);\n    var sin = Math.sin(rotation);\n    var delta = Vec.sub(A, C);\n    var tdx = cos * delta[0] + sin * delta[1];\n    var tdy = sin * delta[0] - cos * delta[1];\n    return tdx * tdx / (rx * rx) + tdy * tdy / (ry * ry) <= 1;\n  }\n  /**\r\n   * Get whether a point is inside of a rectangle.\r\n   * @param point\r\n   * @param size\r\n   */\n  ;\n\n  Utils.pointInRect = function pointInRect(point, size) {\n    return !(point[0] < size[0] || point[0] > point[0] + size[0] || point[1] < size[1] || point[1] > point[1] + size[1]);\n  }\n  /* --------------------- Bounds --------------------- */\n\n  /**\r\n   * Expand a bounding box by a delta.\r\n   *\r\n   * ### Example\r\n   *\r\n   *```ts\r\n   * expandBounds(myBounds, [100, 100])\r\n   *```\r\n   */\n  ;\n\n  Utils.expandBounds = function expandBounds(bounds, delta) {\n    return {\n      minX: bounds.minX - delta,\n      minY: bounds.minY - delta,\n      maxX: bounds.maxX + delta,\n      maxY: bounds.maxY + delta,\n      width: bounds.width + delta * 2,\n      height: bounds.height + delta * 2\n    };\n  }\n  /**\r\n   * Get whether a point is inside of a bounds.\r\n   * @param A\r\n   * @param b\r\n   * @returns\r\n   */\n  ;\n\n  Utils.pointInBounds = function pointInBounds(A, b) {\n    return !(A[0] < b.minX || A[0] > b.maxX || A[1] < b.minY || A[1] > b.maxY);\n  }\n  /**\r\n   * Get whether two bounds collide.\r\n   * @param a Bounds\r\n   * @param b Bounds\r\n   * @returns\r\n   */\n  ;\n\n  Utils.boundsCollide = function boundsCollide(a, b) {\n    return !(a.maxX < b.minX || a.minX > b.maxX || a.maxY < b.minY || a.minY > b.maxY);\n  }\n  /**\r\n   * Get whether the bounds of A contain the bounds of B. A perfect match will return true.\r\n   * @param a Bounds\r\n   * @param b Bounds\r\n   * @returns\r\n   */\n  ;\n\n  Utils.boundsContain = function boundsContain(a, b) {\n    return a.minX < b.minX && a.minY < b.minY && a.maxY > b.maxY && a.maxX > b.maxX;\n  }\n  /**\r\n   * Get whether the bounds of A are contained by the bounds of B.\r\n   * @param a Bounds\r\n   * @param b Bounds\r\n   * @returns\r\n   */\n  ;\n\n  Utils.boundsContained = function boundsContained(a, b) {\n    return Utils.boundsContain(b, a);\n  }\n  /**\r\n   * Get whether two bounds are identical.\r\n   * @param a Bounds\r\n   * @param b Bounds\r\n   * @returns\r\n   */\n  ;\n\n  Utils.boundsAreEqual = function boundsAreEqual(a, b) {\n    return !(b.maxX !== a.maxX || b.minX !== a.minX || b.maxY !== a.maxY || b.minY !== a.minY);\n  }\n  /**\r\n   * Find a bounding box from an array of points.\r\n   * @param points\r\n   * @param rotation (optional) The bounding box's rotation.\r\n   */\n  ;\n\n  Utils.getBoundsFromPoints = function getBoundsFromPoints(points, rotation) {\n    if (rotation === void 0) {\n      rotation = 0;\n    }\n\n    var minX = Infinity;\n    var minY = Infinity;\n    var maxX = -Infinity;\n    var maxY = -Infinity;\n\n    if (points.length < 2) {\n      minX = 0;\n      minY = 0;\n      maxX = 1;\n      maxY = 1;\n    } else {\n      for (var _iterator = _createForOfIteratorHelperLoose(points), _step; !(_step = _iterator()).done;) {\n        var _step$value = _step.value,\n            x = _step$value[0],\n            y = _step$value[1];\n        minX = Math.min(x, minX);\n        minY = Math.min(y, minY);\n        maxX = Math.max(x, maxX);\n        maxY = Math.max(y, maxY);\n      }\n    }\n\n    if (rotation !== 0) {\n      return Utils.getBoundsFromPoints(points.map(function (pt) {\n        return Vec.rotWith(pt, [(minX + maxX) / 2, (minY + maxY) / 2], rotation);\n      }));\n    }\n\n    return {\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY,\n      width: Math.max(1, maxX - minX),\n      height: Math.max(1, maxY - minY)\n    };\n  }\n  /**\r\n   * Move a bounding box without recalculating it.\r\n   * @param bounds\r\n   * @param delta\r\n   * @returns\r\n   */\n  ;\n\n  Utils.translateBounds = function translateBounds(bounds, delta) {\n    return {\n      minX: bounds.minX + delta[0],\n      minY: bounds.minY + delta[1],\n      maxX: bounds.maxX + delta[0],\n      maxY: bounds.maxY + delta[1],\n      width: bounds.width,\n      height: bounds.height\n    };\n  }\n  /**\r\n   * Rotate a bounding box.\r\n   * @param bounds\r\n   * @param center\r\n   * @param rotation\r\n   */\n  ;\n\n  Utils.rotateBounds = function rotateBounds(bounds, center, rotation) {\n    var _vec$rotWith = Vec.rotWith([bounds.minX, bounds.minY], center, rotation),\n        minX = _vec$rotWith[0],\n        minY = _vec$rotWith[1];\n\n    var _vec$rotWith2 = Vec.rotWith([bounds.maxX, bounds.maxY], center, rotation),\n        maxX = _vec$rotWith2[0],\n        maxY = _vec$rotWith2[1];\n\n    return {\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY,\n      width: bounds.width,\n      height: bounds.height\n    };\n  }\n  /**\r\n   * Get the rotated bounds of an ellipse.\r\n   * @param x\r\n   * @param y\r\n   * @param rx\r\n   * @param ry\r\n   * @param rotation\r\n   */\n  ;\n\n  Utils.getRotatedEllipseBounds = function getRotatedEllipseBounds(x, y, rx, ry, rotation) {\n    var c = Math.cos(rotation);\n    var s = Math.sin(rotation);\n    var w = Math.hypot(rx * c, ry * s);\n    var h = Math.hypot(rx * s, ry * c);\n    return {\n      minX: x + rx - w,\n      minY: y + ry - h,\n      maxX: x + rx + w,\n      maxY: y + ry + h,\n      width: w * 2,\n      height: h * 2\n    };\n  }\n  /**\r\n   * Get a bounding box that includes two bounding boxes.\r\n   * @param a Bounding box\r\n   * @param b Bounding box\r\n   * @returns\r\n   */\n  ;\n\n  Utils.getExpandedBounds = function getExpandedBounds(a, b) {\n    var minX = Math.min(a.minX, b.minX);\n    var minY = Math.min(a.minY, b.minY);\n    var maxX = Math.max(a.maxX, b.maxX);\n    var maxY = Math.max(a.maxY, b.maxY);\n    var width = Math.abs(maxX - minX);\n    var height = Math.abs(maxY - minY);\n    return {\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY,\n      width: width,\n      height: height\n    };\n  }\n  /**\r\n   * Get the common bounds of a group of bounds.\r\n   * @returns\r\n   */\n  ;\n\n  Utils.getCommonBounds = function getCommonBounds(bounds) {\n    if (bounds.length < 2) return bounds[0];\n    var result = bounds[0];\n\n    for (var i = 1; i < bounds.length; i++) {\n      result = Utils.getExpandedBounds(result, bounds[i]);\n    }\n\n    return result;\n  };\n\n  Utils.getRotatedCorners = function getRotatedCorners(b, rotation) {\n    if (rotation === void 0) {\n      rotation = 0;\n    }\n\n    var center = [b.minX + b.width / 2, b.minY + b.height / 2];\n    return [[b.minX, b.minY], [b.maxX, b.minY], [b.maxX, b.maxY], [b.minX, b.maxY]].map(function (point) {\n      return Vec.rotWith(point, center, rotation);\n    });\n  };\n\n  Utils.getTransformedBoundingBox = function getTransformedBoundingBox(bounds, handle, delta, rotation, isAspectRatioLocked) {\n    if (rotation === void 0) {\n      rotation = 0;\n    }\n\n    if (isAspectRatioLocked === void 0) {\n      isAspectRatioLocked = false;\n    }\n\n    // Create top left and bottom right corners.\n    var _ref = [bounds.minX, bounds.minY],\n        ax0 = _ref[0],\n        ay0 = _ref[1];\n    var _ref2 = [bounds.maxX, bounds.maxY],\n        ax1 = _ref2[0],\n        ay1 = _ref2[1]; // Create a second set of corners for the new box.\n\n    var _ref3 = [bounds.minX, bounds.minY],\n        bx0 = _ref3[0],\n        by0 = _ref3[1];\n    var _ref4 = [bounds.maxX, bounds.maxY],\n        bx1 = _ref4[0],\n        by1 = _ref4[1]; // If the drag is on the center, just translate the bounds.\n\n    if (handle === 'center') {\n      return {\n        minX: bx0 + delta[0],\n        minY: by0 + delta[1],\n        maxX: bx1 + delta[0],\n        maxY: by1 + delta[1],\n        width: bx1 - bx0,\n        height: by1 - by0,\n        scaleX: 1,\n        scaleY: 1\n      };\n    } // Counter rotate the delta. This lets us make changes as if\n    // the (possibly rotated) boxes were axis aligned.\n\n\n    var _vec$rot = Vec.rot(delta, -rotation),\n        dx = _vec$rot[0],\n        dy = _vec$rot[1];\n    /*\r\n    1. Delta\r\n     Use the delta to adjust the new box by changing its corners.\r\n    The dragging handle (corner or edge) will determine which\r\n    corners should change.\r\n    */\n\n\n    switch (handle) {\n      case exports.TLBoundsEdge.Top:\n      case exports.TLBoundsCorner.TopLeft:\n      case exports.TLBoundsCorner.TopRight:\n        {\n          by0 += dy;\n          break;\n        }\n\n      case exports.TLBoundsEdge.Bottom:\n      case exports.TLBoundsCorner.BottomLeft:\n      case exports.TLBoundsCorner.BottomRight:\n        {\n          by1 += dy;\n          break;\n        }\n    }\n\n    switch (handle) {\n      case exports.TLBoundsEdge.Left:\n      case exports.TLBoundsCorner.TopLeft:\n      case exports.TLBoundsCorner.BottomLeft:\n        {\n          bx0 += dx;\n          break;\n        }\n\n      case exports.TLBoundsEdge.Right:\n      case exports.TLBoundsCorner.TopRight:\n      case exports.TLBoundsCorner.BottomRight:\n        {\n          bx1 += dx;\n          break;\n        }\n    }\n\n    var aw = ax1 - ax0;\n    var ah = ay1 - ay0;\n    var scaleX = (bx1 - bx0) / aw;\n    var scaleY = (by1 - by0) / ah;\n    var flipX = scaleX < 0;\n    var flipY = scaleY < 0;\n    var bw = Math.abs(bx1 - bx0);\n    var bh = Math.abs(by1 - by0);\n    /*\r\n    2. Aspect ratio\r\n     If the aspect ratio is locked, adjust the corners so that the\r\n    new box's aspect ratio matches the original aspect ratio.\r\n    */\n\n    if (isAspectRatioLocked) {\n      var ar = aw / ah;\n      var isTall = ar < bw / bh;\n      var tw = bw * (scaleY < 0 ? 1 : -1) * (1 / ar);\n      var th = bh * (scaleX < 0 ? 1 : -1) * ar;\n\n      switch (handle) {\n        case exports.TLBoundsCorner.TopLeft:\n          {\n            if (isTall) by0 = by1 + tw;else bx0 = bx1 + th;\n            break;\n          }\n\n        case exports.TLBoundsCorner.TopRight:\n          {\n            if (isTall) by0 = by1 + tw;else bx1 = bx0 - th;\n            break;\n          }\n\n        case exports.TLBoundsCorner.BottomRight:\n          {\n            if (isTall) by1 = by0 - tw;else bx1 = bx0 - th;\n            break;\n          }\n\n        case exports.TLBoundsCorner.BottomLeft:\n          {\n            if (isTall) by1 = by0 - tw;else bx0 = bx1 + th;\n            break;\n          }\n\n        case exports.TLBoundsEdge.Bottom:\n        case exports.TLBoundsEdge.Top:\n          {\n            var m = (bx0 + bx1) / 2;\n            var w = bh * ar;\n            bx0 = m - w / 2;\n            bx1 = m + w / 2;\n            break;\n          }\n\n        case exports.TLBoundsEdge.Left:\n        case exports.TLBoundsEdge.Right:\n          {\n            var _m = (by0 + by1) / 2;\n\n            var h = bw / ar;\n            by0 = _m - h / 2;\n            by1 = _m + h / 2;\n            break;\n          }\n      }\n    }\n    /*\r\n    3. Rotation\r\n     If the bounds are rotated, get a vector from the rotated anchor\r\n    corner in the inital bounds to the rotated anchor corner in the\r\n    result's bounds. Subtract this vector from the result's corners,\r\n    so that the two anchor points (initial and result) will be equal.\r\n    */\n\n\n    if (rotation % (Math.PI * 2) !== 0) {\n      var cv = [0, 0];\n      var c0 = Vec.med([ax0, ay0], [ax1, ay1]);\n      var c1 = Vec.med([bx0, by0], [bx1, by1]);\n\n      switch (handle) {\n        case exports.TLBoundsCorner.TopLeft:\n          {\n            cv = Vec.sub(Vec.rotWith([bx1, by1], c1, rotation), Vec.rotWith([ax1, ay1], c0, rotation));\n            break;\n          }\n\n        case exports.TLBoundsCorner.TopRight:\n          {\n            cv = Vec.sub(Vec.rotWith([bx0, by1], c1, rotation), Vec.rotWith([ax0, ay1], c0, rotation));\n            break;\n          }\n\n        case exports.TLBoundsCorner.BottomRight:\n          {\n            cv = Vec.sub(Vec.rotWith([bx0, by0], c1, rotation), Vec.rotWith([ax0, ay0], c0, rotation));\n            break;\n          }\n\n        case exports.TLBoundsCorner.BottomLeft:\n          {\n            cv = Vec.sub(Vec.rotWith([bx1, by0], c1, rotation), Vec.rotWith([ax1, ay0], c0, rotation));\n            break;\n          }\n\n        case exports.TLBoundsEdge.Top:\n          {\n            cv = Vec.sub(Vec.rotWith(Vec.med([bx0, by1], [bx1, by1]), c1, rotation), Vec.rotWith(Vec.med([ax0, ay1], [ax1, ay1]), c0, rotation));\n            break;\n          }\n\n        case exports.TLBoundsEdge.Left:\n          {\n            cv = Vec.sub(Vec.rotWith(Vec.med([bx1, by0], [bx1, by1]), c1, rotation), Vec.rotWith(Vec.med([ax1, ay0], [ax1, ay1]), c0, rotation));\n            break;\n          }\n\n        case exports.TLBoundsEdge.Bottom:\n          {\n            cv = Vec.sub(Vec.rotWith(Vec.med([bx0, by0], [bx1, by0]), c1, rotation), Vec.rotWith(Vec.med([ax0, ay0], [ax1, ay0]), c0, rotation));\n            break;\n          }\n\n        case exports.TLBoundsEdge.Right:\n          {\n            cv = Vec.sub(Vec.rotWith(Vec.med([bx0, by0], [bx0, by1]), c1, rotation), Vec.rotWith(Vec.med([ax0, ay0], [ax0, ay1]), c0, rotation));\n            break;\n          }\n      }\n\n      var _vec$sub = Vec.sub([bx0, by0], cv);\n\n      bx0 = _vec$sub[0];\n      by0 = _vec$sub[1];\n\n      var _vec$sub2 = Vec.sub([bx1, by1], cv);\n\n      bx1 = _vec$sub2[0];\n      by1 = _vec$sub2[1];\n    }\n    /*\r\n    4. Flips\r\n     If the axes are flipped (e.g. if the right edge has been dragged\r\n    left past the initial left edge) then swap points on that axis.\r\n    */\n\n\n    if (bx1 < bx0) {\n      var _ref5 = [bx0, bx1];\n      bx1 = _ref5[0];\n      bx0 = _ref5[1];\n    }\n\n    if (by1 < by0) {\n      var _ref6 = [by0, by1];\n      by1 = _ref6[0];\n      by0 = _ref6[1];\n    }\n\n    return {\n      minX: bx0,\n      minY: by0,\n      maxX: bx1,\n      maxY: by1,\n      width: bx1 - bx0,\n      height: by1 - by0,\n      scaleX: (bx1 - bx0) / (ax1 - ax0 || 1) * (flipX ? -1 : 1),\n      scaleY: (by1 - by0) / (ay1 - ay0 || 1) * (flipY ? -1 : 1)\n    };\n  };\n\n  Utils.getTransformAnchor = function getTransformAnchor(type, isFlippedX, isFlippedY) {\n    var anchor = type; // Change corner anchors if flipped\n\n    switch (type) {\n      case exports.TLBoundsCorner.TopLeft:\n        {\n          if (isFlippedX && isFlippedY) {\n            anchor = exports.TLBoundsCorner.BottomRight;\n          } else if (isFlippedX) {\n            anchor = exports.TLBoundsCorner.TopRight;\n          } else if (isFlippedY) {\n            anchor = exports.TLBoundsCorner.BottomLeft;\n          } else {\n            anchor = exports.TLBoundsCorner.BottomRight;\n          }\n\n          break;\n        }\n\n      case exports.TLBoundsCorner.TopRight:\n        {\n          if (isFlippedX && isFlippedY) {\n            anchor = exports.TLBoundsCorner.BottomLeft;\n          } else if (isFlippedX) {\n            anchor = exports.TLBoundsCorner.TopLeft;\n          } else if (isFlippedY) {\n            anchor = exports.TLBoundsCorner.BottomRight;\n          } else {\n            anchor = exports.TLBoundsCorner.BottomLeft;\n          }\n\n          break;\n        }\n\n      case exports.TLBoundsCorner.BottomRight:\n        {\n          if (isFlippedX && isFlippedY) {\n            anchor = exports.TLBoundsCorner.TopLeft;\n          } else if (isFlippedX) {\n            anchor = exports.TLBoundsCorner.BottomLeft;\n          } else if (isFlippedY) {\n            anchor = exports.TLBoundsCorner.TopRight;\n          } else {\n            anchor = exports.TLBoundsCorner.TopLeft;\n          }\n\n          break;\n        }\n\n      case exports.TLBoundsCorner.BottomLeft:\n        {\n          if (isFlippedX && isFlippedY) {\n            anchor = exports.TLBoundsCorner.TopRight;\n          } else if (isFlippedX) {\n            anchor = exports.TLBoundsCorner.BottomRight;\n          } else if (isFlippedY) {\n            anchor = exports.TLBoundsCorner.TopLeft;\n          } else {\n            anchor = exports.TLBoundsCorner.TopRight;\n          }\n\n          break;\n        }\n    }\n\n    return anchor;\n  }\n  /**\r\n   * Get the relative bounds (usually a child) within a transformed bounding box.\r\n   * @param bounds\r\n   * @param initialBounds\r\n   * @param initialShapeBounds\r\n   * @param isFlippedX\r\n   * @param isFlippedY\r\n   */\n  ;\n\n  Utils.getRelativeTransformedBoundingBox = function getRelativeTransformedBoundingBox(bounds, initialBounds, initialShapeBounds, isFlippedX, isFlippedY) {\n    var nx = (isFlippedX ? initialBounds.maxX - initialShapeBounds.maxX : initialShapeBounds.minX - initialBounds.minX) / initialBounds.width;\n    var ny = (isFlippedY ? initialBounds.maxY - initialShapeBounds.maxY : initialShapeBounds.minY - initialBounds.minY) / initialBounds.height;\n    var nw = initialShapeBounds.width / initialBounds.width;\n    var nh = initialShapeBounds.height / initialBounds.height;\n    var minX = bounds.minX + bounds.width * nx;\n    var minY = bounds.minY + bounds.height * ny;\n    var width = bounds.width * nw;\n    var height = bounds.height * nh;\n    return {\n      minX: minX,\n      minY: minY,\n      maxX: minX + width,\n      maxY: minY + height,\n      width: width,\n      height: height\n    };\n  }\n  /**\r\n   * Get the size of a rotated box.\r\n   * @param size : ;\r\n   * @param rotation\r\n   */\n  ;\n\n  Utils.getRotatedSize = function getRotatedSize(size, rotation) {\n    var center = Vec.div(size, 2);\n    var points = [[0, 0], [size[0], 0], size, [0, size[1]]].map(function (point) {\n      return Vec.rotWith(point, center, rotation);\n    });\n    var bounds = Utils.getBoundsFromPoints(points);\n    return [bounds.width, bounds.height];\n  }\n  /**\r\n   * Get the center of a bounding box.\r\n   * @param bounds\r\n   */\n  ;\n\n  Utils.getBoundsCenter = function getBoundsCenter(bounds) {\n    return [bounds.minX + bounds.width / 2, bounds.minY + bounds.height / 2];\n  }\n  /* -------------------------------------------------- */\n\n  /*                Lists and Collections               */\n\n  /* -------------------------------------------------- */\n\n  /**\r\n   *\r\n   *\r\n   * ### Example\r\n   *\r\n   *```ts\r\n   * example\r\n   *```\r\n   */\n  ;\n\n  Utils.removeDuplicatePoints = function removeDuplicatePoints(points) {\n    return points.reduce(function (acc, pt, i) {\n      if (i === 0 || !Vec.isEqual(pt, acc[i - 1])) {\n        acc.push(pt);\n      }\n\n      return acc;\n    }, []);\n  }\n  /**\r\n  // points =\r\n   \n  /**\r\n  * Get a value from a cache (a WeakMap), filling the value if it is not present.\r\n  *\r\n  * ### Example\r\n  *\r\n  *```ts\r\n  * getFromCache(boundsCache, shape, (cache) => cache.set(shape, \"value\"))\r\n  *```\r\n  */\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  ;\n\n  Utils.getFromCache = function getFromCache(cache, item, getNext) {\n    var value = cache.get(item);\n\n    if (value === undefined) {\n      cache.set(item, getNext());\n      value = cache.get(item);\n\n      if (value === undefined) {\n        throw Error('Cache did not include item!');\n      }\n    }\n\n    return value;\n  }\n  /**\r\n   * Get a unique string id.\r\n   */\n  ;\n\n  Utils.uniqueId = function uniqueId(a) {\n    if (a === void 0) {\n      a = '';\n    }\n\n    return a ?\n    /* eslint-disable no-bitwise */\n    ((Number(a) ^ Math.random() * 16) >> Number(a) / 4).toString(16) : (1e7 + \"-\" + 1e3 + \"-\" + 4e3 + \"-\" + 8e3 + \"-\" + 1e11).replace(/[018]/g, Utils.uniqueId);\n  }\n  /**\r\n   * Shuffle the contents of an array.\r\n   * @param arr\r\n   * @param offset\r\n   */\n  ;\n\n  Utils.shuffleArr = function shuffleArr(arr, offset) {\n    return arr.map(function (_, i) {\n      return arr[(i + offset) % arr.length];\n    });\n  }\n  /**\r\n   * Deep compare two arrays.\r\n   * @param a\r\n   * @param b\r\n   */\n  ;\n\n  Utils.deepCompareArrays = function deepCompareArrays(a, b) {\n    if ((a == null ? void 0 : a.length) !== (b == null ? void 0 : b.length)) return false;\n    return Utils.deepCompare(a, b);\n  }\n  /**\r\n   * Deep compare any values.\r\n   * @param a\r\n   * @param b\r\n   */\n  ;\n\n  Utils.deepCompare = function deepCompare(a, b) {\n    return a === b || JSON.stringify(a) === JSON.stringify(b);\n  };\n\n  Utils.arrsIntersect = function arrsIntersect(a, b, fn) {\n    return a.some(function (item) {\n      return b.includes(fn ? fn(item) : item);\n    });\n  }\n  /**\r\n   * Get the unique values from an array of strings or numbers.\r\n   * @param items\r\n   */\n  ;\n\n  Utils.uniqueArray = function uniqueArray() {\n    for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {\n      items[_key] = arguments[_key];\n    }\n\n    return Array.from(new Set(items).values());\n  }\n  /**\r\n   * Convert a set to an array.\r\n   * @param set\r\n   */\n  ;\n\n  Utils.setToArray = function setToArray(set) {\n    return Array.from(set.values());\n  }\n  /**\r\n   * Debounce a function.\r\n   */\n  ;\n\n  Utils.debounce = function debounce(fn, ms) {\n    if (ms === void 0) {\n      ms = 0;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    var timeoutId;\n    return function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(function () {\n        return fn.apply(args);\n      }, ms);\n    };\n  }\n  /**\r\n   * Turn an array of points into a path of quadradic curves.\r\n   * @param stroke ;\r\n   */\n  ;\n\n  Utils.getSvgPathFromStroke = function getSvgPathFromStroke(stroke) {\n    if (!stroke.length) return '';\n    var d = stroke.reduce(function (acc, _ref7, i, arr) {\n      var x0 = _ref7[0],\n          y0 = _ref7[1];\n      var _arr = arr[(i + 1) % arr.length],\n          x1 = _arr[0],\n          y1 = _arr[1];\n      acc.push(\" \" + x0 + \",\" + y0 + \" \" + (x0 + x1) / 2 + \",\" + (y0 + y1) / 2);\n      return acc;\n    }, ['M ', stroke[0][0] + \",\" + stroke[0][1], ' Q']);\n    d.push(' Z');\n    return d.join('').replaceAll(/(\\s?[A-Z]?,?-?[0-9]*\\.[0-9]{0,2})(([0-9]|e|-)*)/g, '$1');\n  }\n  /* -------------------------------------------------- */\n\n  /*                   Browser and DOM                  */\n\n  /* -------------------------------------------------- */\n\n  /**\r\n   * Find whether the current display is a touch display.\r\n   */\n  ;\n\n  Utils.isTouchDisplay = function isTouchDisplay() {\n    return 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;\n  }\n  /**\r\n   * Find whether the current device is a Mac / iOS / iPadOS.\r\n   */\n  ;\n\n  Utils.isDarwin = function isDarwin() {\n    return /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);\n  }\n  /**\r\n   * Get whether the current device is a mobile device.\r\n   */\n  ;\n\n  Utils.isMobile = function isMobile() {\n    return false; // _isMobile().any\n  }\n  /**\r\n   * Get whether an event is command (mac) or control (pc).\r\n   * @param e\r\n   */\n  ;\n\n  Utils.metaKey = function metaKey(e) {\n    return Utils.isDarwin() ? e.metaKey : e.ctrlKey;\n  }\n  /**\r\n   * Find the closest point on a SVG path to an off-path point.\r\n   * @param pathNode\r\n   * @param point\r\n   * @returns\r\n   */\n  ;\n\n  Utils.getClosestPointOnSVGPath = function getClosestPointOnSVGPath(pathNode, point) {\n    function distance2(p, point) {\n      var dx = p.x - point[0];\n      var dy = p.y - point[1];\n      return dx * dx + dy * dy;\n    }\n\n    var pathLen = pathNode.getTotalLength();\n    var p = 8;\n    var best = {};\n    var bestLen = Infinity;\n    var bestDist = Infinity;\n    var bl = 0;\n    var al = 0; // linear scan for coarse approximation\n\n    for (var scan, scanLen = 0, scanDist; scanLen <= pathLen; scanLen += p) {\n      if ((scanDist = distance2(scan = pathNode.getPointAtLength(scanLen), point)) < bestDist) {\n        best = scan;\n        bestLen = scanLen;\n        bestDist = scanDist;\n      }\n    } // binary search for precise estimate\n\n\n    p /= 2;\n\n    while (p > 0.5) {\n      var before = void 0,\n          after = void 0,\n          bd = void 0,\n          ad = void 0;\n\n      if ((bl = bestLen - p) >= 0 && (bd = distance2(before = pathNode.getPointAtLength(bl), point)) < bestDist) {\n        best = before;\n        bestLen = bl;\n        bestDist = bd;\n      } else if ((al = bestLen + p) <= pathLen && (ad = distance2(after = pathNode.getPointAtLength(al), point)) < bestDist) {\n        best = after;\n        bestLen = al;\n        bestDist = ad;\n      } else {\n        p /= 2;\n      }\n    }\n\n    return {\n      point: [best.x, best.y],\n      distance: bestDist,\n      length: (bl + al) / 2,\n      t: (bl + al) / 2 / pathLen\n    };\n  };\n\n  return Utils;\n}();\n\n/* ----------------- Start Copy Here ---------------- */\n\nfunction getIntersection(message) {\n  for (var _len = arguments.length, points = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    points[_key - 1] = arguments[_key];\n  }\n\n  var didIntersect = points.length > 0;\n  return {\n    didIntersect: didIntersect,\n    message: message,\n    points: points\n  };\n}\n\nvar Intersect = function Intersect() {};\nIntersect.ray = {\n  // Intersect a ray with a ray.\n  ray: function ray(p0, n0, p1, n1) {\n    var dx = p1[0] - p0[0];\n    var dy = p1[1] - p0[1];\n    var det = n1[0] * n0[1] - n1[1] * n0[0];\n    var u = (dy * n1[0] - dx * n1[1]) / det;\n    var v = (dy * n0[0] - dx * n0[1]) / det;\n    if (u < 0 || v < 0) return getIntersection('miss');\n    var m0 = n0[1] / n0[0];\n    var m1 = n1[1] / n1[0];\n    var b0 = p0[1] - m0 * p0[0];\n    var b1 = p1[1] - m1 * p1[0];\n    var x = (b1 - b0) / (m0 - m1);\n    var y = m0 * x + b0;\n    return Number.isFinite(x) ? getIntersection('intersection', [x, y]) : getIntersection('parallel');\n  },\n  // Interseg a ray with a line segment.\n  lineSegment: function lineSegment(origin, direction, a1, a2) {\n    var x = origin[0],\n        y = origin[1];\n    var dx = direction[0],\n        dy = direction[1];\n    var x1 = a1[0],\n        y1 = a1[1];\n    var x2 = a2[0],\n        y2 = a2[1];\n\n    if (dy / dx !== (y2 - y1) / (x2 - x1)) {\n      var d = dx * (y2 - y1) - dy * (x2 - x1);\n\n      if (d !== 0) {\n        var r = ((y - y1) * (x2 - x1) - (x - x1) * (y2 - y1)) / d;\n        var s = ((y - y1) * dx - (x - x1) * dy) / d;\n\n        if (r >= 0 && s >= 0 && s <= 1) {\n          return getIntersection('intersection', [x + r * dx, y + r * dy]);\n        }\n      }\n    }\n\n    return getIntersection('no intersection');\n  },\n  // Intersect a ray with a rectangle.\n  rectangle: function rectangle(origin, direction, point, size) {\n    return Intersect.rectangle.ray(point, size, origin, direction);\n  },\n  // Intersect a ray with an ellipse.\n  ellipse: function ellipse(origin, direction, center, rx, ry, rotation) {\n    var a1 = origin;\n    var a2 = Vec.mul(direction, 999999999);\n    return Intersect.lineSegment.ellipse(a1, a2, center, rx, ry, rotation);\n  },\n  // Intersect a ray with a bounding box.\n  bounds: function bounds(origin, direction, _bounds) {\n    var minX = _bounds.minX,\n        minY = _bounds.minY,\n        width = _bounds.width,\n        height = _bounds.height;\n    return Intersect.ray.rectangle(origin, direction, [minX, minY], [width, height]);\n  }\n};\nIntersect.lineSegment = {\n  // Intersect a line segment with a ray.\n  ray: function ray(a1, a2, origin, direction) {\n    return Intersect.ray.lineSegment(origin, direction, a1, a2);\n  },\n  // Intersect a line segment with a line segment.\n  lineSegment: function lineSegment(a1, a2, b1, b2) {\n    var AB = Vec.sub(a1, b1);\n    var BV = Vec.sub(b2, b1);\n    var AV = Vec.sub(a2, a1);\n    var ua_t = BV[0] * AB[1] - BV[1] * AB[0];\n    var ub_t = AV[0] * AB[1] - AV[1] * AB[0];\n    var u_b = BV[1] * AV[0] - BV[0] * AV[1];\n\n    if (ua_t === 0 || ub_t === 0) {\n      return getIntersection('coincident');\n    }\n\n    if (u_b === 0) {\n      return getIntersection('parallel');\n    }\n\n    if (u_b !== 0) {\n      var ua = ua_t / u_b;\n      var ub = ub_t / u_b;\n\n      if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {\n        return getIntersection('intersection', Vec.add(a1, Vec.mul(AV, ua)));\n      }\n    }\n\n    return getIntersection('no intersection');\n  },\n  // Intersect a line segment with a rectangle\n  rectangle: function rectangle(a1, a2, point, size) {\n    return Intersect.rectangle.lineSegment(point, size, a1, a2);\n  },\n  // Intersect a line segment with an arc.\n  arc: function arc(a1, a2, center, radius, start, end) {\n    var sa = Vec.angle(center, start);\n    var ea = Vec.angle(center, end);\n    var ellipseTest = Intersect.ellipse.lineSegment(center, radius, radius, 0, a1, a2);\n    if (!ellipseTest.didIntersect) return getIntersection('No intersection');\n    var points = ellipseTest.points.filter(function (point) {\n      return Utils.isAngleBetween(sa, ea, Vec.angle(center, point));\n    });\n\n    if (points.length === 0) {\n      return getIntersection('No intersection');\n    }\n\n    return getIntersection.apply(void 0, ['intersection'].concat(points));\n  },\n  // Intersect a line segment with a circle.\n  circle: function circle(a1, a2, c, r) {\n    var a = (a2[0] - a1[0]) * (a2[0] - a1[0]) + (a2[1] - a1[1]) * (a2[1] - a1[1]);\n    var b = 2 * ((a2[0] - a1[0]) * (a1[0] - c[0]) + (a2[1] - a1[1]) * (a1[1] - c[1]));\n    var cc = c[0] * c[0] + c[1] * c[1] + a1[0] * a1[0] + a1[1] * a1[1] - 2 * (c[0] * a1[0] + c[1] * a1[1]) - r * r;\n    var deter = b * b - 4 * a * cc;\n\n    if (deter < 0) {\n      return getIntersection('outside');\n    }\n\n    if (deter === 0) {\n      return getIntersection('tangent');\n    }\n\n    var e = Math.sqrt(deter);\n    var u1 = (-b + e) / (2 * a);\n    var u2 = (-b - e) / (2 * a);\n\n    if ((u1 < 0 || u1 > 1) && (u2 < 0 || u2 > 1)) {\n      if (u1 < 0 && u2 < 0 || u1 > 1 && u2 > 1) {\n        return getIntersection('outside');\n      } else {\n        return getIntersection('inside');\n      }\n    }\n\n    var results = [];\n    if (0 <= u1 && u1 <= 1) results.push(Vec.lrp(a1, a2, u1));\n    if (0 <= u2 && u2 <= 1) results.push(Vec.lrp(a1, a2, u2));\n    return getIntersection.apply(void 0, ['intersection'].concat(results));\n  },\n  // Intersect a line segment with an ellipse.\n  ellipse: function ellipse(a1, a2, center, rx, ry, rotation) {\n    if (rotation === void 0) {\n      rotation = 0;\n    }\n\n    // If the ellipse or line segment are empty, return no tValues.\n    if (rx === 0 || ry === 0 || Vec.isEqual(a1, a2)) {\n      return getIntersection('No intersection');\n    } // Get the semimajor and semiminor axes.\n\n\n    rx = rx < 0 ? rx : -rx;\n    ry = ry < 0 ? ry : -ry; // Rotate points and translate so the ellipse is centered at the origin.\n\n    a1 = Vec.sub(Vec.rotWith(a1, center, -rotation), center);\n    a2 = Vec.sub(Vec.rotWith(a2, center, -rotation), center); // Calculate the quadratic parameters.\n\n    var diff = Vec.sub(a2, a1);\n    var A = diff[0] * diff[0] / rx / rx + diff[1] * diff[1] / ry / ry;\n    var B = 2 * a1[0] * diff[0] / rx / rx + 2 * a1[1] * diff[1] / ry / ry;\n    var C = a1[0] * a1[0] / rx / rx + a1[1] * a1[1] / ry / ry - 1; // Make a list of t values (normalized points on the line where intersections occur).\n\n    var tValues = []; // Calculate the discriminant.\n\n    var discriminant = B * B - 4 * A * C;\n\n    if (discriminant === 0) {\n      // One real solution.\n      tValues.push(-B / 2 / A);\n    } else if (discriminant > 0) {\n      var root = Math.sqrt(discriminant); // Two real solutions.\n\n      tValues.push((-B + root) / 2 / A);\n      tValues.push((-B - root) / 2 / A);\n    } // Filter to only points that are on the segment.\n    // Solve for points, then counter-rotate points.\n\n\n    var points = tValues.filter(function (t) {\n      return t >= 0 && t <= 1;\n    }).map(function (t) {\n      return Vec.add(center, Vec.add(a1, Vec.mul(Vec.sub(a2, a1), t)));\n    }).map(function (p) {\n      return Vec.rotWith(p, center, rotation);\n    });\n    return getIntersection.apply(void 0, ['intersection'].concat(points));\n  },\n  // Intersect a line segment with a bounding box.\n  bounds: function bounds(a1, a2, _bounds2) {\n    return Intersect.bounds.lineSegment(_bounds2, a1, a2);\n  },\n  // Intersect a line segment with a polyline\n  polyline: function polyline(a1, a2, points) {\n    var intersections = [];\n\n    for (var i = 1; i < points.length + 1; i++) {\n      var _int = Intersect.lineSegment.lineSegment(a1, a2, points[i - 1], points[i % points.length]);\n\n      if (_int) {\n        intersections.push(_int);\n      }\n    }\n\n    return intersections;\n  }\n};\nIntersect.rectangle = {\n  // Intersect a rectangle with a ray.\n  ray: function ray(point, size, origin, direction) {\n    var sideIntersections = Utils.getRectangleSides(point, size).reduce(function (acc, _ref) {\n      var message = _ref[0],\n          _ref$ = _ref[1],\n          a1 = _ref$[0],\n          a2 = _ref$[1];\n      var intersection = Intersect.ray.lineSegment(origin, direction, a1, a2);\n\n      if (intersection) {\n        acc.push(getIntersection.apply(void 0, [message].concat(intersection.points)));\n      }\n\n      return acc;\n    }, []);\n    return sideIntersections.filter(function (_int2) {\n      return _int2.didIntersect;\n    });\n  },\n  // Intersect a rectangle with a line segment.\n  lineSegment: function lineSegment(point, size, a1, a2) {\n    var sideIntersections = Utils.getRectangleSides(point, size).reduce(function (acc, _ref2) {\n      var message = _ref2[0],\n          _ref2$ = _ref2[1],\n          b1 = _ref2$[0],\n          b2 = _ref2$[1];\n      var intersection = Intersect.lineSegment.lineSegment(a1, a2, b1, b2);\n\n      if (intersection) {\n        acc.push(getIntersection.apply(void 0, [message].concat(intersection.points)));\n      }\n\n      return acc;\n    }, []);\n    return sideIntersections.filter(function (_int3) {\n      return _int3.didIntersect;\n    });\n  },\n  // Intersect a rectangle with a rectangle.\n  rectangle: function rectangle(point1, size1, point2, size2) {\n    var sideIntersections = Utils.getRectangleSides(point1, size1).reduce(function (acc, _ref3) {\n      var message = _ref3[0],\n          _ref3$ = _ref3[1],\n          a1 = _ref3$[0],\n          a2 = _ref3$[1];\n      var intersections = Intersect.rectangle.lineSegment(point2, size2, a1, a2);\n      acc.push.apply(acc, intersections.map(function (_int4) {\n        return getIntersection.apply(void 0, [message + \" \" + _int4.message].concat(_int4.points));\n      }));\n      return acc;\n    }, []);\n    return sideIntersections.filter(function (_int5) {\n      return _int5.didIntersect;\n    });\n  },\n  // Intersect a rectangle with an arc.\n  arc: function arc(point, size, center, radius, start, end) {\n    var sideIntersections = Utils.getRectangleSides(point, size).reduce(function (acc, _ref4) {\n      var message = _ref4[0],\n          _ref4$ = _ref4[1],\n          a1 = _ref4$[0],\n          a2 = _ref4$[1];\n      var intersection = Intersect.arc.lineSegment(center, radius, start, end, a1, a2);\n\n      if (intersection) {\n        acc.push(_extends({}, intersection, {\n          message: message\n        }));\n      }\n\n      return acc;\n    }, []);\n    return sideIntersections.filter(function (_int6) {\n      return _int6.didIntersect;\n    });\n  },\n  // Intersect a rectangle with a circle.\n  circle: function circle(point, size, c, r) {\n    var sideIntersections = Utils.getRectangleSides(point, size).reduce(function (acc, _ref5) {\n      var message = _ref5[0],\n          _ref5$ = _ref5[1],\n          a1 = _ref5$[0],\n          a2 = _ref5$[1];\n      var intersection = Intersect.lineSegment.circle(a1, a2, c, r);\n\n      if (intersection) {\n        acc.push(_extends({}, intersection, {\n          message: message\n        }));\n      }\n\n      return acc;\n    }, []);\n    return sideIntersections.filter(function (_int7) {\n      return _int7.didIntersect;\n    });\n  },\n  // Intersect a rectangle with an ellipse.\n  ellipse: function ellipse(point, size, c, rx, ry, rotation) {\n    if (rotation === void 0) {\n      rotation = 0;\n    }\n\n    var sideIntersections = Utils.getRectangleSides(point, size).reduce(function (acc, _ref6) {\n      var message = _ref6[0],\n          _ref6$ = _ref6[1],\n          a1 = _ref6$[0],\n          a2 = _ref6$[1];\n      var intersection = Intersect.lineSegment.ellipse(a1, a2, c, rx, ry, rotation);\n\n      if (intersection) {\n        acc.push(_extends({}, intersection, {\n          message: message\n        }));\n      }\n\n      return acc;\n    }, []);\n    return sideIntersections.filter(function (_int8) {\n      return _int8.didIntersect;\n    });\n  },\n  // Intersect a rectangle with a bounding box.\n  bounds: function bounds(point, size, _bounds3) {\n    var minX = _bounds3.minX,\n        minY = _bounds3.minY,\n        width = _bounds3.width,\n        height = _bounds3.height;\n    return Intersect.rectangle.rectangle(point, size, [minX, minY], [width, height]);\n  },\n  // Intersect a rectangle with a polyline\n  polyline: function polyline(point, size, points) {\n    var sideIntersections = Utils.getRectangleSides(point, size).reduce(function (acc, _ref7) {\n      var message = _ref7[0],\n          _ref7$ = _ref7[1],\n          a1 = _ref7$[0],\n          a2 = _ref7$[1];\n      var intersections = Intersect.lineSegment.polyline(a1, a2, points);\n\n      if (intersections.length > 0) {\n        acc.push(getIntersection.apply(void 0, [message].concat(intersections.flatMap(function (i) {\n          return i.points;\n        }))));\n      }\n\n      return acc;\n    }, []);\n    return sideIntersections.filter(function (_int9) {\n      return _int9.didIntersect;\n    });\n  }\n};\nIntersect.arc = {\n  // Intersect an arc with a line segment.\n  lineSegment: function lineSegment(center, radius, start, end, a1, a2) {\n    return Intersect.lineSegment.arc(a1, a2, center, radius, start, end);\n  },\n  // Intersect an arc with a rectangle.\n  rectangle: function rectangle(center, radius, start, end, point, size) {\n    return Intersect.rectangle.arc(point, size, center, radius, start, end);\n  },\n  // Intersect an arc with a bounding box.\n  bounds: function bounds(center, radius, start, end, _bounds4) {\n    var minX = _bounds4.minX,\n        minY = _bounds4.minY,\n        width = _bounds4.width,\n        height = _bounds4.height;\n    return Intersect.arc.rectangle(center, radius, start, end, [minX, minY], [width, height]);\n  }\n};\nIntersect.circle = {\n  // Intersect a circle with a line segment.\n  lineSegment: function lineSegment(c, r, a1, a2) {\n    return Intersect.lineSegment.circle(a1, a2, c, r);\n  },\n  // Intersect a circle with a circle.\n  circle: function circle(c1, r1, c2, r2) {\n    var dx = c2[0] - c1[0],\n        dy = c2[1] - c1[1];\n    var d = Math.sqrt(dx * dx + dy * dy),\n        x = (d * d - r2 * r2 + r1 * r1) / (2 * d),\n        y = Math.sqrt(r1 * r1 - x * x);\n    dx /= d;\n    dy /= d;\n    return getIntersection('intersection', [c1[0] + dx * x - dy * y, c1[1] + dy * x + dx * y], [c1[0] + dx * x + dy * y, c1[1] + dy * x - dx * y]);\n  },\n  // Intersect a circle with a rectangle.\n  rectangle: function rectangle(c, r, point, size) {\n    return Intersect.rectangle.circle(point, size, c, r);\n  },\n  // Intersect a circle with a bounding box.\n  bounds: function bounds(c, r, _bounds5) {\n    var minX = _bounds5.minX,\n        minY = _bounds5.minY,\n        width = _bounds5.width,\n        height = _bounds5.height;\n    return Intersect.circle.rectangle(c, r, [minX, minY], [width, height]);\n  }\n};\nIntersect.ellipse = {\n  // Intersect an ellipse with a ray.\n  ray: function ray(center, rx, ry, rotation, point, direction) {\n    return Intersect.ray.ellipse(point, direction, center, rx, ry, rotation);\n  },\n  // Intersect an ellipse with a line segment.\n  lineSegment: function lineSegment(center, rx, ry, rotation, a1, a2) {\n    if (rotation === void 0) {\n      rotation = 0;\n    }\n\n    if (rx === ry) {\n      return Intersect.lineSegment.circle(a1, a2, center, rx);\n    }\n\n    return Intersect.lineSegment.ellipse(a1, a2, center, rx, ry, rotation);\n  },\n  // Intersect an ellipse with a rectangle.\n  rectangle: function rectangle(center, rx, ry, rotation, point, size) {\n    if (rotation === void 0) {\n      rotation = 0;\n    }\n\n    if (rx === ry) {\n      return Intersect.rectangle.circle(point, size, center, rx);\n    }\n\n    return Intersect.rectangle.ellipse(point, size, center, rx, ry, rotation);\n  },\n  // Get an intersection between an ellipse and a second ellipse.\n  // Adapted from https://gist.github.com/drawable/92792f59b6ff8869d8b1\n  ellipse: function ellipse(_c1, _rx1, _ry1, _r1, _c2, _rx2, _ry2, _r2) {\n    // TODO\n    return getIntersection('no intersection');\n  },\n  circle: function circle(c, rx, ry, rotation, c2, r2) {\n    return Intersect.ellipse.ellipse(c, rx, ry, rotation, c2, r2, r2, 0);\n  },\n  // Intersect an ellipse with a bounding box.\n  bounds: function bounds(c, rx, ry, rotation, _bounds6) {\n    var minX = _bounds6.minX,\n        minY = _bounds6.minY,\n        width = _bounds6.width,\n        height = _bounds6.height;\n    return Intersect.ellipse.rectangle(c, rx, ry, rotation, [minX, minY], [width, height]);\n  }\n};\nIntersect.bounds = {\n  ray: function ray(bounds, origin, direction) {\n    var minX = bounds.minX,\n        minY = bounds.minY,\n        width = bounds.width,\n        height = bounds.height;\n    return Intersect.ray.rectangle(origin, direction, [minX, minY], [width, height]);\n  },\n  lineSegment: function lineSegment(bounds, a1, a2) {\n    var minX = bounds.minX,\n        minY = bounds.minY,\n        width = bounds.width,\n        height = bounds.height;\n    return Intersect.lineSegment.rectangle(a1, a2, [minX, minY], [width, height]);\n  },\n  rectangle: function rectangle(bounds, point, size) {\n    var minX = bounds.minX,\n        minY = bounds.minY,\n        width = bounds.width,\n        height = bounds.height;\n    return Intersect.rectangle.rectangle(point, size, [minX, minY], [width, height]);\n  },\n  bounds: function bounds(bounds1, bounds2) {\n    return Intersect.rectangle.rectangle([bounds1.minX, bounds1.minY], [bounds1.width, bounds1.height], [bounds2.minX, bounds2.minY], [bounds2.width, bounds2.height]);\n  },\n  arc: function arc(bounds, center, radius, start, end) {\n    var minX = bounds.minX,\n        minY = bounds.minY,\n        width = bounds.width,\n        height = bounds.height;\n    return Intersect.arc.rectangle(center, radius, start, end, [minX, minY], [width, height]);\n  },\n  circle: function circle(bounds, c, r) {\n    var minX = bounds.minX,\n        minY = bounds.minY,\n        width = bounds.width,\n        height = bounds.height;\n    return Intersect.circle.rectangle(c, r, [minX, minY], [width, height]);\n  },\n  ellipse: function ellipse(bounds, c, rx, ry, rotation) {\n    if (rotation === void 0) {\n      rotation = 0;\n    }\n\n    var minX = bounds.minX,\n        minY = bounds.minY,\n        width = bounds.width,\n        height = bounds.height;\n    return Intersect.ellipse.rectangle(c, rx, ry, rotation, [minX, minY], [width, height]);\n  },\n  polyline: function polyline(bounds, points) {\n    return Intersect.polyline.bounds(points, bounds);\n  }\n};\nIntersect.polyline = {\n  // Intersect a polyline with a line segment.\n  lineSegment: function lineSegment(points, a1, a2) {\n    return Intersect.lineSegment.polyline(a1, a2, points);\n  },\n  // Interesct a polyline with a rectangle.\n  rectangle: function rectangle(points, point, size) {\n    return Intersect.rectangle.polyline(point, size, points);\n  },\n  // Intersect a polyline with a bounding box.\n  bounds: function bounds(points, _bounds7) {\n    return Intersect.rectangle.polyline([_bounds7.minX, _bounds7.minY], [_bounds7.width, _bounds7.height], points);\n  }\n};\n\nvar Svg = function Svg() {};\n\nSvg.ellipse = function (A, r) {\n  return \"M \" + (A[0] - r) + \",\" + A[1] + \"\\n      a \" + r + \",\" + r + \" 0 1,0 \" + r * 2 + \",0\\n      a \" + r + \",\" + r + \" 0 1,0 -\" + r * 2 + \",0 \";\n};\n\nSvg.moveTo = function (v) {\n  return \"M \" + v[0] + \",\" + v[1] + \" \";\n};\n\nSvg.lineTo = function (v) {\n  return \"L \" + v[0] + \",\" + v[1] + \" \";\n};\n\nSvg.line = function (a) {\n  for (var _len = arguments.length, pts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    pts[_key - 1] = arguments[_key];\n  }\n\n  return Svg.moveTo(a) + pts.map(function (p) {\n    return Svg.lineTo(p);\n  }).join();\n};\n\nSvg.hLineTo = function (v) {\n  return \"H \" + v[0] + \",\" + v[1] + \" \";\n};\n\nSvg.vLineTo = function (v) {\n  return \"V \" + v[0] + \",\" + v[1] + \" \";\n};\n\nSvg.bezierTo = function (A, B, C) {\n  return \"C \" + A[0] + \",\" + A[1] + \" \" + B[0] + \",\" + B[1] + \" \" + C[0] + \",\" + C[1] + \" \";\n};\n\nSvg.arcTo = function (C, r, A, B) {\n  return [Svg.moveTo(A), 'A', r, r, 0, Utils.getSweep(C, A, B) > 0 ? '1' : '0', 0, B[0], B[1]].join(' ');\n};\n\nSvg.closePath = function () {\n  return 'Z';\n};\n\nSvg.rectTo = function (A) {\n  return ['R', A[0], A[1]].join(' ');\n};\n\nSvg.getPointAtLength = function (path, length) {\n  var point = path.getPointAtLength(length);\n  return [point.x, point.y];\n};\n\nvar DOUBLE_CLICK_DURATION = 250;\n\nvar Inputs = /*#__PURE__*/function () {\n  function Inputs() {\n    var _this = this;\n\n    this.pointer = void 0;\n    this.keyboard = void 0;\n    this.keys = {};\n    this.pointerUpTime = 0;\n\n    this.panStart = function (e) {\n      var _this$pointer, _this$pointer2;\n\n      var shiftKey = e.shiftKey,\n          ctrlKey = e.ctrlKey,\n          metaKey = e.metaKey,\n          altKey = e.altKey;\n      var info = {\n        target: 'wheel',\n        pointerId: ((_this$pointer = _this.pointer) == null ? void 0 : _this$pointer.pointerId) || 0,\n        origin: ((_this$pointer2 = _this.pointer) == null ? void 0 : _this$pointer2.origin) || [0, 0],\n        delta: [0, 0],\n        pressure: 0.5,\n        point: Inputs.getPoint(e),\n        shiftKey: shiftKey,\n        ctrlKey: ctrlKey,\n        metaKey: metaKey,\n        altKey: altKey\n      };\n      _this.pointer = info;\n      return info;\n    };\n\n    this.pan = function (delta, e) {\n      if (!_this.pointer || _this.pointer.target !== 'wheel') {\n        return _this.panStart(e);\n      }\n\n      var shiftKey = e.shiftKey,\n          ctrlKey = e.ctrlKey,\n          metaKey = e.metaKey,\n          altKey = e.altKey;\n      var prev = _this.pointer;\n      var point = Inputs.getPoint(e);\n\n      var info = _extends({}, prev, {\n        target: 'wheel',\n        delta: delta,\n        point: Vec.sub(point, delta),\n        shiftKey: shiftKey,\n        ctrlKey: ctrlKey,\n        metaKey: metaKey,\n        altKey: altKey\n      });\n\n      _this.pointer = info;\n      return info;\n    };\n\n    this.canAccept = function (_pointerId) {\n      return true; //   return (\n      //     this.activePointerId === undefined || this.activePointerId === pointerId\n      //   )\n    };\n\n    this.keydown = function (e) {\n      var _this$pointer3, _this$pointer4;\n\n      var shiftKey = e.shiftKey,\n          ctrlKey = e.ctrlKey,\n          metaKey = e.metaKey,\n          altKey = e.altKey;\n      _this.keys[e.key] = true;\n      return {\n        point: ((_this$pointer3 = _this.pointer) == null ? void 0 : _this$pointer3.point) || [0, 0],\n        origin: ((_this$pointer4 = _this.pointer) == null ? void 0 : _this$pointer4.origin) || [0, 0],\n        key: e.key,\n        keys: Object.keys(_this.keys),\n        shiftKey: shiftKey,\n        ctrlKey: ctrlKey,\n        metaKey: Utils.isDarwin() ? metaKey : ctrlKey,\n        altKey: altKey\n      };\n    };\n\n    this.keyup = function (e) {\n      var _this$pointer5, _this$pointer6;\n\n      var shiftKey = e.shiftKey,\n          ctrlKey = e.ctrlKey,\n          metaKey = e.metaKey,\n          altKey = e.altKey;\n      delete _this.keys[e.key];\n      return {\n        point: ((_this$pointer5 = _this.pointer) == null ? void 0 : _this$pointer5.point) || [0, 0],\n        origin: ((_this$pointer6 = _this.pointer) == null ? void 0 : _this$pointer6.origin) || [0, 0],\n        key: e.key,\n        keys: Object.keys(_this.keys),\n        shiftKey: shiftKey,\n        ctrlKey: ctrlKey,\n        metaKey: Utils.isDarwin() ? metaKey : ctrlKey,\n        altKey: altKey\n      };\n    };\n  }\n\n  var _proto = Inputs.prototype;\n\n  _proto.touchStart = function touchStart(e, target) {\n    var shiftKey = e.shiftKey,\n        ctrlKey = e.ctrlKey,\n        metaKey = e.metaKey,\n        altKey = e.altKey;\n    e.preventDefault();\n    var touch = e.changedTouches[0];\n    var info = {\n      target: target,\n      pointerId: touch.identifier,\n      origin: Inputs.getPoint(touch),\n      delta: [0, 0],\n      point: Inputs.getPoint(touch),\n      pressure: Inputs.getPressure(touch),\n      shiftKey: shiftKey,\n      ctrlKey: ctrlKey,\n      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,\n      altKey: altKey\n    };\n    this.pointer = info;\n    return info;\n  };\n\n  _proto.touchMove = function touchMove(e, target) {\n    var shiftKey = e.shiftKey,\n        ctrlKey = e.ctrlKey,\n        metaKey = e.metaKey,\n        altKey = e.altKey;\n    e.preventDefault();\n    var touch = e.changedTouches[0];\n    var prev = this.pointer;\n    var point = Inputs.getPoint(touch);\n    var delta = prev != null && prev.point ? Vec.sub(point, prev.point) : [0, 0];\n\n    var info = _extends({\n      origin: point\n    }, prev, {\n      target: target,\n      pointerId: touch.identifier,\n      point: point,\n      delta: delta,\n      pressure: Inputs.getPressure(touch),\n      shiftKey: shiftKey,\n      ctrlKey: ctrlKey,\n      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,\n      altKey: altKey\n    });\n\n    this.pointer = info;\n    return info;\n  };\n\n  _proto.pointerDown = function pointerDown(e, target) {\n    var shiftKey = e.shiftKey,\n        ctrlKey = e.ctrlKey,\n        metaKey = e.metaKey,\n        altKey = e.altKey;\n    var point = Inputs.getPoint(e);\n    var info = {\n      target: target,\n      pointerId: e.pointerId,\n      origin: point,\n      point: point,\n      delta: [0, 0],\n      pressure: Inputs.getPressure(e),\n      shiftKey: shiftKey,\n      ctrlKey: ctrlKey,\n      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,\n      altKey: altKey\n    };\n    this.pointer = info;\n    return info;\n  };\n\n  _proto.pointerEnter = function pointerEnter(e, target) {\n    var shiftKey = e.shiftKey,\n        ctrlKey = e.ctrlKey,\n        metaKey = e.metaKey,\n        altKey = e.altKey;\n    var point = Inputs.getPoint(e);\n    var info = {\n      target: target,\n      pointerId: e.pointerId,\n      origin: point,\n      delta: [0, 0],\n      point: point,\n      pressure: Inputs.getPressure(e),\n      shiftKey: shiftKey,\n      ctrlKey: ctrlKey,\n      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,\n      altKey: altKey\n    };\n    this.pointer = info;\n    return info;\n  };\n\n  _proto.pointerMove = function pointerMove(e, target) {\n    var shiftKey = e.shiftKey,\n        ctrlKey = e.ctrlKey,\n        metaKey = e.metaKey,\n        altKey = e.altKey;\n    var prev = this.pointer;\n    var point = Inputs.getPoint(e);\n    var delta = prev != null && prev.point ? Vec.sub(point, prev.point) : [0, 0];\n\n    var info = _extends({\n      origin: point\n    }, prev, {\n      target: target,\n      pointerId: e.pointerId,\n      point: point,\n      delta: delta,\n      pressure: Inputs.getPressure(e),\n      shiftKey: shiftKey,\n      ctrlKey: ctrlKey,\n      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,\n      altKey: altKey\n    });\n\n    this.pointer = info;\n    return info;\n  };\n\n  _proto.pointerUp = function pointerUp(e, target) {\n    var shiftKey = e.shiftKey,\n        ctrlKey = e.ctrlKey,\n        metaKey = e.metaKey,\n        altKey = e.altKey;\n    var prev = this.pointer;\n    var point = Inputs.getPoint(e);\n    var delta = prev != null && prev.point ? Vec.sub(point, prev.point) : [0, 0];\n\n    var info = _extends({\n      origin: point\n    }, prev, {\n      target: target,\n      pointerId: e.pointerId,\n      point: point,\n      delta: delta,\n      pressure: Inputs.getPressure(e),\n      shiftKey: shiftKey,\n      ctrlKey: ctrlKey,\n      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,\n      altKey: altKey\n    });\n\n    this.pointer = info;\n    this.pointerUpTime = Date.now();\n    return info;\n  };\n\n  _proto.isDoubleClick = function isDoubleClick() {\n    if (!this.pointer) return;\n    var _this$pointer7 = this.pointer,\n        origin = _this$pointer7.origin,\n        point = _this$pointer7.point;\n    return Date.now() - this.pointerUpTime < DOUBLE_CLICK_DURATION && Vec.dist(origin, point) < 4;\n  };\n\n  _proto.clear = function clear() {\n    this.pointer = undefined;\n  };\n\n  _proto.resetDoubleClick = function resetDoubleClick() {\n    this.pointerUpTime = 0;\n  };\n\n  _proto.pinch = function pinch(point, origin) {\n    var _this$keys = this.keys,\n        shiftKey = _this$keys.shiftKey,\n        ctrlKey = _this$keys.ctrlKey,\n        metaKey = _this$keys.metaKey,\n        altKey = _this$keys.altKey;\n    var prev = this.pointer;\n    var delta = Vec.sub(origin, point);\n    var info = {\n      pointerId: 0,\n      target: 'pinch',\n      origin: (prev == null ? void 0 : prev.origin) || Vec.round(point),\n      delta: delta,\n      point: Vec.round(point),\n      pressure: 0.5,\n      shiftKey: shiftKey,\n      ctrlKey: ctrlKey,\n      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,\n      altKey: altKey\n    };\n    this.pointer = info;\n    return info;\n  };\n\n  _proto.reset = function reset() {\n    this.pointerUpTime = 0;\n    this.pointer = undefined;\n    this.keyboard = undefined;\n    this.keys = {};\n  };\n\n  Inputs.getPoint = function getPoint(e) {\n    return [Number(e.clientX.toPrecision(5)), Number(e.clientY.toPrecision(5))];\n  };\n\n  Inputs.getPressure = function getPressure(e) {\n    return 'pressure' in e ? Number(e.pressure.toPrecision(5)) || 0.5 : 0.5;\n  };\n\n  Inputs.commandKey = function commandKey() {\n    return Utils.isDarwin() ? '' : 'Ctrl';\n  };\n\n  return Inputs;\n}();\n\nvar inputs = /*#__PURE__*/new Inputs();\n\nfunction useZoomEvents() {\n  var rPinchDa = React.useRef(undefined);\n  var rPinchPoint = React.useRef(undefined);\n\n  var _useTLContext = useTLContext(),\n      callbacks = _useTLContext.callbacks;\n\n  reactUseGesture.useGesture({\n    onWheel: function onWheel(_ref) {\n      var e = _ref.event,\n          delta = _ref.delta;\n      var info = inputs.pan(delta, e);\n\n      if (e.ctrlKey) {\n        callbacks.onZoom == null ? void 0 : callbacks.onZoom(info, e);\n        return;\n      } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n      callbacks.onPan == null ? void 0 : callbacks.onPan(info, e);\n    },\n    onPinch: function onPinch(_ref2) {\n      var pinching = _ref2.pinching,\n          da = _ref2.da,\n          origin = _ref2.origin,\n          e = _ref2.event;\n\n      if (!pinching) {\n        var _info = inputs.pinch(origin, origin);\n\n        callbacks.onPinchEnd == null ? void 0 : callbacks.onPinchEnd(_info, e);\n        rPinchDa.current = undefined;\n        rPinchPoint.current = undefined;\n        return;\n      }\n\n      if (rPinchPoint.current === undefined) {\n        var _info2 = inputs.pinch(origin, origin);\n\n        callbacks.onPinchStart == null ? void 0 : callbacks.onPinchStart(_info2, e);\n        rPinchDa.current = da;\n        rPinchPoint.current = origin;\n      } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n      var _Vec$sub = Vec.sub(rPinchDa.current, da),\n          distanceDelta = _Vec$sub[0];\n\n      var info = inputs.pinch(rPinchPoint.current, origin); // Naming things is hard\n\n      callbacks.onPinch == null ? void 0 : callbacks.onPinch(_extends({}, info, {\n        point: origin,\n        origin: rPinchPoint.current,\n        delta: [].concat(info.delta, [distanceDelta])\n      }), e);\n      rPinchDa.current = da;\n      rPinchPoint.current = origin;\n    }\n  }, {\n    domTarget: typeof document === 'undefined' ? undefined : document.body,\n    eventOptions: {\n      passive: false\n    }\n  });\n}\n\nfunction useSafariFocusOutFix() {\n  var _useTLContext = useTLContext(),\n      callbacks = _useTLContext.callbacks;\n\n  React.useEffect(function () {\n    function handleFocusOut() {\n      callbacks.onBlurEditingShape == null ? void 0 : callbacks.onBlurEditingShape();\n    }\n\n    if (!Utils.isMobile()) return;\n    document.addEventListener('focusout', handleFocusOut);\n    return function () {\n      return document.removeEventListener('focusout', handleFocusOut);\n    };\n  }, [callbacks]);\n}\n\nfunction useCanvasEvents() {\n  var _useTLContext = useTLContext(),\n      callbacks = _useTLContext.callbacks;\n\n  var onPointerDown = React.useCallback(function (e) {\n    e.currentTarget.setPointerCapture(e.pointerId);\n\n    if (e.button === 0) {\n      var info = inputs.pointerDown(e, 'canvas');\n      callbacks.onPointCanvas == null ? void 0 : callbacks.onPointCanvas(info, e);\n      callbacks.onPointerDown == null ? void 0 : callbacks.onPointerDown(info, e);\n    }\n  }, [callbacks]);\n  var onPointerMove = React.useCallback(function (e) {\n    e.stopPropagation();\n\n    if (e.currentTarget.hasPointerCapture(e.pointerId)) {\n      var _info = inputs.pointerMove(e, 'canvas');\n\n      callbacks.onDragCanvas == null ? void 0 : callbacks.onDragCanvas(_info, e);\n    }\n\n    var info = inputs.pointerMove(e, 'canvas');\n    callbacks.onPointerMove == null ? void 0 : callbacks.onPointerMove(info, e);\n  }, [callbacks]);\n  var onPointerUp = React.useCallback(function (e) {\n    e.stopPropagation();\n    var isDoubleClick = inputs.isDoubleClick();\n    var info = inputs.pointerUp(e, 'canvas');\n\n    if (e.currentTarget.hasPointerCapture(e.pointerId)) {\n      var _e$currentTarget;\n\n      (_e$currentTarget = e.currentTarget) == null ? void 0 : _e$currentTarget.releasePointerCapture(e.pointerId);\n    }\n\n    if (isDoubleClick && !(info.altKey || info.metaKey)) {\n      callbacks.onDoubleClickCanvas == null ? void 0 : callbacks.onDoubleClickCanvas(info, e);\n    }\n\n    callbacks.onReleaseCanvas == null ? void 0 : callbacks.onReleaseCanvas(info, e);\n    callbacks.onPointerUp == null ? void 0 : callbacks.onPointerUp(info, e);\n  }, [callbacks]);\n  return {\n    onPointerDown: onPointerDown,\n    onPointerMove: onPointerMove,\n    onPointerUp: onPointerUp\n  };\n}\n\nfunction useShapeEvents(id, disable) {\n  if (disable === void 0) {\n    disable = false;\n  }\n\n  var _useTLContext = useTLContext(),\n      callbacks = _useTLContext.callbacks;\n\n  var onPointerDown = React.useCallback(function (e) {\n    var _e$currentTarget;\n\n    if (disable) return;\n    e.stopPropagation();\n    (_e$currentTarget = e.currentTarget) == null ? void 0 : _e$currentTarget.setPointerCapture(e.pointerId);\n    var info = inputs.pointerDown(e, id);\n    callbacks.onPointShape == null ? void 0 : callbacks.onPointShape(info, e);\n    callbacks.onPointerDown == null ? void 0 : callbacks.onPointerDown(info, e);\n  }, [callbacks, id, disable]);\n  var onPointerUp = React.useCallback(function (e) {\n    if (disable) return;\n    e.stopPropagation();\n    var isDoubleClick = inputs.isDoubleClick();\n    var info = inputs.pointerUp(e, id);\n\n    if (e.currentTarget.hasPointerCapture(e.pointerId)) {\n      var _e$currentTarget2;\n\n      (_e$currentTarget2 = e.currentTarget) == null ? void 0 : _e$currentTarget2.releasePointerCapture(e.pointerId);\n    }\n\n    if (isDoubleClick && !(info.altKey || info.metaKey)) {\n      callbacks.onDoubleClickShape == null ? void 0 : callbacks.onDoubleClickShape(info, e);\n    }\n\n    callbacks.onReleaseShape == null ? void 0 : callbacks.onReleaseShape(info, e);\n    callbacks.onPointerUp == null ? void 0 : callbacks.onPointerUp(info, e);\n  }, [callbacks, id, disable]);\n  var onPointerMove = React.useCallback(function (e) {\n    if (disable) return;\n    e.stopPropagation();\n    if (inputs.pointer && e.pointerId !== inputs.pointer.pointerId) return;\n    var info = inputs.pointerMove(e, id);\n\n    if (e.currentTarget.hasPointerCapture(e.pointerId)) {\n      callbacks.onDragShape == null ? void 0 : callbacks.onDragShape(info, e);\n    }\n\n    callbacks.onPointerMove == null ? void 0 : callbacks.onPointerMove(info, e);\n  }, [callbacks, id, disable]);\n  var onPointerEnter = React.useCallback(function (e) {\n    if (disable) return;\n    var info = inputs.pointerEnter(e, id);\n    callbacks.onHoverShape == null ? void 0 : callbacks.onHoverShape(info, e);\n  }, [callbacks, id, disable]);\n  var onPointerLeave = React.useCallback(function (e) {\n    if (disable) return;\n    var info = inputs.pointerEnter(e, id);\n    callbacks.onUnhoverShape == null ? void 0 : callbacks.onUnhoverShape(info, e);\n  }, [callbacks, id, disable]);\n  var onTouchStart = React.useCallback(function (e) {\n    e.preventDefault();\n  }, []);\n  var onTouchEnd = React.useCallback(function (e) {\n    e.preventDefault();\n  }, []);\n  return {\n    onPointerDown: onPointerDown,\n    onPointerUp: onPointerUp,\n    onPointerEnter: onPointerEnter,\n    onPointerMove: onPointerMove,\n    onPointerLeave: onPointerLeave,\n    onTouchStart: onTouchStart,\n    onTouchEnd: onTouchEnd\n  };\n}\n\nfunction addToShapeTree(shape, branch, shapes, selectedIds, info) {\n  var node = {\n    shape: shape,\n    isHovered: info.hoveredId === shape.id,\n    isCurrentParent: info.currentParentId === shape.id,\n    isEditing: info.editingId === shape.id,\n    isBinding: info.bindingId === shape.id,\n    isDarkMode: info.isDarkMode || false,\n    isSelected: selectedIds.includes(shape.id)\n  };\n  branch.push(node);\n\n  if (shape.children) {\n    node.children = [];\n    shape.children.map(function (id) {\n      return shapes[id];\n    }).sort(function (a, b) {\n      return a.childIndex - b.childIndex;\n    }).forEach(function (childShape) {\n      return (// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        addToShapeTree(childShape, node.children, shapes, selectedIds, info)\n      );\n    });\n  }\n}\n\nfunction useShapeTree(page, pageState, shapeUtils, info, onChange) {\n  if (info === void 0) {\n    info = {};\n  }\n\n  var rPreviousCount = React.useRef(0);\n  if (typeof window === 'undefined') return [];\n  var selectedIds = pageState.selectedIds,\n      camera = pageState.camera; // Find viewport\n\n  var _Vec$sub = Vec.sub(Vec.div([0, 0], camera.zoom), camera.point),\n      minX = _Vec$sub[0],\n      minY = _Vec$sub[1];\n\n  var _Vec$sub2 = Vec.sub(Vec.div([window.innerWidth, window.innerHeight], camera.zoom), camera.point),\n      maxX = _Vec$sub2[0],\n      maxY = _Vec$sub2[1];\n\n  var viewport = {\n    minX: minX,\n    minY: minY,\n    maxX: maxX,\n    maxY: maxY,\n    height: maxX - minX,\n    width: maxY - minY\n  }; // Filter shapes that are in view\n\n  var shapesToRender = Object.values(page.shapes).filter(function (shape) {\n    if (shape.parentId !== page.id) return false; // Don't hide selected shapes (this breaks certain drag interactions)\n\n    if (pageState.selectedIds.includes(shape.id)) return true;\n    var shapeBounds = shapeUtils[shape.type].getBounds(shape);\n    return (// TODO: Some shapes should always render (lines, rays)\n      Utils.boundsContain(viewport, shapeBounds) || Utils.boundsCollide(viewport, shapeBounds)\n    );\n  }); // Call onChange callback when number of rendering shapes changes\n\n  if (shapesToRender.length !== rPreviousCount.current) {\n    setTimeout(function () {\n      return onChange == null ? void 0 : onChange(shapesToRender.map(function (shape) {\n        return shape.id;\n      }));\n    }, 0);\n    rPreviousCount.current = shapesToRender.length;\n  } // Populate the shape tree\n\n\n  var tree = [];\n  shapesToRender.sort(function (a, b) {\n    return a.childIndex - b.childIndex;\n  }).forEach(function (shape) {\n    return addToShapeTree(shape, tree, page.shapes, selectedIds, info);\n  });\n  return tree;\n}\n\nvar _templateObject;\nvar styles = /*#__PURE__*/new Map();\n\nfunction makeCssTheme(prefix, theme) {\n  return Object.keys(theme).reduce(function (acc, key) {\n    var value = theme[key];\n\n    if (value) {\n      return acc + (\"--\" + prefix + \"-\" + key + \": \" + value + \";\\n\");\n    }\n\n    return acc;\n  }, '');\n}\n\nfunction useTheme(prefix, theme, selector) {\n  if (selector === void 0) {\n    selector = ':root';\n  }\n\n  React.useLayoutEffect(function () {\n    var style = document.createElement('style');\n    var cssTheme = makeCssTheme(prefix, theme);\n    style.setAttribute('id', prefix + \"-theme\");\n    style.setAttribute('data-selector', selector);\n    style.innerHTML = \"\\n        \" + selector + \" {\\n          \" + cssTheme + \"\\n        }\\n      \";\n    document.head.appendChild(style);\n    return function () {\n      if (style && document.head.contains(style)) {\n        document.head.removeChild(style);\n      }\n    };\n  }, [prefix, theme, selector]);\n}\n\nfunction useStyle(uid, rules) {\n  React.useLayoutEffect(function () {\n    if (styles.get(uid)) {\n      return;\n    }\n\n    var style = document.createElement('style');\n    style.innerHTML = rules;\n    style.setAttribute('id', uid);\n    document.head.appendChild(style);\n    styles.set(uid, style);\n    return function () {\n      if (style && document.head.contains(style)) {\n        document.head.removeChild(style);\n        styles[\"delete\"](uid);\n      }\n    };\n  }, [uid, rules]);\n}\n\nvar css = function css(strings) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return strings.reduce(function (acc, string, index) {\n    return acc + string + (index < args.length ? args[index] : '');\n  }, '');\n};\n\nvar defaultTheme = {\n  brushFill: 'rgba(0,0,0,.05)',\n  brushStroke: 'rgba(0,0,0,.25)',\n  selectStroke: 'rgb(66, 133, 244)',\n  selectFill: 'rgba(65, 132, 244, 0.05)',\n  background: 'rgb(248, 249, 250)',\n  foreground: 'rgb(51, 51, 51)'\n};\nvar tlcss = /*#__PURE__*/css(_templateObject || (_templateObject = /*#__PURE__*/_taggedTemplateLiteralLoose([\"\\n  :root {\\n    --tl-zoom: 1;\\n    --tl-scale: calc(1 / var(--tl-zoom));\\n  }\\n\\n  .tl-counter-scaled {\\n    transform: scale(var(--tl-scale));\\n  }\\n\\n  .tl-dashed {\\n    stroke-dasharray: calc(2px * var(--tl-scale)), calc(2px * var(--tl-scale));\\n  }\\n\\n  .tl-transparent {\\n    fill: transparent;\\n    stroke: transparent;\\n  }\\n\\n  .tl-cursor-ns {\\n    cursor: ns-resize;\\n  }\\n\\n  .tl-cursor-ew {\\n    cursor: ew-resize;\\n  }\\n\\n  .tl-cursor-nesw {\\n    cursor: nesw-resize;\\n  }\\n\\n  .tl-cursor-nwse {\\n    cursor: nwse-resize;\\n  }\\n\\n  .tl-corner-handle {\\n    stroke: var(--tl-selectStroke);\\n    fill: var(--tl-background);\\n    stroke-width: calc(1.5px * var(--tl-scale));\\n  }\\n\\n  .tl-rotate-handle {\\n    stroke: var(--tl-selectStroke);\\n    fill: var(--tl-background);\\n    stroke-width: calc(1.5px * var(--tl-scale));\\n    cursor: grab;\\n  }\\n\\n  .tl-handle {\\n    transform: scale(var(--tl-scale));\\n    fill: var(--tl-background);\\n    stroke: var(--tl-stroke);\\n    stroke-width: calc(2px * var(--tl-scale));\\n    pointer-events: all;\\n  }\\n\\n  .tl-binding {\\n    fill: var(--tl-selectFill);\\n    stroke: var(--tl-selectStroke);\\n    stroke-width: calc(1px * var(--tl-scale));\\n    pointer-events: none;\\n  }\\n\\n  .tl-bounds-center {\\n    fill: transparent;\\n    stroke: var(--tl-selectStroke);\\n    stroke-width: calc(1.5px * var(--tl-scale));\\n  }\\n\\n  .tl-bounds-bg {\\n    stroke: none;\\n    fill: var(--tl-selectFill);\\n    pointer-events: all;\\n  }\\n\\n  .tl-brush {\\n    fill: var(--tl-brushFill);\\n    stroke: var(--tl-brushStroke);\\n    stroke-width: calc(1px * var(--tl-scale));\\n    pointer-events: none;\\n  }\\n\\n  .tl-canvas {\\n    position: fixed;\\n    overflow: hidden;\\n    top: 0px;\\n    left: 0px;\\n    width: 100%;\\n    height: 100%;\\n    touch-action: none;\\n    z-index: 100;\\n    pointer-events: all;\\n  }\\n\\n  .tl-container {\\n    position: relative;\\n    box-sizing: border-box;\\n    width: 100%;\\n    height: 100%;\\n    padding: 0px;\\n    margin: 0px;\\n    overscroll-behavior: none;\\n    overscroll-behavior-x: none;\\n    background-color: var(--tl-background);\\n  }\\n\\n  .tl-container * {\\n    user-select: none;\\n  }\\n\\n  .tl-dot {\\n    fill: var(--tl-background);\\n    stroke: var(--tl-foreground);\\n    stroke-width: 2px;\\n  }\\n\\n  .tl-handle {\\n    fill: var(--tl-background);\\n    stroke: var(--tl-selectStroke);\\n    stroke-width: calc(1.5px * var(--tl-scale));\\n  }\\n\\n  .tl-handle-bg {\\n    fill: transparent;\\n    stroke: none;\\n    opacity: 0.2;\\n    pointer-events: all;\\n  }\\n\\n  .tl-handle-bg:hover {\\n    fill: var(--tl-selected-fill);\\n  }\\n\\n  .tl-handle-bg:hover > * {\\n    stroke: var(--tl-selected-fill);\\n  }\\n\\n  .tl-handle-bg:active {\\n    fill: var(--tl-selected-fill);\\n    stroke: var(--tl-selected-fill);\\n  }\\n\\n  .tl-binding-indicator {\\n    stroke-width: calc(3px * var(--tl-scale));\\n    fill: none;\\n    stroke: var(--tl-selected);\\n  }\\n\\n  .tl-shape-group {\\n    outline: none;\\n  }\\n\\n  .tl-shape-group > *[data-shy='true'] {\\n    opacity: 0;\\n  }\\n\\n  .tl-shape-group:hover > *[data-shy='true'] {\\n    opacity: 1;\\n  }\\n\\n  .tl-current-parent > *[data-shy='true'] {\\n    opacity: 1;\\n  }\\n\"])));\nfunction useTLTheme(theme) {\n  var _React$useState = React.useState(function () {\n    return _extends({}, defaultTheme, theme);\n  }),\n      tltheme = _React$useState[0];\n\n  useTheme('tl', tltheme);\n  useStyle('tl-canvas', tlcss);\n}\n\nfunction useBoundsHandleEvents(id) {\n  var _useTLContext = useTLContext(),\n      callbacks = _useTLContext.callbacks;\n\n  var onPointerDown = React.useCallback(function (e) {\n    var _e$currentTarget;\n\n    e.stopPropagation();\n    (_e$currentTarget = e.currentTarget) == null ? void 0 : _e$currentTarget.setPointerCapture(e.pointerId);\n    var info = inputs.pointerDown(e, id);\n    callbacks.onPointBoundsHandle == null ? void 0 : callbacks.onPointBoundsHandle(info, e);\n    callbacks.onPointerDown == null ? void 0 : callbacks.onPointerDown(info, e);\n  }, [callbacks, id]);\n  var onPointerUp = React.useCallback(function (e) {\n    e.stopPropagation();\n    var isDoubleClick = inputs.isDoubleClick();\n    var info = inputs.pointerUp(e, id);\n\n    if (e.currentTarget.hasPointerCapture(e.pointerId)) {\n      var _e$currentTarget2;\n\n      (_e$currentTarget2 = e.currentTarget) == null ? void 0 : _e$currentTarget2.releasePointerCapture(e.pointerId);\n    }\n\n    if (isDoubleClick && !(info.altKey || info.metaKey)) {\n      callbacks.onDoubleClickBoundsHandle == null ? void 0 : callbacks.onDoubleClickBoundsHandle(info, e);\n    }\n\n    callbacks.onReleaseBoundsHandle == null ? void 0 : callbacks.onReleaseBoundsHandle(info, e);\n    callbacks.onPointerUp == null ? void 0 : callbacks.onPointerUp(info, e);\n  }, [callbacks, id]);\n  var onPointerMove = React.useCallback(function (e) {\n    // e.stopPropagation()\n    if (e.currentTarget.hasPointerCapture(e.pointerId)) {\n      callbacks.onDragBoundsHandle == null ? void 0 : callbacks.onDragBoundsHandle(inputs.pointerMove(e, id), e);\n    }\n\n    var info = inputs.pointerMove(e, id);\n    callbacks.onPointerMove == null ? void 0 : callbacks.onPointerMove(info, e);\n    e.stopPropagation();\n  }, [callbacks, id]);\n  var onPointerEnter = React.useCallback(function (e) {\n    callbacks.onHoverBoundsHandle == null ? void 0 : callbacks.onHoverBoundsHandle(inputs.pointerEnter(e, id), e);\n  }, [callbacks, id]);\n  var onPointerLeave = React.useCallback(function (e) {\n    callbacks.onUnhoverBoundsHandle == null ? void 0 : callbacks.onUnhoverBoundsHandle(inputs.pointerEnter(e, id), e);\n  }, [callbacks, id]);\n  var onTouchStart = React.useCallback(function (e) {\n    e.preventDefault();\n  }, []);\n  var onTouchEnd = React.useCallback(function (e) {\n    e.preventDefault();\n  }, []);\n  return {\n    onPointerDown: onPointerDown,\n    onPointerUp: onPointerUp,\n    onPointerEnter: onPointerEnter,\n    onPointerMove: onPointerMove,\n    onPointerLeave: onPointerLeave,\n    onTouchStart: onTouchStart,\n    onTouchEnd: onTouchEnd\n  };\n}\n\nfunction useCameraCss(pageState) {\n  var rGroup = React.useRef(null); // Update the tl-zoom CSS variable when the zoom changes\n\n  React.useEffect(function () {\n    document.documentElement.style.setProperty('--tl-zoom', pageState.camera.zoom.toString());\n  }, [pageState.camera.zoom]); // Update the group's position when the camera moves or zooms\n\n  React.useEffect(function () {\n    var _rGroup$current;\n\n    var _pageState$camera = pageState.camera,\n        zoom = _pageState$camera.zoom,\n        point = _pageState$camera.point;\n    (_rGroup$current = rGroup.current) == null ? void 0 : _rGroup$current.setAttribute('transform', \"scale(\" + zoom + \") translate(\" + point[0] + \" \" + point[1] + \")\");\n  }, [pageState.camera]);\n  return rGroup;\n}\n\nfunction useRenderOnResize() {\n  var forceUpdate = React.useReducer(function (x) {\n    return x + 1;\n  }, 0)[1];\n  React.useEffect(function () {\n    var debouncedUpdate = Utils.debounce(forceUpdate, 96);\n    window.addEventListener('resize', debouncedUpdate);\n    return function () {\n      window.removeEventListener('resize', debouncedUpdate);\n    };\n  }, [forceUpdate]);\n}\n\nfunction useSelection(page, pageState, shapeUtils) {\n  var selectedIds = pageState.selectedIds;\n  var bounds = undefined;\n  var rotation = 0;\n  var isLocked = false;\n\n  if (selectedIds.length === 1) {\n    var id = selectedIds[0];\n    var shape = page.shapes[id];\n    rotation = shape.rotation || 0;\n    isLocked = shape.isLocked || false;\n    bounds = shapeUtils[shape.type].getBounds(shape);\n  } else if (selectedIds.length > 1) {\n    var selectedShapes = selectedIds.map(function (id) {\n      return page.shapes[id];\n    });\n    rotation = 0;\n    isLocked = selectedShapes.every(function (shape) {\n      return shape.isLocked;\n    });\n    bounds = selectedShapes.reduce(function (acc, shape, i) {\n      if (i === 0) {\n        return shapeUtils[shape.type].getRotatedBounds(shape);\n      }\n\n      return Utils.getExpandedBounds(acc, shapeUtils[shape.type].getRotatedBounds(shape));\n    }, {});\n  }\n\n  return {\n    bounds: bounds,\n    rotation: rotation,\n    isLocked: isLocked\n  };\n}\n\nfunction useHandleEvents(id) {\n  var _useTLContext = useTLContext(),\n      callbacks = _useTLContext.callbacks;\n\n  var onPointerDown = React.useCallback(function (e) {\n    var _e$currentTarget;\n\n    e.stopPropagation();\n    (_e$currentTarget = e.currentTarget) == null ? void 0 : _e$currentTarget.setPointerCapture(e.pointerId);\n    var info = inputs.pointerDown(e, id);\n    callbacks.onPointHandle == null ? void 0 : callbacks.onPointHandle(info, e);\n    callbacks.onPointerDown == null ? void 0 : callbacks.onPointerDown(info, e);\n  }, [callbacks, id]);\n  var onPointerUp = React.useCallback(function (e) {\n    e.stopPropagation();\n    var isDoubleClick = inputs.isDoubleClick();\n    var info = inputs.pointerUp(e, 'bounds');\n\n    if (e.currentTarget.hasPointerCapture(e.pointerId)) {\n      var _e$currentTarget2;\n\n      (_e$currentTarget2 = e.currentTarget) == null ? void 0 : _e$currentTarget2.releasePointerCapture(e.pointerId);\n\n      if (isDoubleClick && !(info.altKey || info.metaKey)) {\n        callbacks.onDoubleClickHandle == null ? void 0 : callbacks.onDoubleClickHandle(info, e);\n      }\n\n      callbacks.onReleaseHandle == null ? void 0 : callbacks.onReleaseHandle(info, e);\n    }\n\n    callbacks.onPointerUp == null ? void 0 : callbacks.onPointerUp(info, e);\n  }, [callbacks]);\n  var onPointerMove = React.useCallback(function (e) {\n    // e.stopPropagation()\n    if (e.currentTarget.hasPointerCapture(e.pointerId)) {\n      var _info = inputs.pointerMove(e, id);\n\n      callbacks.onDragHandle == null ? void 0 : callbacks.onDragHandle(_info, e);\n    }\n\n    var info = inputs.pointerMove(e, id);\n    callbacks.onPointerMove == null ? void 0 : callbacks.onPointerMove(info, e);\n    e.stopPropagation();\n  }, [callbacks, id]);\n  var onPointerEnter = React.useCallback(function (e) {\n    var info = inputs.pointerEnter(e, id);\n    callbacks.onHoverHandle == null ? void 0 : callbacks.onHoverHandle(info, e);\n  }, [callbacks, id]);\n  var onPointerLeave = React.useCallback(function (e) {\n    var info = inputs.pointerEnter(e, id);\n    callbacks.onUnhoverHandle == null ? void 0 : callbacks.onUnhoverHandle(info, e);\n  }, [callbacks, id]);\n  var onTouchStart = React.useCallback(function (e) {\n    e.preventDefault();\n  }, []);\n  var onTouchEnd = React.useCallback(function (e) {\n    e.preventDefault();\n  }, []);\n  return {\n    onPointerDown: onPointerDown,\n    onPointerUp: onPointerUp,\n    onPointerEnter: onPointerEnter,\n    onPointerMove: onPointerMove,\n    onPointerLeave: onPointerLeave,\n    onTouchStart: onTouchStart,\n    onTouchEnd: onTouchEnd\n  };\n}\n\nfunction useHandles(page, pageState) {\n  var selectedIds = pageState.selectedIds;\n  var shapeWithHandles = undefined;\n\n  if (selectedIds.length === 1) {\n    var id = selectedIds[0];\n    var shape = page.shapes[id];\n\n    if (shape.handles !== undefined) {\n      shapeWithHandles = shape;\n    }\n  }\n\n  return {\n    shapeWithHandles: shapeWithHandles\n  };\n}\n\nvar ErrorFallback = /*#__PURE__*/React.memo(function (_ref) {\n  var error = _ref.error,\n      resetErrorBoundary = _ref.resetErrorBoundary;\n\n  var _useTLContext = useTLContext(),\n      callbacks = _useTLContext.callbacks;\n\n  React.useEffect(function () {\n    callbacks.onError == null ? void 0 : callbacks.onError(error);\n    console.error(error);\n  }, [error, resetErrorBoundary, callbacks]);\n  return null;\n});\n\nvar BrushUpdater = /*#__PURE__*/function () {\n  function BrushUpdater() {\n    this.ref = React.createRef();\n    this.isControlled = false;\n  }\n\n  var _proto = BrushUpdater.prototype;\n\n  _proto.set = function set(bounds) {\n    var _this$ref;\n\n    if (!this.isControlled) this.isControlled = true;\n\n    if (!bounds) {\n      this.clear();\n      return;\n    }\n\n    var elm = (_this$ref = this.ref) == null ? void 0 : _this$ref.current;\n    if (!elm) return;\n    elm.setAttribute('opacity', '1');\n    elm.setAttribute('x', bounds.minX.toString());\n    elm.setAttribute('y', bounds.minY.toString());\n    elm.setAttribute('width', bounds.width.toString());\n    elm.setAttribute('height', bounds.height.toString());\n  };\n\n  _proto.clear = function clear() {\n    var _this$ref2;\n\n    var elm = (_this$ref2 = this.ref) == null ? void 0 : _this$ref2.current;\n    if (!elm) return;\n    elm.setAttribute('opacity', '0');\n    elm.setAttribute('width', '0');\n    elm.setAttribute('height', '0');\n  };\n\n  return BrushUpdater;\n}();\n\nvar brushUpdater = /*#__PURE__*/new BrushUpdater();\nvar Brush = /*#__PURE__*/React.memo(function (_ref) {\n  return React.createElement(\"rect\", {\n    ref: brushUpdater.ref,\n    className: \"tl-brush\",\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  });\n}, // Once the brush is controlled, never update again from props\nfunction (prev, next) {\n  return true;\n});\n\nfunction Defs(_ref) {\n  var zoom = _ref.zoom;\n  return React.createElement(\"defs\", null, React.createElement(\"circle\", {\n    id: \"dot\",\n    className: \"tl-counter-scaled tl-dot\",\n    r: 4\n  }), React.createElement(\"circle\", {\n    id: \"handle\",\n    className: \"tl-counter-scaled tl-handle\",\n    r: 4\n  }), React.createElement(\"g\", {\n    id: \"cross\",\n    className: \"tl-binding-indicator\"\n  }, React.createElement(\"line\", {\n    x1: -6,\n    y1: -6,\n    x2: 6,\n    y2: 6\n  }), React.createElement(\"line\", {\n    x1: 6,\n    y1: -6,\n    x2: -6,\n    y2: 6\n  })), React.createElement(\"filter\", {\n    id: \"expand\"\n  }, React.createElement(\"feMorphology\", {\n    operator: \"dilate\",\n    radius: 0.5 / zoom\n  })));\n}\n\nvar RenderedShape = /*#__PURE__*/React.memo(function RenderedShape(_ref) {\n  var shape = _ref.shape,\n      utils = _ref.utils,\n      isEditing = _ref.isEditing,\n      isHovered = _ref.isHovered,\n      isBinding = _ref.isBinding,\n      isSelected = _ref.isSelected,\n      isDarkMode = _ref.isDarkMode,\n      isCurrentParent = _ref.isCurrentParent;\n  return utils.render(shape, {\n    isEditing: isEditing,\n    isHovered: isHovered,\n    isSelected: isSelected,\n    isBinding: isBinding,\n    isDarkMode: isDarkMode,\n    isCurrentParent: isCurrentParent\n  });\n}, function (prev, next) {\n  if (prev.isEditing !== next.isEditing || prev.isHovered !== next.isHovered || prev.isSelected !== next.isSelected || prev.isDarkMode !== next.isDarkMode || prev.isBinding !== next.isBinding || prev.isCurrentParent !== next.isCurrentParent) {\n    return false;\n  }\n\n  if (next.shape !== prev.shape) {\n    return !next.utils.shouldRender(next.shape, prev.shape);\n  }\n\n  return true;\n});\n\nfunction EditingTextShape(_ref) {\n  var shape = _ref.shape,\n      utils = _ref.utils,\n      isEditing = _ref.isEditing,\n      isHovered = _ref.isHovered,\n      isBinding = _ref.isBinding,\n      isSelected = _ref.isSelected,\n      isDarkMode = _ref.isDarkMode,\n      isCurrentParent = _ref.isCurrentParent;\n  var ref = React.useRef(null);\n  return utils.render(shape, {\n    ref: ref,\n    isEditing: isEditing,\n    isHovered: isHovered,\n    isSelected: isSelected,\n    isCurrentParent: isCurrentParent,\n    isBinding: isBinding,\n    isDarkMode: isDarkMode\n  });\n}\n\nvar Shape = /*#__PURE__*/React.memo(function (_ref) {\n  var shape = _ref.shape,\n      isEditing = _ref.isEditing,\n      isHovered = _ref.isHovered,\n      isSelected = _ref.isSelected,\n      isBinding = _ref.isBinding,\n      isDarkMode = _ref.isDarkMode,\n      isCurrentParent = _ref.isCurrentParent;\n\n  var _useTLContext = useTLContext(),\n      shapeUtils = _useTLContext.shapeUtils;\n\n  var events = useShapeEvents(shape.id, isCurrentParent);\n  var utils = shapeUtils[shape.type];\n  var center = utils.getCenter(shape);\n  var rotation = (shape.rotation || 0) * (180 / Math.PI);\n  var transform = \"rotate(\" + rotation + \", \" + center + \") translate(\" + shape.point + \")\";\n  return React.createElement(\"g\", _extends({\n    className: isCurrentParent ? 'tl-shape-group tl-current-parent' : 'tl-shape-group',\n    id: shape.id,\n    transform: transform,\n    filter: isHovered ? 'url(#expand)' : 'none'\n  }, events), isEditing && utils.isEditableText ? React.createElement(EditingTextShape, {\n    shape: shape,\n    isBinding: false,\n    isCurrentParent: false,\n    isDarkMode: isDarkMode,\n    isEditing: true,\n    isHovered: false,\n    isSelected: false,\n    utils: utils\n  }) : React.createElement(RenderedShape, {\n    shape: shape,\n    utils: utils,\n    isBinding: isBinding,\n    isCurrentParent: isCurrentParent,\n    isDarkMode: isDarkMode,\n    isEditing: isEditing,\n    isHovered: isHovered,\n    isSelected: isSelected\n  }));\n});\n\nvar CenterHandle = /*#__PURE__*/React.memo(function (_ref) {\n  var bounds = _ref.bounds,\n      isLocked = _ref.isLocked;\n  return React.createElement(\"rect\", {\n    className: isLocked ? 'tl-bounds-center tl-dashed' : 'tl-bounds-center',\n    x: -1,\n    y: -1,\n    width: bounds.width + 2,\n    height: bounds.height + 2,\n    pointerEvents: \"none\"\n  });\n});\n\nvar RotateHandle = /*#__PURE__*/React.memo(function (_ref) {\n  var bounds = _ref.bounds,\n      size = _ref.size;\n  var events = useBoundsHandleEvents('rotate');\n  return React.createElement(\"g\", {\n    cursor: \"grab\"\n  }, React.createElement(\"circle\", _extends({\n    cx: bounds.width / 2,\n    cy: size * -2,\n    r: size * 2,\n    fill: \"transparent\",\n    stroke: \"none\",\n    pointerEvents: \"all\"\n  }, events)), React.createElement(\"circle\", {\n    className: \"tl-rotate-handle\",\n    cx: bounds.width / 2,\n    cy: size * -2,\n    r: size / 2,\n    pointerEvents: \"none\"\n  }));\n});\n\nvar _cornerBgClassnames;\nvar cornerBgClassnames = (_cornerBgClassnames = {}, _cornerBgClassnames[exports.TLBoundsCorner.TopLeft] = 'tl-transparent tl-cursor-nwse', _cornerBgClassnames[exports.TLBoundsCorner.TopRight] = 'tl-transparent tl-cursor-nesw', _cornerBgClassnames[exports.TLBoundsCorner.BottomRight] = 'tl-transparent tl-cursor-nwse', _cornerBgClassnames[exports.TLBoundsCorner.BottomLeft] = 'tl-transparent tl-cursor-nesw', _cornerBgClassnames);\nvar CornerHandle = /*#__PURE__*/React.memo(function (_ref) {\n  var size = _ref.size,\n      corner = _ref.corner,\n      bounds = _ref.bounds;\n  var events = useBoundsHandleEvents(corner);\n  var isTop = corner === exports.TLBoundsCorner.TopLeft || corner === exports.TLBoundsCorner.TopRight;\n  var isLeft = corner === exports.TLBoundsCorner.TopLeft || corner === exports.TLBoundsCorner.BottomLeft;\n  return React.createElement(\"g\", null, React.createElement(\"rect\", _extends({\n    className: cornerBgClassnames[corner],\n    x: (isLeft ? -1 : bounds.width + 1) - size,\n    y: (isTop ? -1 : bounds.height + 1) - size,\n    width: size * 2,\n    height: size * 2,\n    pointerEvents: \"all\"\n  }, events)), React.createElement(\"rect\", {\n    className: \"tl-corner-handle\",\n    x: (isLeft ? -1 : bounds.width + 1) - size / 2,\n    y: (isTop ? -1 : bounds.height + 1) - size / 2,\n    width: size,\n    height: size,\n    pointerEvents: \"none\"\n  }));\n});\n\nvar _edgeClassnames;\nvar edgeClassnames = (_edgeClassnames = {}, _edgeClassnames[exports.TLBoundsEdge.Top] = 'tl-transparent tl-cursor-ns', _edgeClassnames[exports.TLBoundsEdge.Right] = 'tl-transparent tl-cursor-ew', _edgeClassnames[exports.TLBoundsEdge.Bottom] = 'tl-transparent tl-cursor-ns', _edgeClassnames[exports.TLBoundsEdge.Left] = 'tl-transparent tl-cursor-ew', _edgeClassnames);\nvar EdgeHandle = /*#__PURE__*/React.memo(function (_ref) {\n  var size = _ref.size,\n      bounds = _ref.bounds,\n      edge = _ref.edge;\n  var events = useBoundsHandleEvents(edge);\n  var isHorizontal = edge === exports.TLBoundsEdge.Top || edge === exports.TLBoundsEdge.Bottom;\n  var isFarEdge = edge === exports.TLBoundsEdge.Right || edge === exports.TLBoundsEdge.Bottom;\n  var height = bounds.height,\n      width = bounds.width;\n  return React.createElement(\"rect\", _extends({\n    className: edgeClassnames[edge],\n    x: isHorizontal ? size / 2 : (isFarEdge ? width + 1 : -1) - size / 2,\n    y: isHorizontal ? (isFarEdge ? height + 1 : -1) - size / 2 : size / 2,\n    width: isHorizontal ? Math.max(0, width + 1 - size) : size,\n    height: isHorizontal ? size : Math.max(0, height + 1 - size)\n  }, events));\n});\n\nfunction Bounds(_ref) {\n  var zoom = _ref.zoom,\n      bounds = _ref.bounds,\n      rotation = _ref.rotation,\n      isLocked = _ref.isLocked;\n  var size = (Utils.isMobile() ? 10 : 8) / zoom; // Touch target size\n\n  var center = Utils.getBoundsCenter(bounds);\n  return React.createElement(\"g\", {\n    pointerEvents: \"all\",\n    transform: \"\\n        rotate(\" + rotation * (180 / Math.PI) + \",\" + center + \")\\n        translate(\" + bounds.minX + \",\" + bounds.minY + \")\\n        rotate(\" + (bounds.rotation || 0) * (180 / Math.PI) + \", 0, 0)\"\n  }, React.createElement(CenterHandle, {\n    bounds: bounds,\n    isLocked: isLocked\n  }), !isLocked && React.createElement(React.Fragment, null, React.createElement(EdgeHandle, {\n    size: size,\n    bounds: bounds,\n    edge: exports.TLBoundsEdge.Top\n  }), React.createElement(EdgeHandle, {\n    size: size,\n    bounds: bounds,\n    edge: exports.TLBoundsEdge.Right\n  }), React.createElement(EdgeHandle, {\n    size: size,\n    bounds: bounds,\n    edge: exports.TLBoundsEdge.Bottom\n  }), React.createElement(EdgeHandle, {\n    size: size,\n    bounds: bounds,\n    edge: exports.TLBoundsEdge.Left\n  }), React.createElement(CornerHandle, {\n    size: size,\n    bounds: bounds,\n    corner: exports.TLBoundsCorner.TopLeft\n  }), React.createElement(CornerHandle, {\n    size: size,\n    bounds: bounds,\n    corner: exports.TLBoundsCorner.TopRight\n  }), React.createElement(CornerHandle, {\n    size: size,\n    bounds: bounds,\n    corner: exports.TLBoundsCorner.BottomRight\n  }), React.createElement(CornerHandle, {\n    size: size,\n    bounds: bounds,\n    corner: exports.TLBoundsCorner.BottomLeft\n  }), React.createElement(RotateHandle, {\n    size: size,\n    bounds: bounds\n  })));\n}\n\nfunction useBoundsEvents() {\n  var _useTLContext = useTLContext(),\n      callbacks = _useTLContext.callbacks;\n\n  var onPointerDown = React.useCallback(function (e) {\n    var _e$currentTarget;\n\n    e.stopPropagation();\n    (_e$currentTarget = e.currentTarget) == null ? void 0 : _e$currentTarget.setPointerCapture(e.pointerId);\n    var info = inputs.pointerDown(e, 'bounds');\n    callbacks.onPointBounds == null ? void 0 : callbacks.onPointBounds(info, e);\n    callbacks.onPointerDown == null ? void 0 : callbacks.onPointerDown(info, e);\n  }, [callbacks]);\n  var onPointerUp = React.useCallback(function (e) {\n    e.stopPropagation();\n    var isDoubleClick = inputs.isDoubleClick();\n    var info = inputs.pointerUp(e, 'bounds');\n\n    if (e.currentTarget.hasPointerCapture(e.pointerId)) {\n      var _e$currentTarget2;\n\n      (_e$currentTarget2 = e.currentTarget) == null ? void 0 : _e$currentTarget2.releasePointerCapture(e.pointerId);\n    }\n\n    if (isDoubleClick && !(info.altKey || info.metaKey)) {\n      callbacks.onDoubleClickBounds == null ? void 0 : callbacks.onDoubleClickBounds(info, e);\n    }\n\n    callbacks.onReleaseBounds == null ? void 0 : callbacks.onReleaseBounds(info, e);\n    callbacks.onPointerUp == null ? void 0 : callbacks.onPointerUp(info, e);\n  }, [callbacks]);\n  var onPointerMove = React.useCallback(function (e) {\n    e.stopPropagation();\n    if (inputs.pointer && e.pointerId !== inputs.pointer.pointerId) return;\n\n    if (e.currentTarget.hasPointerCapture(e.pointerId)) {\n      callbacks.onDragBounds == null ? void 0 : callbacks.onDragBounds(inputs.pointerMove(e, 'bounds'), e);\n    }\n\n    var info = inputs.pointerMove(e, 'bounds');\n    callbacks.onPointerMove == null ? void 0 : callbacks.onPointerMove(info, e);\n  }, [callbacks]);\n  var onPointerEnter = React.useCallback(function (e) {\n    callbacks.onHoverBounds == null ? void 0 : callbacks.onHoverBounds(inputs.pointerEnter(e, 'bounds'), e);\n  }, [callbacks]);\n  var onPointerLeave = React.useCallback(function (e) {\n    callbacks.onUnhoverBounds == null ? void 0 : callbacks.onUnhoverBounds(inputs.pointerEnter(e, 'bounds'), e);\n  }, [callbacks]);\n  var onTouchStart = React.useCallback(function (e) {\n    e.preventDefault();\n  }, []);\n  var onTouchEnd = React.useCallback(function (e) {\n    e.preventDefault();\n  }, []);\n  return {\n    onPointerDown: onPointerDown,\n    onPointerUp: onPointerUp,\n    onPointerEnter: onPointerEnter,\n    onPointerMove: onPointerMove,\n    onPointerLeave: onPointerLeave,\n    onTouchStart: onTouchStart,\n    onTouchEnd: onTouchEnd\n  };\n}\n\nfunction BoundsBg(_ref) {\n  var bounds = _ref.bounds,\n      rotation = _ref.rotation;\n  var events = useBoundsEvents();\n  var width = bounds.width,\n      height = bounds.height;\n  var center = Utils.getBoundsCenter(bounds);\n  return React.createElement(\"rect\", _extends({\n    className: \"tl-bounds-bg\",\n    width: Math.max(1, width),\n    height: Math.max(1, height),\n    transform: \"\\n        rotate(\" + rotation * (180 / Math.PI) + \",\" + center + \")\\n        translate(\" + bounds.minX + \",\" + bounds.minY + \")\\n        rotate(\" + (bounds.rotation || 0) * (180 / Math.PI) + \", 0, 0)\"\n  }, events));\n}\n\nvar Handle = /*#__PURE__*/React.memo(function (_ref) {\n  var id = _ref.id,\n      point = _ref.point;\n  var events = useHandleEvents(id);\n  return React.createElement(\"g\", _extends({\n    className: \"handles\",\n    pointerEvents: \"all\",\n    transform: \"translate(\" + point + \")\"\n  }, events), React.createElement(\"circle\", {\n    className: \"tl-handle-bg\",\n    r: 12\n  }), React.createElement(\"use\", {\n    href: \"#handle\",\n    pointerEvents: \"none\"\n  }));\n});\n\nvar toAngle = 180 / Math.PI;\nvar Handles = /*#__PURE__*/React.memo(function (_ref) {\n  var shape = _ref.shape;\n\n  var _useTLContext = useTLContext(),\n      shapeUtils = _useTLContext.shapeUtils;\n\n  var center = shapeUtils[shape.type].getCenter(shape);\n\n  if (shape.handles === undefined) {\n    return null;\n  }\n\n  return React.createElement(\"g\", {\n    transform: \"rotate(\" + (shape.rotation || 0) * toAngle + \",\" + center + \")\"\n  }, Object.values(shape.handles).map(function (handle) {\n    return React.createElement(Handle, {\n      key: shape.id + '_' + handle.id,\n      id: handle.id,\n      point: Vec.add(handle.point, shape.point)\n    });\n  }));\n});\n\nfunction Page(_ref) {\n  var page = _ref.page,\n      pageState = _ref.pageState,\n      hideBounds = _ref.hideBounds;\n\n  var _useTLContext = useTLContext(),\n      callbacks = _useTLContext.callbacks,\n      shapeUtils = _useTLContext.shapeUtils;\n\n  useRenderOnResize();\n  var shapeTree = useShapeTree(page, pageState, shapeUtils, pageState, callbacks.onChange);\n\n  var _useHandles = useHandles(page, pageState),\n      shapeWithHandles = _useHandles.shapeWithHandles;\n\n  var _useSelection = useSelection(page, pageState, shapeUtils),\n      bounds = _useSelection.bounds,\n      isLocked = _useSelection.isLocked,\n      rotation = _useSelection.rotation;\n\n  return React.createElement(React.Fragment, null, bounds && !hideBounds && React.createElement(BoundsBg, {\n    bounds: bounds,\n    rotation: rotation\n  }), shapeTree.map(function (node) {\n    return React.createElement(ShapeNode, _extends({\n      key: node.shape.id,\n      allowHovers: true\n    }, node));\n  }), bounds && !hideBounds && React.createElement(Bounds, {\n    zoom: pageState.camera.zoom,\n    bounds: bounds,\n    isLocked: isLocked,\n    rotation: rotation\n  }), shapeWithHandles && React.createElement(Handles, {\n    shape: shapeWithHandles\n  }));\n}\nvar ShapeNode = /*#__PURE__*/React.memo(function (_ref2) {\n  var shape = _ref2.shape,\n      children = _ref2.children,\n      isEditing = _ref2.isEditing,\n      isHovered = _ref2.isHovered,\n      isDarkMode = _ref2.isDarkMode,\n      isSelected = _ref2.isSelected,\n      isBinding = _ref2.isBinding,\n      isCurrentParent = _ref2.isCurrentParent,\n      allowHovers = _ref2.allowHovers;\n  return React.createElement(React.Fragment, null, React.createElement(Shape, {\n    shape: shape,\n    isEditing: isEditing,\n    isHovered: allowHovers && isHovered,\n    isSelected: isSelected,\n    isDarkMode: isDarkMode,\n    isBinding: isBinding,\n    isCurrentParent: isCurrentParent\n  }), children && children.map(function (childNode) {\n    return React.createElement(ShapeNode, _extends({\n      key: childNode.shape.id,\n      allowHovers: allowHovers\n    }, childNode));\n  }));\n});\n\n/* eslint-disable @typescript-eslint/ban-ts-comment */\nfunction usePreventNavigation(rCanvas) {\n  React.useEffect(function () {\n    var preventGestureNavigation = function preventGestureNavigation(event) {\n      event.preventDefault();\n    };\n\n    var preventNavigation = function preventNavigation(event) {\n      // Center point of the touch area\n      var touchXPosition = event.touches[0].pageX; // Size of the touch area\n\n      var touchXRadius = event.touches[0].radiusX || 0; // We set a threshold (10px) on both sizes of the screen,\n      // if the touch area overlaps with the screen edges\n      // it's likely to trigger the navigation. We prevent the\n      // touchstart event in that case.\n\n      if (touchXPosition - touchXRadius < 10 || touchXPosition + touchXRadius > window.innerWidth - 10) {\n        event.preventDefault();\n      }\n    };\n\n    var elm = rCanvas.current;\n    if (!elm) return;\n    elm.addEventListener('touchstart', preventGestureNavigation); // @ts-ignore\n\n    elm.addEventListener('gestureend', preventGestureNavigation); // @ts-ignore\n\n    elm.addEventListener('gesturechange', preventGestureNavigation); // @ts-ignore\n\n    elm.addEventListener('gesturestart', preventGestureNavigation); // @ts-ignore\n\n    elm.addEventListener('touchstart', preventNavigation);\n    return function () {\n      if (elm) {\n        elm.removeEventListener('touchstart', preventGestureNavigation); // @ts-ignore\n\n        elm.removeEventListener('gestureend', preventGestureNavigation); // @ts-ignore\n\n        elm.removeEventListener('gesturechange', preventGestureNavigation); // @ts-ignore\n\n        elm.removeEventListener('gesturestart', preventGestureNavigation); // @ts-ignore\n\n        elm.removeEventListener('touchstart', preventNavigation);\n      }\n    };\n  }, [rCanvas]);\n}\n\nfunction resetError() {\n}\n\nvar Canvas = /*#__PURE__*/React.memo(function Canvas(_ref) {\n  var page = _ref.page,\n      pageState = _ref.pageState,\n      _ref$hideBounds = _ref.hideBounds,\n      hideBounds = _ref$hideBounds === void 0 ? false : _ref$hideBounds;\n  var rCanvas = React.useRef(null);\n  var rGroup = useCameraCss(pageState);\n  useZoomEvents();\n  useSafariFocusOutFix();\n  usePreventNavigation(rCanvas);\n  var events = useCanvasEvents();\n  return React.createElement(\"div\", {\n    className: \"tl-container\"\n  }, React.createElement(\"svg\", _extends({\n    id: \"canvas\",\n    className: \"tl-canvas\",\n    ref: rCanvas\n  }, events), React.createElement(reactErrorBoundary.ErrorBoundary, {\n    FallbackComponent: ErrorFallback,\n    onReset: resetError\n  }, React.createElement(Defs, {\n    zoom: pageState.camera.zoom\n  }), React.createElement(\"g\", {\n    ref: rGroup,\n    id: \"tl-shapes\"\n  }, React.createElement(Page, {\n    page: page,\n    pageState: pageState,\n    hideBounds: hideBounds\n  }), React.createElement(Brush, null)))));\n});\n\nvar _excluded = [\"shapeUtils\", \"page\", \"pageState\", \"theme\", \"hideBounds\", \"isDarkMode\", \"isDebugMode\", \"isPenMode\"];\nfunction Renderer(_ref) {\n  var shapeUtils = _ref.shapeUtils,\n      page = _ref.page,\n      pageState = _ref.pageState,\n      theme = _ref.theme,\n      _ref$hideBounds = _ref.hideBounds,\n      hideBounds = _ref$hideBounds === void 0 ? false : _ref$hideBounds,\n      rest = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n  useTLTheme(theme);\n\n  var _React$useState = React.useState(function () {\n    return {\n      callbacks: rest,\n      shapeUtils: shapeUtils\n    };\n  }),\n      context = _React$useState[0];\n\n  return React.createElement(TLContext.Provider, {\n    value: context\n  }, React.createElement(Canvas, {\n    page: page,\n    pageState: pageState,\n    hideBounds: hideBounds\n  }));\n}\n\nexports.Intersect = Intersect;\nexports.Renderer = Renderer;\nexports.Svg = Svg;\nexports.TLShapeUtil = TLShapeUtil;\nexports.Utils = Utils;\nexports.Vec = Vec;\nexports.brushUpdater = brushUpdater;\nexports.inputs = inputs;\n//# sourceMappingURL=core.cjs.development.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdGxkcmF3L3d3dy8uLi9wYWNrYWdlcy9jb3JlL2Rpc3QvY29yZS5janMuZGV2ZWxvcG1lbnQuanM/OGEwMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsQ0FBQyxjQUFjLEVBQUM7O0FBRTdELCtCQUErQixpRkFBaUY7O0FBRWhILFlBQVksbUJBQU8sQ0FBQyxvQkFBTztBQUMzQix5QkFBeUIsbUJBQU8sQ0FBQyxrREFBc0I7QUFDdkQsZ0NBQWdDLG1CQUFPLENBQUMsNEJBQVc7QUFDbkQsc0JBQXNCLG1CQUFPLENBQUMsNENBQW1COztBQUVqRDtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxTQUFTOztBQUVqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkIsb0JBQW9CLEtBQUs7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDZCQUE2QixzQkFBc0IsS0FBSztBQUN6RDs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRTtBQUMxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGFBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4Qix3QkFBd0I7O0FBRXhCLHdEQUF3RDs7QUFFeEQsd0RBQXdEOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwSEFBMEgsS0FBSztBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUEsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQSxnREFBZ0Q7O0FBRWhELGtEQUFrRDs7QUFFbEQ7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSwrQkFBK0I7O0FBRS9CLEtBQUs7OztBQUdMLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7O0FBRXREO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsYUFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDBFQUEwRSw2QkFBNkI7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3RUFBd0UsYUFBYTtBQUNyRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxlQUFlO0FBQzNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOERBQThELElBQUk7QUFDbEU7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWYseUNBQXlDLG9CQUFvQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBLDBGQUEwRixhQUFhO0FBQ3ZHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFOztBQUVsRSxxQkFBcUI7O0FBRXJCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsdUJBQXVCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVGQUF1RixhQUFhO0FBQ3BHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7O0FBRUEsMkRBQTJEOztBQUUzRCx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUU7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpRUFBaUU7QUFDakU7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx1Q0FBdUM7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLHdGQUF3RixhQUFhO0FBQ3JHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUhBQXlILG1CQUFtQiwyQ0FBMkMsS0FBSywwQkFBMEIsd0NBQXdDLEtBQUssa0JBQWtCLGlGQUFpRixLQUFLLHVCQUF1Qix3QkFBd0IsMEJBQTBCLEtBQUsscUJBQXFCLHdCQUF3QixLQUFLLHFCQUFxQix3QkFBd0IsS0FBSyx1QkFBdUIsMEJBQTBCLEtBQUssdUJBQXVCLDBCQUEwQixLQUFLLHlCQUF5QixxQ0FBcUMsaUNBQWlDLGtEQUFrRCxLQUFLLHlCQUF5QixxQ0FBcUMsaUNBQWlDLGtEQUFrRCxtQkFBbUIsS0FBSyxrQkFBa0Isd0NBQXdDLGlDQUFpQywrQkFBK0IsZ0RBQWdELDBCQUEwQixLQUFLLG1CQUFtQixpQ0FBaUMscUNBQXFDLGdEQUFnRCwyQkFBMkIsS0FBSyx5QkFBeUIsd0JBQXdCLHFDQUFxQyxrREFBa0QsS0FBSyxxQkFBcUIsbUJBQW1CLGlDQUFpQywwQkFBMEIsS0FBSyxpQkFBaUIsZ0NBQWdDLG9DQUFvQyxnREFBZ0QsMkJBQTJCLEtBQUssa0JBQWtCLHNCQUFzQix1QkFBdUIsZUFBZSxnQkFBZ0Isa0JBQWtCLG1CQUFtQix5QkFBeUIsbUJBQW1CLDBCQUEwQixLQUFLLHFCQUFxQix5QkFBeUIsNkJBQTZCLGtCQUFrQixtQkFBbUIsbUJBQW1CLGtCQUFrQixnQ0FBZ0Msa0NBQWtDLDZDQUE2QyxLQUFLLHVCQUF1Qix3QkFBd0IsS0FBSyxlQUFlLGlDQUFpQyxtQ0FBbUMsd0JBQXdCLEtBQUssa0JBQWtCLGlDQUFpQyxxQ0FBcUMsa0RBQWtELEtBQUsscUJBQXFCLHdCQUF3QixtQkFBbUIsbUJBQW1CLDBCQUEwQixLQUFLLDJCQUEyQixvQ0FBb0MsS0FBSywrQkFBK0Isc0NBQXNDLEtBQUssNEJBQTRCLG9DQUFvQyxzQ0FBc0MsS0FBSyw2QkFBNkIsZ0RBQWdELGlCQUFpQixpQ0FBaUMsS0FBSyx1QkFBdUIsb0JBQW9CLEtBQUssNENBQTRDLGlCQUFpQixLQUFLLGtEQUFrRCxpQkFBaUIsS0FBSywrQ0FBK0MsaUJBQWlCLEtBQUs7QUFDNXNHO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0EsR0FBRywyQkFBMkI7O0FBRTlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRCx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpRUFBaUU7O0FBRWpFLGlFQUFpRTs7QUFFakUsb0VBQW9FOztBQUVwRSxtRUFBbUU7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTs7QUFFeEUsd0VBQXdFOztBQUV4RSwyRUFBMkU7O0FBRTNFLDBFQUEwRTs7QUFFMUU7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCLFdBQVc7QUFDWCxtQkFBbUI7QUFDbkIsYUFBYTtBQUNiLFdBQVc7QUFDWCxvQkFBb0I7QUFDcEIsY0FBYztBQUNkIiwiZmlsZSI6Ii4uL3BhY2thZ2VzL2NvcmUvZGlzdC9jb3JlLmNqcy5kZXZlbG9wbWVudC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChleCkgeyByZXR1cm4gKGV4ICYmICh0eXBlb2YgZXggPT09ICdvYmplY3QnKSAmJiAnZGVmYXVsdCcgaW4gZXgpID8gZXhbJ2RlZmF1bHQnXSA6IGV4OyB9XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgcmVhY3RFcnJvckJvdW5kYXJ5ID0gcmVxdWlyZSgncmVhY3QtZXJyb3ItYm91bmRhcnknKTtcbnZhciBkZWVwbWVyZ2UgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnZGVlcG1lcmdlJykpO1xudmFyIHJlYWN0VXNlR2VzdHVyZSA9IHJlcXVpcmUoJ3JlYWN0LXVzZS1nZXN0dXJlJyk7XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsTG9vc2Uoc3RyaW5ncywgcmF3KSB7XG4gIGlmICghcmF3KSB7XG4gICAgcmF3ID0gc3RyaW5ncy5zbGljZSgwKTtcbiAgfVxuXG4gIHN0cmluZ3MucmF3ID0gcmF3O1xuICByZXR1cm4gc3RyaW5ncztcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07XG4gIGlmIChpdCkgcmV0dXJuIChpdCA9IGl0LmNhbGwobykpLm5leHQuYmluZChpdCk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmIChpdCkgbyA9IGl0O1xuICAgIHZhciBpID0gMDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7XG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IG9baSsrXVxuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG52YXIgVExDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQoe30pO1xuZnVuY3Rpb24gdXNlVExDb250ZXh0KCkge1xuICB2YXIgY29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoVExDb250ZXh0KTtcbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbihmdW5jdGlvbiAoVExCb3VuZHNFZGdlKSB7XG4gIFRMQm91bmRzRWRnZVtcIlRvcFwiXSA9IFwidG9wX2VkZ2VcIjtcbiAgVExCb3VuZHNFZGdlW1wiUmlnaHRcIl0gPSBcInJpZ2h0X2VkZ2VcIjtcbiAgVExCb3VuZHNFZGdlW1wiQm90dG9tXCJdID0gXCJib3R0b21fZWRnZVwiO1xuICBUTEJvdW5kc0VkZ2VbXCJMZWZ0XCJdID0gXCJsZWZ0X2VkZ2VcIjtcbn0pKGV4cG9ydHMuVExCb3VuZHNFZGdlIHx8IChleHBvcnRzLlRMQm91bmRzRWRnZSA9IHt9KSk7XG5cbihmdW5jdGlvbiAoVExCb3VuZHNDb3JuZXIpIHtcbiAgVExCb3VuZHNDb3JuZXJbXCJUb3BMZWZ0XCJdID0gXCJ0b3BfbGVmdF9jb3JuZXJcIjtcbiAgVExCb3VuZHNDb3JuZXJbXCJUb3BSaWdodFwiXSA9IFwidG9wX3JpZ2h0X2Nvcm5lclwiO1xuICBUTEJvdW5kc0Nvcm5lcltcIkJvdHRvbVJpZ2h0XCJdID0gXCJib3R0b21fcmlnaHRfY29ybmVyXCI7XG4gIFRMQm91bmRzQ29ybmVyW1wiQm90dG9tTGVmdFwiXSA9IFwiYm90dG9tX2xlZnRfY29ybmVyXCI7XG59KShleHBvcnRzLlRMQm91bmRzQ29ybmVyIHx8IChleHBvcnRzLlRMQm91bmRzQ29ybmVyID0ge30pKTtcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbi8qICAgICAgICAgICAgICAgICAgIFNoYXBlIFV0aWxpdHkgICAgICAgICAgICAgICAgICAgICovXG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblxudmFyIFRMU2hhcGVVdGlsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVExTaGFwZVV0aWwoKSB7XG4gICAgdGhpcy5ib3VuZHNDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG4gICAgdGhpcy5pc0VkaXRhYmxlVGV4dCA9IGZhbHNlO1xuICAgIHRoaXMuaXNBc3BlY3RSYXRpb0xvY2tlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2FuRWRpdCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFRMU2hhcGVVdGlsLnByb3RvdHlwZTtcblxuICBfcHJvdG8udHJhbnNmb3JtU2luZ2xlID0gZnVuY3Rpb24gdHJhbnNmb3JtU2luZ2xlKHNoYXBlLCBib3VuZHMsIGluZm8pIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oc2hhcGUsIGJvdW5kcywgaW5mbyk7XG4gIH07XG5cbiAgX3Byb3RvLnNob3VsZFJlbmRlciA9IGZ1bmN0aW9uIHNob3VsZFJlbmRlcihfcHJldiwgX25leHQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBfcHJvdG8uc2hvdWxkRGVsZXRlID0gZnVuY3Rpb24gc2hvdWxkRGVsZXRlKF9zaGFwZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0Q2VudGVyID0gZnVuY3Rpb24gZ2V0Q2VudGVyKHNoYXBlKSB7XG4gICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKHNoYXBlKTtcbiAgICByZXR1cm4gW2JvdW5kcy53aWR0aCAvIDIsIGJvdW5kcy5oZWlnaHQgLyAyXTtcbiAgfTtcblxuICBfcHJvdG8uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BzKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCB0aGlzLmRlZmF1bHRQcm9wcywgcHJvcHMpO1xuICB9O1xuXG4gIF9wcm90by5tdXRhdGUgPSBmdW5jdGlvbiBtdXRhdGUoc2hhcGUsIHByb3BzKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzaGFwZSwgcHJvcHMpO1xuICB9O1xuXG4gIF9wcm90by51cGRhdGVDaGlsZHJlbiA9IGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuKF9zaGFwZSwgX2NoaWxkcmVuKSB7XG4gICAgcmV0dXJuO1xuICB9O1xuXG4gIF9wcm90by5vbkNoaWxkcmVuQ2hhbmdlID0gZnVuY3Rpb24gb25DaGlsZHJlbkNoYW5nZShfc2hhcGUsIF9jaGlsZHJlbikge1xuICAgIHJldHVybjtcbiAgfTtcblxuICBfcHJvdG8ub25CaW5kaW5nQ2hhbmdlID0gZnVuY3Rpb24gb25CaW5kaW5nQ2hhbmdlKF9zaGFwZSwgX2JpbmRpbmcsIF90YXJnZXQsIF90YXJnZXRCb3VuZHMpIHtcbiAgICByZXR1cm47XG4gIH07XG5cbiAgX3Byb3RvLm9uSGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gb25IYW5kbGVDaGFuZ2UoX3NoYXBlLCBfaGFuZGxlLCBfaW5mbykge1xuICAgIHJldHVybjtcbiAgfTtcblxuICBfcHJvdG8ub25SaWdodFBvaW50SGFuZGxlID0gZnVuY3Rpb24gb25SaWdodFBvaW50SGFuZGxlKF9zaGFwZSwgX2hhbmRsZSwgX2luZm8pIHtcbiAgICByZXR1cm47XG4gIH07XG5cbiAgX3Byb3RvLm9uRG91YmxlQ2xpY2tIYW5kbGUgPSBmdW5jdGlvbiBvbkRvdWJsZUNsaWNrSGFuZGxlKF9zaGFwZSwgX2hhbmRsZSwgX2luZm8pIHtcbiAgICByZXR1cm47XG4gIH07XG5cbiAgX3Byb3RvLm9uU2Vzc2lvbkNvbXBsZXRlID0gZnVuY3Rpb24gb25TZXNzaW9uQ29tcGxldGUoX3NoYXBlKSB7XG4gICAgcmV0dXJuO1xuICB9O1xuXG4gIF9wcm90by5vbkJvdW5kc1Jlc2V0ID0gZnVuY3Rpb24gb25Cb3VuZHNSZXNldChfc2hhcGUpIHtcbiAgICByZXR1cm47XG4gIH07XG5cbiAgcmV0dXJuIFRMU2hhcGVVdGlsO1xufSgpO1xuXG4vLyBBIGJpZyBjb2xsZWN0aW9uIG9mIHZlY3RvciB1dGlsaXRpZXMuIENvbGxlY3RlZCBpbnRvIGEgY2xhc3MgdG8gaW1wcm92ZSBsb2dnaW5nIC8gcGFja2FnaW5nLlxuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLSBTdGFydCBDb3B5IEhlcmUgLS0tLS0tLS0tLS0tLS0tLSAqL1xudmFyIFZlYyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFZlYygpIHt9XG5cbiAgVmVjLmNsYW1wID0gZnVuY3Rpb24gY2xhbXAobiwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgobWluLCB0eXBlb2YgbWF4ICE9PSAndW5kZWZpbmVkJyA/IE1hdGgubWluKG4sIG1heCkgOiBuKTtcbiAgfVxuICAvKipcclxuICAgKiBOZWdhdGUgYSB2ZWN0b3IuXHJcbiAgICogQHBhcmFtIEFcclxuICAgKi9cbiAgO1xuXG4gIHJldHVybiBWZWM7XG59KCk7XG5cblZlYy5uZWcgPSBmdW5jdGlvbiAoQSkge1xuICByZXR1cm4gWy1BWzBdLCAtQVsxXV07XG59O1xuXG5WZWMuYWRkID0gZnVuY3Rpb24gKEEsIEIpIHtcbiAgcmV0dXJuIFtBWzBdICsgQlswXSwgQVsxXSArIEJbMV1dO1xufTtcblxuVmVjLmFkZFNjYWxhciA9IGZ1bmN0aW9uIChBLCBuKSB7XG4gIHJldHVybiBbQVswXSArIG4sIEFbMV0gKyBuXTtcbn07XG5cblZlYy5zdWIgPSBmdW5jdGlvbiAoQSwgQikge1xuICByZXR1cm4gW0FbMF0gLSBCWzBdLCBBWzFdIC0gQlsxXV07XG59O1xuXG5WZWMuc3ViU2NhbGFyID0gZnVuY3Rpb24gKEEsIG4pIHtcbiAgcmV0dXJuIFtBWzBdIC0gbiwgQVsxXSAtIG5dO1xufTtcblxuVmVjLnZlYyA9IGZ1bmN0aW9uIChBLCBCKSB7XG4gIC8vIEEsIEIgYXMgdmVjdG9ycyBnZXQgdGhlIHZlY3RvciBmcm9tIEEgdG8gQlxuICByZXR1cm4gW0JbMF0gLSBBWzBdLCBCWzFdIC0gQVsxXV07XG59O1xuXG5WZWMubXVsID0gZnVuY3Rpb24gKEEsIG4pIHtcbiAgcmV0dXJuIFtBWzBdICogbiwgQVsxXSAqIG5dO1xufTtcblxuVmVjLm11bFYgPSBmdW5jdGlvbiAoQSwgQikge1xuICByZXR1cm4gW0FbMF0gKiBCWzBdLCBBWzFdICogQlsxXV07XG59O1xuXG5WZWMuZGl2ID0gZnVuY3Rpb24gKEEsIG4pIHtcbiAgcmV0dXJuIFtBWzBdIC8gbiwgQVsxXSAvIG5dO1xufTtcblxuVmVjLmRpdlYgPSBmdW5jdGlvbiAoQSwgQikge1xuICByZXR1cm4gW0FbMF0gLyBCWzBdLCBBWzFdIC8gQlsxXV07XG59O1xuXG5WZWMucGVyID0gZnVuY3Rpb24gKEEpIHtcbiAgcmV0dXJuIFtBWzFdLCAtQVswXV07XG59O1xuXG5WZWMuZHByID0gZnVuY3Rpb24gKEEsIEIpIHtcbiAgcmV0dXJuIEFbMF0gKiBCWzBdICsgQVsxXSAqIEJbMV07XG59O1xuXG5WZWMuY3ByID0gZnVuY3Rpb24gKEEsIEIpIHtcbiAgcmV0dXJuIEFbMF0gKiBCWzFdIC0gQlswXSAqIEFbMV07XG59O1xuXG5WZWMubGVuMiA9IGZ1bmN0aW9uIChBKSB7XG4gIHJldHVybiBBWzBdICogQVswXSArIEFbMV0gKiBBWzFdO1xufTtcblxuVmVjLmxlbiA9IGZ1bmN0aW9uIChBKSB7XG4gIHJldHVybiBNYXRoLmh5cG90KEFbMF0sIEFbMV0pO1xufTtcblxuVmVjLnByeSA9IGZ1bmN0aW9uIChBLCBCKSB7XG4gIHJldHVybiBWZWMuZHByKEEsIEIpIC8gVmVjLmxlbihCKTtcbn07XG5cblZlYy51bmkgPSBmdW5jdGlvbiAoQSkge1xuICByZXR1cm4gVmVjLmRpdihBLCBWZWMubGVuKEEpKTtcbn07XG5cblZlYy5ub3JtYWxpemUgPSBmdW5jdGlvbiAoQSkge1xuICByZXR1cm4gVmVjLnVuaShBKTtcbn07XG5cblZlYy50YW5nZW50ID0gZnVuY3Rpb24gKEEsIEIpIHtcbiAgcmV0dXJuIFZlYy5ub3JtYWxpemUoVmVjLnN1YihBLCBCKSk7XG59O1xuXG5WZWMuZGlzdDIgPSBmdW5jdGlvbiAoQSwgQikge1xuICByZXR1cm4gVmVjLmxlbjIoVmVjLnN1YihBLCBCKSk7XG59O1xuXG5WZWMuZGlzdCA9IGZ1bmN0aW9uIChBLCBCKSB7XG4gIHJldHVybiBNYXRoLmh5cG90KEFbMV0gLSBCWzFdLCBBWzBdIC0gQlswXSk7XG59O1xuXG5WZWMuZmFzdERpc3QgPSBmdW5jdGlvbiAoQSwgQikge1xuICB2YXIgViA9IFtCWzBdIC0gQVswXSwgQlsxXSAtIEFbMV1dO1xuICB2YXIgYVYgPSBbTWF0aC5hYnMoVlswXSksIE1hdGguYWJzKFZbMV0pXTtcbiAgdmFyIHIgPSAxIC8gTWF0aC5tYXgoYVZbMF0sIGFWWzFdKTtcbiAgciA9IHIgKiAoMS4yOTI4OSAtIChhVlswXSArIGFWWzFdKSAqIHIgKiAwLjI5Mjg5KTtcbiAgcmV0dXJuIFtWWzBdICogciwgVlsxXSAqIHJdO1xufTtcblxuVmVjLmFuZyA9IGZ1bmN0aW9uIChBLCBCKSB7XG4gIHJldHVybiBNYXRoLmF0YW4yKFZlYy5jcHIoQSwgQiksIFZlYy5kcHIoQSwgQikpO1xufTtcblxuVmVjLmFuZ2xlID0gZnVuY3Rpb24gKEEsIEIpIHtcbiAgcmV0dXJuIE1hdGguYXRhbjIoQlsxXSAtIEFbMV0sIEJbMF0gLSBBWzBdKTtcbn07XG5cblZlYy5tZWQgPSBmdW5jdGlvbiAoQSwgQikge1xuICByZXR1cm4gVmVjLm11bChWZWMuYWRkKEEsIEIpLCAwLjUpO1xufTtcblxuVmVjLnJvdCA9IGZ1bmN0aW9uIChBLCByKSB7XG4gIHJldHVybiBbQVswXSAqIE1hdGguY29zKHIpIC0gQVsxXSAqIE1hdGguc2luKHIpLCBBWzBdICogTWF0aC5zaW4ocikgKyBBWzFdICogTWF0aC5jb3MocildO1xufTtcblxuVmVjLnJvdFdpdGggPSBmdW5jdGlvbiAoQSwgQywgcikge1xuICBpZiAociA9PT0gMCkgcmV0dXJuIEE7XG4gIHZhciBzID0gTWF0aC5zaW4ocik7XG4gIHZhciBjID0gTWF0aC5jb3Mocik7XG4gIHZhciBweCA9IEFbMF0gLSBDWzBdO1xuICB2YXIgcHkgPSBBWzFdIC0gQ1sxXTtcbiAgdmFyIG54ID0gcHggKiBjIC0gcHkgKiBzO1xuICB2YXIgbnkgPSBweCAqIHMgKyBweSAqIGM7XG4gIHJldHVybiBbbnggKyBDWzBdLCBueSArIENbMV1dO1xufTtcblxuVmVjLmlzRXF1YWwgPSBmdW5jdGlvbiAoQSwgQikge1xuICByZXR1cm4gQVswXSA9PT0gQlswXSAmJiBBWzFdID09PSBCWzFdO1xufTtcblxuVmVjLmxycCA9IGZ1bmN0aW9uIChBLCBCLCB0KSB7XG4gIHJldHVybiBWZWMuYWRkKEEsIFZlYy5tdWwoVmVjLnZlYyhBLCBCKSwgdCkpO1xufTtcblxuVmVjW1wiaW50XCJdID0gZnVuY3Rpb24gKEEsIEIsIGZyb20sIHRvLCBzKSB7XG4gIGlmIChzID09PSB2b2lkIDApIHtcbiAgICBzID0gMTtcbiAgfVxuXG4gIHZhciB0ID0gKFZlYy5jbGFtcChmcm9tLCB0bykgLSBmcm9tKSAvICh0byAtIGZyb20pO1xuICByZXR1cm4gVmVjLmFkZChWZWMubXVsKEEsIDEgLSB0KSwgVmVjLm11bChCLCBzKSk7XG59O1xuXG5WZWMuYW5nMyA9IGZ1bmN0aW9uIChwMSwgcGMsIHAyKSB7XG4gIC8vIHRoaXMsXG4gIHZhciB2MSA9IFZlYy52ZWMocGMsIHAxKTtcbiAgdmFyIHYyID0gVmVjLnZlYyhwYywgcDIpO1xuICByZXR1cm4gVmVjLmFuZyh2MSwgdjIpO1xufTtcblxuVmVjLmFicyA9IGZ1bmN0aW9uIChBKSB7XG4gIHJldHVybiBbTWF0aC5hYnMoQVswXSksIE1hdGguYWJzKEFbMV0pXTtcbn07XG5cblZlYy5yZXNjYWxlID0gZnVuY3Rpb24gKGEsIG4pIHtcbiAgdmFyIGwgPSBWZWMubGVuKGEpO1xuICByZXR1cm4gW24gKiBhWzBdIC8gbCwgbiAqIGFbMV0gLyBsXTtcbn07XG5cblZlYy5pc0xlZnQgPSBmdW5jdGlvbiAocDEsIHBjLCBwMikge1xuICAvLyAgaXNMZWZ0OiA+MCBmb3IgY291bnRlcmNsb2Nrd2lzZVxuICAvLyAgICAgICAgICA9MCBmb3Igbm9uZSAoZGVnZW5lcmF0ZSlcbiAgLy8gICAgICAgICAgPDAgZm9yIGNsb2Nrd2lzZVxuICByZXR1cm4gKHBjWzBdIC0gcDFbMF0pICogKHAyWzFdIC0gcDFbMV0pIC0gKHAyWzBdIC0gcDFbMF0pICogKHBjWzFdIC0gcDFbMV0pO1xufTtcblxuVmVjLmNsb2Nrd2lzZSA9IGZ1bmN0aW9uIChwMSwgcGMsIHAyKSB7XG4gIHJldHVybiBWZWMuaXNMZWZ0KHAxLCBwYywgcDIpID4gMDtcbn07XG5cblZlYy5yb3VuZCA9IGZ1bmN0aW9uIChhLCBkKSB7XG4gIGlmIChkID09PSB2b2lkIDApIHtcbiAgICBkID0gNTtcbiAgfVxuXG4gIHJldHVybiBhLm1hcChmdW5jdGlvbiAodikge1xuICAgIHJldHVybiArdi50b1ByZWNpc2lvbihkKTtcbiAgfSk7XG59O1xuXG5WZWMubmVhcmVzdFBvaW50T25MaW5lVGhyb3VnaFBvaW50ID0gZnVuY3Rpb24gKEEsIHUsIFApIHtcbiAgcmV0dXJuIFZlYy5hZGQoQSwgVmVjLm11bCh1LCBWZWMucHJ5KFZlYy5zdWIoUCwgQSksIHUpKSk7XG59O1xuXG5WZWMuZGlzdGFuY2VUb0xpbmVUaHJvdWdoUG9pbnQgPSBmdW5jdGlvbiAoQSwgdSwgUCkge1xuICByZXR1cm4gVmVjLmRpc3QoUCwgVmVjLm5lYXJlc3RQb2ludE9uTGluZVRocm91Z2hQb2ludChBLCB1LCBQKSk7XG59O1xuXG5WZWMubmVhcmVzdFBvaW50T25MaW5lU2VnbWVudCA9IGZ1bmN0aW9uIChBLCBCLCBQLCBjbGFtcCkge1xuICBpZiAoY2xhbXAgPT09IHZvaWQgMCkge1xuICAgIGNsYW1wID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBkZWx0YSA9IFZlYy5zdWIoQiwgQSk7XG4gIHZhciBsZW5ndGggPSBWZWMubGVuKGRlbHRhKTtcbiAgdmFyIHUgPSBWZWMuZGl2KGRlbHRhLCBsZW5ndGgpO1xuICB2YXIgcHQgPSBWZWMuYWRkKEEsIFZlYy5tdWwodSwgVmVjLnByeShWZWMuc3ViKFAsIEEpLCB1KSkpO1xuXG4gIGlmIChjbGFtcCkge1xuICAgIHZhciBkYSA9IFZlYy5kaXN0KEEsIHB0KTtcbiAgICB2YXIgZGIgPSBWZWMuZGlzdChCLCBwdCk7XG4gICAgaWYgKGRiIDwgZGEgJiYgZGEgPiBsZW5ndGgpIHJldHVybiBCO1xuICAgIGlmIChkYSA8IGRiICYmIGRiID4gbGVuZ3RoKSByZXR1cm4gQTtcbiAgfVxuXG4gIHJldHVybiBwdDtcbn07XG5cblZlYy5kaXN0YW5jZVRvTGluZVNlZ21lbnQgPSBmdW5jdGlvbiAoQSwgQiwgUCwgY2xhbXApIHtcbiAgaWYgKGNsYW1wID09PSB2b2lkIDApIHtcbiAgICBjbGFtcCA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gVmVjLmRpc3QoUCwgVmVjLm5lYXJlc3RQb2ludE9uTGluZVNlZ21lbnQoQSwgQiwgUCwgY2xhbXApKTtcbn07XG5cblZlYy5udWRnZSA9IGZ1bmN0aW9uIChBLCBCLCBkKSB7XG4gIHJldHVybiBWZWMuYWRkKEEsIFZlYy5tdWwoVmVjLnVuaShWZWMudmVjKEEsIEIpKSwgZCkpO1xufTtcblxuVmVjLm51ZGdlQXRBbmdsZSA9IGZ1bmN0aW9uIChBLCBhLCBkKSB7XG4gIHJldHVybiBbTWF0aC5jb3MoYSkgKiBkICsgQVswXSwgTWF0aC5zaW4oYSkgKiBkICsgQVsxXV07XG59O1xuXG5WZWMudG9QcmVjaXNpb24gPSBmdW5jdGlvbiAoYSwgbikge1xuICBpZiAobiA9PT0gdm9pZCAwKSB7XG4gICAgbiA9IDQ7XG4gIH1cblxuICByZXR1cm4gWythWzBdLnRvUHJlY2lzaW9uKG4pLCArYVsxXS50b1ByZWNpc2lvbihuKV07XG59O1xuXG5WZWMucG9pbnRzQmV0d2VlbiA9IGZ1bmN0aW9uIChhLCBiLCBzdGVwcykge1xuICBpZiAoc3RlcHMgPT09IHZvaWQgMCkge1xuICAgIHN0ZXBzID0gNjtcbiAgfVxuXG4gIHJldHVybiBBcnJheS5mcm9tKEFycmF5KHN0ZXBzKSkubWFwKGZ1bmN0aW9uIChfLCBpKSB7XG4gICAgdmFyIHQgPSBpIC8gc3RlcHM7XG4gICAgcmV0dXJuIHQgKiB0ICogdDtcbiAgfSkubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIFZlYy5yb3VuZChbXS5jb25jYXQoVmVjLmxycChhLCBiLCB0KSwgWygxIC0gdCkgLyAyXSkpO1xuICB9KTtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudCAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1leHRlbmQtbmF0aXZlICovXG5cbi8qKlxyXG4gKiBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2VBbGwoKSBwb2x5ZmlsbFxyXG4gKiBodHRwczovL2dvbWFrZXRoaW5ncy5jb20vaG93LXRvLXJlcGxhY2UtYS1zZWN0aW9uLW9mLWEtc3RyaW5nLXdpdGgtYW5vdGhlci1vbmUtd2l0aC12YW5pbGxhLWpzL1xyXG4gKiBAYXV0aG9yIENocmlzIEZlcmRpbmFuZGlcclxuICogQGxpY2Vuc2UgTUlUXHJcbiAqL1xuaWYgKCFTdHJpbmcucHJvdG90eXBlLnJlcGxhY2VBbGwpIHtcbiAgLy8gQHRzLWlnbm9yZVxuICBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2VBbGwgPSBmdW5jdGlvbiAoc3RyLCBuZXdTdHIpIHtcbiAgICAvLyBJZiBhIHJlZ2V4IHBhdHRlcm5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN0cikudG9Mb3dlckNhc2UoKSA9PT0gJ1tvYmplY3QgcmVnZXhwXScpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcGxhY2Uoc3RyLCBuZXdTdHIpO1xuICAgIH0gLy8gSWYgYSBzdHJpbmdcblxuXG4gICAgcmV0dXJuIHRoaXMucmVwbGFjZShuZXcgUmVnRXhwKHN0ciwgJ2cnKSwgbmV3U3RyKTtcbiAgfTtcbn1cblxudmFyIFV0aWxzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVXRpbHMoKSB7fVxuXG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgLyogICAgICAgICAgICAgICAgICAgIE1hdGggJiBHZW9tZXRyeSAgICAgICAgICAgICAgICAgKi9cblxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuICBVdGlscy5maWx0ZXJPYmplY3QgPSBmdW5jdGlvbiBmaWx0ZXJPYmplY3Qob2JqLCBmbikge1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMob2JqKS5maWx0ZXIoZm4pKTtcbiAgfTtcblxuICBVdGlscy5kZWVwTWVyZ2UgPSBmdW5jdGlvbiBkZWVwTWVyZ2UoYSwgYikge1xuICAgIHJldHVybiBkZWVwbWVyZ2UoYSwgYiwge1xuICAgICAgYXJyYXlNZXJnZTogZnVuY3Rpb24gYXJyYXlNZXJnZShfYSwgYikge1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBMaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZW4gdHdvIG51bWJlcnMuXHJcbiAgICogQHBhcmFtIHkxXHJcbiAgICogQHBhcmFtIHkyXHJcbiAgICogQHBhcmFtIG11XHJcbiAgICovXG4gIDtcblxuICBVdGlscy5sZXJwID0gZnVuY3Rpb24gbGVycCh5MSwgeTIsIG11KSB7XG4gICAgbXUgPSBVdGlscy5jbGFtcChtdSwgMCwgMSk7XG4gICAgcmV0dXJuIHkxICogKDEgLSBtdSkgKyB5MiAqIG11O1xuICB9XG4gIC8qKlxyXG4gICAqIExpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIGNvbG9ycy5cclxuICAgKlxyXG4gICAqICMjIyBFeGFtcGxlXHJcbiAgICpcclxuICAgKmBgYHRzXHJcbiAgICogbGVycENvbG9yKFwiIzAwMDAwMFwiLCBcIiMwMDk5RkZcIiwgLjI1KVxyXG4gICAqYGBgXHJcbiAgICovXG4gIDtcblxuICBVdGlscy5sZXJwQ29sb3IgPSBmdW5jdGlvbiBsZXJwQ29sb3IoY29sb3IxLCBjb2xvcjIsIGZhY3Rvcikge1xuICAgIGlmIChmYWN0b3IgPT09IHZvaWQgMCkge1xuICAgICAgZmFjdG9yID0gMC41O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGgycihoZXgpIHtcbiAgICAgIHZhciByZXN1bHQgPSAvXiM/KFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pJC9pLmV4ZWMoaGV4KTtcbiAgICAgIHJldHVybiByZXN1bHQgPyBbcGFyc2VJbnQocmVzdWx0WzFdLCAxNiksIHBhcnNlSW50KHJlc3VsdFsyXSwgMTYpLCBwYXJzZUludChyZXN1bHRbM10sIDE2KV0gOiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHIyaChyZ2IpIHtcbiAgICAgIHJldHVybiAnIycgKyAoKDEgPDwgMjQpICsgKHJnYlswXSA8PCAxNikgKyAocmdiWzFdIDw8IDgpICsgcmdiWzJdKS50b1N0cmluZygxNikuc2xpY2UoMSk7XG4gICAgfVxuXG4gICAgdmFyIGMxID0gaDJyKGNvbG9yMSk7XG4gICAgdmFyIGMyID0gaDJyKGNvbG9yMik7XG4gICAgaWYgKCEoYzEgJiYgYzIpKSByZXR1cm47XG4gICAgdmFyIHJlc3VsdCA9IGMxLnNsaWNlKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gTWF0aC5yb3VuZChyZXN1bHRbaV0gKyBmYWN0b3IgKiAoYzJbaV0gLSBjMVtpXSkpO1xuICAgIH1cblxuICAgIHJldHVybiByMmgocmVzdWx0KTtcbiAgfVxuICAvKipcclxuICAgKiBNb2R1bGF0ZSBhIHZhbHVlIGJldHdlZW4gdHdvIHJhbmdlcy5cclxuICAgKiBAcGFyYW0gdmFsdWVcclxuICAgKiBAcGFyYW0gcmFuZ2VBIGZyb20gW2xvdywgaGlnaF1cclxuICAgKiBAcGFyYW0gcmFuZ2VCIHRvIFtsb3csIGhpZ2hdXHJcbiAgICogQHBhcmFtIGNsYW1wXHJcbiAgICovXG4gIDtcblxuICBVdGlscy5tb2R1bGF0ZSA9IGZ1bmN0aW9uIG1vZHVsYXRlKHZhbHVlLCByYW5nZUEsIHJhbmdlQiwgY2xhbXApIHtcbiAgICBpZiAoY2xhbXAgPT09IHZvaWQgMCkge1xuICAgICAgY2xhbXAgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZnJvbUxvdyA9IHJhbmdlQVswXSxcbiAgICAgICAgZnJvbUhpZ2ggPSByYW5nZUFbMV07XG4gICAgdmFyIHYwID0gcmFuZ2VCWzBdLFxuICAgICAgICB2MSA9IHJhbmdlQlsxXTtcbiAgICB2YXIgcmVzdWx0ID0gdjAgKyAodmFsdWUgLSBmcm9tTG93KSAvIChmcm9tSGlnaCAtIGZyb21Mb3cpICogKHYxIC0gdjApO1xuICAgIHJldHVybiBjbGFtcCA/IHYwIDwgdjEgPyBNYXRoLm1heChNYXRoLm1pbihyZXN1bHQsIHYxKSwgdjApIDogTWF0aC5tYXgoTWF0aC5taW4ocmVzdWx0LCB2MCksIHYxKSA6IHJlc3VsdDtcbiAgfTtcblxuICBVdGlscy5jbGFtcCA9IGZ1bmN0aW9uIGNsYW1wKG4sIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KG1pbiwgdHlwZW9mIG1heCAhPT0gJ3VuZGVmaW5lZCcgPyBNYXRoLm1pbihuLCBtYXgpIDogbik7XG4gIH0gLy8gVE9ETzogcmVwbGFjZSB3aXRoIGEgc3RyaW5nIGNvbXByZXNzaW9uIGFsZ29yaXRobVxuICA7XG5cbiAgVXRpbHMuY29tcHJlc3MgPSBmdW5jdGlvbiBjb21wcmVzcyhzKSB7XG4gICAgcmV0dXJuIHM7XG4gIH0gLy8gVE9ETzogcmVwbGFjZSB3aXRoIGEgc3RyaW5nIGRlY29tcHJlc3Npb24gYWxnb3JpdGhtXG4gIDtcblxuICBVdGlscy5kZWNvbXByZXNzID0gZnVuY3Rpb24gZGVjb21wcmVzcyhzKSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVjdXJzaXZlbHkgY2xvbmUgYW4gb2JqZWN0IG9yIGFycmF5LlxyXG4gICAqIEBwYXJhbSBvYmpcclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLmRlZXBDbG9uZSA9IGZ1bmN0aW9uIGRlZXBDbG9uZShvYmopIHtcbiAgICBpZiAob2JqID09PSBudWxsKSByZXR1cm4gb2JqO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgcmV0dXJuIFtdLmNvbmNhdChvYmopO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGNsb25lID0gX2V4dGVuZHMoe30sIG9iaik7XG5cbiAgICAgIE9iamVjdC5rZXlzKGNsb25lKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGNsb25lW2tleV0gPSB0eXBlb2Ygb2JqW2tleV0gPT09ICdvYmplY3QnID8gVXRpbHMuZGVlcENsb25lKG9ialtrZXldKSA6IG9ialtrZXldO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICAvKipcclxuICAgKiBTZWVkZWQgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IsIHVzaW5nIFt4b3JzaGlmdF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvWG9yc2hpZnQpLlxyXG4gICAqIFRoZSByZXN1bHQgd2lsbCBhbHdheXMgYmUgYmV0d2VlZW4gLTEgYW5kIDEuXHJcbiAgICpcclxuICAgKiBBZGFwdGVkIGZyb20gW3NlZWRyYW5kb21dKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXZpZGJhdS9zZWVkcmFuZG9tKS5cclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLnJuZyA9IGZ1bmN0aW9uIHJuZyhzZWVkKSB7XG4gICAgaWYgKHNlZWQgPT09IHZvaWQgMCkge1xuICAgICAgc2VlZCA9ICcnO1xuICAgIH1cblxuICAgIHZhciB4ID0gMDtcbiAgICB2YXIgeSA9IDA7XG4gICAgdmFyIHogPSAwO1xuICAgIHZhciB3ID0gMDtcblxuICAgIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB2YXIgdCA9IHggXiB4IDw8IDExO1xuICAgICAgeCA9IHk7XG4gICAgICB5ID0gejtcbiAgICAgIHogPSB3O1xuICAgICAgdyBePSAodyA+Pj4gMTkgXiB0IF4gdCA+Pj4gOCkgPj4+IDA7XG4gICAgICByZXR1cm4gdyAvIDB4MTAwMDAwMDAwO1xuICAgIH1cblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc2VlZC5sZW5ndGggKyA2NDsgaysrKSB7XG4gICAgICB4IF49IHNlZWQuY2hhckNvZGVBdChrKSB8IDA7XG4gICAgICBuZXh0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBCb3hlcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgO1xuXG4gIFV0aWxzLmdldFJlY3RhbmdsZVNpZGVzID0gZnVuY3Rpb24gZ2V0UmVjdGFuZ2xlU2lkZXMocG9pbnQsIHNpemUpIHtcbiAgICB2YXIgdGwgPSBwb2ludDtcbiAgICB2YXIgdHIgPSBWZWMuYWRkKHBvaW50LCBbc2l6ZVswXSwgMF0pO1xuICAgIHZhciBiciA9IFZlYy5hZGQocG9pbnQsIHNpemUpO1xuICAgIHZhciBibCA9IFZlYy5hZGQocG9pbnQsIFswLCBzaXplWzFdXSk7XG4gICAgcmV0dXJuIFtbJ3RvcCcsIFt0bCwgdHJdXSwgWydyaWdodCcsIFt0ciwgYnJdXSwgWydib3R0b20nLCBbYnIsIGJsXV0sIFsnbGVmdCcsIFtibCwgdGxdXV07XG4gIH07XG5cbiAgVXRpbHMuZ2V0Qm91bmRzU2lkZXMgPSBmdW5jdGlvbiBnZXRCb3VuZHNTaWRlcyhib3VuZHMpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSZWN0YW5nbGVTaWRlcyhbYm91bmRzLm1pblgsIGJvdW5kcy5taW5ZXSwgW2JvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodF0pO1xuICB9O1xuXG4gIFV0aWxzLnNoYWxsb3dFcXVhbCA9IGZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gICAgaWYgKG9iakEgPT09IG9iakIpIHJldHVybiB0cnVlO1xuICAgIGlmICghb2JqQSB8fCAhb2JqQikgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBhS2V5cyA9IE9iamVjdC5rZXlzKG9iakEpO1xuICAgIHZhciBiS2V5cyA9IE9iamVjdC5rZXlzKG9iakIpO1xuICAgIHZhciBsZW4gPSBhS2V5cy5sZW5ndGg7XG4gICAgaWYgKGJLZXlzLmxlbmd0aCAhPT0gbGVuKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gYUtleXNbaV07XG5cbiAgICAgIGlmIChvYmpBW2tleV0gIT09IG9iakJba2V5XSB8fCAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qIC0tLS0tLS0tLS0tLS0tLSBDaXJjbGVzIGFuZCBBbmdsZXMgLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBvdXRlciBvZiBiZXR3ZWVuIGEgY2lyY2xlIGFuZCBhIHBvaW50LlxyXG4gICAqIEBwYXJhbSBDIFRoZSBjaXJjbGUncyBjZW50ZXIuXHJcbiAgICogQHBhcmFtIHIgVGhlIGNpcmNsZSdzIHJhZGl1cy5cclxuICAgKiBAcGFyYW0gUCBUaGUgcG9pbnQuXHJcbiAgICogQHBhcmFtIHNpZGVcclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLmdldENpcmNsZVRhbmdlbnRUb1BvaW50ID0gZnVuY3Rpb24gZ2V0Q2lyY2xlVGFuZ2VudFRvUG9pbnQoQywgciwgUCwgc2lkZSkge1xuICAgIHZhciBCID0gVmVjLmxycChDLCBQLCAwLjUpO1xuICAgIHZhciByMSA9IFZlYy5kaXN0KEMsIEIpO1xuICAgIHZhciBkZWx0YSA9IFZlYy5zdWIoQiwgQyk7XG4gICAgdmFyIGQgPSBWZWMubGVuKGRlbHRhKTtcblxuICAgIGlmICghKGQgPD0gciArIHIxICYmIGQgPj0gTWF0aC5hYnMociAtIHIxKSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBhID0gKHIgKiByIC0gcjEgKiByMSArIGQgKiBkKSAvICgyLjAgKiBkKTtcbiAgICB2YXIgbiA9IDEgLyBkO1xuICAgIHZhciBwID0gVmVjLmFkZChDLCBWZWMubXVsKGRlbHRhLCBhICogbikpO1xuICAgIHZhciBoID0gTWF0aC5zcXJ0KHIgKiByIC0gYSAqIGEpO1xuICAgIHZhciBrID0gVmVjLm11bChWZWMucGVyKGRlbHRhKSwgaCAqIG4pO1xuICAgIHJldHVybiBzaWRlID09PSAwID8gVmVjLmFkZChwLCBrKSA6IFZlYy5zdWIocCwgayk7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IG91dGVyIHRhbmdlbnRzIG9mIHR3byBjaXJjbGVzLlxyXG4gICAqIEBwYXJhbSB4MFxyXG4gICAqIEBwYXJhbSB5MFxyXG4gICAqIEBwYXJhbSByMFxyXG4gICAqIEBwYXJhbSB4MVxyXG4gICAqIEBwYXJhbSB5MVxyXG4gICAqIEBwYXJhbSByMVxyXG4gICAqIEByZXR1cm5zIFtseDAsIGx5MCwgbHgxLCBseTEsIHJ4MCwgcnkwLCByeDEsIHJ5MV1cclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLmdldE91dGVyVGFuZ2VudHNPZkNpcmNsZXMgPSBmdW5jdGlvbiBnZXRPdXRlclRhbmdlbnRzT2ZDaXJjbGVzKEMwLCByMCwgQzEsIHIxKSB7XG4gICAgdmFyIGEwID0gVmVjLmFuZ2xlKEMwLCBDMSk7XG4gICAgdmFyIGQgPSBWZWMuZGlzdChDMCwgQzEpOyAvLyBDaXJjbGVzIGFyZSBvdmVybGFwcGluZywgbm8gdGFuZ2VudHNcblxuICAgIGlmIChkIDwgTWF0aC5hYnMocjEgLSByMCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBhMSA9IE1hdGguYWNvcygocjAgLSByMSkgLyBkKTtcbiAgICB2YXIgdDAgPSBhMCArIGExO1xuICAgIHZhciB0MSA9IGEwIC0gYTE7XG4gICAgcmV0dXJuIFtbQzBbMF0gKyByMCAqIE1hdGguY29zKHQxKSwgQzBbMV0gKyByMCAqIE1hdGguc2luKHQxKV0sIFtDMVswXSArIHIxICogTWF0aC5jb3ModDEpLCBDMVsxXSArIHIxICogTWF0aC5zaW4odDEpXSwgW0MwWzBdICsgcjAgKiBNYXRoLmNvcyh0MCksIEMwWzFdICsgcjAgKiBNYXRoLnNpbih0MCldLCBbQzFbMF0gKyByMSAqIE1hdGguY29zKHQwKSwgQzFbMV0gKyByMSAqIE1hdGguc2luKHQwKV1dO1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCB0aGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgcGVyaW1ldGVyIG9mIGEgY2lyY2xlIHRvIGEgZ2l2ZW4gcG9pbnQuXHJcbiAgICogQHBhcmFtIEMgVGhlIGNpcmNsZSdzIGNlbnRlci5cclxuICAgKiBAcGFyYW0gciBUaGUgY2lyY2xlJ3MgcmFkaXVzLlxyXG4gICAqIEBwYXJhbSBQIFRoZSBwb2ludC5cclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLmdldENsb3Nlc3RQb2ludE9uQ2lyY2xlID0gZnVuY3Rpb24gZ2V0Q2xvc2VzdFBvaW50T25DaXJjbGUoQywgciwgUCkge1xuICAgIHZhciB2ID0gVmVjLnN1YihDLCBQKTtcbiAgICByZXR1cm4gVmVjLnN1YihDLCBWZWMubXVsKFZlYy5kaXYodiwgVmVjLmxlbih2KSksIHIpKTtcbiAgfVxuICAvKipcclxuICAgKiBHZXQgYSBjaXJjbGUgZnJvbSB0aHJlZSBwb2ludHMuXHJcbiAgICogQHBhcmFtIEFcclxuICAgKiBAcGFyYW0gQlxyXG4gICAqIEBwYXJhbSBDXHJcbiAgICogQHJldHVybnMgW3gsIHksIHJdXHJcbiAgICovXG4gIDtcblxuICBVdGlscy5jaXJjbGVGcm9tVGhyZWVQb2ludHMgPSBmdW5jdGlvbiBjaXJjbGVGcm9tVGhyZWVQb2ludHMoQSwgQiwgQykge1xuICAgIHZhciB4MSA9IEFbMF0sXG4gICAgICAgIHkxID0gQVsxXTtcbiAgICB2YXIgeDIgPSBCWzBdLFxuICAgICAgICB5MiA9IEJbMV07XG4gICAgdmFyIHgzID0gQ1swXSxcbiAgICAgICAgeTMgPSBDWzFdO1xuICAgIHZhciBhID0geDEgKiAoeTIgLSB5MykgLSB5MSAqICh4MiAtIHgzKSArIHgyICogeTMgLSB4MyAqIHkyO1xuICAgIHZhciBiID0gKHgxICogeDEgKyB5MSAqIHkxKSAqICh5MyAtIHkyKSArICh4MiAqIHgyICsgeTIgKiB5MikgKiAoeTEgLSB5MykgKyAoeDMgKiB4MyArIHkzICogeTMpICogKHkyIC0geTEpO1xuICAgIHZhciBjID0gKHgxICogeDEgKyB5MSAqIHkxKSAqICh4MiAtIHgzKSArICh4MiAqIHgyICsgeTIgKiB5MikgKiAoeDMgLSB4MSkgKyAoeDMgKiB4MyArIHkzICogeTMpICogKHgxIC0geDIpO1xuICAgIHZhciB4ID0gLWIgLyAoMiAqIGEpO1xuICAgIHZhciB5ID0gLWMgLyAoMiAqIGEpO1xuICAgIHJldHVybiBbeCwgeSwgTWF0aC5oeXBvdCh4IC0geDEsIHkgLSB5MSldO1xuICB9XG4gIC8qKlxyXG4gICAqIEZpbmQgdGhlIGFwcHJveGltYXRlIHBlcmltZXRlciBvZiBhbiBlbGxpcHNlLlxyXG4gICAqIEBwYXJhbSByeFxyXG4gICAqIEBwYXJhbSByeVxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMucGVyaW1ldGVyT2ZFbGxpcHNlID0gZnVuY3Rpb24gcGVyaW1ldGVyT2ZFbGxpcHNlKHJ4LCByeSkge1xuICAgIHZhciBoID0gTWF0aC5wb3cocnggLSByeSwgMikgLyBNYXRoLnBvdyhyeCArIHJ5LCAyKTtcbiAgICB2YXIgcCA9IE1hdGguUEkgKiAocnggKyByeSkgKiAoMSArIDMgKiBoIC8gKDEwICsgTWF0aC5zcXJ0KDQgLSAzICogaCkpKTtcbiAgICByZXR1cm4gcDtcbiAgfVxuICAvKipcclxuICAgKiBHZXQgdGhlIHNob3J0IGFuZ2xlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGFuZ2xlcy5cclxuICAgKiBAcGFyYW0gYTBcclxuICAgKiBAcGFyYW0gYTFcclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLnNob3J0QW5nbGVEaXN0ID0gZnVuY3Rpb24gc2hvcnRBbmdsZURpc3QoYTAsIGExKSB7XG4gICAgdmFyIG1heCA9IE1hdGguUEkgKiAyO1xuICAgIHZhciBkYSA9IChhMSAtIGEwKSAlIG1heDtcbiAgICByZXR1cm4gMiAqIGRhICUgbWF4IC0gZGE7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBsb25nIGFuZ2xlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGFuZ2xlcy5cclxuICAgKiBAcGFyYW0gYTBcclxuICAgKiBAcGFyYW0gYTFcclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLmxvbmdBbmdsZURpc3QgPSBmdW5jdGlvbiBsb25nQW5nbGVEaXN0KGEwLCBhMSkge1xuICAgIHJldHVybiBNYXRoLlBJICogMiAtIFV0aWxzLnNob3J0QW5nbGVEaXN0KGEwLCBhMSk7XG4gIH1cbiAgLyoqXHJcbiAgICogSW50ZXJwb2xhdGUgYW4gYW5nbGUgYmV0d2VlbiB0d28gYW5nbGVzLlxyXG4gICAqIEBwYXJhbSBhMFxyXG4gICAqIEBwYXJhbSBhMVxyXG4gICAqIEBwYXJhbSB0XHJcbiAgICovXG4gIDtcblxuICBVdGlscy5sZXJwQW5nbGVzID0gZnVuY3Rpb24gbGVycEFuZ2xlcyhhMCwgYTEsIHQpIHtcbiAgICByZXR1cm4gYTAgKyBVdGlscy5zaG9ydEFuZ2xlRGlzdChhMCwgYTEpICogdDtcbiAgfVxuICAvKipcclxuICAgKiBHZXQgdGhlIHNob3J0IGRpc3RhbmNlIGJldHdlZW4gdHdvIGFuZ2xlcy5cclxuICAgKiBAcGFyYW0gYTBcclxuICAgKiBAcGFyYW0gYTFcclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLmFuZ2xlRGVsdGEgPSBmdW5jdGlvbiBhbmdsZURlbHRhKGEwLCBhMSkge1xuICAgIHJldHVybiBVdGlscy5zaG9ydEFuZ2xlRGlzdChhMCwgYTEpO1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCB0aGUgXCJzd2VlcFwiIG9yIHNob3J0IGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cyBvbiBhIGNpcmNsZSdzIHBlcmltZXRlci5cclxuICAgKiBAcGFyYW0gQ1xyXG4gICAqIEBwYXJhbSBBXHJcbiAgICogQHBhcmFtIEJcclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLmdldFN3ZWVwID0gZnVuY3Rpb24gZ2V0U3dlZXAoQywgQSwgQikge1xuICAgIHJldHVybiBVdGlscy5hbmdsZURlbHRhKFZlYy5hbmdsZShDLCBBKSwgVmVjLmFuZ2xlKEMsIEIpKTtcbiAgfVxuICAvKipcclxuICAgKiBSb3RhdGUgYSBwb2ludCBhcm91bmQgYSBjZW50ZXIuXHJcbiAgICogQHBhcmFtIHggVGhlIHgtYXhpcyBjb29yZGluYXRlIG9mIHRoZSBwb2ludC5cclxuICAgKiBAcGFyYW0geSBUaGUgeS1heGlzIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LlxyXG4gICAqIEBwYXJhbSBjeCBUaGUgeC1heGlzIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHJvdGF0ZSByb3VuZC5cclxuICAgKiBAcGFyYW0gY3kgVGhlIHktYXhpcyBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byByb3RhdGUgcm91bmQuXHJcbiAgICogQHBhcmFtIGFuZ2xlIFRoZSBkaXN0YW5jZSAoaW4gcmFkaWFucykgdG8gcm90YXRlLlxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMucm90YXRlUG9pbnQgPSBmdW5jdGlvbiByb3RhdGVQb2ludChBLCBCLCBhbmdsZSkge1xuICAgIHZhciBzID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgIHZhciBjID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgIHZhciBweCA9IEFbMF0gLSBCWzBdO1xuICAgIHZhciBweSA9IEFbMV0gLSBCWzFdO1xuICAgIHZhciBueCA9IHB4ICogYyAtIHB5ICogcztcbiAgICB2YXIgbnkgPSBweCAqIHMgKyBweSAqIGM7XG4gICAgcmV0dXJuIFtueCArIEJbMF0sIG55ICsgQlsxXV07XG4gIH1cbiAgLyoqXHJcbiAgICogQ2xhbXAgcmFkaWFucyB3aXRoaW4gMCBhbmQgMlBJXHJcbiAgICogQHBhcmFtIHJcclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLmNsYW1wUmFkaWFucyA9IGZ1bmN0aW9uIGNsYW1wUmFkaWFucyhyKSB7XG4gICAgcmV0dXJuIChNYXRoLlBJICogMiArIHIpICUgKE1hdGguUEkgKiAyKTtcbiAgfVxuICAvKipcclxuICAgKiBDbGFtcCByb3RhdGlvbiB0byBldmVuIHNlZ21lbnRzLlxyXG4gICAqIEBwYXJhbSByXHJcbiAgICogQHBhcmFtIHNlZ21lbnRzXHJcbiAgICovXG4gIDtcblxuICBVdGlscy5jbGFtcFRvUm90YXRpb25Ub1NlZ21lbnRzID0gZnVuY3Rpb24gY2xhbXBUb1JvdGF0aW9uVG9TZWdtZW50cyhyLCBzZWdtZW50cykge1xuICAgIHZhciBzZWcgPSBNYXRoLlBJICogMiAvIHNlZ21lbnRzO1xuICAgIHJldHVybiBNYXRoLmZsb29yKChVdGlscy5jbGFtcFJhZGlhbnMocikgKyBzZWcgLyAyKSAvIHNlZykgKiBzZWc7XG4gIH1cbiAgLyoqXHJcbiAgICogSXMgYW5nbGUgYyBiZXR3ZWVuIGFuZ2xlcyBhIGFuZCBiP1xyXG4gICAqIEBwYXJhbSBhXHJcbiAgICogQHBhcmFtIGJcclxuICAgKiBAcGFyYW0gY1xyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuaXNBbmdsZUJldHdlZW4gPSBmdW5jdGlvbiBpc0FuZ2xlQmV0d2VlbihhLCBiLCBjKSB7XG4gICAgaWYgKGMgPT09IGEgfHwgYyA9PT0gYikgcmV0dXJuIHRydWU7XG4gICAgdmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuICAgIHZhciBBQiA9IChiIC0gYSArIFBJMikgJSBQSTI7XG4gICAgdmFyIEFDID0gKGMgLSBhICsgUEkyKSAlIFBJMjtcbiAgICByZXR1cm4gQUIgPD0gTWF0aC5QSSAhPT0gQUMgPiBBQjtcbiAgfVxuICAvKipcclxuICAgKiBDb252ZXJ0IGRlZ3JlZXMgdG8gcmFkaWFucy5cclxuICAgKiBAcGFyYW0gZFxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuZGVncmVlc1RvUmFkaWFucyA9IGZ1bmN0aW9uIGRlZ3JlZXNUb1JhZGlhbnMoZCkge1xuICAgIHJldHVybiBkICogTWF0aC5QSSAvIDE4MDtcbiAgfVxuICAvKipcclxuICAgKiBDb252ZXJ0IHJhZGlhbnMgdG8gZGVncmVlcy5cclxuICAgKiBAcGFyYW0gclxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMucmFkaWFuc1RvRGVncmVlcyA9IGZ1bmN0aW9uIHJhZGlhbnNUb0RlZ3JlZXMocikge1xuICAgIHJldHVybiByICogMTgwIC8gTWF0aC5QSTtcbiAgfVxuICAvKipcclxuICAgKiBHZXQgdGhlIGxlbmd0aCBvZiBhbiBhcmMgYmV0d2VlbiB0d28gcG9pbnRzIG9uIGEgY2lyY2xlJ3MgcGVyaW1ldGVyLlxyXG4gICAqIEBwYXJhbSBDXHJcbiAgICogQHBhcmFtIHJcclxuICAgKiBAcGFyYW0gQVxyXG4gICAqIEBwYXJhbSBCXHJcbiAgICovXG4gIDtcblxuICBVdGlscy5nZXRBcmNMZW5ndGggPSBmdW5jdGlvbiBnZXRBcmNMZW5ndGgoQywgciwgQSwgQikge1xuICAgIHZhciBzd2VlcCA9IFV0aWxzLmdldFN3ZWVwKEMsIEEsIEIpO1xuICAgIHJldHVybiByICogKDIgKiBNYXRoLlBJKSAqIChzd2VlcCAvICgyICogTWF0aC5QSSkpO1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCBhIGRhc2ggb2Zmc2V0IGZvciBhbiBhcmMsIGJhc2VkIG9uIGl0cyBsZW5ndGguXHJcbiAgICogQHBhcmFtIENcclxuICAgKiBAcGFyYW0gclxyXG4gICAqIEBwYXJhbSBBXHJcbiAgICogQHBhcmFtIEJcclxuICAgKiBAcGFyYW0gc3RlcFxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuZ2V0QXJjRGFzaE9mZnNldCA9IGZ1bmN0aW9uIGdldEFyY0Rhc2hPZmZzZXQoQywgciwgQSwgQiwgc3RlcCkge1xuICAgIHZhciBkZWwwID0gVXRpbHMuZ2V0U3dlZXAoQywgQSwgQik7XG4gICAgdmFyIGxlbjAgPSBVdGlscy5nZXRBcmNMZW5ndGgoQywgciwgQSwgQik7XG4gICAgdmFyIG9mZjAgPSBkZWwwIDwgMCA/IGxlbjAgOiAyICogTWF0aC5QSSAqIENbMl0gLSBsZW4wO1xuICAgIHJldHVybiAtb2ZmMCAvIDIgKyBzdGVwO1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCBhIGRhc2ggb2Zmc2V0IGZvciBhbiBlbGxpcHNlLCBiYXNlZCBvbiBpdHMgbGVuZ3RoLlxyXG4gICAqIEBwYXJhbSBBXHJcbiAgICogQHBhcmFtIHN0ZXBcclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLmdldEVsbGlwc2VEYXNoT2Zmc2V0ID0gZnVuY3Rpb24gZ2V0RWxsaXBzZURhc2hPZmZzZXQoQSwgc3RlcCkge1xuICAgIHZhciBjID0gMiAqIE1hdGguUEkgKiBBWzJdO1xuICAgIHJldHVybiAtYyAvIDIgKyAtc3RlcDtcbiAgfVxuICAvKiAtLS0tLS0tLS0tLS0tLS0gQ3VydmVzIGFuZCBTcGxpbmVzIC0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gIC8qKlxyXG4gICAqIEdldCBiZXppZXIgY3VydmUgc2VnbWVudHMgdGhhdCBwYXNzIHRocm91Z2ggYW4gYXJyYXkgb2YgcG9pbnRzLlxyXG4gICAqIEBwYXJhbSBwb2ludHNcclxuICAgKiBAcGFyYW0gdGVuc2lvblxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuZ2V0VExCZXppZXJDdXJ2ZVNlZ21lbnRzID0gZnVuY3Rpb24gZ2V0VExCZXppZXJDdXJ2ZVNlZ21lbnRzKHBvaW50cywgdGVuc2lvbikge1xuICAgIGlmICh0ZW5zaW9uID09PSB2b2lkIDApIHtcbiAgICAgIHRlbnNpb24gPSAwLjQ7XG4gICAgfVxuXG4gICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgdmFyIGNwb2ludHMgPSBbXS5jb25jYXQocG9pbnRzKTtcblxuICAgIGlmIChsZW4gPCAyKSB7XG4gICAgICB0aHJvdyBFcnJvcignQ3VydmUgbXVzdCBoYXZlIGF0IGxlYXN0IHR3byBwb2ludHMuJyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgICAgIHZhciBwMCA9IHBvaW50c1tpIC0gMV07XG4gICAgICB2YXIgcDEgPSBwb2ludHNbaV07XG4gICAgICB2YXIgcDIgPSBwb2ludHNbaSArIDFdO1xuICAgICAgdmFyIHBkeCA9IHAyWzBdIC0gcDBbMF07XG4gICAgICB2YXIgcGR5ID0gcDJbMV0gLSBwMFsxXTtcbiAgICAgIHZhciBwZCA9IE1hdGguaHlwb3QocGR4LCBwZHkpO1xuICAgICAgdmFyIG54ID0gcGR4IC8gcGQ7IC8vIG5vcm1hbGl6ZWQgeFxuXG4gICAgICB2YXIgbnkgPSBwZHkgLyBwZDsgLy8gbm9ybWFsaXplZCB5XG5cbiAgICAgIHZhciBkcCA9IE1hdGguaHlwb3QocDFbMF0gLSBwMFswXSwgcDFbMV0gLSBwMFsxXSk7IC8vIERpc3RhbmNlIHRvIHByZXZpb3VzXG5cbiAgICAgIHZhciBkbiA9IE1hdGguaHlwb3QocDFbMF0gLSBwMlswXSwgcDFbMV0gLSBwMlsxXSk7IC8vIERpc3RhbmNlIHRvIG5leHRcblxuICAgICAgY3BvaW50c1tpXSA9IFsvLyB0YW5nZW50IHN0YXJ0XG4gICAgICBwMVswXSAtIG54ICogZHAgKiB0ZW5zaW9uLCBwMVsxXSAtIG55ICogZHAgKiB0ZW5zaW9uLCAvLyB0YW5nZW50IGVuZFxuICAgICAgcDFbMF0gKyBueCAqIGRuICogdGVuc2lvbiwgcDFbMV0gKyBueSAqIGRuICogdGVuc2lvbiwgLy8gbm9ybWFsXG4gICAgICBueCwgbnldO1xuICAgIH0gLy8gVE9ETzogUmVmbGVjdCB0aGUgbmVhcmVzdCBjb250cm9sIHBvaW50cywgbm90IGF2ZXJhZ2UgdGhlbVxuXG5cbiAgICB2YXIgZDAgPSBNYXRoLmh5cG90KHBvaW50c1swXVswXSArIGNwb2ludHNbMV1bMF0pO1xuICAgIGNwb2ludHNbMF1bMl0gPSAocG9pbnRzWzBdWzBdICsgY3BvaW50c1sxXVswXSkgLyAyO1xuICAgIGNwb2ludHNbMF1bM10gPSAocG9pbnRzWzBdWzFdICsgY3BvaW50c1sxXVsxXSkgLyAyO1xuICAgIGNwb2ludHNbMF1bNF0gPSAoY3BvaW50c1sxXVswXSAtIHBvaW50c1swXVswXSkgLyBkMDtcbiAgICBjcG9pbnRzWzBdWzVdID0gKGNwb2ludHNbMV1bMV0gLSBwb2ludHNbMF1bMV0pIC8gZDA7XG4gICAgdmFyIGQxID0gTWF0aC5oeXBvdChwb2ludHNbbGVuIC0gMV1bMV0gKyBjcG9pbnRzW2xlbiAtIDFdWzFdKTtcbiAgICBjcG9pbnRzW2xlbiAtIDFdWzBdID0gKHBvaW50c1tsZW4gLSAxXVswXSArIGNwb2ludHNbbGVuIC0gMl1bMl0pIC8gMjtcbiAgICBjcG9pbnRzW2xlbiAtIDFdWzFdID0gKHBvaW50c1tsZW4gLSAxXVsxXSArIGNwb2ludHNbbGVuIC0gMl1bM10pIC8gMjtcbiAgICBjcG9pbnRzW2xlbiAtIDFdWzRdID0gKGNwb2ludHNbbGVuIC0gMl1bMl0gLSBwb2ludHNbbGVuIC0gMV1bMF0pIC8gLWQxO1xuICAgIGNwb2ludHNbbGVuIC0gMV1bNV0gPSAoY3BvaW50c1tsZW4gLSAyXVszXSAtIHBvaW50c1tsZW4gLSAxXVsxXSkgLyAtZDE7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBjcG9pbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgc3RhcnQ6IHBvaW50c1tfaSAtIDFdLnNsaWNlKDAsIDIpLFxuICAgICAgICB0YW5nZW50U3RhcnQ6IGNwb2ludHNbX2kgLSAxXS5zbGljZSgyLCA0KSxcbiAgICAgICAgbm9ybWFsU3RhcnQ6IGNwb2ludHNbX2kgLSAxXS5zbGljZSg0LCA2KSxcbiAgICAgICAgcHJlc3N1cmVTdGFydDogMiArICgoX2kgLSAxKSAlIDIgPT09IDAgPyAxLjUgOiAwKSxcbiAgICAgICAgZW5kOiBwb2ludHNbX2ldLnNsaWNlKDAsIDIpLFxuICAgICAgICB0YW5nZW50RW5kOiBjcG9pbnRzW19pXS5zbGljZSgwLCAyKSxcbiAgICAgICAgbm9ybWFsRW5kOiBjcG9pbnRzW19pXS5zbGljZSg0LCA2KSxcbiAgICAgICAgcHJlc3N1cmVFbmQ6IDIgKyAoX2kgJSAyID09PSAwID8gMS41IDogMClcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG4gIC8qKlxyXG4gICAqIEZpbmQgYSBwb2ludCBhbG9uZyBhIGN1cnZlIHNlZ21lbnQsIHZpYSBwb21heC5cclxuICAgKiBAcGFyYW0gdFxyXG4gICAqIEBwYXJhbSBwb2ludHMgW2NweDEsIGNweTEsIGNweDIsIGNweTIsIHB4LCBweV1bXVxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuY29tcHV0ZVBvaW50T25DdXJ2ZSA9IGZ1bmN0aW9uIGNvbXB1dGVQb2ludE9uQ3VydmUodCwgcG9pbnRzKSB7XG4gICAgLy8gc2hvcnRjdXRzXG4gICAgaWYgKHQgPT09IDApIHtcbiAgICAgIHJldHVybiBwb2ludHNbMF07XG4gICAgfVxuXG4gICAgdmFyIG9yZGVyID0gcG9pbnRzLmxlbmd0aCAtIDE7XG5cbiAgICBpZiAodCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHBvaW50c1tvcmRlcl07XG4gICAgfVxuXG4gICAgdmFyIG10ID0gMSAtIHQ7XG4gICAgdmFyIHAgPSBwb2ludHM7IC8vIGNvbnN0YW50P1xuXG4gICAgaWYgKG9yZGVyID09PSAwKSB7XG4gICAgICByZXR1cm4gcG9pbnRzWzBdO1xuICAgIH0gLy8gbGluZWFyP1xuXG5cbiAgICBpZiAob3JkZXIgPT09IDEpIHtcbiAgICAgIHJldHVybiBbbXQgKiBwWzBdWzBdICsgdCAqIHBbMV1bMF0sIG10ICogcFswXVsxXSArIHQgKiBwWzFdWzFdXTtcbiAgICB9IC8vIHF1YWRyYXRpYy9jdWJpYyBjdXJ2ZT9cbiAgICAvLyBpZiAob3JkZXIgPCA0KSB7XG5cblxuICAgIHZhciBtdDIgPSBtdCAqIG10O1xuICAgIHZhciB0MiA9IHQgKiB0O1xuICAgIHZhciBhO1xuICAgIHZhciBiO1xuICAgIHZhciBjO1xuICAgIHZhciBkID0gMDtcblxuICAgIGlmIChvcmRlciA9PT0gMikge1xuICAgICAgcCA9IFtwWzBdLCBwWzFdLCBwWzJdLCBbMCwgMF1dO1xuICAgICAgYSA9IG10MjtcbiAgICAgIGIgPSBtdCAqIHQgKiAyO1xuICAgICAgYyA9IHQyOyAvLyB9IGVsc2UgaWYgKG9yZGVyID09PSAzKSB7XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBtdDIgKiBtdDtcbiAgICAgIGIgPSBtdDIgKiB0ICogMztcbiAgICAgIGMgPSBtdCAqIHQyICogMztcbiAgICAgIGQgPSB0ICogdDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIFthICogcFswXVswXSArIGIgKiBwWzFdWzBdICsgYyAqIHBbMl1bMF0gKyBkICogcFszXVswXSwgYSAqIHBbMF1bMV0gKyBiICogcFsxXVsxXSArIGMgKiBwWzJdWzFdICsgZCAqIHBbM11bMV1dOyAvLyB9IC8vIGhpZ2hlciBvcmRlciBjdXJ2ZXM6IHVzZSBkZSBDYXN0ZWxqYXUncyBjb21wdXRhdGlvblxuICB9XG4gIC8qKlxyXG4gICAqIEV2YWx1YXRlIGEgMmQgY3ViaWMgYmV6aWVyIGF0IGEgcG9pbnQgdCBvbiB0aGUgeCBheGlzLlxyXG4gICAqIEBwYXJhbSB0eFxyXG4gICAqIEBwYXJhbSB4MVxyXG4gICAqIEBwYXJhbSB5MVxyXG4gICAqIEBwYXJhbSB4MlxyXG4gICAqIEBwYXJhbSB5MlxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuY3ViaWNCZXppZXIgPSBmdW5jdGlvbiBjdWJpY0Jlemllcih0eCwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAvLyBJbnNwaXJlZCBieSBEb24gTGFuY2FzdGVyJ3MgdHdvIGFydGljbGVzXG4gICAgLy8gaHR0cDovL3d3dy50aW5hamEuY29tL2dsaWIvY3ViZW1hdGgucGRmXG4gICAgLy8gaHR0cDovL3d3dy50aW5hamEuY29tL3RleHQvYmV6bWF0aC5odG1sXG4gICAgLy8gU2V0IHN0YXJ0IGFuZCBlbmQgcG9pbnRcbiAgICB2YXIgeDAgPSAwO1xuICAgIHZhciB5MCA9IDA7XG4gICAgdmFyIHgzID0gMTtcbiAgICB2YXIgeTMgPSAxOyAvLyBDb252ZXJ0IHRoZSBjb29yZGluYXRlcyB0byBlcXVhdGlvbiBzcGFjZVxuXG4gICAgdmFyIEEgPSB4MyAtIDMgKiB4MiArIDMgKiB4MSAtIHgwO1xuICAgIHZhciBCID0gMyAqIHgyIC0gNiAqIHgxICsgMyAqIHgwO1xuICAgIHZhciBDID0gMyAqIHgxIC0gMyAqIHgwO1xuICAgIHZhciBEID0geDA7XG4gICAgdmFyIEUgPSB5MyAtIDMgKiB5MiArIDMgKiB5MSAtIHkwO1xuICAgIHZhciBGID0gMyAqIHkyIC0gNiAqIHkxICsgMyAqIHkwO1xuICAgIHZhciBHID0gMyAqIHkxIC0gMyAqIHkwO1xuICAgIHZhciBIID0geTA7IC8vIFZhcmlhYmxlcyBmb3IgdGhlIGxvb3AgYmVsb3dcblxuICAgIHZhciBpdGVyYXRpb25zID0gNTtcbiAgICB2YXIgaTtcbiAgICB2YXIgc2xvcGU7XG4gICAgdmFyIHg7XG4gICAgdmFyIHQgPSB0eDsgLy8gTG9vcCB0aHJvdWdoIGEgZmV3IHRpbWVzIHRvIGdldCBhIG1vcmUgYWNjdXJhdGUgdGltZSB2YWx1ZSwgYWNjb3JkaW5nIHRvIHRoZSBOZXd0b24tUmFwaHNvbiBtZXRob2RcbiAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL05ld3RvbidzX21ldGhvZFxuXG4gICAgZm9yIChpID0gMDsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgLy8gVGhlIGN1cnZlJ3MgeCBlcXVhdGlvbiBmb3IgdGhlIGN1cnJlbnQgdGltZSB2YWx1ZVxuICAgICAgeCA9IEEgKiB0ICogdCAqIHQgKyBCICogdCAqIHQgKyBDICogdCArIEQ7IC8vIFRoZSBzbG9wZSB3ZSB3YW50IGlzIHRoZSBpbnZlcnNlIG9mIHRoZSBkZXJpdmF0ZSBvZiB4XG5cbiAgICAgIHNsb3BlID0gMSAvICgzICogQSAqIHQgKiB0ICsgMiAqIEIgKiB0ICsgQyk7IC8vIEdldCB0aGUgbmV4dCBlc3RpbWF0ZWQgdGltZSB2YWx1ZSwgd2hpY2ggd2lsbCBiZSBtb3JlIGFjY3VyYXRlIHRoYW4gdGhlIG9uZSBiZWZvcmVcblxuICAgICAgdCAtPSAoeCAtIHR4KSAqIHNsb3BlO1xuICAgICAgdCA9IHQgPiAxID8gMSA6IHQgPCAwID8gMCA6IHQ7XG4gICAgfSAvLyBGaW5kIHRoZSB5IHZhbHVlIHRocm91Z2ggdGhlIGN1cnZlJ3MgeSBlcXVhdGlvbiwgd2l0aCB0aGUgbm93IG1vcmUgYWNjdXJhdGUgdGltZSB2YWx1ZVxuXG5cbiAgICByZXR1cm4gTWF0aC5hYnMoRSAqIHQgKiB0ICogdCArIEYgKiB0ICogdCArIEcgKiB0ICogSCk7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IGEgYmV6aWVyIGN1cnZlIGRhdGEgZm9yIGEgc3BsaW5lIHRoYXQgZml0cyBhbiBhcnJheSBvZiBwb2ludHMuXHJcbiAgICogQHBhcmFtIHBvaW50cyBBbiBhcnJheSBvZiBwb2ludHMgZm9ybWF0dGVkIGFzIFt4LCB5XVxyXG4gICAqIEBwYXJhbSBrIFRlbnNpb25cclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLmdldFNwbGluZSA9IGZ1bmN0aW9uIGdldFNwbGluZShwdHMsIGspIHtcbiAgICBpZiAoayA9PT0gdm9pZCAwKSB7XG4gICAgICBrID0gMC41O1xuICAgIH1cblxuICAgIHZhciBwMDtcbiAgICB2YXIgcDEgPSBwdHNbMF0sXG4gICAgICAgIHAyID0gcHRzWzFdLFxuICAgICAgICBwMyA9IHB0c1syXTtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IHB0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcDAgPSBwMTtcbiAgICAgIHAxID0gcDI7XG4gICAgICBwMiA9IHAzO1xuICAgICAgcDMgPSBwdHNbaSArIDJdID8gcHRzW2kgKyAyXSA6IHAyO1xuICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgY3AxeDogcDFbMF0gKyAocDJbMF0gLSBwMFswXSkgLyA2ICogayxcbiAgICAgICAgY3AxeTogcDFbMV0gKyAocDJbMV0gLSBwMFsxXSkgLyA2ICogayxcbiAgICAgICAgY3AyeDogcDJbMF0gLSAocDNbMF0gLSBwMVswXSkgLyA2ICogayxcbiAgICAgICAgY3AyeTogcDJbMV0gLSAocDNbMV0gLSBwMVsxXSkgLyA2ICogayxcbiAgICAgICAgcHg6IHB0c1tpXVswXSxcbiAgICAgICAgcHk6IHB0c1tpXVsxXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IGEgYmV6aWVyIGN1cnZlIGRhdGEgZm9yIGEgc3BsaW5lIHRoYXQgZml0cyBhbiBhcnJheSBvZiBwb2ludHMuXHJcbiAgICogQHBhcmFtIHB0c1xyXG4gICAqIEBwYXJhbSB0ZW5zaW9uXHJcbiAgICogQHBhcmFtIGlzQ2xvc2VkXHJcbiAgICogQHBhcmFtIG51bU9mU2VnbWVudHNcclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLmdldEN1cnZlUG9pbnRzID0gZnVuY3Rpb24gZ2V0Q3VydmVQb2ludHMocHRzLCB0ZW5zaW9uLCBpc0Nsb3NlZCwgbnVtT2ZTZWdtZW50cykge1xuICAgIGlmICh0ZW5zaW9uID09PSB2b2lkIDApIHtcbiAgICAgIHRlbnNpb24gPSAwLjU7XG4gICAgfVxuXG4gICAgaWYgKGlzQ2xvc2VkID09PSB2b2lkIDApIHtcbiAgICAgIGlzQ2xvc2VkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG51bU9mU2VnbWVudHMgPT09IHZvaWQgMCkge1xuICAgICAgbnVtT2ZTZWdtZW50cyA9IDM7XG4gICAgfVxuXG4gICAgdmFyIF9wdHMgPSBbXS5jb25jYXQocHRzKTtcblxuICAgIHZhciBsZW4gPSBwdHMubGVuZ3RoO1xuICAgIHZhciByZXMgPSBbXTsgLy8gcmVzdWx0c1xuXG4gICAgdmFyIHQxeCwgLy8gdGVuc2lvbiB2ZWN0b3JzXG4gICAgdDJ4LCB0MXksIHQyeSwgYzEsIC8vIGNhcmRpbmFsIHBvaW50c1xuICAgIGMyLCBjMywgYzQsIHN0LCBzdDIsIHN0MzsgLy8gVGhlIGFsZ29yaXRobSByZXF1aXJlIGEgcHJldmlvdXMgYW5kIG5leHQgcG9pbnQgdG8gdGhlIGFjdHVhbCBwb2ludCBhcnJheS5cbiAgICAvLyBDaGVjayBpZiB3ZSB3aWxsIGRyYXcgY2xvc2VkIG9yIG9wZW4gY3VydmUuXG4gICAgLy8gSWYgY2xvc2VkLCBjb3B5IGVuZCBwb2ludHMgdG8gYmVnaW5uaW5nIGFuZCBmaXJzdCBwb2ludHMgdG8gZW5kXG4gICAgLy8gSWYgb3BlbiwgZHVwbGljYXRlIGZpcnN0IHBvaW50cyB0byBiZWZpbm5pbmcsIGVuZCBwb2ludHMgdG8gZW5kXG5cbiAgICBpZiAoaXNDbG9zZWQpIHtcbiAgICAgIF9wdHMudW5zaGlmdChfcHRzW2xlbiAtIDFdKTtcblxuICAgICAgX3B0cy5wdXNoKF9wdHNbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb3B5IDEuIHBvaW50IGFuZCBpbnNlcnQgYXQgYmVnaW5uaW5nXG4gICAgICBfcHRzLnVuc2hpZnQoX3B0c1swXSk7XG5cbiAgICAgIF9wdHMucHVzaChfcHRzW2xlbiAtIDFdKTsgLy8gX3B0cy5wdXNoKF9wdHNbbGVuIC0gMV0pXG5cbiAgICB9IC8vIEZvciBlYWNoIHBvaW50LCBjYWxjdWxhdGUgYSBzZWdtZW50XG5cblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgX3B0cy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgIC8vIENhbGN1bGF0ZSBwb2ludHMgYWxvbmcgc2VnbWVudCBhbmQgYWRkIHRvIHJlc3VsdHNcbiAgICAgIGZvciAodmFyIHQgPSAwOyB0IDw9IG51bU9mU2VnbWVudHM7IHQrKykge1xuICAgICAgICAvLyBTdGVwXG4gICAgICAgIHN0ID0gdCAvIG51bU9mU2VnbWVudHM7XG4gICAgICAgIHN0MiA9IE1hdGgucG93KHN0LCAyKTtcbiAgICAgICAgc3QzID0gTWF0aC5wb3coc3QsIDMpOyAvLyBDYXJkaW5hbHNcblxuICAgICAgICBjMSA9IDIgKiBzdDMgLSAzICogc3QyICsgMTtcbiAgICAgICAgYzIgPSAtKDIgKiBzdDMpICsgMyAqIHN0MjtcbiAgICAgICAgYzMgPSBzdDMgLSAyICogc3QyICsgc3Q7XG4gICAgICAgIGM0ID0gc3QzIC0gc3QyOyAvLyBUZW5zaW9uXG5cbiAgICAgICAgdDF4ID0gKF9wdHNbaSArIDFdWzBdIC0gX3B0c1tpIC0gMV1bMF0pICogdGVuc2lvbjtcbiAgICAgICAgdDJ4ID0gKF9wdHNbaSArIDJdWzBdIC0gX3B0c1tpXVswXSkgKiB0ZW5zaW9uO1xuICAgICAgICB0MXkgPSAoX3B0c1tpICsgMV1bMV0gLSBfcHRzW2kgLSAxXVsxXSkgKiB0ZW5zaW9uO1xuICAgICAgICB0MnkgPSAoX3B0c1tpICsgMl1bMV0gLSBfcHRzW2ldWzFdKSAqIHRlbnNpb247IC8vIENvbnRyb2wgcG9pbnRzXG5cbiAgICAgICAgcmVzLnB1c2goW2MxICogX3B0c1tpXVswXSArIGMyICogX3B0c1tpICsgMV1bMF0gKyBjMyAqIHQxeCArIGM0ICogdDJ4LCBjMSAqIF9wdHNbaV1bMV0gKyBjMiAqIF9wdHNbaSArIDFdWzFdICsgYzMgKiB0MXkgKyBjNCAqIHQyeV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlcy5wdXNoKHB0c1twdHMubGVuZ3RoIC0gMV0pO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgLyoqXHJcbiAgICogU2ltcGxpZnkgYSBsaW5lICh1c2luZyBSYW1lci1Eb3VnbGFzLVBldWNrZXIgYWxnb3JpdGhtKS5cclxuICAgKiBAcGFyYW0gcG9pbnRzIEFuIGFycmF5IG9mIHBvaW50cyBhcyBbeCwgeSwgLi4uXVtdXHJcbiAgICogQHBhcmFtIHRvbGVyYW5jZSBUaGUgbWluaW11bSBsaW5lIGRpc3RhbmNlIChhbHNvIGNhbGxlZCBlcHNpbG9uKS5cclxuICAgKiBAcmV0dXJucyBTaW1wbGlmaWVkIGFycmF5IGFzIFt4LCB5LCAuLi5dW11cclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLnNpbXBsaWZ5ID0gZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzLCB0b2xlcmFuY2UpIHtcbiAgICBpZiAodG9sZXJhbmNlID09PSB2b2lkIDApIHtcbiAgICAgIHRvbGVyYW5jZSA9IDE7XG4gICAgfVxuXG4gICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgdmFyIGEgPSBwb2ludHNbMF07XG4gICAgdmFyIGIgPSBwb2ludHNbbGVuIC0gMV07XG4gICAgdmFyIHgxID0gYVswXSxcbiAgICAgICAgeTEgPSBhWzFdO1xuICAgIHZhciB4MiA9IGJbMF0sXG4gICAgICAgIHkyID0gYlsxXTtcblxuICAgIGlmIChsZW4gPiAyKSB7XG4gICAgICB2YXIgZGlzdGFuY2UgPSAwO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciBtYXggPSBNYXRoLmh5cG90KHkyIC0geTEsIHgyIC0geDEpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbiAtIDE7IGkrKykge1xuICAgICAgICB2YXIgX3BvaW50cyRpID0gcG9pbnRzW2ldLFxuICAgICAgICAgICAgeDAgPSBfcG9pbnRzJGlbMF0sXG4gICAgICAgICAgICB5MCA9IF9wb2ludHMkaVsxXTtcbiAgICAgICAgdmFyIGQgPSBNYXRoLmFicygoeTIgLSB5MSkgKiB4MCAtICh4MiAtIHgxKSAqIHkwICsgeDIgKiB5MSAtIHkyICogeDEpIC8gbWF4O1xuICAgICAgICBpZiAoZGlzdGFuY2UgPiBkKSBjb250aW51ZTtcbiAgICAgICAgZGlzdGFuY2UgPSBkO1xuICAgICAgICBpbmRleCA9IGk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXN0YW5jZSA+IHRvbGVyYW5jZSkge1xuICAgICAgICB2YXIgbDAgPSBVdGlscy5zaW1wbGlmeShwb2ludHMuc2xpY2UoMCwgaW5kZXggKyAxKSwgdG9sZXJhbmNlKTtcbiAgICAgICAgdmFyIGwxID0gVXRpbHMuc2ltcGxpZnkocG9pbnRzLnNsaWNlKGluZGV4ICsgMSksIHRvbGVyYW5jZSk7XG4gICAgICAgIHJldHVybiBsMC5jb25jYXQobDEuc2xpY2UoMSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbYSwgYl07XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IHdoZXRoZXIgYSBwb2ludCBpcyBpbnNpZGUgb2YgYSBjaXJjbGUuXHJcbiAgICogQHBhcmFtIEFcclxuICAgKiBAcGFyYW0gYlxyXG4gICAqIEByZXR1cm5zXHJcbiAgICovXG4gIDtcblxuICBVdGlscy5wb2ludEluQ2lyY2xlID0gZnVuY3Rpb24gcG9pbnRJbkNpcmNsZShBLCBDLCByKSB7XG4gICAgcmV0dXJuIFZlYy5kaXN0KEEsIEMpIDw9IHI7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IHdoZXRoZXIgYSBwb2ludCBpcyBpbnNpZGUgb2YgYW4gZWxsaXBzZS5cclxuICAgKiBAcGFyYW0gcG9pbnRcclxuICAgKiBAcGFyYW0gY2VudGVyXHJcbiAgICogQHBhcmFtIHJ4XHJcbiAgICogQHBhcmFtIHJ5XHJcbiAgICogQHBhcmFtIHJvdGF0aW9uXHJcbiAgICogQHJldHVybnNcclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLnBvaW50SW5FbGxpcHNlID0gZnVuY3Rpb24gcG9pbnRJbkVsbGlwc2UoQSwgQywgcngsIHJ5LCByb3RhdGlvbikge1xuICAgIGlmIChyb3RhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICByb3RhdGlvbiA9IDA7XG4gICAgfVxuXG4gICAgcm90YXRpb24gPSByb3RhdGlvbiB8fCAwO1xuICAgIHZhciBjb3MgPSBNYXRoLmNvcyhyb3RhdGlvbik7XG4gICAgdmFyIHNpbiA9IE1hdGguc2luKHJvdGF0aW9uKTtcbiAgICB2YXIgZGVsdGEgPSBWZWMuc3ViKEEsIEMpO1xuICAgIHZhciB0ZHggPSBjb3MgKiBkZWx0YVswXSArIHNpbiAqIGRlbHRhWzFdO1xuICAgIHZhciB0ZHkgPSBzaW4gKiBkZWx0YVswXSAtIGNvcyAqIGRlbHRhWzFdO1xuICAgIHJldHVybiB0ZHggKiB0ZHggLyAocnggKiByeCkgKyB0ZHkgKiB0ZHkgLyAocnkgKiByeSkgPD0gMTtcbiAgfVxuICAvKipcclxuICAgKiBHZXQgd2hldGhlciBhIHBvaW50IGlzIGluc2lkZSBvZiBhIHJlY3RhbmdsZS5cclxuICAgKiBAcGFyYW0gcG9pbnRcclxuICAgKiBAcGFyYW0gc2l6ZVxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMucG9pbnRJblJlY3QgPSBmdW5jdGlvbiBwb2ludEluUmVjdChwb2ludCwgc2l6ZSkge1xuICAgIHJldHVybiAhKHBvaW50WzBdIDwgc2l6ZVswXSB8fCBwb2ludFswXSA+IHBvaW50WzBdICsgc2l6ZVswXSB8fCBwb2ludFsxXSA8IHNpemVbMV0gfHwgcG9pbnRbMV0gPiBwb2ludFsxXSArIHNpemVbMV0pO1xuICB9XG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLSBCb3VuZHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgLyoqXHJcbiAgICogRXhwYW5kIGEgYm91bmRpbmcgYm94IGJ5IGEgZGVsdGEuXHJcbiAgICpcclxuICAgKiAjIyMgRXhhbXBsZVxyXG4gICAqXHJcbiAgICpgYGB0c1xyXG4gICAqIGV4cGFuZEJvdW5kcyhteUJvdW5kcywgWzEwMCwgMTAwXSlcclxuICAgKmBgYFxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuZXhwYW5kQm91bmRzID0gZnVuY3Rpb24gZXhwYW5kQm91bmRzKGJvdW5kcywgZGVsdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWluWDogYm91bmRzLm1pblggLSBkZWx0YSxcbiAgICAgIG1pblk6IGJvdW5kcy5taW5ZIC0gZGVsdGEsXG4gICAgICBtYXhYOiBib3VuZHMubWF4WCArIGRlbHRhLFxuICAgICAgbWF4WTogYm91bmRzLm1heFkgKyBkZWx0YSxcbiAgICAgIHdpZHRoOiBib3VuZHMud2lkdGggKyBkZWx0YSAqIDIsXG4gICAgICBoZWlnaHQ6IGJvdW5kcy5oZWlnaHQgKyBkZWx0YSAqIDJcbiAgICB9O1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCB3aGV0aGVyIGEgcG9pbnQgaXMgaW5zaWRlIG9mIGEgYm91bmRzLlxyXG4gICAqIEBwYXJhbSBBXHJcbiAgICogQHBhcmFtIGJcclxuICAgKiBAcmV0dXJuc1xyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMucG9pbnRJbkJvdW5kcyA9IGZ1bmN0aW9uIHBvaW50SW5Cb3VuZHMoQSwgYikge1xuICAgIHJldHVybiAhKEFbMF0gPCBiLm1pblggfHwgQVswXSA+IGIubWF4WCB8fCBBWzFdIDwgYi5taW5ZIHx8IEFbMV0gPiBiLm1heFkpO1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCB3aGV0aGVyIHR3byBib3VuZHMgY29sbGlkZS5cclxuICAgKiBAcGFyYW0gYSBCb3VuZHNcclxuICAgKiBAcGFyYW0gYiBCb3VuZHNcclxuICAgKiBAcmV0dXJuc1xyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuYm91bmRzQ29sbGlkZSA9IGZ1bmN0aW9uIGJvdW5kc0NvbGxpZGUoYSwgYikge1xuICAgIHJldHVybiAhKGEubWF4WCA8IGIubWluWCB8fCBhLm1pblggPiBiLm1heFggfHwgYS5tYXhZIDwgYi5taW5ZIHx8IGEubWluWSA+IGIubWF4WSk7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IHdoZXRoZXIgdGhlIGJvdW5kcyBvZiBBIGNvbnRhaW4gdGhlIGJvdW5kcyBvZiBCLiBBIHBlcmZlY3QgbWF0Y2ggd2lsbCByZXR1cm4gdHJ1ZS5cclxuICAgKiBAcGFyYW0gYSBCb3VuZHNcclxuICAgKiBAcGFyYW0gYiBCb3VuZHNcclxuICAgKiBAcmV0dXJuc1xyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuYm91bmRzQ29udGFpbiA9IGZ1bmN0aW9uIGJvdW5kc0NvbnRhaW4oYSwgYikge1xuICAgIHJldHVybiBhLm1pblggPCBiLm1pblggJiYgYS5taW5ZIDwgYi5taW5ZICYmIGEubWF4WSA+IGIubWF4WSAmJiBhLm1heFggPiBiLm1heFg7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IHdoZXRoZXIgdGhlIGJvdW5kcyBvZiBBIGFyZSBjb250YWluZWQgYnkgdGhlIGJvdW5kcyBvZiBCLlxyXG4gICAqIEBwYXJhbSBhIEJvdW5kc1xyXG4gICAqIEBwYXJhbSBiIEJvdW5kc1xyXG4gICAqIEByZXR1cm5zXHJcbiAgICovXG4gIDtcblxuICBVdGlscy5ib3VuZHNDb250YWluZWQgPSBmdW5jdGlvbiBib3VuZHNDb250YWluZWQoYSwgYikge1xuICAgIHJldHVybiBVdGlscy5ib3VuZHNDb250YWluKGIsIGEpO1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCB3aGV0aGVyIHR3byBib3VuZHMgYXJlIGlkZW50aWNhbC5cclxuICAgKiBAcGFyYW0gYSBCb3VuZHNcclxuICAgKiBAcGFyYW0gYiBCb3VuZHNcclxuICAgKiBAcmV0dXJuc1xyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuYm91bmRzQXJlRXF1YWwgPSBmdW5jdGlvbiBib3VuZHNBcmVFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuICEoYi5tYXhYICE9PSBhLm1heFggfHwgYi5taW5YICE9PSBhLm1pblggfHwgYi5tYXhZICE9PSBhLm1heFkgfHwgYi5taW5ZICE9PSBhLm1pblkpO1xuICB9XG4gIC8qKlxyXG4gICAqIEZpbmQgYSBib3VuZGluZyBib3ggZnJvbSBhbiBhcnJheSBvZiBwb2ludHMuXHJcbiAgICogQHBhcmFtIHBvaW50c1xyXG4gICAqIEBwYXJhbSByb3RhdGlvbiAob3B0aW9uYWwpIFRoZSBib3VuZGluZyBib3gncyByb3RhdGlvbi5cclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLmdldEJvdW5kc0Zyb21Qb2ludHMgPSBmdW5jdGlvbiBnZXRCb3VuZHNGcm9tUG9pbnRzKHBvaW50cywgcm90YXRpb24pIHtcbiAgICBpZiAocm90YXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgcm90YXRpb24gPSAwO1xuICAgIH1cblxuICAgIHZhciBtaW5YID0gSW5maW5pdHk7XG4gICAgdmFyIG1pblkgPSBJbmZpbml0eTtcbiAgICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcbiAgICB2YXIgbWF4WSA9IC1JbmZpbml0eTtcblxuICAgIGlmIChwb2ludHMubGVuZ3RoIDwgMikge1xuICAgICAgbWluWCA9IDA7XG4gICAgICBtaW5ZID0gMDtcbiAgICAgIG1heFggPSAxO1xuICAgICAgbWF4WSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UocG9pbnRzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIF9zdGVwJHZhbHVlID0gX3N0ZXAudmFsdWUsXG4gICAgICAgICAgICB4ID0gX3N0ZXAkdmFsdWVbMF0sXG4gICAgICAgICAgICB5ID0gX3N0ZXAkdmFsdWVbMV07XG4gICAgICAgIG1pblggPSBNYXRoLm1pbih4LCBtaW5YKTtcbiAgICAgICAgbWluWSA9IE1hdGgubWluKHksIG1pblkpO1xuICAgICAgICBtYXhYID0gTWF0aC5tYXgoeCwgbWF4WCk7XG4gICAgICAgIG1heFkgPSBNYXRoLm1heCh5LCBtYXhZKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocm90YXRpb24gIT09IDApIHtcbiAgICAgIHJldHVybiBVdGlscy5nZXRCb3VuZHNGcm9tUG9pbnRzKHBvaW50cy5tYXAoZnVuY3Rpb24gKHB0KSB7XG4gICAgICAgIHJldHVybiBWZWMucm90V2l0aChwdCwgWyhtaW5YICsgbWF4WCkgLyAyLCAobWluWSArIG1heFkpIC8gMl0sIHJvdGF0aW9uKTtcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWluWDogbWluWCxcbiAgICAgIG1pblk6IG1pblksXG4gICAgICBtYXhYOiBtYXhYLFxuICAgICAgbWF4WTogbWF4WSxcbiAgICAgIHdpZHRoOiBNYXRoLm1heCgxLCBtYXhYIC0gbWluWCksXG4gICAgICBoZWlnaHQ6IE1hdGgubWF4KDEsIG1heFkgLSBtaW5ZKVxuICAgIH07XG4gIH1cbiAgLyoqXHJcbiAgICogTW92ZSBhIGJvdW5kaW5nIGJveCB3aXRob3V0IHJlY2FsY3VsYXRpbmcgaXQuXHJcbiAgICogQHBhcmFtIGJvdW5kc1xyXG4gICAqIEBwYXJhbSBkZWx0YVxyXG4gICAqIEByZXR1cm5zXHJcbiAgICovXG4gIDtcblxuICBVdGlscy50cmFuc2xhdGVCb3VuZHMgPSBmdW5jdGlvbiB0cmFuc2xhdGVCb3VuZHMoYm91bmRzLCBkZWx0YSkge1xuICAgIHJldHVybiB7XG4gICAgICBtaW5YOiBib3VuZHMubWluWCArIGRlbHRhWzBdLFxuICAgICAgbWluWTogYm91bmRzLm1pblkgKyBkZWx0YVsxXSxcbiAgICAgIG1heFg6IGJvdW5kcy5tYXhYICsgZGVsdGFbMF0sXG4gICAgICBtYXhZOiBib3VuZHMubWF4WSArIGRlbHRhWzFdLFxuICAgICAgd2lkdGg6IGJvdW5kcy53aWR0aCxcbiAgICAgIGhlaWdodDogYm91bmRzLmhlaWdodFxuICAgIH07XG4gIH1cbiAgLyoqXHJcbiAgICogUm90YXRlIGEgYm91bmRpbmcgYm94LlxyXG4gICAqIEBwYXJhbSBib3VuZHNcclxuICAgKiBAcGFyYW0gY2VudGVyXHJcbiAgICogQHBhcmFtIHJvdGF0aW9uXHJcbiAgICovXG4gIDtcblxuICBVdGlscy5yb3RhdGVCb3VuZHMgPSBmdW5jdGlvbiByb3RhdGVCb3VuZHMoYm91bmRzLCBjZW50ZXIsIHJvdGF0aW9uKSB7XG4gICAgdmFyIF92ZWMkcm90V2l0aCA9IFZlYy5yb3RXaXRoKFtib3VuZHMubWluWCwgYm91bmRzLm1pblldLCBjZW50ZXIsIHJvdGF0aW9uKSxcbiAgICAgICAgbWluWCA9IF92ZWMkcm90V2l0aFswXSxcbiAgICAgICAgbWluWSA9IF92ZWMkcm90V2l0aFsxXTtcblxuICAgIHZhciBfdmVjJHJvdFdpdGgyID0gVmVjLnJvdFdpdGgoW2JvdW5kcy5tYXhYLCBib3VuZHMubWF4WV0sIGNlbnRlciwgcm90YXRpb24pLFxuICAgICAgICBtYXhYID0gX3ZlYyRyb3RXaXRoMlswXSxcbiAgICAgICAgbWF4WSA9IF92ZWMkcm90V2l0aDJbMV07XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWluWDogbWluWCxcbiAgICAgIG1pblk6IG1pblksXG4gICAgICBtYXhYOiBtYXhYLFxuICAgICAgbWF4WTogbWF4WSxcbiAgICAgIHdpZHRoOiBib3VuZHMud2lkdGgsXG4gICAgICBoZWlnaHQ6IGJvdW5kcy5oZWlnaHRcbiAgICB9O1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCB0aGUgcm90YXRlZCBib3VuZHMgb2YgYW4gZWxsaXBzZS5cclxuICAgKiBAcGFyYW0geFxyXG4gICAqIEBwYXJhbSB5XHJcbiAgICogQHBhcmFtIHJ4XHJcbiAgICogQHBhcmFtIHJ5XHJcbiAgICogQHBhcmFtIHJvdGF0aW9uXHJcbiAgICovXG4gIDtcblxuICBVdGlscy5nZXRSb3RhdGVkRWxsaXBzZUJvdW5kcyA9IGZ1bmN0aW9uIGdldFJvdGF0ZWRFbGxpcHNlQm91bmRzKHgsIHksIHJ4LCByeSwgcm90YXRpb24pIHtcbiAgICB2YXIgYyA9IE1hdGguY29zKHJvdGF0aW9uKTtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJvdGF0aW9uKTtcbiAgICB2YXIgdyA9IE1hdGguaHlwb3QocnggKiBjLCByeSAqIHMpO1xuICAgIHZhciBoID0gTWF0aC5oeXBvdChyeCAqIHMsIHJ5ICogYyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pblg6IHggKyByeCAtIHcsXG4gICAgICBtaW5ZOiB5ICsgcnkgLSBoLFxuICAgICAgbWF4WDogeCArIHJ4ICsgdyxcbiAgICAgIG1heFk6IHkgKyByeSArIGgsXG4gICAgICB3aWR0aDogdyAqIDIsXG4gICAgICBoZWlnaHQ6IGggKiAyXG4gICAgfTtcbiAgfVxuICAvKipcclxuICAgKiBHZXQgYSBib3VuZGluZyBib3ggdGhhdCBpbmNsdWRlcyB0d28gYm91bmRpbmcgYm94ZXMuXHJcbiAgICogQHBhcmFtIGEgQm91bmRpbmcgYm94XHJcbiAgICogQHBhcmFtIGIgQm91bmRpbmcgYm94XHJcbiAgICogQHJldHVybnNcclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLmdldEV4cGFuZGVkQm91bmRzID0gZnVuY3Rpb24gZ2V0RXhwYW5kZWRCb3VuZHMoYSwgYikge1xuICAgIHZhciBtaW5YID0gTWF0aC5taW4oYS5taW5YLCBiLm1pblgpO1xuICAgIHZhciBtaW5ZID0gTWF0aC5taW4oYS5taW5ZLCBiLm1pblkpO1xuICAgIHZhciBtYXhYID0gTWF0aC5tYXgoYS5tYXhYLCBiLm1heFgpO1xuICAgIHZhciBtYXhZID0gTWF0aC5tYXgoYS5tYXhZLCBiLm1heFkpO1xuICAgIHZhciB3aWR0aCA9IE1hdGguYWJzKG1heFggLSBtaW5YKTtcbiAgICB2YXIgaGVpZ2h0ID0gTWF0aC5hYnMobWF4WSAtIG1pblkpO1xuICAgIHJldHVybiB7XG4gICAgICBtaW5YOiBtaW5YLFxuICAgICAgbWluWTogbWluWSxcbiAgICAgIG1heFg6IG1heFgsXG4gICAgICBtYXhZOiBtYXhZLFxuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9O1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCB0aGUgY29tbW9uIGJvdW5kcyBvZiBhIGdyb3VwIG9mIGJvdW5kcy5cclxuICAgKiBAcmV0dXJuc1xyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuZ2V0Q29tbW9uQm91bmRzID0gZnVuY3Rpb24gZ2V0Q29tbW9uQm91bmRzKGJvdW5kcykge1xuICAgIGlmIChib3VuZHMubGVuZ3RoIDwgMikgcmV0dXJuIGJvdW5kc1swXTtcbiAgICB2YXIgcmVzdWx0ID0gYm91bmRzWzBdO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBib3VuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdCA9IFV0aWxzLmdldEV4cGFuZGVkQm91bmRzKHJlc3VsdCwgYm91bmRzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIFV0aWxzLmdldFJvdGF0ZWRDb3JuZXJzID0gZnVuY3Rpb24gZ2V0Um90YXRlZENvcm5lcnMoYiwgcm90YXRpb24pIHtcbiAgICBpZiAocm90YXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgcm90YXRpb24gPSAwO1xuICAgIH1cblxuICAgIHZhciBjZW50ZXIgPSBbYi5taW5YICsgYi53aWR0aCAvIDIsIGIubWluWSArIGIuaGVpZ2h0IC8gMl07XG4gICAgcmV0dXJuIFtbYi5taW5YLCBiLm1pblldLCBbYi5tYXhYLCBiLm1pblldLCBbYi5tYXhYLCBiLm1heFldLCBbYi5taW5YLCBiLm1heFldXS5tYXAoZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICByZXR1cm4gVmVjLnJvdFdpdGgocG9pbnQsIGNlbnRlciwgcm90YXRpb24pO1xuICAgIH0pO1xuICB9O1xuXG4gIFV0aWxzLmdldFRyYW5zZm9ybWVkQm91bmRpbmdCb3ggPSBmdW5jdGlvbiBnZXRUcmFuc2Zvcm1lZEJvdW5kaW5nQm94KGJvdW5kcywgaGFuZGxlLCBkZWx0YSwgcm90YXRpb24sIGlzQXNwZWN0UmF0aW9Mb2NrZWQpIHtcbiAgICBpZiAocm90YXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgcm90YXRpb24gPSAwO1xuICAgIH1cblxuICAgIGlmIChpc0FzcGVjdFJhdGlvTG9ja2VkID09PSB2b2lkIDApIHtcbiAgICAgIGlzQXNwZWN0UmF0aW9Mb2NrZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgdG9wIGxlZnQgYW5kIGJvdHRvbSByaWdodCBjb3JuZXJzLlxuICAgIHZhciBfcmVmID0gW2JvdW5kcy5taW5YLCBib3VuZHMubWluWV0sXG4gICAgICAgIGF4MCA9IF9yZWZbMF0sXG4gICAgICAgIGF5MCA9IF9yZWZbMV07XG4gICAgdmFyIF9yZWYyID0gW2JvdW5kcy5tYXhYLCBib3VuZHMubWF4WV0sXG4gICAgICAgIGF4MSA9IF9yZWYyWzBdLFxuICAgICAgICBheTEgPSBfcmVmMlsxXTsgLy8gQ3JlYXRlIGEgc2Vjb25kIHNldCBvZiBjb3JuZXJzIGZvciB0aGUgbmV3IGJveC5cblxuICAgIHZhciBfcmVmMyA9IFtib3VuZHMubWluWCwgYm91bmRzLm1pblldLFxuICAgICAgICBieDAgPSBfcmVmM1swXSxcbiAgICAgICAgYnkwID0gX3JlZjNbMV07XG4gICAgdmFyIF9yZWY0ID0gW2JvdW5kcy5tYXhYLCBib3VuZHMubWF4WV0sXG4gICAgICAgIGJ4MSA9IF9yZWY0WzBdLFxuICAgICAgICBieTEgPSBfcmVmNFsxXTsgLy8gSWYgdGhlIGRyYWcgaXMgb24gdGhlIGNlbnRlciwganVzdCB0cmFuc2xhdGUgdGhlIGJvdW5kcy5cblxuICAgIGlmIChoYW5kbGUgPT09ICdjZW50ZXInKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW5YOiBieDAgKyBkZWx0YVswXSxcbiAgICAgICAgbWluWTogYnkwICsgZGVsdGFbMV0sXG4gICAgICAgIG1heFg6IGJ4MSArIGRlbHRhWzBdLFxuICAgICAgICBtYXhZOiBieTEgKyBkZWx0YVsxXSxcbiAgICAgICAgd2lkdGg6IGJ4MSAtIGJ4MCxcbiAgICAgICAgaGVpZ2h0OiBieTEgLSBieTAsXG4gICAgICAgIHNjYWxlWDogMSxcbiAgICAgICAgc2NhbGVZOiAxXG4gICAgICB9O1xuICAgIH0gLy8gQ291bnRlciByb3RhdGUgdGhlIGRlbHRhLiBUaGlzIGxldHMgdXMgbWFrZSBjaGFuZ2VzIGFzIGlmXG4gICAgLy8gdGhlIChwb3NzaWJseSByb3RhdGVkKSBib3hlcyB3ZXJlIGF4aXMgYWxpZ25lZC5cblxuXG4gICAgdmFyIF92ZWMkcm90ID0gVmVjLnJvdChkZWx0YSwgLXJvdGF0aW9uKSxcbiAgICAgICAgZHggPSBfdmVjJHJvdFswXSxcbiAgICAgICAgZHkgPSBfdmVjJHJvdFsxXTtcbiAgICAvKlxyXG4gICAgMS4gRGVsdGFcclxuICAgICBVc2UgdGhlIGRlbHRhIHRvIGFkanVzdCB0aGUgbmV3IGJveCBieSBjaGFuZ2luZyBpdHMgY29ybmVycy5cclxuICAgIFRoZSBkcmFnZ2luZyBoYW5kbGUgKGNvcm5lciBvciBlZGdlKSB3aWxsIGRldGVybWluZSB3aGljaFxyXG4gICAgY29ybmVycyBzaG91bGQgY2hhbmdlLlxyXG4gICAgKi9cblxuXG4gICAgc3dpdGNoIChoYW5kbGUpIHtcbiAgICAgIGNhc2UgZXhwb3J0cy5UTEJvdW5kc0VkZ2UuVG9wOlxuICAgICAgY2FzZSBleHBvcnRzLlRMQm91bmRzQ29ybmVyLlRvcExlZnQ6XG4gICAgICBjYXNlIGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuVG9wUmlnaHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBieTAgKz0gZHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBleHBvcnRzLlRMQm91bmRzRWRnZS5Cb3R0b206XG4gICAgICBjYXNlIGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuQm90dG9tTGVmdDpcbiAgICAgIGNhc2UgZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Cb3R0b21SaWdodDpcbiAgICAgICAge1xuICAgICAgICAgIGJ5MSArPSBkeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAoaGFuZGxlKSB7XG4gICAgICBjYXNlIGV4cG9ydHMuVExCb3VuZHNFZGdlLkxlZnQ6XG4gICAgICBjYXNlIGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuVG9wTGVmdDpcbiAgICAgIGNhc2UgZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Cb3R0b21MZWZ0OlxuICAgICAgICB7XG4gICAgICAgICAgYngwICs9IGR4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgZXhwb3J0cy5UTEJvdW5kc0VkZ2UuUmlnaHQ6XG4gICAgICBjYXNlIGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuVG9wUmlnaHQ6XG4gICAgICBjYXNlIGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuQm90dG9tUmlnaHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBieDEgKz0gZHg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYXcgPSBheDEgLSBheDA7XG4gICAgdmFyIGFoID0gYXkxIC0gYXkwO1xuICAgIHZhciBzY2FsZVggPSAoYngxIC0gYngwKSAvIGF3O1xuICAgIHZhciBzY2FsZVkgPSAoYnkxIC0gYnkwKSAvIGFoO1xuICAgIHZhciBmbGlwWCA9IHNjYWxlWCA8IDA7XG4gICAgdmFyIGZsaXBZID0gc2NhbGVZIDwgMDtcbiAgICB2YXIgYncgPSBNYXRoLmFicyhieDEgLSBieDApO1xuICAgIHZhciBiaCA9IE1hdGguYWJzKGJ5MSAtIGJ5MCk7XG4gICAgLypcclxuICAgIDIuIEFzcGVjdCByYXRpb1xyXG4gICAgIElmIHRoZSBhc3BlY3QgcmF0aW8gaXMgbG9ja2VkLCBhZGp1c3QgdGhlIGNvcm5lcnMgc28gdGhhdCB0aGVcclxuICAgIG5ldyBib3gncyBhc3BlY3QgcmF0aW8gbWF0Y2hlcyB0aGUgb3JpZ2luYWwgYXNwZWN0IHJhdGlvLlxyXG4gICAgKi9cblxuICAgIGlmIChpc0FzcGVjdFJhdGlvTG9ja2VkKSB7XG4gICAgICB2YXIgYXIgPSBhdyAvIGFoO1xuICAgICAgdmFyIGlzVGFsbCA9IGFyIDwgYncgLyBiaDtcbiAgICAgIHZhciB0dyA9IGJ3ICogKHNjYWxlWSA8IDAgPyAxIDogLTEpICogKDEgLyBhcik7XG4gICAgICB2YXIgdGggPSBiaCAqIChzY2FsZVggPCAwID8gMSA6IC0xKSAqIGFyO1xuXG4gICAgICBzd2l0Y2ggKGhhbmRsZSkge1xuICAgICAgICBjYXNlIGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuVG9wTGVmdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoaXNUYWxsKSBieTAgPSBieTEgKyB0dztlbHNlIGJ4MCA9IGJ4MSArIHRoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Ub3BSaWdodDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoaXNUYWxsKSBieTAgPSBieTEgKyB0dztlbHNlIGJ4MSA9IGJ4MCAtIHRoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Cb3R0b21SaWdodDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoaXNUYWxsKSBieTEgPSBieTAgLSB0dztlbHNlIGJ4MSA9IGJ4MCAtIHRoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Cb3R0b21MZWZ0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChpc1RhbGwpIGJ5MSA9IGJ5MCAtIHR3O2Vsc2UgYngwID0gYngxICsgdGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBleHBvcnRzLlRMQm91bmRzRWRnZS5Cb3R0b206XG4gICAgICAgIGNhc2UgZXhwb3J0cy5UTEJvdW5kc0VkZ2UuVG9wOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBtID0gKGJ4MCArIGJ4MSkgLyAyO1xuICAgICAgICAgICAgdmFyIHcgPSBiaCAqIGFyO1xuICAgICAgICAgICAgYngwID0gbSAtIHcgLyAyO1xuICAgICAgICAgICAgYngxID0gbSArIHcgLyAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgZXhwb3J0cy5UTEJvdW5kc0VkZ2UuTGVmdDpcbiAgICAgICAgY2FzZSBleHBvcnRzLlRMQm91bmRzRWRnZS5SaWdodDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX20gPSAoYnkwICsgYnkxKSAvIDI7XG5cbiAgICAgICAgICAgIHZhciBoID0gYncgLyBhcjtcbiAgICAgICAgICAgIGJ5MCA9IF9tIC0gaCAvIDI7XG4gICAgICAgICAgICBieTEgPSBfbSArIGggLyAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKlxyXG4gICAgMy4gUm90YXRpb25cclxuICAgICBJZiB0aGUgYm91bmRzIGFyZSByb3RhdGVkLCBnZXQgYSB2ZWN0b3IgZnJvbSB0aGUgcm90YXRlZCBhbmNob3JcclxuICAgIGNvcm5lciBpbiB0aGUgaW5pdGFsIGJvdW5kcyB0byB0aGUgcm90YXRlZCBhbmNob3IgY29ybmVyIGluIHRoZVxyXG4gICAgcmVzdWx0J3MgYm91bmRzLiBTdWJ0cmFjdCB0aGlzIHZlY3RvciBmcm9tIHRoZSByZXN1bHQncyBjb3JuZXJzLFxyXG4gICAgc28gdGhhdCB0aGUgdHdvIGFuY2hvciBwb2ludHMgKGluaXRpYWwgYW5kIHJlc3VsdCkgd2lsbCBiZSBlcXVhbC5cclxuICAgICovXG5cblxuICAgIGlmIChyb3RhdGlvbiAlIChNYXRoLlBJICogMikgIT09IDApIHtcbiAgICAgIHZhciBjdiA9IFswLCAwXTtcbiAgICAgIHZhciBjMCA9IFZlYy5tZWQoW2F4MCwgYXkwXSwgW2F4MSwgYXkxXSk7XG4gICAgICB2YXIgYzEgPSBWZWMubWVkKFtieDAsIGJ5MF0sIFtieDEsIGJ5MV0pO1xuXG4gICAgICBzd2l0Y2ggKGhhbmRsZSkge1xuICAgICAgICBjYXNlIGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuVG9wTGVmdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjdiA9IFZlYy5zdWIoVmVjLnJvdFdpdGgoW2J4MSwgYnkxXSwgYzEsIHJvdGF0aW9uKSwgVmVjLnJvdFdpdGgoW2F4MSwgYXkxXSwgYzAsIHJvdGF0aW9uKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBleHBvcnRzLlRMQm91bmRzQ29ybmVyLlRvcFJpZ2h0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGN2ID0gVmVjLnN1YihWZWMucm90V2l0aChbYngwLCBieTFdLCBjMSwgcm90YXRpb24pLCBWZWMucm90V2l0aChbYXgwLCBheTFdLCBjMCwgcm90YXRpb24pKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuQm90dG9tUmlnaHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY3YgPSBWZWMuc3ViKFZlYy5yb3RXaXRoKFtieDAsIGJ5MF0sIGMxLCByb3RhdGlvbiksIFZlYy5yb3RXaXRoKFtheDAsIGF5MF0sIGMwLCByb3RhdGlvbikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Cb3R0b21MZWZ0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGN2ID0gVmVjLnN1YihWZWMucm90V2l0aChbYngxLCBieTBdLCBjMSwgcm90YXRpb24pLCBWZWMucm90V2l0aChbYXgxLCBheTBdLCBjMCwgcm90YXRpb24pKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIGV4cG9ydHMuVExCb3VuZHNFZGdlLlRvcDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjdiA9IFZlYy5zdWIoVmVjLnJvdFdpdGgoVmVjLm1lZChbYngwLCBieTFdLCBbYngxLCBieTFdKSwgYzEsIHJvdGF0aW9uKSwgVmVjLnJvdFdpdGgoVmVjLm1lZChbYXgwLCBheTFdLCBbYXgxLCBheTFdKSwgYzAsIHJvdGF0aW9uKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBleHBvcnRzLlRMQm91bmRzRWRnZS5MZWZ0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGN2ID0gVmVjLnN1YihWZWMucm90V2l0aChWZWMubWVkKFtieDEsIGJ5MF0sIFtieDEsIGJ5MV0pLCBjMSwgcm90YXRpb24pLCBWZWMucm90V2l0aChWZWMubWVkKFtheDEsIGF5MF0sIFtheDEsIGF5MV0pLCBjMCwgcm90YXRpb24pKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIGV4cG9ydHMuVExCb3VuZHNFZGdlLkJvdHRvbTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjdiA9IFZlYy5zdWIoVmVjLnJvdFdpdGgoVmVjLm1lZChbYngwLCBieTBdLCBbYngxLCBieTBdKSwgYzEsIHJvdGF0aW9uKSwgVmVjLnJvdFdpdGgoVmVjLm1lZChbYXgwLCBheTBdLCBbYXgxLCBheTBdKSwgYzAsIHJvdGF0aW9uKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBleHBvcnRzLlRMQm91bmRzRWRnZS5SaWdodDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjdiA9IFZlYy5zdWIoVmVjLnJvdFdpdGgoVmVjLm1lZChbYngwLCBieTBdLCBbYngwLCBieTFdKSwgYzEsIHJvdGF0aW9uKSwgVmVjLnJvdFdpdGgoVmVjLm1lZChbYXgwLCBheTBdLCBbYXgwLCBheTFdKSwgYzAsIHJvdGF0aW9uKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBfdmVjJHN1YiA9IFZlYy5zdWIoW2J4MCwgYnkwXSwgY3YpO1xuXG4gICAgICBieDAgPSBfdmVjJHN1YlswXTtcbiAgICAgIGJ5MCA9IF92ZWMkc3ViWzFdO1xuXG4gICAgICB2YXIgX3ZlYyRzdWIyID0gVmVjLnN1YihbYngxLCBieTFdLCBjdik7XG5cbiAgICAgIGJ4MSA9IF92ZWMkc3ViMlswXTtcbiAgICAgIGJ5MSA9IF92ZWMkc3ViMlsxXTtcbiAgICB9XG4gICAgLypcclxuICAgIDQuIEZsaXBzXHJcbiAgICAgSWYgdGhlIGF4ZXMgYXJlIGZsaXBwZWQgKGUuZy4gaWYgdGhlIHJpZ2h0IGVkZ2UgaGFzIGJlZW4gZHJhZ2dlZFxyXG4gICAgbGVmdCBwYXN0IHRoZSBpbml0aWFsIGxlZnQgZWRnZSkgdGhlbiBzd2FwIHBvaW50cyBvbiB0aGF0IGF4aXMuXHJcbiAgICAqL1xuXG5cbiAgICBpZiAoYngxIDwgYngwKSB7XG4gICAgICB2YXIgX3JlZjUgPSBbYngwLCBieDFdO1xuICAgICAgYngxID0gX3JlZjVbMF07XG4gICAgICBieDAgPSBfcmVmNVsxXTtcbiAgICB9XG5cbiAgICBpZiAoYnkxIDwgYnkwKSB7XG4gICAgICB2YXIgX3JlZjYgPSBbYnkwLCBieTFdO1xuICAgICAgYnkxID0gX3JlZjZbMF07XG4gICAgICBieTAgPSBfcmVmNlsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWluWDogYngwLFxuICAgICAgbWluWTogYnkwLFxuICAgICAgbWF4WDogYngxLFxuICAgICAgbWF4WTogYnkxLFxuICAgICAgd2lkdGg6IGJ4MSAtIGJ4MCxcbiAgICAgIGhlaWdodDogYnkxIC0gYnkwLFxuICAgICAgc2NhbGVYOiAoYngxIC0gYngwKSAvIChheDEgLSBheDAgfHwgMSkgKiAoZmxpcFggPyAtMSA6IDEpLFxuICAgICAgc2NhbGVZOiAoYnkxIC0gYnkwKSAvIChheTEgLSBheTAgfHwgMSkgKiAoZmxpcFkgPyAtMSA6IDEpXG4gICAgfTtcbiAgfTtcblxuICBVdGlscy5nZXRUcmFuc2Zvcm1BbmNob3IgPSBmdW5jdGlvbiBnZXRUcmFuc2Zvcm1BbmNob3IodHlwZSwgaXNGbGlwcGVkWCwgaXNGbGlwcGVkWSkge1xuICAgIHZhciBhbmNob3IgPSB0eXBlOyAvLyBDaGFuZ2UgY29ybmVyIGFuY2hvcnMgaWYgZmxpcHBlZFxuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuVG9wTGVmdDpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChpc0ZsaXBwZWRYICYmIGlzRmxpcHBlZFkpIHtcbiAgICAgICAgICAgIGFuY2hvciA9IGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuQm90dG9tUmlnaHQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0ZsaXBwZWRYKSB7XG4gICAgICAgICAgICBhbmNob3IgPSBleHBvcnRzLlRMQm91bmRzQ29ybmVyLlRvcFJpZ2h0O1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNGbGlwcGVkWSkge1xuICAgICAgICAgICAgYW5jaG9yID0gZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Cb3R0b21MZWZ0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbmNob3IgPSBleHBvcnRzLlRMQm91bmRzQ29ybmVyLkJvdHRvbVJpZ2h0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Ub3BSaWdodDpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChpc0ZsaXBwZWRYICYmIGlzRmxpcHBlZFkpIHtcbiAgICAgICAgICAgIGFuY2hvciA9IGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuQm90dG9tTGVmdDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRmxpcHBlZFgpIHtcbiAgICAgICAgICAgIGFuY2hvciA9IGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuVG9wTGVmdDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRmxpcHBlZFkpIHtcbiAgICAgICAgICAgIGFuY2hvciA9IGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuQm90dG9tUmlnaHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuY2hvciA9IGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuQm90dG9tTGVmdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuQm90dG9tUmlnaHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoaXNGbGlwcGVkWCAmJiBpc0ZsaXBwZWRZKSB7XG4gICAgICAgICAgICBhbmNob3IgPSBleHBvcnRzLlRMQm91bmRzQ29ybmVyLlRvcExlZnQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0ZsaXBwZWRYKSB7XG4gICAgICAgICAgICBhbmNob3IgPSBleHBvcnRzLlRMQm91bmRzQ29ybmVyLkJvdHRvbUxlZnQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0ZsaXBwZWRZKSB7XG4gICAgICAgICAgICBhbmNob3IgPSBleHBvcnRzLlRMQm91bmRzQ29ybmVyLlRvcFJpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbmNob3IgPSBleHBvcnRzLlRMQm91bmRzQ29ybmVyLlRvcExlZnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBleHBvcnRzLlRMQm91bmRzQ29ybmVyLkJvdHRvbUxlZnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoaXNGbGlwcGVkWCAmJiBpc0ZsaXBwZWRZKSB7XG4gICAgICAgICAgICBhbmNob3IgPSBleHBvcnRzLlRMQm91bmRzQ29ybmVyLlRvcFJpZ2h0O1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNGbGlwcGVkWCkge1xuICAgICAgICAgICAgYW5jaG9yID0gZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Cb3R0b21SaWdodDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRmxpcHBlZFkpIHtcbiAgICAgICAgICAgIGFuY2hvciA9IGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuVG9wTGVmdDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5jaG9yID0gZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Ub3BSaWdodDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhbmNob3I7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IHRoZSByZWxhdGl2ZSBib3VuZHMgKHVzdWFsbHkgYSBjaGlsZCkgd2l0aGluIGEgdHJhbnNmb3JtZWQgYm91bmRpbmcgYm94LlxyXG4gICAqIEBwYXJhbSBib3VuZHNcclxuICAgKiBAcGFyYW0gaW5pdGlhbEJvdW5kc1xyXG4gICAqIEBwYXJhbSBpbml0aWFsU2hhcGVCb3VuZHNcclxuICAgKiBAcGFyYW0gaXNGbGlwcGVkWFxyXG4gICAqIEBwYXJhbSBpc0ZsaXBwZWRZXHJcbiAgICovXG4gIDtcblxuICBVdGlscy5nZXRSZWxhdGl2ZVRyYW5zZm9ybWVkQm91bmRpbmdCb3ggPSBmdW5jdGlvbiBnZXRSZWxhdGl2ZVRyYW5zZm9ybWVkQm91bmRpbmdCb3goYm91bmRzLCBpbml0aWFsQm91bmRzLCBpbml0aWFsU2hhcGVCb3VuZHMsIGlzRmxpcHBlZFgsIGlzRmxpcHBlZFkpIHtcbiAgICB2YXIgbnggPSAoaXNGbGlwcGVkWCA/IGluaXRpYWxCb3VuZHMubWF4WCAtIGluaXRpYWxTaGFwZUJvdW5kcy5tYXhYIDogaW5pdGlhbFNoYXBlQm91bmRzLm1pblggLSBpbml0aWFsQm91bmRzLm1pblgpIC8gaW5pdGlhbEJvdW5kcy53aWR0aDtcbiAgICB2YXIgbnkgPSAoaXNGbGlwcGVkWSA/IGluaXRpYWxCb3VuZHMubWF4WSAtIGluaXRpYWxTaGFwZUJvdW5kcy5tYXhZIDogaW5pdGlhbFNoYXBlQm91bmRzLm1pblkgLSBpbml0aWFsQm91bmRzLm1pblkpIC8gaW5pdGlhbEJvdW5kcy5oZWlnaHQ7XG4gICAgdmFyIG53ID0gaW5pdGlhbFNoYXBlQm91bmRzLndpZHRoIC8gaW5pdGlhbEJvdW5kcy53aWR0aDtcbiAgICB2YXIgbmggPSBpbml0aWFsU2hhcGVCb3VuZHMuaGVpZ2h0IC8gaW5pdGlhbEJvdW5kcy5oZWlnaHQ7XG4gICAgdmFyIG1pblggPSBib3VuZHMubWluWCArIGJvdW5kcy53aWR0aCAqIG54O1xuICAgIHZhciBtaW5ZID0gYm91bmRzLm1pblkgKyBib3VuZHMuaGVpZ2h0ICogbnk7XG4gICAgdmFyIHdpZHRoID0gYm91bmRzLndpZHRoICogbnc7XG4gICAgdmFyIGhlaWdodCA9IGJvdW5kcy5oZWlnaHQgKiBuaDtcbiAgICByZXR1cm4ge1xuICAgICAgbWluWDogbWluWCxcbiAgICAgIG1pblk6IG1pblksXG4gICAgICBtYXhYOiBtaW5YICsgd2lkdGgsXG4gICAgICBtYXhZOiBtaW5ZICsgaGVpZ2h0LFxuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9O1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc2l6ZSBvZiBhIHJvdGF0ZWQgYm94LlxyXG4gICAqIEBwYXJhbSBzaXplIDogO1xyXG4gICAqIEBwYXJhbSByb3RhdGlvblxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuZ2V0Um90YXRlZFNpemUgPSBmdW5jdGlvbiBnZXRSb3RhdGVkU2l6ZShzaXplLCByb3RhdGlvbikge1xuICAgIHZhciBjZW50ZXIgPSBWZWMuZGl2KHNpemUsIDIpO1xuICAgIHZhciBwb2ludHMgPSBbWzAsIDBdLCBbc2l6ZVswXSwgMF0sIHNpemUsIFswLCBzaXplWzFdXV0ubWFwKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgcmV0dXJuIFZlYy5yb3RXaXRoKHBvaW50LCBjZW50ZXIsIHJvdGF0aW9uKTtcbiAgICB9KTtcbiAgICB2YXIgYm91bmRzID0gVXRpbHMuZ2V0Qm91bmRzRnJvbVBvaW50cyhwb2ludHMpO1xuICAgIHJldHVybiBbYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0XTtcbiAgfVxuICAvKipcclxuICAgKiBHZXQgdGhlIGNlbnRlciBvZiBhIGJvdW5kaW5nIGJveC5cclxuICAgKiBAcGFyYW0gYm91bmRzXHJcbiAgICovXG4gIDtcblxuICBVdGlscy5nZXRCb3VuZHNDZW50ZXIgPSBmdW5jdGlvbiBnZXRCb3VuZHNDZW50ZXIoYm91bmRzKSB7XG4gICAgcmV0dXJuIFtib3VuZHMubWluWCArIGJvdW5kcy53aWR0aCAvIDIsIGJvdW5kcy5taW5ZICsgYm91bmRzLmhlaWdodCAvIDJdO1xuICB9XG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgLyogICAgICAgICAgICAgICAgTGlzdHMgYW5kIENvbGxlY3Rpb25zICAgICAgICAgICAgICAgKi9cblxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gIC8qKlxyXG4gICAqXHJcbiAgICpcclxuICAgKiAjIyMgRXhhbXBsZVxyXG4gICAqXHJcbiAgICpgYGB0c1xyXG4gICAqIGV4YW1wbGVcclxuICAgKmBgYFxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMucmVtb3ZlRHVwbGljYXRlUG9pbnRzID0gZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlUG9pbnRzKHBvaW50cykge1xuICAgIHJldHVybiBwb2ludHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHB0LCBpKSB7XG4gICAgICBpZiAoaSA9PT0gMCB8fCAhVmVjLmlzRXF1YWwocHQsIGFjY1tpIC0gMV0pKSB7XG4gICAgICAgIGFjYy5wdXNoKHB0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSk7XG4gIH1cbiAgLyoqXHJcbiAgLy8gcG9pbnRzID1cclxuICAgXG4gIC8qKlxyXG4gICogR2V0IGEgdmFsdWUgZnJvbSBhIGNhY2hlIChhIFdlYWtNYXApLCBmaWxsaW5nIHRoZSB2YWx1ZSBpZiBpdCBpcyBub3QgcHJlc2VudC5cclxuICAqXHJcbiAgKiAjIyMgRXhhbXBsZVxyXG4gICpcclxuICAqYGBgdHNcclxuICAqIGdldEZyb21DYWNoZShib3VuZHNDYWNoZSwgc2hhcGUsIChjYWNoZSkgPT4gY2FjaGUuc2V0KHNoYXBlLCBcInZhbHVlXCIpKVxyXG4gICpgYGBcclxuICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuICA7XG5cbiAgVXRpbHMuZ2V0RnJvbUNhY2hlID0gZnVuY3Rpb24gZ2V0RnJvbUNhY2hlKGNhY2hlLCBpdGVtLCBnZXROZXh0KSB7XG4gICAgdmFyIHZhbHVlID0gY2FjaGUuZ2V0KGl0ZW0pO1xuXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNhY2hlLnNldChpdGVtLCBnZXROZXh0KCkpO1xuICAgICAgdmFsdWUgPSBjYWNoZS5nZXQoaXRlbSk7XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdDYWNoZSBkaWQgbm90IGluY2x1ZGUgaXRlbSEnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IGEgdW5pcXVlIHN0cmluZyBpZC5cclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLnVuaXF1ZUlkID0gZnVuY3Rpb24gdW5pcXVlSWQoYSkge1xuICAgIGlmIChhID09PSB2b2lkIDApIHtcbiAgICAgIGEgPSAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gYSA/XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuICAgICgoTnVtYmVyKGEpIF4gTWF0aC5yYW5kb20oKSAqIDE2KSA+PiBOdW1iZXIoYSkgLyA0KS50b1N0cmluZygxNikgOiAoMWU3ICsgXCItXCIgKyAxZTMgKyBcIi1cIiArIDRlMyArIFwiLVwiICsgOGUzICsgXCItXCIgKyAxZTExKS5yZXBsYWNlKC9bMDE4XS9nLCBVdGlscy51bmlxdWVJZCk7XG4gIH1cbiAgLyoqXHJcbiAgICogU2h1ZmZsZSB0aGUgY29udGVudHMgb2YgYW4gYXJyYXkuXHJcbiAgICogQHBhcmFtIGFyclxyXG4gICAqIEBwYXJhbSBvZmZzZXRcclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLnNodWZmbGVBcnIgPSBmdW5jdGlvbiBzaHVmZmxlQXJyKGFyciwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGFyci5tYXAoZnVuY3Rpb24gKF8sIGkpIHtcbiAgICAgIHJldHVybiBhcnJbKGkgKyBvZmZzZXQpICUgYXJyLmxlbmd0aF07XG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogRGVlcCBjb21wYXJlIHR3byBhcnJheXMuXHJcbiAgICogQHBhcmFtIGFcclxuICAgKiBAcGFyYW0gYlxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuZGVlcENvbXBhcmVBcnJheXMgPSBmdW5jdGlvbiBkZWVwQ29tcGFyZUFycmF5cyhhLCBiKSB7XG4gICAgaWYgKChhID09IG51bGwgPyB2b2lkIDAgOiBhLmxlbmd0aCkgIT09IChiID09IG51bGwgPyB2b2lkIDAgOiBiLmxlbmd0aCkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gVXRpbHMuZGVlcENvbXBhcmUoYSwgYik7XG4gIH1cbiAgLyoqXHJcbiAgICogRGVlcCBjb21wYXJlIGFueSB2YWx1ZXMuXHJcbiAgICogQHBhcmFtIGFcclxuICAgKiBAcGFyYW0gYlxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuZGVlcENvbXBhcmUgPSBmdW5jdGlvbiBkZWVwQ29tcGFyZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT09IGIgfHwgSlNPTi5zdHJpbmdpZnkoYSkgPT09IEpTT04uc3RyaW5naWZ5KGIpO1xuICB9O1xuXG4gIFV0aWxzLmFycnNJbnRlcnNlY3QgPSBmdW5jdGlvbiBhcnJzSW50ZXJzZWN0KGEsIGIsIGZuKSB7XG4gICAgcmV0dXJuIGEuc29tZShmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGIuaW5jbHVkZXMoZm4gPyBmbihpdGVtKSA6IGl0ZW0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCB0aGUgdW5pcXVlIHZhbHVlcyBmcm9tIGFuIGFycmF5IG9mIHN0cmluZ3Mgb3IgbnVtYmVycy5cclxuICAgKiBAcGFyYW0gaXRlbXNcclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLnVuaXF1ZUFycmF5ID0gZnVuY3Rpb24gdW5pcXVlQXJyYXkoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGl0ZW1zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgaXRlbXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChpdGVtcykudmFsdWVzKCkpO1xuICB9XG4gIC8qKlxyXG4gICAqIENvbnZlcnQgYSBzZXQgdG8gYW4gYXJyYXkuXHJcbiAgICogQHBhcmFtIHNldFxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuc2V0VG9BcnJheSA9IGZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oc2V0LnZhbHVlcygpKTtcbiAgfVxuICAvKipcclxuICAgKiBEZWJvdW5jZSBhIGZ1bmN0aW9uLlxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuZGVib3VuY2UgPSBmdW5jdGlvbiBkZWJvdW5jZShmbiwgbXMpIHtcbiAgICBpZiAobXMgPT09IHZvaWQgMCkge1xuICAgICAgbXMgPSAwO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgdmFyIHRpbWVvdXRJZDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGFyZ3MpO1xuICAgICAgfSwgbXMpO1xuICAgIH07XG4gIH1cbiAgLyoqXHJcbiAgICogVHVybiBhbiBhcnJheSBvZiBwb2ludHMgaW50byBhIHBhdGggb2YgcXVhZHJhZGljIGN1cnZlcy5cclxuICAgKiBAcGFyYW0gc3Ryb2tlIDtcclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLmdldFN2Z1BhdGhGcm9tU3Ryb2tlID0gZnVuY3Rpb24gZ2V0U3ZnUGF0aEZyb21TdHJva2Uoc3Ryb2tlKSB7XG4gICAgaWYgKCFzdHJva2UubGVuZ3RoKSByZXR1cm4gJyc7XG4gICAgdmFyIGQgPSBzdHJva2UucmVkdWNlKGZ1bmN0aW9uIChhY2MsIF9yZWY3LCBpLCBhcnIpIHtcbiAgICAgIHZhciB4MCA9IF9yZWY3WzBdLFxuICAgICAgICAgIHkwID0gX3JlZjdbMV07XG4gICAgICB2YXIgX2FyciA9IGFyclsoaSArIDEpICUgYXJyLmxlbmd0aF0sXG4gICAgICAgICAgeDEgPSBfYXJyWzBdLFxuICAgICAgICAgIHkxID0gX2FyclsxXTtcbiAgICAgIGFjYy5wdXNoKFwiIFwiICsgeDAgKyBcIixcIiArIHkwICsgXCIgXCIgKyAoeDAgKyB4MSkgLyAyICsgXCIsXCIgKyAoeTAgKyB5MSkgLyAyKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgWydNICcsIHN0cm9rZVswXVswXSArIFwiLFwiICsgc3Ryb2tlWzBdWzFdLCAnIFEnXSk7XG4gICAgZC5wdXNoKCcgWicpO1xuICAgIHJldHVybiBkLmpvaW4oJycpLnJlcGxhY2VBbGwoLyhcXHM/W0EtWl0/LD8tP1swLTldKlxcLlswLTldezAsMn0pKChbMC05XXxlfC0pKikvZywgJyQxJyk7XG4gIH1cbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAvKiAgICAgICAgICAgICAgICAgICBCcm93c2VyIGFuZCBET00gICAgICAgICAgICAgICAgICAqL1xuXG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgLyoqXHJcbiAgICogRmluZCB3aGV0aGVyIHRoZSBjdXJyZW50IGRpc3BsYXkgaXMgYSB0b3VjaCBkaXNwbGF5LlxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuaXNUb3VjaERpc3BsYXkgPSBmdW5jdGlvbiBpc1RvdWNoRGlzcGxheSgpIHtcbiAgICByZXR1cm4gJ29udG91Y2hzdGFydCcgaW4gd2luZG93IHx8IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDAgfHwgbmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMgPiAwO1xuICB9XG4gIC8qKlxyXG4gICAqIEZpbmQgd2hldGhlciB0aGUgY3VycmVudCBkZXZpY2UgaXMgYSBNYWMgLyBpT1MgLyBpUGFkT1MuXHJcbiAgICovXG4gIDtcblxuICBVdGlscy5pc0RhcndpbiA9IGZ1bmN0aW9uIGlzRGFyd2luKCkge1xuICAgIHJldHVybiAvTWFjfGlQb2R8aVBob25lfGlQYWQvLnRlc3Qod2luZG93Lm5hdmlnYXRvci5wbGF0Zm9ybSk7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IHdoZXRoZXIgdGhlIGN1cnJlbnQgZGV2aWNlIGlzIGEgbW9iaWxlIGRldmljZS5cclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLmlzTW9iaWxlID0gZnVuY3Rpb24gaXNNb2JpbGUoKSB7XG4gICAgcmV0dXJuIGZhbHNlOyAvLyBfaXNNb2JpbGUoKS5hbnlcbiAgfVxuICAvKipcclxuICAgKiBHZXQgd2hldGhlciBhbiBldmVudCBpcyBjb21tYW5kIChtYWMpIG9yIGNvbnRyb2wgKHBjKS5cclxuICAgKiBAcGFyYW0gZVxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMubWV0YUtleSA9IGZ1bmN0aW9uIG1ldGFLZXkoZSkge1xuICAgIHJldHVybiBVdGlscy5pc0RhcndpbigpID8gZS5tZXRhS2V5IDogZS5jdHJsS2V5O1xuICB9XG4gIC8qKlxyXG4gICAqIEZpbmQgdGhlIGNsb3Nlc3QgcG9pbnQgb24gYSBTVkcgcGF0aCB0byBhbiBvZmYtcGF0aCBwb2ludC5cclxuICAgKiBAcGFyYW0gcGF0aE5vZGVcclxuICAgKiBAcGFyYW0gcG9pbnRcclxuICAgKiBAcmV0dXJuc1xyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuZ2V0Q2xvc2VzdFBvaW50T25TVkdQYXRoID0gZnVuY3Rpb24gZ2V0Q2xvc2VzdFBvaW50T25TVkdQYXRoKHBhdGhOb2RlLCBwb2ludCkge1xuICAgIGZ1bmN0aW9uIGRpc3RhbmNlMihwLCBwb2ludCkge1xuICAgICAgdmFyIGR4ID0gcC54IC0gcG9pbnRbMF07XG4gICAgICB2YXIgZHkgPSBwLnkgLSBwb2ludFsxXTtcbiAgICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICB9XG5cbiAgICB2YXIgcGF0aExlbiA9IHBhdGhOb2RlLmdldFRvdGFsTGVuZ3RoKCk7XG4gICAgdmFyIHAgPSA4O1xuICAgIHZhciBiZXN0ID0ge307XG4gICAgdmFyIGJlc3RMZW4gPSBJbmZpbml0eTtcbiAgICB2YXIgYmVzdERpc3QgPSBJbmZpbml0eTtcbiAgICB2YXIgYmwgPSAwO1xuICAgIHZhciBhbCA9IDA7IC8vIGxpbmVhciBzY2FuIGZvciBjb2Fyc2UgYXBwcm94aW1hdGlvblxuXG4gICAgZm9yICh2YXIgc2Nhbiwgc2NhbkxlbiA9IDAsIHNjYW5EaXN0OyBzY2FuTGVuIDw9IHBhdGhMZW47IHNjYW5MZW4gKz0gcCkge1xuICAgICAgaWYgKChzY2FuRGlzdCA9IGRpc3RhbmNlMihzY2FuID0gcGF0aE5vZGUuZ2V0UG9pbnRBdExlbmd0aChzY2FuTGVuKSwgcG9pbnQpKSA8IGJlc3REaXN0KSB7XG4gICAgICAgIGJlc3QgPSBzY2FuO1xuICAgICAgICBiZXN0TGVuID0gc2NhbkxlbjtcbiAgICAgICAgYmVzdERpc3QgPSBzY2FuRGlzdDtcbiAgICAgIH1cbiAgICB9IC8vIGJpbmFyeSBzZWFyY2ggZm9yIHByZWNpc2UgZXN0aW1hdGVcblxuXG4gICAgcCAvPSAyO1xuXG4gICAgd2hpbGUgKHAgPiAwLjUpIHtcbiAgICAgIHZhciBiZWZvcmUgPSB2b2lkIDAsXG4gICAgICAgICAgYWZ0ZXIgPSB2b2lkIDAsXG4gICAgICAgICAgYmQgPSB2b2lkIDAsXG4gICAgICAgICAgYWQgPSB2b2lkIDA7XG5cbiAgICAgIGlmICgoYmwgPSBiZXN0TGVuIC0gcCkgPj0gMCAmJiAoYmQgPSBkaXN0YW5jZTIoYmVmb3JlID0gcGF0aE5vZGUuZ2V0UG9pbnRBdExlbmd0aChibCksIHBvaW50KSkgPCBiZXN0RGlzdCkge1xuICAgICAgICBiZXN0ID0gYmVmb3JlO1xuICAgICAgICBiZXN0TGVuID0gYmw7XG4gICAgICAgIGJlc3REaXN0ID0gYmQ7XG4gICAgICB9IGVsc2UgaWYgKChhbCA9IGJlc3RMZW4gKyBwKSA8PSBwYXRoTGVuICYmIChhZCA9IGRpc3RhbmNlMihhZnRlciA9IHBhdGhOb2RlLmdldFBvaW50QXRMZW5ndGgoYWwpLCBwb2ludCkpIDwgYmVzdERpc3QpIHtcbiAgICAgICAgYmVzdCA9IGFmdGVyO1xuICAgICAgICBiZXN0TGVuID0gYWw7XG4gICAgICAgIGJlc3REaXN0ID0gYWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwIC89IDI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBvaW50OiBbYmVzdC54LCBiZXN0LnldLFxuICAgICAgZGlzdGFuY2U6IGJlc3REaXN0LFxuICAgICAgbGVuZ3RoOiAoYmwgKyBhbCkgLyAyLFxuICAgICAgdDogKGJsICsgYWwpIC8gMiAvIHBhdGhMZW5cbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBVdGlscztcbn0oKTtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0gU3RhcnQgQ29weSBIZXJlIC0tLS0tLS0tLS0tLS0tLS0gKi9cblxuZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uKG1lc3NhZ2UpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBvaW50cyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgcG9pbnRzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHZhciBkaWRJbnRlcnNlY3QgPSBwb2ludHMubGVuZ3RoID4gMDtcbiAgcmV0dXJuIHtcbiAgICBkaWRJbnRlcnNlY3Q6IGRpZEludGVyc2VjdCxcbiAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgIHBvaW50czogcG9pbnRzXG4gIH07XG59XG5cbnZhciBJbnRlcnNlY3QgPSBmdW5jdGlvbiBJbnRlcnNlY3QoKSB7fTtcbkludGVyc2VjdC5yYXkgPSB7XG4gIC8vIEludGVyc2VjdCBhIHJheSB3aXRoIGEgcmF5LlxuICByYXk6IGZ1bmN0aW9uIHJheShwMCwgbjAsIHAxLCBuMSkge1xuICAgIHZhciBkeCA9IHAxWzBdIC0gcDBbMF07XG4gICAgdmFyIGR5ID0gcDFbMV0gLSBwMFsxXTtcbiAgICB2YXIgZGV0ID0gbjFbMF0gKiBuMFsxXSAtIG4xWzFdICogbjBbMF07XG4gICAgdmFyIHUgPSAoZHkgKiBuMVswXSAtIGR4ICogbjFbMV0pIC8gZGV0O1xuICAgIHZhciB2ID0gKGR5ICogbjBbMF0gLSBkeCAqIG4wWzFdKSAvIGRldDtcbiAgICBpZiAodSA8IDAgfHwgdiA8IDApIHJldHVybiBnZXRJbnRlcnNlY3Rpb24oJ21pc3MnKTtcbiAgICB2YXIgbTAgPSBuMFsxXSAvIG4wWzBdO1xuICAgIHZhciBtMSA9IG4xWzFdIC8gbjFbMF07XG4gICAgdmFyIGIwID0gcDBbMV0gLSBtMCAqIHAwWzBdO1xuICAgIHZhciBiMSA9IHAxWzFdIC0gbTEgKiBwMVswXTtcbiAgICB2YXIgeCA9IChiMSAtIGIwKSAvIChtMCAtIG0xKTtcbiAgICB2YXIgeSA9IG0wICogeCArIGIwO1xuICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUoeCkgPyBnZXRJbnRlcnNlY3Rpb24oJ2ludGVyc2VjdGlvbicsIFt4LCB5XSkgOiBnZXRJbnRlcnNlY3Rpb24oJ3BhcmFsbGVsJyk7XG4gIH0sXG4gIC8vIEludGVyc2VnIGEgcmF5IHdpdGggYSBsaW5lIHNlZ21lbnQuXG4gIGxpbmVTZWdtZW50OiBmdW5jdGlvbiBsaW5lU2VnbWVudChvcmlnaW4sIGRpcmVjdGlvbiwgYTEsIGEyKSB7XG4gICAgdmFyIHggPSBvcmlnaW5bMF0sXG4gICAgICAgIHkgPSBvcmlnaW5bMV07XG4gICAgdmFyIGR4ID0gZGlyZWN0aW9uWzBdLFxuICAgICAgICBkeSA9IGRpcmVjdGlvblsxXTtcbiAgICB2YXIgeDEgPSBhMVswXSxcbiAgICAgICAgeTEgPSBhMVsxXTtcbiAgICB2YXIgeDIgPSBhMlswXSxcbiAgICAgICAgeTIgPSBhMlsxXTtcblxuICAgIGlmIChkeSAvIGR4ICE9PSAoeTIgLSB5MSkgLyAoeDIgLSB4MSkpIHtcbiAgICAgIHZhciBkID0gZHggKiAoeTIgLSB5MSkgLSBkeSAqICh4MiAtIHgxKTtcblxuICAgICAgaWYgKGQgIT09IDApIHtcbiAgICAgICAgdmFyIHIgPSAoKHkgLSB5MSkgKiAoeDIgLSB4MSkgLSAoeCAtIHgxKSAqICh5MiAtIHkxKSkgLyBkO1xuICAgICAgICB2YXIgcyA9ICgoeSAtIHkxKSAqIGR4IC0gKHggLSB4MSkgKiBkeSkgLyBkO1xuXG4gICAgICAgIGlmIChyID49IDAgJiYgcyA+PSAwICYmIHMgPD0gMSkge1xuICAgICAgICAgIHJldHVybiBnZXRJbnRlcnNlY3Rpb24oJ2ludGVyc2VjdGlvbicsIFt4ICsgciAqIGR4LCB5ICsgciAqIGR5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0SW50ZXJzZWN0aW9uKCdubyBpbnRlcnNlY3Rpb24nKTtcbiAgfSxcbiAgLy8gSW50ZXJzZWN0IGEgcmF5IHdpdGggYSByZWN0YW5nbGUuXG4gIHJlY3RhbmdsZTogZnVuY3Rpb24gcmVjdGFuZ2xlKG9yaWdpbiwgZGlyZWN0aW9uLCBwb2ludCwgc2l6ZSkge1xuICAgIHJldHVybiBJbnRlcnNlY3QucmVjdGFuZ2xlLnJheShwb2ludCwgc2l6ZSwgb3JpZ2luLCBkaXJlY3Rpb24pO1xuICB9LFxuICAvLyBJbnRlcnNlY3QgYSByYXkgd2l0aCBhbiBlbGxpcHNlLlxuICBlbGxpcHNlOiBmdW5jdGlvbiBlbGxpcHNlKG9yaWdpbiwgZGlyZWN0aW9uLCBjZW50ZXIsIHJ4LCByeSwgcm90YXRpb24pIHtcbiAgICB2YXIgYTEgPSBvcmlnaW47XG4gICAgdmFyIGEyID0gVmVjLm11bChkaXJlY3Rpb24sIDk5OTk5OTk5OSk7XG4gICAgcmV0dXJuIEludGVyc2VjdC5saW5lU2VnbWVudC5lbGxpcHNlKGExLCBhMiwgY2VudGVyLCByeCwgcnksIHJvdGF0aW9uKTtcbiAgfSxcbiAgLy8gSW50ZXJzZWN0IGEgcmF5IHdpdGggYSBib3VuZGluZyBib3guXG4gIGJvdW5kczogZnVuY3Rpb24gYm91bmRzKG9yaWdpbiwgZGlyZWN0aW9uLCBfYm91bmRzKSB7XG4gICAgdmFyIG1pblggPSBfYm91bmRzLm1pblgsXG4gICAgICAgIG1pblkgPSBfYm91bmRzLm1pblksXG4gICAgICAgIHdpZHRoID0gX2JvdW5kcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX2JvdW5kcy5oZWlnaHQ7XG4gICAgcmV0dXJuIEludGVyc2VjdC5yYXkucmVjdGFuZ2xlKG9yaWdpbiwgZGlyZWN0aW9uLCBbbWluWCwgbWluWV0sIFt3aWR0aCwgaGVpZ2h0XSk7XG4gIH1cbn07XG5JbnRlcnNlY3QubGluZVNlZ21lbnQgPSB7XG4gIC8vIEludGVyc2VjdCBhIGxpbmUgc2VnbWVudCB3aXRoIGEgcmF5LlxuICByYXk6IGZ1bmN0aW9uIHJheShhMSwgYTIsIG9yaWdpbiwgZGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIEludGVyc2VjdC5yYXkubGluZVNlZ21lbnQob3JpZ2luLCBkaXJlY3Rpb24sIGExLCBhMik7XG4gIH0sXG4gIC8vIEludGVyc2VjdCBhIGxpbmUgc2VnbWVudCB3aXRoIGEgbGluZSBzZWdtZW50LlxuICBsaW5lU2VnbWVudDogZnVuY3Rpb24gbGluZVNlZ21lbnQoYTEsIGEyLCBiMSwgYjIpIHtcbiAgICB2YXIgQUIgPSBWZWMuc3ViKGExLCBiMSk7XG4gICAgdmFyIEJWID0gVmVjLnN1YihiMiwgYjEpO1xuICAgIHZhciBBViA9IFZlYy5zdWIoYTIsIGExKTtcbiAgICB2YXIgdWFfdCA9IEJWWzBdICogQUJbMV0gLSBCVlsxXSAqIEFCWzBdO1xuICAgIHZhciB1Yl90ID0gQVZbMF0gKiBBQlsxXSAtIEFWWzFdICogQUJbMF07XG4gICAgdmFyIHVfYiA9IEJWWzFdICogQVZbMF0gLSBCVlswXSAqIEFWWzFdO1xuXG4gICAgaWYgKHVhX3QgPT09IDAgfHwgdWJfdCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGdldEludGVyc2VjdGlvbignY29pbmNpZGVudCcpO1xuICAgIH1cblxuICAgIGlmICh1X2IgPT09IDApIHtcbiAgICAgIHJldHVybiBnZXRJbnRlcnNlY3Rpb24oJ3BhcmFsbGVsJyk7XG4gICAgfVxuXG4gICAgaWYgKHVfYiAhPT0gMCkge1xuICAgICAgdmFyIHVhID0gdWFfdCAvIHVfYjtcbiAgICAgIHZhciB1YiA9IHViX3QgLyB1X2I7XG5cbiAgICAgIGlmICgwIDw9IHVhICYmIHVhIDw9IDEgJiYgMCA8PSB1YiAmJiB1YiA8PSAxKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnRlcnNlY3Rpb24oJ2ludGVyc2VjdGlvbicsIFZlYy5hZGQoYTEsIFZlYy5tdWwoQVYsIHVhKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBnZXRJbnRlcnNlY3Rpb24oJ25vIGludGVyc2VjdGlvbicpO1xuICB9LFxuICAvLyBJbnRlcnNlY3QgYSBsaW5lIHNlZ21lbnQgd2l0aCBhIHJlY3RhbmdsZVxuICByZWN0YW5nbGU6IGZ1bmN0aW9uIHJlY3RhbmdsZShhMSwgYTIsIHBvaW50LCBzaXplKSB7XG4gICAgcmV0dXJuIEludGVyc2VjdC5yZWN0YW5nbGUubGluZVNlZ21lbnQocG9pbnQsIHNpemUsIGExLCBhMik7XG4gIH0sXG4gIC8vIEludGVyc2VjdCBhIGxpbmUgc2VnbWVudCB3aXRoIGFuIGFyYy5cbiAgYXJjOiBmdW5jdGlvbiBhcmMoYTEsIGEyLCBjZW50ZXIsIHJhZGl1cywgc3RhcnQsIGVuZCkge1xuICAgIHZhciBzYSA9IFZlYy5hbmdsZShjZW50ZXIsIHN0YXJ0KTtcbiAgICB2YXIgZWEgPSBWZWMuYW5nbGUoY2VudGVyLCBlbmQpO1xuICAgIHZhciBlbGxpcHNlVGVzdCA9IEludGVyc2VjdC5lbGxpcHNlLmxpbmVTZWdtZW50KGNlbnRlciwgcmFkaXVzLCByYWRpdXMsIDAsIGExLCBhMik7XG4gICAgaWYgKCFlbGxpcHNlVGVzdC5kaWRJbnRlcnNlY3QpIHJldHVybiBnZXRJbnRlcnNlY3Rpb24oJ05vIGludGVyc2VjdGlvbicpO1xuICAgIHZhciBwb2ludHMgPSBlbGxpcHNlVGVzdC5wb2ludHMuZmlsdGVyKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgcmV0dXJuIFV0aWxzLmlzQW5nbGVCZXR3ZWVuKHNhLCBlYSwgVmVjLmFuZ2xlKGNlbnRlciwgcG9pbnQpKTtcbiAgICB9KTtcblxuICAgIGlmIChwb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZ2V0SW50ZXJzZWN0aW9uKCdObyBpbnRlcnNlY3Rpb24nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0SW50ZXJzZWN0aW9uLmFwcGx5KHZvaWQgMCwgWydpbnRlcnNlY3Rpb24nXS5jb25jYXQocG9pbnRzKSk7XG4gIH0sXG4gIC8vIEludGVyc2VjdCBhIGxpbmUgc2VnbWVudCB3aXRoIGEgY2lyY2xlLlxuICBjaXJjbGU6IGZ1bmN0aW9uIGNpcmNsZShhMSwgYTIsIGMsIHIpIHtcbiAgICB2YXIgYSA9IChhMlswXSAtIGExWzBdKSAqIChhMlswXSAtIGExWzBdKSArIChhMlsxXSAtIGExWzFdKSAqIChhMlsxXSAtIGExWzFdKTtcbiAgICB2YXIgYiA9IDIgKiAoKGEyWzBdIC0gYTFbMF0pICogKGExWzBdIC0gY1swXSkgKyAoYTJbMV0gLSBhMVsxXSkgKiAoYTFbMV0gLSBjWzFdKSk7XG4gICAgdmFyIGNjID0gY1swXSAqIGNbMF0gKyBjWzFdICogY1sxXSArIGExWzBdICogYTFbMF0gKyBhMVsxXSAqIGExWzFdIC0gMiAqIChjWzBdICogYTFbMF0gKyBjWzFdICogYTFbMV0pIC0gciAqIHI7XG4gICAgdmFyIGRldGVyID0gYiAqIGIgLSA0ICogYSAqIGNjO1xuXG4gICAgaWYgKGRldGVyIDwgMCkge1xuICAgICAgcmV0dXJuIGdldEludGVyc2VjdGlvbignb3V0c2lkZScpO1xuICAgIH1cblxuICAgIGlmIChkZXRlciA9PT0gMCkge1xuICAgICAgcmV0dXJuIGdldEludGVyc2VjdGlvbigndGFuZ2VudCcpO1xuICAgIH1cblxuICAgIHZhciBlID0gTWF0aC5zcXJ0KGRldGVyKTtcbiAgICB2YXIgdTEgPSAoLWIgKyBlKSAvICgyICogYSk7XG4gICAgdmFyIHUyID0gKC1iIC0gZSkgLyAoMiAqIGEpO1xuXG4gICAgaWYgKCh1MSA8IDAgfHwgdTEgPiAxKSAmJiAodTIgPCAwIHx8IHUyID4gMSkpIHtcbiAgICAgIGlmICh1MSA8IDAgJiYgdTIgPCAwIHx8IHUxID4gMSAmJiB1MiA+IDEpIHtcbiAgICAgICAgcmV0dXJuIGdldEludGVyc2VjdGlvbignb3V0c2lkZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdldEludGVyc2VjdGlvbignaW5zaWRlJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBpZiAoMCA8PSB1MSAmJiB1MSA8PSAxKSByZXN1bHRzLnB1c2goVmVjLmxycChhMSwgYTIsIHUxKSk7XG4gICAgaWYgKDAgPD0gdTIgJiYgdTIgPD0gMSkgcmVzdWx0cy5wdXNoKFZlYy5scnAoYTEsIGEyLCB1MikpO1xuICAgIHJldHVybiBnZXRJbnRlcnNlY3Rpb24uYXBwbHkodm9pZCAwLCBbJ2ludGVyc2VjdGlvbiddLmNvbmNhdChyZXN1bHRzKSk7XG4gIH0sXG4gIC8vIEludGVyc2VjdCBhIGxpbmUgc2VnbWVudCB3aXRoIGFuIGVsbGlwc2UuXG4gIGVsbGlwc2U6IGZ1bmN0aW9uIGVsbGlwc2UoYTEsIGEyLCBjZW50ZXIsIHJ4LCByeSwgcm90YXRpb24pIHtcbiAgICBpZiAocm90YXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgcm90YXRpb24gPSAwO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBlbGxpcHNlIG9yIGxpbmUgc2VnbWVudCBhcmUgZW1wdHksIHJldHVybiBubyB0VmFsdWVzLlxuICAgIGlmIChyeCA9PT0gMCB8fCByeSA9PT0gMCB8fCBWZWMuaXNFcXVhbChhMSwgYTIpKSB7XG4gICAgICByZXR1cm4gZ2V0SW50ZXJzZWN0aW9uKCdObyBpbnRlcnNlY3Rpb24nKTtcbiAgICB9IC8vIEdldCB0aGUgc2VtaW1ham9yIGFuZCBzZW1pbWlub3IgYXhlcy5cblxuXG4gICAgcnggPSByeCA8IDAgPyByeCA6IC1yeDtcbiAgICByeSA9IHJ5IDwgMCA/IHJ5IDogLXJ5OyAvLyBSb3RhdGUgcG9pbnRzIGFuZCB0cmFuc2xhdGUgc28gdGhlIGVsbGlwc2UgaXMgY2VudGVyZWQgYXQgdGhlIG9yaWdpbi5cblxuICAgIGExID0gVmVjLnN1YihWZWMucm90V2l0aChhMSwgY2VudGVyLCAtcm90YXRpb24pLCBjZW50ZXIpO1xuICAgIGEyID0gVmVjLnN1YihWZWMucm90V2l0aChhMiwgY2VudGVyLCAtcm90YXRpb24pLCBjZW50ZXIpOyAvLyBDYWxjdWxhdGUgdGhlIHF1YWRyYXRpYyBwYXJhbWV0ZXJzLlxuXG4gICAgdmFyIGRpZmYgPSBWZWMuc3ViKGEyLCBhMSk7XG4gICAgdmFyIEEgPSBkaWZmWzBdICogZGlmZlswXSAvIHJ4IC8gcnggKyBkaWZmWzFdICogZGlmZlsxXSAvIHJ5IC8gcnk7XG4gICAgdmFyIEIgPSAyICogYTFbMF0gKiBkaWZmWzBdIC8gcnggLyByeCArIDIgKiBhMVsxXSAqIGRpZmZbMV0gLyByeSAvIHJ5O1xuICAgIHZhciBDID0gYTFbMF0gKiBhMVswXSAvIHJ4IC8gcnggKyBhMVsxXSAqIGExWzFdIC8gcnkgLyByeSAtIDE7IC8vIE1ha2UgYSBsaXN0IG9mIHQgdmFsdWVzIChub3JtYWxpemVkIHBvaW50cyBvbiB0aGUgbGluZSB3aGVyZSBpbnRlcnNlY3Rpb25zIG9jY3VyKS5cblxuICAgIHZhciB0VmFsdWVzID0gW107IC8vIENhbGN1bGF0ZSB0aGUgZGlzY3JpbWluYW50LlxuXG4gICAgdmFyIGRpc2NyaW1pbmFudCA9IEIgKiBCIC0gNCAqIEEgKiBDO1xuXG4gICAgaWYgKGRpc2NyaW1pbmFudCA9PT0gMCkge1xuICAgICAgLy8gT25lIHJlYWwgc29sdXRpb24uXG4gICAgICB0VmFsdWVzLnB1c2goLUIgLyAyIC8gQSk7XG4gICAgfSBlbHNlIGlmIChkaXNjcmltaW5hbnQgPiAwKSB7XG4gICAgICB2YXIgcm9vdCA9IE1hdGguc3FydChkaXNjcmltaW5hbnQpOyAvLyBUd28gcmVhbCBzb2x1dGlvbnMuXG5cbiAgICAgIHRWYWx1ZXMucHVzaCgoLUIgKyByb290KSAvIDIgLyBBKTtcbiAgICAgIHRWYWx1ZXMucHVzaCgoLUIgLSByb290KSAvIDIgLyBBKTtcbiAgICB9IC8vIEZpbHRlciB0byBvbmx5IHBvaW50cyB0aGF0IGFyZSBvbiB0aGUgc2VnbWVudC5cbiAgICAvLyBTb2x2ZSBmb3IgcG9pbnRzLCB0aGVuIGNvdW50ZXItcm90YXRlIHBvaW50cy5cblxuXG4gICAgdmFyIHBvaW50cyA9IHRWYWx1ZXMuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdCA+PSAwICYmIHQgPD0gMTtcbiAgICB9KS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiBWZWMuYWRkKGNlbnRlciwgVmVjLmFkZChhMSwgVmVjLm11bChWZWMuc3ViKGEyLCBhMSksIHQpKSk7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gVmVjLnJvdFdpdGgocCwgY2VudGVyLCByb3RhdGlvbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGdldEludGVyc2VjdGlvbi5hcHBseSh2b2lkIDAsIFsnaW50ZXJzZWN0aW9uJ10uY29uY2F0KHBvaW50cykpO1xuICB9LFxuICAvLyBJbnRlcnNlY3QgYSBsaW5lIHNlZ21lbnQgd2l0aCBhIGJvdW5kaW5nIGJveC5cbiAgYm91bmRzOiBmdW5jdGlvbiBib3VuZHMoYTEsIGEyLCBfYm91bmRzMikge1xuICAgIHJldHVybiBJbnRlcnNlY3QuYm91bmRzLmxpbmVTZWdtZW50KF9ib3VuZHMyLCBhMSwgYTIpO1xuICB9LFxuICAvLyBJbnRlcnNlY3QgYSBsaW5lIHNlZ21lbnQgd2l0aCBhIHBvbHlsaW5lXG4gIHBvbHlsaW5lOiBmdW5jdGlvbiBwb2x5bGluZShhMSwgYTIsIHBvaW50cykge1xuICAgIHZhciBpbnRlcnNlY3Rpb25zID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGggKyAxOyBpKyspIHtcbiAgICAgIHZhciBfaW50ID0gSW50ZXJzZWN0LmxpbmVTZWdtZW50LmxpbmVTZWdtZW50KGExLCBhMiwgcG9pbnRzW2kgLSAxXSwgcG9pbnRzW2kgJSBwb2ludHMubGVuZ3RoXSk7XG5cbiAgICAgIGlmIChfaW50KSB7XG4gICAgICAgIGludGVyc2VjdGlvbnMucHVzaChfaW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbiAgfVxufTtcbkludGVyc2VjdC5yZWN0YW5nbGUgPSB7XG4gIC8vIEludGVyc2VjdCBhIHJlY3RhbmdsZSB3aXRoIGEgcmF5LlxuICByYXk6IGZ1bmN0aW9uIHJheShwb2ludCwgc2l6ZSwgb3JpZ2luLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgc2lkZUludGVyc2VjdGlvbnMgPSBVdGlscy5nZXRSZWN0YW5nbGVTaWRlcyhwb2ludCwgc2l6ZSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIF9yZWYpIHtcbiAgICAgIHZhciBtZXNzYWdlID0gX3JlZlswXSxcbiAgICAgICAgICBfcmVmJCA9IF9yZWZbMV0sXG4gICAgICAgICAgYTEgPSBfcmVmJFswXSxcbiAgICAgICAgICBhMiA9IF9yZWYkWzFdO1xuICAgICAgdmFyIGludGVyc2VjdGlvbiA9IEludGVyc2VjdC5yYXkubGluZVNlZ21lbnQob3JpZ2luLCBkaXJlY3Rpb24sIGExLCBhMik7XG5cbiAgICAgIGlmIChpbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgYWNjLnB1c2goZ2V0SW50ZXJzZWN0aW9uLmFwcGx5KHZvaWQgMCwgW21lc3NhZ2VdLmNvbmNhdChpbnRlcnNlY3Rpb24ucG9pbnRzKSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gc2lkZUludGVyc2VjdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChfaW50Mikge1xuICAgICAgcmV0dXJuIF9pbnQyLmRpZEludGVyc2VjdDtcbiAgICB9KTtcbiAgfSxcbiAgLy8gSW50ZXJzZWN0IGEgcmVjdGFuZ2xlIHdpdGggYSBsaW5lIHNlZ21lbnQuXG4gIGxpbmVTZWdtZW50OiBmdW5jdGlvbiBsaW5lU2VnbWVudChwb2ludCwgc2l6ZSwgYTEsIGEyKSB7XG4gICAgdmFyIHNpZGVJbnRlcnNlY3Rpb25zID0gVXRpbHMuZ2V0UmVjdGFuZ2xlU2lkZXMocG9pbnQsIHNpemUpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBfcmVmMikge1xuICAgICAgdmFyIG1lc3NhZ2UgPSBfcmVmMlswXSxcbiAgICAgICAgICBfcmVmMiQgPSBfcmVmMlsxXSxcbiAgICAgICAgICBiMSA9IF9yZWYyJFswXSxcbiAgICAgICAgICBiMiA9IF9yZWYyJFsxXTtcbiAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBJbnRlcnNlY3QubGluZVNlZ21lbnQubGluZVNlZ21lbnQoYTEsIGEyLCBiMSwgYjIpO1xuXG4gICAgICBpZiAoaW50ZXJzZWN0aW9uKSB7XG4gICAgICAgIGFjYy5wdXNoKGdldEludGVyc2VjdGlvbi5hcHBseSh2b2lkIDAsIFttZXNzYWdlXS5jb25jYXQoaW50ZXJzZWN0aW9uLnBvaW50cykpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHNpZGVJbnRlcnNlY3Rpb25zLmZpbHRlcihmdW5jdGlvbiAoX2ludDMpIHtcbiAgICAgIHJldHVybiBfaW50My5kaWRJbnRlcnNlY3Q7XG4gICAgfSk7XG4gIH0sXG4gIC8vIEludGVyc2VjdCBhIHJlY3RhbmdsZSB3aXRoIGEgcmVjdGFuZ2xlLlxuICByZWN0YW5nbGU6IGZ1bmN0aW9uIHJlY3RhbmdsZShwb2ludDEsIHNpemUxLCBwb2ludDIsIHNpemUyKSB7XG4gICAgdmFyIHNpZGVJbnRlcnNlY3Rpb25zID0gVXRpbHMuZ2V0UmVjdGFuZ2xlU2lkZXMocG9pbnQxLCBzaXplMSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIF9yZWYzKSB7XG4gICAgICB2YXIgbWVzc2FnZSA9IF9yZWYzWzBdLFxuICAgICAgICAgIF9yZWYzJCA9IF9yZWYzWzFdLFxuICAgICAgICAgIGExID0gX3JlZjMkWzBdLFxuICAgICAgICAgIGEyID0gX3JlZjMkWzFdO1xuICAgICAgdmFyIGludGVyc2VjdGlvbnMgPSBJbnRlcnNlY3QucmVjdGFuZ2xlLmxpbmVTZWdtZW50KHBvaW50Miwgc2l6ZTIsIGExLCBhMik7XG4gICAgICBhY2MucHVzaC5hcHBseShhY2MsIGludGVyc2VjdGlvbnMubWFwKGZ1bmN0aW9uIChfaW50NCkge1xuICAgICAgICByZXR1cm4gZ2V0SW50ZXJzZWN0aW9uLmFwcGx5KHZvaWQgMCwgW21lc3NhZ2UgKyBcIiBcIiArIF9pbnQ0Lm1lc3NhZ2VdLmNvbmNhdChfaW50NC5wb2ludHMpKTtcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBzaWRlSW50ZXJzZWN0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKF9pbnQ1KSB7XG4gICAgICByZXR1cm4gX2ludDUuZGlkSW50ZXJzZWN0O1xuICAgIH0pO1xuICB9LFxuICAvLyBJbnRlcnNlY3QgYSByZWN0YW5nbGUgd2l0aCBhbiBhcmMuXG4gIGFyYzogZnVuY3Rpb24gYXJjKHBvaW50LCBzaXplLCBjZW50ZXIsIHJhZGl1cywgc3RhcnQsIGVuZCkge1xuICAgIHZhciBzaWRlSW50ZXJzZWN0aW9ucyA9IFV0aWxzLmdldFJlY3RhbmdsZVNpZGVzKHBvaW50LCBzaXplKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgX3JlZjQpIHtcbiAgICAgIHZhciBtZXNzYWdlID0gX3JlZjRbMF0sXG4gICAgICAgICAgX3JlZjQkID0gX3JlZjRbMV0sXG4gICAgICAgICAgYTEgPSBfcmVmNCRbMF0sXG4gICAgICAgICAgYTIgPSBfcmVmNCRbMV07XG4gICAgICB2YXIgaW50ZXJzZWN0aW9uID0gSW50ZXJzZWN0LmFyYy5saW5lU2VnbWVudChjZW50ZXIsIHJhZGl1cywgc3RhcnQsIGVuZCwgYTEsIGEyKTtcblxuICAgICAgaWYgKGludGVyc2VjdGlvbikge1xuICAgICAgICBhY2MucHVzaChfZXh0ZW5kcyh7fSwgaW50ZXJzZWN0aW9uLCB7XG4gICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBzaWRlSW50ZXJzZWN0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKF9pbnQ2KSB7XG4gICAgICByZXR1cm4gX2ludDYuZGlkSW50ZXJzZWN0O1xuICAgIH0pO1xuICB9LFxuICAvLyBJbnRlcnNlY3QgYSByZWN0YW5nbGUgd2l0aCBhIGNpcmNsZS5cbiAgY2lyY2xlOiBmdW5jdGlvbiBjaXJjbGUocG9pbnQsIHNpemUsIGMsIHIpIHtcbiAgICB2YXIgc2lkZUludGVyc2VjdGlvbnMgPSBVdGlscy5nZXRSZWN0YW5nbGVTaWRlcyhwb2ludCwgc2l6ZSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIF9yZWY1KSB7XG4gICAgICB2YXIgbWVzc2FnZSA9IF9yZWY1WzBdLFxuICAgICAgICAgIF9yZWY1JCA9IF9yZWY1WzFdLFxuICAgICAgICAgIGExID0gX3JlZjUkWzBdLFxuICAgICAgICAgIGEyID0gX3JlZjUkWzFdO1xuICAgICAgdmFyIGludGVyc2VjdGlvbiA9IEludGVyc2VjdC5saW5lU2VnbWVudC5jaXJjbGUoYTEsIGEyLCBjLCByKTtcblxuICAgICAgaWYgKGludGVyc2VjdGlvbikge1xuICAgICAgICBhY2MucHVzaChfZXh0ZW5kcyh7fSwgaW50ZXJzZWN0aW9uLCB7XG4gICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBzaWRlSW50ZXJzZWN0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKF9pbnQ3KSB7XG4gICAgICByZXR1cm4gX2ludDcuZGlkSW50ZXJzZWN0O1xuICAgIH0pO1xuICB9LFxuICAvLyBJbnRlcnNlY3QgYSByZWN0YW5nbGUgd2l0aCBhbiBlbGxpcHNlLlxuICBlbGxpcHNlOiBmdW5jdGlvbiBlbGxpcHNlKHBvaW50LCBzaXplLCBjLCByeCwgcnksIHJvdGF0aW9uKSB7XG4gICAgaWYgKHJvdGF0aW9uID09PSB2b2lkIDApIHtcbiAgICAgIHJvdGF0aW9uID0gMDtcbiAgICB9XG5cbiAgICB2YXIgc2lkZUludGVyc2VjdGlvbnMgPSBVdGlscy5nZXRSZWN0YW5nbGVTaWRlcyhwb2ludCwgc2l6ZSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIF9yZWY2KSB7XG4gICAgICB2YXIgbWVzc2FnZSA9IF9yZWY2WzBdLFxuICAgICAgICAgIF9yZWY2JCA9IF9yZWY2WzFdLFxuICAgICAgICAgIGExID0gX3JlZjYkWzBdLFxuICAgICAgICAgIGEyID0gX3JlZjYkWzFdO1xuICAgICAgdmFyIGludGVyc2VjdGlvbiA9IEludGVyc2VjdC5saW5lU2VnbWVudC5lbGxpcHNlKGExLCBhMiwgYywgcngsIHJ5LCByb3RhdGlvbik7XG5cbiAgICAgIGlmIChpbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgYWNjLnB1c2goX2V4dGVuZHMoe30sIGludGVyc2VjdGlvbiwge1xuICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gc2lkZUludGVyc2VjdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChfaW50OCkge1xuICAgICAgcmV0dXJuIF9pbnQ4LmRpZEludGVyc2VjdDtcbiAgICB9KTtcbiAgfSxcbiAgLy8gSW50ZXJzZWN0IGEgcmVjdGFuZ2xlIHdpdGggYSBib3VuZGluZyBib3guXG4gIGJvdW5kczogZnVuY3Rpb24gYm91bmRzKHBvaW50LCBzaXplLCBfYm91bmRzMykge1xuICAgIHZhciBtaW5YID0gX2JvdW5kczMubWluWCxcbiAgICAgICAgbWluWSA9IF9ib3VuZHMzLm1pblksXG4gICAgICAgIHdpZHRoID0gX2JvdW5kczMud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9ib3VuZHMzLmhlaWdodDtcbiAgICByZXR1cm4gSW50ZXJzZWN0LnJlY3RhbmdsZS5yZWN0YW5nbGUocG9pbnQsIHNpemUsIFttaW5YLCBtaW5ZXSwgW3dpZHRoLCBoZWlnaHRdKTtcbiAgfSxcbiAgLy8gSW50ZXJzZWN0IGEgcmVjdGFuZ2xlIHdpdGggYSBwb2x5bGluZVxuICBwb2x5bGluZTogZnVuY3Rpb24gcG9seWxpbmUocG9pbnQsIHNpemUsIHBvaW50cykge1xuICAgIHZhciBzaWRlSW50ZXJzZWN0aW9ucyA9IFV0aWxzLmdldFJlY3RhbmdsZVNpZGVzKHBvaW50LCBzaXplKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgX3JlZjcpIHtcbiAgICAgIHZhciBtZXNzYWdlID0gX3JlZjdbMF0sXG4gICAgICAgICAgX3JlZjckID0gX3JlZjdbMV0sXG4gICAgICAgICAgYTEgPSBfcmVmNyRbMF0sXG4gICAgICAgICAgYTIgPSBfcmVmNyRbMV07XG4gICAgICB2YXIgaW50ZXJzZWN0aW9ucyA9IEludGVyc2VjdC5saW5lU2VnbWVudC5wb2x5bGluZShhMSwgYTIsIHBvaW50cyk7XG5cbiAgICAgIGlmIChpbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYWNjLnB1c2goZ2V0SW50ZXJzZWN0aW9uLmFwcGx5KHZvaWQgMCwgW21lc3NhZ2VdLmNvbmNhdChpbnRlcnNlY3Rpb25zLmZsYXRNYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICByZXR1cm4gaS5wb2ludHM7XG4gICAgICAgIH0pKSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gc2lkZUludGVyc2VjdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChfaW50OSkge1xuICAgICAgcmV0dXJuIF9pbnQ5LmRpZEludGVyc2VjdDtcbiAgICB9KTtcbiAgfVxufTtcbkludGVyc2VjdC5hcmMgPSB7XG4gIC8vIEludGVyc2VjdCBhbiBhcmMgd2l0aCBhIGxpbmUgc2VnbWVudC5cbiAgbGluZVNlZ21lbnQ6IGZ1bmN0aW9uIGxpbmVTZWdtZW50KGNlbnRlciwgcmFkaXVzLCBzdGFydCwgZW5kLCBhMSwgYTIpIHtcbiAgICByZXR1cm4gSW50ZXJzZWN0LmxpbmVTZWdtZW50LmFyYyhhMSwgYTIsIGNlbnRlciwgcmFkaXVzLCBzdGFydCwgZW5kKTtcbiAgfSxcbiAgLy8gSW50ZXJzZWN0IGFuIGFyYyB3aXRoIGEgcmVjdGFuZ2xlLlxuICByZWN0YW5nbGU6IGZ1bmN0aW9uIHJlY3RhbmdsZShjZW50ZXIsIHJhZGl1cywgc3RhcnQsIGVuZCwgcG9pbnQsIHNpemUpIHtcbiAgICByZXR1cm4gSW50ZXJzZWN0LnJlY3RhbmdsZS5hcmMocG9pbnQsIHNpemUsIGNlbnRlciwgcmFkaXVzLCBzdGFydCwgZW5kKTtcbiAgfSxcbiAgLy8gSW50ZXJzZWN0IGFuIGFyYyB3aXRoIGEgYm91bmRpbmcgYm94LlxuICBib3VuZHM6IGZ1bmN0aW9uIGJvdW5kcyhjZW50ZXIsIHJhZGl1cywgc3RhcnQsIGVuZCwgX2JvdW5kczQpIHtcbiAgICB2YXIgbWluWCA9IF9ib3VuZHM0Lm1pblgsXG4gICAgICAgIG1pblkgPSBfYm91bmRzNC5taW5ZLFxuICAgICAgICB3aWR0aCA9IF9ib3VuZHM0LndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfYm91bmRzNC5oZWlnaHQ7XG4gICAgcmV0dXJuIEludGVyc2VjdC5hcmMucmVjdGFuZ2xlKGNlbnRlciwgcmFkaXVzLCBzdGFydCwgZW5kLCBbbWluWCwgbWluWV0sIFt3aWR0aCwgaGVpZ2h0XSk7XG4gIH1cbn07XG5JbnRlcnNlY3QuY2lyY2xlID0ge1xuICAvLyBJbnRlcnNlY3QgYSBjaXJjbGUgd2l0aCBhIGxpbmUgc2VnbWVudC5cbiAgbGluZVNlZ21lbnQ6IGZ1bmN0aW9uIGxpbmVTZWdtZW50KGMsIHIsIGExLCBhMikge1xuICAgIHJldHVybiBJbnRlcnNlY3QubGluZVNlZ21lbnQuY2lyY2xlKGExLCBhMiwgYywgcik7XG4gIH0sXG4gIC8vIEludGVyc2VjdCBhIGNpcmNsZSB3aXRoIGEgY2lyY2xlLlxuICBjaXJjbGU6IGZ1bmN0aW9uIGNpcmNsZShjMSwgcjEsIGMyLCByMikge1xuICAgIHZhciBkeCA9IGMyWzBdIC0gYzFbMF0sXG4gICAgICAgIGR5ID0gYzJbMV0gLSBjMVsxXTtcbiAgICB2YXIgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSksXG4gICAgICAgIHggPSAoZCAqIGQgLSByMiAqIHIyICsgcjEgKiByMSkgLyAoMiAqIGQpLFxuICAgICAgICB5ID0gTWF0aC5zcXJ0KHIxICogcjEgLSB4ICogeCk7XG4gICAgZHggLz0gZDtcbiAgICBkeSAvPSBkO1xuICAgIHJldHVybiBnZXRJbnRlcnNlY3Rpb24oJ2ludGVyc2VjdGlvbicsIFtjMVswXSArIGR4ICogeCAtIGR5ICogeSwgYzFbMV0gKyBkeSAqIHggKyBkeCAqIHldLCBbYzFbMF0gKyBkeCAqIHggKyBkeSAqIHksIGMxWzFdICsgZHkgKiB4IC0gZHggKiB5XSk7XG4gIH0sXG4gIC8vIEludGVyc2VjdCBhIGNpcmNsZSB3aXRoIGEgcmVjdGFuZ2xlLlxuICByZWN0YW5nbGU6IGZ1bmN0aW9uIHJlY3RhbmdsZShjLCByLCBwb2ludCwgc2l6ZSkge1xuICAgIHJldHVybiBJbnRlcnNlY3QucmVjdGFuZ2xlLmNpcmNsZShwb2ludCwgc2l6ZSwgYywgcik7XG4gIH0sXG4gIC8vIEludGVyc2VjdCBhIGNpcmNsZSB3aXRoIGEgYm91bmRpbmcgYm94LlxuICBib3VuZHM6IGZ1bmN0aW9uIGJvdW5kcyhjLCByLCBfYm91bmRzNSkge1xuICAgIHZhciBtaW5YID0gX2JvdW5kczUubWluWCxcbiAgICAgICAgbWluWSA9IF9ib3VuZHM1Lm1pblksXG4gICAgICAgIHdpZHRoID0gX2JvdW5kczUud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9ib3VuZHM1LmhlaWdodDtcbiAgICByZXR1cm4gSW50ZXJzZWN0LmNpcmNsZS5yZWN0YW5nbGUoYywgciwgW21pblgsIG1pblldLCBbd2lkdGgsIGhlaWdodF0pO1xuICB9XG59O1xuSW50ZXJzZWN0LmVsbGlwc2UgPSB7XG4gIC8vIEludGVyc2VjdCBhbiBlbGxpcHNlIHdpdGggYSByYXkuXG4gIHJheTogZnVuY3Rpb24gcmF5KGNlbnRlciwgcngsIHJ5LCByb3RhdGlvbiwgcG9pbnQsIGRpcmVjdGlvbikge1xuICAgIHJldHVybiBJbnRlcnNlY3QucmF5LmVsbGlwc2UocG9pbnQsIGRpcmVjdGlvbiwgY2VudGVyLCByeCwgcnksIHJvdGF0aW9uKTtcbiAgfSxcbiAgLy8gSW50ZXJzZWN0IGFuIGVsbGlwc2Ugd2l0aCBhIGxpbmUgc2VnbWVudC5cbiAgbGluZVNlZ21lbnQ6IGZ1bmN0aW9uIGxpbmVTZWdtZW50KGNlbnRlciwgcngsIHJ5LCByb3RhdGlvbiwgYTEsIGEyKSB7XG4gICAgaWYgKHJvdGF0aW9uID09PSB2b2lkIDApIHtcbiAgICAgIHJvdGF0aW9uID0gMDtcbiAgICB9XG5cbiAgICBpZiAocnggPT09IHJ5KSB7XG4gICAgICByZXR1cm4gSW50ZXJzZWN0LmxpbmVTZWdtZW50LmNpcmNsZShhMSwgYTIsIGNlbnRlciwgcngpO1xuICAgIH1cblxuICAgIHJldHVybiBJbnRlcnNlY3QubGluZVNlZ21lbnQuZWxsaXBzZShhMSwgYTIsIGNlbnRlciwgcngsIHJ5LCByb3RhdGlvbik7XG4gIH0sXG4gIC8vIEludGVyc2VjdCBhbiBlbGxpcHNlIHdpdGggYSByZWN0YW5nbGUuXG4gIHJlY3RhbmdsZTogZnVuY3Rpb24gcmVjdGFuZ2xlKGNlbnRlciwgcngsIHJ5LCByb3RhdGlvbiwgcG9pbnQsIHNpemUpIHtcbiAgICBpZiAocm90YXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgcm90YXRpb24gPSAwO1xuICAgIH1cblxuICAgIGlmIChyeCA9PT0gcnkpIHtcbiAgICAgIHJldHVybiBJbnRlcnNlY3QucmVjdGFuZ2xlLmNpcmNsZShwb2ludCwgc2l6ZSwgY2VudGVyLCByeCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEludGVyc2VjdC5yZWN0YW5nbGUuZWxsaXBzZShwb2ludCwgc2l6ZSwgY2VudGVyLCByeCwgcnksIHJvdGF0aW9uKTtcbiAgfSxcbiAgLy8gR2V0IGFuIGludGVyc2VjdGlvbiBiZXR3ZWVuIGFuIGVsbGlwc2UgYW5kIGEgc2Vjb25kIGVsbGlwc2UuXG4gIC8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9kcmF3YWJsZS85Mjc5MmY1OWI2ZmY4ODY5ZDhiMVxuICBlbGxpcHNlOiBmdW5jdGlvbiBlbGxpcHNlKF9jMSwgX3J4MSwgX3J5MSwgX3IxLCBfYzIsIF9yeDIsIF9yeTIsIF9yMikge1xuICAgIC8vIFRPRE9cbiAgICByZXR1cm4gZ2V0SW50ZXJzZWN0aW9uKCdubyBpbnRlcnNlY3Rpb24nKTtcbiAgfSxcbiAgY2lyY2xlOiBmdW5jdGlvbiBjaXJjbGUoYywgcngsIHJ5LCByb3RhdGlvbiwgYzIsIHIyKSB7XG4gICAgcmV0dXJuIEludGVyc2VjdC5lbGxpcHNlLmVsbGlwc2UoYywgcngsIHJ5LCByb3RhdGlvbiwgYzIsIHIyLCByMiwgMCk7XG4gIH0sXG4gIC8vIEludGVyc2VjdCBhbiBlbGxpcHNlIHdpdGggYSBib3VuZGluZyBib3guXG4gIGJvdW5kczogZnVuY3Rpb24gYm91bmRzKGMsIHJ4LCByeSwgcm90YXRpb24sIF9ib3VuZHM2KSB7XG4gICAgdmFyIG1pblggPSBfYm91bmRzNi5taW5YLFxuICAgICAgICBtaW5ZID0gX2JvdW5kczYubWluWSxcbiAgICAgICAgd2lkdGggPSBfYm91bmRzNi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX2JvdW5kczYuaGVpZ2h0O1xuICAgIHJldHVybiBJbnRlcnNlY3QuZWxsaXBzZS5yZWN0YW5nbGUoYywgcngsIHJ5LCByb3RhdGlvbiwgW21pblgsIG1pblldLCBbd2lkdGgsIGhlaWdodF0pO1xuICB9XG59O1xuSW50ZXJzZWN0LmJvdW5kcyA9IHtcbiAgcmF5OiBmdW5jdGlvbiByYXkoYm91bmRzLCBvcmlnaW4sIGRpcmVjdGlvbikge1xuICAgIHZhciBtaW5YID0gYm91bmRzLm1pblgsXG4gICAgICAgIG1pblkgPSBib3VuZHMubWluWSxcbiAgICAgICAgd2lkdGggPSBib3VuZHMud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IGJvdW5kcy5oZWlnaHQ7XG4gICAgcmV0dXJuIEludGVyc2VjdC5yYXkucmVjdGFuZ2xlKG9yaWdpbiwgZGlyZWN0aW9uLCBbbWluWCwgbWluWV0sIFt3aWR0aCwgaGVpZ2h0XSk7XG4gIH0sXG4gIGxpbmVTZWdtZW50OiBmdW5jdGlvbiBsaW5lU2VnbWVudChib3VuZHMsIGExLCBhMikge1xuICAgIHZhciBtaW5YID0gYm91bmRzLm1pblgsXG4gICAgICAgIG1pblkgPSBib3VuZHMubWluWSxcbiAgICAgICAgd2lkdGggPSBib3VuZHMud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IGJvdW5kcy5oZWlnaHQ7XG4gICAgcmV0dXJuIEludGVyc2VjdC5saW5lU2VnbWVudC5yZWN0YW5nbGUoYTEsIGEyLCBbbWluWCwgbWluWV0sIFt3aWR0aCwgaGVpZ2h0XSk7XG4gIH0sXG4gIHJlY3RhbmdsZTogZnVuY3Rpb24gcmVjdGFuZ2xlKGJvdW5kcywgcG9pbnQsIHNpemUpIHtcbiAgICB2YXIgbWluWCA9IGJvdW5kcy5taW5YLFxuICAgICAgICBtaW5ZID0gYm91bmRzLm1pblksXG4gICAgICAgIHdpZHRoID0gYm91bmRzLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBib3VuZHMuaGVpZ2h0O1xuICAgIHJldHVybiBJbnRlcnNlY3QucmVjdGFuZ2xlLnJlY3RhbmdsZShwb2ludCwgc2l6ZSwgW21pblgsIG1pblldLCBbd2lkdGgsIGhlaWdodF0pO1xuICB9LFxuICBib3VuZHM6IGZ1bmN0aW9uIGJvdW5kcyhib3VuZHMxLCBib3VuZHMyKSB7XG4gICAgcmV0dXJuIEludGVyc2VjdC5yZWN0YW5nbGUucmVjdGFuZ2xlKFtib3VuZHMxLm1pblgsIGJvdW5kczEubWluWV0sIFtib3VuZHMxLndpZHRoLCBib3VuZHMxLmhlaWdodF0sIFtib3VuZHMyLm1pblgsIGJvdW5kczIubWluWV0sIFtib3VuZHMyLndpZHRoLCBib3VuZHMyLmhlaWdodF0pO1xuICB9LFxuICBhcmM6IGZ1bmN0aW9uIGFyYyhib3VuZHMsIGNlbnRlciwgcmFkaXVzLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIG1pblggPSBib3VuZHMubWluWCxcbiAgICAgICAgbWluWSA9IGJvdW5kcy5taW5ZLFxuICAgICAgICB3aWR0aCA9IGJvdW5kcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gYm91bmRzLmhlaWdodDtcbiAgICByZXR1cm4gSW50ZXJzZWN0LmFyYy5yZWN0YW5nbGUoY2VudGVyLCByYWRpdXMsIHN0YXJ0LCBlbmQsIFttaW5YLCBtaW5ZXSwgW3dpZHRoLCBoZWlnaHRdKTtcbiAgfSxcbiAgY2lyY2xlOiBmdW5jdGlvbiBjaXJjbGUoYm91bmRzLCBjLCByKSB7XG4gICAgdmFyIG1pblggPSBib3VuZHMubWluWCxcbiAgICAgICAgbWluWSA9IGJvdW5kcy5taW5ZLFxuICAgICAgICB3aWR0aCA9IGJvdW5kcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gYm91bmRzLmhlaWdodDtcbiAgICByZXR1cm4gSW50ZXJzZWN0LmNpcmNsZS5yZWN0YW5nbGUoYywgciwgW21pblgsIG1pblldLCBbd2lkdGgsIGhlaWdodF0pO1xuICB9LFxuICBlbGxpcHNlOiBmdW5jdGlvbiBlbGxpcHNlKGJvdW5kcywgYywgcngsIHJ5LCByb3RhdGlvbikge1xuICAgIGlmIChyb3RhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICByb3RhdGlvbiA9IDA7XG4gICAgfVxuXG4gICAgdmFyIG1pblggPSBib3VuZHMubWluWCxcbiAgICAgICAgbWluWSA9IGJvdW5kcy5taW5ZLFxuICAgICAgICB3aWR0aCA9IGJvdW5kcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gYm91bmRzLmhlaWdodDtcbiAgICByZXR1cm4gSW50ZXJzZWN0LmVsbGlwc2UucmVjdGFuZ2xlKGMsIHJ4LCByeSwgcm90YXRpb24sIFttaW5YLCBtaW5ZXSwgW3dpZHRoLCBoZWlnaHRdKTtcbiAgfSxcbiAgcG9seWxpbmU6IGZ1bmN0aW9uIHBvbHlsaW5lKGJvdW5kcywgcG9pbnRzKSB7XG4gICAgcmV0dXJuIEludGVyc2VjdC5wb2x5bGluZS5ib3VuZHMocG9pbnRzLCBib3VuZHMpO1xuICB9XG59O1xuSW50ZXJzZWN0LnBvbHlsaW5lID0ge1xuICAvLyBJbnRlcnNlY3QgYSBwb2x5bGluZSB3aXRoIGEgbGluZSBzZWdtZW50LlxuICBsaW5lU2VnbWVudDogZnVuY3Rpb24gbGluZVNlZ21lbnQocG9pbnRzLCBhMSwgYTIpIHtcbiAgICByZXR1cm4gSW50ZXJzZWN0LmxpbmVTZWdtZW50LnBvbHlsaW5lKGExLCBhMiwgcG9pbnRzKTtcbiAgfSxcbiAgLy8gSW50ZXJlc2N0IGEgcG9seWxpbmUgd2l0aCBhIHJlY3RhbmdsZS5cbiAgcmVjdGFuZ2xlOiBmdW5jdGlvbiByZWN0YW5nbGUocG9pbnRzLCBwb2ludCwgc2l6ZSkge1xuICAgIHJldHVybiBJbnRlcnNlY3QucmVjdGFuZ2xlLnBvbHlsaW5lKHBvaW50LCBzaXplLCBwb2ludHMpO1xuICB9LFxuICAvLyBJbnRlcnNlY3QgYSBwb2x5bGluZSB3aXRoIGEgYm91bmRpbmcgYm94LlxuICBib3VuZHM6IGZ1bmN0aW9uIGJvdW5kcyhwb2ludHMsIF9ib3VuZHM3KSB7XG4gICAgcmV0dXJuIEludGVyc2VjdC5yZWN0YW5nbGUucG9seWxpbmUoW19ib3VuZHM3Lm1pblgsIF9ib3VuZHM3Lm1pblldLCBbX2JvdW5kczcud2lkdGgsIF9ib3VuZHM3LmhlaWdodF0sIHBvaW50cyk7XG4gIH1cbn07XG5cbnZhciBTdmcgPSBmdW5jdGlvbiBTdmcoKSB7fTtcblxuU3ZnLmVsbGlwc2UgPSBmdW5jdGlvbiAoQSwgcikge1xuICByZXR1cm4gXCJNIFwiICsgKEFbMF0gLSByKSArIFwiLFwiICsgQVsxXSArIFwiXFxuICAgICAgYSBcIiArIHIgKyBcIixcIiArIHIgKyBcIiAwIDEsMCBcIiArIHIgKiAyICsgXCIsMFxcbiAgICAgIGEgXCIgKyByICsgXCIsXCIgKyByICsgXCIgMCAxLDAgLVwiICsgciAqIDIgKyBcIiwwIFwiO1xufTtcblxuU3ZnLm1vdmVUbyA9IGZ1bmN0aW9uICh2KSB7XG4gIHJldHVybiBcIk0gXCIgKyB2WzBdICsgXCIsXCIgKyB2WzFdICsgXCIgXCI7XG59O1xuXG5TdmcubGluZVRvID0gZnVuY3Rpb24gKHYpIHtcbiAgcmV0dXJuIFwiTCBcIiArIHZbMF0gKyBcIixcIiArIHZbMV0gKyBcIiBcIjtcbn07XG5cblN2Zy5saW5lID0gZnVuY3Rpb24gKGEpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHB0cyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgcHRzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBTdmcubW92ZVRvKGEpICsgcHRzLm1hcChmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBTdmcubGluZVRvKHApO1xuICB9KS5qb2luKCk7XG59O1xuXG5TdmcuaExpbmVUbyA9IGZ1bmN0aW9uICh2KSB7XG4gIHJldHVybiBcIkggXCIgKyB2WzBdICsgXCIsXCIgKyB2WzFdICsgXCIgXCI7XG59O1xuXG5TdmcudkxpbmVUbyA9IGZ1bmN0aW9uICh2KSB7XG4gIHJldHVybiBcIlYgXCIgKyB2WzBdICsgXCIsXCIgKyB2WzFdICsgXCIgXCI7XG59O1xuXG5TdmcuYmV6aWVyVG8gPSBmdW5jdGlvbiAoQSwgQiwgQykge1xuICByZXR1cm4gXCJDIFwiICsgQVswXSArIFwiLFwiICsgQVsxXSArIFwiIFwiICsgQlswXSArIFwiLFwiICsgQlsxXSArIFwiIFwiICsgQ1swXSArIFwiLFwiICsgQ1sxXSArIFwiIFwiO1xufTtcblxuU3ZnLmFyY1RvID0gZnVuY3Rpb24gKEMsIHIsIEEsIEIpIHtcbiAgcmV0dXJuIFtTdmcubW92ZVRvKEEpLCAnQScsIHIsIHIsIDAsIFV0aWxzLmdldFN3ZWVwKEMsIEEsIEIpID4gMCA/ICcxJyA6ICcwJywgMCwgQlswXSwgQlsxXV0uam9pbignICcpO1xufTtcblxuU3ZnLmNsb3NlUGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICdaJztcbn07XG5cblN2Zy5yZWN0VG8gPSBmdW5jdGlvbiAoQSkge1xuICByZXR1cm4gWydSJywgQVswXSwgQVsxXV0uam9pbignICcpO1xufTtcblxuU3ZnLmdldFBvaW50QXRMZW5ndGggPSBmdW5jdGlvbiAocGF0aCwgbGVuZ3RoKSB7XG4gIHZhciBwb2ludCA9IHBhdGguZ2V0UG9pbnRBdExlbmd0aChsZW5ndGgpO1xuICByZXR1cm4gW3BvaW50LngsIHBvaW50LnldO1xufTtcblxudmFyIERPVUJMRV9DTElDS19EVVJBVElPTiA9IDI1MDtcblxudmFyIElucHV0cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIElucHV0cygpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5wb2ludGVyID0gdm9pZCAwO1xuICAgIHRoaXMua2V5Ym9hcmQgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXlzID0ge307XG4gICAgdGhpcy5wb2ludGVyVXBUaW1lID0gMDtcblxuICAgIHRoaXMucGFuU3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIF90aGlzJHBvaW50ZXIsIF90aGlzJHBvaW50ZXIyO1xuXG4gICAgICB2YXIgc2hpZnRLZXkgPSBlLnNoaWZ0S2V5LFxuICAgICAgICAgIGN0cmxLZXkgPSBlLmN0cmxLZXksXG4gICAgICAgICAgbWV0YUtleSA9IGUubWV0YUtleSxcbiAgICAgICAgICBhbHRLZXkgPSBlLmFsdEtleTtcbiAgICAgIHZhciBpbmZvID0ge1xuICAgICAgICB0YXJnZXQ6ICd3aGVlbCcsXG4gICAgICAgIHBvaW50ZXJJZDogKChfdGhpcyRwb2ludGVyID0gX3RoaXMucG9pbnRlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHBvaW50ZXIucG9pbnRlcklkKSB8fCAwLFxuICAgICAgICBvcmlnaW46ICgoX3RoaXMkcG9pbnRlcjIgPSBfdGhpcy5wb2ludGVyKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcG9pbnRlcjIub3JpZ2luKSB8fCBbMCwgMF0sXG4gICAgICAgIGRlbHRhOiBbMCwgMF0sXG4gICAgICAgIHByZXNzdXJlOiAwLjUsXG4gICAgICAgIHBvaW50OiBJbnB1dHMuZ2V0UG9pbnQoZSksXG4gICAgICAgIHNoaWZ0S2V5OiBzaGlmdEtleSxcbiAgICAgICAgY3RybEtleTogY3RybEtleSxcbiAgICAgICAgbWV0YUtleTogbWV0YUtleSxcbiAgICAgICAgYWx0S2V5OiBhbHRLZXlcbiAgICAgIH07XG4gICAgICBfdGhpcy5wb2ludGVyID0gaW5mbztcbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH07XG5cbiAgICB0aGlzLnBhbiA9IGZ1bmN0aW9uIChkZWx0YSwgZSkge1xuICAgICAgaWYgKCFfdGhpcy5wb2ludGVyIHx8IF90aGlzLnBvaW50ZXIudGFyZ2V0ICE9PSAnd2hlZWwnKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5wYW5TdGFydChlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNoaWZ0S2V5ID0gZS5zaGlmdEtleSxcbiAgICAgICAgICBjdHJsS2V5ID0gZS5jdHJsS2V5LFxuICAgICAgICAgIG1ldGFLZXkgPSBlLm1ldGFLZXksXG4gICAgICAgICAgYWx0S2V5ID0gZS5hbHRLZXk7XG4gICAgICB2YXIgcHJldiA9IF90aGlzLnBvaW50ZXI7XG4gICAgICB2YXIgcG9pbnQgPSBJbnB1dHMuZ2V0UG9pbnQoZSk7XG5cbiAgICAgIHZhciBpbmZvID0gX2V4dGVuZHMoe30sIHByZXYsIHtcbiAgICAgICAgdGFyZ2V0OiAnd2hlZWwnLFxuICAgICAgICBkZWx0YTogZGVsdGEsXG4gICAgICAgIHBvaW50OiBWZWMuc3ViKHBvaW50LCBkZWx0YSksXG4gICAgICAgIHNoaWZ0S2V5OiBzaGlmdEtleSxcbiAgICAgICAgY3RybEtleTogY3RybEtleSxcbiAgICAgICAgbWV0YUtleTogbWV0YUtleSxcbiAgICAgICAgYWx0S2V5OiBhbHRLZXlcbiAgICAgIH0pO1xuXG4gICAgICBfdGhpcy5wb2ludGVyID0gaW5mbztcbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH07XG5cbiAgICB0aGlzLmNhbkFjY2VwdCA9IGZ1bmN0aW9uIChfcG9pbnRlcklkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gICByZXR1cm4gKFxuICAgICAgLy8gICAgIHRoaXMuYWN0aXZlUG9pbnRlcklkID09PSB1bmRlZmluZWQgfHwgdGhpcy5hY3RpdmVQb2ludGVySWQgPT09IHBvaW50ZXJJZFxuICAgICAgLy8gICApXG4gICAgfTtcblxuICAgIHRoaXMua2V5ZG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgX3RoaXMkcG9pbnRlcjMsIF90aGlzJHBvaW50ZXI0O1xuXG4gICAgICB2YXIgc2hpZnRLZXkgPSBlLnNoaWZ0S2V5LFxuICAgICAgICAgIGN0cmxLZXkgPSBlLmN0cmxLZXksXG4gICAgICAgICAgbWV0YUtleSA9IGUubWV0YUtleSxcbiAgICAgICAgICBhbHRLZXkgPSBlLmFsdEtleTtcbiAgICAgIF90aGlzLmtleXNbZS5rZXldID0gdHJ1ZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvaW50OiAoKF90aGlzJHBvaW50ZXIzID0gX3RoaXMucG9pbnRlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHBvaW50ZXIzLnBvaW50KSB8fCBbMCwgMF0sXG4gICAgICAgIG9yaWdpbjogKChfdGhpcyRwb2ludGVyNCA9IF90aGlzLnBvaW50ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRwb2ludGVyNC5vcmlnaW4pIHx8IFswLCAwXSxcbiAgICAgICAga2V5OiBlLmtleSxcbiAgICAgICAga2V5czogT2JqZWN0LmtleXMoX3RoaXMua2V5cyksXG4gICAgICAgIHNoaWZ0S2V5OiBzaGlmdEtleSxcbiAgICAgICAgY3RybEtleTogY3RybEtleSxcbiAgICAgICAgbWV0YUtleTogVXRpbHMuaXNEYXJ3aW4oKSA/IG1ldGFLZXkgOiBjdHJsS2V5LFxuICAgICAgICBhbHRLZXk6IGFsdEtleVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdGhpcy5rZXl1cCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgX3RoaXMkcG9pbnRlcjUsIF90aGlzJHBvaW50ZXI2O1xuXG4gICAgICB2YXIgc2hpZnRLZXkgPSBlLnNoaWZ0S2V5LFxuICAgICAgICAgIGN0cmxLZXkgPSBlLmN0cmxLZXksXG4gICAgICAgICAgbWV0YUtleSA9IGUubWV0YUtleSxcbiAgICAgICAgICBhbHRLZXkgPSBlLmFsdEtleTtcbiAgICAgIGRlbGV0ZSBfdGhpcy5rZXlzW2Uua2V5XTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvaW50OiAoKF90aGlzJHBvaW50ZXI1ID0gX3RoaXMucG9pbnRlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHBvaW50ZXI1LnBvaW50KSB8fCBbMCwgMF0sXG4gICAgICAgIG9yaWdpbjogKChfdGhpcyRwb2ludGVyNiA9IF90aGlzLnBvaW50ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRwb2ludGVyNi5vcmlnaW4pIHx8IFswLCAwXSxcbiAgICAgICAga2V5OiBlLmtleSxcbiAgICAgICAga2V5czogT2JqZWN0LmtleXMoX3RoaXMua2V5cyksXG4gICAgICAgIHNoaWZ0S2V5OiBzaGlmdEtleSxcbiAgICAgICAgY3RybEtleTogY3RybEtleSxcbiAgICAgICAgbWV0YUtleTogVXRpbHMuaXNEYXJ3aW4oKSA/IG1ldGFLZXkgOiBjdHJsS2V5LFxuICAgICAgICBhbHRLZXk6IGFsdEtleVxuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIF9wcm90byA9IElucHV0cy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnRvdWNoU3RhcnQgPSBmdW5jdGlvbiB0b3VjaFN0YXJ0KGUsIHRhcmdldCkge1xuICAgIHZhciBzaGlmdEtleSA9IGUuc2hpZnRLZXksXG4gICAgICAgIGN0cmxLZXkgPSBlLmN0cmxLZXksXG4gICAgICAgIG1ldGFLZXkgPSBlLm1ldGFLZXksXG4gICAgICAgIGFsdEtleSA9IGUuYWx0S2V5O1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgdG91Y2ggPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgIHZhciBpbmZvID0ge1xuICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICBwb2ludGVySWQ6IHRvdWNoLmlkZW50aWZpZXIsXG4gICAgICBvcmlnaW46IElucHV0cy5nZXRQb2ludCh0b3VjaCksXG4gICAgICBkZWx0YTogWzAsIDBdLFxuICAgICAgcG9pbnQ6IElucHV0cy5nZXRQb2ludCh0b3VjaCksXG4gICAgICBwcmVzc3VyZTogSW5wdXRzLmdldFByZXNzdXJlKHRvdWNoKSxcbiAgICAgIHNoaWZ0S2V5OiBzaGlmdEtleSxcbiAgICAgIGN0cmxLZXk6IGN0cmxLZXksXG4gICAgICBtZXRhS2V5OiBVdGlscy5pc0RhcndpbigpID8gbWV0YUtleSA6IGN0cmxLZXksXG4gICAgICBhbHRLZXk6IGFsdEtleVxuICAgIH07XG4gICAgdGhpcy5wb2ludGVyID0gaW5mbztcbiAgICByZXR1cm4gaW5mbztcbiAgfTtcblxuICBfcHJvdG8udG91Y2hNb3ZlID0gZnVuY3Rpb24gdG91Y2hNb3ZlKGUsIHRhcmdldCkge1xuICAgIHZhciBzaGlmdEtleSA9IGUuc2hpZnRLZXksXG4gICAgICAgIGN0cmxLZXkgPSBlLmN0cmxLZXksXG4gICAgICAgIG1ldGFLZXkgPSBlLm1ldGFLZXksXG4gICAgICAgIGFsdEtleSA9IGUuYWx0S2V5O1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgdG91Y2ggPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgIHZhciBwcmV2ID0gdGhpcy5wb2ludGVyO1xuICAgIHZhciBwb2ludCA9IElucHV0cy5nZXRQb2ludCh0b3VjaCk7XG4gICAgdmFyIGRlbHRhID0gcHJldiAhPSBudWxsICYmIHByZXYucG9pbnQgPyBWZWMuc3ViKHBvaW50LCBwcmV2LnBvaW50KSA6IFswLCAwXTtcblxuICAgIHZhciBpbmZvID0gX2V4dGVuZHMoe1xuICAgICAgb3JpZ2luOiBwb2ludFxuICAgIH0sIHByZXYsIHtcbiAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgcG9pbnRlcklkOiB0b3VjaC5pZGVudGlmaWVyLFxuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgZGVsdGE6IGRlbHRhLFxuICAgICAgcHJlc3N1cmU6IElucHV0cy5nZXRQcmVzc3VyZSh0b3VjaCksXG4gICAgICBzaGlmdEtleTogc2hpZnRLZXksXG4gICAgICBjdHJsS2V5OiBjdHJsS2V5LFxuICAgICAgbWV0YUtleTogVXRpbHMuaXNEYXJ3aW4oKSA/IG1ldGFLZXkgOiBjdHJsS2V5LFxuICAgICAgYWx0S2V5OiBhbHRLZXlcbiAgICB9KTtcblxuICAgIHRoaXMucG9pbnRlciA9IGluZm87XG4gICAgcmV0dXJuIGluZm87XG4gIH07XG5cbiAgX3Byb3RvLnBvaW50ZXJEb3duID0gZnVuY3Rpb24gcG9pbnRlckRvd24oZSwgdGFyZ2V0KSB7XG4gICAgdmFyIHNoaWZ0S2V5ID0gZS5zaGlmdEtleSxcbiAgICAgICAgY3RybEtleSA9IGUuY3RybEtleSxcbiAgICAgICAgbWV0YUtleSA9IGUubWV0YUtleSxcbiAgICAgICAgYWx0S2V5ID0gZS5hbHRLZXk7XG4gICAgdmFyIHBvaW50ID0gSW5wdXRzLmdldFBvaW50KGUpO1xuICAgIHZhciBpbmZvID0ge1xuICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICBwb2ludGVySWQ6IGUucG9pbnRlcklkLFxuICAgICAgb3JpZ2luOiBwb2ludCxcbiAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgIGRlbHRhOiBbMCwgMF0sXG4gICAgICBwcmVzc3VyZTogSW5wdXRzLmdldFByZXNzdXJlKGUpLFxuICAgICAgc2hpZnRLZXk6IHNoaWZ0S2V5LFxuICAgICAgY3RybEtleTogY3RybEtleSxcbiAgICAgIG1ldGFLZXk6IFV0aWxzLmlzRGFyd2luKCkgPyBtZXRhS2V5IDogY3RybEtleSxcbiAgICAgIGFsdEtleTogYWx0S2V5XG4gICAgfTtcbiAgICB0aGlzLnBvaW50ZXIgPSBpbmZvO1xuICAgIHJldHVybiBpbmZvO1xuICB9O1xuXG4gIF9wcm90by5wb2ludGVyRW50ZXIgPSBmdW5jdGlvbiBwb2ludGVyRW50ZXIoZSwgdGFyZ2V0KSB7XG4gICAgdmFyIHNoaWZ0S2V5ID0gZS5zaGlmdEtleSxcbiAgICAgICAgY3RybEtleSA9IGUuY3RybEtleSxcbiAgICAgICAgbWV0YUtleSA9IGUubWV0YUtleSxcbiAgICAgICAgYWx0S2V5ID0gZS5hbHRLZXk7XG4gICAgdmFyIHBvaW50ID0gSW5wdXRzLmdldFBvaW50KGUpO1xuICAgIHZhciBpbmZvID0ge1xuICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICBwb2ludGVySWQ6IGUucG9pbnRlcklkLFxuICAgICAgb3JpZ2luOiBwb2ludCxcbiAgICAgIGRlbHRhOiBbMCwgMF0sXG4gICAgICBwb2ludDogcG9pbnQsXG4gICAgICBwcmVzc3VyZTogSW5wdXRzLmdldFByZXNzdXJlKGUpLFxuICAgICAgc2hpZnRLZXk6IHNoaWZ0S2V5LFxuICAgICAgY3RybEtleTogY3RybEtleSxcbiAgICAgIG1ldGFLZXk6IFV0aWxzLmlzRGFyd2luKCkgPyBtZXRhS2V5IDogY3RybEtleSxcbiAgICAgIGFsdEtleTogYWx0S2V5XG4gICAgfTtcbiAgICB0aGlzLnBvaW50ZXIgPSBpbmZvO1xuICAgIHJldHVybiBpbmZvO1xuICB9O1xuXG4gIF9wcm90by5wb2ludGVyTW92ZSA9IGZ1bmN0aW9uIHBvaW50ZXJNb3ZlKGUsIHRhcmdldCkge1xuICAgIHZhciBzaGlmdEtleSA9IGUuc2hpZnRLZXksXG4gICAgICAgIGN0cmxLZXkgPSBlLmN0cmxLZXksXG4gICAgICAgIG1ldGFLZXkgPSBlLm1ldGFLZXksXG4gICAgICAgIGFsdEtleSA9IGUuYWx0S2V5O1xuICAgIHZhciBwcmV2ID0gdGhpcy5wb2ludGVyO1xuICAgIHZhciBwb2ludCA9IElucHV0cy5nZXRQb2ludChlKTtcbiAgICB2YXIgZGVsdGEgPSBwcmV2ICE9IG51bGwgJiYgcHJldi5wb2ludCA/IFZlYy5zdWIocG9pbnQsIHByZXYucG9pbnQpIDogWzAsIDBdO1xuXG4gICAgdmFyIGluZm8gPSBfZXh0ZW5kcyh7XG4gICAgICBvcmlnaW46IHBvaW50XG4gICAgfSwgcHJldiwge1xuICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICBwb2ludGVySWQ6IGUucG9pbnRlcklkLFxuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgZGVsdGE6IGRlbHRhLFxuICAgICAgcHJlc3N1cmU6IElucHV0cy5nZXRQcmVzc3VyZShlKSxcbiAgICAgIHNoaWZ0S2V5OiBzaGlmdEtleSxcbiAgICAgIGN0cmxLZXk6IGN0cmxLZXksXG4gICAgICBtZXRhS2V5OiBVdGlscy5pc0RhcndpbigpID8gbWV0YUtleSA6IGN0cmxLZXksXG4gICAgICBhbHRLZXk6IGFsdEtleVxuICAgIH0pO1xuXG4gICAgdGhpcy5wb2ludGVyID0gaW5mbztcbiAgICByZXR1cm4gaW5mbztcbiAgfTtcblxuICBfcHJvdG8ucG9pbnRlclVwID0gZnVuY3Rpb24gcG9pbnRlclVwKGUsIHRhcmdldCkge1xuICAgIHZhciBzaGlmdEtleSA9IGUuc2hpZnRLZXksXG4gICAgICAgIGN0cmxLZXkgPSBlLmN0cmxLZXksXG4gICAgICAgIG1ldGFLZXkgPSBlLm1ldGFLZXksXG4gICAgICAgIGFsdEtleSA9IGUuYWx0S2V5O1xuICAgIHZhciBwcmV2ID0gdGhpcy5wb2ludGVyO1xuICAgIHZhciBwb2ludCA9IElucHV0cy5nZXRQb2ludChlKTtcbiAgICB2YXIgZGVsdGEgPSBwcmV2ICE9IG51bGwgJiYgcHJldi5wb2ludCA/IFZlYy5zdWIocG9pbnQsIHByZXYucG9pbnQpIDogWzAsIDBdO1xuXG4gICAgdmFyIGluZm8gPSBfZXh0ZW5kcyh7XG4gICAgICBvcmlnaW46IHBvaW50XG4gICAgfSwgcHJldiwge1xuICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICBwb2ludGVySWQ6IGUucG9pbnRlcklkLFxuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgZGVsdGE6IGRlbHRhLFxuICAgICAgcHJlc3N1cmU6IElucHV0cy5nZXRQcmVzc3VyZShlKSxcbiAgICAgIHNoaWZ0S2V5OiBzaGlmdEtleSxcbiAgICAgIGN0cmxLZXk6IGN0cmxLZXksXG4gICAgICBtZXRhS2V5OiBVdGlscy5pc0RhcndpbigpID8gbWV0YUtleSA6IGN0cmxLZXksXG4gICAgICBhbHRLZXk6IGFsdEtleVxuICAgIH0pO1xuXG4gICAgdGhpcy5wb2ludGVyID0gaW5mbztcbiAgICB0aGlzLnBvaW50ZXJVcFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHJldHVybiBpbmZvO1xuICB9O1xuXG4gIF9wcm90by5pc0RvdWJsZUNsaWNrID0gZnVuY3Rpb24gaXNEb3VibGVDbGljaygpIHtcbiAgICBpZiAoIXRoaXMucG9pbnRlcikgcmV0dXJuO1xuICAgIHZhciBfdGhpcyRwb2ludGVyNyA9IHRoaXMucG9pbnRlcixcbiAgICAgICAgb3JpZ2luID0gX3RoaXMkcG9pbnRlcjcub3JpZ2luLFxuICAgICAgICBwb2ludCA9IF90aGlzJHBvaW50ZXI3LnBvaW50O1xuICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGhpcy5wb2ludGVyVXBUaW1lIDwgRE9VQkxFX0NMSUNLX0RVUkFUSU9OICYmIFZlYy5kaXN0KG9yaWdpbiwgcG9pbnQpIDwgNDtcbiAgfTtcblxuICBfcHJvdG8uY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLnBvaW50ZXIgPSB1bmRlZmluZWQ7XG4gIH07XG5cbiAgX3Byb3RvLnJlc2V0RG91YmxlQ2xpY2sgPSBmdW5jdGlvbiByZXNldERvdWJsZUNsaWNrKCkge1xuICAgIHRoaXMucG9pbnRlclVwVGltZSA9IDA7XG4gIH07XG5cbiAgX3Byb3RvLnBpbmNoID0gZnVuY3Rpb24gcGluY2gocG9pbnQsIG9yaWdpbikge1xuICAgIHZhciBfdGhpcyRrZXlzID0gdGhpcy5rZXlzLFxuICAgICAgICBzaGlmdEtleSA9IF90aGlzJGtleXMuc2hpZnRLZXksXG4gICAgICAgIGN0cmxLZXkgPSBfdGhpcyRrZXlzLmN0cmxLZXksXG4gICAgICAgIG1ldGFLZXkgPSBfdGhpcyRrZXlzLm1ldGFLZXksXG4gICAgICAgIGFsdEtleSA9IF90aGlzJGtleXMuYWx0S2V5O1xuICAgIHZhciBwcmV2ID0gdGhpcy5wb2ludGVyO1xuICAgIHZhciBkZWx0YSA9IFZlYy5zdWIob3JpZ2luLCBwb2ludCk7XG4gICAgdmFyIGluZm8gPSB7XG4gICAgICBwb2ludGVySWQ6IDAsXG4gICAgICB0YXJnZXQ6ICdwaW5jaCcsXG4gICAgICBvcmlnaW46IChwcmV2ID09IG51bGwgPyB2b2lkIDAgOiBwcmV2Lm9yaWdpbikgfHwgVmVjLnJvdW5kKHBvaW50KSxcbiAgICAgIGRlbHRhOiBkZWx0YSxcbiAgICAgIHBvaW50OiBWZWMucm91bmQocG9pbnQpLFxuICAgICAgcHJlc3N1cmU6IDAuNSxcbiAgICAgIHNoaWZ0S2V5OiBzaGlmdEtleSxcbiAgICAgIGN0cmxLZXk6IGN0cmxLZXksXG4gICAgICBtZXRhS2V5OiBVdGlscy5pc0RhcndpbigpID8gbWV0YUtleSA6IGN0cmxLZXksXG4gICAgICBhbHRLZXk6IGFsdEtleVxuICAgIH07XG4gICAgdGhpcy5wb2ludGVyID0gaW5mbztcbiAgICByZXR1cm4gaW5mbztcbiAgfTtcblxuICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB0aGlzLnBvaW50ZXJVcFRpbWUgPSAwO1xuICAgIHRoaXMucG9pbnRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmtleWJvYXJkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMua2V5cyA9IHt9O1xuICB9O1xuXG4gIElucHV0cy5nZXRQb2ludCA9IGZ1bmN0aW9uIGdldFBvaW50KGUpIHtcbiAgICByZXR1cm4gW051bWJlcihlLmNsaWVudFgudG9QcmVjaXNpb24oNSkpLCBOdW1iZXIoZS5jbGllbnRZLnRvUHJlY2lzaW9uKDUpKV07XG4gIH07XG5cbiAgSW5wdXRzLmdldFByZXNzdXJlID0gZnVuY3Rpb24gZ2V0UHJlc3N1cmUoZSkge1xuICAgIHJldHVybiAncHJlc3N1cmUnIGluIGUgPyBOdW1iZXIoZS5wcmVzc3VyZS50b1ByZWNpc2lvbig1KSkgfHwgMC41IDogMC41O1xuICB9O1xuXG4gIElucHV0cy5jb21tYW5kS2V5ID0gZnVuY3Rpb24gY29tbWFuZEtleSgpIHtcbiAgICByZXR1cm4gVXRpbHMuaXNEYXJ3aW4oKSA/ICfijJgnIDogJ0N0cmwnO1xuICB9O1xuXG4gIHJldHVybiBJbnB1dHM7XG59KCk7XG5cbnZhciBpbnB1dHMgPSAvKiNfX1BVUkVfXyovbmV3IElucHV0cygpO1xuXG5mdW5jdGlvbiB1c2Vab29tRXZlbnRzKCkge1xuICB2YXIgclBpbmNoRGEgPSBSZWFjdC51c2VSZWYodW5kZWZpbmVkKTtcbiAgdmFyIHJQaW5jaFBvaW50ID0gUmVhY3QudXNlUmVmKHVuZGVmaW5lZCk7XG5cbiAgdmFyIF91c2VUTENvbnRleHQgPSB1c2VUTENvbnRleHQoKSxcbiAgICAgIGNhbGxiYWNrcyA9IF91c2VUTENvbnRleHQuY2FsbGJhY2tzO1xuXG4gIHJlYWN0VXNlR2VzdHVyZS51c2VHZXN0dXJlKHtcbiAgICBvbldoZWVsOiBmdW5jdGlvbiBvbldoZWVsKF9yZWYpIHtcbiAgICAgIHZhciBlID0gX3JlZi5ldmVudCxcbiAgICAgICAgICBkZWx0YSA9IF9yZWYuZGVsdGE7XG4gICAgICB2YXIgaW5mbyA9IGlucHV0cy5wYW4oZGVsdGEsIGUpO1xuXG4gICAgICBpZiAoZS5jdHJsS2V5KSB7XG4gICAgICAgIGNhbGxiYWNrcy5vblpvb20gPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vblpvb20oaW5mbywgZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cblxuXG4gICAgICBjYWxsYmFja3Mub25QYW4gPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vblBhbihpbmZvLCBlKTtcbiAgICB9LFxuICAgIG9uUGluY2g6IGZ1bmN0aW9uIG9uUGluY2goX3JlZjIpIHtcbiAgICAgIHZhciBwaW5jaGluZyA9IF9yZWYyLnBpbmNoaW5nLFxuICAgICAgICAgIGRhID0gX3JlZjIuZGEsXG4gICAgICAgICAgb3JpZ2luID0gX3JlZjIub3JpZ2luLFxuICAgICAgICAgIGUgPSBfcmVmMi5ldmVudDtcblxuICAgICAgaWYgKCFwaW5jaGluZykge1xuICAgICAgICB2YXIgX2luZm8gPSBpbnB1dHMucGluY2gob3JpZ2luLCBvcmlnaW4pO1xuXG4gICAgICAgIGNhbGxiYWNrcy5vblBpbmNoRW5kID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25QaW5jaEVuZChfaW5mbywgZSk7XG4gICAgICAgIHJQaW5jaERhLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJQaW5jaFBvaW50LmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHJQaW5jaFBvaW50LmN1cnJlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgX2luZm8yID0gaW5wdXRzLnBpbmNoKG9yaWdpbiwgb3JpZ2luKTtcblxuICAgICAgICBjYWxsYmFja3Mub25QaW5jaFN0YXJ0ID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25QaW5jaFN0YXJ0KF9pbmZvMiwgZSk7XG4gICAgICAgIHJQaW5jaERhLmN1cnJlbnQgPSBkYTtcbiAgICAgICAgclBpbmNoUG9pbnQuY3VycmVudCA9IG9yaWdpbjtcbiAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cblxuXG4gICAgICB2YXIgX1ZlYyRzdWIgPSBWZWMuc3ViKHJQaW5jaERhLmN1cnJlbnQsIGRhKSxcbiAgICAgICAgICBkaXN0YW5jZURlbHRhID0gX1ZlYyRzdWJbMF07XG5cbiAgICAgIHZhciBpbmZvID0gaW5wdXRzLnBpbmNoKHJQaW5jaFBvaW50LmN1cnJlbnQsIG9yaWdpbik7IC8vIE5hbWluZyB0aGluZ3MgaXMgaGFyZFxuXG4gICAgICBjYWxsYmFja3Mub25QaW5jaCA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uUGluY2goX2V4dGVuZHMoe30sIGluZm8sIHtcbiAgICAgICAgcG9pbnQ6IG9yaWdpbixcbiAgICAgICAgb3JpZ2luOiByUGluY2hQb2ludC5jdXJyZW50LFxuICAgICAgICBkZWx0YTogW10uY29uY2F0KGluZm8uZGVsdGEsIFtkaXN0YW5jZURlbHRhXSlcbiAgICAgIH0pLCBlKTtcbiAgICAgIHJQaW5jaERhLmN1cnJlbnQgPSBkYTtcbiAgICAgIHJQaW5jaFBvaW50LmN1cnJlbnQgPSBvcmlnaW47XG4gICAgfVxuICB9LCB7XG4gICAgZG9tVGFyZ2V0OiB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogZG9jdW1lbnQuYm9keSxcbiAgICBldmVudE9wdGlvbnM6IHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlU2FmYXJpRm9jdXNPdXRGaXgoKSB7XG4gIHZhciBfdXNlVExDb250ZXh0ID0gdXNlVExDb250ZXh0KCksXG4gICAgICBjYWxsYmFja3MgPSBfdXNlVExDb250ZXh0LmNhbGxiYWNrcztcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGhhbmRsZUZvY3VzT3V0KCkge1xuICAgICAgY2FsbGJhY2tzLm9uQmx1ckVkaXRpbmdTaGFwZSA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uQmx1ckVkaXRpbmdTaGFwZSgpO1xuICAgIH1cblxuICAgIGlmICghVXRpbHMuaXNNb2JpbGUoKSkgcmV0dXJuO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgaGFuZGxlRm9jdXNPdXQpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBoYW5kbGVGb2N1c091dCk7XG4gICAgfTtcbiAgfSwgW2NhbGxiYWNrc10pO1xufVxuXG5mdW5jdGlvbiB1c2VDYW52YXNFdmVudHMoKSB7XG4gIHZhciBfdXNlVExDb250ZXh0ID0gdXNlVExDb250ZXh0KCksXG4gICAgICBjYWxsYmFja3MgPSBfdXNlVExDb250ZXh0LmNhbGxiYWNrcztcblxuICB2YXIgb25Qb2ludGVyRG93biA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgZS5jdXJyZW50VGFyZ2V0LnNldFBvaW50ZXJDYXB0dXJlKGUucG9pbnRlcklkKTtcblxuICAgIGlmIChlLmJ1dHRvbiA9PT0gMCkge1xuICAgICAgdmFyIGluZm8gPSBpbnB1dHMucG9pbnRlckRvd24oZSwgJ2NhbnZhcycpO1xuICAgICAgY2FsbGJhY2tzLm9uUG9pbnRDYW52YXMgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vblBvaW50Q2FudmFzKGluZm8sIGUpO1xuICAgICAgY2FsbGJhY2tzLm9uUG9pbnRlckRvd24gPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vblBvaW50ZXJEb3duKGluZm8sIGUpO1xuICAgIH1cbiAgfSwgW2NhbGxiYWNrc10pO1xuICB2YXIgb25Qb2ludGVyTW92ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIGlmIChlLmN1cnJlbnRUYXJnZXQuaGFzUG9pbnRlckNhcHR1cmUoZS5wb2ludGVySWQpKSB7XG4gICAgICB2YXIgX2luZm8gPSBpbnB1dHMucG9pbnRlck1vdmUoZSwgJ2NhbnZhcycpO1xuXG4gICAgICBjYWxsYmFja3Mub25EcmFnQ2FudmFzID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25EcmFnQ2FudmFzKF9pbmZvLCBlKTtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IGlucHV0cy5wb2ludGVyTW92ZShlLCAnY2FudmFzJyk7XG4gICAgY2FsbGJhY2tzLm9uUG9pbnRlck1vdmUgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vblBvaW50ZXJNb3ZlKGluZm8sIGUpO1xuICB9LCBbY2FsbGJhY2tzXSk7XG4gIHZhciBvblBvaW50ZXJVcCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB2YXIgaXNEb3VibGVDbGljayA9IGlucHV0cy5pc0RvdWJsZUNsaWNrKCk7XG4gICAgdmFyIGluZm8gPSBpbnB1dHMucG9pbnRlclVwKGUsICdjYW52YXMnKTtcblxuICAgIGlmIChlLmN1cnJlbnRUYXJnZXQuaGFzUG9pbnRlckNhcHR1cmUoZS5wb2ludGVySWQpKSB7XG4gICAgICB2YXIgX2UkY3VycmVudFRhcmdldDtcblxuICAgICAgKF9lJGN1cnJlbnRUYXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQpID09IG51bGwgPyB2b2lkIDAgOiBfZSRjdXJyZW50VGFyZ2V0LnJlbGVhc2VQb2ludGVyQ2FwdHVyZShlLnBvaW50ZXJJZCk7XG4gICAgfVxuXG4gICAgaWYgKGlzRG91YmxlQ2xpY2sgJiYgIShpbmZvLmFsdEtleSB8fCBpbmZvLm1ldGFLZXkpKSB7XG4gICAgICBjYWxsYmFja3Mub25Eb3VibGVDbGlja0NhbnZhcyA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uRG91YmxlQ2xpY2tDYW52YXMoaW5mbywgZSk7XG4gICAgfVxuXG4gICAgY2FsbGJhY2tzLm9uUmVsZWFzZUNhbnZhcyA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uUmVsZWFzZUNhbnZhcyhpbmZvLCBlKTtcbiAgICBjYWxsYmFja3Mub25Qb2ludGVyVXAgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vblBvaW50ZXJVcChpbmZvLCBlKTtcbiAgfSwgW2NhbGxiYWNrc10pO1xuICByZXR1cm4ge1xuICAgIG9uUG9pbnRlckRvd246IG9uUG9pbnRlckRvd24sXG4gICAgb25Qb2ludGVyTW92ZTogb25Qb2ludGVyTW92ZSxcbiAgICBvblBvaW50ZXJVcDogb25Qb2ludGVyVXBcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlU2hhcGVFdmVudHMoaWQsIGRpc2FibGUpIHtcbiAgaWYgKGRpc2FibGUgPT09IHZvaWQgMCkge1xuICAgIGRpc2FibGUgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBfdXNlVExDb250ZXh0ID0gdXNlVExDb250ZXh0KCksXG4gICAgICBjYWxsYmFja3MgPSBfdXNlVExDb250ZXh0LmNhbGxiYWNrcztcblxuICB2YXIgb25Qb2ludGVyRG93biA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIF9lJGN1cnJlbnRUYXJnZXQ7XG5cbiAgICBpZiAoZGlzYWJsZSkgcmV0dXJuO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgKF9lJGN1cnJlbnRUYXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQpID09IG51bGwgPyB2b2lkIDAgOiBfZSRjdXJyZW50VGFyZ2V0LnNldFBvaW50ZXJDYXB0dXJlKGUucG9pbnRlcklkKTtcbiAgICB2YXIgaW5mbyA9IGlucHV0cy5wb2ludGVyRG93bihlLCBpZCk7XG4gICAgY2FsbGJhY2tzLm9uUG9pbnRTaGFwZSA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uUG9pbnRTaGFwZShpbmZvLCBlKTtcbiAgICBjYWxsYmFja3Mub25Qb2ludGVyRG93biA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uUG9pbnRlckRvd24oaW5mbywgZSk7XG4gIH0sIFtjYWxsYmFja3MsIGlkLCBkaXNhYmxlXSk7XG4gIHZhciBvblBvaW50ZXJVcCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGRpc2FibGUpIHJldHVybjtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHZhciBpc0RvdWJsZUNsaWNrID0gaW5wdXRzLmlzRG91YmxlQ2xpY2soKTtcbiAgICB2YXIgaW5mbyA9IGlucHV0cy5wb2ludGVyVXAoZSwgaWQpO1xuXG4gICAgaWYgKGUuY3VycmVudFRhcmdldC5oYXNQb2ludGVyQ2FwdHVyZShlLnBvaW50ZXJJZCkpIHtcbiAgICAgIHZhciBfZSRjdXJyZW50VGFyZ2V0MjtcblxuICAgICAgKF9lJGN1cnJlbnRUYXJnZXQyID0gZS5jdXJyZW50VGFyZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX2UkY3VycmVudFRhcmdldDIucmVsZWFzZVBvaW50ZXJDYXB0dXJlKGUucG9pbnRlcklkKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEb3VibGVDbGljayAmJiAhKGluZm8uYWx0S2V5IHx8IGluZm8ubWV0YUtleSkpIHtcbiAgICAgIGNhbGxiYWNrcy5vbkRvdWJsZUNsaWNrU2hhcGUgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vbkRvdWJsZUNsaWNrU2hhcGUoaW5mbywgZSk7XG4gICAgfVxuXG4gICAgY2FsbGJhY2tzLm9uUmVsZWFzZVNoYXBlID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25SZWxlYXNlU2hhcGUoaW5mbywgZSk7XG4gICAgY2FsbGJhY2tzLm9uUG9pbnRlclVwID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25Qb2ludGVyVXAoaW5mbywgZSk7XG4gIH0sIFtjYWxsYmFja3MsIGlkLCBkaXNhYmxlXSk7XG4gIHZhciBvblBvaW50ZXJNb3ZlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZGlzYWJsZSkgcmV0dXJuO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgaWYgKGlucHV0cy5wb2ludGVyICYmIGUucG9pbnRlcklkICE9PSBpbnB1dHMucG9pbnRlci5wb2ludGVySWQpIHJldHVybjtcbiAgICB2YXIgaW5mbyA9IGlucHV0cy5wb2ludGVyTW92ZShlLCBpZCk7XG5cbiAgICBpZiAoZS5jdXJyZW50VGFyZ2V0Lmhhc1BvaW50ZXJDYXB0dXJlKGUucG9pbnRlcklkKSkge1xuICAgICAgY2FsbGJhY2tzLm9uRHJhZ1NoYXBlID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25EcmFnU2hhcGUoaW5mbywgZSk7XG4gICAgfVxuXG4gICAgY2FsbGJhY2tzLm9uUG9pbnRlck1vdmUgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vblBvaW50ZXJNb3ZlKGluZm8sIGUpO1xuICB9LCBbY2FsbGJhY2tzLCBpZCwgZGlzYWJsZV0pO1xuICB2YXIgb25Qb2ludGVyRW50ZXIgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xuICAgIGlmIChkaXNhYmxlKSByZXR1cm47XG4gICAgdmFyIGluZm8gPSBpbnB1dHMucG9pbnRlckVudGVyKGUsIGlkKTtcbiAgICBjYWxsYmFja3Mub25Ib3ZlclNoYXBlID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25Ib3ZlclNoYXBlKGluZm8sIGUpO1xuICB9LCBbY2FsbGJhY2tzLCBpZCwgZGlzYWJsZV0pO1xuICB2YXIgb25Qb2ludGVyTGVhdmUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xuICAgIGlmIChkaXNhYmxlKSByZXR1cm47XG4gICAgdmFyIGluZm8gPSBpbnB1dHMucG9pbnRlckVudGVyKGUsIGlkKTtcbiAgICBjYWxsYmFja3Mub25VbmhvdmVyU2hhcGUgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vblVuaG92ZXJTaGFwZShpbmZvLCBlKTtcbiAgfSwgW2NhbGxiYWNrcywgaWQsIGRpc2FibGVdKTtcbiAgdmFyIG9uVG91Y2hTdGFydCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9LCBbXSk7XG4gIHZhciBvblRvdWNoRW5kID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHtcbiAgICBvblBvaW50ZXJEb3duOiBvblBvaW50ZXJEb3duLFxuICAgIG9uUG9pbnRlclVwOiBvblBvaW50ZXJVcCxcbiAgICBvblBvaW50ZXJFbnRlcjogb25Qb2ludGVyRW50ZXIsXG4gICAgb25Qb2ludGVyTW92ZTogb25Qb2ludGVyTW92ZSxcbiAgICBvblBvaW50ZXJMZWF2ZTogb25Qb2ludGVyTGVhdmUsXG4gICAgb25Ub3VjaFN0YXJ0OiBvblRvdWNoU3RhcnQsXG4gICAgb25Ub3VjaEVuZDogb25Ub3VjaEVuZFxuICB9O1xufVxuXG5mdW5jdGlvbiBhZGRUb1NoYXBlVHJlZShzaGFwZSwgYnJhbmNoLCBzaGFwZXMsIHNlbGVjdGVkSWRzLCBpbmZvKSB7XG4gIHZhciBub2RlID0ge1xuICAgIHNoYXBlOiBzaGFwZSxcbiAgICBpc0hvdmVyZWQ6IGluZm8uaG92ZXJlZElkID09PSBzaGFwZS5pZCxcbiAgICBpc0N1cnJlbnRQYXJlbnQ6IGluZm8uY3VycmVudFBhcmVudElkID09PSBzaGFwZS5pZCxcbiAgICBpc0VkaXRpbmc6IGluZm8uZWRpdGluZ0lkID09PSBzaGFwZS5pZCxcbiAgICBpc0JpbmRpbmc6IGluZm8uYmluZGluZ0lkID09PSBzaGFwZS5pZCxcbiAgICBpc0RhcmtNb2RlOiBpbmZvLmlzRGFya01vZGUgfHwgZmFsc2UsXG4gICAgaXNTZWxlY3RlZDogc2VsZWN0ZWRJZHMuaW5jbHVkZXMoc2hhcGUuaWQpXG4gIH07XG4gIGJyYW5jaC5wdXNoKG5vZGUpO1xuXG4gIGlmIChzaGFwZS5jaGlsZHJlbikge1xuICAgIG5vZGUuY2hpbGRyZW4gPSBbXTtcbiAgICBzaGFwZS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgICByZXR1cm4gc2hhcGVzW2lkXTtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5jaGlsZEluZGV4IC0gYi5jaGlsZEluZGV4O1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkU2hhcGUpIHtcbiAgICAgIHJldHVybiAoLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgYWRkVG9TaGFwZVRyZWUoY2hpbGRTaGFwZSwgbm9kZS5jaGlsZHJlbiwgc2hhcGVzLCBzZWxlY3RlZElkcywgaW5mbylcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlU2hhcGVUcmVlKHBhZ2UsIHBhZ2VTdGF0ZSwgc2hhcGVVdGlscywgaW5mbywgb25DaGFuZ2UpIHtcbiAgaWYgKGluZm8gPT09IHZvaWQgMCkge1xuICAgIGluZm8gPSB7fTtcbiAgfVxuXG4gIHZhciByUHJldmlvdXNDb3VudCA9IFJlYWN0LnVzZVJlZigwKTtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gW107XG4gIHZhciBzZWxlY3RlZElkcyA9IHBhZ2VTdGF0ZS5zZWxlY3RlZElkcyxcbiAgICAgIGNhbWVyYSA9IHBhZ2VTdGF0ZS5jYW1lcmE7IC8vIEZpbmQgdmlld3BvcnRcblxuICB2YXIgX1ZlYyRzdWIgPSBWZWMuc3ViKFZlYy5kaXYoWzAsIDBdLCBjYW1lcmEuem9vbSksIGNhbWVyYS5wb2ludCksXG4gICAgICBtaW5YID0gX1ZlYyRzdWJbMF0sXG4gICAgICBtaW5ZID0gX1ZlYyRzdWJbMV07XG5cbiAgdmFyIF9WZWMkc3ViMiA9IFZlYy5zdWIoVmVjLmRpdihbd2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodF0sIGNhbWVyYS56b29tKSwgY2FtZXJhLnBvaW50KSxcbiAgICAgIG1heFggPSBfVmVjJHN1YjJbMF0sXG4gICAgICBtYXhZID0gX1ZlYyRzdWIyWzFdO1xuXG4gIHZhciB2aWV3cG9ydCA9IHtcbiAgICBtaW5YOiBtaW5YLFxuICAgIG1pblk6IG1pblksXG4gICAgbWF4WDogbWF4WCxcbiAgICBtYXhZOiBtYXhZLFxuICAgIGhlaWdodDogbWF4WCAtIG1pblgsXG4gICAgd2lkdGg6IG1heFkgLSBtaW5ZXG4gIH07IC8vIEZpbHRlciBzaGFwZXMgdGhhdCBhcmUgaW4gdmlld1xuXG4gIHZhciBzaGFwZXNUb1JlbmRlciA9IE9iamVjdC52YWx1ZXMocGFnZS5zaGFwZXMpLmZpbHRlcihmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICBpZiAoc2hhcGUucGFyZW50SWQgIT09IHBhZ2UuaWQpIHJldHVybiBmYWxzZTsgLy8gRG9uJ3QgaGlkZSBzZWxlY3RlZCBzaGFwZXMgKHRoaXMgYnJlYWtzIGNlcnRhaW4gZHJhZyBpbnRlcmFjdGlvbnMpXG5cbiAgICBpZiAocGFnZVN0YXRlLnNlbGVjdGVkSWRzLmluY2x1ZGVzKHNoYXBlLmlkKSkgcmV0dXJuIHRydWU7XG4gICAgdmFyIHNoYXBlQm91bmRzID0gc2hhcGVVdGlsc1tzaGFwZS50eXBlXS5nZXRCb3VuZHMoc2hhcGUpO1xuICAgIHJldHVybiAoLy8gVE9ETzogU29tZSBzaGFwZXMgc2hvdWxkIGFsd2F5cyByZW5kZXIgKGxpbmVzLCByYXlzKVxuICAgICAgVXRpbHMuYm91bmRzQ29udGFpbih2aWV3cG9ydCwgc2hhcGVCb3VuZHMpIHx8IFV0aWxzLmJvdW5kc0NvbGxpZGUodmlld3BvcnQsIHNoYXBlQm91bmRzKVxuICAgICk7XG4gIH0pOyAvLyBDYWxsIG9uQ2hhbmdlIGNhbGxiYWNrIHdoZW4gbnVtYmVyIG9mIHJlbmRlcmluZyBzaGFwZXMgY2hhbmdlc1xuXG4gIGlmIChzaGFwZXNUb1JlbmRlci5sZW5ndGggIT09IHJQcmV2aW91c0NvdW50LmN1cnJlbnQpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBvbkNoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogb25DaGFuZ2Uoc2hhcGVzVG9SZW5kZXIubWFwKGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgICByZXR1cm4gc2hhcGUuaWQ7XG4gICAgICB9KSk7XG4gICAgfSwgMCk7XG4gICAgclByZXZpb3VzQ291bnQuY3VycmVudCA9IHNoYXBlc1RvUmVuZGVyLmxlbmd0aDtcbiAgfSAvLyBQb3B1bGF0ZSB0aGUgc2hhcGUgdHJlZVxuXG5cbiAgdmFyIHRyZWUgPSBbXTtcbiAgc2hhcGVzVG9SZW5kZXIuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhLmNoaWxkSW5kZXggLSBiLmNoaWxkSW5kZXg7XG4gIH0pLmZvckVhY2goZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgcmV0dXJuIGFkZFRvU2hhcGVUcmVlKHNoYXBlLCB0cmVlLCBwYWdlLnNoYXBlcywgc2VsZWN0ZWRJZHMsIGluZm8pO1xuICB9KTtcbiAgcmV0dXJuIHRyZWU7XG59XG5cbnZhciBfdGVtcGxhdGVPYmplY3Q7XG52YXIgc3R5bGVzID0gLyojX19QVVJFX18qL25ldyBNYXAoKTtcblxuZnVuY3Rpb24gbWFrZUNzc1RoZW1lKHByZWZpeCwgdGhlbWUpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHRoZW1lKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgdmFyIHZhbHVlID0gdGhlbWVba2V5XTtcblxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGFjYyArIChcIi0tXCIgKyBwcmVmaXggKyBcIi1cIiArIGtleSArIFwiOiBcIiArIHZhbHVlICsgXCI7XFxuXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sICcnKTtcbn1cblxuZnVuY3Rpb24gdXNlVGhlbWUocHJlZml4LCB0aGVtZSwgc2VsZWN0b3IpIHtcbiAgaWYgKHNlbGVjdG9yID09PSB2b2lkIDApIHtcbiAgICBzZWxlY3RvciA9ICc6cm9vdCc7XG4gIH1cblxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgdmFyIGNzc1RoZW1lID0gbWFrZUNzc1RoZW1lKHByZWZpeCwgdGhlbWUpO1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnaWQnLCBwcmVmaXggKyBcIi10aGVtZVwiKTtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtc2VsZWN0b3InLCBzZWxlY3Rvcik7XG4gICAgc3R5bGUuaW5uZXJIVE1MID0gXCJcXG4gICAgICAgIFwiICsgc2VsZWN0b3IgKyBcIiB7XFxuICAgICAgICAgIFwiICsgY3NzVGhlbWUgKyBcIlxcbiAgICAgICAgfVxcbiAgICAgIFwiO1xuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc3R5bGUgJiYgZG9jdW1lbnQuaGVhZC5jb250YWlucyhzdHlsZSkpIHtcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZChzdHlsZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW3ByZWZpeCwgdGhlbWUsIHNlbGVjdG9yXSk7XG59XG5cbmZ1bmN0aW9uIHVzZVN0eWxlKHVpZCwgcnVsZXMpIHtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc3R5bGVzLmdldCh1aWQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBzdHlsZS5pbm5lckhUTUwgPSBydWxlcztcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ2lkJywgdWlkKTtcbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICBzdHlsZXMuc2V0KHVpZCwgc3R5bGUpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc3R5bGUgJiYgZG9jdW1lbnQuaGVhZC5jb250YWlucyhzdHlsZSkpIHtcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZChzdHlsZSk7XG4gICAgICAgIHN0eWxlc1tcImRlbGV0ZVwiXSh1aWQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFt1aWQsIHJ1bGVzXSk7XG59XG5cbnZhciBjc3MgPSBmdW5jdGlvbiBjc3Moc3RyaW5ncykge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gc3RyaW5ncy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgc3RyaW5nLCBpbmRleCkge1xuICAgIHJldHVybiBhY2MgKyBzdHJpbmcgKyAoaW5kZXggPCBhcmdzLmxlbmd0aCA/IGFyZ3NbaW5kZXhdIDogJycpO1xuICB9LCAnJyk7XG59O1xuXG52YXIgZGVmYXVsdFRoZW1lID0ge1xuICBicnVzaEZpbGw6ICdyZ2JhKDAsMCwwLC4wNSknLFxuICBicnVzaFN0cm9rZTogJ3JnYmEoMCwwLDAsLjI1KScsXG4gIHNlbGVjdFN0cm9rZTogJ3JnYig2NiwgMTMzLCAyNDQpJyxcbiAgc2VsZWN0RmlsbDogJ3JnYmEoNjUsIDEzMiwgMjQ0LCAwLjA1KScsXG4gIGJhY2tncm91bmQ6ICdyZ2IoMjQ4LCAyNDksIDI1MCknLFxuICBmb3JlZ3JvdW5kOiAncmdiKDUxLCA1MSwgNTEpJ1xufTtcbnZhciB0bGNzcyA9IC8qI19fUFVSRV9fKi9jc3MoX3RlbXBsYXRlT2JqZWN0IHx8IChfdGVtcGxhdGVPYmplY3QgPSAvKiNfX1BVUkVfXyovX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlKFtcIlxcbiAgOnJvb3Qge1xcbiAgICAtLXRsLXpvb206IDE7XFxuICAgIC0tdGwtc2NhbGU6IGNhbGMoMSAvIHZhcigtLXRsLXpvb20pKTtcXG4gIH1cXG5cXG4gIC50bC1jb3VudGVyLXNjYWxlZCB7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUodmFyKC0tdGwtc2NhbGUpKTtcXG4gIH1cXG5cXG4gIC50bC1kYXNoZWQge1xcbiAgICBzdHJva2UtZGFzaGFycmF5OiBjYWxjKDJweCAqIHZhcigtLXRsLXNjYWxlKSksIGNhbGMoMnB4ICogdmFyKC0tdGwtc2NhbGUpKTtcXG4gIH1cXG5cXG4gIC50bC10cmFuc3BhcmVudCB7XFxuICAgIGZpbGw6IHRyYW5zcGFyZW50O1xcbiAgICBzdHJva2U6IHRyYW5zcGFyZW50O1xcbiAgfVxcblxcbiAgLnRsLWN1cnNvci1ucyB7XFxuICAgIGN1cnNvcjogbnMtcmVzaXplO1xcbiAgfVxcblxcbiAgLnRsLWN1cnNvci1ldyB7XFxuICAgIGN1cnNvcjogZXctcmVzaXplO1xcbiAgfVxcblxcbiAgLnRsLWN1cnNvci1uZXN3IHtcXG4gICAgY3Vyc29yOiBuZXN3LXJlc2l6ZTtcXG4gIH1cXG5cXG4gIC50bC1jdXJzb3ItbndzZSB7XFxuICAgIGN1cnNvcjogbndzZS1yZXNpemU7XFxuICB9XFxuXFxuICAudGwtY29ybmVyLWhhbmRsZSB7XFxuICAgIHN0cm9rZTogdmFyKC0tdGwtc2VsZWN0U3Ryb2tlKTtcXG4gICAgZmlsbDogdmFyKC0tdGwtYmFja2dyb3VuZCk7XFxuICAgIHN0cm9rZS13aWR0aDogY2FsYygxLjVweCAqIHZhcigtLXRsLXNjYWxlKSk7XFxuICB9XFxuXFxuICAudGwtcm90YXRlLWhhbmRsZSB7XFxuICAgIHN0cm9rZTogdmFyKC0tdGwtc2VsZWN0U3Ryb2tlKTtcXG4gICAgZmlsbDogdmFyKC0tdGwtYmFja2dyb3VuZCk7XFxuICAgIHN0cm9rZS13aWR0aDogY2FsYygxLjVweCAqIHZhcigtLXRsLXNjYWxlKSk7XFxuICAgIGN1cnNvcjogZ3JhYjtcXG4gIH1cXG5cXG4gIC50bC1oYW5kbGUge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKHZhcigtLXRsLXNjYWxlKSk7XFxuICAgIGZpbGw6IHZhcigtLXRsLWJhY2tncm91bmQpO1xcbiAgICBzdHJva2U6IHZhcigtLXRsLXN0cm9rZSk7XFxuICAgIHN0cm9rZS13aWR0aDogY2FsYygycHggKiB2YXIoLS10bC1zY2FsZSkpO1xcbiAgICBwb2ludGVyLWV2ZW50czogYWxsO1xcbiAgfVxcblxcbiAgLnRsLWJpbmRpbmcge1xcbiAgICBmaWxsOiB2YXIoLS10bC1zZWxlY3RGaWxsKTtcXG4gICAgc3Ryb2tlOiB2YXIoLS10bC1zZWxlY3RTdHJva2UpO1xcbiAgICBzdHJva2Utd2lkdGg6IGNhbGMoMXB4ICogdmFyKC0tdGwtc2NhbGUpKTtcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICB9XFxuXFxuICAudGwtYm91bmRzLWNlbnRlciB7XFxuICAgIGZpbGw6IHRyYW5zcGFyZW50O1xcbiAgICBzdHJva2U6IHZhcigtLXRsLXNlbGVjdFN0cm9rZSk7XFxuICAgIHN0cm9rZS13aWR0aDogY2FsYygxLjVweCAqIHZhcigtLXRsLXNjYWxlKSk7XFxuICB9XFxuXFxuICAudGwtYm91bmRzLWJnIHtcXG4gICAgc3Ryb2tlOiBub25lO1xcbiAgICBmaWxsOiB2YXIoLS10bC1zZWxlY3RGaWxsKTtcXG4gICAgcG9pbnRlci1ldmVudHM6IGFsbDtcXG4gIH1cXG5cXG4gIC50bC1icnVzaCB7XFxuICAgIGZpbGw6IHZhcigtLXRsLWJydXNoRmlsbCk7XFxuICAgIHN0cm9rZTogdmFyKC0tdGwtYnJ1c2hTdHJva2UpO1xcbiAgICBzdHJva2Utd2lkdGg6IGNhbGMoMXB4ICogdmFyKC0tdGwtc2NhbGUpKTtcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICB9XFxuXFxuICAudGwtY2FudmFzIHtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICB0b3A6IDBweDtcXG4gICAgbGVmdDogMHB4O1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICB0b3VjaC1hY3Rpb246IG5vbmU7XFxuICAgIHotaW5kZXg6IDEwMDtcXG4gICAgcG9pbnRlci1ldmVudHM6IGFsbDtcXG4gIH1cXG5cXG4gIC50bC1jb250YWluZXIge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHBhZGRpbmc6IDBweDtcXG4gICAgbWFyZ2luOiAwcHg7XFxuICAgIG92ZXJzY3JvbGwtYmVoYXZpb3I6IG5vbmU7XFxuICAgIG92ZXJzY3JvbGwtYmVoYXZpb3IteDogbm9uZTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tdGwtYmFja2dyb3VuZCk7XFxuICB9XFxuXFxuICAudGwtY29udGFpbmVyICoge1xcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gIH1cXG5cXG4gIC50bC1kb3Qge1xcbiAgICBmaWxsOiB2YXIoLS10bC1iYWNrZ3JvdW5kKTtcXG4gICAgc3Ryb2tlOiB2YXIoLS10bC1mb3JlZ3JvdW5kKTtcXG4gICAgc3Ryb2tlLXdpZHRoOiAycHg7XFxuICB9XFxuXFxuICAudGwtaGFuZGxlIHtcXG4gICAgZmlsbDogdmFyKC0tdGwtYmFja2dyb3VuZCk7XFxuICAgIHN0cm9rZTogdmFyKC0tdGwtc2VsZWN0U3Ryb2tlKTtcXG4gICAgc3Ryb2tlLXdpZHRoOiBjYWxjKDEuNXB4ICogdmFyKC0tdGwtc2NhbGUpKTtcXG4gIH1cXG5cXG4gIC50bC1oYW5kbGUtYmcge1xcbiAgICBmaWxsOiB0cmFuc3BhcmVudDtcXG4gICAgc3Ryb2tlOiBub25lO1xcbiAgICBvcGFjaXR5OiAwLjI7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XFxuICB9XFxuXFxuICAudGwtaGFuZGxlLWJnOmhvdmVyIHtcXG4gICAgZmlsbDogdmFyKC0tdGwtc2VsZWN0ZWQtZmlsbCk7XFxuICB9XFxuXFxuICAudGwtaGFuZGxlLWJnOmhvdmVyID4gKiB7XFxuICAgIHN0cm9rZTogdmFyKC0tdGwtc2VsZWN0ZWQtZmlsbCk7XFxuICB9XFxuXFxuICAudGwtaGFuZGxlLWJnOmFjdGl2ZSB7XFxuICAgIGZpbGw6IHZhcigtLXRsLXNlbGVjdGVkLWZpbGwpO1xcbiAgICBzdHJva2U6IHZhcigtLXRsLXNlbGVjdGVkLWZpbGwpO1xcbiAgfVxcblxcbiAgLnRsLWJpbmRpbmctaW5kaWNhdG9yIHtcXG4gICAgc3Ryb2tlLXdpZHRoOiBjYWxjKDNweCAqIHZhcigtLXRsLXNjYWxlKSk7XFxuICAgIGZpbGw6IG5vbmU7XFxuICAgIHN0cm9rZTogdmFyKC0tdGwtc2VsZWN0ZWQpO1xcbiAgfVxcblxcbiAgLnRsLXNoYXBlLWdyb3VwIHtcXG4gICAgb3V0bGluZTogbm9uZTtcXG4gIH1cXG5cXG4gIC50bC1zaGFwZS1ncm91cCA+ICpbZGF0YS1zaHk9J3RydWUnXSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICB9XFxuXFxuICAudGwtc2hhcGUtZ3JvdXA6aG92ZXIgPiAqW2RhdGEtc2h5PSd0cnVlJ10ge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgfVxcblxcbiAgLnRsLWN1cnJlbnQtcGFyZW50ID4gKltkYXRhLXNoeT0ndHJ1ZSddIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gIH1cXG5cIl0pKSk7XG5mdW5jdGlvbiB1c2VUTFRoZW1lKHRoZW1lKSB7XG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBkZWZhdWx0VGhlbWUsIHRoZW1lKTtcbiAgfSksXG4gICAgICB0bHRoZW1lID0gX1JlYWN0JHVzZVN0YXRlWzBdO1xuXG4gIHVzZVRoZW1lKCd0bCcsIHRsdGhlbWUpO1xuICB1c2VTdHlsZSgndGwtY2FudmFzJywgdGxjc3MpO1xufVxuXG5mdW5jdGlvbiB1c2VCb3VuZHNIYW5kbGVFdmVudHMoaWQpIHtcbiAgdmFyIF91c2VUTENvbnRleHQgPSB1c2VUTENvbnRleHQoKSxcbiAgICAgIGNhbGxiYWNrcyA9IF91c2VUTENvbnRleHQuY2FsbGJhY2tzO1xuXG4gIHZhciBvblBvaW50ZXJEb3duID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgX2UkY3VycmVudFRhcmdldDtcblxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgKF9lJGN1cnJlbnRUYXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQpID09IG51bGwgPyB2b2lkIDAgOiBfZSRjdXJyZW50VGFyZ2V0LnNldFBvaW50ZXJDYXB0dXJlKGUucG9pbnRlcklkKTtcbiAgICB2YXIgaW5mbyA9IGlucHV0cy5wb2ludGVyRG93bihlLCBpZCk7XG4gICAgY2FsbGJhY2tzLm9uUG9pbnRCb3VuZHNIYW5kbGUgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vblBvaW50Qm91bmRzSGFuZGxlKGluZm8sIGUpO1xuICAgIGNhbGxiYWNrcy5vblBvaW50ZXJEb3duID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25Qb2ludGVyRG93bihpbmZvLCBlKTtcbiAgfSwgW2NhbGxiYWNrcywgaWRdKTtcbiAgdmFyIG9uUG9pbnRlclVwID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHZhciBpc0RvdWJsZUNsaWNrID0gaW5wdXRzLmlzRG91YmxlQ2xpY2soKTtcbiAgICB2YXIgaW5mbyA9IGlucHV0cy5wb2ludGVyVXAoZSwgaWQpO1xuXG4gICAgaWYgKGUuY3VycmVudFRhcmdldC5oYXNQb2ludGVyQ2FwdHVyZShlLnBvaW50ZXJJZCkpIHtcbiAgICAgIHZhciBfZSRjdXJyZW50VGFyZ2V0MjtcblxuICAgICAgKF9lJGN1cnJlbnRUYXJnZXQyID0gZS5jdXJyZW50VGFyZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX2UkY3VycmVudFRhcmdldDIucmVsZWFzZVBvaW50ZXJDYXB0dXJlKGUucG9pbnRlcklkKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEb3VibGVDbGljayAmJiAhKGluZm8uYWx0S2V5IHx8IGluZm8ubWV0YUtleSkpIHtcbiAgICAgIGNhbGxiYWNrcy5vbkRvdWJsZUNsaWNrQm91bmRzSGFuZGxlID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25Eb3VibGVDbGlja0JvdW5kc0hhbmRsZShpbmZvLCBlKTtcbiAgICB9XG5cbiAgICBjYWxsYmFja3Mub25SZWxlYXNlQm91bmRzSGFuZGxlID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25SZWxlYXNlQm91bmRzSGFuZGxlKGluZm8sIGUpO1xuICAgIGNhbGxiYWNrcy5vblBvaW50ZXJVcCA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uUG9pbnRlclVwKGluZm8sIGUpO1xuICB9LCBbY2FsbGJhY2tzLCBpZF0pO1xuICB2YXIgb25Qb2ludGVyTW92ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgLy8gZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgIGlmIChlLmN1cnJlbnRUYXJnZXQuaGFzUG9pbnRlckNhcHR1cmUoZS5wb2ludGVySWQpKSB7XG4gICAgICBjYWxsYmFja3Mub25EcmFnQm91bmRzSGFuZGxlID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25EcmFnQm91bmRzSGFuZGxlKGlucHV0cy5wb2ludGVyTW92ZShlLCBpZCksIGUpO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gaW5wdXRzLnBvaW50ZXJNb3ZlKGUsIGlkKTtcbiAgICBjYWxsYmFja3Mub25Qb2ludGVyTW92ZSA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uUG9pbnRlck1vdmUoaW5mbywgZSk7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSwgW2NhbGxiYWNrcywgaWRdKTtcbiAgdmFyIG9uUG9pbnRlckVudGVyID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGUpIHtcbiAgICBjYWxsYmFja3Mub25Ib3ZlckJvdW5kc0hhbmRsZSA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uSG92ZXJCb3VuZHNIYW5kbGUoaW5wdXRzLnBvaW50ZXJFbnRlcihlLCBpZCksIGUpO1xuICB9LCBbY2FsbGJhY2tzLCBpZF0pO1xuICB2YXIgb25Qb2ludGVyTGVhdmUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xuICAgIGNhbGxiYWNrcy5vblVuaG92ZXJCb3VuZHNIYW5kbGUgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vblVuaG92ZXJCb3VuZHNIYW5kbGUoaW5wdXRzLnBvaW50ZXJFbnRlcihlLCBpZCksIGUpO1xuICB9LCBbY2FsbGJhY2tzLCBpZF0pO1xuICB2YXIgb25Ub3VjaFN0YXJ0ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0sIFtdKTtcbiAgdmFyIG9uVG91Y2hFbmQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSwgW10pO1xuICByZXR1cm4ge1xuICAgIG9uUG9pbnRlckRvd246IG9uUG9pbnRlckRvd24sXG4gICAgb25Qb2ludGVyVXA6IG9uUG9pbnRlclVwLFxuICAgIG9uUG9pbnRlckVudGVyOiBvblBvaW50ZXJFbnRlcixcbiAgICBvblBvaW50ZXJNb3ZlOiBvblBvaW50ZXJNb3ZlLFxuICAgIG9uUG9pbnRlckxlYXZlOiBvblBvaW50ZXJMZWF2ZSxcbiAgICBvblRvdWNoU3RhcnQ6IG9uVG91Y2hTdGFydCxcbiAgICBvblRvdWNoRW5kOiBvblRvdWNoRW5kXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZUNhbWVyYUNzcyhwYWdlU3RhdGUpIHtcbiAgdmFyIHJHcm91cCA9IFJlYWN0LnVzZVJlZihudWxsKTsgLy8gVXBkYXRlIHRoZSB0bC16b29tIENTUyB2YXJpYWJsZSB3aGVuIHRoZSB6b29tIGNoYW5nZXNcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS10bC16b29tJywgcGFnZVN0YXRlLmNhbWVyYS56b29tLnRvU3RyaW5nKCkpO1xuICB9LCBbcGFnZVN0YXRlLmNhbWVyYS56b29tXSk7IC8vIFVwZGF0ZSB0aGUgZ3JvdXAncyBwb3NpdGlvbiB3aGVuIHRoZSBjYW1lcmEgbW92ZXMgb3Igem9vbXNcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBfckdyb3VwJGN1cnJlbnQ7XG5cbiAgICB2YXIgX3BhZ2VTdGF0ZSRjYW1lcmEgPSBwYWdlU3RhdGUuY2FtZXJhLFxuICAgICAgICB6b29tID0gX3BhZ2VTdGF0ZSRjYW1lcmEuem9vbSxcbiAgICAgICAgcG9pbnQgPSBfcGFnZVN0YXRlJGNhbWVyYS5wb2ludDtcbiAgICAoX3JHcm91cCRjdXJyZW50ID0gckdyb3VwLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfckdyb3VwJGN1cnJlbnQuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBcInNjYWxlKFwiICsgem9vbSArIFwiKSB0cmFuc2xhdGUoXCIgKyBwb2ludFswXSArIFwiIFwiICsgcG9pbnRbMV0gKyBcIilcIik7XG4gIH0sIFtwYWdlU3RhdGUuY2FtZXJhXSk7XG4gIHJldHVybiByR3JvdXA7XG59XG5cbmZ1bmN0aW9uIHVzZVJlbmRlck9uUmVzaXplKCkge1xuICB2YXIgZm9yY2VVcGRhdGUgPSBSZWFjdC51c2VSZWR1Y2VyKGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHggKyAxO1xuICB9LCAwKVsxXTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGVib3VuY2VkVXBkYXRlID0gVXRpbHMuZGVib3VuY2UoZm9yY2VVcGRhdGUsIDk2KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZGVib3VuY2VkVXBkYXRlKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGRlYm91bmNlZFVwZGF0ZSk7XG4gICAgfTtcbiAgfSwgW2ZvcmNlVXBkYXRlXSk7XG59XG5cbmZ1bmN0aW9uIHVzZVNlbGVjdGlvbihwYWdlLCBwYWdlU3RhdGUsIHNoYXBlVXRpbHMpIHtcbiAgdmFyIHNlbGVjdGVkSWRzID0gcGFnZVN0YXRlLnNlbGVjdGVkSWRzO1xuICB2YXIgYm91bmRzID0gdW5kZWZpbmVkO1xuICB2YXIgcm90YXRpb24gPSAwO1xuICB2YXIgaXNMb2NrZWQgPSBmYWxzZTtcblxuICBpZiAoc2VsZWN0ZWRJZHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGlkID0gc2VsZWN0ZWRJZHNbMF07XG4gICAgdmFyIHNoYXBlID0gcGFnZS5zaGFwZXNbaWRdO1xuICAgIHJvdGF0aW9uID0gc2hhcGUucm90YXRpb24gfHwgMDtcbiAgICBpc0xvY2tlZCA9IHNoYXBlLmlzTG9ja2VkIHx8IGZhbHNlO1xuICAgIGJvdW5kcyA9IHNoYXBlVXRpbHNbc2hhcGUudHlwZV0uZ2V0Qm91bmRzKHNoYXBlKTtcbiAgfSBlbHNlIGlmIChzZWxlY3RlZElkcy5sZW5ndGggPiAxKSB7XG4gICAgdmFyIHNlbGVjdGVkU2hhcGVzID0gc2VsZWN0ZWRJZHMubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuIHBhZ2Uuc2hhcGVzW2lkXTtcbiAgICB9KTtcbiAgICByb3RhdGlvbiA9IDA7XG4gICAgaXNMb2NrZWQgPSBzZWxlY3RlZFNoYXBlcy5ldmVyeShmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgIHJldHVybiBzaGFwZS5pc0xvY2tlZDtcbiAgICB9KTtcbiAgICBib3VuZHMgPSBzZWxlY3RlZFNoYXBlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgc2hhcGUsIGkpIHtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzaGFwZVV0aWxzW3NoYXBlLnR5cGVdLmdldFJvdGF0ZWRCb3VuZHMoc2hhcGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gVXRpbHMuZ2V0RXhwYW5kZWRCb3VuZHMoYWNjLCBzaGFwZVV0aWxzW3NoYXBlLnR5cGVdLmdldFJvdGF0ZWRCb3VuZHMoc2hhcGUpKTtcbiAgICB9LCB7fSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJvdW5kczogYm91bmRzLFxuICAgIHJvdGF0aW9uOiByb3RhdGlvbixcbiAgICBpc0xvY2tlZDogaXNMb2NrZWRcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlSGFuZGxlRXZlbnRzKGlkKSB7XG4gIHZhciBfdXNlVExDb250ZXh0ID0gdXNlVExDb250ZXh0KCksXG4gICAgICBjYWxsYmFja3MgPSBfdXNlVExDb250ZXh0LmNhbGxiYWNrcztcblxuICB2YXIgb25Qb2ludGVyRG93biA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIF9lJGN1cnJlbnRUYXJnZXQ7XG5cbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIChfZSRjdXJyZW50VGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX2UkY3VycmVudFRhcmdldC5zZXRQb2ludGVyQ2FwdHVyZShlLnBvaW50ZXJJZCk7XG4gICAgdmFyIGluZm8gPSBpbnB1dHMucG9pbnRlckRvd24oZSwgaWQpO1xuICAgIGNhbGxiYWNrcy5vblBvaW50SGFuZGxlID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25Qb2ludEhhbmRsZShpbmZvLCBlKTtcbiAgICBjYWxsYmFja3Mub25Qb2ludGVyRG93biA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uUG9pbnRlckRvd24oaW5mbywgZSk7XG4gIH0sIFtjYWxsYmFja3MsIGlkXSk7XG4gIHZhciBvblBvaW50ZXJVcCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB2YXIgaXNEb3VibGVDbGljayA9IGlucHV0cy5pc0RvdWJsZUNsaWNrKCk7XG4gICAgdmFyIGluZm8gPSBpbnB1dHMucG9pbnRlclVwKGUsICdib3VuZHMnKTtcblxuICAgIGlmIChlLmN1cnJlbnRUYXJnZXQuaGFzUG9pbnRlckNhcHR1cmUoZS5wb2ludGVySWQpKSB7XG4gICAgICB2YXIgX2UkY3VycmVudFRhcmdldDI7XG5cbiAgICAgIChfZSRjdXJyZW50VGFyZ2V0MiA9IGUuY3VycmVudFRhcmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lJGN1cnJlbnRUYXJnZXQyLnJlbGVhc2VQb2ludGVyQ2FwdHVyZShlLnBvaW50ZXJJZCk7XG5cbiAgICAgIGlmIChpc0RvdWJsZUNsaWNrICYmICEoaW5mby5hbHRLZXkgfHwgaW5mby5tZXRhS2V5KSkge1xuICAgICAgICBjYWxsYmFja3Mub25Eb3VibGVDbGlja0hhbmRsZSA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uRG91YmxlQ2xpY2tIYW5kbGUoaW5mbywgZSk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrcy5vblJlbGVhc2VIYW5kbGUgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vblJlbGVhc2VIYW5kbGUoaW5mbywgZSk7XG4gICAgfVxuXG4gICAgY2FsbGJhY2tzLm9uUG9pbnRlclVwID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25Qb2ludGVyVXAoaW5mbywgZSk7XG4gIH0sIFtjYWxsYmFja3NdKTtcbiAgdmFyIG9uUG9pbnRlck1vdmUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xuICAgIC8vIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICBpZiAoZS5jdXJyZW50VGFyZ2V0Lmhhc1BvaW50ZXJDYXB0dXJlKGUucG9pbnRlcklkKSkge1xuICAgICAgdmFyIF9pbmZvID0gaW5wdXRzLnBvaW50ZXJNb3ZlKGUsIGlkKTtcblxuICAgICAgY2FsbGJhY2tzLm9uRHJhZ0hhbmRsZSA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uRHJhZ0hhbmRsZShfaW5mbywgZSk7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSBpbnB1dHMucG9pbnRlck1vdmUoZSwgaWQpO1xuICAgIGNhbGxiYWNrcy5vblBvaW50ZXJNb3ZlID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25Qb2ludGVyTW92ZShpbmZvLCBlKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9LCBbY2FsbGJhY2tzLCBpZF0pO1xuICB2YXIgb25Qb2ludGVyRW50ZXIgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xuICAgIHZhciBpbmZvID0gaW5wdXRzLnBvaW50ZXJFbnRlcihlLCBpZCk7XG4gICAgY2FsbGJhY2tzLm9uSG92ZXJIYW5kbGUgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vbkhvdmVySGFuZGxlKGluZm8sIGUpO1xuICB9LCBbY2FsbGJhY2tzLCBpZF0pO1xuICB2YXIgb25Qb2ludGVyTGVhdmUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xuICAgIHZhciBpbmZvID0gaW5wdXRzLnBvaW50ZXJFbnRlcihlLCBpZCk7XG4gICAgY2FsbGJhY2tzLm9uVW5ob3ZlckhhbmRsZSA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uVW5ob3ZlckhhbmRsZShpbmZvLCBlKTtcbiAgfSwgW2NhbGxiYWNrcywgaWRdKTtcbiAgdmFyIG9uVG91Y2hTdGFydCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9LCBbXSk7XG4gIHZhciBvblRvdWNoRW5kID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHtcbiAgICBvblBvaW50ZXJEb3duOiBvblBvaW50ZXJEb3duLFxuICAgIG9uUG9pbnRlclVwOiBvblBvaW50ZXJVcCxcbiAgICBvblBvaW50ZXJFbnRlcjogb25Qb2ludGVyRW50ZXIsXG4gICAgb25Qb2ludGVyTW92ZTogb25Qb2ludGVyTW92ZSxcbiAgICBvblBvaW50ZXJMZWF2ZTogb25Qb2ludGVyTGVhdmUsXG4gICAgb25Ub3VjaFN0YXJ0OiBvblRvdWNoU3RhcnQsXG4gICAgb25Ub3VjaEVuZDogb25Ub3VjaEVuZFxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VIYW5kbGVzKHBhZ2UsIHBhZ2VTdGF0ZSkge1xuICB2YXIgc2VsZWN0ZWRJZHMgPSBwYWdlU3RhdGUuc2VsZWN0ZWRJZHM7XG4gIHZhciBzaGFwZVdpdGhIYW5kbGVzID0gdW5kZWZpbmVkO1xuXG4gIGlmIChzZWxlY3RlZElkcy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgaWQgPSBzZWxlY3RlZElkc1swXTtcbiAgICB2YXIgc2hhcGUgPSBwYWdlLnNoYXBlc1tpZF07XG5cbiAgICBpZiAoc2hhcGUuaGFuZGxlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzaGFwZVdpdGhIYW5kbGVzID0gc2hhcGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzaGFwZVdpdGhIYW5kbGVzOiBzaGFwZVdpdGhIYW5kbGVzXG4gIH07XG59XG5cbnZhciBFcnJvckZhbGxiYWNrID0gLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGVycm9yID0gX3JlZi5lcnJvcixcbiAgICAgIHJlc2V0RXJyb3JCb3VuZGFyeSA9IF9yZWYucmVzZXRFcnJvckJvdW5kYXJ5O1xuXG4gIHZhciBfdXNlVExDb250ZXh0ID0gdXNlVExDb250ZXh0KCksXG4gICAgICBjYWxsYmFja3MgPSBfdXNlVExDb250ZXh0LmNhbGxiYWNrcztcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGNhbGxiYWNrcy5vbkVycm9yID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25FcnJvcihlcnJvcik7XG4gICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gIH0sIFtlcnJvciwgcmVzZXRFcnJvckJvdW5kYXJ5LCBjYWxsYmFja3NdKTtcbiAgcmV0dXJuIG51bGw7XG59KTtcblxudmFyIEJydXNoVXBkYXRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJydXNoVXBkYXRlcigpIHtcbiAgICB0aGlzLnJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgIHRoaXMuaXNDb250cm9sbGVkID0gZmFsc2U7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQnJ1c2hVcGRhdGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KGJvdW5kcykge1xuICAgIHZhciBfdGhpcyRyZWY7XG5cbiAgICBpZiAoIXRoaXMuaXNDb250cm9sbGVkKSB0aGlzLmlzQ29udHJvbGxlZCA9IHRydWU7XG5cbiAgICBpZiAoIWJvdW5kcykge1xuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlbG0gPSAoX3RoaXMkcmVmID0gdGhpcy5yZWYpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRyZWYuY3VycmVudDtcbiAgICBpZiAoIWVsbSkgcmV0dXJuO1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ29wYWNpdHknLCAnMScpO1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ3gnLCBib3VuZHMubWluWC50b1N0cmluZygpKTtcbiAgICBlbG0uc2V0QXR0cmlidXRlKCd5JywgYm91bmRzLm1pblkudG9TdHJpbmcoKSk7XG4gICAgZWxtLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBib3VuZHMud2lkdGgudG9TdHJpbmcoKSk7XG4gICAgZWxtLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgYm91bmRzLmhlaWdodC50b1N0cmluZygpKTtcbiAgfTtcblxuICBfcHJvdG8uY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB2YXIgX3RoaXMkcmVmMjtcblxuICAgIHZhciBlbG0gPSAoX3RoaXMkcmVmMiA9IHRoaXMucmVmKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcmVmMi5jdXJyZW50O1xuICAgIGlmICghZWxtKSByZXR1cm47XG4gICAgZWxtLnNldEF0dHJpYnV0ZSgnb3BhY2l0eScsICcwJyk7XG4gICAgZWxtLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMCcpO1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcwJyk7XG4gIH07XG5cbiAgcmV0dXJuIEJydXNoVXBkYXRlcjtcbn0oKTtcblxudmFyIGJydXNoVXBkYXRlciA9IC8qI19fUFVSRV9fKi9uZXcgQnJ1c2hVcGRhdGVyKCk7XG52YXIgQnJ1c2ggPSAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyhmdW5jdGlvbiAoX3JlZikge1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xuICAgIHJlZjogYnJ1c2hVcGRhdGVyLnJlZixcbiAgICBjbGFzc05hbWU6IFwidGwtYnJ1c2hcIixcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH0pO1xufSwgLy8gT25jZSB0aGUgYnJ1c2ggaXMgY29udHJvbGxlZCwgbmV2ZXIgdXBkYXRlIGFnYWluIGZyb20gcHJvcHNcbmZ1bmN0aW9uIChwcmV2LCBuZXh0KSB7XG4gIHJldHVybiB0cnVlO1xufSk7XG5cbmZ1bmN0aW9uIERlZnMoX3JlZikge1xuICB2YXIgem9vbSA9IF9yZWYuem9vbTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkZWZzXCIsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIiwge1xuICAgIGlkOiBcImRvdFwiLFxuICAgIGNsYXNzTmFtZTogXCJ0bC1jb3VudGVyLXNjYWxlZCB0bC1kb3RcIixcbiAgICByOiA0XG4gIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIsIHtcbiAgICBpZDogXCJoYW5kbGVcIixcbiAgICBjbGFzc05hbWU6IFwidGwtY291bnRlci1zY2FsZWQgdGwtaGFuZGxlXCIsXG4gICAgcjogNFxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIiwge1xuICAgIGlkOiBcImNyb3NzXCIsXG4gICAgY2xhc3NOYW1lOiBcInRsLWJpbmRpbmctaW5kaWNhdG9yXCJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmVcIiwge1xuICAgIHgxOiAtNixcbiAgICB5MTogLTYsXG4gICAgeDI6IDYsXG4gICAgeTI6IDZcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIsIHtcbiAgICB4MTogNixcbiAgICB5MTogLTYsXG4gICAgeDI6IC02LFxuICAgIHkyOiA2XG4gIH0pKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImZpbHRlclwiLCB7XG4gICAgaWQ6IFwiZXhwYW5kXCJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImZlTW9ycGhvbG9neVwiLCB7XG4gICAgb3BlcmF0b3I6IFwiZGlsYXRlXCIsXG4gICAgcmFkaXVzOiAwLjUgLyB6b29tXG4gIH0pKSk7XG59XG5cbnZhciBSZW5kZXJlZFNoYXBlID0gLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oZnVuY3Rpb24gUmVuZGVyZWRTaGFwZShfcmVmKSB7XG4gIHZhciBzaGFwZSA9IF9yZWYuc2hhcGUsXG4gICAgICB1dGlscyA9IF9yZWYudXRpbHMsXG4gICAgICBpc0VkaXRpbmcgPSBfcmVmLmlzRWRpdGluZyxcbiAgICAgIGlzSG92ZXJlZCA9IF9yZWYuaXNIb3ZlcmVkLFxuICAgICAgaXNCaW5kaW5nID0gX3JlZi5pc0JpbmRpbmcsXG4gICAgICBpc1NlbGVjdGVkID0gX3JlZi5pc1NlbGVjdGVkLFxuICAgICAgaXNEYXJrTW9kZSA9IF9yZWYuaXNEYXJrTW9kZSxcbiAgICAgIGlzQ3VycmVudFBhcmVudCA9IF9yZWYuaXNDdXJyZW50UGFyZW50O1xuICByZXR1cm4gdXRpbHMucmVuZGVyKHNoYXBlLCB7XG4gICAgaXNFZGl0aW5nOiBpc0VkaXRpbmcsXG4gICAgaXNIb3ZlcmVkOiBpc0hvdmVyZWQsXG4gICAgaXNTZWxlY3RlZDogaXNTZWxlY3RlZCxcbiAgICBpc0JpbmRpbmc6IGlzQmluZGluZyxcbiAgICBpc0RhcmtNb2RlOiBpc0RhcmtNb2RlLFxuICAgIGlzQ3VycmVudFBhcmVudDogaXNDdXJyZW50UGFyZW50XG4gIH0pO1xufSwgZnVuY3Rpb24gKHByZXYsIG5leHQpIHtcbiAgaWYgKHByZXYuaXNFZGl0aW5nICE9PSBuZXh0LmlzRWRpdGluZyB8fCBwcmV2LmlzSG92ZXJlZCAhPT0gbmV4dC5pc0hvdmVyZWQgfHwgcHJldi5pc1NlbGVjdGVkICE9PSBuZXh0LmlzU2VsZWN0ZWQgfHwgcHJldi5pc0RhcmtNb2RlICE9PSBuZXh0LmlzRGFya01vZGUgfHwgcHJldi5pc0JpbmRpbmcgIT09IG5leHQuaXNCaW5kaW5nIHx8IHByZXYuaXNDdXJyZW50UGFyZW50ICE9PSBuZXh0LmlzQ3VycmVudFBhcmVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChuZXh0LnNoYXBlICE9PSBwcmV2LnNoYXBlKSB7XG4gICAgcmV0dXJuICFuZXh0LnV0aWxzLnNob3VsZFJlbmRlcihuZXh0LnNoYXBlLCBwcmV2LnNoYXBlKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufSk7XG5cbmZ1bmN0aW9uIEVkaXRpbmdUZXh0U2hhcGUoX3JlZikge1xuICB2YXIgc2hhcGUgPSBfcmVmLnNoYXBlLFxuICAgICAgdXRpbHMgPSBfcmVmLnV0aWxzLFxuICAgICAgaXNFZGl0aW5nID0gX3JlZi5pc0VkaXRpbmcsXG4gICAgICBpc0hvdmVyZWQgPSBfcmVmLmlzSG92ZXJlZCxcbiAgICAgIGlzQmluZGluZyA9IF9yZWYuaXNCaW5kaW5nLFxuICAgICAgaXNTZWxlY3RlZCA9IF9yZWYuaXNTZWxlY3RlZCxcbiAgICAgIGlzRGFya01vZGUgPSBfcmVmLmlzRGFya01vZGUsXG4gICAgICBpc0N1cnJlbnRQYXJlbnQgPSBfcmVmLmlzQ3VycmVudFBhcmVudDtcbiAgdmFyIHJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgcmV0dXJuIHV0aWxzLnJlbmRlcihzaGFwZSwge1xuICAgIHJlZjogcmVmLFxuICAgIGlzRWRpdGluZzogaXNFZGl0aW5nLFxuICAgIGlzSG92ZXJlZDogaXNIb3ZlcmVkLFxuICAgIGlzU2VsZWN0ZWQ6IGlzU2VsZWN0ZWQsXG4gICAgaXNDdXJyZW50UGFyZW50OiBpc0N1cnJlbnRQYXJlbnQsXG4gICAgaXNCaW5kaW5nOiBpc0JpbmRpbmcsXG4gICAgaXNEYXJrTW9kZTogaXNEYXJrTW9kZVxuICB9KTtcbn1cblxudmFyIFNoYXBlID0gLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHNoYXBlID0gX3JlZi5zaGFwZSxcbiAgICAgIGlzRWRpdGluZyA9IF9yZWYuaXNFZGl0aW5nLFxuICAgICAgaXNIb3ZlcmVkID0gX3JlZi5pc0hvdmVyZWQsXG4gICAgICBpc1NlbGVjdGVkID0gX3JlZi5pc1NlbGVjdGVkLFxuICAgICAgaXNCaW5kaW5nID0gX3JlZi5pc0JpbmRpbmcsXG4gICAgICBpc0RhcmtNb2RlID0gX3JlZi5pc0RhcmtNb2RlLFxuICAgICAgaXNDdXJyZW50UGFyZW50ID0gX3JlZi5pc0N1cnJlbnRQYXJlbnQ7XG5cbiAgdmFyIF91c2VUTENvbnRleHQgPSB1c2VUTENvbnRleHQoKSxcbiAgICAgIHNoYXBlVXRpbHMgPSBfdXNlVExDb250ZXh0LnNoYXBlVXRpbHM7XG5cbiAgdmFyIGV2ZW50cyA9IHVzZVNoYXBlRXZlbnRzKHNoYXBlLmlkLCBpc0N1cnJlbnRQYXJlbnQpO1xuICB2YXIgdXRpbHMgPSBzaGFwZVV0aWxzW3NoYXBlLnR5cGVdO1xuICB2YXIgY2VudGVyID0gdXRpbHMuZ2V0Q2VudGVyKHNoYXBlKTtcbiAgdmFyIHJvdGF0aW9uID0gKHNoYXBlLnJvdGF0aW9uIHx8IDApICogKDE4MCAvIE1hdGguUEkpO1xuICB2YXIgdHJhbnNmb3JtID0gXCJyb3RhdGUoXCIgKyByb3RhdGlvbiArIFwiLCBcIiArIGNlbnRlciArIFwiKSB0cmFuc2xhdGUoXCIgKyBzaGFwZS5wb2ludCArIFwiKVwiO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIiwgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogaXNDdXJyZW50UGFyZW50ID8gJ3RsLXNoYXBlLWdyb3VwIHRsLWN1cnJlbnQtcGFyZW50JyA6ICd0bC1zaGFwZS1ncm91cCcsXG4gICAgaWQ6IHNoYXBlLmlkLFxuICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgIGZpbHRlcjogaXNIb3ZlcmVkID8gJ3VybCgjZXhwYW5kKScgOiAnbm9uZSdcbiAgfSwgZXZlbnRzKSwgaXNFZGl0aW5nICYmIHV0aWxzLmlzRWRpdGFibGVUZXh0ID8gUmVhY3QuY3JlYXRlRWxlbWVudChFZGl0aW5nVGV4dFNoYXBlLCB7XG4gICAgc2hhcGU6IHNoYXBlLFxuICAgIGlzQmluZGluZzogZmFsc2UsXG4gICAgaXNDdXJyZW50UGFyZW50OiBmYWxzZSxcbiAgICBpc0RhcmtNb2RlOiBpc0RhcmtNb2RlLFxuICAgIGlzRWRpdGluZzogdHJ1ZSxcbiAgICBpc0hvdmVyZWQ6IGZhbHNlLFxuICAgIGlzU2VsZWN0ZWQ6IGZhbHNlLFxuICAgIHV0aWxzOiB1dGlsc1xuICB9KSA6IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVuZGVyZWRTaGFwZSwge1xuICAgIHNoYXBlOiBzaGFwZSxcbiAgICB1dGlsczogdXRpbHMsXG4gICAgaXNCaW5kaW5nOiBpc0JpbmRpbmcsXG4gICAgaXNDdXJyZW50UGFyZW50OiBpc0N1cnJlbnRQYXJlbnQsXG4gICAgaXNEYXJrTW9kZTogaXNEYXJrTW9kZSxcbiAgICBpc0VkaXRpbmc6IGlzRWRpdGluZyxcbiAgICBpc0hvdmVyZWQ6IGlzSG92ZXJlZCxcbiAgICBpc1NlbGVjdGVkOiBpc1NlbGVjdGVkXG4gIH0pKTtcbn0pO1xuXG52YXIgQ2VudGVySGFuZGxlID0gLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGJvdW5kcyA9IF9yZWYuYm91bmRzLFxuICAgICAgaXNMb2NrZWQgPSBfcmVmLmlzTG9ja2VkO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xuICAgIGNsYXNzTmFtZTogaXNMb2NrZWQgPyAndGwtYm91bmRzLWNlbnRlciB0bC1kYXNoZWQnIDogJ3RsLWJvdW5kcy1jZW50ZXInLFxuICAgIHg6IC0xLFxuICAgIHk6IC0xLFxuICAgIHdpZHRoOiBib3VuZHMud2lkdGggKyAyLFxuICAgIGhlaWdodDogYm91bmRzLmhlaWdodCArIDIsXG4gICAgcG9pbnRlckV2ZW50czogXCJub25lXCJcbiAgfSk7XG59KTtcblxudmFyIFJvdGF0ZUhhbmRsZSA9IC8qI19fUFVSRV9fKi9SZWFjdC5tZW1vKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBib3VuZHMgPSBfcmVmLmJvdW5kcyxcbiAgICAgIHNpemUgPSBfcmVmLnNpemU7XG4gIHZhciBldmVudHMgPSB1c2VCb3VuZHNIYW5kbGVFdmVudHMoJ3JvdGF0ZScpO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIiwge1xuICAgIGN1cnNvcjogXCJncmFiXCJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImNpcmNsZVwiLCBfZXh0ZW5kcyh7XG4gICAgY3g6IGJvdW5kcy53aWR0aCAvIDIsXG4gICAgY3k6IHNpemUgKiAtMixcbiAgICByOiBzaXplICogMixcbiAgICBmaWxsOiBcInRyYW5zcGFyZW50XCIsXG4gICAgc3Ryb2tlOiBcIm5vbmVcIixcbiAgICBwb2ludGVyRXZlbnRzOiBcImFsbFwiXG4gIH0sIGV2ZW50cykpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIsIHtcbiAgICBjbGFzc05hbWU6IFwidGwtcm90YXRlLWhhbmRsZVwiLFxuICAgIGN4OiBib3VuZHMud2lkdGggLyAyLFxuICAgIGN5OiBzaXplICogLTIsXG4gICAgcjogc2l6ZSAvIDIsXG4gICAgcG9pbnRlckV2ZW50czogXCJub25lXCJcbiAgfSkpO1xufSk7XG5cbnZhciBfY29ybmVyQmdDbGFzc25hbWVzO1xudmFyIGNvcm5lckJnQ2xhc3NuYW1lcyA9IChfY29ybmVyQmdDbGFzc25hbWVzID0ge30sIF9jb3JuZXJCZ0NsYXNzbmFtZXNbZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Ub3BMZWZ0XSA9ICd0bC10cmFuc3BhcmVudCB0bC1jdXJzb3ItbndzZScsIF9jb3JuZXJCZ0NsYXNzbmFtZXNbZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Ub3BSaWdodF0gPSAndGwtdHJhbnNwYXJlbnQgdGwtY3Vyc29yLW5lc3cnLCBfY29ybmVyQmdDbGFzc25hbWVzW2V4cG9ydHMuVExCb3VuZHNDb3JuZXIuQm90dG9tUmlnaHRdID0gJ3RsLXRyYW5zcGFyZW50IHRsLWN1cnNvci1ud3NlJywgX2Nvcm5lckJnQ2xhc3NuYW1lc1tleHBvcnRzLlRMQm91bmRzQ29ybmVyLkJvdHRvbUxlZnRdID0gJ3RsLXRyYW5zcGFyZW50IHRsLWN1cnNvci1uZXN3JywgX2Nvcm5lckJnQ2xhc3NuYW1lcyk7XG52YXIgQ29ybmVySGFuZGxlID0gLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHNpemUgPSBfcmVmLnNpemUsXG4gICAgICBjb3JuZXIgPSBfcmVmLmNvcm5lcixcbiAgICAgIGJvdW5kcyA9IF9yZWYuYm91bmRzO1xuICB2YXIgZXZlbnRzID0gdXNlQm91bmRzSGFuZGxlRXZlbnRzKGNvcm5lcik7XG4gIHZhciBpc1RvcCA9IGNvcm5lciA9PT0gZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Ub3BMZWZ0IHx8IGNvcm5lciA9PT0gZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Ub3BSaWdodDtcbiAgdmFyIGlzTGVmdCA9IGNvcm5lciA9PT0gZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Ub3BMZWZ0IHx8IGNvcm5lciA9PT0gZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Cb3R0b21MZWZ0O1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIiwgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChcInJlY3RcIiwgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogY29ybmVyQmdDbGFzc25hbWVzW2Nvcm5lcl0sXG4gICAgeDogKGlzTGVmdCA/IC0xIDogYm91bmRzLndpZHRoICsgMSkgLSBzaXplLFxuICAgIHk6IChpc1RvcCA/IC0xIDogYm91bmRzLmhlaWdodCArIDEpIC0gc2l6ZSxcbiAgICB3aWR0aDogc2l6ZSAqIDIsXG4gICAgaGVpZ2h0OiBzaXplICogMixcbiAgICBwb2ludGVyRXZlbnRzOiBcImFsbFwiXG4gIH0sIGV2ZW50cykpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7XG4gICAgY2xhc3NOYW1lOiBcInRsLWNvcm5lci1oYW5kbGVcIixcbiAgICB4OiAoaXNMZWZ0ID8gLTEgOiBib3VuZHMud2lkdGggKyAxKSAtIHNpemUgLyAyLFxuICAgIHk6IChpc1RvcCA/IC0xIDogYm91bmRzLmhlaWdodCArIDEpIC0gc2l6ZSAvIDIsXG4gICAgd2lkdGg6IHNpemUsXG4gICAgaGVpZ2h0OiBzaXplLFxuICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiXG4gIH0pKTtcbn0pO1xuXG52YXIgX2VkZ2VDbGFzc25hbWVzO1xudmFyIGVkZ2VDbGFzc25hbWVzID0gKF9lZGdlQ2xhc3NuYW1lcyA9IHt9LCBfZWRnZUNsYXNzbmFtZXNbZXhwb3J0cy5UTEJvdW5kc0VkZ2UuVG9wXSA9ICd0bC10cmFuc3BhcmVudCB0bC1jdXJzb3ItbnMnLCBfZWRnZUNsYXNzbmFtZXNbZXhwb3J0cy5UTEJvdW5kc0VkZ2UuUmlnaHRdID0gJ3RsLXRyYW5zcGFyZW50IHRsLWN1cnNvci1ldycsIF9lZGdlQ2xhc3NuYW1lc1tleHBvcnRzLlRMQm91bmRzRWRnZS5Cb3R0b21dID0gJ3RsLXRyYW5zcGFyZW50IHRsLWN1cnNvci1ucycsIF9lZGdlQ2xhc3NuYW1lc1tleHBvcnRzLlRMQm91bmRzRWRnZS5MZWZ0XSA9ICd0bC10cmFuc3BhcmVudCB0bC1jdXJzb3ItZXcnLCBfZWRnZUNsYXNzbmFtZXMpO1xudmFyIEVkZ2VIYW5kbGUgPSAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyhmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgc2l6ZSA9IF9yZWYuc2l6ZSxcbiAgICAgIGJvdW5kcyA9IF9yZWYuYm91bmRzLFxuICAgICAgZWRnZSA9IF9yZWYuZWRnZTtcbiAgdmFyIGV2ZW50cyA9IHVzZUJvdW5kc0hhbmRsZUV2ZW50cyhlZGdlKTtcbiAgdmFyIGlzSG9yaXpvbnRhbCA9IGVkZ2UgPT09IGV4cG9ydHMuVExCb3VuZHNFZGdlLlRvcCB8fCBlZGdlID09PSBleHBvcnRzLlRMQm91bmRzRWRnZS5Cb3R0b207XG4gIHZhciBpc0ZhckVkZ2UgPSBlZGdlID09PSBleHBvcnRzLlRMQm91bmRzRWRnZS5SaWdodCB8fCBlZGdlID09PSBleHBvcnRzLlRMQm91bmRzRWRnZS5Cb3R0b207XG4gIHZhciBoZWlnaHQgPSBib3VuZHMuaGVpZ2h0LFxuICAgICAgd2lkdGggPSBib3VuZHMud2lkdGg7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCBfZXh0ZW5kcyh7XG4gICAgY2xhc3NOYW1lOiBlZGdlQ2xhc3NuYW1lc1tlZGdlXSxcbiAgICB4OiBpc0hvcml6b250YWwgPyBzaXplIC8gMiA6IChpc0ZhckVkZ2UgPyB3aWR0aCArIDEgOiAtMSkgLSBzaXplIC8gMixcbiAgICB5OiBpc0hvcml6b250YWwgPyAoaXNGYXJFZGdlID8gaGVpZ2h0ICsgMSA6IC0xKSAtIHNpemUgLyAyIDogc2l6ZSAvIDIsXG4gICAgd2lkdGg6IGlzSG9yaXpvbnRhbCA/IE1hdGgubWF4KDAsIHdpZHRoICsgMSAtIHNpemUpIDogc2l6ZSxcbiAgICBoZWlnaHQ6IGlzSG9yaXpvbnRhbCA/IHNpemUgOiBNYXRoLm1heCgwLCBoZWlnaHQgKyAxIC0gc2l6ZSlcbiAgfSwgZXZlbnRzKSk7XG59KTtcblxuZnVuY3Rpb24gQm91bmRzKF9yZWYpIHtcbiAgdmFyIHpvb20gPSBfcmVmLnpvb20sXG4gICAgICBib3VuZHMgPSBfcmVmLmJvdW5kcyxcbiAgICAgIHJvdGF0aW9uID0gX3JlZi5yb3RhdGlvbixcbiAgICAgIGlzTG9ja2VkID0gX3JlZi5pc0xvY2tlZDtcbiAgdmFyIHNpemUgPSAoVXRpbHMuaXNNb2JpbGUoKSA/IDEwIDogOCkgLyB6b29tOyAvLyBUb3VjaCB0YXJnZXQgc2l6ZVxuXG4gIHZhciBjZW50ZXIgPSBVdGlscy5nZXRCb3VuZHNDZW50ZXIoYm91bmRzKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHtcbiAgICBwb2ludGVyRXZlbnRzOiBcImFsbFwiLFxuICAgIHRyYW5zZm9ybTogXCJcXG4gICAgICAgIHJvdGF0ZShcIiArIHJvdGF0aW9uICogKDE4MCAvIE1hdGguUEkpICsgXCIsXCIgKyBjZW50ZXIgKyBcIilcXG4gICAgICAgIHRyYW5zbGF0ZShcIiArIGJvdW5kcy5taW5YICsgXCIsXCIgKyBib3VuZHMubWluWSArIFwiKVxcbiAgICAgICAgcm90YXRlKFwiICsgKGJvdW5kcy5yb3RhdGlvbiB8fCAwKSAqICgxODAgLyBNYXRoLlBJKSArIFwiLCAwLCAwKVwiXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2VudGVySGFuZGxlLCB7XG4gICAgYm91bmRzOiBib3VuZHMsXG4gICAgaXNMb2NrZWQ6IGlzTG9ja2VkXG4gIH0pLCAhaXNMb2NrZWQgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChFZGdlSGFuZGxlLCB7XG4gICAgc2l6ZTogc2l6ZSxcbiAgICBib3VuZHM6IGJvdW5kcyxcbiAgICBlZGdlOiBleHBvcnRzLlRMQm91bmRzRWRnZS5Ub3BcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRWRnZUhhbmRsZSwge1xuICAgIHNpemU6IHNpemUsXG4gICAgYm91bmRzOiBib3VuZHMsXG4gICAgZWRnZTogZXhwb3J0cy5UTEJvdW5kc0VkZ2UuUmlnaHRcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRWRnZUhhbmRsZSwge1xuICAgIHNpemU6IHNpemUsXG4gICAgYm91bmRzOiBib3VuZHMsXG4gICAgZWRnZTogZXhwb3J0cy5UTEJvdW5kc0VkZ2UuQm90dG9tXG4gIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KEVkZ2VIYW5kbGUsIHtcbiAgICBzaXplOiBzaXplLFxuICAgIGJvdW5kczogYm91bmRzLFxuICAgIGVkZ2U6IGV4cG9ydHMuVExCb3VuZHNFZGdlLkxlZnRcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29ybmVySGFuZGxlLCB7XG4gICAgc2l6ZTogc2l6ZSxcbiAgICBib3VuZHM6IGJvdW5kcyxcbiAgICBjb3JuZXI6IGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuVG9wTGVmdFxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChDb3JuZXJIYW5kbGUsIHtcbiAgICBzaXplOiBzaXplLFxuICAgIGJvdW5kczogYm91bmRzLFxuICAgIGNvcm5lcjogZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Ub3BSaWdodFxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChDb3JuZXJIYW5kbGUsIHtcbiAgICBzaXplOiBzaXplLFxuICAgIGJvdW5kczogYm91bmRzLFxuICAgIGNvcm5lcjogZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Cb3R0b21SaWdodFxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChDb3JuZXJIYW5kbGUsIHtcbiAgICBzaXplOiBzaXplLFxuICAgIGJvdW5kczogYm91bmRzLFxuICAgIGNvcm5lcjogZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Cb3R0b21MZWZ0XG4gIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdGF0ZUhhbmRsZSwge1xuICAgIHNpemU6IHNpemUsXG4gICAgYm91bmRzOiBib3VuZHNcbiAgfSkpKTtcbn1cblxuZnVuY3Rpb24gdXNlQm91bmRzRXZlbnRzKCkge1xuICB2YXIgX3VzZVRMQ29udGV4dCA9IHVzZVRMQ29udGV4dCgpLFxuICAgICAgY2FsbGJhY2tzID0gX3VzZVRMQ29udGV4dC5jYWxsYmFja3M7XG5cbiAgdmFyIG9uUG9pbnRlckRvd24gPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xuICAgIHZhciBfZSRjdXJyZW50VGFyZ2V0O1xuXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAoX2UkY3VycmVudFRhcmdldCA9IGUuY3VycmVudFRhcmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lJGN1cnJlbnRUYXJnZXQuc2V0UG9pbnRlckNhcHR1cmUoZS5wb2ludGVySWQpO1xuICAgIHZhciBpbmZvID0gaW5wdXRzLnBvaW50ZXJEb3duKGUsICdib3VuZHMnKTtcbiAgICBjYWxsYmFja3Mub25Qb2ludEJvdW5kcyA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uUG9pbnRCb3VuZHMoaW5mbywgZSk7XG4gICAgY2FsbGJhY2tzLm9uUG9pbnRlckRvd24gPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vblBvaW50ZXJEb3duKGluZm8sIGUpO1xuICB9LCBbY2FsbGJhY2tzXSk7XG4gIHZhciBvblBvaW50ZXJVcCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB2YXIgaXNEb3VibGVDbGljayA9IGlucHV0cy5pc0RvdWJsZUNsaWNrKCk7XG4gICAgdmFyIGluZm8gPSBpbnB1dHMucG9pbnRlclVwKGUsICdib3VuZHMnKTtcblxuICAgIGlmIChlLmN1cnJlbnRUYXJnZXQuaGFzUG9pbnRlckNhcHR1cmUoZS5wb2ludGVySWQpKSB7XG4gICAgICB2YXIgX2UkY3VycmVudFRhcmdldDI7XG5cbiAgICAgIChfZSRjdXJyZW50VGFyZ2V0MiA9IGUuY3VycmVudFRhcmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lJGN1cnJlbnRUYXJnZXQyLnJlbGVhc2VQb2ludGVyQ2FwdHVyZShlLnBvaW50ZXJJZCk7XG4gICAgfVxuXG4gICAgaWYgKGlzRG91YmxlQ2xpY2sgJiYgIShpbmZvLmFsdEtleSB8fCBpbmZvLm1ldGFLZXkpKSB7XG4gICAgICBjYWxsYmFja3Mub25Eb3VibGVDbGlja0JvdW5kcyA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uRG91YmxlQ2xpY2tCb3VuZHMoaW5mbywgZSk7XG4gICAgfVxuXG4gICAgY2FsbGJhY2tzLm9uUmVsZWFzZUJvdW5kcyA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uUmVsZWFzZUJvdW5kcyhpbmZvLCBlKTtcbiAgICBjYWxsYmFja3Mub25Qb2ludGVyVXAgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vblBvaW50ZXJVcChpbmZvLCBlKTtcbiAgfSwgW2NhbGxiYWNrc10pO1xuICB2YXIgb25Qb2ludGVyTW92ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBpZiAoaW5wdXRzLnBvaW50ZXIgJiYgZS5wb2ludGVySWQgIT09IGlucHV0cy5wb2ludGVyLnBvaW50ZXJJZCkgcmV0dXJuO1xuXG4gICAgaWYgKGUuY3VycmVudFRhcmdldC5oYXNQb2ludGVyQ2FwdHVyZShlLnBvaW50ZXJJZCkpIHtcbiAgICAgIGNhbGxiYWNrcy5vbkRyYWdCb3VuZHMgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vbkRyYWdCb3VuZHMoaW5wdXRzLnBvaW50ZXJNb3ZlKGUsICdib3VuZHMnKSwgZSk7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSBpbnB1dHMucG9pbnRlck1vdmUoZSwgJ2JvdW5kcycpO1xuICAgIGNhbGxiYWNrcy5vblBvaW50ZXJNb3ZlID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25Qb2ludGVyTW92ZShpbmZvLCBlKTtcbiAgfSwgW2NhbGxiYWNrc10pO1xuICB2YXIgb25Qb2ludGVyRW50ZXIgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xuICAgIGNhbGxiYWNrcy5vbkhvdmVyQm91bmRzID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25Ib3ZlckJvdW5kcyhpbnB1dHMucG9pbnRlckVudGVyKGUsICdib3VuZHMnKSwgZSk7XG4gIH0sIFtjYWxsYmFja3NdKTtcbiAgdmFyIG9uUG9pbnRlckxlYXZlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGUpIHtcbiAgICBjYWxsYmFja3Mub25VbmhvdmVyQm91bmRzID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25VbmhvdmVyQm91bmRzKGlucHV0cy5wb2ludGVyRW50ZXIoZSwgJ2JvdW5kcycpLCBlKTtcbiAgfSwgW2NhbGxiYWNrc10pO1xuICB2YXIgb25Ub3VjaFN0YXJ0ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0sIFtdKTtcbiAgdmFyIG9uVG91Y2hFbmQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSwgW10pO1xuICByZXR1cm4ge1xuICAgIG9uUG9pbnRlckRvd246IG9uUG9pbnRlckRvd24sXG4gICAgb25Qb2ludGVyVXA6IG9uUG9pbnRlclVwLFxuICAgIG9uUG9pbnRlckVudGVyOiBvblBvaW50ZXJFbnRlcixcbiAgICBvblBvaW50ZXJNb3ZlOiBvblBvaW50ZXJNb3ZlLFxuICAgIG9uUG9pbnRlckxlYXZlOiBvblBvaW50ZXJMZWF2ZSxcbiAgICBvblRvdWNoU3RhcnQ6IG9uVG91Y2hTdGFydCxcbiAgICBvblRvdWNoRW5kOiBvblRvdWNoRW5kXG4gIH07XG59XG5cbmZ1bmN0aW9uIEJvdW5kc0JnKF9yZWYpIHtcbiAgdmFyIGJvdW5kcyA9IF9yZWYuYm91bmRzLFxuICAgICAgcm90YXRpb24gPSBfcmVmLnJvdGF0aW9uO1xuICB2YXIgZXZlbnRzID0gdXNlQm91bmRzRXZlbnRzKCk7XG4gIHZhciB3aWR0aCA9IGJvdW5kcy53aWR0aCxcbiAgICAgIGhlaWdodCA9IGJvdW5kcy5oZWlnaHQ7XG4gIHZhciBjZW50ZXIgPSBVdGlscy5nZXRCb3VuZHNDZW50ZXIoYm91bmRzKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIsIF9leHRlbmRzKHtcbiAgICBjbGFzc05hbWU6IFwidGwtYm91bmRzLWJnXCIsXG4gICAgd2lkdGg6IE1hdGgubWF4KDEsIHdpZHRoKSxcbiAgICBoZWlnaHQ6IE1hdGgubWF4KDEsIGhlaWdodCksXG4gICAgdHJhbnNmb3JtOiBcIlxcbiAgICAgICAgcm90YXRlKFwiICsgcm90YXRpb24gKiAoMTgwIC8gTWF0aC5QSSkgKyBcIixcIiArIGNlbnRlciArIFwiKVxcbiAgICAgICAgdHJhbnNsYXRlKFwiICsgYm91bmRzLm1pblggKyBcIixcIiArIGJvdW5kcy5taW5ZICsgXCIpXFxuICAgICAgICByb3RhdGUoXCIgKyAoYm91bmRzLnJvdGF0aW9uIHx8IDApICogKDE4MCAvIE1hdGguUEkpICsgXCIsIDAsIDApXCJcbiAgfSwgZXZlbnRzKSk7XG59XG5cbnZhciBIYW5kbGUgPSAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyhmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgaWQgPSBfcmVmLmlkLFxuICAgICAgcG9pbnQgPSBfcmVmLnBvaW50O1xuICB2YXIgZXZlbnRzID0gdXNlSGFuZGxlRXZlbnRzKGlkKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJnXCIsIF9leHRlbmRzKHtcbiAgICBjbGFzc05hbWU6IFwiaGFuZGxlc1wiLFxuICAgIHBvaW50ZXJFdmVudHM6IFwiYWxsXCIsXG4gICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIiArIHBvaW50ICsgXCIpXCJcbiAgfSwgZXZlbnRzKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImNpcmNsZVwiLCB7XG4gICAgY2xhc3NOYW1lOiBcInRsLWhhbmRsZS1iZ1wiLFxuICAgIHI6IDEyXG4gIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwidXNlXCIsIHtcbiAgICBocmVmOiBcIiNoYW5kbGVcIixcbiAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIlxuICB9KSk7XG59KTtcblxudmFyIHRvQW5nbGUgPSAxODAgLyBNYXRoLlBJO1xudmFyIEhhbmRsZXMgPSAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyhmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgc2hhcGUgPSBfcmVmLnNoYXBlO1xuXG4gIHZhciBfdXNlVExDb250ZXh0ID0gdXNlVExDb250ZXh0KCksXG4gICAgICBzaGFwZVV0aWxzID0gX3VzZVRMQ29udGV4dC5zaGFwZVV0aWxzO1xuXG4gIHZhciBjZW50ZXIgPSBzaGFwZVV0aWxzW3NoYXBlLnR5cGVdLmdldENlbnRlcihzaGFwZSk7XG5cbiAgaWYgKHNoYXBlLmhhbmRsZXMgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHtcbiAgICB0cmFuc2Zvcm06IFwicm90YXRlKFwiICsgKHNoYXBlLnJvdGF0aW9uIHx8IDApICogdG9BbmdsZSArIFwiLFwiICsgY2VudGVyICsgXCIpXCJcbiAgfSwgT2JqZWN0LnZhbHVlcyhzaGFwZS5oYW5kbGVzKS5tYXAoZnVuY3Rpb24gKGhhbmRsZSkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEhhbmRsZSwge1xuICAgICAga2V5OiBzaGFwZS5pZCArICdfJyArIGhhbmRsZS5pZCxcbiAgICAgIGlkOiBoYW5kbGUuaWQsXG4gICAgICBwb2ludDogVmVjLmFkZChoYW5kbGUucG9pbnQsIHNoYXBlLnBvaW50KVxuICAgIH0pO1xuICB9KSk7XG59KTtcblxuZnVuY3Rpb24gUGFnZShfcmVmKSB7XG4gIHZhciBwYWdlID0gX3JlZi5wYWdlLFxuICAgICAgcGFnZVN0YXRlID0gX3JlZi5wYWdlU3RhdGUsXG4gICAgICBoaWRlQm91bmRzID0gX3JlZi5oaWRlQm91bmRzO1xuXG4gIHZhciBfdXNlVExDb250ZXh0ID0gdXNlVExDb250ZXh0KCksXG4gICAgICBjYWxsYmFja3MgPSBfdXNlVExDb250ZXh0LmNhbGxiYWNrcyxcbiAgICAgIHNoYXBlVXRpbHMgPSBfdXNlVExDb250ZXh0LnNoYXBlVXRpbHM7XG5cbiAgdXNlUmVuZGVyT25SZXNpemUoKTtcbiAgdmFyIHNoYXBlVHJlZSA9IHVzZVNoYXBlVHJlZShwYWdlLCBwYWdlU3RhdGUsIHNoYXBlVXRpbHMsIHBhZ2VTdGF0ZSwgY2FsbGJhY2tzLm9uQ2hhbmdlKTtcblxuICB2YXIgX3VzZUhhbmRsZXMgPSB1c2VIYW5kbGVzKHBhZ2UsIHBhZ2VTdGF0ZSksXG4gICAgICBzaGFwZVdpdGhIYW5kbGVzID0gX3VzZUhhbmRsZXMuc2hhcGVXaXRoSGFuZGxlcztcblxuICB2YXIgX3VzZVNlbGVjdGlvbiA9IHVzZVNlbGVjdGlvbihwYWdlLCBwYWdlU3RhdGUsIHNoYXBlVXRpbHMpLFxuICAgICAgYm91bmRzID0gX3VzZVNlbGVjdGlvbi5ib3VuZHMsXG4gICAgICBpc0xvY2tlZCA9IF91c2VTZWxlY3Rpb24uaXNMb2NrZWQsXG4gICAgICByb3RhdGlvbiA9IF91c2VTZWxlY3Rpb24ucm90YXRpb247XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGJvdW5kcyAmJiAhaGlkZUJvdW5kcyAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KEJvdW5kc0JnLCB7XG4gICAgYm91bmRzOiBib3VuZHMsXG4gICAgcm90YXRpb246IHJvdGF0aW9uXG4gIH0pLCBzaGFwZVRyZWUubWFwKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2hhcGVOb2RlLCBfZXh0ZW5kcyh7XG4gICAgICBrZXk6IG5vZGUuc2hhcGUuaWQsXG4gICAgICBhbGxvd0hvdmVyczogdHJ1ZVxuICAgIH0sIG5vZGUpKTtcbiAgfSksIGJvdW5kcyAmJiAhaGlkZUJvdW5kcyAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KEJvdW5kcywge1xuICAgIHpvb206IHBhZ2VTdGF0ZS5jYW1lcmEuem9vbSxcbiAgICBib3VuZHM6IGJvdW5kcyxcbiAgICBpc0xvY2tlZDogaXNMb2NrZWQsXG4gICAgcm90YXRpb246IHJvdGF0aW9uXG4gIH0pLCBzaGFwZVdpdGhIYW5kbGVzICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSGFuZGxlcywge1xuICAgIHNoYXBlOiBzaGFwZVdpdGhIYW5kbGVzXG4gIH0pKTtcbn1cbnZhciBTaGFwZU5vZGUgPSAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyhmdW5jdGlvbiAoX3JlZjIpIHtcbiAgdmFyIHNoYXBlID0gX3JlZjIuc2hhcGUsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYyLmNoaWxkcmVuLFxuICAgICAgaXNFZGl0aW5nID0gX3JlZjIuaXNFZGl0aW5nLFxuICAgICAgaXNIb3ZlcmVkID0gX3JlZjIuaXNIb3ZlcmVkLFxuICAgICAgaXNEYXJrTW9kZSA9IF9yZWYyLmlzRGFya01vZGUsXG4gICAgICBpc1NlbGVjdGVkID0gX3JlZjIuaXNTZWxlY3RlZCxcbiAgICAgIGlzQmluZGluZyA9IF9yZWYyLmlzQmluZGluZyxcbiAgICAgIGlzQ3VycmVudFBhcmVudCA9IF9yZWYyLmlzQ3VycmVudFBhcmVudCxcbiAgICAgIGFsbG93SG92ZXJzID0gX3JlZjIuYWxsb3dIb3ZlcnM7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBSZWFjdC5jcmVhdGVFbGVtZW50KFNoYXBlLCB7XG4gICAgc2hhcGU6IHNoYXBlLFxuICAgIGlzRWRpdGluZzogaXNFZGl0aW5nLFxuICAgIGlzSG92ZXJlZDogYWxsb3dIb3ZlcnMgJiYgaXNIb3ZlcmVkLFxuICAgIGlzU2VsZWN0ZWQ6IGlzU2VsZWN0ZWQsXG4gICAgaXNEYXJrTW9kZTogaXNEYXJrTW9kZSxcbiAgICBpc0JpbmRpbmc6IGlzQmluZGluZyxcbiAgICBpc0N1cnJlbnRQYXJlbnQ6IGlzQ3VycmVudFBhcmVudFxuICB9KSwgY2hpbGRyZW4gJiYgY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZE5vZGUpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChTaGFwZU5vZGUsIF9leHRlbmRzKHtcbiAgICAgIGtleTogY2hpbGROb2RlLnNoYXBlLmlkLFxuICAgICAgYWxsb3dIb3ZlcnM6IGFsbG93SG92ZXJzXG4gICAgfSwgY2hpbGROb2RlKSk7XG4gIH0pKTtcbn0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnQgKi9cbmZ1bmN0aW9uIHVzZVByZXZlbnROYXZpZ2F0aW9uKHJDYW52YXMpIHtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJldmVudEdlc3R1cmVOYXZpZ2F0aW9uID0gZnVuY3Rpb24gcHJldmVudEdlc3R1cmVOYXZpZ2F0aW9uKGV2ZW50KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG5cbiAgICB2YXIgcHJldmVudE5hdmlnYXRpb24gPSBmdW5jdGlvbiBwcmV2ZW50TmF2aWdhdGlvbihldmVudCkge1xuICAgICAgLy8gQ2VudGVyIHBvaW50IG9mIHRoZSB0b3VjaCBhcmVhXG4gICAgICB2YXIgdG91Y2hYUG9zaXRpb24gPSBldmVudC50b3VjaGVzWzBdLnBhZ2VYOyAvLyBTaXplIG9mIHRoZSB0b3VjaCBhcmVhXG5cbiAgICAgIHZhciB0b3VjaFhSYWRpdXMgPSBldmVudC50b3VjaGVzWzBdLnJhZGl1c1ggfHwgMDsgLy8gV2Ugc2V0IGEgdGhyZXNob2xkICgxMHB4KSBvbiBib3RoIHNpemVzIG9mIHRoZSBzY3JlZW4sXG4gICAgICAvLyBpZiB0aGUgdG91Y2ggYXJlYSBvdmVybGFwcyB3aXRoIHRoZSBzY3JlZW4gZWRnZXNcbiAgICAgIC8vIGl0J3MgbGlrZWx5IHRvIHRyaWdnZXIgdGhlIG5hdmlnYXRpb24uIFdlIHByZXZlbnQgdGhlXG4gICAgICAvLyB0b3VjaHN0YXJ0IGV2ZW50IGluIHRoYXQgY2FzZS5cblxuICAgICAgaWYgKHRvdWNoWFBvc2l0aW9uIC0gdG91Y2hYUmFkaXVzIDwgMTAgfHwgdG91Y2hYUG9zaXRpb24gKyB0b3VjaFhSYWRpdXMgPiB3aW5kb3cuaW5uZXJXaWR0aCAtIDEwKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBlbG0gPSByQ2FudmFzLmN1cnJlbnQ7XG4gICAgaWYgKCFlbG0pIHJldHVybjtcbiAgICBlbG0uYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHByZXZlbnRHZXN0dXJlTmF2aWdhdGlvbik7IC8vIEB0cy1pZ25vcmVcblxuICAgIGVsbS5hZGRFdmVudExpc3RlbmVyKCdnZXN0dXJlZW5kJywgcHJldmVudEdlc3R1cmVOYXZpZ2F0aW9uKTsgLy8gQHRzLWlnbm9yZVxuXG4gICAgZWxtLmFkZEV2ZW50TGlzdGVuZXIoJ2dlc3R1cmVjaGFuZ2UnLCBwcmV2ZW50R2VzdHVyZU5hdmlnYXRpb24pOyAvLyBAdHMtaWdub3JlXG5cbiAgICBlbG0uYWRkRXZlbnRMaXN0ZW5lcignZ2VzdHVyZXN0YXJ0JywgcHJldmVudEdlc3R1cmVOYXZpZ2F0aW9uKTsgLy8gQHRzLWlnbm9yZVxuXG4gICAgZWxtLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBwcmV2ZW50TmF2aWdhdGlvbik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChlbG0pIHtcbiAgICAgICAgZWxtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBwcmV2ZW50R2VzdHVyZU5hdmlnYXRpb24pOyAvLyBAdHMtaWdub3JlXG5cbiAgICAgICAgZWxtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2dlc3R1cmVlbmQnLCBwcmV2ZW50R2VzdHVyZU5hdmlnYXRpb24pOyAvLyBAdHMtaWdub3JlXG5cbiAgICAgICAgZWxtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2dlc3R1cmVjaGFuZ2UnLCBwcmV2ZW50R2VzdHVyZU5hdmlnYXRpb24pOyAvLyBAdHMtaWdub3JlXG5cbiAgICAgICAgZWxtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2dlc3R1cmVzdGFydCcsIHByZXZlbnRHZXN0dXJlTmF2aWdhdGlvbik7IC8vIEB0cy1pZ25vcmVcblxuICAgICAgICBlbG0ucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHByZXZlbnROYXZpZ2F0aW9uKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbckNhbnZhc10pO1xufVxuXG5mdW5jdGlvbiByZXNldEVycm9yKCkge1xufVxuXG52YXIgQ2FudmFzID0gLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oZnVuY3Rpb24gQ2FudmFzKF9yZWYpIHtcbiAgdmFyIHBhZ2UgPSBfcmVmLnBhZ2UsXG4gICAgICBwYWdlU3RhdGUgPSBfcmVmLnBhZ2VTdGF0ZSxcbiAgICAgIF9yZWYkaGlkZUJvdW5kcyA9IF9yZWYuaGlkZUJvdW5kcyxcbiAgICAgIGhpZGVCb3VuZHMgPSBfcmVmJGhpZGVCb3VuZHMgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRoaWRlQm91bmRzO1xuICB2YXIgckNhbnZhcyA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdmFyIHJHcm91cCA9IHVzZUNhbWVyYUNzcyhwYWdlU3RhdGUpO1xuICB1c2Vab29tRXZlbnRzKCk7XG4gIHVzZVNhZmFyaUZvY3VzT3V0Rml4KCk7XG4gIHVzZVByZXZlbnROYXZpZ2F0aW9uKHJDYW52YXMpO1xuICB2YXIgZXZlbnRzID0gdXNlQ2FudmFzRXZlbnRzKCk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IFwidGwtY29udGFpbmVyXCJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCBfZXh0ZW5kcyh7XG4gICAgaWQ6IFwiY2FudmFzXCIsXG4gICAgY2xhc3NOYW1lOiBcInRsLWNhbnZhc1wiLFxuICAgIHJlZjogckNhbnZhc1xuICB9LCBldmVudHMpLCBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0RXJyb3JCb3VuZGFyeS5FcnJvckJvdW5kYXJ5LCB7XG4gICAgRmFsbGJhY2tDb21wb25lbnQ6IEVycm9yRmFsbGJhY2ssXG4gICAgb25SZXNldDogcmVzZXRFcnJvclxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KERlZnMsIHtcbiAgICB6b29tOiBwYWdlU3RhdGUuY2FtZXJhLnpvb21cbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHtcbiAgICByZWY6IHJHcm91cCxcbiAgICBpZDogXCJ0bC1zaGFwZXNcIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFBhZ2UsIHtcbiAgICBwYWdlOiBwYWdlLFxuICAgIHBhZ2VTdGF0ZTogcGFnZVN0YXRlLFxuICAgIGhpZGVCb3VuZHM6IGhpZGVCb3VuZHNcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQnJ1c2gsIG51bGwpKSkpKTtcbn0pO1xuXG52YXIgX2V4Y2x1ZGVkID0gW1wic2hhcGVVdGlsc1wiLCBcInBhZ2VcIiwgXCJwYWdlU3RhdGVcIiwgXCJ0aGVtZVwiLCBcImhpZGVCb3VuZHNcIiwgXCJpc0RhcmtNb2RlXCIsIFwiaXNEZWJ1Z01vZGVcIiwgXCJpc1Blbk1vZGVcIl07XG5mdW5jdGlvbiBSZW5kZXJlcihfcmVmKSB7XG4gIHZhciBzaGFwZVV0aWxzID0gX3JlZi5zaGFwZVV0aWxzLFxuICAgICAgcGFnZSA9IF9yZWYucGFnZSxcbiAgICAgIHBhZ2VTdGF0ZSA9IF9yZWYucGFnZVN0YXRlLFxuICAgICAgdGhlbWUgPSBfcmVmLnRoZW1lLFxuICAgICAgX3JlZiRoaWRlQm91bmRzID0gX3JlZi5oaWRlQm91bmRzLFxuICAgICAgaGlkZUJvdW5kcyA9IF9yZWYkaGlkZUJvdW5kcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJGhpZGVCb3VuZHMsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgX2V4Y2x1ZGVkKTtcblxuICB1c2VUTFRoZW1lKHRoZW1lKTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjYWxsYmFja3M6IHJlc3QsXG4gICAgICBzaGFwZVV0aWxzOiBzaGFwZVV0aWxzXG4gICAgfTtcbiAgfSksXG4gICAgICBjb250ZXh0ID0gX1JlYWN0JHVzZVN0YXRlWzBdO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFRMQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FudmFzLCB7XG4gICAgcGFnZTogcGFnZSxcbiAgICBwYWdlU3RhdGU6IHBhZ2VTdGF0ZSxcbiAgICBoaWRlQm91bmRzOiBoaWRlQm91bmRzXG4gIH0pKTtcbn1cblxuZXhwb3J0cy5JbnRlcnNlY3QgPSBJbnRlcnNlY3Q7XG5leHBvcnRzLlJlbmRlcmVyID0gUmVuZGVyZXI7XG5leHBvcnRzLlN2ZyA9IFN2ZztcbmV4cG9ydHMuVExTaGFwZVV0aWwgPSBUTFNoYXBlVXRpbDtcbmV4cG9ydHMuVXRpbHMgPSBVdGlscztcbmV4cG9ydHMuVmVjID0gVmVjO1xuZXhwb3J0cy5icnVzaFVwZGF0ZXIgPSBicnVzaFVwZGF0ZXI7XG5leHBvcnRzLmlucHV0cyA9IGlucHV0cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmUuY2pzLmRldmVsb3BtZW50LmpzLm1hcFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../packages/core/dist/core.cjs.development.js\n");

/***/ }),

/***/ "../packages/core/dist/index.js":
/*!**************************************!*\
  !*** ../packages/core/dist/index.js ***!
  \**************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./core.cjs.development.js */ \"../packages/core/dist/core.cjs.development.js\")\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdGxkcmF3L3d3dy8uLi9wYWNrYWdlcy9jb3JlL2Rpc3QvaW5kZXguanM/MWQyZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ1k7O0FBRVosSUFBSSxLQUFxQyxFQUFFLEVBRTFDO0FBQ0QsRUFBRSxzSEFBcUQ7QUFDdkQiLCJmaWxlIjoiLi4vcGFja2FnZXMvY29yZS9kaXN0L2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4ndXNlIHN0cmljdCdcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvcmUuY2pzLnByb2R1Y3Rpb24ubWluLmpzJylcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb3JlLmNqcy5kZXZlbG9wbWVudC5qcycpXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../packages/core/dist/index.js\n");

/***/ }),

/***/ "../packages/tldraw/dist/index.js":
/*!****************************************!*\
  !*** ../packages/tldraw/dist/index.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./tldraw.cjs.development.js */ \"../packages/tldraw/dist/tldraw.cjs.development.js\")\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdGxkcmF3L3d3dy8uLi9wYWNrYWdlcy90bGRyYXcvZGlzdC9pbmRleC5qcz8wZDU3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDWTs7QUFFWixJQUFJLEtBQXFDLEVBQUUsRUFFMUM7QUFDRCxFQUFFLDRIQUF1RDtBQUN6RCIsImZpbGUiOiIuLi9wYWNrYWdlcy90bGRyYXcvZGlzdC9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuJ3VzZSBzdHJpY3QnXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi90bGRyYXcuY2pzLnByb2R1Y3Rpb24ubWluLmpzJylcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi90bGRyYXcuY2pzLmRldmVsb3BtZW50LmpzJylcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../packages/tldraw/dist/index.js\n");

/***/ }),

/***/ "../packages/tldraw/dist/tldraw.cjs.development.js":
/*!*********************************************************!*\
  !*** ../packages/tldraw/dist/tldraw.cjs.development.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar React = __webpack_require__(/*! react */ \"react\");\nvar React__default = _interopDefault(React);\nvar reactId = __webpack_require__(/*! @radix-ui/react-id */ \"@radix-ui/react-id\");\nvar core = __webpack_require__(/*! @tldraw/core */ \"../packages/core/dist/index.js\");\nvar getStroke = __webpack_require__(/*! perfect-freehand */ \"perfect-freehand\");\nvar getStroke__default = _interopDefault(getStroke);\nvar reactHotkeysHook = __webpack_require__(/*! react-hotkeys-hook */ \"react-hotkeys-hook\");\nvar react = __webpack_require__(/*! @stitches/react */ \"@stitches/react\");\nvar RadixContextMenu = __webpack_require__(/*! @radix-ui/react-context-menu */ \"@radix-ui/react-context-menu\");\nvar RadixTooltip = __webpack_require__(/*! @radix-ui/react-tooltip */ \"@radix-ui/react-tooltip\");\nvar DropdownMenu = __webpack_require__(/*! @radix-ui/react-dropdown-menu */ \"@radix-ui/react-dropdown-menu\");\n__webpack_require__(/*! @radix-ui/react-radio-group */ \"@radix-ui/react-radio-group\");\nvar reactIcons = __webpack_require__(/*! @radix-ui/react-icons */ \"@radix-ui/react-icons\");\nvar Checkbox = __webpack_require__(/*! @radix-ui/react-checkbox */ \"@radix-ui/react-checkbox\");\nvar createReact = _interopDefault(__webpack_require__(/*! zustand */ \"zustand\"));\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\n(function (TLDrawToolType) {\n  TLDrawToolType[\"Draw\"] = \"draw\";\n  TLDrawToolType[\"Bounds\"] = \"bounds\";\n  TLDrawToolType[\"Point\"] = \"point\";\n  TLDrawToolType[\"Handle\"] = \"handle\";\n  TLDrawToolType[\"Points\"] = \"points\";\n})(exports.TLDrawToolType || (exports.TLDrawToolType = {}));\n\n(function (TLDrawShapeType) {\n  TLDrawShapeType[\"Ellipse\"] = \"ellipse\";\n  TLDrawShapeType[\"Rectangle\"] = \"rectangle\";\n  TLDrawShapeType[\"Draw\"] = \"draw\";\n  TLDrawShapeType[\"Arrow\"] = \"arrow\";\n})(exports.TLDrawShapeType || (exports.TLDrawShapeType = {}));\n\n(function (Decoration) {\n  Decoration[\"Arrow\"] = \"Arrow\";\n})(exports.Decoration || (exports.Decoration = {}));\n\nvar TLDrawShapeUtil = /*#__PURE__*/function (_TLShapeUtil) {\n  _inheritsLoose(TLDrawShapeUtil, _TLShapeUtil);\n\n  function TLDrawShapeUtil() {\n    return _TLShapeUtil.apply(this, arguments) || this;\n  }\n\n  return TLDrawShapeUtil;\n}(core.TLShapeUtil);\n\n(function (ColorStyle) {\n  ColorStyle[\"White\"] = \"White\";\n  ColorStyle[\"LightGray\"] = \"LightGray\";\n  ColorStyle[\"Gray\"] = \"Gray\";\n  ColorStyle[\"Black\"] = \"Black\";\n  ColorStyle[\"Green\"] = \"Green\";\n  ColorStyle[\"Cyan\"] = \"Cyan\";\n  ColorStyle[\"Blue\"] = \"Blue\";\n  ColorStyle[\"Indigo\"] = \"Indigo\";\n  ColorStyle[\"Violet\"] = \"Violet\";\n  ColorStyle[\"Red\"] = \"Red\";\n  ColorStyle[\"Orange\"] = \"Orange\";\n  ColorStyle[\"Yellow\"] = \"Yellow\";\n})(exports.ColorStyle || (exports.ColorStyle = {}));\n\n(function (SizeStyle) {\n  SizeStyle[\"Small\"] = \"Small\";\n  SizeStyle[\"Medium\"] = \"Medium\";\n  SizeStyle[\"Large\"] = \"Large\";\n})(exports.SizeStyle || (exports.SizeStyle = {}));\n\n(function (DashStyle) {\n  DashStyle[\"Draw\"] = \"Draw\";\n  DashStyle[\"Solid\"] = \"Solid\";\n  DashStyle[\"Dashed\"] = \"Dashed\";\n  DashStyle[\"Dotted\"] = \"Dotted\";\n})(exports.DashStyle || (exports.DashStyle = {}));\n\n(function (FontSize) {\n  FontSize[\"Small\"] = \"Small\";\n  FontSize[\"Medium\"] = \"Medium\";\n  FontSize[\"Large\"] = \"Large\";\n  FontSize[\"ExtraLarge\"] = \"ExtraLarge\";\n})(exports.FontSize || (exports.FontSize = {}));\n\nvar _colors, _extends2, _extends3, _strokeWidths, _fontSizes;\nvar canvasLight = '#fafafa';\nvar canvasDark = '#343d45';\nvar colors = (_colors = {}, _colors[exports.ColorStyle.Black] = '#212528', _colors[exports.ColorStyle.White] = '#f0f1f3', _colors[exports.ColorStyle.LightGray] = '#c6cbd1', _colors[exports.ColorStyle.Gray] = '#788492', _colors[exports.ColorStyle.Green] = '#36b24d', _colors[exports.ColorStyle.Cyan] = '#0e98ad', _colors[exports.ColorStyle.Blue] = '#1c7ed6', _colors[exports.ColorStyle.Indigo] = '#4263eb', _colors[exports.ColorStyle.Violet] = '#7746f1', _colors[exports.ColorStyle.Red] = '#ff2133', _colors[exports.ColorStyle.Orange] = '#ff9433', _colors[exports.ColorStyle.Yellow] = '#ffc936', _colors);\nvar strokes = {\n  light: colors,\n  dark: /*#__PURE__*/_extends({}, /*#__PURE__*/Object.fromEntries( /*#__PURE__*/Object.entries(colors).map(function (_ref) {\n    var k = _ref[0],\n        v = _ref[1];\n    return [k, core.Utils.lerpColor(v, canvasDark, 0.1)];\n  })), (_extends2 = {}, _extends2[exports.ColorStyle.White] = '#ffffff', _extends2[exports.ColorStyle.Black] = '#000', _extends2))\n};\nvar fills = {\n  light: /*#__PURE__*/_extends({}, /*#__PURE__*/Object.fromEntries( /*#__PURE__*/Object.entries(colors).map(function (_ref2) {\n    var k = _ref2[0],\n        v = _ref2[1];\n    return [k, core.Utils.lerpColor(v, canvasLight, 0.82)];\n  })), (_extends3 = {}, _extends3[exports.ColorStyle.White] = '#ffffff', _extends3[exports.ColorStyle.Black] = '#ffffff', _extends3)),\n  dark: /*#__PURE__*/Object.fromEntries( /*#__PURE__*/Object.entries(colors).map(function (_ref3) {\n    var k = _ref3[0],\n        v = _ref3[1];\n    return [k, core.Utils.lerpColor(v, canvasDark, 0.618)];\n  }))\n};\nvar strokeWidths = (_strokeWidths = {}, _strokeWidths[exports.SizeStyle.Small] = 2, _strokeWidths[exports.SizeStyle.Medium] = 4, _strokeWidths[exports.SizeStyle.Large] = 8, _strokeWidths);\nvar fontSizes = (_fontSizes = {}, _fontSizes[exports.SizeStyle.Small] = 24, _fontSizes[exports.SizeStyle.Medium] = 48, _fontSizes[exports.SizeStyle.Large] = 72, _fontSizes.auto = 'auto', _fontSizes);\nfunction getStrokeWidth(size) {\n  return strokeWidths[size];\n}\nfunction getFontSize(size) {\n  return fontSizes[size];\n}\nfunction getFontStyle(scale, style) {\n  var fontSize = getFontSize(style.size);\n  return fontSize * scale + \"px/1.4 Verveine Regular\";\n}\nfunction getShapeStyle(style, isDarkMode) {\n  if (isDarkMode === void 0) {\n    isDarkMode = false;\n  }\n\n  var color = style.color,\n      size = style.size,\n      isFilled = style.isFilled;\n  var strokeWidth = getStrokeWidth(size);\n  var theme = isDarkMode ? 'dark' : 'light';\n  return {\n    stroke: strokes[theme][color],\n    fill: isFilled ? fills[theme][color] : 'none',\n    strokeWidth: strokeWidth\n  };\n}\nvar defaultStyle = {\n  color: exports.ColorStyle.Black,\n  size: exports.SizeStyle.Medium,\n  isFilled: false,\n  dash: exports.DashStyle.Draw\n};\n/**\r\n * Get balanced dash-strokearray and dash-strokeoffset properties for a path of a given length.\r\n * @param length The length of the path.\r\n * @param strokeWidth The shape's stroke-width property.\r\n * @param style The stroke's style: \"dashed\" or \"dotted\" (default \"dashed\").\r\n * @param snap An interval for dashes (e.g. 4 will produce arrays with 4, 8, 16, etc dashes).\r\n */\n\nfunction getPerfectDashProps(length, strokeWidth, style, snap) {\n  if (snap === void 0) {\n    snap = 1;\n  }\n\n  var dashLength;\n  var strokeDashoffset;\n  var ratio;\n\n  if (style === exports.DashStyle.Solid || style === exports.DashStyle.Draw) {\n    return {\n      strokeDasharray: 'none',\n      strokeDashoffset: 'none'\n    };\n  } else if (style === exports.DashStyle.Dashed) {\n    dashLength = strokeWidth * 2;\n    ratio = 1;\n    strokeDashoffset = (dashLength / 2).toString();\n  } else {\n    dashLength = strokeWidth / 100;\n    ratio = 100;\n    strokeDashoffset = '0';\n  }\n\n  var dashes = Math.floor(length / dashLength / (2 * ratio));\n  dashes -= dashes % snap;\n  if (dashes === 0) dashes = 1;\n  var gapLength = (length - dashes * dashLength) / dashes;\n  return {\n    strokeDasharray: [dashLength, gapLength].join(' '),\n    strokeDashoffset: strokeDashoffset\n  };\n}\n\nvar Draw = /*#__PURE__*/function (_TLDrawShapeUtil) {\n  _inheritsLoose(Draw, _TLDrawShapeUtil);\n\n  function Draw() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _TLDrawShapeUtil.call.apply(_TLDrawShapeUtil, [this].concat(args)) || this;\n    _this.type = exports.TLDrawShapeType.Draw;\n    _this.toolType = exports.TLDrawToolType.Draw;\n    _this.pointsBoundsCache = new WeakMap([]);\n    _this.rotatedCache = new WeakMap([]);\n    _this.drawPathCache = new WeakMap([]);\n    _this.simplePathCache = new WeakMap([]);\n    _this.polygonCache = new WeakMap([]);\n    _this.defaultProps = {\n      id: 'id',\n      type: exports.TLDrawShapeType.Draw,\n      name: 'Draw',\n      parentId: 'page',\n      childIndex: 1,\n      point: [0, 0],\n      points: [[0, 0, 0.5]],\n      rotation: 0,\n      radius: 0,\n      style: defaultStyle\n    };\n    return _this;\n  }\n\n  var _proto = Draw.prototype;\n\n  _proto.render = function render(shape, _ref) {\n    var _DashStyle$Draw$DashS, _DashStyle$Draw$DashS2;\n\n    var isHovered = _ref.isHovered,\n        isDarkMode = _ref.isDarkMode;\n    var points = shape.points,\n        style = shape.style;\n    var styles = getShapeStyle(style, isDarkMode);\n    var strokeWidth = +styles.strokeWidth;\n    var shouldFill = style.isFilled && points.length > 3 && core.Vec.dist(points[0], points[points.length - 1]) < +styles.strokeWidth * 2; // For very short lines, draw a point instead of a line\n\n    if (points.length > 0 && points.length < 3) {\n      var _sw = strokeWidth * 0.618;\n\n      return React.createElement(\"circle\", {\n        r: strokeWidth * 0.618,\n        fill: styles.stroke,\n        stroke: styles.stroke,\n        strokeWidth: _sw,\n        pointerEvents: \"all\",\n        filter: isHovered ? 'url(#expand)' : 'none'\n      });\n    } // For drawn lines, draw a line from the path cache\n\n\n    if (shape.style.dash === exports.DashStyle.Draw) {\n      var polygonPathData = core.Utils.getFromCache(this.polygonCache, points, function () {\n        return getFillPath(shape);\n      });\n      var drawPathData = core.Utils.getFromCache(this.drawPathCache, points, function () {\n        return getDrawStrokePath(shape);\n      });\n      return React.createElement(React.Fragment, null, shouldFill && React.createElement(\"path\", {\n        d: polygonPathData,\n        stroke: \"none\",\n        fill: styles.fill,\n        strokeLinejoin: \"round\",\n        strokeLinecap: \"round\",\n        pointerEvents: \"fill\"\n      }), React.createElement(\"path\", {\n        d: drawPathData,\n        fill: styles.stroke,\n        stroke: styles.stroke,\n        strokeWidth: strokeWidth,\n        strokeLinejoin: \"round\",\n        strokeLinecap: \"round\",\n        pointerEvents: \"all\",\n        filter: isHovered ? 'url(#expand)' : 'none'\n      }));\n    } // For solid, dash and dotted lines, draw a regular stroke path\n\n\n    var strokeDasharray = (_DashStyle$Draw$DashS = {}, _DashStyle$Draw$DashS[exports.DashStyle.Draw] = 'none', _DashStyle$Draw$DashS[exports.DashStyle.Solid] = \"none\", _DashStyle$Draw$DashS[exports.DashStyle.Dotted] = strokeWidth / 10 + \" \" + strokeWidth * 3, _DashStyle$Draw$DashS[exports.DashStyle.Dashed] = strokeWidth * 3 + \" \" + strokeWidth * 3, _DashStyle$Draw$DashS)[style.dash];\n    var strokeDashoffset = (_DashStyle$Draw$DashS2 = {}, _DashStyle$Draw$DashS2[exports.DashStyle.Draw] = 'none', _DashStyle$Draw$DashS2[exports.DashStyle.Solid] = \"none\", _DashStyle$Draw$DashS2[exports.DashStyle.Dotted] = \"-\" + strokeWidth / 20, _DashStyle$Draw$DashS2[exports.DashStyle.Dashed] = \"-\" + strokeWidth, _DashStyle$Draw$DashS2)[style.dash];\n    var path = core.Utils.getFromCache(this.simplePathCache, points, function () {\n      return getSolidStrokePath(shape);\n    });\n    var sw = strokeWidth * 1.618;\n    return React.createElement(React.Fragment, null, React.createElement(\"path\", {\n      d: path,\n      fill: shouldFill ? styles.fill : 'none',\n      stroke: \"transparent\",\n      strokeWidth: Math.min(4, strokeWidth * 2),\n      strokeLinejoin: \"round\",\n      strokeLinecap: \"round\",\n      pointerEvents: shouldFill ? 'all' : 'stroke'\n    }), React.createElement(\"path\", {\n      d: path,\n      fill: \"transparent\",\n      stroke: styles.stroke,\n      strokeWidth: sw,\n      strokeDasharray: strokeDasharray,\n      strokeDashoffset: strokeDashoffset,\n      strokeLinejoin: \"round\",\n      strokeLinecap: \"round\",\n      pointerEvents: \"stroke\",\n      filter: isHovered ? 'url(#expand)' : 'none'\n    }));\n  };\n\n  _proto.getBounds = function getBounds(shape) {\n    return core.Utils.translateBounds(core.Utils.getFromCache(this.pointsBoundsCache, shape.points, function () {\n      return core.Utils.getBoundsFromPoints(shape.points);\n    }), shape.point);\n  };\n\n  _proto.getRotatedBounds = function getRotatedBounds(shape) {\n    return core.Utils.translateBounds(core.Utils.getBoundsFromPoints(shape.points, shape.rotation), shape.point);\n  };\n\n  _proto.getCenter = function getCenter(shape) {\n    return core.Utils.getBoundsCenter(this.getBounds(shape));\n  };\n\n  _proto.hitTest = function hitTest(shape, point) {\n    return true;\n  };\n\n  _proto.hitTestBounds = function hitTestBounds(shape, brushBounds) {\n    // Test axis-aligned shape\n    if (!shape.rotation) {\n      var bounds = this.getBounds(shape);\n      return core.Utils.boundsContain(brushBounds, bounds) || (core.Utils.boundsContain(bounds, brushBounds) || core.Intersect.bounds.bounds(bounds, brushBounds).length > 0) && core.Intersect.polyline.bounds(shape.points, core.Utils.translateBounds(brushBounds, core.Vec.neg(shape.point))).length > 0;\n    } // Test rotated shape\n\n\n    var rBounds = this.getRotatedBounds(shape);\n    var rotatedBounds = core.Utils.getFromCache(this.rotatedCache, shape, function () {\n      var c = core.Utils.getBoundsCenter(core.Utils.getBoundsFromPoints(shape.points));\n      return shape.points.map(function (pt) {\n        return core.Vec.rotWith(pt, c, shape.rotation || 0);\n      });\n    });\n    return core.Utils.boundsContain(brushBounds, rBounds) || core.Intersect.bounds.polyline(core.Utils.translateBounds(brushBounds, core.Vec.neg(shape.point)), rotatedBounds).length > 0;\n  };\n\n  _proto.transform = function transform(shape, bounds, _ref2) {\n    var initialShape = _ref2.initialShape,\n        scaleX = _ref2.scaleX,\n        scaleY = _ref2.scaleY;\n    var initialShapeBounds = core.Utils.getFromCache(this.boundsCache, initialShape, function () {\n      return core.Utils.getBoundsFromPoints(initialShape.points);\n    });\n    var points = initialShape.points.map(function (_ref3) {\n      var x = _ref3[0],\n          y = _ref3[1],\n          r = _ref3[2];\n      return [bounds.width * (scaleX < 0 // * sin?\n      ? 1 - x / initialShapeBounds.width : x / initialShapeBounds.width), bounds.height * (scaleY < 0 // * cos?\n      ? 1 - y / initialShapeBounds.height : y / initialShapeBounds.height), r];\n    });\n    var newBounds = core.Utils.getBoundsFromPoints(shape.points);\n    var point = core.Vec.sub([bounds.minX, bounds.minY], [newBounds.minX, newBounds.minY]);\n    return {\n      points: points,\n      point: point\n    };\n  };\n\n  _proto.transformSingle = function transformSingle(shape, bounds, info) {\n    return this.transform(shape, bounds, info);\n  };\n\n  _proto.onSessionComplete = function onSessionComplete(shape) {\n    var bounds = this.getBounds(shape);\n\n    var _Vec$sub = core.Vec.sub([bounds.minX, bounds.minY], shape.point),\n        x1 = _Vec$sub[0],\n        y1 = _Vec$sub[1];\n\n    return {\n      points: shape.points.map(function (_ref4) {\n        var x0 = _ref4[0],\n            y0 = _ref4[1],\n            p = _ref4[2];\n        return [x0 - x1, y0 - y1, p];\n      }),\n      point: core.Vec.add(shape.point, [x1, y1])\n    };\n  };\n\n  return Draw;\n}(TLDrawShapeUtil);\nvar simulatePressureSettings = {\n  simulatePressure: true\n};\nvar realPressureSettings = {\n  easing: function easing(t) {\n    return t * t;\n  },\n  simulatePressure: false,\n  start: {\n    taper: 1\n  },\n  end: {\n    taper: 1\n  }\n};\n\nfunction getFillPath(shape) {\n  var styles = getShapeStyle(shape.style);\n\n  if (shape.points.length < 2) {\n    return '';\n  }\n\n  return core.Utils.getSvgPathFromStroke(getStroke.getStrokePoints(shape.points, {\n    size: 1 + +styles.strokeWidth * 2,\n    thinning: 0.85,\n    end: {\n      taper: +styles.strokeWidth * 20\n    },\n    start: {\n      taper: +styles.strokeWidth * 20\n    }\n  }).map(function (pt) {\n    return pt.point;\n  }));\n}\n\nfunction getDrawStrokePath(shape) {\n  var styles = getShapeStyle(shape.style);\n\n  if (shape.points.length < 2) {\n    return '';\n  }\n\n  var options = shape.points[1][2] === 0.5 ? simulatePressureSettings : realPressureSettings;\n  var stroke = getStroke__default(shape.points, _extends({\n    size: 1 + +styles.strokeWidth * 2,\n    thinning: 0.85,\n    end: {\n      taper: +styles.strokeWidth * 10\n    },\n    start: {\n      taper: +styles.strokeWidth * 10\n    }\n  }, options));\n  return core.Utils.getSvgPathFromStroke(stroke);\n}\n\nfunction getSolidStrokePath(shape) {\n  var points = shape.points;\n  var len = points.length;\n  if (len === 0) return 'M 0 0 L 0 0';\n  if (len < 3) return \"M \" + points[0][0] + \" \" + points[0][1];\n  points = getStroke.getStrokePoints(points).map(function (pt) {\n    return pt.point;\n  });\n  len = points.length;\n  var d = points.reduce(function (acc, _ref5, i, arr) {\n    var x0 = _ref5[0],\n        y0 = _ref5[1];\n\n    if (i === len - 1) {\n      acc.push('L', x0, y0);\n      return acc;\n    }\n\n    var _arr = arr[i + 1],\n        x1 = _arr[0],\n        y1 = _arr[1];\n    acc.push(x0.toFixed(2), y0.toFixed(2), ((x0 + x1) / 2).toFixed(2), ((y0 + y1) / 2).toFixed(2));\n    return acc;\n  }, ['M', points[0][0], points[0][1], 'Q']);\n  var path = d.join(' ').replaceAll(/(\\s[0-9]*\\.[0-9]{2})([0-9]*)\\b/g, '$1');\n  return path;\n}\n\nvar Arrow = /*#__PURE__*/function (_TLDrawShapeUtil) {\n  _inheritsLoose(Arrow, _TLDrawShapeUtil);\n\n  function Arrow() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _TLDrawShapeUtil.call.apply(_TLDrawShapeUtil, [this].concat(args)) || this;\n    _this.type = exports.TLDrawShapeType.Arrow;\n    _this.toolType = exports.TLDrawToolType.Handle;\n    _this.canStyleFill = false;\n    _this.defaultProps = {\n      id: 'id',\n      type: exports.TLDrawShapeType.Arrow,\n      name: 'Arrow',\n      parentId: 'page',\n      childIndex: 1,\n      point: [0, 0],\n      rotation: 0,\n      bend: 0,\n      handles: {\n        start: {\n          id: 'start',\n          index: 0,\n          point: [0, 0],\n          canBind: true\n        },\n        end: {\n          id: 'end',\n          index: 1,\n          point: [1, 1],\n          canBind: true\n        },\n        bend: {\n          id: 'bend',\n          index: 2,\n          point: [0.5, 0.5]\n        }\n      },\n      decorations: {\n        end: exports.Decoration.Arrow\n      },\n      style: _extends({}, defaultStyle, {\n        isFilled: false\n      })\n    };\n\n    _this.shouldRender = function (prev, next) {\n      return next.handles !== prev.handles || next.style !== prev.style;\n    };\n\n    _this.render = function (shape, _ref) {\n      var _shape$decorations, _shape$decorations2;\n\n      var isDarkMode = _ref.isDarkMode;\n      var bend = shape.bend,\n          handles = shape.handles,\n          style = shape.style;\n      var start = handles.start,\n          end = handles.end,\n          _bend = handles.bend;\n      var isStraightLine = core.Vec.dist(_bend.point, core.Vec.round(core.Vec.med(start.point, end.point))) < 1;\n      var isDraw = shape.style.dash === exports.DashStyle.Draw;\n      var styles = getShapeStyle(style, isDarkMode);\n      var strokeWidth = styles.strokeWidth;\n      var arrowDist = core.Vec.dist(start.point, end.point);\n      var arrowHeadlength = Math.min(arrowDist / 3, strokeWidth * 8);\n      var shaftPath;\n      var insetStart;\n      var insetEnd;\n\n      if (isStraightLine) {\n        var _sw = strokeWidth * (isDraw ? 0.618 : 1.618);\n\n        var path = isDraw ? renderFreehandArrowShaft(shape) : 'M' + core.Vec.round(start.point) + 'L' + core.Vec.round(end.point);\n\n        var _getPerfectDashProps = getPerfectDashProps(arrowDist, _sw, shape.style.dash, 2),\n            strokeDasharray = _getPerfectDashProps.strokeDasharray,\n            strokeDashoffset = _getPerfectDashProps.strokeDashoffset;\n\n        insetStart = core.Vec.nudge(start.point, end.point, arrowHeadlength);\n        insetEnd = core.Vec.nudge(end.point, start.point, arrowHeadlength); // Straight arrow path\n\n        shaftPath = React.createElement(React.Fragment, null, React.createElement(\"path\", {\n          d: path,\n          fill: \"none\",\n          strokeWidth: Math.max(8, strokeWidth * 2),\n          strokeDasharray: \"none\",\n          strokeDashoffset: \"none\",\n          strokeLinecap: \"round\",\n          strokeLinejoin: \"round\"\n        }), React.createElement(\"path\", {\n          d: path,\n          fill: styles.stroke,\n          stroke: styles.stroke,\n          strokeWidth: _sw,\n          strokeDasharray: strokeDasharray,\n          strokeDashoffset: strokeDashoffset,\n          strokeLinecap: \"round\",\n          strokeLinejoin: \"round\"\n        }));\n      } else {\n        var circle = getCtp(shape);\n\n        var _sw2 = strokeWidth * (isDraw ? 0.618 : 1.618);\n\n        var _path = isDraw ? renderCurvedFreehandArrowShaft(shape, circle) : getArrowArcPath(start, end, circle, bend);\n\n        var arcLength = core.Utils.getArcLength([circle[0], circle[1]], circle[2], start.point, end.point);\n\n        var _getPerfectDashProps2 = getPerfectDashProps(arcLength - 1, _sw2, shape.style.dash, 2),\n            _strokeDasharray = _getPerfectDashProps2.strokeDasharray,\n            _strokeDashoffset = _getPerfectDashProps2.strokeDashoffset;\n\n        var center = [circle[0], circle[1]];\n        var radius = circle[2];\n        var sa = core.Vec.angle(center, start.point);\n        var ea = core.Vec.angle(center, end.point);\n        var t = arrowHeadlength / Math.abs(arcLength);\n        insetStart = core.Vec.nudgeAtAngle(center, core.Utils.lerpAngles(sa, ea, t), radius);\n        insetEnd = core.Vec.nudgeAtAngle(center, core.Utils.lerpAngles(ea, sa, t), radius); // Curved arrow path\n\n        shaftPath = React.createElement(React.Fragment, null, React.createElement(\"path\", {\n          d: _path,\n          fill: \"none\",\n          stroke: \"transparent\",\n          strokeWidth: Math.max(8, strokeWidth * 2),\n          strokeDasharray: \"none\",\n          strokeDashoffset: \"none\",\n          strokeLinecap: \"round\",\n          strokeLinejoin: \"round\"\n        }), React.createElement(\"path\", {\n          d: _path,\n          fill: isDraw ? styles.stroke : 'none',\n          stroke: styles.stroke,\n          strokeWidth: _sw2,\n          strokeDasharray: _strokeDasharray,\n          strokeDashoffset: _strokeDashoffset,\n          strokeLinecap: \"round\",\n          strokeLinejoin: \"round\"\n        }));\n      }\n\n      var sw = strokeWidth * 1.618;\n      return React.createElement(\"g\", {\n        pointerEvents: \"all\"\n      }, shaftPath, ((_shape$decorations = shape.decorations) == null ? void 0 : _shape$decorations.start) === exports.Decoration.Arrow && React.createElement(\"path\", {\n        d: getArrowHeadPath(shape, start.point, insetStart),\n        fill: \"none\",\n        stroke: styles.stroke,\n        strokeWidth: sw,\n        strokeDashoffset: \"none\",\n        strokeDasharray: \"none\",\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        pointerEvents: \"stroke\"\n      }), ((_shape$decorations2 = shape.decorations) == null ? void 0 : _shape$decorations2.end) === exports.Decoration.Arrow && React.createElement(\"path\", {\n        d: getArrowHeadPath(shape, end.point, insetEnd),\n        fill: \"none\",\n        stroke: styles.stroke,\n        strokeWidth: sw,\n        strokeDashoffset: \"none\",\n        strokeDasharray: \"none\",\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        pointerEvents: \"stroke\"\n      }));\n    };\n\n    _this.getBounds = function (shape) {\n      var bounds = core.Utils.getFromCache(_this.boundsCache, shape, function () {\n        var _shape$handles = shape.handles,\n            start = _shape$handles.start,\n            bend = _shape$handles.bend,\n            end = _shape$handles.end;\n        return core.Utils.getBoundsFromPoints([start.point, bend.point, end.point]);\n      });\n      return core.Utils.translateBounds(bounds, shape.point);\n    };\n\n    _this.getRotatedBounds = function (shape) {\n      var _shape$handles2 = shape.handles,\n          start = _shape$handles2.start,\n          bend = _shape$handles2.bend,\n          end = _shape$handles2.end;\n      return core.Utils.translateBounds(core.Utils.getBoundsFromPoints([start.point, bend.point, end.point], shape.rotation), shape.point);\n    };\n\n    _this.getCenter = function (shape) {\n      var _shape$handles3 = shape.handles,\n          start = _shape$handles3.start,\n          end = _shape$handles3.end;\n      return core.Vec.add(shape.point, core.Vec.med(start.point, end.point));\n    };\n\n    _this.hitTest = function () {\n      return true;\n    };\n\n    _this.hitTestBounds = function (shape, brushBounds) {\n      var _shape$handles4 = shape.handles,\n          start = _shape$handles4.start,\n          end = _shape$handles4.end,\n          bend = _shape$handles4.bend;\n      var sp = core.Vec.add(shape.point, start.point);\n      var ep = core.Vec.add(shape.point, end.point);\n\n      if (core.Utils.pointInBounds(sp, brushBounds) || core.Utils.pointInBounds(ep, brushBounds)) {\n        return true;\n      }\n\n      if (core.Vec.isEqual(core.Vec.med(start.point, end.point), bend.point)) {\n        return core.Intersect.lineSegment.bounds(sp, ep, brushBounds).length > 0;\n      } else {\n        var _getCtp = getCtp(shape),\n            cx = _getCtp[0],\n            cy = _getCtp[1],\n            r = _getCtp[2];\n\n        var cp = core.Vec.add(shape.point, [cx, cy]);\n        return core.Intersect.arc.bounds(cp, r, sp, ep, brushBounds).length > 0;\n      }\n    };\n\n    _this.transform = function (_shape, bounds, _ref2) {\n      var initialShape = _ref2.initialShape,\n          scaleX = _ref2.scaleX,\n          scaleY = _ref2.scaleY;\n\n      var initialShapeBounds = _this.getBounds(initialShape);\n\n      var handles = ['start', 'end'];\n\n      var nextHandles = _extends({}, initialShape.handles);\n\n      handles.forEach(function (handle) {\n        var _nextHandles$handle$p = nextHandles[handle].point,\n            x = _nextHandles$handle$p[0],\n            y = _nextHandles$handle$p[1];\n        var nw = x / initialShapeBounds.width;\n        var nh = y / initialShapeBounds.height;\n        nextHandles[handle] = _extends({}, nextHandles[handle], {\n          point: [bounds.width * (scaleX < 0 ? 1 - nw : nw), bounds.height * (scaleY < 0 ? 1 - nh : nh)]\n        });\n      });\n      var start = nextHandles.start,\n          bend = nextHandles.bend,\n          end = nextHandles.end;\n      var dist = core.Vec.dist(start.point, end.point);\n      var midPoint = core.Vec.med(start.point, end.point);\n      var bendDist = dist / 2 * initialShape.bend;\n      var u = core.Vec.uni(core.Vec.vec(start.point, end.point));\n      var point = core.Vec.add(midPoint, core.Vec.mul(core.Vec.per(u), bendDist));\n      nextHandles['bend'] = _extends({}, bend, {\n        point: Math.abs(bendDist) < 10 ? midPoint : point\n      });\n      return {\n        point: [bounds.minX, bounds.minY],\n        handles: nextHandles\n      };\n    };\n\n    _this.onDoubleClickHandle = function (shape, handle) {\n      switch (handle) {\n        case 'bend':\n          {\n            return {\n              bend: 0,\n              handles: _extends({}, shape.handles, {\n                bend: _extends({}, shape.handles.bend, {\n                  point: getBendPoint(shape.handles, shape.bend)\n                })\n              })\n            };\n          }\n\n        case 'start':\n          {\n            var _shape$decorations3;\n\n            return {\n              decorations: _extends({}, shape.decorations, {\n                start: (_shape$decorations3 = shape.decorations) != null && _shape$decorations3.start ? undefined : exports.Decoration.Arrow\n              })\n            };\n          }\n\n        case 'end':\n          {\n            var _shape$decorations4;\n\n            return {\n              decorations: _extends({}, shape.decorations, {\n                end: (_shape$decorations4 = shape.decorations) != null && _shape$decorations4.end ? undefined : exports.Decoration.Arrow\n              })\n            };\n          }\n      }\n\n      return _assertThisInitialized(_this);\n    };\n\n    _this.onHandleChange = function (shape, handles, _ref3) {\n      var shiftKey = _ref3.shiftKey;\n      var nextHandles = core.Utils.deepMerge(shape.handles, handles);\n      var nextBend = shape.bend; // If the user is holding shift, we want to snap the handles to angles\n\n      for (var id in handles) {\n        if ((id === 'start' || id === 'end') && shiftKey) {\n          var _extends2;\n\n          var point = handles[id].point;\n          var other = id === 'start' ? shape.handles.end : shape.handles.start;\n          var angle = core.Vec.angle(other.point, point);\n          var distance = core.Vec.dist(other.point, point);\n          var newAngle = core.Utils.clampToRotationToSegments(angle, 24);\n          nextHandles = _extends({}, nextHandles, (_extends2 = {}, _extends2[id] = _extends({}, nextHandles[id], {\n            point: core.Vec.nudgeAtAngle(other.point, newAngle, distance)\n          }), _extends2));\n        }\n      } // If the user is moving the bend handle, we want to move the bend point\n\n\n      if ('bend' in handles) {\n        var _nextHandles = nextHandles,\n            start = _nextHandles.start,\n            end = _nextHandles.end,\n            bend = _nextHandles.bend;\n\n        var _distance = core.Vec.dist(start.point, end.point);\n\n        var midPoint = core.Vec.med(start.point, end.point);\n\n        var _angle = core.Vec.angle(start.point, end.point);\n\n        var u = core.Vec.uni(core.Vec.vec(start.point, end.point)); // Create a line segment perendicular to the line between the start and end points\n\n        var ap = core.Vec.add(midPoint, core.Vec.mul(core.Vec.per(u), _distance / 2));\n        var bp = core.Vec.sub(midPoint, core.Vec.mul(core.Vec.per(u), _distance / 2));\n        var bendPoint = core.Vec.nearestPointOnLineSegment(ap, bp, bend.point, true); // Find the distance between the midpoint and the nearest point on the\n        // line segment to the bend handle's dragged point\n\n        var bendDist = core.Vec.dist(midPoint, bendPoint); // The shape's \"bend\" is the ratio of the bend to the distance between\n        // the start and end points. If the bend is below a certain amount, the\n        // bend should be zero.\n\n        nextBend = core.Utils.clamp(bendDist / (_distance / 2), -0.99, 0.99); // If the point is to the left of the line segment, we make the bend\n        // negative, otherwise it's positive.\n\n        var angleToBend = core.Vec.angle(start.point, bendPoint);\n\n        if (core.Utils.isAngleBetween(_angle, _angle + Math.PI, angleToBend)) {\n          nextBend *= -1;\n        }\n      }\n\n      nextHandles = _extends({}, nextHandles, {\n        start: _extends({}, nextHandles.start, {\n          point: core.Vec.round(nextHandles.start.point)\n        }),\n        end: _extends({}, nextHandles.end, {\n          point: core.Vec.round(nextHandles.end.point)\n        })\n      });\n      return {\n        bend: nextBend,\n        handles: _extends({}, nextHandles, {\n          bend: _extends({}, nextHandles.bend, {\n            point: getBendPoint(nextHandles, nextBend)\n          })\n        })\n      };\n    };\n\n    _this.onSessionComplete = function (shape) {\n      var bounds = _this.getBounds(shape);\n\n      var offset = core.Vec.sub([bounds.minX, bounds.minY], shape.point);\n      var _shape$handles5 = shape.handles,\n          start = _shape$handles5.start,\n          end = _shape$handles5.end,\n          bend = _shape$handles5.bend;\n      return {\n        point: core.Vec.add(shape.point, offset),\n        handles: {\n          start: _extends({}, start, {\n            point: core.Vec.round(core.Vec.sub(start.point, offset))\n          }),\n          end: _extends({}, end, {\n            point: core.Vec.round(core.Vec.sub(end.point, offset))\n          }),\n          bend: _extends({}, bend, {\n            point: core.Vec.round(core.Vec.sub(bend.point, offset))\n          })\n        }\n      };\n    };\n\n    return _this;\n  }\n\n  return Arrow;\n}(TLDrawShapeUtil);\n\nfunction getArrowArcPath(start, end, circle, bend) {\n  return ['M', start.point[0], start.point[1], 'A', circle[2], circle[2], 0, 0, bend < 0 ? 0 : 1, end.point[0], end.point[1]].join(' ');\n}\n\nfunction getBendPoint(handles, bend) {\n  var start = handles.start,\n      end = handles.end;\n  var dist = core.Vec.dist(start.point, end.point);\n  var midPoint = core.Vec.med(start.point, end.point);\n  var bendDist = dist / 2 * bend;\n  var u = core.Vec.uni(core.Vec.vec(start.point, end.point));\n  var point = core.Vec.round(Math.abs(bendDist) < 10 ? midPoint : core.Vec.add(midPoint, core.Vec.mul(core.Vec.per(u), bendDist)));\n  return point;\n}\n\nfunction renderFreehandArrowShaft(shape) {\n  var style = shape.style,\n      id = shape.id;\n  var _shape$handles6 = shape.handles,\n      start = _shape$handles6.start,\n      end = _shape$handles6.end;\n  var getRandom = core.Utils.rng(id);\n  var strokeWidth = +getShapeStyle(style).strokeWidth * 2;\n  var st = Math.abs(getRandom());\n  var stroke = getStroke__default([].concat(core.Vec.pointsBetween(start.point, end.point), [end.point, end.point, end.point, end.point]), {\n    size: strokeWidth / 2,\n    thinning: 0.5 + getRandom() * 0.3,\n    easing: function easing(t) {\n      return t * t;\n    },\n    end: {\n      taper: 1\n    },\n    start: {\n      taper: 1 + 32 * (st * st * st)\n    },\n    simulatePressure: true,\n    last: true\n  });\n  var path = core.Utils.getSvgPathFromStroke(stroke);\n  return path;\n}\n\nfunction renderCurvedFreehandArrowShaft(shape, circle) {\n  var _shape$decorations5, _shape$decorations6;\n\n  var style = shape.style,\n      id = shape.id;\n  var _shape$handles7 = shape.handles,\n      start = _shape$handles7.start,\n      end = _shape$handles7.end;\n  var getRandom = core.Utils.rng(id);\n  var strokeWidth = +getShapeStyle(style).strokeWidth * 2;\n  var st = Math.abs(getRandom());\n  var center = [circle[0], circle[1]];\n  var radius = circle[2];\n  var startAngle = core.Vec.angle(center, start.point);\n  var endAngle = core.Vec.angle(center, end.point);\n  var points = [];\n\n  for (var i = 0; i < 21; i++) {\n    var t = i / 20;\n    var angle = core.Utils.lerpAngles(startAngle, endAngle, t);\n    points.push(core.Vec.round(core.Vec.nudgeAtAngle(center, angle, radius)));\n  }\n\n  var stroke = getStroke__default([].concat(points, [end.point, end.point]), {\n    size: strokeWidth / 2,\n    thinning: 0.5 + getRandom() * 0.3,\n    easing: function easing(t) {\n      return t * t;\n    },\n    end: {\n      taper: (_shape$decorations5 = shape.decorations) != null && _shape$decorations5.end ? 1 : 1 + strokeWidth * 5 * (st * st * st)\n    },\n    start: {\n      taper: (_shape$decorations6 = shape.decorations) != null && _shape$decorations6.start ? 1 : 1 + strokeWidth * 5 * (st * st * st)\n    },\n    simulatePressure: true,\n    streamline: 0.01,\n    last: true\n  });\n  var path = core.Utils.getSvgPathFromStroke(stroke);\n  return path;\n}\n\nfunction getArrowHeadPath(shape, point, inset) {\n  var _getArrowHeadPoints = getArrowHeadPoints(shape, point, inset),\n      left = _getArrowHeadPoints.left,\n      right = _getArrowHeadPoints.right;\n\n  return ['M', left, 'L', point, right].join(' ');\n}\n\nfunction getArrowHeadPoints(shape, point, inset) {\n  // Use the shape's random seed to create minor offsets for the angles\n  var getRandom = core.Utils.rng(shape.id);\n  return {\n    left: core.Vec.rotWith(inset, point, Math.PI / 6 + Math.PI / 12 * getRandom()),\n    right: core.Vec.rotWith(inset, point, -Math.PI / 6 + Math.PI / 12 * getRandom())\n  };\n}\n\nfunction getCtp(shape) {\n  var _shape$handles8 = shape.handles,\n      start = _shape$handles8.start,\n      end = _shape$handles8.end,\n      bend = _shape$handles8.bend;\n  return core.Utils.circleFromThreePoints(start.point, end.point, bend.point);\n}\n\nvar Rectangle = /*#__PURE__*/function (_TLDrawShapeUtil) {\n  _inheritsLoose(Rectangle, _TLDrawShapeUtil);\n\n  function Rectangle() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _TLDrawShapeUtil.call.apply(_TLDrawShapeUtil, [this].concat(args)) || this;\n    _this.type = exports.TLDrawShapeType.Rectangle;\n    _this.toolType = exports.TLDrawToolType.Bounds;\n    _this.pathCache = new WeakMap([]);\n    _this.defaultProps = {\n      id: 'id',\n      type: exports.TLDrawShapeType.Rectangle,\n      name: 'Rectangle',\n      parentId: 'page',\n      childIndex: 1,\n      point: [0, 0],\n      size: [1, 1],\n      rotation: 0,\n      radius: 0,\n      style: defaultStyle\n    };\n    return _this;\n  }\n\n  var _proto = Rectangle.prototype;\n\n  _proto.render = function render(shape, _ref) {\n    var isBinding = _ref.isBinding,\n        isHovered = _ref.isHovered,\n        isDarkMode = _ref.isDarkMode;\n    var id = shape.id,\n        size = shape.size,\n        style = shape.style;\n    var styles = getShapeStyle(style, isDarkMode);\n    var strokeWidth = +styles.strokeWidth;\n\n    if (style.dash === exports.DashStyle.Draw) {\n      var pathData = core.Utils.getFromCache(this.pathCache, shape.size, function () {\n        return renderPath(shape);\n      });\n      return React.createElement(React.Fragment, null, isBinding && React.createElement(\"rect\", {\n        className: \"tl-binding-indicator\",\n        x: strokeWidth / 2 - 32,\n        y: strokeWidth / 2 - 32,\n        width: Math.max(0, size[0] - strokeWidth / 2) + 64,\n        height: Math.max(0, size[1] - strokeWidth / 2) + 64\n      }), React.createElement(\"rect\", {\n        x: +styles.strokeWidth / 2,\n        y: +styles.strokeWidth / 2,\n        width: Math.max(0, size[0] - strokeWidth),\n        height: Math.max(0, size[1] - strokeWidth),\n        fill: style.isFilled ? styles.fill : 'transparent',\n        stroke: \"none\",\n        pointerEvents: \"all\"\n      }), React.createElement(\"path\", {\n        d: pathData,\n        fill: styles.stroke,\n        stroke: styles.stroke,\n        strokeWidth: styles.strokeWidth,\n        filter: isHovered ? 'url(#expand)' : 'none',\n        pointerEvents: \"all\"\n      }));\n    }\n\n    var sw = strokeWidth * 1.618;\n    var w = Math.max(0, size[0] - sw / 2);\n    var h = Math.max(0, size[1] - sw / 2);\n    var strokes = [[[sw / 2, sw / 2], [w, sw / 2], w - sw / 2], [[w, sw / 2], [w, h], h - sw / 2], [[w, h], [sw / 2, h], w - sw / 2], [[sw / 2, h], [sw / 2, sw / 2], h - sw / 2]];\n    var paths = strokes.map(function (_ref2, i) {\n      var start = _ref2[0],\n          end = _ref2[1],\n          length = _ref2[2];\n\n      var _getPerfectDashProps = getPerfectDashProps(length, sw, shape.style.dash),\n          strokeDasharray = _getPerfectDashProps.strokeDasharray,\n          strokeDashoffset = _getPerfectDashProps.strokeDashoffset;\n\n      return React.createElement(\"line\", {\n        key: id + '_' + i,\n        x1: start[0],\n        y1: start[1],\n        x2: end[0],\n        y2: end[1],\n        stroke: styles.stroke,\n        strokeWidth: sw,\n        strokeLinecap: \"round\",\n        strokeDasharray: strokeDasharray,\n        strokeDashoffset: strokeDashoffset\n      });\n    });\n    return React.createElement(React.Fragment, null, isBinding && React.createElement(\"rect\", {\n      className: \"tl-binding-indicator\",\n      x: sw / 2 - 32,\n      y: sw / 2 - 32,\n      width: w + 64,\n      height: h + 64\n    }), React.createElement(\"rect\", {\n      x: sw / 2,\n      y: sw / 2,\n      width: w,\n      height: h,\n      fill: styles.fill,\n      stroke: \"transparent\",\n      strokeWidth: sw,\n      pointerEvents: \"all\"\n    }), React.createElement(\"g\", {\n      filter: isHovered ? 'url(#expand)' : 'none',\n      pointerEvents: \"stroke\"\n    }, paths));\n  };\n\n  _proto.getBounds = function getBounds(shape) {\n    var bounds = core.Utils.getFromCache(this.boundsCache, shape, function () {\n      var _shape$size = shape.size,\n          width = _shape$size[0],\n          height = _shape$size[1];\n      return {\n        minX: 0,\n        maxX: width,\n        minY: 0,\n        maxY: height,\n        width: width,\n        height: height\n      };\n    });\n    return core.Utils.translateBounds(bounds, shape.point);\n  };\n\n  _proto.getRotatedBounds = function getRotatedBounds(shape) {\n    return core.Utils.getBoundsFromPoints(core.Utils.getRotatedCorners(this.getBounds(shape), shape.rotation));\n  };\n\n  _proto.getCenter = function getCenter(shape) {\n    return core.Utils.getBoundsCenter(this.getBounds(shape));\n  };\n\n  _proto.hitTest = function hitTest(shape, point) {\n    return core.Utils.pointInBounds(point, this.getBounds(shape));\n  };\n\n  _proto.hitTestBounds = function hitTestBounds(shape, bounds) {\n    var rotatedCorners = core.Utils.getRotatedCorners(this.getBounds(shape), shape.rotation);\n    return rotatedCorners.every(function (point) {\n      return core.Utils.pointInBounds(point, bounds);\n    }) || core.Intersect.polyline.bounds(rotatedCorners, bounds).length > 0;\n  };\n\n  _proto.transform = function transform(shape, bounds, _ref3) {\n    var initialShape = _ref3.initialShape,\n        transformOrigin = _ref3.transformOrigin,\n        scaleX = _ref3.scaleX,\n        scaleY = _ref3.scaleY;\n\n    if (!shape.rotation && !shape.isAspectRatioLocked) {\n      return {\n        point: core.Vec.round([bounds.minX, bounds.minY]),\n        size: core.Vec.round([bounds.width, bounds.height])\n      };\n    } else {\n      var size = core.Vec.round(core.Vec.mul(initialShape.size, Math.min(Math.abs(scaleX), Math.abs(scaleY))));\n      var point = core.Vec.round([bounds.minX + (bounds.width - shape.size[0]) * (scaleX < 0 ? 1 - transformOrigin[0] : transformOrigin[0]), bounds.minY + (bounds.height - shape.size[1]) * (scaleY < 0 ? 1 - transformOrigin[1] : transformOrigin[1])]);\n      var rotation = scaleX < 0 && scaleY >= 0 || scaleY < 0 && scaleX >= 0 ? initialShape.rotation ? -initialShape.rotation : 0 : initialShape.rotation;\n      return {\n        size: size,\n        point: point,\n        rotation: rotation\n      };\n    }\n  };\n\n  _proto.transformSingle = function transformSingle(shape, bounds, info) {\n    return {\n      size: core.Vec.round([bounds.width, bounds.height]),\n      point: core.Vec.round([bounds.minX, bounds.minY])\n    };\n  };\n\n  return Rectangle;\n}(TLDrawShapeUtil);\n\nfunction renderPath(shape) {\n  var styles = getShapeStyle(shape.style);\n  var getRandom = core.Utils.rng(shape.id);\n  var strokeWidth = +styles.strokeWidth;\n  var baseOffset = strokeWidth / 2;\n  var offsets = Array.from(Array(4)).map(function () {\n    return [getRandom() * baseOffset, getRandom() * baseOffset];\n  });\n  var sw = strokeWidth;\n  var w = Math.max(0, shape.size[0] - sw / 2);\n  var h = Math.max(0, shape.size[1] - sw / 2);\n  var tl = core.Vec.add([sw / 2, sw / 2], offsets[0]);\n  var tr = core.Vec.add([w, sw / 2], offsets[1]);\n  var br = core.Vec.add([w, h], offsets[2]);\n  var bl = core.Vec.add([sw / 2, h], offsets[3]);\n  var lines = core.Utils.shuffleArr([core.Vec.pointsBetween(tr, br), core.Vec.pointsBetween(br, bl), core.Vec.pointsBetween(bl, tl), core.Vec.pointsBetween(tl, tr)], Math.floor(5 + getRandom() * 4));\n  var stroke = getStroke__default([].concat(lines.flat().slice(2), lines[0], lines[0].slice(4)), {\n    size: 1 + +styles.strokeWidth,\n    thinning: 0.6,\n    easing: function easing(t) {\n      return t * t * t * t;\n    },\n    end: {\n      taper: +styles.strokeWidth * 20\n    },\n    start: {\n      taper: +styles.strokeWidth * 20\n    },\n    simulatePressure: false\n  });\n  return core.Utils.getSvgPathFromStroke(stroke);\n}\n\nvar Ellipse = /*#__PURE__*/function (_TLDrawShapeUtil) {\n  _inheritsLoose(Ellipse, _TLDrawShapeUtil);\n\n  function Ellipse() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _TLDrawShapeUtil.call.apply(_TLDrawShapeUtil, [this].concat(args)) || this;\n    _this.type = exports.TLDrawShapeType.Ellipse;\n    _this.toolType = exports.TLDrawToolType.Bounds;\n    _this.pathCache = new WeakMap([]);\n    _this.defaultProps = {\n      id: 'id',\n      type: exports.TLDrawShapeType.Ellipse,\n      name: 'Ellipse',\n      parentId: 'page',\n      childIndex: 1,\n      point: [0, 0],\n      radius: [1, 1],\n      rotation: 0,\n      style: defaultStyle\n    };\n    return _this;\n  }\n\n  var _proto = Ellipse.prototype;\n\n  _proto.render = function render(shape, _ref) {\n    var _this2 = this;\n\n    var isDarkMode = _ref.isDarkMode,\n        isBinding = _ref.isBinding;\n    var _shape$radius = shape.radius,\n        radiusX = _shape$radius[0],\n        radiusY = _shape$radius[1],\n        style = shape.style;\n    var styles = getShapeStyle(style, isDarkMode);\n    var strokeWidth = +styles.strokeWidth;\n    var rx = Math.max(0, radiusX - strokeWidth / 2);\n    var ry = Math.max(0, radiusY - strokeWidth / 2);\n\n    if (style.dash === exports.DashStyle.Draw) {\n      var path = core.Utils.getFromCache(this.pathCache, shape, function () {\n        return renderPath$1(shape, _this2.getCenter(shape));\n      });\n      return React.createElement(React.Fragment, null, isBinding && React.createElement(\"ellipse\", {\n        className: \"tl-binding-indicator\",\n        cx: radiusX,\n        cy: radiusY,\n        rx: rx + 2,\n        ry: ry + 2\n      }), React.createElement(\"ellipse\", {\n        cx: radiusX,\n        cy: radiusY,\n        rx: rx,\n        ry: ry,\n        stroke: \"none\",\n        fill: style.isFilled ? styles.fill : 'transparent',\n        pointerEvents: \"all\"\n      }), React.createElement(\"path\", {\n        d: path,\n        fill: styles.stroke,\n        stroke: styles.stroke,\n        strokeWidth: strokeWidth,\n        pointerEvents: \"all\",\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\"\n      }));\n    }\n\n    var h = Math.pow(rx - ry, 2) / Math.pow(rx + ry, 2);\n    var perimeter = Math.PI * (rx + ry) * (1 + 3 * h / (10 + Math.sqrt(4 - 3 * h)));\n\n    var _getPerfectDashProps = getPerfectDashProps(perimeter, strokeWidth * 1.618, shape.style.dash, 4),\n        strokeDasharray = _getPerfectDashProps.strokeDasharray,\n        strokeDashoffset = _getPerfectDashProps.strokeDashoffset;\n\n    var sw = strokeWidth * 1.618;\n    return React.createElement(React.Fragment, null, isBinding && React.createElement(\"ellipse\", {\n      className: \"tl-binding-indicator\",\n      cx: radiusX,\n      cy: radiusY,\n      rx: rx + 32,\n      ry: ry + 32\n    }), React.createElement(\"ellipse\", {\n      cx: radiusX,\n      cy: radiusY,\n      rx: rx,\n      ry: ry,\n      fill: styles.fill,\n      stroke: styles.stroke,\n      strokeWidth: sw,\n      strokeDasharray: strokeDasharray,\n      strokeDashoffset: strokeDashoffset,\n      pointerEvents: \"all\",\n      strokeLinecap: \"round\",\n      strokeLinejoin: \"round\"\n    }));\n  };\n\n  _proto.getBounds = function getBounds(shape) {\n    return core.Utils.getFromCache(this.boundsCache, shape, function () {\n      return core.Utils.getRotatedEllipseBounds(shape.point[0], shape.point[1], shape.radius[0], shape.radius[1], shape.rotation || 0);\n    });\n  };\n\n  _proto.getRotatedBounds = function getRotatedBounds(shape) {\n    return core.Utils.getBoundsFromPoints(core.Utils.getRotatedCorners(this.getBounds(shape), shape.rotation));\n  };\n\n  _proto.getCenter = function getCenter(shape) {\n    return core.Utils.getBoundsCenter(this.getBounds(shape));\n  };\n\n  _proto.hitTest = function hitTest(shape, point) {\n    return core.Utils.pointInBounds(point, this.getBounds(shape));\n  };\n\n  _proto.hitTestBounds = function hitTestBounds(shape, bounds) {\n    var rotatedCorners = core.Utils.getRotatedCorners(this.getBounds(shape), shape.rotation);\n    return rotatedCorners.every(function (point) {\n      return core.Utils.pointInBounds(point, bounds);\n    }) || core.Intersect.polyline.bounds(rotatedCorners, bounds).length > 0;\n  };\n\n  _proto.transform = function transform(shape, bounds, _ref2) {\n    var scaleX = _ref2.scaleX,\n        scaleY = _ref2.scaleY,\n        initialShape = _ref2.initialShape;\n    var _initialShape$rotatio = initialShape.rotation,\n        rotation = _initialShape$rotatio === void 0 ? 0 : _initialShape$rotatio;\n    return {\n      point: [bounds.minX, bounds.minY],\n      radius: [bounds.width / 2, bounds.height / 2],\n      rotation: scaleX < 0 && scaleY >= 0 || scaleY < 0 && scaleX >= 0 ? -(rotation || 0) : rotation || 0\n    };\n  };\n\n  _proto.transformSingle = function transformSingle(shape, bounds) {\n    return {\n      point: core.Vec.round([bounds.minX, bounds.minY]),\n      radius: core.Vec.div([bounds.width, bounds.height], 2)\n    };\n  };\n\n  return Ellipse;\n}(TLDrawShapeUtil);\n\nfunction renderPath$1(shape, boundsCenter) {\n  var style = shape.style,\n      id = shape.id,\n      _shape$radius2 = shape.radius,\n      radiusX = _shape$radius2[0],\n      radiusY = _shape$radius2[1],\n      point = shape.point;\n  var getRandom = core.Utils.rng(id);\n  var center = core.Vec.sub(boundsCenter, point);\n  var strokeWidth = +getShapeStyle(style).strokeWidth;\n  var rx = radiusX + getRandom() * strokeWidth - strokeWidth / 2;\n  var ry = radiusY + getRandom() * strokeWidth - strokeWidth / 2;\n  var points = [];\n  var start = Math.PI + Math.PI * getRandom();\n  var overlap = Math.PI / 12;\n\n  for (var i = 2; i < 8; i++) {\n    var rads = start + overlap * 2 * (i / 8);\n    var x = rx * Math.cos(rads) + center[0];\n    var y = ry * Math.sin(rads) + center[1];\n    points.push([x, y]);\n  }\n\n  for (var _i = 5; _i < 32; _i++) {\n    var t = _i / 35;\n\n    var _rads = start + overlap * 2 + Math.PI * 2.5 * (t * t * t);\n\n    var _x = rx * Math.cos(_rads) + center[0];\n\n    var _y = ry * Math.sin(_rads) + center[1];\n\n    points.push([_x, _y]);\n  }\n\n  for (var _i2 = 0; _i2 < 8; _i2++) {\n    var _rads2 = start + overlap * 2 * (_i2 / 4);\n\n    var _x2 = rx * Math.cos(_rads2) + center[0];\n\n    var _y2 = ry * Math.sin(_rads2) + center[1];\n\n    points.push([_x2, _y2]);\n  }\n\n  var stroke = getStroke__default(points, {\n    size: 1 + strokeWidth,\n    thinning: 0.6,\n    easing: function easing(t) {\n      return t * t * t * t;\n    },\n    end: {\n      taper: strokeWidth * 20\n    },\n    start: {\n      taper: strokeWidth * 20\n    },\n    simulatePressure: false\n  });\n  return core.Utils.getSvgPathFromStroke(stroke);\n}\n\nvar tldrawShapeUtils = {\n  rectangle: /*#__PURE__*/new Rectangle(),\n  ellipse: /*#__PURE__*/new Ellipse(),\n  draw: /*#__PURE__*/new Draw(),\n  arrow: /*#__PURE__*/new Arrow()\n};\nfunction getShapeUtils(shape) {\n  return tldrawShapeUtils[shape.type];\n}\nfunction createShape(type, props) {\n  return tldrawShapeUtils[type].create(props);\n}\n\nfunction useKeyboardShortcuts(tlstate) {\n  React__default.useEffect(function () {\n    var handleKeyDown = function handleKeyDown(e) {\n      var info = core.inputs.keydown(e);\n      tlstate.onKeyDown(e.key, info);\n    };\n\n    var handleKeyUp = function handleKeyUp(e) {\n      var info = core.inputs.keyup(e);\n      tlstate.onKeyUp(e.key, info);\n    };\n\n    window.addEventListener('keydown', handleKeyDown);\n    window.addEventListener('keyup', handleKeyUp);\n    return function () {\n      window.removeEventListener('keydown', handleKeyDown);\n      window.removeEventListener('keyup', handleKeyUp);\n    };\n  }, [tlstate]);\n  reactHotkeysHook.useHotkeys('command+z', function (e) {\n    tlstate.undo();\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('ctrl+shift-z,command+shift+z', function (e) {\n    tlstate.redo();\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('ctrl+d,command+d', function (e) {\n    tlstate.duplicate();\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('ctrl+s,command+s', function (e) {\n    tlstate.save();\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('ctrl+=,command+=', function (e) {\n    tlstate.zoomIn();\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('ctrl+-,command+-', function (e) {\n    tlstate.zoomOut();\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('shift+1', function (e) {\n    tlstate.zoomToFit();\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('shift+2', function (e) {\n    tlstate.zoomToSelection();\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('shift+0', function (e) {\n    tlstate.zoomToActual();\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('escape', function (e) {\n    tlstate.cancel();\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('backspace', function (e) {\n    tlstate[\"delete\"]();\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('command+a,ctrl+a', function (e) {\n    tlstate.selectAll();\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('up', function (e) {\n    tlstate.nudge([0, -1], false);\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('right', function (e) {\n    tlstate.nudge([1, 0], false);\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('down', function (e) {\n    tlstate.nudge([0, 1], false);\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('left', function (e) {\n    tlstate.nudge([-1, 0], false);\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('shift+up', function (e) {\n    tlstate.nudge([0, -1], true);\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('shift+right', function (e) {\n    tlstate.nudge([1, 0], true);\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('shift+down', function (e) {\n    tlstate.nudge([0, 1], true);\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('shift+left', function (e) {\n    tlstate.nudge([-1, 0], true);\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('[', function (e) {\n    tlstate.moveBackward();\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys(']', function (e) {\n    tlstate.moveForward();\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('shift+[', function (e) {\n    tlstate.moveToBack();\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('shift+]', function (e) {\n    tlstate.moveToFront();\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('v,1', function (e) {\n    tlstate.selectTool('select');\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('d,2', function (e) {\n    tlstate.selectTool(exports.TLDrawShapeType.Draw);\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('r,3', function (e) {\n    tlstate.selectTool(exports.TLDrawShapeType.Rectangle);\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('e,4', function (e) {\n    tlstate.selectTool(exports.TLDrawShapeType.Ellipse);\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('a,5', function (e) {\n    tlstate.selectTool(exports.TLDrawShapeType.Arrow);\n    e.preventDefault();\n  });\n}\n\nvar TLDrawContext = /*#__PURE__*/React.createContext({});\nfunction useTLDrawContext() {\n  var context = React.useContext(TLDrawContext);\n  return context;\n}\n\nfunction useTheme() {\n  return {\n    theme: 'light',\n    toggle: function toggle() {\n      return null;\n    }\n  };\n}\n\nvar _createCss = /*#__PURE__*/react.createCss({\n  themeMap: /*#__PURE__*/_extends({}, react.defaultThemeMap),\n  theme: {\n    colors: {\n      codeHl: 'rgba(144, 144, 144, .15)',\n      brushFill: 'rgba(0,0,0,.05)',\n      brushStroke: 'rgba(0,0,0,.25)',\n      hint: 'rgba(216, 226, 249, 1.000)',\n      selected: 'rgba(66, 133, 244, 1.000)',\n      bounds: 'rgba(65, 132, 244, 1.000)',\n      boundsBg: 'rgba(65, 132, 244, 0.05)',\n      highlight: 'rgba(65, 132, 244, 0.15)',\n      overlay: 'rgba(0, 0, 0, 0.15)',\n      overlayContrast: 'rgba(255, 255, 255, 0.15)',\n      border: '#aaaaaa',\n      canvas: '#f8f9fa',\n      panel: '#fefefe',\n      inactive: '#cccccf',\n      hover: '#efefef',\n      text: '#333333',\n      tooltipBg: '#1d1d1d',\n      tooltipText: '#ffffff',\n      muted: '#777777',\n      input: '#f3f3f3',\n      inputBorder: '#dddddd',\n      warn: 'rgba(255, 100, 100, 1)',\n      lineError: 'rgba(255, 0, 0, .1)'\n    },\n    shadows: {\n      2: '0px 1px 1px rgba(0, 0, 0, 0.14)',\n      3: '0px 2px 3px rgba(0, 0, 0, 0.14)',\n      4: '0px 4px 5px -1px rgba(0, 0, 0, 0.14)',\n      8: '0px 12px 17px rgba(0, 0, 0, 0.14)',\n      12: '0px 12px 17px rgba(0, 0, 0, 0.14)',\n      24: '0px 24px 38px rgba(0, 0, 0, 0.14)',\n      key: '1px 1px rgba(0,0,0,1)'\n    },\n    space: {\n      0: '2px',\n      1: '3px',\n      2: '4px',\n      3: '8px',\n      4: '12px',\n      5: '16px'\n    },\n    fontSizes: {\n      0: '10px',\n      1: '12px',\n      2: '13px',\n      3: '16px',\n      4: '18px'\n    },\n    fonts: {\n      ui: '\"Recursive\", system-ui, sans-serif',\n      body: '\"Recursive\", system-ui, sans-serif',\n      mono: '\"Recursive Mono\", monospace'\n    },\n    fontWeights: {},\n    lineHeights: {},\n    letterSpacings: {},\n    sizes: {},\n    borderWidths: {\n      0: '$1'\n    },\n    borderStyles: {},\n    radii: {\n      0: '2px',\n      1: '4px',\n      2: '8px'\n    },\n    zIndices: {},\n    transitions: {}\n  },\n  media: {\n    sm: '(min-width: 640px)',\n    md: '(min-width: 768px)'\n  },\n  utils: {\n    zDash: function zDash() {\n      return function (value) {\n        return {\n          strokeDasharray: \"calc(\" + value + \"px / var(--camera-zoom)) calc(\" + value + \"px / var(--camera-zoom))\"\n        };\n      };\n    },\n    zStrokeWidth: function zStrokeWidth() {\n      return function (value) {\n        if (Array.isArray(value)) {\n          return {\n            strokeWidth: \"calc(\" + value[0] + \"px / var(--camera-zoom))\"\n          };\n        }\n\n        return {\n          strokeWidth: \"calc(\" + value + \"px / var(--camera-zoom))\"\n        };\n      };\n    }\n  }\n}),\n    styled = _createCss.styled;\n\nfunction commandKey() {\n  return core.Utils.isDarwin() ? '' : 'Ctrl';\n}\nfunction Kbd(_ref) {\n  var variant = _ref.variant,\n      children = _ref.children;\n  if (core.Utils.isMobile()) return null;\n  return React.createElement(StyledKbd, {\n    variant: variant\n  }, children.replaceAll('#', commandKey()).split('').map(function (k, i) {\n    return React.createElement(\"span\", {\n      key: i\n    }, k);\n  }));\n}\nvar StyledKbd = /*#__PURE__*/styled('kbd', {\n  marginLeft: '$3',\n  textShadow: '$2',\n  textAlign: 'center',\n  fontSize: '$0',\n  fontFamily: '$ui',\n  fontWeight: 400,\n  gap: '$1',\n  display: 'flex',\n  alignItems: 'center',\n  '& > span': {\n    padding: '$0',\n    borderRadius: '$0',\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'center'\n  },\n  variants: {\n    variant: {\n      tooltip: {\n        '& > span': {\n          background: '$overlayContrast',\n          boxShadow: '$key',\n          width: '20px',\n          height: '20px'\n        }\n      },\n      menu: {}\n    }\n  }\n});\n\nfunction Tooltip(_ref) {\n  var children = _ref.children,\n      label = _ref.label,\n      kbd = _ref.kbd,\n      _ref$side = _ref.side,\n      side = _ref$side === void 0 ? 'top' : _ref$side;\n  return React__default.createElement(RadixTooltip.Root, null, React__default.createElement(RadixTooltip.Trigger, {\n    as: \"span\"\n  }, children), React__default.createElement(StyledContent, {\n    side: side,\n    sideOffset: 8\n  }, label, kbd ? React__default.createElement(Kbd, {\n    variant: \"tooltip\"\n  }, kbd) : null, React__default.createElement(StyledArrow, null)));\n}\nvar StyledContent = /*#__PURE__*/styled(RadixTooltip.Content, {\n  borderRadius: 3,\n  padding: '$3 $3 $3 $3',\n  fontSize: '$1',\n  backgroundColor: '$tooltipBg',\n  color: '$tooltipText',\n  boxShadow: '$3',\n  display: 'flex',\n  alignItems: 'center',\n  fontFamily: '$ui'\n});\nvar StyledArrow = /*#__PURE__*/styled(RadixTooltip.Arrow, {\n  fill: '$tooltipBg',\n  margin: '0 8px'\n});\n\nvar _excluded = [\"size\"];\n\nvar _pageButton;\nvar breakpoints = {\n  '@initial': 'mobile',\n  '@sm': 'small'\n};\nvar IconButton = /*#__PURE__*/styled('button', {\n  position: 'relative',\n  height: '32px',\n  width: '32px',\n  backgroundColor: '$panel',\n  borderRadius: '4px',\n  padding: '0',\n  margin: '0',\n  display: 'grid',\n  alignItems: 'center',\n  justifyContent: 'center',\n  outline: 'none',\n  border: 'none',\n  pointerEvents: 'all',\n  fontSize: '$0',\n  color: '$text',\n  cursor: 'pointer',\n  '& > *': {\n    gridRow: 1,\n    gridColumn: 1\n  },\n  '&:disabled': {\n    opacity: '0.5'\n  },\n  '& > span': {\n    width: '100%',\n    height: '100%',\n    display: 'flex',\n    alignItems: 'center'\n  },\n  variants: {\n    bp: {\n      mobile: {\n        backgroundColor: 'transparent'\n      },\n      small: {\n        '&:hover:not(:disabled)': {\n          backgroundColor: '$hover'\n        }\n      }\n    },\n    size: {\n      small: {\n        height: 32,\n        width: 32,\n        '& svg:nth-of-type(1)': {\n          height: '16px',\n          width: '16px'\n        }\n      },\n      medium: {\n        height: 44,\n        width: 44,\n        '& svg:nth-of-type(1)': {\n          height: '18px',\n          width: '18px'\n        }\n      },\n      large: {\n        height: 44,\n        width: 44,\n        '& svg:nth-of-type(1)': {\n          height: '20px',\n          width: '20px'\n        }\n      }\n    },\n    isActive: {\n      \"true\": {\n        color: '$selected'\n      }\n    }\n  }\n});\nvar RowButton = /*#__PURE__*/styled('button', {\n  position: 'relative',\n  display: 'flex',\n  width: '100%',\n  background: 'none',\n  height: '32px',\n  border: 'none',\n  cursor: 'pointer',\n  color: '$text',\n  outline: 'none',\n  alignItems: 'center',\n  fontFamily: '$ui',\n  fontWeight: 400,\n  fontSize: '$1',\n  justifyContent: 'space-between',\n  padding: '4px 8px 4px 12px',\n  borderRadius: 4,\n  userSelect: 'none',\n  '& label': {\n    fontWeight: '$1',\n    margin: 0,\n    padding: 0\n  },\n  '& svg': {\n    position: 'relative',\n    stroke: '$overlay',\n    strokeWidth: 1,\n    zIndex: 1\n  },\n  '&[data-disabled]': {\n    opacity: 0.3\n  },\n  '&:disabled': {\n    opacity: 0.3\n  },\n  variants: {\n    bp: {\n      mobile: {},\n      small: {\n        '& *[data-shy=\"true\"]': {\n          opacity: 0\n        },\n        '&:hover:not(:disabled)': {\n          backgroundColor: '$hover',\n          '& *[data-shy=\"true\"]': {\n            opacity: 1\n          }\n        }\n      }\n    },\n    size: {\n      icon: {\n        padding: '4px ',\n        width: 'auto'\n      }\n    },\n    variant: {\n      noIcon: {\n        padding: '4px 12px'\n      },\n      pageButton: (_pageButton = {\n        display: 'grid',\n        gridTemplateColumns: '24px auto',\n        width: '100%',\n        paddingLeft: '$1',\n        gap: '$3',\n        justifyContent: 'flex-start'\n      }, _pageButton[\"& > *[data-state=\\\"checked\\\"]\"] = {\n        gridRow: 1,\n        gridColumn: 1\n      }, _pageButton['& > span'] = {\n        gridRow: 1,\n        gridColumn: 2,\n        width: '100%'\n      }, _pageButton)\n    },\n    warn: {\n      \"true\": {\n        color: '$warn'\n      }\n    },\n    isActive: {\n      \"true\": {\n        backgroundColor: '$hover'\n      }\n    }\n  }\n});\nvar IconWrapper = /*#__PURE__*/styled('div', {\n  height: '100%',\n  borderRadius: '4px',\n  marginRight: '1px',\n  display: 'grid',\n  alignItems: 'center',\n  justifyContent: 'center',\n  outline: 'none',\n  border: 'none',\n  pointerEvents: 'all',\n  cursor: 'pointer',\n  color: '$text',\n  '& svg': {\n    height: 22,\n    width: 22,\n    strokeWidth: 1\n  },\n  '& > *': {\n    gridRow: 1,\n    gridColumn: 1\n  },\n  variants: {\n    size: {\n      small: {\n        '& svg': {\n          height: '16px',\n          width: '16px'\n        }\n      },\n      medium: {\n        '& svg': {\n          height: '22px',\n          width: '22px'\n        }\n      }\n    }\n  }\n});\nvar ButtonsRow = /*#__PURE__*/styled('div', {\n  position: 'relative',\n  display: 'flex',\n  width: '100%',\n  background: 'none',\n  border: 'none',\n  cursor: 'pointer',\n  outline: 'none',\n  alignItems: 'center',\n  justifyContent: 'flex-start',\n  padding: 0\n});\nvar FloatingContainer = /*#__PURE__*/styled('div', {\n  backgroundColor: '$panel',\n  border: '1px solid $panel',\n  borderRadius: '4px',\n  boxShadow: '$4',\n  display: 'flex',\n  height: 'fit-content',\n  padding: '$0',\n  pointerEvents: 'all',\n  position: 'relative',\n  userSelect: 'none',\n  zIndex: 200,\n  variants: {\n    direction: {\n      row: {\n        flexDirection: 'row'\n      },\n      column: {\n        flexDirection: 'column'\n      }\n    },\n    elevation: {\n      0: {\n        boxShadow: 'none'\n      },\n      2: {\n        boxShadow: '$2'\n      },\n      3: {\n        boxShadow: '$3'\n      },\n      4: {\n        boxShadow: '$4'\n      }\n    }\n  }\n});\n/* -------------------------------------------------- */\n\n/*                        Menus                       */\n\n/* -------------------------------------------------- */\n\nvar MenuContent = /*#__PURE__*/styled('div', {\n  position: 'relative',\n  overflow: 'hidden',\n  userSelect: 'none',\n  zIndex: 180,\n  minWidth: 180,\n  pointerEvents: 'all',\n  backgroundColor: '$panel',\n  border: '1px solid $panel',\n  padding: '$0',\n  boxShadow: '$4',\n  borderRadius: '4px',\n  font: '$ui'\n});\nvar Divider = /*#__PURE__*/styled('div', {\n  backgroundColor: '$hover',\n  height: 1,\n  marginTop: '$2',\n  marginRight: '-$2',\n  marginBottom: '$2',\n  marginLeft: '-$2'\n});\nfunction DropdownMenuIconTriggerButton(_ref6) {\n  var label = _ref6.label,\n      kbd = _ref6.kbd,\n      children = _ref6.children,\n      _ref6$disabled = _ref6.disabled,\n      disabled = _ref6$disabled === void 0 ? false : _ref6$disabled;\n  return React__default.createElement(DropdownMenu.Trigger, {\n    as: IconButton,\n    bp: breakpoints,\n    disabled: disabled\n  }, React__default.createElement(Tooltip, {\n    label: label,\n    kbd: kbd\n  }, children));\n}\n/* -------------------------------------------------- */\n\n/*                    Context Menu                   */\n\n/* -------------------------------------------------- */\n\nfunction ContextMenuRoot(_ref8) {\n  var onOpenChange = _ref8.onOpenChange,\n      children = _ref8.children;\n  return React__default.createElement(RadixContextMenu.Root, {\n    dir: \"ltr\",\n    onOpenChange: onOpenChange\n  }, children);\n}\nfunction ContextMenuSubMenu(_ref9) {\n  var children = _ref9.children,\n      label = _ref9.label;\n  return React__default.createElement(RadixContextMenu.Root, {\n    dir: \"ltr\"\n  }, React__default.createElement(RadixContextMenu.TriggerItem, {\n    as: RowButton,\n    bp: breakpoints\n  }, React__default.createElement(\"span\", null, label), React__default.createElement(IconWrapper, {\n    size: \"small\"\n  }, React__default.createElement(reactIcons.ChevronRightIcon, null))), React__default.createElement(RadixContextMenu.Content, {\n    as: MenuContent,\n    sideOffset: 2,\n    alignOffset: -2\n  }, children, React__default.createElement(ContextMenuArrow, {\n    offset: 13\n  })));\n}\nvar ContextMenuDivider = /*#__PURE__*/styled(RadixContextMenu.Separator, {\n  backgroundColor: '$hover',\n  height: 1,\n  margin: '$2 -$2'\n});\nvar ContextMenuArrow = /*#__PURE__*/styled(RadixContextMenu.Arrow, {\n  fill: '$panel'\n});\nfunction ContextMenuButton(_ref10) {\n  var onSelect = _ref10.onSelect,\n      children = _ref10.children,\n      _ref10$disabled = _ref10.disabled,\n      disabled = _ref10$disabled === void 0 ? false : _ref10$disabled;\n  return React__default.createElement(RowButton, {\n    as: RadixContextMenu.Item,\n    bp: breakpoints,\n    disabled: disabled,\n    onSelect: onSelect\n  }, children);\n}\nfunction ContextMenuIconButton(_ref11) {\n  var onSelect = _ref11.onSelect,\n      children = _ref11.children,\n      _ref11$disabled = _ref11.disabled,\n      disabled = _ref11$disabled === void 0 ? false : _ref11$disabled;\n  return React__default.createElement(RadixContextMenu.Item, {\n    as: IconButton,\n    bp: breakpoints,\n    disabled: disabled,\n    onSelect: onSelect\n  }, children);\n}\nfunction CircleIcon(props) {\n  var _props$size = props.size,\n      size = _props$size === void 0 ? 16 : _props$size,\n      rest = _objectWithoutPropertiesLoose(props, _excluded);\n\n  return React__default.createElement(\"svg\", _extends({\n    width: 24,\n    height: 24\n  }, rest), React__default.createElement(\"circle\", {\n    cx: 12,\n    cy: 12,\n    r: size / 2\n  }));\n}\n\n(function (MoveType) {\n  MoveType[\"Backward\"] = \"backward\";\n  MoveType[\"Forward\"] = \"forward\";\n  MoveType[\"ToFront\"] = \"toFront\";\n  MoveType[\"ToBack\"] = \"toBack\";\n})(exports.MoveType || (exports.MoveType = {}));\n\n(function (AlignType) {\n  AlignType[\"Top\"] = \"top\";\n  AlignType[\"CenterVertical\"] = \"centerVertical\";\n  AlignType[\"Bottom\"] = \"bottom\";\n  AlignType[\"Left\"] = \"left\";\n  AlignType[\"CenterHorizontal\"] = \"centerHorizontal\";\n  AlignType[\"Right\"] = \"right\";\n})(exports.AlignType || (exports.AlignType = {}));\n\n(function (StretchType) {\n  StretchType[\"Horizontal\"] = \"horizontal\";\n  StretchType[\"Vertical\"] = \"vertical\";\n})(exports.StretchType || (exports.StretchType = {}));\n\n(function (DistributeType) {\n  DistributeType[\"Horizontal\"] = \"horizontal\";\n  DistributeType[\"Vertical\"] = \"vertical\";\n})(exports.DistributeType || (exports.DistributeType = {}));\n\nvar has1SelectedIdsSelector = function has1SelectedIdsSelector(s) {\n  return s.pageState.selectedIds.length > 0;\n};\n\nvar has2SelectedIdsSelector = function has2SelectedIdsSelector(s) {\n  return s.pageState.selectedIds.length > 1;\n};\n\nvar has3SelectedIdsSelector = function has3SelectedIdsSelector(s) {\n  return s.pageState.selectedIds.length > 2;\n};\n\nvar isDebugModeSelector = function isDebugModeSelector(s) {\n  return s.settings.isDebugMode;\n};\n\nvar hasGroupSelectedSelector = function hasGroupSelectedSelector(s) {\n  return s.pageState.selectedIds.some(function (id) {\n    return s.page.shapes[id].children !== undefined;\n  });\n};\n\nvar ContextMenu = /*#__PURE__*/React.memo(function (_ref) {\n  var children = _ref.children;\n\n  var _useTLDrawContext = useTLDrawContext(),\n      tlstate = _useTLDrawContext.tlstate,\n      useAppState = _useTLDrawContext.useAppState;\n\n  var hasSelection = useAppState(has1SelectedIdsSelector);\n  var hasTwoOrMore = useAppState(has2SelectedIdsSelector);\n  var hasThreeOrMore = useAppState(has3SelectedIdsSelector);\n  var isDebugMode = useAppState(isDebugModeSelector);\n  var hasGroupSelected = useAppState(hasGroupSelectedSelector);\n  var rContent = React.useRef(null);\n  var handleDuplicate = React.useCallback(function () {\n    tlstate.duplicate();\n  }, [tlstate]);\n  var handleGroup = React.useCallback(function () {\n    tlstate.group();\n  }, [tlstate]);\n  var handleMoveToBack = React.useCallback(function () {\n    tlstate.moveToBack();\n  }, [tlstate]);\n  var handleMoveBackward = React.useCallback(function () {\n    tlstate.moveBackward();\n  }, [tlstate]);\n  var handleMoveForward = React.useCallback(function () {\n    tlstate.moveForward();\n  }, [tlstate]);\n  var handleMoveToFront = React.useCallback(function () {\n    tlstate.moveToFront();\n  }, [tlstate]);\n  var handleDelete = React.useCallback(function () {\n    tlstate[\"delete\"]();\n  }, [tlstate]);\n  var handleCopyAsJson = React.useCallback(function () {\n    tlstate.copyAsJson();\n  }, [tlstate]);\n  var handleCopyAsSvg = React.useCallback(function () {\n    tlstate.copyAsSvg();\n  }, [tlstate]);\n  var handleUndo = React.useCallback(function () {\n    tlstate.undo();\n  }, [tlstate]);\n  var handleRedo = React.useCallback(function () {\n    tlstate.redo();\n  }, [tlstate]);\n  return React.createElement(ContextMenuRoot, null, React.createElement(RadixContextMenu.Trigger, null, children), React.createElement(MenuContent, {\n    as: RadixContextMenu.Content,\n    ref: rContent\n  }, hasSelection ? React.createElement(React.Fragment, null, React.createElement(ContextMenuButton, {\n    onSelect: handleDuplicate\n  }, React.createElement(\"span\", null, \"Duplicate\"), React.createElement(Kbd, {\n    variant: \"menu\"\n  }, \"#D\")), React.createElement(ContextMenuDivider, null), hasGroupSelected || hasTwoOrMore && React.createElement(React.Fragment, null, hasGroupSelected && React.createElement(ContextMenuButton, {\n    onSelect: handleGroup\n  }, React.createElement(\"span\", null, \"Ungroup\"), React.createElement(Kbd, {\n    variant: \"menu\"\n  }, \"#\\u21E7G\")), hasTwoOrMore && React.createElement(ContextMenuButton, {\n    onSelect: handleGroup\n  }, React.createElement(\"span\", null, \"Group\"), React.createElement(Kbd, {\n    variant: \"menu\"\n  }, \"#G\"))), React.createElement(ContextMenuSubMenu, {\n    label: \"Move\"\n  }, React.createElement(ContextMenuButton, {\n    onSelect: handleMoveToFront\n  }, React.createElement(\"span\", null, \"To Front\"), React.createElement(Kbd, {\n    variant: \"menu\"\n  }, \"# \\u21E7 ]\")), React.createElement(ContextMenuButton, {\n    onSelect: handleMoveForward\n  }, React.createElement(\"span\", null, \"Forward\"), React.createElement(Kbd, {\n    variant: \"menu\"\n  }, \"# ]\")), React.createElement(ContextMenuButton, {\n    onSelect: handleMoveBackward\n  }, React.createElement(\"span\", null, \"Backward\"), React.createElement(Kbd, {\n    variant: \"menu\"\n  }, \"# [\")), React.createElement(ContextMenuButton, {\n    onSelect: handleMoveToBack\n  }, React.createElement(\"span\", null, \"To Back\"), React.createElement(Kbd, {\n    variant: \"menu\"\n  }, \"# \\u21E7 [\"))), hasTwoOrMore && React.createElement(AlignDistributeSubMenu, {\n    hasTwoOrMore: hasTwoOrMore,\n    hasThreeOrMore: hasThreeOrMore\n  }), isDebugMode && React.createElement(ContextMenuButton, {\n    onSelect: handleCopyAsJson\n  }, React.createElement(\"span\", null, \"Copy Data\"), React.createElement(Kbd, {\n    variant: \"menu\"\n  }, \"# \\u21E7 C\")), React.createElement(ContextMenuButton, {\n    onSelect: handleCopyAsSvg\n  }, React.createElement(\"span\", null, \"Copy to SVG\"), React.createElement(Kbd, {\n    variant: \"menu\"\n  }, \"# \\u21E7 C\")), React.createElement(ContextMenuDivider, null), React.createElement(ContextMenuButton, {\n    onSelect: handleDelete\n  }, React.createElement(\"span\", null, \"Delete\"), React.createElement(Kbd, {\n    variant: \"menu\"\n  }, \"\\u232B\"))) : React.createElement(React.Fragment, null, React.createElement(ContextMenuButton, {\n    onSelect: handleUndo\n  }, React.createElement(\"span\", null, \"Undo\"), React.createElement(Kbd, {\n    variant: \"menu\"\n  }, \"# Z\")), React.createElement(ContextMenuButton, {\n    onSelect: handleRedo\n  }, React.createElement(\"span\", null, \"Redo\"), React.createElement(Kbd, {\n    variant: \"menu\"\n  }, \"# \\u21E7 Z\")))));\n});\n\nfunction AlignDistributeSubMenu(_ref2) {\n  var hasThreeOrMore = _ref2.hasThreeOrMore;\n\n  var _useTLDrawContext2 = useTLDrawContext(),\n      tlstate = _useTLDrawContext2.tlstate;\n\n  var alignTop = React.useCallback(function () {\n    tlstate.align(exports.AlignType.Top);\n  }, [tlstate]);\n  var alignCenterVertical = React.useCallback(function () {\n    tlstate.align(exports.AlignType.CenterVertical);\n  }, [tlstate]);\n  var alignBottom = React.useCallback(function () {\n    tlstate.align(exports.AlignType.Bottom);\n  }, [tlstate]);\n  var stretchVertically = React.useCallback(function () {\n    tlstate.stretch(exports.StretchType.Vertical);\n  }, [tlstate]);\n  var distributeVertically = React.useCallback(function () {\n    tlstate.distribute(exports.DistributeType.Vertical);\n  }, [tlstate]);\n  var alignLeft = React.useCallback(function () {\n    tlstate.align(exports.AlignType.Left);\n  }, [tlstate]);\n  var alignCenterHorizontal = React.useCallback(function () {\n    tlstate.align(exports.AlignType.CenterHorizontal);\n  }, [tlstate]);\n  var alignRight = React.useCallback(function () {\n    tlstate.align(exports.AlignType.Right);\n  }, [tlstate]);\n  var stretchHorizontally = React.useCallback(function () {\n    tlstate.stretch(exports.StretchType.Horizontal);\n  }, [tlstate]);\n  var distributeHorizontally = React.useCallback(function () {\n    tlstate.distribute(exports.DistributeType.Horizontal);\n  }, [tlstate]);\n  return React.createElement(ContextMenuRoot, null, React.createElement(RadixContextMenu.TriggerItem, {\n    as: RowButton,\n    bp: breakpoints\n  }, React.createElement(\"span\", null, \"Align / Distribute\"), React.createElement(IconWrapper, {\n    size: \"small\"\n  }, React.createElement(reactIcons.ChevronRightIcon, null))), React.createElement(StyledGrid, {\n    as: RadixContextMenu.Content,\n    sideOffset: 2,\n    alignOffset: -2,\n    selectedStyle: hasThreeOrMore ? 'threeOrMore' : 'twoOrMore'\n  }, React.createElement(ContextMenuIconButton, {\n    onSelect: alignLeft\n  }, React.createElement(reactIcons.AlignLeftIcon, null)), React.createElement(ContextMenuIconButton, {\n    onSelect: alignCenterHorizontal\n  }, React.createElement(reactIcons.AlignCenterHorizontallyIcon, null)), React.createElement(ContextMenuIconButton, {\n    onSelect: alignRight\n  }, React.createElement(reactIcons.AlignRightIcon, null)), React.createElement(ContextMenuIconButton, {\n    onSelect: stretchHorizontally\n  }, React.createElement(reactIcons.StretchHorizontallyIcon, null)), hasThreeOrMore && React.createElement(ContextMenuIconButton, {\n    onSelect: distributeHorizontally\n  }, React.createElement(reactIcons.SpaceEvenlyHorizontallyIcon, null)), React.createElement(ContextMenuIconButton, {\n    onSelect: alignTop\n  }, React.createElement(reactIcons.AlignTopIcon, null)), React.createElement(ContextMenuIconButton, {\n    onSelect: alignCenterVertical\n  }, React.createElement(reactIcons.AlignCenterVerticallyIcon, null)), React.createElement(ContextMenuIconButton, {\n    onSelect: alignBottom\n  }, React.createElement(reactIcons.AlignBottomIcon, null)), React.createElement(ContextMenuIconButton, {\n    onSelect: stretchVertically\n  }, React.createElement(reactIcons.StretchVerticallyIcon, null)), hasThreeOrMore && React.createElement(ContextMenuIconButton, {\n    onSelect: distributeVertically\n  }, React.createElement(reactIcons.SpaceEvenlyVerticallyIcon, null)), React.createElement(ContextMenuArrow, {\n    offset: 13\n  })));\n}\n\nvar StyledGrid = /*#__PURE__*/styled(MenuContent, {\n  display: 'grid',\n  variants: {\n    selectedStyle: {\n      threeOrMore: {\n        gridTemplateColumns: 'repeat(5, auto)'\n      },\n      twoOrMore: {\n        gridTemplateColumns: 'repeat(4, auto)'\n      }\n    }\n  }\n}); // function MoveToPageMenu() {\n//   const documentPages = useSelector((s) => s.data.document.pages)\n//   const currentPageId = useSelector((s) => s.data.currentPageId)\n//   if (!documentPages[currentPageId]) return null\n//   const sorted = Object.values(documentPages)\n//     .sort((a, b) => a.childIndex - b.childIndex)\n//     .filter((a) => a.id !== currentPageId)\n//   if (sorted.length === 0) return null\n//   return (\n//     <ContextMenuRoot>\n//       <ContextMenuButton>\n//         <span>Move To Page</span>\n//         <IconWrapper size=\"small\">\n//           <ChevronRightIcon />\n//         </IconWrapper>\n//       </ContextMenuButton>\n//       <MenuContent as={RadixContextMenu.Content} sideOffset={2} alignOffset={-2}>\n//         {sorted.map(({ id, name }) => (\n//           <ContextMenuButton\n//             key={id}\n//             disabled={id === currentPageId}\n//             onSelect={() => state.send('MOVED_TO_PAGE', { id })}\n//           >\n//             <span>{name}</span>\n//           </ContextMenuButton>\n//         ))}\n//         <ContextMenuArrow offset={13} />\n//       </MenuContent>\n//     </ContextMenuRoot>\n//   )\n// }\n\nfunction SvgRedo(props) {\n  return React.createElement(\"svg\", _extends({\n    viewBox: \"0 0 15 15\",\n    fill: \"currentColor\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props), React.createElement(\"path\", {\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\",\n    d: \"M12.5 2.495a.5.5 0 00-.5.5v2.5H9.5a.5.5 0 100 1h3a.5.5 0 00.5-.5v-3a.5.5 0 00-.5-.5z\"\n  }), React.createElement(\"path\", {\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\",\n    d: \"M7.697 2.049a5 5 0 104.02 6.613.5.5 0 10-.944-.332 4 4 0 11-.946-4.16l.01.01 2.32 2.18a.5.5 0 00.685-.729l-2.314-2.175A5 5 0 007.697 2.05z\"\n  }));\n}\n\nfunction SvgTrash(props) {\n  return React.createElement(\"svg\", _extends({\n    viewBox: \"0 0 15 15\",\n    fill: \"currentColor\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props), React.createElement(\"path\", {\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\",\n    d: \"M2 4.656a.5.5 0 01.5-.5h9.7a.5.5 0 010 1H2.5a.5.5 0 01-.5-.5z\"\n  }), React.createElement(\"path\", {\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\",\n    d: \"M6.272 3a.578.578 0 00-.578.578v.578h3.311v-.578A.578.578 0 008.428 3H6.272zm3.733 1.156v-.578A1.578 1.578 0 008.428 2H6.272a1.578 1.578 0 00-1.578 1.578v.578H3.578a.5.5 0 00-.5.5V12.2a1.578 1.578 0 001.577 1.578h5.39a1.578 1.578 0 001.577-1.578V4.656a.5.5 0 00-.5-.5h-1.117zm-5.927 1V12.2a.578.578 0 00.577.578h5.39a.578.578 0 00.577-.578V5.156H4.078z\"\n  }), React.createElement(\"path\", {\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\",\n    d: \"M6.272 6.85a.5.5 0 01.5.5v3.233a.5.5 0 11-1 0V7.35a.5.5 0 01.5-.5zM8.428 6.85a.5.5 0 01.5.5v3.233a.5.5 0 11-1 0V7.35a.5.5 0 01.5-.5z\"\n  }));\n}\n\nfunction SvgUndo(props) {\n  return React.createElement(\"svg\", _extends({\n    viewBox: \"0 0 15 15\",\n    fill: \"currentColor\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props), React.createElement(\"path\", {\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\",\n    d: \"M2.5 2.495a.5.5 0 01.5.5v2.5h2.5a.5.5 0 110 1h-3a.5.5 0 01-.5-.5v-3a.5.5 0 01.5-.5z\"\n  }), React.createElement(\"path\", {\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\",\n    d: \"M7.303 2.049a5 5 0 11-4.02 6.613.5.5 0 01.944-.332 4 4 0 10.946-4.16l-.01.01-2.32 2.18a.5.5 0 01-.685-.729l2.314-2.175A5 5 0 017.303 2.05z\"\n  }));\n}\n\nvar isAllLockedSelector = function isAllLockedSelector(s) {\n  var selectedIds = s.pageState.selectedIds;\n  return selectedIds.every(function (id) {\n    return s.page.shapes[id].isLocked;\n  });\n};\n\nvar isAllAspectLockedSelector = function isAllAspectLockedSelector(s) {\n  var selectedIds = s.pageState.selectedIds;\n  return selectedIds.every(function (id) {\n    return s.page.shapes[id].isAspectRatioLocked;\n  });\n};\n\nvar isAllGroupedSelector = function isAllGroupedSelector(s) {\n  var selectedShapes = s.pageState.selectedIds.map(function (id) {\n    return s.page.shapes[id];\n  });\n  return selectedShapes.every(function (shape) {\n    return shape.children !== undefined || shape.parentId === selectedShapes[0].parentId && selectedShapes[0].parentId !== s.appState.currentPageId;\n  });\n};\n\nvar hasSelectionSelector = function hasSelectionSelector(s) {\n  return s.pageState.selectedIds.length > 0;\n};\n\nvar hasMultipleSelectionSelector = function hasMultipleSelectionSelector(s) {\n  return s.pageState.selectedIds.length > 1;\n};\n\nvar ShapesFunctions = /*#__PURE__*/React.memo(function () {\n  var _useTLDrawContext = useTLDrawContext(),\n      tlstate = _useTLDrawContext.tlstate,\n      useAppState = _useTLDrawContext.useAppState;\n\n  var isAllLocked = useAppState(isAllLockedSelector);\n  var isAllAspectLocked = useAppState(isAllAspectLockedSelector);\n  var isAllGrouped = useAppState(isAllGroupedSelector);\n  var hasSelection = useAppState(hasSelectionSelector);\n  var hasMultipleSelection = useAppState(hasMultipleSelectionSelector);\n  var handleRotate = React.useCallback(function () {\n    tlstate.rotate();\n  }, [tlstate]);\n  var handleDuplicate = React.useCallback(function () {\n    tlstate.duplicate();\n  }, [tlstate]);\n  var handleToggleLocked = React.useCallback(function () {\n    tlstate.toggleLocked();\n  }, [tlstate]);\n  var handleToggleAspectRatio = React.useCallback(function () {\n    tlstate.toggleAspectRatioLocked();\n  }, [tlstate]);\n  var handleGroup = React.useCallback(function () {\n    tlstate.group();\n  }, [tlstate]);\n  var handleMoveToBack = React.useCallback(function () {\n    tlstate.moveToBack();\n  }, [tlstate]);\n  var handleMoveBackward = React.useCallback(function () {\n    tlstate.moveBackward();\n  }, [tlstate]);\n  var handleMoveForward = React.useCallback(function () {\n    tlstate.moveForward();\n  }, [tlstate]);\n  var handleMoveToFront = React.useCallback(function () {\n    tlstate.moveToFront();\n  }, [tlstate]);\n  var handleDelete = React.useCallback(function () {\n    tlstate[\"delete\"]();\n  }, [tlstate]);\n  return React.createElement(React.Fragment, null, React.createElement(ButtonsRow, null, React.createElement(IconButton, {\n    bp: breakpoints,\n    disabled: !hasSelection,\n    size: \"small\",\n    onClick: handleDuplicate\n  }, React.createElement(Tooltip, {\n    label: \"Duplicate\",\n    kbd: \"#D\"\n  }, React.createElement(reactIcons.CopyIcon, null))), React.createElement(IconButton, {\n    disabled: !hasSelection,\n    size: \"small\",\n    onClick: handleRotate\n  }, React.createElement(Tooltip, {\n    label: \"Rotate\"\n  }, React.createElement(reactIcons.RotateCounterClockwiseIcon, null))), React.createElement(IconButton, {\n    bp: breakpoints,\n    disabled: !hasSelection,\n    size: \"small\",\n    onClick: handleToggleLocked\n  }, React.createElement(Tooltip, {\n    label: \"Toogle Locked\",\n    kbd: \"#L\"\n  }, isAllLocked ? React.createElement(reactIcons.LockClosedIcon, null) : React.createElement(reactIcons.LockOpen1Icon, {\n    opacity: 0.4\n  }))), React.createElement(IconButton, {\n    bp: breakpoints,\n    disabled: !hasSelection,\n    size: \"small\",\n    onClick: handleToggleAspectRatio\n  }, React.createElement(Tooltip, {\n    label: \"Toogle Aspect Ratio Lock\"\n  }, React.createElement(reactIcons.AspectRatioIcon, {\n    opacity: isAllAspectLocked ? 1 : 0.4\n  }))), React.createElement(IconButton, {\n    bp: breakpoints,\n    disabled: !isAllGrouped && !hasMultipleSelection,\n    size: \"small\",\n    onClick: handleGroup\n  }, React.createElement(Tooltip, {\n    label: \"Group\",\n    kbd: \"#G\"\n  }, React.createElement(reactIcons.GroupIcon, {\n    opacity: isAllGrouped ? 1 : 0.4\n  })))), React.createElement(ButtonsRow, null, React.createElement(IconButton, {\n    bp: breakpoints,\n    disabled: !hasSelection,\n    size: \"small\",\n    onClick: handleMoveToBack\n  }, React.createElement(Tooltip, {\n    label: \"Move to Back\",\n    kbd: \"#\\u21E7[\"\n  }, React.createElement(reactIcons.PinBottomIcon, null))), React.createElement(IconButton, {\n    bp: breakpoints,\n    disabled: !hasSelection,\n    size: \"small\",\n    onClick: handleMoveBackward\n  }, React.createElement(Tooltip, {\n    label: \"Move Backward\",\n    kbd: \"#[\"\n  }, React.createElement(reactIcons.ArrowDownIcon, null))), React.createElement(IconButton, {\n    bp: breakpoints,\n    disabled: !hasSelection,\n    size: \"small\",\n    onClick: handleMoveForward\n  }, React.createElement(Tooltip, {\n    label: \"Move Forward\",\n    kbd: \"#]\"\n  }, React.createElement(reactIcons.ArrowUpIcon, null))), React.createElement(IconButton, {\n    bp: breakpoints,\n    disabled: !hasSelection,\n    size: \"small\",\n    onClick: handleMoveToFront\n  }, React.createElement(Tooltip, {\n    label: \"More to Front\",\n    kbd: \"#\\u21E7]\"\n  }, React.createElement(reactIcons.PinTopIcon, null))), React.createElement(IconButton, {\n    bp: breakpoints,\n    disabled: !hasSelection,\n    size: \"small\",\n    onClick: handleDelete\n  }, React.createElement(Tooltip, {\n    label: \"Delete\",\n    kbd: \"\\u232B\"\n  }, React.createElement(SvgTrash, null)))));\n});\n\nvar AlignDistribute = /*#__PURE__*/React.memo(function (_ref) {\n  var hasTwoOrMore = _ref.hasTwoOrMore,\n      hasThreeOrMore = _ref.hasThreeOrMore;\n\n  var _useTLDrawContext = useTLDrawContext(),\n      tlstate = _useTLDrawContext.tlstate;\n\n  var alignTop = React.useCallback(function () {\n    tlstate.align(exports.AlignType.Top);\n  }, [tlstate]);\n  var alignCenterVertical = React.useCallback(function () {\n    tlstate.align(exports.AlignType.CenterVertical);\n  }, [tlstate]);\n  var alignBottom = React.useCallback(function () {\n    tlstate.align(exports.AlignType.Bottom);\n  }, [tlstate]);\n  var stretchVertically = React.useCallback(function () {\n    tlstate.stretch(exports.StretchType.Vertical);\n  }, [tlstate]);\n  var distributeVertically = React.useCallback(function () {\n    tlstate.distribute(exports.DistributeType.Vertical);\n  }, [tlstate]);\n  var alignLeft = React.useCallback(function () {\n    tlstate.align(exports.AlignType.Left);\n  }, [tlstate]);\n  var alignCenterHorizontal = React.useCallback(function () {\n    tlstate.align(exports.AlignType.CenterHorizontal);\n  }, [tlstate]);\n  var alignRight = React.useCallback(function () {\n    tlstate.align(exports.AlignType.Right);\n  }, [tlstate]);\n  var stretchHorizontally = React.useCallback(function () {\n    tlstate.stretch(exports.StretchType.Horizontal);\n  }, [tlstate]);\n  var distributeHorizontally = React.useCallback(function () {\n    tlstate.distribute(exports.DistributeType.Horizontal);\n  }, [tlstate]);\n  return React.createElement(React.Fragment, null, React.createElement(ButtonsRow, null, React.createElement(IconButton, {\n    bp: breakpoints,\n    size: \"small\",\n    disabled: !hasTwoOrMore,\n    onClick: alignLeft\n  }, React.createElement(reactIcons.AlignLeftIcon, null)), React.createElement(IconButton, {\n    bp: breakpoints,\n    size: \"small\",\n    disabled: !hasTwoOrMore,\n    onClick: alignCenterHorizontal\n  }, React.createElement(reactIcons.AlignCenterHorizontallyIcon, null)), React.createElement(IconButton, {\n    bp: breakpoints,\n    size: \"small\",\n    disabled: !hasTwoOrMore,\n    onClick: alignRight\n  }, React.createElement(reactIcons.AlignRightIcon, null)), React.createElement(IconButton, {\n    bp: breakpoints,\n    size: \"small\",\n    disabled: !hasTwoOrMore,\n    onClick: stretchHorizontally\n  }, React.createElement(reactIcons.StretchHorizontallyIcon, null)), React.createElement(IconButton, {\n    bp: breakpoints,\n    size: \"small\",\n    disabled: !hasThreeOrMore,\n    onClick: distributeHorizontally\n  }, React.createElement(reactIcons.SpaceEvenlyHorizontallyIcon, null))), React.createElement(ButtonsRow, null, React.createElement(IconButton, {\n    bp: breakpoints,\n    size: \"small\",\n    disabled: !hasTwoOrMore,\n    onClick: alignTop\n  }, React.createElement(reactIcons.AlignTopIcon, null)), React.createElement(IconButton, {\n    bp: breakpoints,\n    size: \"small\",\n    disabled: !hasTwoOrMore,\n    onClick: alignCenterVertical\n  }, React.createElement(reactIcons.AlignCenterVerticallyIcon, null)), React.createElement(IconButton, {\n    bp: breakpoints,\n    size: \"small\",\n    disabled: !hasTwoOrMore,\n    onClick: alignBottom\n  }, React.createElement(reactIcons.AlignBottomIcon, null)), React.createElement(IconButton, {\n    bp: breakpoints,\n    size: \"small\",\n    disabled: !hasTwoOrMore,\n    onClick: stretchVertically\n  }, React.createElement(reactIcons.StretchVerticallyIcon, null)), React.createElement(IconButton, {\n    bp: breakpoints,\n    size: \"small\",\n    disabled: !hasThreeOrMore,\n    onClick: distributeVertically\n  }, React.createElement(reactIcons.SpaceEvenlyVerticallyIcon, null))));\n});\n\nvar StyleDropdownContent = /*#__PURE__*/styled('div', {\n  display: 'grid',\n  padding: 4,\n  gridTemplateColumns: 'repeat(4, 1fr)',\n  backgroundColor: '$panel',\n  borderRadius: 4,\n  border: '1px solid $panel',\n  boxShadow: '$4',\n  variants: {\n    direction: {\n      vertical: {\n        gridTemplateColumns: '1fr'\n      }\n    }\n  }\n});\nvar StyleDropdownItem = /*#__PURE__*/styled('button', {\n  height: '32px',\n  width: '32px',\n  backgroundColor: '$panel',\n  borderRadius: '4px',\n  padding: '0',\n  margin: '0',\n  display: 'flex',\n  alignItems: 'center',\n  justifyContent: 'center',\n  outline: 'none',\n  border: 'none',\n  pointerEvents: 'all',\n  cursor: 'pointer',\n  '&:focus': {\n    backgroundColor: '$hover'\n  },\n  '&:hover:not(:disabled)': {\n    backgroundColor: '$hover'\n  },\n  '&:disabled': {\n    opacity: '0.5'\n  },\n  variants: {\n    isActive: {\n      \"true\": {\n        '& svg': {\n          fill: '$text',\n          stroke: '$text'\n        }\n      },\n      \"false\": {\n        '& svg': {\n          fill: '$inactive',\n          stroke: '$inactive'\n        }\n      }\n    }\n  }\n});\nfunction BoxIcon(_ref) {\n  var _ref$fill = _ref.fill,\n      fill = _ref$fill === void 0 ? 'none' : _ref$fill,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === void 0 ? 'currentColor' : _ref$stroke;\n  return React.createElement(\"svg\", {\n    width: \"24\",\n    height: \"24\",\n    viewBox: \"0 0 24 24\",\n    stroke: stroke,\n    fill: fill,\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, React.createElement(\"rect\", {\n    x: \"4\",\n    y: \"4\",\n    width: \"16\",\n    height: \"16\",\n    rx: \"2\",\n    strokeWidth: \"2\"\n  }));\n}\nfunction DashSolidIcon() {\n  return React.createElement(\"svg\", {\n    width: \"24\",\n    height: \"24\",\n    stroke: \"currentColor\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, React.createElement(\"circle\", {\n    cx: 12,\n    cy: 12,\n    r: 8,\n    fill: \"none\",\n    strokeWidth: 2,\n    strokeLinecap: \"round\"\n  }));\n}\nfunction DashDashedIcon() {\n  return React.createElement(\"svg\", {\n    width: \"24\",\n    height: \"24\",\n    stroke: \"currentColor\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, React.createElement(\"circle\", {\n    cx: 12,\n    cy: 12,\n    r: 8,\n    fill: \"none\",\n    strokeWidth: 2.5,\n    strokeLinecap: \"round\",\n    strokeDasharray: 50.26548 * 0.1\n  }));\n}\nvar dottedDasharray = 50.26548 * 0.025 + \" \" + 50.26548 * 0.1;\nfunction DashDottedIcon() {\n  return React.createElement(\"svg\", {\n    width: \"24\",\n    height: \"24\",\n    stroke: \"currentColor\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, React.createElement(\"circle\", {\n    cx: 12,\n    cy: 12,\n    r: 8,\n    fill: \"none\",\n    strokeWidth: 2.5,\n    strokeLinecap: \"round\",\n    strokeDasharray: dottedDasharray\n  }));\n}\nfunction DashDrawIcon() {\n  return React.createElement(\"svg\", {\n    width: \"24\",\n    height: \"24\",\n    viewBox: \"1 1.5 21 22\",\n    fill: \"currentColor\",\n    stroke: \"currentColor\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, React.createElement(\"path\", {\n    d: \"M10.0162 19.2768C10.0162 19.2768 9.90679 19.2517 9.6879 19.2017C9.46275 19.1454 9.12816 19.0422 8.68413 18.8921C8.23384 18.7358 7.81482 18.545 7.42707 18.3199C7.03307 18.101 6.62343 17.7883 6.19816 17.3818C5.77289 16.9753 5.33511 16.3718 4.88482 15.5713C4.43453 14.7645 4.1531 13.8545 4.04053 12.8414C3.92795 11.822 4.04991 10.8464 4.40639 9.91451C4.76286 8.98266 5.39452 8.10084 6.30135 7.26906C7.21444 6.44353 8.29325 5.83377 9.5378 5.43976C10.7823 5.05202 11.833 4.92068 12.6898 5.04576C13.5466 5.16459 14.3878 5.43664 15.2133 5.86191C16.0388 6.28718 16.7768 6.8688 17.4272 7.60678C18.0714 8.34475 18.5404 9.21406 18.8344 10.2147C19.1283 11.2153 19.1721 12.2598 18.9657 13.348C18.7593 14.4299 18.2872 15.4337 17.5492 16.3593C16.8112 17.2849 15.9263 18.0072 14.8944 18.5263C13.8624 19.0391 12.9056 19.3174 12.0238 19.3612C11.142 19.405 10.2101 19.2705 9.22823 18.9578C8.24635 18.6451 7.35828 18.151 6.56402 17.4756C5.77601 16.8002 6.08871 16.8658 7.50212 17.6726C8.90927 18.4731 10.1444 18.8484 11.2076 18.7983C12.2645 18.7545 13.2965 18.4825 14.3034 17.9822C15.3102 17.4819 16.1264 16.8221 16.7518 16.0028C17.3772 15.1835 17.7681 14.3111 17.9244 13.3855C18.0808 12.4599 18.0401 11.5781 17.8025 10.74C17.5586 9.902 17.1739 9.15464 16.6486 8.49797C16.1233 7.8413 15.2289 7.27844 13.9656 6.80939C12.7086 6.34034 11.4203 6.20901 10.1007 6.41539C8.78732 6.61552 7.69599 7.06893 6.82669 7.77564C5.96363 8.48859 5.34761 9.26409 4.97863 10.1021C4.60964 10.9402 4.45329 11.8376 4.50958 12.7945C4.56586 13.7513 4.79101 14.6238 5.18501 15.4118C5.57276 16.1998 5.96363 16.8002 6.35764 17.2129C6.75164 17.6257 7.13313 17.9509 7.50212 18.1886C7.87736 18.4325 8.28074 18.642 8.71227 18.8171C9.15005 18.9922 9.47839 19.111 9.69728 19.1736C9.91617 19.2361 10.0256 19.2705 10.0256 19.2768H10.0162Z\",\n    strokeWidth: \"2\"\n  }));\n}\nfunction IsFilledFillIcon() {\n  return React.createElement(\"svg\", {\n    width: \"24\",\n    height: \"24\",\n    viewBox: \"0 0 24 24\",\n    fill: \"currentColor\",\n    stroke: \"currentColor\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, React.createElement(\"path\", {\n    d: \"M2.6168 11.1303C2.6168 11.1303 2.7023 11.0131 2.8733 10.7788C3.0443 10.5444 3.1298 10.4272 3.1298 10.4272C3.1298 10.4272 3.23333 10.2823 3.4404 9.99236C3.64746 9.70246 3.85889 9.40341 4.0747 9.09521C4.2905 8.78701 4.50606 8.47574 4.72139 8.16141C4.93671 7.84708 5.14338 7.54139 5.3414 7.24432C5.53943 6.94726 5.72068 6.67162 5.88517 6.41742C6.04966 6.16321 6.2116 5.91477 6.37099 5.67211C6.53038 5.42944 6.69528 5.18806 6.86568 4.94796C7.03608 4.70786 7.21694 4.4699 7.40824 4.23409C7.59955 3.99828 7.81063 3.76287 8.0415 3.52787C8.27236 3.29286 8.71114 3.0267 9.35782 2.72937C10.0045 2.43203 10.4713 2.35281 10.7581 2.49169C11.045 2.63057 11.2637 2.84049 11.4141 3.12146C11.5645 3.40243 11.618 3.70079 11.5746 4.01653C11.5312 4.33227 11.4627 4.59891 11.3691 4.81646C11.2756 5.03401 11.0858 5.43918 10.7998 6.03199C10.5139 6.62479 10.2122 7.17617 9.89499 7.68612C9.57773 8.19607 9.25048 8.71529 8.91323 9.24379C8.57598 9.77229 8.24193 10.3038 7.91107 10.8382C7.58021 11.3726 7.2828 11.8729 7.01885 12.339C6.75489 12.8051 6.53711 13.2259 6.36552 13.6014C6.19393 13.977 6.0132 14.3951 5.82332 14.8557C5.63344 15.3163 5.43771 15.617 5.23612 15.7578C5.03453 15.8986 4.80537 15.7993 4.54865 15.4599C4.29193 15.1205 4.11244 14.8722 4.0102 14.7148C3.90796 14.5575 3.97008 14.3802 4.19657 14.183C4.42306 13.9858 4.69016 13.7584 4.99789 13.5009C5.30561 13.2434 5.64245 12.9617 6.00839 12.6559C6.37434 12.35 6.67617 12.0967 6.91389 11.8958C7.15161 11.695 7.39026 11.4926 7.62985 11.2885C7.86944 11.0844 8.15332 10.8467 8.48148 10.5754C8.80965 10.3042 9.23907 9.9577 9.76972 9.53604C10.3004 9.11439 10.867 8.66604 11.4695 8.19102C12.072 7.71599 12.6869 7.22975 13.3142 6.73229C13.9415 6.23483 14.5741 5.73378 15.2121 5.22914C15.85 4.7245 16.4168 4.26953 16.9125 3.86423C17.4081 3.45892 17.7739 3.14715 18.0099 2.92891C18.2459 2.71066 18.5969 2.50912 19.0631 2.32427C19.5292 2.13942 19.8754 2.10947 20.1017 2.23443C20.328 2.35939 20.4959 2.53892 20.6056 2.77302C20.7152 3.00712 20.7455 3.25108 20.6966 3.50489C20.6477 3.75871 20.6108 3.93537 20.5859 4.03487C20.561 4.13437 20.4998 4.32304 20.4023 4.60088C20.3047 4.87872 20.1621 5.17449 19.9745 5.4882C19.7869 5.80191 19.576 6.14669 19.3419 6.52256C19.1078 6.89842 18.9086 7.21331 18.7443 7.46722C18.58 7.72113 18.4142 7.9759 18.2469 8.23153C18.0796 8.48716 17.8836 8.77861 17.6588 9.10588C17.434 9.43316 17.1448 9.84205 16.7912 10.3326C16.4376 10.8231 16.0659 11.342 15.676 11.8893C15.2862 12.4365 14.9001 12.9968 14.5178 13.5701C14.1356 14.1435 13.7682 14.7264 13.4159 15.3191C13.0635 15.9118 12.7579 16.4671 12.4989 16.985C12.24 17.503 12.0533 17.9527 11.9389 18.3342C11.8244 18.7156 11.7224 19.1347 11.6326 19.5912C11.5429 20.0477 11.3788 20.6043 11.1402 21.2609C10.9016 21.9175 10.6425 22.299 10.3629 22.4054C10.0832 22.5118 9.79895 22.5258 9.51015 22.4475C9.22136 22.3692 8.98315 22.2135 8.79554 21.9804C8.60793 21.7473 8.53141 21.5443 8.56597 21.3714C8.60054 21.1985 8.6805 20.9055 8.80586 20.4924C8.93122 20.0794 9.10654 19.7322 9.33182 19.4511C9.55709 19.17 9.8396 18.8347 10.1793 18.4454C10.5191 18.056 10.8588 17.6756 11.1985 17.3041C11.5381 16.9326 11.8676 16.5798 12.1871 16.2457C12.5065 15.9117 12.8481 15.5592 13.2121 15.1882C13.576 14.8173 13.9567 14.4418 14.3542 14.0616C14.7517 13.6814 15.1666 13.3082 15.599 12.9418C16.0313 12.5755 16.437 12.2489 16.8159 11.962C17.1948 11.6752 17.5102 11.4423 17.762 11.2634C18.0138 11.0844 18.3084 10.8902 18.6457 10.6807C18.983 10.4711 19.3744 10.3243 19.82 10.2401C20.2656 10.1559 20.6534 10.2693 20.9834 10.5803C21.3134 10.8913 21.4496 11.2717 21.392 11.7215C21.3344 12.1713 21.1067 12.5051 20.7089 12.7229C20.3112 12.9406 19.9073 12.9526 19.4973 12.7588C19.0873 12.565 18.8402 12.2453 18.7561 11.7997C18.6719 11.3541 18.7853 10.9663 19.0963 10.6363C19.4073 10.3063 19.7877 10.1701 20.2375 10.2277C20.6873 10.2853 21.0211 10.513 21.2388 10.9108C21.4566 11.3086 21.4686 11.7124 21.2748 12.1224C21.081 12.5324 20.8095 12.8344 20.4603 13.0286C20.1111 13.2227 19.8038 13.4005 19.5384 13.5619C19.273 13.7233 18.9732 13.9304 18.6387 14.1834C18.3043 14.4364 17.9499 14.7309 17.5755 15.0671C17.201 15.4032 16.8338 15.7568 16.4739 16.1278C16.114 16.4987 15.762 16.8738 15.418 17.253C15.0741 17.6321 14.7467 17.9939 14.4358 18.3383C14.125 18.6826 13.8006 19.0346 13.4627 19.3941C13.1248 19.7537 12.7843 20.1151 12.4411 20.4784C12.0979 20.8417 11.7811 21.1784 11.4907 21.4885C11.2003 21.7987 11.0097 22.0025 10.9187 22.0998C10.8278 22.1971 10.6425 22.299 10.3629 22.4054C10.0832 22.5118 9.79895 22.5258 9.51015 22.4475C9.22136 22.3692 8.98315 22.2135 8.79554 21.9804C8.60793 21.7473 8.56361 21.2915 8.6626 20.6129C8.76158 19.9344 8.86025 19.4336 8.95861 19.1104C9.05697 18.7873 9.15977 18.4792 9.267 18.186C9.37423 17.8929 9.51059 17.5722 9.67609 17.2241C9.84159 16.8759 10.0617 16.4208 10.3365 15.8586C10.6113 15.2963 10.9173 14.6928 11.2544 14.0481C11.5915 13.4033 11.9371 12.7709 12.2911 12.1509C12.645 11.5309 12.9985 10.928 13.3515 10.3421C13.7045 9.75628 14.043 9.20593 14.3669 8.6911C14.6908 8.17628 14.9637 7.75371 15.1856 7.42339C15.4075 7.09308 15.6064 6.80362 15.7825 6.55501C15.9585 6.3064 16.1337 6.06006 16.3078 5.81598C16.482 5.5719 16.6533 5.33288 16.8217 5.09891C16.9901 4.86494 17.216 4.59736 17.4993 4.29615C17.7826 3.99495 18.1463 3.6271 18.5904 3.1926C19.0345 2.7581 19.3409 2.45855 19.5094 2.29392C19.678 2.1293 19.8754 2.10947 20.1017 2.23443C20.328 2.35939 20.4959 2.53892 20.6056 2.77302C20.7152 3.00712 20.7455 3.25108 20.6966 3.50489C20.6477 3.75871 20.3584 4.05693 19.8288 4.39957C19.2993 4.7422 18.7953 5.11711 18.3168 5.52431C17.8384 5.93151 17.3057 6.40907 16.7189 6.95701C16.1321 7.50495 15.554 8.0585 14.9846 8.61766C14.4151 9.17682 13.8571 9.72936 13.3104 10.2753C12.7637 10.8212 12.2439 11.3334 11.7509 11.8119C11.258 12.2905 10.8516 12.6747 10.5319 12.9645C10.2122 13.2543 9.93102 13.503 9.68844 13.7105C9.44586 13.918 9.20376 14.1242 8.96214 14.329C8.72051 14.5339 8.41222 14.7917 8.03728 15.1027C7.66233 15.4136 7.3052 15.7042 6.96587 15.9744C6.62655 16.2447 6.30615 16.4867 6.00468 16.7005C5.70321 16.9143 5.4028 17.1012 5.10345 17.2611C4.8041 17.421 4.46527 17.4827 4.08697 17.4462C3.70867 17.4098 3.36157 17.209 3.04566 16.8439C2.72975 16.4788 2.5775 16.0785 2.58891 15.6432C2.60033 15.2079 2.70674 14.7684 2.90815 14.3248C3.10956 13.8811 3.29546 13.4939 3.46586 13.163C3.63625 12.832 3.80799 12.5116 3.98107 12.2016C4.15415 11.8916 4.37223 11.4904 4.6353 10.9979C4.89838 10.5055 5.18148 9.97864 5.48461 9.41727C5.78773 8.8559 6.08723 8.30477 6.3831 7.7639C6.67898 7.22302 6.96213 6.69976 7.23257 6.19412C7.50301 5.68847 7.75585 5.24404 7.99109 4.86081C8.22633 4.47759 8.57505 4.04675 9.03725 3.56831C9.49946 3.08987 9.8301 2.7561 10.0292 2.56701C10.2283 2.37791 10.4713 2.35281 10.7581 2.49169C11.045 2.63057 11.2637 2.84049 11.4141 3.12146C11.5645 3.40243 11.618 3.70079 11.5746 4.01653C11.5312 4.33227 11.1439 4.77278 10.4128 5.33807C9.68173 5.90336 9.17886 6.30718 8.90421 6.54953C8.62955 6.79188 8.38273 7.01366 8.16374 7.21485C7.94475 7.41605 7.71551 7.6216 7.47603 7.83151C7.23655 8.04141 6.97229 8.26391 6.68326 8.49901C6.39423 8.7341 6.09233 8.96876 5.77756 9.20297C5.46279 9.43719 5.1469 9.6616 4.8299 9.87622C4.5129 10.0908 4.20211 10.2932 3.89753 10.4834L2.6168 11.1303Z\",\n    strokeWidth: \"0.5\",\n    strokeLinecap: \"round\"\n  }));\n}\n\nvar selectColor = function selectColor(data) {\n  return data.appState.selectedStyle.color;\n};\n\nvar QuickColorSelect = /*#__PURE__*/React.memo(function () {\n  var _useTheme = useTheme(),\n      theme = _useTheme.theme;\n\n  var _useTLDrawContext = useTLDrawContext(),\n      tlstate = _useTLDrawContext.tlstate,\n      useAppState = _useTLDrawContext.useAppState;\n\n  var color = useAppState(selectColor);\n  var handleColorChange = React.useCallback(function (color) {\n    tlstate.style({\n      color: color\n    });\n  }, [tlstate]);\n  return React.createElement(DropdownMenu.Root, {\n    dir: \"ltr\"\n  }, React.createElement(DropdownMenuIconTriggerButton, {\n    label: \"Color\"\n  }, React.createElement(BoxIcon, {\n    fill: strokes[theme][color],\n    stroke: strokes[theme][color]\n  })), React.createElement(DropdownMenu.Content, {\n    sideOffset: 8\n  }, React.createElement(DropdownMenu.DropdownMenuRadioGroup, {\n    value: color,\n    onValueChange: handleColorChange,\n    as: StyleDropdownContent\n  }, Object.keys(strokes[theme]).map(function (colorStyle) {\n    return React.createElement(DropdownMenu.DropdownMenuRadioItem, {\n      as: StyleDropdownItem,\n      key: colorStyle,\n      title: colorStyle,\n      value: colorStyle\n    }, React.createElement(BoxIcon, {\n      fill: strokes[theme][colorStyle],\n      stroke: strokes[theme][colorStyle]\n    }));\n  }))));\n});\n\nvar _sizes;\nvar sizes = (_sizes = {}, _sizes[exports.SizeStyle.Small] = 6, _sizes[exports.SizeStyle.Medium] = 12, _sizes[exports.SizeStyle.Large] = 22, _sizes);\n\nvar selectSize = function selectSize(data) {\n  return data.appState.selectedStyle.size;\n};\n\nvar QuickSizeSelect = /*#__PURE__*/React.memo(function () {\n  var _useTLDrawContext = useTLDrawContext(),\n      tlstate = _useTLDrawContext.tlstate,\n      useAppState = _useTLDrawContext.useAppState;\n\n  var size = useAppState(selectSize);\n  var changeSizeStyle = React.useCallback(function (size) {\n    tlstate.style({\n      size: size\n    });\n  }, [tlstate]);\n  return React.createElement(DropdownMenu.Root, {\n    dir: \"ltr\"\n  }, React.createElement(DropdownMenuIconTriggerButton, {\n    label: \"Size\"\n  }, React.createElement(CircleIcon, {\n    size: sizes[size],\n    stroke: \"none\",\n    fill: \"currentColor\"\n  })), React.createElement(DropdownMenu.Content, {\n    sideOffset: 8\n  }, React.createElement(DropdownMenu.DropdownMenuRadioGroup, {\n    as: StyleDropdownContent,\n    direction: \"vertical\",\n    value: size,\n    onValueChange: changeSizeStyle\n  }, Object.keys(exports.SizeStyle).map(function (sizeStyle) {\n    return React.createElement(DropdownMenu.DropdownMenuRadioItem, {\n      key: sizeStyle,\n      as: StyleDropdownItem,\n      isActive: size === sizeStyle,\n      value: sizeStyle\n    }, React.createElement(CircleIcon, {\n      size: sizes[sizeStyle]\n    }));\n  }))));\n});\n\nvar _dashes;\nvar dashes = (_dashes = {}, _dashes[exports.DashStyle.Draw] = /*#__PURE__*/React.createElement(DashDrawIcon, null), _dashes[exports.DashStyle.Solid] = /*#__PURE__*/React.createElement(DashSolidIcon, null), _dashes[exports.DashStyle.Dashed] = /*#__PURE__*/React.createElement(DashDashedIcon, null), _dashes[exports.DashStyle.Dotted] = /*#__PURE__*/React.createElement(DashDottedIcon, null), _dashes);\n\nvar selectDash = function selectDash(data) {\n  return data.appState.selectedStyle.dash;\n};\n\nvar QuickDashSelect = /*#__PURE__*/React.memo(function () {\n  var _useTLDrawContext = useTLDrawContext(),\n      tlstate = _useTLDrawContext.tlstate,\n      useAppState = _useTLDrawContext.useAppState;\n\n  var dash = useAppState(selectDash);\n  var changeDashStyle = React.useCallback(function (dash) {\n    tlstate.style({\n      dash: dash\n    });\n  }, [tlstate]);\n  return React.createElement(DropdownMenu.Root, {\n    dir: \"ltr\"\n  }, React.createElement(DropdownMenuIconTriggerButton, {\n    label: \"Dash\"\n  }, dashes[dash]), React.createElement(DropdownMenu.Content, {\n    sideOffset: 8\n  }, React.createElement(DropdownMenu.DropdownMenuRadioGroup, {\n    as: StyleDropdownContent,\n    direction: \"vertical\",\n    value: dash,\n    onValueChange: changeDashStyle\n  }, Object.keys(exports.DashStyle).map(function (dashStyle) {\n    return React.createElement(DropdownMenu.DropdownMenuRadioItem, {\n      as: StyleDropdownItem,\n      key: dashStyle,\n      isActive: dash === dashStyle,\n      value: dashStyle\n    }, dashes[dashStyle]);\n  }))));\n});\n\nvar isFilledSelector = function isFilledSelector(data) {\n  return data.appState.selectedStyle.isFilled;\n};\n\nvar QuickFillSelect = /*#__PURE__*/React.memo(function () {\n  var _useTLDrawContext = useTLDrawContext(),\n      tlstate = _useTLDrawContext.tlstate,\n      useAppState = _useTLDrawContext.useAppState;\n\n  var isFilled = useAppState(isFilledSelector);\n  var handleIsFilledChange = React.useCallback(function (isFilled) {\n    tlstate.style({\n      isFilled: isFilled\n    });\n  }, [tlstate]);\n  return React.createElement(Checkbox.Root, {\n    dir: \"ltr\",\n    as: IconButton,\n    bp: breakpoints,\n    checked: isFilled,\n    onCheckedChange: handleIsFilledChange\n  }, React.createElement(Tooltip, {\n    label: \"Fill\"\n  }, React.createElement(IconWrapper, null, React.createElement(BoxIcon, null), React.createElement(Checkbox.Indicator, null, React.createElement(IsFilledFillIcon, null)))));\n});\n\nvar isStyleOpenSelector = function isStyleOpenSelector(s) {\n  return s.appState.isStyleOpen;\n};\n\nfunction StylePanel() {\n  var _useTLDrawContext = useTLDrawContext(),\n      tlstate = _useTLDrawContext.tlstate,\n      useAppState = _useTLDrawContext.useAppState;\n\n  var isOpen = useAppState(isStyleOpenSelector);\n  return React.createElement(FloatingContainer, {\n    direction: \"column\"\n  }, React.createElement(ButtonsRow, null, React.createElement(QuickColorSelect, null), React.createElement(QuickSizeSelect, null), React.createElement(QuickDashSelect, null), React.createElement(QuickFillSelect, null), React.createElement(IconButton, {\n    bp: breakpoints,\n    title: \"Style\",\n    size: \"small\",\n    onPointerDown: tlstate.toggleStylePanel\n  }, React.createElement(Tooltip, {\n    label: isOpen ? 'Close' : 'More'\n  }, isOpen ? React.createElement(reactIcons.Cross2Icon, null) : React.createElement(reactIcons.DotsHorizontalIcon, null)))), isOpen && React.createElement(SelectedShapeContent, null));\n}\nvar showKbds = ! /*#__PURE__*/core.Utils.isMobile();\n\nvar selectedShapesCountSelector = function selectedShapesCountSelector(s) {\n  return s.pageState.selectedIds.length;\n};\n\nfunction SelectedShapeContent() {\n  var _useTLDrawContext2 = useTLDrawContext(),\n      tlstate = _useTLDrawContext2.tlstate,\n      useAppState = _useTLDrawContext2.useAppState;\n\n  var selectedShapesCount = useAppState(selectedShapesCountSelector);\n  return React.createElement(React.Fragment, null, React.createElement(Divider, null), React.createElement(ShapesFunctions, null), React.createElement(Divider, null), React.createElement(AlignDistribute, {\n    hasTwoOrMore: selectedShapesCount > 1,\n    hasThreeOrMore: selectedShapesCount > 2\n  }), React.createElement(Divider, null), React.createElement(RowButton, {\n    bp: breakpoints,\n    disabled: selectedShapesCount === 0,\n    onClick: tlstate.copy\n  }, React.createElement(\"span\", null, \"Copy\"), showKbds && React.createElement(Kbd, {\n    variant: \"menu\"\n  }, \"#C\")), React.createElement(RowButton, {\n    bp: breakpoints,\n    onClick: tlstate.paste\n  }, React.createElement(\"span\", null, \"Paste\"), showKbds && React.createElement(Kbd, {\n    variant: \"menu\"\n  }, \"#V\")), React.createElement(RowButton, {\n    bp: breakpoints,\n    onClick: tlstate.copyAsSvg\n  }, React.createElement(\"span\", null, \"Copy to SVG\"), showKbds && React.createElement(Kbd, {\n    variant: \"menu\"\n  }, \"\\u21E7#C\")));\n}\n\nvar activeToolSelector = function activeToolSelector(s) {\n  return s.appState.activeTool;\n};\n\nfunction StatusBar() {\n  var _useTLDrawContext = useTLDrawContext(),\n      useAppState = _useTLDrawContext.useAppState;\n\n  var activeTool = useAppState(activeToolSelector);\n  return React.createElement(StatusBarContainer, {\n    size: {\n      '@sm': 'small'\n    }\n  }, React.createElement(Section, null, activeTool));\n}\nvar StatusBarContainer = /*#__PURE__*/styled('div', {\n  height: 40,\n  userSelect: 'none',\n  borderTop: '1px solid $border',\n  gridArea: 'status',\n  display: 'flex',\n  color: '$text',\n  justifyContent: 'space-between',\n  alignItems: 'center',\n  backgroundColor: '$panel',\n  gap: 8,\n  fontFamily: '$ui',\n  fontSize: '$0',\n  padding: '0 16px',\n  variants: {\n    size: {\n      small: {\n        fontSize: '$1'\n      }\n    }\n  }\n});\nvar Section = /*#__PURE__*/styled('div', {\n  whiteSpace: 'nowrap',\n  overflow: 'hidden'\n});\n\nvar ToolButton = /*#__PURE__*/styled('button', {\n  position: 'relative',\n  height: '32px',\n  width: '32px',\n  color: '$text',\n  backgroundColor: '$panel',\n  borderRadius: '4px',\n  padding: '0',\n  margin: '0',\n  display: 'grid',\n  alignItems: 'center',\n  justifyContent: 'center',\n  outline: 'none',\n  border: 'none',\n  pointerEvents: 'all',\n  fontSize: '$0',\n  cursor: 'pointer',\n  '& > *': {\n    gridRow: 1,\n    gridColumn: 1\n  },\n  '&:disabled': {\n    opacity: '0.5'\n  },\n  '& > span': {\n    width: '100%',\n    height: '100%',\n    display: 'flex',\n    alignItems: 'center'\n  }\n});\nvar PrimaryToolButton = /*#__PURE__*/styled(ToolButton, {\n  variants: {\n    bp: {\n      mobile: {\n        height: 44,\n        width: 44,\n        '& svg:nth-of-type(1)': {\n          height: '20px',\n          width: '20px'\n        }\n      },\n      small: {\n        '&:hover:not(:disabled)': {\n          backgroundColor: '$hover'\n        }\n      },\n      medium: {},\n      large: {}\n    },\n    isActive: {\n      \"true\": {\n        color: '$selected'\n      }\n    }\n  }\n});\nvar SecondaryToolButton = /*#__PURE__*/styled(ToolButton, {\n  variants: {\n    bp: {\n      mobile: {\n        height: 44,\n        width: 44,\n        '& svg:nth-of-type(1)': {\n          height: '18px',\n          width: '18px'\n        }\n      },\n      small: {\n        '&:hover:not(:disabled)': {\n          backgroundColor: '$hover'\n        }\n      },\n      medium: {},\n      large: {}\n    },\n    isActive: {\n      \"true\": {\n        color: '$selected'\n      }\n    }\n  }\n});\nvar TertiaryToolButton = /*#__PURE__*/styled(ToolButton, {\n  variants: {\n    bp: {\n      mobile: {\n        height: 32,\n        width: 44,\n        '& svg:nth-of-type(1)': {\n          height: '16px',\n          width: '16px'\n        }\n      },\n      small: {\n        height: 40,\n        width: 40,\n        '& svg:nth-of-type(1)': {\n          height: '18px',\n          width: '18px'\n        },\n        '&:hover:not(:disabled)': {\n          backgroundColor: '$hover'\n        }\n      },\n      medium: {},\n      large: {}\n    }\n  }\n});\nfunction PrimaryButton(_ref) {\n  var label = _ref.label,\n      kbd = _ref.kbd,\n      onClick = _ref.onClick,\n      onDoubleClick = _ref.onDoubleClick,\n      isActive = _ref.isActive,\n      children = _ref.children;\n  return React.createElement(Tooltip, {\n    label: label[0].toUpperCase() + label.slice(1),\n    kbd: kbd\n  }, React.createElement(PrimaryToolButton, {\n    name: label,\n    bp: {\n      '@initial': 'mobile',\n      '@sm': 'small',\n      '@md': 'medium',\n      '@lg': 'large'\n    },\n    onClick: onClick,\n    onDoubleClick: onDoubleClick,\n    isActive: isActive\n  }, children));\n}\nfunction SecondaryButton(_ref2) {\n  var label = _ref2.label,\n      kbd = _ref2.kbd,\n      onClick = _ref2.onClick,\n      onDoubleClick = _ref2.onDoubleClick,\n      isActive = _ref2.isActive,\n      children = _ref2.children;\n  return React.createElement(Tooltip, {\n    label: label[0].toUpperCase() + label.slice(1),\n    kbd: kbd\n  }, React.createElement(SecondaryToolButton, {\n    name: label,\n    bp: {\n      '@initial': 'mobile',\n      '@sm': 'small',\n      '@md': 'medium',\n      '@lg': 'large'\n    },\n    onClick: onClick,\n    onDoubleClick: onDoubleClick,\n    isActive: isActive\n  }, children));\n}\nfunction TertiaryButton(_ref3) {\n  var label = _ref3.label,\n      kbd = _ref3.kbd,\n      onClick = _ref3.onClick,\n      onDoubleClick = _ref3.onDoubleClick,\n      children = _ref3.children;\n  return React.createElement(Tooltip, {\n    label: label[0].toUpperCase() + label.slice(1),\n    kbd: kbd\n  }, React.createElement(TertiaryToolButton, {\n    name: label,\n    bp: {\n      '@initial': 'mobile',\n      '@sm': 'small',\n      '@md': 'medium',\n      '@lg': 'large'\n    },\n    onClick: onClick,\n    onDoubleClick: onDoubleClick\n  }, children));\n}\nvar TertiaryButtonsContainer = /*#__PURE__*/styled(FloatingContainer, {\n  boxShadow: '$3',\n  variants: {\n    bp: {\n      mobile: {\n        alignItems: 'center',\n        flexDirection: 'column'\n      },\n      small: {\n        alignItems: 'center',\n        flexDirection: 'row'\n      }\n    }\n  }\n});\n\nvar UndoRedo = /*#__PURE__*/React.memo(function () {\n  var _useTLDrawContext = useTLDrawContext(),\n      tlstate = _useTLDrawContext.tlstate;\n\n  var handleDelete = React.useCallback(function () {\n    tlstate[\"delete\"]();\n  }, [tlstate]);\n  var handleClear = React.useCallback(function () {\n    tlstate.clear();\n  }, [tlstate]);\n  return React.createElement(TertiaryButtonsContainer, {\n    bp: {\n      '@initial': 'mobile',\n      '@sm': 'small'\n    }\n  }, React.createElement(TertiaryButton, {\n    label: \"Undo\",\n    kbd: \"#Z\",\n    onClick: tlstate.undo\n  }, React.createElement(SvgUndo, null)), React.createElement(TertiaryButton, {\n    label: \"Redo\",\n    kbd: \"#\\u21E7\",\n    onClick: tlstate.redo\n  }, React.createElement(SvgRedo, null)), React.createElement(TertiaryButton, {\n    label: \"Delete\",\n    kbd: \"\\u232B\",\n    onClick: handleDelete,\n    onDoubleClick: handleClear\n  }, React.createElement(SvgTrash, null)));\n});\n\nvar Zoom = /*#__PURE__*/React.memo(function () {\n  var _useTLDrawContext = useTLDrawContext(),\n      tlstate = _useTLDrawContext.tlstate;\n\n  return React.createElement(TertiaryButtonsContainer, {\n    bp: {\n      '@initial': 'mobile',\n      '@sm': 'small'\n    }\n  }, React.createElement(TertiaryButton, {\n    label: \"Zoom Out\",\n    kbd: \"#\\u2212\",\n    onClick: tlstate.zoomOut\n  }, React.createElement(reactIcons.ZoomOutIcon, null)), React.createElement(TertiaryButton, {\n    label: \"Zoom In\",\n    kbd: \"#+\",\n    onClick: tlstate.zoomIn\n  }, React.createElement(reactIcons.ZoomInIcon, null)), React.createElement(ZoomCounter, null));\n});\n\nvar zoomSelector = function zoomSelector(s) {\n  return s.pageState.camera.zoom;\n};\n\nfunction ZoomCounter() {\n  var _useTLDrawContext2 = useTLDrawContext(),\n      tlstate = _useTLDrawContext2.tlstate,\n      useAppState = _useTLDrawContext2.useAppState;\n\n  var zoom = useAppState(zoomSelector);\n  return React.createElement(TertiaryButton, {\n    label: \"Reset Zoom\",\n    kbd: \"\\u21E70\",\n    onClick: tlstate.zoomToActual,\n    onDoubleClick: tlstate.zoomToFit\n  }, Math.round(zoom * 100), \"%\");\n}\n\nvar isEmptyCanvasSelector = function isEmptyCanvasSelector(s) {\n  return Object.keys(s.page.shapes).length > 0 && s.appState.isEmptyCanvas;\n};\n\nvar BackToContent = /*#__PURE__*/React.memo(function () {\n  var _useTLDrawContext = useTLDrawContext(),\n      tlstate = _useTLDrawContext.tlstate,\n      useAppState = _useTLDrawContext.useAppState;\n\n  var isEmptyCanvas = useAppState(isEmptyCanvasSelector);\n  if (!isEmptyCanvas) return null;\n  return React.createElement(BackToContentButton, null, React.createElement(RowButton, {\n    onClick: tlstate.zoomToContent\n  }, \"Back to content\"));\n});\nvar BackToContentButton = /*#__PURE__*/styled(FloatingContainer, {\n  pointerEvents: 'all',\n  width: 'fit-content',\n  gridRow: 1,\n  flexGrow: 2,\n  display: 'block'\n});\n\nvar activeToolSelector$1 = function activeToolSelector(s) {\n  return s.appState.activeTool;\n};\n\nvar isToolLockedSelector = function isToolLockedSelector(s) {\n  return s.appState.isToolLocked;\n};\n\nvar isDebugModeSelector$1 = function isDebugModeSelector(s) {\n  return s.settings.isDebugMode;\n};\n\nvar ToolsPanel = /*#__PURE__*/React.memo(function () {\n  var _useTLDrawContext = useTLDrawContext(),\n      tlstate = _useTLDrawContext.tlstate,\n      useAppState = _useTLDrawContext.useAppState;\n\n  var activeTool = useAppState(activeToolSelector$1);\n  var isToolLocked = useAppState(isToolLockedSelector);\n  var isDebugMode = useAppState(isDebugModeSelector$1);\n  var selectSelectTool = React.useCallback(function () {\n    tlstate.selectTool('select');\n  }, [tlstate]);\n  var selectDrawTool = React.useCallback(function () {\n    tlstate.selectTool(exports.TLDrawShapeType.Draw);\n  }, [tlstate]);\n  var selectRectangleTool = React.useCallback(function () {\n    tlstate.selectTool(exports.TLDrawShapeType.Rectangle);\n  }, [tlstate]);\n  var selectEllipseTool = React.useCallback(function () {\n    tlstate.selectTool(exports.TLDrawShapeType.Ellipse);\n  }, [tlstate]);\n  var selectArrowTool = React.useCallback(function () {\n    tlstate.selectTool(exports.TLDrawShapeType.Arrow);\n  }, [tlstate]); // const selectTextTool = React.useCallback(() => {\n  //   tlstate.selectTool(TLDrawShapeType.Ellipse)\n  // }, [tlstate])\n\n  return React.createElement(ToolsPanelContainer, null, React.createElement(LeftWrap, {\n    size: {\n      '@initial': 'mobile',\n      '@sm': 'small'\n    }\n  }, React.createElement(Zoom, null), React.createElement(FloatingContainer, null, React.createElement(SecondaryButton, {\n    label: 'Select',\n    kbd: '1',\n    onClick: selectSelectTool,\n    isActive: activeTool === 'select'\n  }, React.createElement(reactIcons.CursorArrowIcon, null)))), React.createElement(CenterWrap, null, React.createElement(BackToContent, null), React.createElement(FloatingContainer, null, React.createElement(PrimaryButton, {\n    kbd: '2',\n    label: exports.TLDrawShapeType.Draw,\n    onClick: selectDrawTool,\n    isActive: activeTool === exports.TLDrawShapeType.Draw\n  }, React.createElement(reactIcons.Pencil1Icon, null)), React.createElement(PrimaryButton, {\n    kbd: '3',\n    label: exports.TLDrawShapeType.Rectangle,\n    onClick: selectRectangleTool,\n    isActive: activeTool === exports.TLDrawShapeType.Rectangle\n  }, React.createElement(reactIcons.SquareIcon, null)), React.createElement(PrimaryButton, {\n    kbd: '4',\n    label: exports.TLDrawShapeType.Draw,\n    onClick: selectEllipseTool,\n    isActive: activeTool === exports.TLDrawShapeType.Ellipse\n  }, React.createElement(reactIcons.CircleIcon, null)), React.createElement(PrimaryButton, {\n    kbd: '5',\n    label: exports.TLDrawShapeType.Arrow,\n    onClick: selectArrowTool,\n    isActive: activeTool === exports.TLDrawShapeType.Arrow\n  }, React.createElement(reactIcons.ArrowTopRightIcon, null)))), React.createElement(RightWrap, {\n    size: {\n      '@initial': 'mobile',\n      '@sm': 'small'\n    }\n  }, React.createElement(FloatingContainer, null, React.createElement(SecondaryButton, {\n    kbd: '7',\n    label: 'Lock Tool',\n    onClick: tlstate.toggleToolLock,\n    isActive: isToolLocked\n  }, isToolLocked ? React.createElement(reactIcons.LockClosedIcon, null) : React.createElement(reactIcons.LockOpen1Icon, null))), React.createElement(UndoRedo, null)), React.createElement(StatusWrap, null, isDebugMode && React.createElement(StatusBar, null)));\n});\nvar ToolsPanelContainer = /*#__PURE__*/styled('div', {\n  position: 'fixed',\n  bottom: 0,\n  left: 0,\n  right: 0,\n  width: '100%',\n  minWidth: 0,\n  maxWidth: '100%',\n  display: 'grid',\n  gridTemplateColumns: '1fr auto 1fr',\n  padding: '0',\n  alignItems: 'flex-end',\n  zIndex: 200,\n  gridGap: '$4',\n  gridRowGap: '$4',\n  pointerEvents: 'none',\n  '& > div > *': {\n    pointerEvents: 'all'\n  }\n});\nvar CenterWrap = /*#__PURE__*/styled('div', {\n  gridRow: 1,\n  gridColumn: 2,\n  display: 'flex',\n  width: 'fit-content',\n  alignItems: 'center',\n  justifyContent: 'center',\n  flexDirection: 'column',\n  gap: 12\n});\nvar LeftWrap = /*#__PURE__*/styled('div', {\n  gridRow: 1,\n  gridColumn: 1,\n  display: 'flex',\n  paddingLeft: '$3',\n  variants: {\n    size: {\n      mobile: {\n        flexDirection: 'column',\n        justifyContent: 'flex-end',\n        alignItems: 'flex-start',\n        '& > *:nth-of-type(1)': {\n          marginBottom: '8px'\n        }\n      },\n      small: {\n        flexDirection: 'row',\n        alignItems: 'flex-end',\n        justifyContent: 'space-between',\n        '& > *:nth-of-type(1)': {\n          marginBottom: '0px'\n        }\n      }\n    }\n  }\n});\nvar RightWrap = /*#__PURE__*/styled('div', {\n  gridRow: 1,\n  gridColumn: 3,\n  display: 'flex',\n  paddingRight: '$3',\n  variants: {\n    size: {\n      mobile: {\n        flexDirection: 'column-reverse',\n        justifyContent: 'flex-end',\n        alignItems: 'flex-end',\n        '& > *:nth-of-type(2)': {\n          marginBottom: '8px'\n        }\n      },\n      small: {\n        flexDirection: 'row',\n        alignItems: 'flex-end',\n        justifyContent: 'space-between',\n        '& > *:nth-of-type(2)': {\n          marginBottom: '0px'\n        }\n      }\n    }\n  }\n});\nvar StatusWrap = /*#__PURE__*/styled('div', {\n  gridRow: 2,\n  gridColumn: '1 / span 3'\n});\n\nvar TLDR = /*#__PURE__*/function () {\n  function TLDR() {}\n\n  TLDR.getShapeUtils = function getShapeUtils$1(shape) {\n    return getShapeUtils(shape);\n  };\n\n  TLDR.getSelectedShapes = function getSelectedShapes(data) {\n    return data.pageState.selectedIds.map(function (id) {\n      return data.page.shapes[id];\n    });\n  };\n\n  TLDR.screenToWorld = function screenToWorld(data, point) {\n    var camera = data.pageState.camera;\n    return core.Vec.sub(core.Vec.div(point, camera.zoom), camera.point);\n  };\n\n  TLDR.getViewport = function getViewport(data) {\n    var _this$screenToWorld = this.screenToWorld(data, [0, 0]),\n        minX = _this$screenToWorld[0],\n        minY = _this$screenToWorld[1];\n\n    var _this$screenToWorld2 = this.screenToWorld(data, [window.innerWidth, window.innerHeight]),\n        maxX = _this$screenToWorld2[0],\n        maxY = _this$screenToWorld2[1];\n\n    return {\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY,\n      height: maxX - minX,\n      width: maxY - minY\n    };\n  };\n\n  TLDR.getCameraZoom = function getCameraZoom(zoom) {\n    return core.Utils.clamp(zoom, 0.1, 5);\n  };\n\n  TLDR.getCurrentCamera = function getCurrentCamera(data) {\n    return data.pageState.camera;\n  };\n\n  TLDR.getPage = function getPage(data) {\n    return data.page;\n  };\n\n  TLDR.getPageState = function getPageState(data) {\n    return data.pageState;\n  };\n\n  TLDR.getSelectedIds = function getSelectedIds(data) {\n    return data.pageState.selectedIds;\n  };\n\n  TLDR.getShapes = function getShapes(data) {\n    return Object.values(data.page.shapes);\n  };\n\n  TLDR.getCamera = function getCamera(data) {\n    return data.pageState.camera;\n  };\n\n  TLDR.getShape = function getShape(data, shapeId) {\n    return data.page.shapes[shapeId];\n  };\n\n  TLDR.getBounds = function getBounds(shape) {\n    return getShapeUtils(shape).getBounds(shape);\n  };\n\n  TLDR.getRotatedBounds = function getRotatedBounds(shape) {\n    return getShapeUtils(shape).getRotatedBounds(shape);\n  };\n\n  TLDR.getSelectedBounds = function getSelectedBounds(data) {\n    return core.Utils.getCommonBounds(this.getSelectedShapes(data).map(function (shape) {\n      return getShapeUtils(shape).getBounds(shape);\n    }));\n  };\n\n  TLDR.getParentId = function getParentId(data, id) {\n    var shape = data.page.shapes[id];\n    return shape.parentId;\n  };\n\n  TLDR.getPointedId = function getPointedId(data, id) {\n    var shape = data.page.shapes[id];\n    if (!shape) return id;\n    return shape.parentId === data.pageState.currentParentId || shape.parentId === data.page.id ? id : this.getPointedId(data, shape.parentId);\n  };\n\n  TLDR.getDrilledPointedId = function getDrilledPointedId(data, id) {\n    var shape = data.page.shapes[id];\n    var _data$pageState = data.pageState,\n        currentParentId = _data$pageState.currentParentId,\n        pointedId = _data$pageState.pointedId;\n    return shape.parentId === data.page.id || shape.parentId === pointedId || shape.parentId === currentParentId ? id : this.getDrilledPointedId(data, shape.parentId);\n  };\n\n  TLDR.getTopParentId = function getTopParentId(data, id) {\n    var shape = data.page.shapes[id];\n\n    if (shape.parentId === shape.id) {\n      throw Error(\"Shape has the same id as its parent! \" + shape.id);\n    }\n\n    return shape.parentId === data.page.id || shape.parentId === data.pageState.currentParentId ? id : this.getTopParentId(data, shape.parentId);\n  } // Get an array of a shape id and its descendant shapes' ids\n  ;\n\n  TLDR.getDocumentBranch = function getDocumentBranch(data, id) {\n    var _this = this;\n\n    var shape = data.page.shapes[id];\n    if (shape.children === undefined) return [id];\n    return [id].concat(shape.children.flatMap(function (childId) {\n      return _this.getDocumentBranch(data, childId);\n    }));\n  };\n\n  TLDR.getSelectedBranchSnapshot = function getSelectedBranchSnapshot(data, fn) {\n    var _this2 = this;\n\n    var page = this.getPage(data);\n    var copies = this.getSelectedIds(data).flatMap(function (id) {\n      return _this2.getDocumentBranch(data, id).map(function (id) {\n        return page.shapes[id];\n      });\n    }).filter(function (shape) {\n      return !shape.isLocked;\n    }).map(core.Utils.deepClone);\n\n    if (fn !== undefined) {\n      return copies.map(function (shape) {\n        return _extends({\n          id: shape.id\n        }, fn(shape));\n      });\n    }\n\n    return copies;\n  };\n\n  TLDR.getSelectedShapeSnapshot = function getSelectedShapeSnapshot(data, fn) {\n    var copies = this.getSelectedShapes(data).filter(function (shape) {\n      return !shape.isLocked;\n    }).map(core.Utils.deepClone);\n\n    if (fn !== undefined) {\n      return copies.map(function (shape) {\n        return _extends({\n          id: shape.id\n        }, fn(shape));\n      });\n    }\n\n    return copies;\n  } // For a given array of shape ids, an array of all other shapes that may be affected by a mutation to it.\n  // Use this to decide which shapes to clone as before / after for a command.\n  ;\n\n  TLDR.getAllEffectedShapeIds = function getAllEffectedShapeIds(data, ids) {\n    var visited = new Set(ids);\n    ids.forEach(function (id) {\n      var shape = data.page.shapes[id]; // Add descendant shapes\n\n      function collectDescendants(shape) {\n        if (shape.children === undefined) return;\n        shape.children.filter(function (childId) {\n          return !visited.has(childId);\n        }).forEach(function (childId) {\n          visited.add(childId);\n          collectDescendants(data.page.shapes[childId]);\n        });\n      }\n\n      collectDescendants(shape); // Add asecendant shapes\n\n      function collectAscendants(shape) {\n        var parentId = shape.parentId;\n        if (parentId === data.page.id) return;\n        if (visited.has(parentId)) return;\n        visited.add(parentId);\n        collectAscendants(data.page.shapes[parentId]);\n      }\n\n      collectAscendants(shape); // Add bindings that are to or from any of the visited shapes (this does not have to be recursive)\n\n      visited.forEach(function (id) {\n        Object.values(data.page.bindings).filter(function (binding) {\n          return binding.fromId === id || binding.toId === id;\n        }).forEach(function (binding) {\n          return visited.add(binding.fromId === id ? binding.toId : binding.fromId);\n        });\n      });\n    }); // Return the unique array of visited shapes\n\n    return Array.from(visited.values());\n  };\n\n  TLDR.recursivelyUpdateChildren = function recursivelyUpdateChildren(data, id, beforeShapes, afterShapes) {\n    var _this3 = this;\n\n    if (beforeShapes === void 0) {\n      beforeShapes = {};\n    }\n\n    if (afterShapes === void 0) {\n      afterShapes = {};\n    }\n\n    var shape = data.page.shapes[id];\n\n    if (shape.children !== undefined) {\n      var deltas = this.getShapeUtils(shape).updateChildren(shape, shape.children.map(function (childId) {\n        return data.page.shapes[childId];\n      }));\n\n      if (deltas) {\n        return deltas.reduce(function (cData, delta) {\n          var deltaShape = cData.page.shapes[delta.id];\n\n          if (!beforeShapes[deltaShape.id]) {\n            beforeShapes[deltaShape.id] = deltaShape;\n          }\n\n          cData.page.shapes[deltaShape.id] = _this3.getShapeUtils(deltaShape).mutate(deltaShape, delta);\n          afterShapes[deltaShape.id] = cData.page.shapes[deltaShape.id];\n\n          if (deltaShape.children !== undefined) {\n            _this3.recursivelyUpdateChildren(cData, deltaShape.id, beforeShapes, afterShapes);\n          }\n\n          return cData;\n        }, data);\n      }\n    }\n\n    return data;\n  };\n\n  TLDR.recursivelyUpdateParents = function recursivelyUpdateParents(data, id, beforeShapes, afterShapes) {\n    if (beforeShapes === void 0) {\n      beforeShapes = {};\n    }\n\n    if (afterShapes === void 0) {\n      afterShapes = {};\n    }\n\n    var shape = data.page.shapes[id];\n\n    if (shape.parentId !== data.page.id) {\n      var parent = data.page.shapes[shape.parentId];\n      var delta = this.getShapeUtils(shape).onChildrenChange(parent, parent.children.map(function (childId) {\n        return data.page.shapes[childId];\n      }));\n\n      if (delta) {\n        if (!beforeShapes[parent.id]) {\n          beforeShapes[parent.id] = parent;\n        }\n\n        data.page.shapes[parent.id] = this.getShapeUtils(parent).mutate(parent, delta);\n        afterShapes[parent.id] = data.page.shapes[parent.id];\n      }\n\n      if (parent.parentId !== data.page.id) {\n        return this.recursivelyUpdateParents(data, parent.parentId, beforeShapes, afterShapes);\n      }\n    }\n\n    return data;\n  };\n\n  TLDR.updateBindings = function updateBindings(data, id, beforeShapes, afterShapes) {\n    var _this4 = this;\n\n    if (beforeShapes === void 0) {\n      beforeShapes = {};\n    }\n\n    if (afterShapes === void 0) {\n      afterShapes = {};\n    }\n\n    return Object.values(data.page.bindings).filter(function (binding) {\n      return binding.fromId === id || binding.toId === id;\n    }).reduce(function (cData, binding) {\n      if (!beforeShapes[binding.id]) {\n        beforeShapes[binding.fromId] = core.Utils.deepClone(cData.page.shapes[binding.fromId]);\n      }\n\n      if (!beforeShapes[binding.toId]) {\n        beforeShapes[binding.toId] = core.Utils.deepClone(cData.page.shapes[binding.toId]);\n      }\n\n      _this4.onBindingChange(cData, cData.page.shapes[binding.fromId], binding, cData.page.shapes[binding.toId]);\n\n      afterShapes[binding.fromId] = core.Utils.deepClone(cData.page.shapes[binding.fromId]);\n      afterShapes[binding.toId] = core.Utils.deepClone(cData.page.shapes[binding.toId]);\n      return cData;\n    }, data);\n  };\n\n  TLDR.getChildIndexAbove = function getChildIndexAbove(data, id) {\n    var page = this.getPage(data);\n    var shape = page.shapes[id];\n    var siblings = Object.values(page.shapes).filter(function (_ref) {\n      var parentId = _ref.parentId;\n      return parentId === shape.parentId;\n    }).sort(function (a, b) {\n      return a.childIndex - b.childIndex;\n    });\n    var index = siblings.indexOf(shape);\n    var nextSibling = siblings[index + 1];\n    if (!nextSibling) return shape.childIndex + 1;\n    return (shape.childIndex + nextSibling.childIndex) / 2;\n  }\n  /* -------------------------------------------------- */\n\n  /*                      Mutations                     */\n\n  /* -------------------------------------------------- */\n  ;\n\n  TLDR.setSelectedIds = function setSelectedIds(data, ids) {\n    data.pageState.selectedIds = ids;\n  };\n\n  TLDR.deselectAll = function deselectAll(data) {\n    this.setSelectedIds(data, []);\n  };\n\n  TLDR.mutateShapes = function mutateShapes(data, ids, fn) {\n    var _this5 = this;\n\n    var beforeShapes = {};\n    var afterShapes = {};\n    ids.forEach(function (id, i) {\n      var shape = data.page.shapes[id];\n      var change = fn(shape, i);\n      beforeShapes[id] = Object.fromEntries(Object.keys(change).map(function (key) {\n        return [key, shape[key]];\n      }));\n      afterShapes[id] = change;\n      data.page.shapes[id] = _this5.getShapeUtils(shape).mutate(shape, change);\n    });\n    var dataWithChildrenChanges = ids.reduce(function (cData, id) {\n      return _this5.recursivelyUpdateChildren(cData, id, beforeShapes, afterShapes);\n    }, data);\n    var dataWithParentChanges = ids.reduce(function (cData, id) {\n      return _this5.recursivelyUpdateParents(cData, id, beforeShapes, afterShapes);\n    }, dataWithChildrenChanges);\n    var dataWithBindingChanges = ids.reduce(function (cData, id) {\n      return _this5.updateBindings(cData, id, beforeShapes, afterShapes);\n    }, dataWithParentChanges);\n    return {\n      before: beforeShapes,\n      after: afterShapes,\n      data: dataWithBindingChanges\n    };\n  };\n\n  TLDR.createShapes = function createShapes(data, shapes) {\n    var _this6 = this;\n\n    var page = this.getPage(data);\n    var shapeIds = shapes.map(function (shape) {\n      return shape.id;\n    }); // Update selected ids\n\n    this.setSelectedIds(data, shapeIds); // Restore deleted shapes\n\n    shapes.forEach(function (shape) {\n      var newShape = _extends({}, shape);\n\n      page.shapes[shape.id] = newShape;\n    }); // Update parents\n\n    shapes.forEach(function (shape) {\n      if (shape.parentId === data.page.id) return;\n      var parent = page.shapes[shape.parentId];\n\n      _this6.mutate(data, parent, {\n        children: parent.children.includes(shape.id) ? parent.children : [].concat(parent.children, [shape.id])\n      });\n    });\n  };\n\n  TLDR.onSessionComplete = function onSessionComplete(data, shape) {\n    var delta = getShapeUtils(shape).onSessionComplete(shape);\n\n    if (!delta) return shape;\n    return this.mutate(data, shape, delta);\n  };\n\n  TLDR.onChildrenChange = function onChildrenChange(data, shape) {\n    var delta = getShapeUtils(shape).onChildrenChange(shape, shape.children.map(function (id) {\n      return data.page.shapes[id];\n    }));\n\n    if (!delta) return shape;\n    return this.mutate(data, shape, delta);\n  };\n\n  TLDR.onBindingChange = function onBindingChange(data, shape, binding, otherShape) {\n    var delta = getShapeUtils(shape).onBindingChange(shape, binding, otherShape, getShapeUtils(otherShape).getBounds(otherShape));\n\n    if (!delta) return shape;\n    return this.mutate(data, shape, delta);\n  };\n\n  TLDR.transform = function transform(data, shape, bounds, info) {\n    return this.mutate(data, shape, getShapeUtils(shape).transform(shape, bounds, info));\n  };\n\n  TLDR.transformSingle = function transformSingle(data, shape, bounds, info) {\n    return this.mutate(data, shape, getShapeUtils(shape).transformSingle(shape, bounds, info));\n  };\n\n  TLDR.mutate = function mutate(data, shape, props) {\n    var next = getShapeUtils(shape).mutate(shape, props);\n\n    if ('children' in props) {\n      next = this.onChildrenChange(data, next);\n    }\n\n    data.page.shapes[next.id] = next;\n    return next;\n  }\n  /* -------------------------------------------------- */\n\n  /*                       Parents                      */\n\n  /* -------------------------------------------------- */\n  ;\n\n  TLDR.updateParents = function updateParents(data, changedShapeIds) {\n    if (changedShapeIds.length === 0) return;\n\n    var _this$getPage = this.getPage(data),\n        shapes = _this$getPage.shapes;\n\n    var parentToUpdateIds = Array.from(new Set(changedShapeIds.map(function (id) {\n      return shapes[id].parentId;\n    }).values())).filter(function (id) {\n      return id !== data.page.id;\n    });\n\n    for (var _iterator = _createForOfIteratorHelperLoose(parentToUpdateIds), _step; !(_step = _iterator()).done;) {\n      var parentId = _step.value;\n      var parent = shapes[parentId];\n\n      if (!parent.children) {\n        throw Error('A shape is parented to a shape without a children array.');\n      }\n\n      this.onChildrenChange(data, parent);\n    }\n\n    this.updateParents(data, parentToUpdateIds);\n  };\n\n  TLDR.getSelectedStyle = function getSelectedStyle(data) {\n    var page = data.page,\n        pageState = data.pageState,\n        currentStyle = data.appState.currentStyle;\n\n    if (pageState.selectedIds.length === 0) {\n      return currentStyle;\n    }\n\n    var shapeStyles = data.pageState.selectedIds.map(function (id) {\n      return page.shapes[id].style;\n    });\n    var commonStyle = {};\n    var overrides = new Set([]);\n\n    var _loop = function _loop() {\n      var shapeStyle = _step2.value;\n      Object.keys(currentStyle).forEach(function (key) {\n        if (overrides.has(key)) return;\n\n        if (commonStyle[key] === undefined) {\n          // @ts-ignore\n          commonStyle[key] = shapeStyle[key];\n        } else {\n          if (commonStyle[key] === shapeStyle[key]) return; // @ts-ignore\n\n          commonStyle[key] = currentStyle[key];\n          overrides.add(key);\n        }\n      });\n    };\n\n    for (var _iterator2 = _createForOfIteratorHelperLoose(shapeStyles), _step2; !(_step2 = _iterator2()).done;) {\n      _loop();\n    }\n\n    return commonStyle;\n  }\n  /* -------------------------------------------------- */\n\n  /*                      Bindings                      */\n\n  /* -------------------------------------------------- */\n  ;\n\n  TLDR.getBinding = function getBinding(data, id) {\n    return this.getPage(data).bindings[id];\n  };\n\n  TLDR.getBindings = function getBindings(data) {\n    var page = this.getPage(data);\n    return Object.values(page.bindings);\n  };\n\n  TLDR.getBindingsWithShapeIds = function getBindingsWithShapeIds(data, ids) {\n    return Array.from(new Set(this.getBindings(data).filter(function (binding) {\n      return ids.includes(binding.toId) || ids.includes(binding.fromId);\n    })).values());\n  };\n\n  TLDR.createBindings = function createBindings(data, bindings) {\n    var page = this.getPage(data);\n    bindings.forEach(function (binding) {\n      return page.bindings[binding.id] = binding;\n    });\n  };\n\n  TLDR.deleteBindings = function deleteBindings(data, ids) {\n    if (ids.length === 0) return;\n    var page = this.getPage(data);\n    ids.forEach(function (id) {\n      return delete page.bindings[id];\n    });\n  }\n  /* -------------------------------------------------- */\n\n  /*                     Assertions                     */\n\n  /* -------------------------------------------------- */\n  ;\n\n  TLDR.assertShapeHasProperty = function assertShapeHasProperty(shape, prop) {\n    if (shape[prop] === undefined) {\n      throw new Error();\n    }\n  };\n\n  return TLDR;\n}();\n\nfunction align(data, ids, type) {\n  var initialShapes = ids.map(function (id) {\n    return TLDR.getShape(data, id);\n  });\n  var boundsForShapes = initialShapes.map(function (shape) {\n    return {\n      id: shape.id,\n      point: [].concat(shape.point),\n      bounds: TLDR.getShapeUtils(shape).getBounds(shape)\n    };\n  });\n  var commonBounds = core.Utils.getCommonBounds(boundsForShapes.map(function (_ref) {\n    var bounds = _ref.bounds;\n    return bounds;\n  }));\n  var midX = commonBounds.minX + commonBounds.width / 2;\n  var midY = commonBounds.minY + commonBounds.height / 2;\n  var deltaMap = Object.fromEntries(boundsForShapes.map(function (_ref2) {\n    var _AlignType$CenterVert;\n\n    var id = _ref2.id,\n        point = _ref2.point,\n        bounds = _ref2.bounds;\n    return [id, {\n      prev: point,\n      next: (_AlignType$CenterVert = {}, _AlignType$CenterVert[exports.AlignType.CenterVertical] = [point[0], midY - bounds.height / 2], _AlignType$CenterVert[exports.AlignType.CenterHorizontal] = [midX - bounds.width / 2, point[1]], _AlignType$CenterVert[exports.AlignType.Top] = [point[0], commonBounds.minY], _AlignType$CenterVert[exports.AlignType.Bottom] = [point[0], commonBounds.maxY - bounds.height], _AlignType$CenterVert[exports.AlignType.Left] = [commonBounds.minX, point[1]], _AlignType$CenterVert[exports.AlignType.Right] = [commonBounds.maxX - bounds.width, point[1]], _AlignType$CenterVert)[type]\n    }];\n  }));\n\n  var _TLDR$mutateShapes = TLDR.mutateShapes(data, ids, function (shape) {\n    if (!deltaMap[shape.id]) return shape;\n    return {\n      point: deltaMap[shape.id].next\n    };\n  }),\n      before = _TLDR$mutateShapes.before,\n      after = _TLDR$mutateShapes.after;\n\n  return {\n    id: 'align_shapes',\n    before: {\n      page: {\n        shapes: _extends({}, before)\n      }\n    },\n    after: {\n      page: {\n        shapes: _extends({}, after)\n      }\n    }\n  };\n}\n\nfunction distribute(data, ids, type) {\n  var initialShapes = ids.map(function (id) {\n    return data.page.shapes[id];\n  });\n  var deltaMap = Object.fromEntries(getDistributions(initialShapes, type).map(function (d) {\n    return [d.id, d];\n  }));\n\n  var _TLDR$mutateShapes = TLDR.mutateShapes(data, ids, function (shape) {\n    if (!deltaMap[shape.id]) return shape;\n    return {\n      point: deltaMap[shape.id].next\n    };\n  }),\n      before = _TLDR$mutateShapes.before,\n      after = _TLDR$mutateShapes.after;\n\n  return {\n    id: 'distribute_shapes',\n    before: {\n      page: {\n        shapes: _extends({}, before)\n      }\n    },\n    after: {\n      page: {\n        shapes: _extends({}, after)\n      }\n    }\n  };\n}\n\nfunction getDistributions(initialShapes, type) {\n  var entries = initialShapes.map(function (shape) {\n    var utils = TLDR.getShapeUtils(shape);\n    return {\n      id: shape.id,\n      point: [].concat(shape.point),\n      bounds: utils.getBounds(shape),\n      center: utils.getCenter(shape)\n    };\n  });\n  var len = entries.length;\n  var commonBounds = core.Utils.getCommonBounds(entries.map(function (_ref) {\n    var bounds = _ref.bounds;\n    return bounds;\n  }));\n  var results = [];\n\n  switch (type) {\n    case exports.DistributeType.Horizontal:\n      {\n        var span = entries.reduce(function (a, c) {\n          return a + c.bounds.width;\n        }, 0);\n\n        if (span > commonBounds.width) {\n          var left = entries.sort(function (a, b) {\n            return a.bounds.minX - b.bounds.minX;\n          })[0];\n          var right = entries.sort(function (a, b) {\n            return b.bounds.maxX - a.bounds.maxX;\n          })[0];\n          var entriesToMove = entries.filter(function (a) {\n            return a !== left && a !== right;\n          }).sort(function (a, b) {\n            return a.center[0] - b.center[0];\n          });\n          var step = (right.center[0] - left.center[0]) / (len - 1);\n          var x = left.center[0] + step;\n          entriesToMove.forEach(function (_ref2, i) {\n            var id = _ref2.id,\n                point = _ref2.point,\n                bounds = _ref2.bounds;\n            results.push({\n              id: id,\n              prev: point,\n              next: [x + step * i - bounds.width / 2, bounds.minY]\n            });\n          });\n        } else {\n          var _entriesToMove = entries.sort(function (a, b) {\n            return a.center[0] - b.center[0];\n          });\n\n          var _x = commonBounds.minX;\n\n          var _step = (commonBounds.width - span) / (len - 1);\n\n          _entriesToMove.forEach(function (_ref3, i) {\n            var id = _ref3.id,\n                point = _ref3.point,\n                bounds = _ref3.bounds;\n            results.push({\n              id: id,\n              prev: point,\n              next: [_x, bounds.minY]\n            });\n            _x += bounds.width + _step;\n          });\n        }\n\n        break;\n      }\n\n    case exports.DistributeType.Vertical:\n      {\n        var _span = entries.reduce(function (a, c) {\n          return a + c.bounds.height;\n        }, 0);\n\n        if (_span > commonBounds.height) {\n          var top = entries.sort(function (a, b) {\n            return a.bounds.minY - b.bounds.minY;\n          })[0];\n          var bottom = entries.sort(function (a, b) {\n            return b.bounds.maxY - a.bounds.maxY;\n          })[0];\n\n          var _entriesToMove2 = entries.filter(function (a) {\n            return a !== top && a !== bottom;\n          }).sort(function (a, b) {\n            return a.center[1] - b.center[1];\n          });\n\n          var _step2 = (bottom.center[1] - top.center[1]) / (len - 1);\n\n          var y = top.center[1] + _step2;\n\n          _entriesToMove2.forEach(function (_ref4, i) {\n            var id = _ref4.id,\n                point = _ref4.point,\n                bounds = _ref4.bounds;\n            results.push({\n              id: id,\n              prev: point,\n              next: [bounds.minX, y + _step2 * i - bounds.height / 2]\n            });\n          });\n        } else {\n          var _entriesToMove3 = entries.sort(function (a, b) {\n            return a.center[1] - b.center[1];\n          });\n\n          var _y = commonBounds.minY;\n\n          var _step3 = (commonBounds.height - _span) / (len - 1);\n\n          _entriesToMove3.forEach(function (_ref5, i) {\n            var id = _ref5.id,\n                point = _ref5.point,\n                bounds = _ref5.bounds;\n            results.push({\n              id: id,\n              prev: point,\n              next: [bounds.minX, _y]\n            });\n            _y += bounds.height + _step3;\n          });\n        }\n\n        break;\n      }\n  }\n\n  return results;\n}\n\nfunction style(data, ids, changes) {\n  var _TLDR$mutateShapes = TLDR.mutateShapes(data, ids, function (shape) {\n    return {\n      style: _extends({}, shape.style, changes)\n    };\n  }),\n      before = _TLDR$mutateShapes.before,\n      after = _TLDR$mutateShapes.after;\n\n  return {\n    id: 'style_shapes',\n    before: {\n      page: {\n        shapes: _extends({}, before)\n      },\n      appState: {\n        currentStyle: _extends({}, data.appState.currentStyle)\n      }\n    },\n    after: {\n      page: {\n        shapes: _extends({}, after)\n      },\n      appState: {\n        currentStyle: _extends({}, data.appState.currentStyle, changes)\n      }\n    }\n  };\n}\n\nfunction duplicate(data, ids) {\n  var delta = core.Vec.div([16, 16], data.pageState.camera.zoom);\n  var after = Object.fromEntries(TLDR.getSelectedIds(data).map(function (id) {\n    return data.page.shapes[id];\n  }).map(function (shape) {\n    var id = core.Utils.uniqueId();\n    return [id, _extends({}, core.Utils.deepClone(shape), {\n      id: id,\n      point: core.Vec.add(shape.point, delta)\n    })];\n  }));\n  var before = Object.fromEntries(Object.keys(after).map(function (id) {\n    return [id, undefined];\n  }));\n  return {\n    id: 'duplicate',\n    before: {\n      page: {\n        shapes: _extends({}, before)\n      },\n      pageState: _extends({}, data.pageState, {\n        selectedIds: ids\n      })\n    },\n    after: {\n      page: {\n        shapes: _extends({}, after)\n      },\n      pageState: _extends({}, data.pageState, {\n        selectedIds: Object.keys(after)\n      })\n    }\n  };\n}\n\nfunction move(data, ids, type) {\n  var _result, _result2;\n\n  // Get the unique parent ids for the selected elements\n  var parentIds = new Set(ids.map(function (id) {\n    return data.page.shapes[id].parentId;\n  }));\n  var result = {\n    before: {},\n    after: {}\n  };\n  var startIndex;\n  var startChildIndex;\n  var step; // Collect shapes with common parents into a table under their parent id\n\n  Array.from(parentIds.values()).forEach(function (parentId) {\n    var sortedChildren = parentId === data.page.id ? Object.values(data.page.shapes).sort(function (a, b) {\n      return a.childIndex - b.childIndex;\n    }) : data.page.shapes[parentId].children.map(function (childId) {\n      return data.page.shapes[childId];\n    }).sort(function (a, b) {\n      return a.childIndex - b.childIndex;\n    });\n    var sortedChildIds = sortedChildren.map(function (shape) {\n      return shape.id;\n    });\n    var sortedIndicesToMove = ids.filter(function (id) {\n      return sortedChildIds.includes(id);\n    }).map(function (id) {\n      return sortedChildIds.indexOf(id);\n    }).sort(function (a, b) {\n      return a - b;\n    });\n    if (sortedIndicesToMove.length === sortedChildIds.length) return;\n\n    switch (type) {\n      case exports.MoveType.ToBack:\n        {\n          //               a       b  c\n          // Initial   1   2    3  4  5  6  7\n          // Final   .25  .5  .75  1  3  6  7\n          //           a   b    c\n          // Find the lowest \"open\" index\n          for (var i = 0; i < sortedChildIds.length; i++) {\n            if (sortedIndicesToMove.includes(i)) continue;\n            startIndex = i;\n            break;\n          } // Find the lowest child index that isn't in sortedIndicesToMove\n\n\n          startChildIndex = sortedChildren[startIndex].childIndex; // Find the step for each additional child\n\n          step = startChildIndex / (sortedIndicesToMove.length + 1); // Get the results of moving the selected shapes below the first open index's shape\n\n          result = TLDR.mutateShapes(data, sortedIndicesToMove.map(function (i) {\n            return sortedChildren[i].id;\n          }).reverse(), function (_shape, i) {\n            return {\n              childIndex: startChildIndex - (i + 1) * step\n            };\n          });\n          break;\n        }\n\n      case exports.MoveType.ToFront:\n        {\n          //              a     b  c\n          // Initial   1  2  3  4  5  6   7\n          // Final     1  3  6  7  8  9  10\n          //                       a  b   c\n          // Find the highest \"open\" index\n          for (var _i = sortedChildIds.length - 1; _i >= 0; _i--) {\n            if (sortedIndicesToMove.includes(_i)) continue;\n            startIndex = _i;\n            break;\n          } // Find the lowest child index that isn't in sortedIndicesToMove\n\n\n          startChildIndex = sortedChildren[startIndex].childIndex; // Find the step for each additional child\n\n          step = 1; // Get the results of moving the selected shapes below the first open index's shape\n\n          result = TLDR.mutateShapes(data, sortedIndicesToMove.map(function (i) {\n            return sortedChildren[i].id;\n          }), function (_shape, i) {\n            return {\n              childIndex: startChildIndex + (i + 1)\n            };\n          });\n          break;\n        }\n\n      case exports.MoveType.Backward:\n        {\n          //               a           b  c\n          // Initial    1  2     3     4  5  6  7\n          // Final     .5  1  1.66  2.33  3  6  7\n          //           a         b     c\n          var indexMap = {}; // Starting from the top...\n\n          for (var _i2 = sortedChildIds.length - 1; _i2 >= 0; _i2--) {\n            // If we found a moving index...\n            if (sortedIndicesToMove.includes(_i2)) {\n              for (var j = _i2; j >= 0; j--) {\n                // iterate downward until we find an open spot\n                if (!sortedIndicesToMove.includes(j)) {\n                  // i = the index of the first closed spot\n                  // j = the index of the first open spot\n                  startChildIndex = j === 0 ? sortedChildren[j].childIndex / 2 : sortedChildren[j - 1].childIndex;\n\n                  var _step = (sortedChildren[j].childIndex - startChildIndex) / (_i2 - j + 1);\n\n                  for (var k = 0; k < _i2 - j; k++) {\n                    indexMap[sortedChildren[j + k + 1].id] = startChildIndex + _step * (k + 1);\n                  }\n\n                  break;\n                }\n              }\n            }\n          }\n\n          if (Object.values(indexMap).length > 0) {\n            // Get the results of moving the selected shapes below the first open index's shape\n            result = TLDR.mutateShapes(data, sortedIndicesToMove.map(function (i) {\n              return sortedChildren[i].id;\n            }), function (shape) {\n              return {\n                childIndex: indexMap[shape.id]\n              };\n            });\n          }\n\n          break;\n        }\n\n      case exports.MoveType.Forward:\n        {\n          //             a     b c\n          // Initial   1 2   3 4 5 6 7\n          // Final     1 3 3.5 6 7 8 9\n          //                 a     b c\n          var _indexMap = {}; // Starting from the top...\n\n          for (var _i3 = 0; _i3 < sortedChildIds.length; _i3++) {\n            // If we found a moving index...\n            if (sortedIndicesToMove.includes(_i3)) {\n              // Search for the first open spot above this one\n              for (var _j = _i3; _j < sortedChildIds.length; _j++) {\n                if (!sortedIndicesToMove.includes(_j)) {\n                  // i = the low index of the first closed spot\n                  // j = the high index of the first open spot\n                  startChildIndex = sortedChildren[_j].childIndex;\n\n                  var _step2 = _j === sortedChildIds.length - 1 ? 1 : (sortedChildren[_j + 1].childIndex - startChildIndex) / (_j - _i3 + 1);\n\n                  for (var _k = 0; _k < _j - _i3; _k++) {\n                    _indexMap[sortedChildren[_i3 + _k].id] = startChildIndex + _step2 * (_k + 1);\n                  }\n\n                  break;\n                }\n              }\n            }\n          }\n\n          if (Object.values(_indexMap).length > 0) {\n            // Get the results of moving the selected shapes below the first open index's shape\n            result = TLDR.mutateShapes(data, sortedIndicesToMove.map(function (i) {\n              return sortedChildren[i].id;\n            }), function (shape) {\n              return {\n                childIndex: _indexMap[shape.id]\n              };\n            });\n          }\n\n          break;\n        }\n    }\n  });\n  return {\n    id: 'move_shapes',\n    before: {\n      page: _extends({}, data.page, {\n        shapes: ((_result = result) == null ? void 0 : _result.before) || {}\n      })\n    },\n    after: {\n      page: _extends({}, data.page, {\n        shapes: ((_result2 = result) == null ? void 0 : _result2.after) || {}\n      })\n    }\n  };\n}\n\nfunction translate(data, ids, delta) {\n  var _TLDR$mutateShapes = TLDR.mutateShapes(data, ids, function (shape) {\n    return {\n      point: core.Vec.add(shape.point, delta)\n    };\n  }),\n      before = _TLDR$mutateShapes.before,\n      after = _TLDR$mutateShapes.after;\n\n  return {\n    id: 'translate_shapes',\n    before: {\n      page: _extends({}, data.page, {\n        shapes: _extends({}, before)\n      })\n    },\n    after: {\n      page: _extends({}, data.page, {\n        shapes: _extends({}, after)\n      })\n    }\n  };\n}\n\nfunction toggle(data, ids, prop) {\n  var initialShapes = ids.map(function (id) {\n    return data.page.shapes[id];\n  });\n  var isAllToggled = initialShapes.every(function (shape) {\n    return shape[prop];\n  });\n\n  var _TLDR$mutateShapes = TLDR.mutateShapes(data, TLDR.getSelectedIds(data), function () {\n    var _ref;\n\n    return _ref = {}, _ref[prop] = !isAllToggled, _ref;\n  }),\n      before = _TLDR$mutateShapes.before,\n      after = _TLDR$mutateShapes.after;\n\n  return {\n    id: 'toggle_shapes',\n    before: {\n      page: {\n        shapes: _extends({}, before)\n      }\n    },\n    after: {\n      page: {\n        shapes: _extends({}, after)\n      }\n    }\n  };\n}\n\nfunction deleteShapes(data, ids) {\n  return {\n    id: 'toggle_shapes',\n    before: {\n      page: {\n        shapes: Object.fromEntries(ids.map(function (id) {\n          return [id, data.page.shapes[id]];\n        }))\n      },\n      pageState: {\n        selectedIds: [].concat(data.pageState.selectedIds)\n      }\n    },\n    after: {\n      page: {\n        shapes: Object.fromEntries(ids.map(function (id) {\n          return [id, undefined];\n        }))\n      },\n      pageState: {\n        selectedIds: []\n      }\n    }\n  };\n}\n\nvar PI2 = Math.PI * 2;\nfunction rotate(data, ids, delta) {\n  if (delta === void 0) {\n    delta = -PI2 / 4;\n  }\n\n  var initialShapes = ids.map(function (id) {\n    return data.page.shapes[id];\n  });\n  var boundsForShapes = initialShapes.map(function (shape) {\n    var utils = TLDR.getShapeUtils(shape);\n    return {\n      id: shape.id,\n      point: [].concat(shape.point),\n      bounds: utils.getBounds(shape),\n      center: utils.getCenter(shape),\n      rotation: shape.rotation\n    };\n  });\n  var commonBounds = core.Utils.getCommonBounds(boundsForShapes.map(function (_ref) {\n    var bounds = _ref.bounds;\n    return bounds;\n  }));\n  var commonBoundsCenter = core.Utils.getBoundsCenter(commonBounds);\n  var rotations = Object.fromEntries(boundsForShapes.map(function (_ref2) {\n    var id = _ref2.id,\n        point = _ref2.point,\n        center = _ref2.center,\n        rotation = _ref2.rotation;\n    var offset = core.Vec.sub(center, point);\n    var nextPoint = core.Vec.sub(core.Vec.rotWith(center, commonBoundsCenter, -(PI2 / 4)), offset);\n    var nextRotation = (PI2 + ((rotation || 0) + delta)) % PI2;\n    return [id, {\n      point: nextPoint,\n      rotation: nextRotation\n    }];\n  }));\n  var prevBoundsRotation = data.pageState.boundsRotation;\n  var nextBoundsRotation = (PI2 + ((data.pageState.boundsRotation || 0) + delta)) % PI2;\n\n  var _TLDR$mutateShapes = TLDR.mutateShapes(data, ids, function (shape) {\n    return rotations[shape.id];\n  }),\n      before = _TLDR$mutateShapes.before,\n      after = _TLDR$mutateShapes.after;\n\n  return {\n    id: 'toggle_shapes',\n    before: {\n      page: {\n        shapes: _extends({}, before)\n      },\n      pageState: {\n        boundsRotation: prevBoundsRotation\n      }\n    },\n    after: {\n      page: {\n        shapes: _extends({}, after)\n      },\n      pageState: {\n        boundsRotation: nextBoundsRotation\n      }\n    }\n  };\n}\n\nfunction stretch(data, ids, type) {\n  var initialShapes = ids.map(function (id) {\n    return data.page.shapes[id];\n  });\n  var boundsForShapes = initialShapes.map(function (shape) {\n    return TLDR.getBounds(shape);\n  });\n  var commonBounds = core.Utils.getCommonBounds(boundsForShapes);\n\n  var _TLDR$mutateShapes = TLDR.mutateShapes(data, ids, function (shape) {\n    var bounds = TLDR.getBounds(shape);\n\n    switch (type) {\n      case exports.StretchType.Horizontal:\n        {\n          var newBounds = _extends({}, bounds, {\n            minX: commonBounds.minX,\n            maxX: commonBounds.maxX,\n            width: commonBounds.width\n          });\n\n          return TLDR.getShapeUtils(shape).transformSingle(shape, newBounds, {\n            type: core.TLBoundsCorner.TopLeft,\n            scaleX: newBounds.width / bounds.width,\n            scaleY: 1,\n            initialShape: shape,\n            transformOrigin: [0.5, 0.5]\n          });\n        }\n\n      case exports.StretchType.Vertical:\n        {\n          var _newBounds = _extends({}, bounds, {\n            minY: commonBounds.minY,\n            maxY: commonBounds.maxY,\n            height: commonBounds.height\n          });\n\n          return TLDR.getShapeUtils(shape).transformSingle(shape, _newBounds, {\n            type: core.TLBoundsCorner.TopLeft,\n            scaleX: 1,\n            scaleY: _newBounds.height / bounds.height,\n            initialShape: shape,\n            transformOrigin: [0.5, 0.5]\n          });\n        }\n    }\n  }),\n      before = _TLDR$mutateShapes.before,\n      after = _TLDR$mutateShapes.after;\n\n  return {\n    id: 'stretch_shapes',\n    before: {\n      page: {\n        shapes: _extends({}, before)\n      }\n    },\n    after: {\n      page: {\n        shapes: _extends({}, after)\n      }\n    }\n  };\n}\n\nfunction create(data, shapes) {\n  return {\n    id: 'toggle_shapes',\n    before: {\n      page: {\n        shapes: Object.fromEntries(shapes.map(function (shape) {\n          return [shape.id, undefined];\n        }))\n      }\n    },\n    after: {\n      page: {\n        shapes: Object.fromEntries(shapes.map(function (shape) {\n          return [shape.id, shape];\n        }))\n      }\n    }\n  };\n}\n\nvar BrushSession = /*#__PURE__*/function () {\n  function BrushSession(_data, _point) {\n    var _this = this;\n\n    this.id = 'brush';\n    this.origin = void 0;\n    this.snapshot = void 0;\n\n    this.start = function (data) {\n      return data;\n    };\n\n    this.update = function (data, point, containMode) {\n      if (containMode === void 0) {\n        containMode = false;\n      }\n\n      var snapshot = _this.snapshot,\n          origin = _this.origin; // Create a bounding box between the origin and the new point\n\n      var brush = core.Utils.getBoundsFromPoints([origin, point]);\n      core.brushUpdater.set(brush); // Find ids of brushed shapes\n\n      var hits = new Set();\n      var selectedIds = new Set(snapshot.selectedIds);\n      snapshot.shapesToTest.forEach(function (_ref) {\n        var id = _ref.id,\n            util = _ref.util,\n            selectId = _ref.selectId;\n        if (selectedIds.has(id)) return;\n        var shape = data.page.shapes[id];\n\n        if (!hits.has(selectId)) {\n          if (containMode ? core.Utils.boundsContain(brush, util.getBounds(shape)) : util.hitTestBounds(shape, brush)) {\n            hits.add(selectId); // When brushing a shape, select its top group parent.\n\n            if (!selectedIds.has(selectId)) {\n              selectedIds.add(selectId);\n            }\n          } else if (selectedIds.has(selectId)) {\n            selectedIds[\"delete\"](selectId);\n          }\n        }\n      });\n\n      if (selectedIds.size === data.pageState.selectedIds.length && data.pageState.selectedIds.every(function (id) {\n        return selectedIds.has(id);\n      })) {\n        return data;\n      }\n\n      return _extends({}, data, {\n        pageState: _extends({}, data.pageState, {\n          selectedIds: Array.from(selectedIds.values())\n        })\n      });\n    };\n\n    this.origin = core.Vec.round(_point);\n    this.snapshot = getBrushSnapshot(_data);\n  }\n\n  var _proto = BrushSession.prototype;\n\n  _proto.cancel = function cancel(data) {\n    return _extends({}, data, {\n      pageState: _extends({}, data.pageState, {\n        selectedIds: this.snapshot.selectedIds\n      })\n    });\n  };\n\n  _proto.complete = function complete(data) {\n    return _extends({}, data, {\n      pageState: _extends({}, data.pageState, {\n        selectedIds: [].concat(data.pageState.selectedIds)\n      })\n    });\n  };\n\n  return BrushSession;\n}();\n/**\r\n * Get a snapshot of the current selected ids, for each shape that is\r\n * not already selected, the shape's id and a test to see whether the\r\n * brush will intersect that shape. For tests, start broad -> fine.\r\n */\n\nfunction getBrushSnapshot(data) {\n  var selectedIds = [].concat(data.pageState.selectedIds);\n  var shapesToTest = TLDR.getShapes(data).filter(function (shape) {\n    return !(shape.isHidden || shape.children !== undefined || selectedIds.includes(shape.id) || selectedIds.includes(shape.parentId));\n  }).map(function (shape) {\n    return {\n      id: shape.id,\n      util: getShapeUtils(shape),\n      bounds: getShapeUtils(shape).getBounds(shape),\n      selectId: TLDR.getTopParentId(data, shape.id)\n    };\n  });\n  return {\n    selectedIds: selectedIds,\n    shapesToTest: shapesToTest\n  };\n}\n\nvar TranslateSession = /*#__PURE__*/function () {\n  function TranslateSession(_data, _point) {\n    var _this = this;\n\n    this.id = 'translate';\n    this.delta = [0, 0];\n    this.prev = [0, 0];\n    this.origin = void 0;\n    this.snapshot = void 0;\n    this.isCloning = false;\n\n    this.start = function (data) {\n      return data;\n    };\n\n    this.update = function (data, point, isAligned, isCloning) {\n      if (isAligned === void 0) {\n        isAligned = false;\n      }\n\n      if (isCloning === void 0) {\n        isCloning = false;\n      }\n\n      var _this$snapshot = _this.snapshot,\n          clones = _this$snapshot.clones,\n          initialShapes = _this$snapshot.initialShapes;\n\n      var next = _extends({}, data, {\n        page: _extends({}, data.page),\n        shapes: _extends({}, data.page.shapes),\n        pageState: _extends({}, data.pageState)\n      });\n\n      var delta = core.Vec.sub(point, _this.origin);\n\n      if (isAligned) {\n        if (Math.abs(delta[0]) < Math.abs(delta[1])) {\n          delta[0] = 0;\n        } else {\n          delta[1] = 0;\n        }\n      }\n\n      var trueDelta = core.Vec.sub(delta, _this.prev);\n      _this.delta = delta;\n      _this.prev = delta; // If cloning...\n\n      if (isCloning) {\n        // Not Cloning -> Cloning\n        if (!_this.isCloning) {\n          _this.isCloning = true; // Move original shapes back to start\n\n          next.page.shapes = _extends({}, next.page.shapes, Object.fromEntries(initialShapes.map(function (shape) {\n            return [shape.id, _extends({}, next.page.shapes[shape.id], {\n              point: shape.point\n            })];\n          })));\n          next.page.shapes = _extends({}, next.page.shapes, Object.fromEntries(clones.map(function (clone) {\n            return [clone.id, _extends({}, clone, {\n              point: core.Vec.add(clone.point, delta)\n            })];\n          })));\n          next.pageState.selectedIds = clones.map(function (c) {\n            return c.id;\n          });\n        } // Either way, move the clones\n\n\n        next.page.shapes = _extends({}, next.page.shapes, Object.fromEntries(clones.map(function (clone) {\n          return [clone.id, _extends({}, clone, {\n            point: core.Vec.add(next.page.shapes[clone.id].point, trueDelta)\n          })];\n        })));\n        return next;\n      } // If not cloning...\n      // Cloning -> Not Cloning\n\n\n      if (_this.isCloning) {\n        _this.isCloning = false; // Delete the clones\n\n        clones.forEach(function (clone) {\n          return delete next.page.shapes[clone.id];\n        }); // Move the original shapes back to the cursor position\n\n        next.page.shapes = _extends({}, next.page.shapes, Object.fromEntries(initialShapes.map(function (shape) {\n          return [shape.id, _extends({}, next.page.shapes[shape.id], {\n            point: core.Vec.add(shape.point, delta)\n          })];\n        }))); // Set selected ids\n\n        next.pageState.selectedIds = initialShapes.map(function (c) {\n          return c.id;\n        });\n      } // Move the shapes by the delta\n\n\n      next.page.shapes = _extends({}, next.page.shapes, Object.fromEntries(initialShapes.map(function (shape) {\n        return [shape.id, _extends({}, next.page.shapes[shape.id], {\n          point: core.Vec.add(next.page.shapes[shape.id].point, trueDelta)\n        })];\n      })));\n      return next;\n    };\n\n    this.cancel = function (data) {\n      return _extends({}, data, {\n        page: _extends({}, data.page, {\n          // @ts-ignore - We need to set deleted shapes to undefined in order to correctly deep merge them away.\n          shapes: _extends({}, data.page.shapes, Object.fromEntries(_this.snapshot.clones.map(function (clone) {\n            return [clone.id, undefined];\n          })), Object.fromEntries(_this.snapshot.initialShapes.map(function (shape) {\n            return [shape.id, _extends({}, data.page.shapes[shape.id], {\n              point: shape.point\n            })];\n          })))\n        }),\n        pageState: _extends({}, data.pageState, {\n          selectedIds: _this.snapshot.selectedIds\n        })\n      });\n    };\n\n    this.origin = _point;\n    this.snapshot = getTranslateSnapshot(_data);\n  }\n\n  var _proto = TranslateSession.prototype;\n\n  _proto.complete = function complete(data) {\n    return {\n      id: 'translate',\n      before: _extends({}, data, {\n        page: _extends({}, data.page, {\n          shapes: _extends({}, data.page.shapes, Object.fromEntries(this.snapshot.clones.map(function (clone) {\n            return [clone.id, undefined];\n          })), Object.fromEntries(this.snapshot.initialShapes.map(function (shape) {\n            return [shape.id, {\n              point: shape.point\n            }];\n          })))\n        }),\n        pageState: _extends({}, data.pageState, {\n          selectedIds: this.snapshot.selectedIds\n        })\n      }),\n      after: _extends({}, data, {\n        page: _extends({}, data.page, {\n          shapes: _extends({}, data.page.shapes, Object.fromEntries(this.snapshot.clones.map(function (clone) {\n            return [clone.id, data.page.shapes[clone.id]];\n          })), Object.fromEntries(this.snapshot.initialShapes.map(function (shape) {\n            return [shape.id, {\n              point: data.page.shapes[shape.id].point\n            }];\n          })))\n        }),\n        pageState: _extends({}, data.pageState, {\n          selectedIds: [].concat(data.pageState.selectedIds)\n        })\n      })\n    };\n  };\n\n  return TranslateSession;\n}(); // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n\nfunction getTranslateSnapshot(data) {\n  var selectedShapes = TLDR.getSelectedShapeSnapshot(data);\n  var hasUnlockedShapes = selectedShapes.length > 0;\n  var initialParents = Array.from(new Set(selectedShapes.map(function (s) {\n    return s.parentId;\n  })).values()).filter(function (id) {\n    return id !== data.page.id;\n  }).map(function (id) {\n    var shape = TLDR.getShape(data, id);\n    return {\n      id: id,\n      children: shape.children\n    };\n  });\n  return {\n    selectedIds: TLDR.getSelectedIds(data),\n    hasUnlockedShapes: hasUnlockedShapes,\n    initialParents: initialParents,\n    initialShapes: selectedShapes.map(function (_ref) {\n      var id = _ref.id,\n          point = _ref.point,\n          parentId = _ref.parentId;\n      return {\n        id: id,\n        point: point,\n        parentId: parentId\n      };\n    }),\n    clones: selectedShapes.filter(function (shape) {\n      return shape.children === undefined;\n    }).flatMap(function (shape) {\n      var clone = _extends({}, shape, {\n        id: core.Utils.uniqueId(),\n        parentId: shape.parentId,\n        childIndex: TLDR.getChildIndexAbove(data, shape.id)\n      });\n\n      return clone;\n    })\n  };\n}\n\nvar TransformSingleSession = /*#__PURE__*/function () {\n  function TransformSingleSession(_data, _point, _transformType, commandId) {\n    var _this = this;\n\n    if (_transformType === void 0) {\n      _transformType = core.TLBoundsCorner.BottomRight;\n    }\n\n    if (commandId === void 0) {\n      commandId = 'transform_single';\n    }\n\n    this.id = 'transform_single';\n    this.commandId = void 0;\n    this.transformType = void 0;\n    this.origin = void 0;\n    this.scaleX = 1;\n    this.scaleY = 1;\n    this.snapshot = void 0;\n\n    this.start = function (data) {\n      return data;\n    };\n\n    this.update = function (data, point, isAspectRatioLocked) {\n      var _extends2;\n\n      if (isAspectRatioLocked === void 0) {\n        isAspectRatioLocked = false;\n      }\n\n      var transformType = _this.transformType;\n      var _this$snapshot = _this.snapshot,\n          initialShapeBounds = _this$snapshot.initialShapeBounds,\n          initialShape = _this$snapshot.initialShape,\n          id = _this$snapshot.id;\n      var shape = data.page.shapes[id];\n      var utils = TLDR.getShapeUtils(shape);\n      var newBounds = core.Utils.getTransformedBoundingBox(initialShapeBounds, transformType, core.Vec.sub(point, _this.origin), shape.rotation, isAspectRatioLocked || shape.isAspectRatioLocked || utils.isAspectRatioLocked);\n      return _extends({}, data, {\n        page: _extends({}, data.page, {\n          shapes: _extends({}, data.page.shapes, (_extends2 = {}, _extends2[shape.id] = _extends({}, initialShape, TLDR.getShapeUtils(shape).transformSingle(shape, newBounds, {\n            initialShape: initialShape,\n            type: _this.transformType,\n            scaleX: newBounds.scaleX,\n            scaleY: newBounds.scaleY,\n            transformOrigin: [0.5, 0.5]\n          })), _extends2))\n        })\n      });\n    };\n\n    this.cancel = function (data) {\n      var _extends3;\n\n      var _this$snapshot2 = _this.snapshot,\n          id = _this$snapshot2.id,\n          initialShape = _this$snapshot2.initialShape;\n      data.page.shapes[id] = initialShape;\n      return _extends({}, data, {\n        page: _extends({}, data.page, {\n          shapes: _extends({}, data.page.shapes, (_extends3 = {}, _extends3[id] = initialShape, _extends3))\n        })\n      });\n    };\n\n    this.origin = _point;\n    this.transformType = _transformType;\n    this.snapshot = getTransformSingleSnapshot(_data, _transformType);\n    this.commandId = commandId;\n  }\n\n  var _proto = TransformSingleSession.prototype;\n\n  _proto.complete = function complete(data) {\n    var _shapes, _shapes2;\n\n    if (!this.snapshot.hasUnlockedShape) return data;\n    return {\n      id: this.commandId,\n      before: {\n        page: {\n          shapes: (_shapes = {}, _shapes[this.snapshot.id] = this.snapshot.initialShape, _shapes)\n        }\n      },\n      after: {\n        page: {\n          shapes: (_shapes2 = {}, _shapes2[this.snapshot.id] = TLDR.onSessionComplete(data, data.page.shapes[this.snapshot.id]), _shapes2)\n        }\n      }\n    };\n  };\n\n  return TransformSingleSession;\n}();\nfunction getTransformSingleSnapshot(data, transformType) {\n  var shape = data.page.shapes[data.pageState.selectedIds[0]];\n\n  if (!shape) {\n    throw Error('You must have one shape selected.');\n  }\n\n  var bounds = TLDR.getBounds(shape);\n  return {\n    id: shape.id,\n    hasUnlockedShape: !shape.isLocked,\n    type: transformType,\n    initialShape: core.Utils.deepClone(shape),\n    initialShapeBounds: bounds\n  };\n}\n\nvar TransformSession = /*#__PURE__*/function () {\n  function TransformSession(_data, _point, _transformType) {\n    var _this = this;\n\n    if (_transformType === void 0) {\n      _transformType = core.TLBoundsCorner.BottomRight;\n    }\n\n    this.id = 'transform';\n    this.scaleX = 1;\n    this.scaleY = 1;\n    this.transformType = void 0;\n    this.origin = void 0;\n    this.snapshot = void 0;\n\n    this.start = function (data) {\n      return data;\n    };\n\n    this.update = function (data, point, isAspectRatioLocked, _altKey) {\n      if (isAspectRatioLocked === void 0) {\n        isAspectRatioLocked = false;\n      }\n\n      var transformType = _this.transformType,\n          _this$snapshot = _this.snapshot,\n          shapeBounds = _this$snapshot.shapeBounds,\n          initialBounds = _this$snapshot.initialBounds,\n          isAllAspectRatioLocked = _this$snapshot.isAllAspectRatioLocked;\n\n      var next = _extends({}, data, {\n        page: _extends({}, data.page)\n      });\n\n      var shapes = next.page.shapes;\n      var newBoundingBox = core.Utils.getTransformedBoundingBox(initialBounds, transformType, core.Vec.vec(_this.origin, point), data.pageState.boundsRotation, isAspectRatioLocked || isAllAspectRatioLocked); // Now work backward to calculate a new bounding box for each of the shapes.\n\n      _this.scaleX = newBoundingBox.scaleX;\n      _this.scaleY = newBoundingBox.scaleY;\n      next.page.shapes = _extends({}, next.page.shapes, Object.fromEntries(Object.entries(shapeBounds).map(function (_ref) {\n        var id = _ref[0],\n            _ref$ = _ref[1],\n            initialShape = _ref$.initialShape,\n            initialShapeBounds = _ref$.initialShapeBounds,\n            transformOrigin = _ref$.transformOrigin;\n        var newShapeBounds = core.Utils.getRelativeTransformedBoundingBox(newBoundingBox, initialBounds, initialShapeBounds, _this.scaleX < 0, _this.scaleY < 0);\n        var shape = shapes[id];\n        return [id, _extends({}, initialShape, TLDR.transform(next, shape, newShapeBounds, {\n          type: _this.transformType,\n          initialShape: initialShape,\n          scaleX: _this.scaleX,\n          scaleY: _this.scaleY,\n          transformOrigin: transformOrigin\n        }))];\n      })));\n      return next;\n    };\n\n    this.cancel = function (data) {\n      var shapeBounds = _this.snapshot.shapeBounds;\n      return _extends({}, data, {\n        page: _extends({}, data.page, {\n          shapes: _extends({}, data.page.shapes, Object.fromEntries(Object.entries(shapeBounds).map(function (_ref2) {\n            var id = _ref2[0],\n                initialShape = _ref2[1].initialShape;\n            return [id, initialShape];\n          })))\n        })\n      });\n    };\n\n    this.origin = _point;\n    this.transformType = _transformType;\n    this.snapshot = getTransformSnapshot(_data, _transformType);\n  }\n\n  var _proto = TransformSession.prototype;\n\n  _proto.complete = function complete(data) {\n    var _this$snapshot2 = this.snapshot,\n        hasUnlockedShapes = _this$snapshot2.hasUnlockedShapes,\n        shapeBounds = _this$snapshot2.shapeBounds;\n    if (!hasUnlockedShapes) return data;\n    return {\n      id: 'transform',\n      before: {\n        page: {\n          shapes: Object.fromEntries(Object.entries(shapeBounds).map(function (_ref3) {\n            var id = _ref3[0],\n                initialShape = _ref3[1].initialShape;\n            return [id, initialShape];\n          }))\n        }\n      },\n      after: {\n        page: {\n          shapes: Object.fromEntries(this.snapshot.initialShapes.map(function (shape) {\n            return [shape.id, TLDR.onSessionComplete(data, data.page.shapes[shape.id])];\n          }))\n        }\n      }\n    };\n  };\n\n  return TransformSession;\n}();\nfunction getTransformSnapshot(data, transformType) {\n  var initialShapes = TLDR.getSelectedBranchSnapshot(data);\n  var hasUnlockedShapes = initialShapes.length > 0;\n  var isAllAspectRatioLocked = initialShapes.every(function (shape) {\n    return shape.isAspectRatioLocked || TLDR.getShapeUtils(shape).isAspectRatioLocked;\n  });\n  var shapesBounds = Object.fromEntries(initialShapes.map(function (shape) {\n    return [shape.id, TLDR.getBounds(shape)];\n  }));\n  var boundsArr = Object.values(shapesBounds);\n  var commonBounds = core.Utils.getCommonBounds(boundsArr);\n  var initialInnerBounds = core.Utils.getBoundsFromPoints(boundsArr.map(core.Utils.getBoundsCenter)); // Return a mapping of shapes to bounds together with the relative\n  // positions of the shape's bounds within the common bounds shape.\n\n  return {\n    type: transformType,\n    hasUnlockedShapes: hasUnlockedShapes,\n    isAllAspectRatioLocked: isAllAspectRatioLocked,\n    initialShapes: initialShapes,\n    initialBounds: commonBounds,\n    shapeBounds: Object.fromEntries(initialShapes.map(function (shape) {\n      var initialShapeBounds = shapesBounds[shape.id];\n      var ic = core.Utils.getBoundsCenter(initialShapeBounds);\n      var ix = (ic[0] - initialInnerBounds.minX) / initialInnerBounds.width;\n      var iy = (ic[1] - initialInnerBounds.minY) / initialInnerBounds.height;\n      return [shape.id, {\n        initialShape: shape,\n        initialShapeBounds: initialShapeBounds,\n        transformOrigin: [ix, iy]\n      }];\n    }))\n  };\n}\n\nvar DrawSession = function DrawSession(_data, id, _point) {\n  var _this = this;\n\n  this.id = 'draw';\n  this.origin = void 0;\n  this.previous = void 0;\n  this.last = void 0;\n  this.points = void 0;\n  this.snapshot = void 0;\n  this.isLocked = void 0;\n  this.lockedDirection = void 0;\n\n  this.start = function (data) {\n    return data;\n  };\n\n  this.update = function (data, point, pressure, isLocked) {\n    var _extends2;\n\n    if (isLocked === void 0) {\n      isLocked = false;\n    }\n\n    var snapshot = _this.snapshot; // Drawing while holding shift will \"lock\" the pen to either the\n    // x or y axis, depending on which direction has the greater\n    // delta. Pressing shift will also add more points to \"return\"\n    // the pen to the axis.\n\n    if (isLocked) {\n      if (!_this.isLocked && _this.points.length > 1) {\n        var bounds = core.Utils.getBoundsFromPoints(_this.points);\n\n        if (bounds.width > 8 || bounds.height > 8) {\n          _this.isLocked = true;\n          var returning = [].concat(_this.previous);\n          var isVertical = bounds.height > 8;\n\n          if (isVertical) {\n            _this.lockedDirection = 'vertical';\n            returning[0] = _this.origin[0];\n          } else {\n            _this.lockedDirection = 'horizontal';\n            returning[1] = _this.origin[1];\n          }\n\n          _this.previous = returning;\n\n          _this.points.push(core.Vec.sub(returning, _this.origin));\n        }\n      }\n    } else if (_this.isLocked) {\n      _this.isLocked = false;\n    }\n\n    if (_this.isLocked) {\n      if (_this.lockedDirection === 'vertical') {\n        point[0] = _this.origin[0];\n      } else {\n        point[1] = _this.origin[1];\n      }\n    } // Low pass the current input point against the previous one\n\n\n    var nextPrev = core.Vec.med(_this.previous, point);\n    _this.previous = nextPrev; // Don't add duplicate points. It's important to test against the\n    // adjusted (low-passed) point rather than the input point.\n\n    var newPoint = core.Vec.round([].concat(core.Vec.sub(_this.previous, _this.origin), [pressure]));\n    if (core.Vec.isEqual(_this.last, newPoint)) return data;\n    _this.last = newPoint;\n\n    _this.points.push(newPoint); // We draw a dot when the number of points is 1 or 2, so this guard\n    // prevents a \"flash\" of a dot when a user begins drawing a line.\n\n\n    if (_this.points.length <= 2) return data;\n    return _extends({}, data, {\n      page: _extends({}, data.page, {\n        shapes: _extends({}, data.page.shapes, (_extends2 = {}, _extends2[snapshot.id] = _extends({}, data.page.shapes[snapshot.id], {\n          points: [].concat(_this.points)\n        }), _extends2))\n      }),\n      pageState: _extends({}, data.pageState, {\n        selectedIds: [snapshot.id]\n      })\n    });\n  };\n\n  this.cancel = function (data) {\n    var _extends3;\n\n    var snapshot = _this.snapshot;\n    return _extends({}, data, {\n      page: _extends({}, data.page, {\n        // @ts-ignore\n        shapes: _extends({}, data.page.shapes, (_extends3 = {}, _extends3[snapshot.id] = undefined, _extends3))\n      }),\n      pageState: _extends({}, data.pageState, {\n        selectedIds: []\n      })\n    });\n  };\n\n  this.complete = function (data) {\n    var _shapes, _shapes2;\n\n    var snapshot = _this.snapshot;\n    return {\n      id: 'create_draw',\n      before: {\n        page: {\n          shapes: (_shapes = {}, _shapes[snapshot.id] = undefined, _shapes)\n        },\n        pageState: {\n          selectedIds: []\n        }\n      },\n      after: {\n        page: {\n          shapes: (_shapes2 = {}, _shapes2[snapshot.id] = TLDR.onSessionComplete(data, data.page.shapes[snapshot.id]), _shapes2)\n        },\n        pageState: {\n          selectedIds: []\n        }\n      }\n    };\n  };\n\n  this.origin = _point;\n  this.previous = _point;\n  this.last = _point;\n  this.snapshot = getDrawSnapshot(_data, id); // Add a first point but don't update the shape yet. We'll update\n  // when the draw session ends; if the user hasn't added additional\n  // points, this single point will be interpreted as a \"dot\" shape.\n\n  this.points = [[0, 0, 0.5]];\n}; // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n\nfunction getDrawSnapshot(data, shapeId) {\n  var page = data.page;\n\n  var _Utils$deepClone = core.Utils.deepClone(page.shapes[shapeId]),\n      points = _Utils$deepClone.points,\n      point = _Utils$deepClone.point;\n\n  return {\n    id: shapeId,\n    point: point,\n    points: points\n  };\n}\n\nvar PI2$1 = Math.PI * 2;\nvar RotateSession = /*#__PURE__*/function () {\n  function RotateSession(_data, _point) {\n    var _this = this;\n\n    this.id = 'rotate';\n    this.delta = [0, 0];\n    this.origin = void 0;\n    this.snapshot = void 0;\n    this.prev = 0;\n\n    this.start = function (data) {\n      return data;\n    };\n\n    this.update = function (data, point, isLocked) {\n      if (isLocked === void 0) {\n        isLocked = false;\n      }\n\n      var _this$snapshot = _this.snapshot,\n          commonBoundsCenter = _this$snapshot.commonBoundsCenter,\n          initialShapes = _this$snapshot.initialShapes;\n\n      var next = _extends({}, data, {\n        page: _extends({}, data.page),\n        pageState: _extends({}, data.pageState)\n      });\n\n      var page = next.page,\n          pageState = next.pageState;\n      var a1 = core.Vec.angle(commonBoundsCenter, _this.origin);\n      var a2 = core.Vec.angle(commonBoundsCenter, point);\n      var rot = a2 - a1;\n      _this.prev = rot;\n\n      if (isLocked) {\n        rot = core.Utils.clampToRotationToSegments(rot, 24);\n      }\n\n      pageState.boundsRotation = (PI2$1 + (_this.snapshot.boundsRotation + rot)) % PI2$1;\n      next.page.shapes = _extends({}, next.page.shapes, Object.fromEntries(initialShapes.map(function (_ref) {\n        var id = _ref.id,\n            center = _ref.center,\n            offset = _ref.offset,\n            _ref$shape$rotation = _ref.shape.rotation,\n            rotation = _ref$shape$rotation === void 0 ? 0 : _ref$shape$rotation;\n        var shape = page.shapes[id];\n        var nextRotation = isLocked ? core.Utils.clampToRotationToSegments(rotation + rot, 24) : rotation + rot;\n        var nextPoint = core.Vec.sub(core.Vec.rotWith(center, commonBoundsCenter, rot), offset);\n        return [id, _extends({}, next.page.shapes[id], TLDR.mutate(data, shape, {\n          point: nextPoint,\n          rotation: (PI2$1 + nextRotation) % PI2$1\n        }))];\n      })));\n      return next;\n    };\n\n    this.cancel = function (data) {\n      var initialShapes = _this.snapshot.initialShapes;\n\n      for (var _iterator = _createForOfIteratorHelperLoose(initialShapes), _step; !(_step = _iterator()).done;) {\n        var _step$value = _step.value,\n            id = _step$value.id,\n            shape = _step$value.shape;\n        data.page.shapes[id] = _extends({}, shape);\n      }\n\n      return _extends({}, data, {\n        page: _extends({}, data.page, {\n          shapes: _extends({}, data.page.shapes, Object.fromEntries(initialShapes.map(function (_ref2) {\n            var id = _ref2.id,\n                shape = _ref2.shape;\n            return [id, TLDR.onSessionComplete(data, shape)];\n          })))\n        })\n      });\n    };\n\n    this.origin = _point;\n    this.snapshot = getRotateSnapshot(_data);\n  }\n\n  var _proto = RotateSession.prototype;\n\n  _proto.complete = function complete(data) {\n    var _this$snapshot2 = this.snapshot,\n        hasUnlockedShapes = _this$snapshot2.hasUnlockedShapes,\n        initialShapes = _this$snapshot2.initialShapes;\n    if (!hasUnlockedShapes) return data;\n    return {\n      id: 'rotate',\n      before: {\n        page: {\n          shapes: Object.fromEntries(initialShapes.map(function (_ref3) {\n            var _ref3$shape = _ref3.shape,\n                id = _ref3$shape.id,\n                point = _ref3$shape.point,\n                _ref3$shape$rotation = _ref3$shape.rotation,\n                rotation = _ref3$shape$rotation === void 0 ? undefined : _ref3$shape$rotation;\n            return [id, {\n              point: point,\n              rotation: rotation\n            }];\n          }))\n        }\n      },\n      after: {\n        page: {\n          shapes: Object.fromEntries(this.snapshot.initialShapes.map(function (_ref4) {\n            var shape = _ref4.shape;\n            var _data$page$shapes$sha = data.page.shapes[shape.id],\n                point = _data$page$shapes$sha.point,\n                rotation = _data$page$shapes$sha.rotation;\n            return [shape.id, {\n              point: point,\n              rotation: rotation\n            }];\n          }))\n        }\n      }\n    };\n  };\n\n  return RotateSession;\n}(); // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n\nfunction getRotateSnapshot(data) {\n  var initialShapes = TLDR.getSelectedBranchSnapshot(data);\n\n  if (initialShapes.length === 0) {\n    throw Error('No selected shapes!');\n  }\n\n  var hasUnlockedShapes = initialShapes.length > 0;\n  var shapesBounds = Object.fromEntries(initialShapes.map(function (shape) {\n    return [shape.id, TLDR.getBounds(shape)];\n  }));\n  var rotatedBounds = Object.fromEntries(initialShapes.map(function (shape) {\n    return [shape.id, TLDR.getRotatedBounds(shape)];\n  }));\n  var bounds = core.Utils.getCommonBounds(Object.values(shapesBounds));\n  var commonBoundsCenter = core.Utils.getBoundsCenter(bounds);\n  return {\n    hasUnlockedShapes: hasUnlockedShapes,\n    boundsRotation: data.pageState.boundsRotation || 0,\n    commonBoundsCenter: commonBoundsCenter,\n    initialShapes: initialShapes.filter(function (shape) {\n      return shape.children === undefined;\n    }).map(function (shape) {\n      var bounds = TLDR.getBounds(shape);\n      var center = core.Utils.getBoundsCenter(bounds);\n      var offset = core.Vec.sub(center, shape.point);\n      var rotationOffset = core.Vec.sub(center, core.Utils.getBoundsCenter(rotatedBounds[shape.id]));\n      return {\n        id: shape.id,\n        shape: core.Utils.deepClone(shape),\n        offset: offset,\n        rotationOffset: rotationOffset,\n        center: center\n      };\n    })\n  };\n}\n\nvar HandleSession = /*#__PURE__*/function () {\n  function HandleSession(_data, _handleId, _point, commandId) {\n    var _this = this;\n\n    if (commandId === void 0) {\n      commandId = 'move_handle';\n    }\n\n    this.id = 'transform_single';\n    this.commandId = void 0;\n    this.delta = [0, 0];\n    this.origin = void 0;\n    this.shiftKey = false;\n    this.initialShape = void 0;\n    this.handleId = void 0;\n\n    this.start = function (data) {\n      return data;\n    };\n\n    this.update = function (data, point, shiftKey, altKey, metaKey) {\n      var _TLDR$getShapeUtils$o, _extends2;\n\n      var initialShape = _this.initialShape,\n          origin = _this.origin;\n      var shape = TLDR.getShape(data, initialShape.id);\n      TLDR.assertShapeHasProperty(shape, 'handles');\n      _this.shiftKey = shiftKey;\n      var delta = core.Vec.vec(origin, point);\n      var handles = initialShape.handles;\n      var handleId = _this.handleId;\n      var change = TLDR.getShapeUtils(shape).onHandleChange(shape, (_TLDR$getShapeUtils$o = {}, _TLDR$getShapeUtils$o[handleId] = _extends({}, shape.handles[handleId], {\n        point: core.Vec.round(core.Vec.add(handles[handleId].point, delta)) // Vec.rot(delta, shape.rotation)),\n\n      }), _TLDR$getShapeUtils$o), {\n        delta: delta,\n        shiftKey: shiftKey,\n        altKey: altKey,\n        metaKey: metaKey\n      });\n      if (!change) return data;\n      return _extends({}, data, {\n        page: _extends({}, data.page, {\n          shapes: _extends({}, data.page.shapes, (_extends2 = {}, _extends2[shape.id] = _extends({}, shape, change), _extends2))\n        })\n      });\n    };\n\n    this.cancel = function (data) {\n      var _extends3;\n\n      var initialShape = _this.initialShape;\n      return _extends({}, data, {\n        page: _extends({}, data.page, {\n          shapes: _extends({}, data.page.shapes, (_extends3 = {}, _extends3[initialShape.id] = initialShape, _extends3))\n        })\n      });\n    };\n\n    var shapeId = _data.pageState.selectedIds[0];\n    this.origin = _point;\n    this.handleId = _handleId;\n    this.initialShape = TLDR.getShape(_data, shapeId);\n    this.commandId = commandId;\n  }\n\n  var _proto = HandleSession.prototype;\n\n  _proto.complete = function complete(data) {\n    var _shapes, _shapes2;\n\n    return {\n      id: this.commandId,\n      before: {\n        page: {\n          shapes: (_shapes = {}, _shapes[this.initialShape.id] = this.initialShape, _shapes)\n        }\n      },\n      after: {\n        page: {\n          shapes: (_shapes2 = {}, _shapes2[this.initialShape.id] = TLDR.onSessionComplete(data, data.page.shapes[this.initialShape.id]), _shapes2)\n        }\n      }\n    };\n  };\n\n  return HandleSession;\n}();\n\nvar initialData = {\n  settings: {\n    isPenMode: false,\n    isDarkMode: false,\n    isDebugMode: \"development\" === 'development',\n    isReadonlyMode: false,\n    nudgeDistanceLarge: 10,\n    nudgeDistanceSmall: 1\n  },\n  appState: {\n    activeToolType: undefined,\n    activeTool: 'select',\n    hoveredId: undefined,\n    currentPageId: 'page',\n    pages: [{\n      id: 'page'\n    }],\n    currentStyle: defaultStyle,\n    selectedStyle: defaultStyle,\n    isToolLocked: false,\n    isStyleOpen: false,\n    isEmptyCanvas: false\n  },\n  page: {\n    id: 'page',\n    childIndex: 1,\n    shapes: {},\n    bindings: {}\n  },\n  pageState: {\n    id: 'page',\n    selectedIds: [],\n    camera: {\n      point: [0, 0],\n      zoom: 1\n    }\n  }\n};\nvar TLDrawState = /*#__PURE__*/function () {\n  function TLDrawState() {\n    var _this = this;\n\n    this.store = createReact(function () {\n      return initialData;\n    });\n    this.history = {\n      stack: [],\n      pointer: -1\n    };\n    this.session = void 0;\n    this.status = {\n      current: 'idle',\n      previous: 'idle'\n    };\n    this.pointedId = void 0;\n    this.pointedHandle = void 0;\n    this.pointedBoundsHandle = void 0;\n    this.currentDocumentId = 'doc';\n    this.currentPageId = 'page';\n    this.pages = {\n      page: initialData.page\n    };\n    this.pageStates = {\n      page: initialData.pageState\n    };\n    this._onChange = void 0;\n    this.getState = this.store.getState;\n\n    this.setState = function (data) {\n      var current = _this.getState(); // Apply incoming change\n\n\n      var result = typeof data === 'function' ? data(current) : data;\n\n      var next = _extends({}, current, result);\n\n      if ('page' in result) {\n        next.page = _extends({}, next.page, {\n          shapes: Object.fromEntries(Object.entries(next.page.shapes).filter(function (_ref) {\n            var shape = _ref[1];\n            return shape && (shape.parentId === next.page.id || next.page.shapes[shape.parentId]);\n          }))\n        });\n      } // Apply selected style change, if any\n\n\n      var newSelectedStyle = TLDR.getSelectedStyle(next);\n\n      if (newSelectedStyle) {\n        next = _extends({}, next, {\n          appState: _extends({}, current.appState, next.appState, {\n            selectedStyle: newSelectedStyle\n          })\n        });\n      }\n\n      _this.store.setState(next);\n\n      _this.pages[next.page.id] = next.page;\n      _this.pageStates[next.page.id] = next.pageState;\n      return _this;\n    };\n\n    this.getShape = function (id) {\n      return _this.getState().page.shapes[id];\n    };\n\n    this.getPage = function (id) {\n      if (id === void 0) {\n        id = _this.currentPageId;\n      }\n\n      return _this.pages[id];\n    };\n\n    this.getPageState = function (id) {\n      if (id === void 0) {\n        id = _this.currentPageId;\n      }\n\n      return _this.pageStates[id];\n    };\n\n    this.getAppState = function (id) {\n\n      return _this.getState().appState;\n    };\n\n    this.getPagePoint = function (point) {\n      var _this$getPageState = _this.getPageState(),\n          camera = _this$getPageState.camera;\n\n      return core.Vec.sub(core.Vec.div(point, camera.zoom), camera.point);\n    };\n\n    this.toggleStylePanel = function () {\n      _this.setState(function (data) {\n        return {\n          appState: _extends({}, data.appState, {\n            isStyleOpen: !data.appState.isStyleOpen\n          })\n        };\n      });\n\n      return _this;\n    };\n\n    this.copy = function () {\n      // TODO\n      return _this;\n    };\n\n    this.paste = function () {\n      // TODO\n      return _this;\n    };\n\n    this.copyAsSvg = function () {\n      // TODO\n      return '<svg/>';\n    };\n\n    this.copyAsJson = function () {\n      // TODO\n      return {};\n    };\n\n    this.togglePenMode = function () {\n      _this.setState(function (data) {\n        return {\n          settings: _extends({}, data.settings, {\n            isPenMode: !data.settings.isPenMode\n          })\n        };\n      });\n\n      return _this;\n    };\n\n    this.toggleDarkMode = function () {\n      _this.setState(function (data) {\n        return {\n          settings: _extends({}, data.settings, {\n            isDarkMode: !data.settings.isDarkMode\n          })\n        };\n      });\n\n      return _this;\n    };\n\n    this.reset = function () {\n      _this.setState(function (data) {\n        return {\n          appState: _extends({}, data.appState, initialData.appState),\n          settings: _extends({}, data.appState, initialData.settings)\n        };\n      });\n\n      _this._onChange == null ? void 0 : _this._onChange(_this, \"reset\");\n      return _this;\n    };\n\n    this.selectTool = function (tool) {\n      _this.setState(function (data) {\n        return {\n          appState: _extends({}, data.appState, {\n            activeTool: tool,\n            activeToolType: tool === 'select' ? 'select' : TLDR.getShapeUtils({\n              type: tool\n            }).toolType\n          })\n        };\n      });\n\n      return _this;\n    };\n\n    this.toggleToolLock = function () {\n      _this.setState(function (data) {\n        return {\n          appState: _extends({}, data.appState, {\n            isToolLocked: true\n          })\n        };\n      });\n\n      return _this;\n    };\n\n    this.zoomIn = function () {\n      var i = Math.round(_this.store.getState().pageState.camera.zoom * 100 / 25);\n      var nextZoom = TLDR.getCameraZoom((i + 1) * 0.25);\n\n      _this.zoomTo(nextZoom);\n\n      return _this;\n    };\n\n    this.zoomOut = function () {\n      var i = Math.round(_this.store.getState().pageState.camera.zoom * 100 / 25);\n      var nextZoom = TLDR.getCameraZoom((i - 1) * 0.25);\n\n      _this.zoomTo(nextZoom);\n\n      return _this;\n    };\n\n    this.zoomToFit = function () {\n      _this.setState(function (data) {\n        var shapes = Object.values(data.page.shapes);\n        if (shapes.length === 0) return {\n          pageState: data.pageState\n        };\n        var bounds = core.Utils.getCommonBounds(Object.values(shapes).map(TLDR.getBounds));\n        var zoom = TLDR.getCameraZoom(bounds.width > bounds.height ? (window.innerWidth - 128) / bounds.width : (window.innerHeight - 128) / bounds.height);\n        var mx = (window.innerWidth - bounds.width * zoom) / 2 / zoom;\n        var my = (window.innerHeight - bounds.height * zoom) / 2 / zoom;\n        return {\n          pageState: _extends({}, data.pageState, {\n            camera: _extends({}, data.pageState.camera, {\n              point: core.Vec.add([-bounds.minX, -bounds.minY], [mx, my]),\n              zoom: zoom\n            })\n          })\n        };\n      });\n\n      return _this;\n    };\n\n    this.zoomToSelection = function () {\n      _this.setState(function (data) {\n        if (TLDR.getSelectedIds(data).length === 0) return {\n          pageState: data.pageState\n        };\n        var bounds = TLDR.getSelectedBounds(data);\n        var zoom = TLDR.getCameraZoom(bounds.width > bounds.height ? (window.innerWidth - 128) / bounds.width : (window.innerHeight - 128) / bounds.height);\n        var mx = (window.innerWidth - bounds.width * zoom) / 2 / zoom;\n        var my = (window.innerHeight - bounds.height * zoom) / 2 / zoom;\n        return {\n          pageState: _extends({}, data.pageState, {\n            camera: _extends({}, data.pageState.camera, {\n              point: core.Vec.add([-bounds.minX, -bounds.minY], [mx, my]),\n              zoom: zoom\n            })\n          })\n        };\n      });\n\n      return _this;\n    };\n\n    this.resetCamera = function () {\n      _this.setState(function (data) {\n        return {\n          pageState: _extends({}, data.pageState, {\n            camera: {\n              zoom: 1,\n              point: [window.innerWidth / 2, window.innerHeight / 2]\n            }\n          })\n        };\n      });\n\n      return _this;\n    };\n\n    this.zoomToContent = function () {\n      _this.setState(function (data) {\n        var shapes = Object.values(data.page.shapes);\n        if (shapes.length === 0) return {\n          pageState: data.pageState\n        };\n        var bounds = core.Utils.getCommonBounds(Object.values(shapes).map(TLDR.getBounds));\n        var zoom = data.pageState.camera.zoom;\n        var mx = (window.innerWidth - bounds.width * zoom) / 2 / zoom;\n        var my = (window.innerHeight - bounds.height * zoom) / 2 / zoom;\n        return {\n          pageState: _extends({}, data.pageState, {\n            camera: _extends({}, data.pageState.camera, {\n              point: core.Vec.add([-bounds.minX, -bounds.minY], [mx, my])\n            })\n          })\n        };\n      });\n\n      return _this;\n    };\n\n    this.zoomToActual = function () {\n      _this.zoomTo(1);\n\n      return _this;\n    };\n\n    this.loadDocument = function (document, onChange) {\n      _this._onChange = onChange;\n      _this.currentDocumentId = document.id;\n      _this.pages = core.Utils.deepClone(document.pages);\n      _this.pageStates = core.Utils.deepClone(document.pageStates);\n      _this.currentPageId = Object.values(_this.pages)[0].id;\n\n      _this.setState(function (data) {\n        return {\n          page: _this.pages[_this.currentPageId],\n          pageState: _this.pageStates[_this.currentPageId],\n          appState: _extends({}, data.appState, {\n            pageIds: Object.values(_this.pages).sort(function (a, b) {\n              return (a.childIndex || 0) - (b.childIndex || 0);\n            }).map(function (page) {\n              return page.id;\n            })\n          })\n        };\n      });\n\n      return _this;\n    };\n\n    this.undo = function () {\n      var history = _this.history;\n      if (history.pointer <= -1) return _this;\n      var command = history.stack[history.pointer];\n\n      _this.setState(function (data) {\n        return core.Utils.deepMerge(data, command.before);\n      });\n\n      history.pointer--;\n      _this._onChange == null ? void 0 : _this._onChange(_this, \"undo:\" + command.id);\n      return _this;\n    };\n\n    this.redo = function () {\n      var history = _this.history;\n      if (history.pointer >= history.stack.length - 1) return _this;\n      history.pointer++;\n      var command = history.stack[history.pointer];\n\n      _this.setState(function (data) {\n        return core.Utils.deepMerge(data, command.after);\n      });\n\n      _this._onChange == null ? void 0 : _this._onChange(_this, \"redo:\" + command.id);\n      return _this;\n    };\n\n    this.select = function () {\n      for (var _len = arguments.length, ids = new Array(_len), _key = 0; _key < _len; _key++) {\n        ids[_key] = arguments[_key];\n      }\n\n      _this.setSelectedIds(ids);\n\n      return _this;\n    };\n\n    this.selectAll = function () {\n      _this.setState(function (data) {\n        return {\n          appState: _extends({}, data.appState, {\n            activeTool: 'select',\n            activeToolType: 'select'\n          }),\n          pageState: _extends({}, data.pageState, {\n            selectedIds: Object.keys(data.page.shapes)\n          })\n        };\n      });\n\n      return _this;\n    };\n\n    this.deselectAll = function () {\n      _this.setSelectedIds([]);\n\n      return _this;\n    };\n\n    this.style = function (style$1, ids) {\n      var data = _this.store.getState();\n\n      var idsToMutate = ids ? ids : data.pageState.selectedIds;\n\n      _this[\"do\"](style(data, idsToMutate, style$1));\n\n      return _this;\n    };\n\n    this.align = function (type, ids) {\n      var data = _this.store.getState();\n\n      var idsToMutate = ids ? ids : data.pageState.selectedIds;\n\n      _this[\"do\"](align(data, idsToMutate, type));\n\n      return _this;\n    };\n\n    this.distribute = function (type, ids) {\n      var data = _this.store.getState();\n\n      var idsToMutate = ids ? ids : data.pageState.selectedIds;\n\n      _this[\"do\"](distribute(data, idsToMutate, type));\n\n      return _this;\n    };\n\n    this.stretch = function (type, ids) {\n      var data = _this.store.getState();\n\n      var idsToMutate = ids ? ids : data.pageState.selectedIds;\n\n      _this[\"do\"](stretch(data, idsToMutate, type));\n\n      return _this;\n    };\n\n    this.moveToBack = function (ids) {\n      var data = _this.store.getState();\n\n      var idsToMutate = ids ? ids : data.pageState.selectedIds;\n\n      _this[\"do\"](move(data, idsToMutate, exports.MoveType.ToBack));\n\n      return _this;\n    };\n\n    this.moveBackward = function (ids) {\n      var data = _this.store.getState();\n\n      var idsToMutate = ids ? ids : data.pageState.selectedIds;\n\n      _this[\"do\"](move(data, idsToMutate, exports.MoveType.Backward));\n\n      return _this;\n    };\n\n    this.moveForward = function (ids) {\n      var data = _this.store.getState();\n\n      var idsToMutate = ids ? ids : data.pageState.selectedIds;\n\n      _this[\"do\"](move(data, idsToMutate, exports.MoveType.Forward));\n\n      return _this;\n    };\n\n    this.moveToFront = function (ids) {\n      var data = _this.store.getState();\n\n      var idsToMutate = ids ? ids : data.pageState.selectedIds;\n\n      _this[\"do\"](move(data, idsToMutate, exports.MoveType.ToFront));\n\n      return _this;\n    };\n\n    this.nudge = function (delta, isMajor, ids) {\n      if (isMajor === void 0) {\n        isMajor = false;\n      }\n\n      var data = _this.store.getState();\n\n      var idsToMutate = ids ? ids : data.pageState.selectedIds;\n\n      _this[\"do\"](translate(data, idsToMutate, core.Vec.mul(delta, isMajor ? 10 : 1)));\n\n      return _this;\n    };\n\n    this.duplicate = function (ids) {\n      var data = _this.store.getState();\n\n      var idsToMutate = ids ? ids : data.pageState.selectedIds;\n\n      _this[\"do\"](duplicate(data, idsToMutate));\n\n      return _this;\n    };\n\n    this.toggleHidden = function (ids) {\n      var data = _this.store.getState();\n\n      var idsToMutate = ids ? ids : data.pageState.selectedIds;\n\n      _this[\"do\"](toggle(data, idsToMutate, 'isHidden'));\n\n      return _this;\n    };\n\n    this.toggleLocked = function (ids) {\n      var data = _this.store.getState();\n\n      var idsToMutate = ids ? ids : data.pageState.selectedIds;\n\n      _this[\"do\"](toggle(data, idsToMutate, 'isLocked'));\n\n      return _this;\n    };\n\n    this.toggleAspectRatioLocked = function (ids) {\n      var data = _this.store.getState();\n\n      var idsToMutate = ids ? ids : data.pageState.selectedIds;\n\n      _this[\"do\"](toggle(data, idsToMutate, 'isAspectRatioLocked'));\n\n      return _this;\n    };\n\n    this.rotate = function (delta, ids) {\n      if (delta === void 0) {\n        delta = Math.PI * -0.5;\n      }\n\n      var data = _this.store.getState();\n\n      var idsToMutate = ids ? ids : data.pageState.selectedIds;\n\n      _this[\"do\"](rotate(data, idsToMutate, delta));\n\n      return _this;\n    };\n\n    this.group = function (ids) {\n      // TODO\n      // const data = this.store.getState()\n      // const idsToMutate = ids ? ids : data.pageState.selectedIds\n      // this.do(commands.toggle(data, idsToMutate, 'isAspectRatioLocked'))\n      return _this;\n    };\n\n    this.create = function () {\n      var data = _this.store.getState();\n\n      for (var _len2 = arguments.length, shapes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        shapes[_key2] = arguments[_key2];\n      }\n\n      _this[\"do\"](create(data, shapes));\n\n      return _this;\n    };\n\n    this[\"delete\"] = function (ids) {\n      var data = _this.store.getState();\n\n      var idsToMutate = ids ? ids : data.pageState.selectedIds;\n      if (idsToMutate.length === 0) return _this;\n\n      _this[\"do\"](deleteShapes(data, idsToMutate));\n\n      return _this;\n    };\n\n    this.clear = function () {\n      _this.selectAll();\n\n      _this[\"delete\"]();\n\n      return _this;\n    };\n\n    this.cancel = function () {\n      switch (_this.status.current) {\n        case 'idle':\n          {\n            _this.deselectAll();\n\n            _this.selectTool('select');\n\n            break;\n          }\n\n        case 'brushing':\n          {\n            _this.cancelSession();\n\n            core.brushUpdater.clear();\n            break;\n          }\n\n        case 'translating':\n          {\n            _this.cancelSession();\n\n            break;\n          }\n\n        case 'transforming':\n          {\n            _this.cancelSession();\n\n            break;\n          }\n\n        case 'rotating':\n          {\n            _this.cancelSession();\n\n            break;\n          }\n\n        case 'creating':\n          {\n            _this.cancelSession();\n\n            _this[\"delete\"]();\n\n            break;\n          }\n      }\n\n      return _this;\n    };\n\n    this.save = function () {\n      // TODO\n      return _this;\n    };\n\n    this.startBrushSession = function (point) {\n      _this.setStatus('brushing');\n\n      _this.startSession(new BrushSession(_this.store.getState(), point));\n\n      return _this;\n    };\n\n    this.updateBrushSession = function (point, metaKey) {\n      if (metaKey === void 0) {\n        metaKey = false;\n      }\n\n      _this.updateSession(point, metaKey);\n\n      return _this;\n    };\n\n    this.startTranslateSession = function (point) {\n      _this.setStatus('translating');\n\n      _this.startSession(new TranslateSession(_this.store.getState(), point));\n\n      return _this;\n    };\n\n    this.updateTranslateSession = function (point, shiftKey, altKey) {\n      if (shiftKey === void 0) {\n        shiftKey = false;\n      }\n\n      if (altKey === void 0) {\n        altKey = false;\n      }\n\n      _this.updateSession(point, shiftKey, altKey);\n\n      return _this;\n    };\n\n    this.startTransformSession = function (point, handle, commandId) {\n      var selectedIds = _this.selectedIds;\n      if (selectedIds.length === 0) return _this;\n\n      _this.setStatus('transforming');\n\n      _this.pointedBoundsHandle = handle;\n\n      if (_this.pointedBoundsHandle === 'rotate') {\n        _this.startSession(new RotateSession(_this.store.getState(), point));\n      } else if (_this.selectedIds.length === 1) {\n        _this.startSession(new TransformSingleSession(_this.store.getState(), point, _this.pointedBoundsHandle, commandId));\n      } else {\n        _this.startSession(new TransformSession(_this.store.getState(), point, _this.pointedBoundsHandle));\n      }\n\n      return _this;\n    };\n\n    this.updateTransformSession = function (point, shiftKey, altKey) {\n      if (shiftKey === void 0) {\n        shiftKey = false;\n      }\n\n      if (altKey === void 0) {\n        altKey = false;\n      }\n\n      _this.updateSession(point, shiftKey, altKey);\n\n      return _this;\n    };\n\n    this.startDrawSession = function (id, point) {\n      _this.setStatus('creating');\n\n      _this.startSession(new DrawSession(_this.store.getState(), id, point));\n\n      return _this;\n    };\n\n    this.updateDrawSession = function (point, pressure, shiftKey) {\n      if (shiftKey === void 0) {\n        shiftKey = false;\n      }\n\n      _this.updateSession(point, pressure, shiftKey);\n\n      return _this;\n    };\n\n    this.startHandleSession = function (point, handleId, commandId) {\n      _this.startSession(new HandleSession(_this.store.getState(), handleId, point, commandId));\n\n      return _this;\n    };\n\n    this.updateHandleSession = function (point, shiftKey, altKey, metaKey) {\n      if (shiftKey === void 0) {\n        shiftKey = false;\n      }\n\n      if (altKey === void 0) {\n        altKey = false;\n      }\n\n      if (metaKey === void 0) {\n        metaKey = false;\n      }\n\n      _this.updateSession(point, shiftKey, altKey, metaKey);\n\n      return _this;\n    };\n\n    this.updateSessionsOnPointerMove = function (info) {\n      switch (_this.status.current) {\n        case 'pointingBoundsHandle':\n          {\n            if (core.Vec.dist(info.origin, info.point) > 4) {\n              _this.setStatus('transforming');\n\n              _this.startTransformSession(_this.getPagePoint(info.origin), _this.pointedBoundsHandle);\n            }\n\n            break;\n          }\n\n        case 'pointingHandle':\n          {\n            if (core.Vec.dist(info.origin, info.point) > 4) {\n              _this.setStatus('translatingHandle');\n\n              _this.startHandleSession(_this.getPagePoint(info.origin), _this.pointedHandle);\n            }\n\n            break;\n          }\n\n        case 'pointingBounds':\n          {\n            if (core.Vec.dist(info.origin, info.point) > 4) {\n              _this.setStatus('translating');\n\n              _this.startTranslateSession(_this.getPagePoint(info.origin));\n            }\n\n            break;\n          }\n\n        case 'brushing':\n          {\n            _this.updateBrushSession(_this.getPagePoint(info.point), info.metaKey);\n\n            break;\n          }\n\n        case 'translating':\n          {\n            _this.updateTranslateSession(_this.getPagePoint(info.point), info.shiftKey, info.altKey);\n\n            break;\n          }\n\n        case 'transforming':\n          {\n            _this.updateTransformSession(_this.getPagePoint(info.point), info.shiftKey, info.altKey);\n\n            break;\n          }\n\n        case 'translatingHandle':\n          {\n            _this.updateHandleSession(_this.getPagePoint(info.point), info.shiftKey, info.altKey);\n\n            break;\n          }\n\n        case 'creating':\n          {\n            switch (_this.appState.activeToolType) {\n              case 'draw':\n                {\n                  _this.updateDrawSession(_this.getPagePoint(info.point), info.pressure, info.shiftKey);\n\n                  break;\n                }\n\n              case 'bounds':\n                {\n                  _this.updateTransformSession(_this.getPagePoint(info.point), info.shiftKey);\n\n                  break;\n                }\n\n              case 'handle':\n                {\n                  _this.updateHandleSession(_this.getPagePoint(info.point), info.shiftKey, info.altKey);\n\n                  break;\n                }\n            }\n\n            break;\n          }\n      }\n    };\n\n    this.onKeyDown = function (key, info) {\n      if (key === 'Escape') {\n        _this.cancel();\n\n        return;\n      }\n\n      switch (_this.status.current) {\n        case 'idle':\n          {\n            break;\n          }\n\n        case 'brushing':\n          {\n            if (key === 'Meta' || key === 'Control') {\n              _this.updateBrushSession(_this.getPagePoint(info.point), info.metaKey);\n\n              return;\n            }\n\n            break;\n          }\n\n        case 'translating':\n          {\n            if (key === 'Escape') {\n              _this.cancelSession(_this.getPagePoint(info.point));\n            }\n\n            if (key === 'Shift' || key === 'Alt') {\n              _this.updateTranslateSession(_this.getPagePoint(info.point), info.shiftKey, info.altKey);\n            }\n\n            break;\n          }\n\n        case 'transforming':\n          {\n            if (key === 'Escape') {\n              _this.cancelSession(_this.getPagePoint(info.point));\n            }\n\n            if (key === 'Shift' || key === 'Alt') {\n              _this.updateTransformSession(_this.getPagePoint(info.point), info.shiftKey, info.altKey);\n            }\n\n            break;\n          }\n      }\n    };\n\n    this.onKeyUp = function (key, info) {\n      switch (_this.status.current) {\n        case 'brushing':\n          {\n            if (key === 'Meta' || key === 'Control') {\n              _this.updateBrushSession(_this.getPagePoint(info.point), info.metaKey);\n            }\n\n            break;\n          }\n\n        case 'transforming':\n          {\n            if (key === 'Shift' || key === 'Alt') {\n              _this.updateTransformSession(_this.getPagePoint(info.point), info.shiftKey, info.altKey);\n            }\n\n            break;\n          }\n\n        case 'translating':\n          {\n            if (key === 'Shift' || key === 'Alt') {\n              _this.updateTransformSession(_this.getPagePoint(info.point), info.shiftKey, info.altKey);\n            }\n\n            break;\n          }\n      }\n    };\n\n    this.onPinchStart = function (info) {\n      _this.setStatus('pinching');\n    };\n\n    this.onPinchEnd = function () {\n      _this.setStatus(_this.status.previous);\n    };\n\n    this.onPinch = function (info, e) {\n      if (_this.status.current !== 'pinching') return;\n\n      _this.pinchZoom(info.origin, info.delta, info.delta[2] / 350);\n\n      _this.updateSessionsOnPointerMove(info, e);\n    };\n\n    this.onPan = function (info, e) {\n      var delta = core.Vec.div(info.delta, _this.getPageState().camera.zoom);\n\n      var prev = _this.getPageState().camera.point;\n\n      var next = core.Vec.sub(prev, delta);\n      if (core.Vec.isEqual(next, prev)) return;\n\n      _this.pan(delta);\n\n      _this.updateSessionsOnPointerMove(info, e);\n    };\n\n    this.onZoom = function (info, e) {\n      _this.zoom(info.delta[2] / 100);\n\n      _this.updateSessionsOnPointerMove(info, e);\n    };\n\n    this.onPointerDown = function (info) {\n      switch (_this.status.current) {\n        case 'idle':\n          {\n            switch (_this.appState.activeTool) {\n              case 'draw':\n                {\n                  _this.setStatus('creating');\n\n                  _this.createActiveToolShape(info.point);\n\n                  break;\n                }\n\n              case 'rectangle':\n                {\n                  _this.setStatus('creating');\n\n                  _this.createActiveToolShape(info.point);\n\n                  break;\n                }\n\n              case 'ellipse':\n                {\n                  _this.setStatus('creating');\n\n                  _this.createActiveToolShape(info.point);\n\n                  break;\n                }\n\n              case 'arrow':\n                {\n                  _this.setStatus('creating');\n\n                  _this.createActiveToolShape(info.point);\n\n                  break;\n                }\n            }\n          }\n      }\n    };\n\n    this.onPointerMove = function (info, e) {\n      _this.updateSessionsOnPointerMove(info, e);\n    };\n\n    this.onPointerUp = function (info) {\n      var data = _this.getState();\n\n      switch (_this.status.current) {\n        case 'pointingBounds':\n          {\n            if (info.target === 'bounds') {\n              // If we just clicked the selecting bounds's background, clear the selection\n              _this.deselectAll();\n            } else if (data.pageState.selectedIds.includes(info.target)) {\n              // If we're holding shift...\n              if (info.shiftKey) {\n                // Unless we just shift-selected the shape, remove it from the selected shapes\n                if (_this.pointedId !== info.target) {\n                  _this.setSelectedIds(data.pageState.selectedIds.filter(function (id) {\n                    return id !== info.target;\n                  }));\n                }\n              }\n            }\n\n            _this.setStatus('idle');\n\n            _this.pointedId = undefined;\n            break;\n          }\n\n        case 'pointingBoundsHandle':\n          {\n            _this.setStatus('idle');\n\n            _this.pointedBoundsHandle = undefined;\n            break;\n          }\n\n        case 'pointingHandle':\n          {\n            _this.setStatus('idle');\n\n            _this.pointedHandle = undefined;\n            break;\n          }\n\n        case 'translatingHandle':\n          {\n            _this.completeSession();\n\n            _this.pointedHandle = undefined;\n            break;\n          }\n\n        case 'brushing':\n          {\n            _this.completeSession();\n\n            core.brushUpdater.clear();\n            break;\n          }\n\n        case 'translating':\n          {\n            _this.completeSession(_this.getPagePoint(info.point));\n\n            _this.pointedId = undefined;\n            break;\n          }\n\n        case 'transforming':\n          {\n            _this.completeSession(_this.getPagePoint(info.point));\n\n            _this.pointedBoundsHandle = undefined;\n            break;\n          }\n\n        case 'creating':\n          {\n            _this.completeSession(_this.getPagePoint(info.point));\n\n            _this.pointedHandle = undefined;\n          }\n      }\n    };\n\n    this.onPointCanvas = function (info) {\n      switch (_this.status.current) {\n        case 'idle':\n          {\n            switch (_this.appState.activeTool) {\n              case 'select':\n                {\n                  // Unless the user is holding shift or meta, clear the current selection\n                  if (!(info.shiftKey || info.metaKey)) {\n                    _this.deselectAll();\n                  } // Start a brush session\n\n\n                  _this.startBrushSession(_this.getPagePoint(info.point));\n\n                  break;\n                }\n            }\n          }\n      }\n    };\n\n    this.onDoubleClickCanvas = function () {// Unused\n    };\n\n    this.onRightPointCanvas = function () {// Unused\n    };\n\n    this.onDragCanvas = function () {// Unused\n    };\n\n    this.onReleaseCanvas = function () {// Unused\n    };\n\n    this.onPointShape = function (info) {\n      var data = _this.getState();\n\n      switch (_this.status.current) {\n        case 'idle':\n          {\n            switch (_this.appState.activeTool) {\n              case 'select':\n                {\n                  if (info.metaKey) {\n                    // While holding command key, allow event to pass through to canvas\n                    return;\n                  }\n\n                  if (!data.pageState.selectedIds.includes(info.target)) {\n                    // Set the pointed ID to the shape that was clicked.\n                    _this.pointedId = info.target; // If the shape is not selected; then if the user is pressing shift,\n                    // add the shape to the current selection; otherwise, set the shape as\n                    // the only selected shape.\n\n                    _this.setSelectedIds([info.target], info.shiftKey);\n                  }\n\n                  _this.setStatus('pointingBounds');\n\n                  break;\n                }\n            }\n          }\n      }\n    };\n\n    this.onReleaseShape = function (info) {// const data = this.getState()\n      // switch (this.status.current) {\n      //   case 'pointingBounds': {\n      //     if (info.metaKey) {\n      //       // While holding command key, allow event to pass through to canvas\n      //       return\n      //     }\n      //     // If the shape is selected...\n      //     if (\n      //       data.pageState.selectedIds.includes(info.target) &&\n      //       this.pointedId !== info.target &&\n      //       info.shiftKey\n      //     ) {\n      //       // If the shape is not selected; then if the user is pressing shift,\n      //       // add the shape to the current selection; otherwise, set the shape as\n      //       // the only selected shape.\n      //       this.setSelectedIds(data.pageState.selectedIds.filter((id) => id !== info.target))\n      //     }\n      //     this.setStatus('pointingBounds')\n      //     break\n      //   }\n      // }\n    };\n\n    this.onDoubleClickShape = function (info) {\n      if (_this.selectedIds.includes(info.target)) {\n        _this.setSelectedIds([info.target]);\n      }\n    };\n\n    this.onRightPointShape = function () {// TODO\n    };\n\n    this.onDragShape = function (info) {// Unused\n    };\n\n    this.onHoverShape = function (info) {\n      _this.setState(function (data) {\n        return {\n          appState: _extends({}, data.appState, {\n            hoveredId: info.target\n          })\n        };\n      });\n    };\n\n    this.onUnhoverShape = function (info) {\n      setTimeout(function () {\n        if (_this.getState().appState.hoveredId === info.target) {\n          _this.setState(function (data) {\n            return {\n              appState: _extends({}, data.appState, {\n                hoveredId: undefined\n              })\n            };\n          });\n        }\n      }, 10);\n    };\n\n    this.onPointBounds = function (info) {\n      _this.setStatus('pointingBounds');\n    };\n\n    this.onDoubleClickBounds = function () {// TODO\n    };\n\n    this.onRightPointBounds = function () {// TODO\n    };\n\n    this.onDragBounds = function (info) {// Unused\n    };\n\n    this.onHoverBounds = function () {// TODO\n    };\n\n    this.onUnhoverBounds = function () {// TODO\n    };\n\n    this.onReleaseBounds = function (info) {\n      switch (_this.status.current) {\n        case 'translating':\n          {\n            _this.completeSession(_this.getPagePoint(info.point));\n\n            break;\n          }\n\n        case 'brushing':\n          {\n            _this.completeSession();\n\n            core.brushUpdater.clear();\n            break;\n          }\n      }\n    };\n\n    this.onPointBoundsHandle = function (info) {\n      _this.pointedBoundsHandle = info.target;\n\n      _this.setStatus('pointingBoundsHandle');\n    };\n\n    this.onDoubleClickBoundsHandle = function () {// TODO\n    };\n\n    this.onRightPointBoundsHandle = function () {// TODO\n    };\n\n    this.onDragBoundsHandle = function () {// Unused\n    };\n\n    this.onHoverBoundsHandle = function () {// TODO\n    };\n\n    this.onUnhoverBoundsHandle = function () {// TODO\n    };\n\n    this.onReleaseBoundsHandle = function () {// TODO\n    };\n\n    this.onPointHandle = function (info) {\n      _this.pointedHandle = info.target;\n\n      _this.setStatus('pointingHandle');\n    };\n\n    this.onDoubleClickHandle = function () {// TODO\n    };\n\n    this.onRightPointHandle = function () {// TODO\n    };\n\n    this.onDragHandle = function () {// TODO\n    };\n\n    this.onHoverHandle = function () {// TODO\n    };\n\n    this.onUnhoverHandle = function () {// TODO\n    };\n\n    this.onReleaseHandle = function () {// Unused\n    };\n\n    this.onChange = function (ids) {\n      var appState = _this.getAppState();\n\n      if (appState.isEmptyCanvas && ids.length > 0) {\n        _this.setState(function (data) {\n          return {\n            appState: _extends({}, data.appState, {\n              isEmptyCanvas: false\n            })\n          };\n        });\n      } else if (!appState.isEmptyCanvas && ids.length <= 0) {\n        _this.setState(function (data) {\n          return {\n            appState: _extends({}, data.appState, {\n              isEmptyCanvas: true\n            })\n          };\n        });\n      }\n    };\n\n    this.onError = function (error) {// TODO\n    };\n\n    this.onBlurEditingShape = function () {// TODO\n    };\n  }\n\n  var _proto = TLDrawState.prototype;\n\n  /* --------------------- Status --------------------- */\n  _proto.setStatus = function setStatus(status) {\n    this.status.previous = this.status.current;\n    this.status.current = status;\n    return this; // console.log(this.status.previous, ' -> ', this.status.current)\n  }\n  /* -------------------- App State ------------------- */\n  ;\n\n  _proto.pinchZoom = function pinchZoom(point, delta, zoomDelta) {\n    this.setState(function (data) {\n      var camera = data.pageState.camera;\n      var nextPoint = core.Vec.add(camera.point, core.Vec.div(delta, camera.zoom));\n      var nextZoom = TLDR.getCameraZoom(camera.zoom - zoomDelta * camera.zoom);\n      var p0 = core.Vec.sub(core.Vec.div(point, camera.zoom), nextPoint);\n      var p1 = core.Vec.sub(core.Vec.div(point, nextZoom), nextPoint);\n      return {\n        pageState: _extends({}, data.pageState, {\n          camera: _extends({}, data.pageState.camera, {\n            point: core.Vec.add(nextPoint, core.Vec.sub(p1, p0)),\n            zoom: nextZoom\n          })\n        })\n      };\n    });\n    return this;\n  };\n\n  _proto.zoomTo = function zoomTo(next) {\n    this.setState(function (data) {\n      var _TLDR$getCurrentCamer = TLDR.getCurrentCamera(data),\n          zoom = _TLDR$getCurrentCamer.zoom,\n          point = _TLDR$getCurrentCamer.point;\n\n      var center = [window.innerWidth / 2, window.innerHeight / 2];\n      var p0 = core.Vec.sub(core.Vec.div(center, zoom), point);\n      var p1 = core.Vec.sub(core.Vec.div(center, next), point);\n      return {\n        pageState: _extends({}, data.pageState, {\n          camera: _extends({}, data.pageState.camera, {\n            point: core.Vec.add(point, core.Vec.sub(p1, p0)),\n            zoom: next\n          })\n        })\n      };\n    });\n    return this;\n  };\n\n  _proto.zoom = function zoom(delta) {\n    var zoom = this.store.getState().pageState.camera.zoom;\n    var nextZoom = TLDR.getCameraZoom(zoom - delta * zoom);\n    this.zoomTo(nextZoom);\n    return this;\n  };\n\n  _proto.pan = function pan(delta) {\n    this.setState(function (data) {\n      var _TLDR$getCurrentCamer2 = TLDR.getCurrentCamera(data),\n          point = _TLDR$getCurrentCamer2.point;\n\n      return {\n        pageState: _extends({}, data.pageState, {\n          camera: _extends({}, data.pageState.camera, {\n            point: core.Vec.sub(point, delta)\n          })\n        })\n      };\n    });\n    return this;\n  }\n  /* ---------------------- Document --------------------- */\n  ;\n\n  _proto.setCurrentPageId = function setCurrentPageId(pageId) {\n    if (pageId === this.currentPageId) return this;\n    this.currentPageId = pageId;\n    this.setState({\n      page: this.pages[pageId],\n      pageState: this.pageStates[pageId]\n    });\n    return this;\n  }\n  /* -------------------- Sessions -------------------- */\n  ;\n\n  _proto.startSession = function startSession(session) {\n    var _this$_onChange;\n\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n\n    this.session = session;\n    this.setState(function (data) {\n      return session.start.apply(session, [data].concat(args));\n    });\n    (_this$_onChange = this._onChange) == null ? void 0 : _this$_onChange.call(this, this, \"session:start_\" + session.id);\n    return this;\n  };\n\n  _proto.updateSession = function updateSession() {\n    var _this$_onChange2;\n\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    var session = this.session;\n    if (!session) return this;\n    this.setState(function (data) {\n      return session.update.apply(session, [data].concat(args));\n    });\n    (_this$_onChange2 = this._onChange) == null ? void 0 : _this$_onChange2.call(this, this, \"session:update:\" + session.id);\n    return this;\n  };\n\n  _proto.cancelSession = function cancelSession() {\n    var _this$_onChange3;\n\n    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n\n    var session = this.session;\n    if (!session) return this;\n    this.setState(function (data) {\n      return session.cancel.apply(session, [data].concat(args));\n    });\n    this.setStatus('idle');\n    this.session = undefined;\n    (_this$_onChange3 = this._onChange) == null ? void 0 : _this$_onChange3.call(this, this, \"session:cancel:\" + session.id);\n    return this;\n  };\n\n  _proto.completeSession = function completeSession() {\n    var session = this.session;\n    if (!session) return this;\n    this.setStatus('idle');\n\n    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n\n    var result = session.complete.apply(session, [this.store.getState()].concat(args));\n\n    if ('after' in result) {\n      this[\"do\"](result);\n    } else {\n      var _this$_onChange4;\n\n      this.setState(function (data) {\n        return core.Utils.deepMerge(data, result);\n      });\n      (_this$_onChange4 = this._onChange) == null ? void 0 : _this$_onChange4.call(this, this, \"session:complete:\" + session.id);\n    }\n\n    var _this$appState = this.appState,\n        isToolLocked = _this$appState.isToolLocked,\n        activeTool = _this$appState.activeTool;\n\n    if (!isToolLocked && activeTool !== 'draw') {\n      this.selectTool('select');\n    }\n\n    this.session = undefined;\n    return this;\n  }\n  /* -------------------- Commands -------------------- */\n  ;\n\n  _proto[\"do\"] = function _do(command) {\n    var _this$_onChange5;\n\n    var history = this.history;\n\n    if (history.pointer !== history.stack.length - 1) {\n      history.stack = history.stack.slice(0, history.pointer + 1);\n    }\n\n    history.stack.push(command);\n    history.pointer = history.stack.length - 1;\n    this.setState(function (data) {\n      return core.Utils.deepMerge(data, history.stack[history.pointer].after);\n    });\n    (_this$_onChange5 = this._onChange) == null ? void 0 : _this$_onChange5.call(this, this, \"command:\" + command.id);\n    return this;\n  };\n\n  /* -------------------- Selection ------------------- */\n  _proto.setSelectedIds = function setSelectedIds(ids, push) {\n    if (push === void 0) {\n      push = false;\n    }\n\n    this.setState(function (data) {\n      return {\n        pageState: _extends({}, data.pageState, {\n          selectedIds: push ? [].concat(data.pageState.selectedIds, ids) : [].concat(ids)\n        })\n      };\n    });\n    return this;\n  };\n\n  _proto.createActiveToolShape = function createActiveToolShape(point) {\n    var id = core.Utils.uniqueId();\n    var pagePoint = core.Vec.round(this.getPagePoint(point));\n    this.setState(function (data) {\n      var _extends2;\n\n      var _data$appState = data.appState,\n          activeTool = _data$appState.activeTool,\n          activeToolType = _data$appState.activeToolType;\n      if (activeTool === 'select') return data;\n      if (!activeToolType) throw Error;\n      var utils = TLDR.getShapeUtils({\n        type: activeTool\n      });\n      var shapes = Object.values(data.page.shapes);\n      var childIndex = shapes.length === 0 ? 1 : shapes.sort(function (a, b) {\n        return b.childIndex - a.childIndex;\n      })[0].childIndex + 1;\n      return {\n        page: _extends({}, data.page, {\n          shapes: _extends({}, data.page.shapes, (_extends2 = {}, _extends2[id] = utils.create({\n            id: id,\n            parentId: data.page.id,\n            childIndex: childIndex,\n            point: pagePoint,\n            style: _extends({}, data.appState.currentStyle)\n          }), _extends2))\n        }),\n        pageState: _extends({}, data.pageState, {\n          selectedIds: [id]\n        })\n      };\n    });\n\n    var _this$getAppState = this.getAppState(),\n        activeTool = _this$getAppState.activeTool,\n        activeToolType = _this$getAppState.activeToolType;\n\n    switch (activeToolType) {\n      case 'draw':\n        {\n          this.startDrawSession(id, pagePoint);\n          break;\n        }\n\n      case 'bounds':\n        {\n          this.startTransformSession(pagePoint, core.TLBoundsCorner.BottomRight, \"create_\" + activeTool);\n          break;\n        }\n\n      case 'handle':\n        {\n          this.startHandleSession(pagePoint, 'end', \"create_\" + activeTool);\n          break;\n        }\n    }\n  }\n  /* --------------------- Events --------------------- */\n  ;\n\n  _createClass(TLDrawState, [{\n    key: \"document\",\n    get: function get() {\n      return {\n        id: this.currentDocumentId,\n        pages: this.pages,\n        pageStates: this.pageStates\n      };\n    }\n  }, {\n    key: \"data\",\n    get: function get() {\n      return this.getState();\n    }\n  }, {\n    key: \"selectedIds\",\n    get: function get() {\n      return this.pageState.selectedIds;\n    }\n  }, {\n    key: \"page\",\n    get: function get() {\n      return this.pages[this.currentPageId];\n    }\n  }, {\n    key: \"pageState\",\n    get: function get() {\n      return this.pageStates[this.currentPageId];\n    }\n  }, {\n    key: \"appState\",\n    get: function get() {\n      return this.data.appState;\n    }\n  }]);\n\n  return TLDrawState;\n}();\n\nvar hideBoundsSelector = function hideBoundsSelector(s) {\n  return s.appState.activeTool !== 'select' || s.pageState.selectedIds.length === 1 && s.pageState.selectedIds.every(function (id) {\n    return s.page.shapes[id].handles !== undefined;\n  });\n};\n\nvar pageSelector = function pageSelector(s) {\n  return s.page;\n};\n\nvar pageStateSelector = function pageStateSelector(s) {\n  return s.pageState;\n};\n\nfunction TLDraw(_ref) {\n  var document = _ref.document,\n      currentPageId = _ref.currentPageId,\n      onMount = _ref.onMount,\n      _onChange = _ref.onChange;\n\n  var _React$useState = React.useState(function () {\n    return new TLDrawState();\n  }),\n      tlstate = _React$useState[0];\n\n  var _React$useState2 = React.useState(function () {\n    return {\n      tlstate: tlstate,\n      useAppState: tlstate.store\n    };\n  }),\n      context = _React$useState2[0];\n\n  useKeyboardShortcuts(tlstate);\n  var hideBounds = context.useAppState(hideBoundsSelector);\n  var page = context.useAppState(pageSelector);\n  var pageState = context.useAppState(pageStateSelector);\n  React.useEffect(function () {\n    if (!document) return;\n    tlstate.loadDocument(document, _onChange);\n  }, [document, tlstate]);\n  React.useEffect(function () {\n    if (!currentPageId) return;\n    tlstate.setCurrentPageId(currentPageId);\n  }, [currentPageId, tlstate]);\n  React.useEffect(function () {\n    onMount == null ? void 0 : onMount(tlstate); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return React.createElement(TLDrawContext.Provider, {\n    value: context\n  }, React.createElement(reactId.IdProvider, null, React.createElement(Layout, null, React.createElement(ContextMenu, null, React.createElement(core.Renderer, {\n    page: page,\n    pageState: pageState,\n    shapeUtils: tldrawShapeUtils,\n    hideBounds: hideBounds,\n    onPinchStart: tlstate.onPinchStart,\n    onPinchEnd: tlstate.onPinchEnd,\n    onPinch: tlstate.onPinch,\n    onPan: tlstate.onPan,\n    onZoom: tlstate.onZoom,\n    onPointerDown: tlstate.onPointerDown,\n    onPointerMove: tlstate.onPointerMove,\n    onPointerUp: tlstate.onPointerUp,\n    onPointCanvas: tlstate.onPointCanvas,\n    onDoubleClickCanvas: tlstate.onDoubleClickCanvas,\n    onRightPointCanvas: tlstate.onRightPointCanvas,\n    onDragCanvas: tlstate.onDragCanvas,\n    onReleaseCanvas: tlstate.onReleaseCanvas,\n    onPointShape: tlstate.onPointShape,\n    onDoubleClickShape: tlstate.onDoubleClickShape,\n    onRightPointShape: tlstate.onRightPointShape,\n    onDragShape: tlstate.onDragShape,\n    onHoverShape: tlstate.onHoverShape,\n    onUnhoverShape: tlstate.onUnhoverShape,\n    onReleaseShape: tlstate.onReleaseShape,\n    onPointBounds: tlstate.onPointBounds,\n    onDoubleClickBounds: tlstate.onDoubleClickBounds,\n    onRightPointBounds: tlstate.onRightPointBounds,\n    onDragBounds: tlstate.onDragBounds,\n    onHoverBounds: tlstate.onHoverBounds,\n    onUnhoverBounds: tlstate.onUnhoverBounds,\n    onReleaseBounds: tlstate.onReleaseBounds,\n    onPointBoundsHandle: tlstate.onPointBoundsHandle,\n    onDoubleClickBoundsHandle: tlstate.onDoubleClickBoundsHandle,\n    onRightPointBoundsHandle: tlstate.onRightPointBoundsHandle,\n    onDragBoundsHandle: tlstate.onDragBoundsHandle,\n    onHoverBoundsHandle: tlstate.onHoverBoundsHandle,\n    onUnhoverBoundsHandle: tlstate.onUnhoverBoundsHandle,\n    onReleaseBoundsHandle: tlstate.onReleaseBoundsHandle,\n    onPointHandle: tlstate.onPointHandle,\n    onDoubleClickHandle: tlstate.onDoubleClickHandle,\n    onRightPointHandle: tlstate.onRightPointHandle,\n    onDragHandle: tlstate.onDragHandle,\n    onHoverHandle: tlstate.onHoverHandle,\n    onUnhoverHandle: tlstate.onUnhoverHandle,\n    onReleaseHandle: tlstate.onReleaseHandle,\n    onChange: tlstate.onChange,\n    onError: tlstate.onError,\n    onBlurEditingShape: tlstate.onBlurEditingShape\n  })), React.createElement(Spacer, null), React.createElement(StylePanel, null), React.createElement(ToolsPanel, null))));\n}\nvar Spacer = /*#__PURE__*/styled('div', {\n  flexGrow: 2\n}); // const MenuButtons = styled('div', {\n//   display: 'flex',\n//   gap: 8,\n// })\n\nvar Layout = /*#__PURE__*/styled('main', {\n  position: 'fixed',\n  overflow: 'hidden',\n  top: 0,\n  left: 0,\n  bottom: 0,\n  right: 0,\n  height: '100%',\n  width: '100%',\n  padding: '8px 8px 0 8px',\n  zIndex: 200,\n  display: 'flex',\n  alignItems: 'flex-start',\n  justifyContent: 'flex-start',\n  boxSizing: 'border-box',\n  outline: 'none',\n  pointerEvents: 'none',\n  '& > *': {\n    pointerEvents: 'all'\n  },\n  '& .tl-container': {\n    position: 'absolute',\n    top: 0,\n    left: 0\n  }\n});\n\nexports.TLDraw = TLDraw;\nexports.TLDrawShapeUtil = TLDrawShapeUtil;\nexports.TLDrawState = TLDrawState;\nexports.createShape = createShape;\nexports.defaultStyle = defaultStyle;\nexports.fills = fills;\nexports.getFontSize = getFontSize;\nexports.getFontStyle = getFontStyle;\nexports.getPerfectDashProps = getPerfectDashProps;\nexports.getShapeStyle = getShapeStyle;\nexports.getShapeUtils = getShapeUtils;\nexports.getStrokeWidth = getStrokeWidth;\nexports.strokes = strokes;\nexports.tldrawShapeUtils = tldrawShapeUtils;\n//# sourceMappingURL=tldraw.cjs.development.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdGxkcmF3L3d3dy8uLi9wYWNrYWdlcy90bGRyYXcvZGlzdC90bGRyYXcuY2pzLmRldmVsb3BtZW50LmpzPzFlNDEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDLENBQUMsY0FBYyxFQUFDOztBQUU3RCwrQkFBK0IsaUZBQWlGOztBQUVoSCxZQUFZLG1CQUFPLENBQUMsb0JBQU87QUFDM0I7QUFDQSxjQUFjLG1CQUFPLENBQUMsOENBQW9CO0FBQzFDLFdBQVcsbUJBQU8sQ0FBQyxvREFBYztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQywwQ0FBa0I7QUFDMUM7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQyw4Q0FBb0I7QUFDbkQsWUFBWSxtQkFBTyxDQUFDLHdDQUFpQjtBQUNyQyx1QkFBdUIsbUJBQU8sQ0FBQyxrRUFBOEI7QUFDN0QsbUJBQW1CLG1CQUFPLENBQUMsd0RBQXlCO0FBQ3BELG1CQUFtQixtQkFBTyxDQUFDLG9FQUErQjtBQUMxRCxtQkFBTyxDQUFDLGdFQUE2QjtBQUNyQyxpQkFBaUIsbUJBQU8sQ0FBQyxvREFBdUI7QUFDaEQsZUFBZSxtQkFBTyxDQUFDLDBEQUEwQjtBQUNqRCxrQ0FBa0MsbUJBQU8sQ0FBQyx3QkFBUzs7QUFFbkQ7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxTQUFTOztBQUVqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNkJBQTZCLHNCQUFzQixLQUFLOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEIsdUJBQXVCLEtBQUs7O0FBRTNEO0FBQ0E7QUFDQSxDQUFDLHlCQUF5QixrQkFBa0IsS0FBSzs7QUFFakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx5QkFBeUIsa0JBQWtCLEtBQUs7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0IsaUJBQWlCLEtBQUs7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUIsS0FBSzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsdUJBQXVCLGdCQUFnQixLQUFLOztBQUU3QztBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxHQUFHLG1CQUFtQjtBQUN0QjtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLEdBQUcsbUJBQW1CO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esc0NBQXNDO0FBQ3RDLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1RUFBdUUsYUFBYTtBQUNwRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMElBQTBJOztBQUUxSTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7O0FBR0wscURBQXFEO0FBQ3JELHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0RBQXNELEVBQUU7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUVBQXVFLGFBQWE7QUFDcEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCx3QkFBd0I7QUFDeEI7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyRUFBMkU7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjs7QUFFM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLGlDQUFpQztBQUNqQztBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw4QkFBOEIsNkJBQTZCO0FBQzlGO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtRUFBbUU7O0FBRW5FO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7O0FBRUEsMERBQTBEO0FBQzFEO0FBQ0E7O0FBRUEsNkVBQTZFO0FBQzdFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQiwwQkFBMEI7QUFDMUI7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLDJCQUEyQjtBQUMzQjtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxXQUFXO0FBQ1gsMEJBQTBCO0FBQzFCO0FBQ0EsV0FBVztBQUNYLDJCQUEyQjtBQUMzQjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVFQUF1RSxhQUFhO0FBQ3BGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVFQUF1RSxhQUFhO0FBQ3BGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsc0JBQXNCO0FBQ3RCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQkFBZ0I7QUFDaEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVCQUF1QixnQkFBZ0IsS0FBSzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUIsS0FBSzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEIsbUJBQW1CLEtBQUs7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBLENBQUMsNkJBQTZCLHNCQUFzQixLQUFLOztBQUV6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTtBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix5QkFBeUIsYUFBYSxFQUFFLGNBQWMsR0FBRztBQUNuRixZQUFZLGFBQWEsV0FBVztBQUNwQztBQUNBLG9CQUFvQjtBQUNwQix5QkFBeUI7QUFDekIseUJBQXlCLG1DQUFtQyxLQUFLO0FBQ2pFO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTtBQUNBLHFDQUFxQyxHQUFHO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZ0JBQWdCO0FBQ2hCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxnQkFBZ0I7QUFDaEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRyxhQUFhO0FBQ2hCO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUssRUFBRTs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRTs7QUFFUCx3Q0FBd0M7O0FBRXhDO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBLEtBQUssRUFBRTs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSzs7QUFFTCxtRkFBbUYsNkJBQTZCO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwyREFBMkQ7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQSwrRUFBK0UsK0JBQStCO0FBQzlHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXOztBQUVYOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXOztBQUVYOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLE9BQU87QUFDUDtBQUNBLGlDQUFpQztBQUNqQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLE9BQU87QUFDUDtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLE9BQU87QUFDUCw0QkFBNEI7QUFDNUI7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsT0FBTztBQUNQLDRCQUE0QjtBQUM1QjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwyQkFBMkI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7O0FBR1gsa0VBQWtFOztBQUVsRSxvRUFBb0U7O0FBRXBFO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxXQUFXOzs7QUFHWCxrRUFBa0U7O0FBRWxFLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCLG1EQUFtRCxVQUFVO0FBQzdEO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlDQUFpQyxhQUFhO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCLDJCQUEyQiw2QkFBNkI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDRCQUE0QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQ0FBa0MsZUFBZTtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLDJCQUEyQjtBQUMzQixPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsdUJBQXVCO0FBQ3ZCLDJCQUEyQjtBQUMzQixPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQixHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEIsOEJBQThCO0FBQzlCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEIsNEJBQTRCO0FBQzVCO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0Qiw0QkFBNEI7QUFDNUI7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUIseUJBQXlCO0FBQ3pCLDJCQUEyQjtBQUMzQiw4QkFBOEI7QUFDOUIsT0FBTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakMsd0NBQXdDO0FBQ3hDLHlDQUF5QztBQUN6QztBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsd0NBQXdDO0FBQ3hDLHlDQUF5QztBQUN6QztBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTOzs7QUFHVCxzQ0FBc0M7QUFDdEMsdUNBQXVDO0FBQ3ZDO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQSxTQUFTLEVBQUU7O0FBRVgsc0NBQXNDO0FBQ3RDLHVDQUF1QztBQUN2QztBQUNBLFdBQVc7QUFDWCxTQUFTLElBQUk7O0FBRWI7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOzs7QUFHUCxvQ0FBb0M7QUFDcEMscUNBQXFDO0FBQ3JDO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6QjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLFdBQVc7QUFDWCx5Q0FBeUM7QUFDekM7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFNBQVM7QUFDVCw4QkFBOEI7QUFDOUI7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1QsOEJBQThCO0FBQzlCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCx3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1QsOEJBQThCO0FBQzlCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsQ0FBQyxHQUFHOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCLDZCQUE2QixtQ0FBbUMsbUNBQW1DO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6Qiw2QkFBNkIsbUNBQW1DO0FBQ2hFLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCLHlCQUF5QjtBQUN6QixPQUFPOztBQUVQO0FBQ0EsK01BQStNOztBQUUvTTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekIsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EscUdBQXFHO0FBQ3JHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDOzs7QUFHQTtBQUNBLHNCQUFzQjtBQUN0Qix1QkFBdUI7QUFDdkIsMkJBQTJCLG1DQUFtQyxzQ0FBc0M7QUFDcEc7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLDRCQUE0QjtBQUM1QjtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0Qix1QkFBdUI7QUFDdkI7QUFDQSwyQkFBMkIsbUNBQW1DO0FBQzlELE9BQU87QUFDUCw0QkFBNEI7QUFDNUI7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1Qix5QkFBeUI7QUFDekIsOEJBQThCO0FBQzlCLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpRkFBaUYsNkJBQTZCO0FBQzlHO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQSx3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLEdBQUc7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLCtDQUErQztBQUM3STs7QUFFQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCLDZCQUE2QixtQ0FBbUMsbUNBQW1DO0FBQ25HLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekIsNkJBQTZCLG1DQUFtQztBQUNoRSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7OztBQUdyQzs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTzs7O0FBR1A7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUIsK0JBQStCO0FBQy9CO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQjtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsK0JBQStCO0FBQy9CO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0VBQXdFLGFBQWE7QUFDckY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsV0FBVztBQUNYLGdDQUFnQztBQUNoQztBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEVBQThFLGVBQWU7QUFDN0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7O0FBR25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUM7O0FBRUEsMkNBQTJDO0FBQzNDOztBQUVBLHFDQUFxQztBQUNyQzs7QUFFQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtELGlDQUFpQztBQUNuRiw4REFBOEQ7QUFDOUQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQyx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQzs7QUFFQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRDQUE0QztBQUM1Qzs7QUFFQSwyQ0FBMkM7QUFDM0M7O0FBRUEseUNBQXlDO0FBQ3pDOztBQUVBLHNDQUFzQztBQUN0Qzs7QUFFQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrREFBa0Q7QUFDbEQ7O0FBRUEsaURBQWlEO0FBQ2pEOztBQUVBLDJDQUEyQztBQUMzQzs7QUFFQSw0Q0FBNEM7QUFDNUM7O0FBRUEsOENBQThDO0FBQzlDOztBQUVBLDhDQUE4QztBQUM5Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNENBQTRDO0FBQzVDOztBQUVBLDJDQUEyQztBQUMzQzs7QUFFQSxxQ0FBcUM7QUFDckM7O0FBRUEsc0NBQXNDO0FBQ3RDOztBQUVBLHdDQUF3QztBQUN4Qzs7QUFFQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7O0FBRUEsMkNBQTJDO0FBQzNDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4RkFBOEYsZUFBZTtBQUM3RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwRUFBMEUsZUFBZTtBQUN6RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBFQUEwRSxlQUFlO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwRUFBMEUsZUFBZTtBQUN6RjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx5QkFBeUI7QUFDekIsNkJBQTZCLG1DQUFtQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixXQUFXO0FBQ1gsU0FBUztBQUNULDhCQUE4QjtBQUM5QjtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxnREFBZ0Q7QUFDaEQsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTtBQUNIO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELGNBQWM7QUFDZCx1QkFBdUI7QUFDdkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEIsYUFBYTtBQUNiLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEIsMkJBQTJCO0FBQzNCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCLGVBQWU7QUFDZix3QkFBd0I7QUFDeEIiLCJmaWxlIjoiLi4vcGFja2FnZXMvdGxkcmF3L2Rpc3QvdGxkcmF3LmNqcy5kZXZlbG9wbWVudC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChleCkgeyByZXR1cm4gKGV4ICYmICh0eXBlb2YgZXggPT09ICdvYmplY3QnKSAmJiAnZGVmYXVsdCcgaW4gZXgpID8gZXhbJ2RlZmF1bHQnXSA6IGV4OyB9XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RfX2RlZmF1bHQgPSBfaW50ZXJvcERlZmF1bHQoUmVhY3QpO1xudmFyIHJlYWN0SWQgPSByZXF1aXJlKCdAcmFkaXgtdWkvcmVhY3QtaWQnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnQHRsZHJhdy9jb3JlJyk7XG52YXIgZ2V0U3Ryb2tlID0gcmVxdWlyZSgncGVyZmVjdC1mcmVlaGFuZCcpO1xudmFyIGdldFN0cm9rZV9fZGVmYXVsdCA9IF9pbnRlcm9wRGVmYXVsdChnZXRTdHJva2UpO1xudmFyIHJlYWN0SG90a2V5c0hvb2sgPSByZXF1aXJlKCdyZWFjdC1ob3RrZXlzLWhvb2snKTtcbnZhciByZWFjdCA9IHJlcXVpcmUoJ0BzdGl0Y2hlcy9yZWFjdCcpO1xudmFyIFJhZGl4Q29udGV4dE1lbnUgPSByZXF1aXJlKCdAcmFkaXgtdWkvcmVhY3QtY29udGV4dC1tZW51Jyk7XG52YXIgUmFkaXhUb29sdGlwID0gcmVxdWlyZSgnQHJhZGl4LXVpL3JlYWN0LXRvb2x0aXAnKTtcbnZhciBEcm9wZG93bk1lbnUgPSByZXF1aXJlKCdAcmFkaXgtdWkvcmVhY3QtZHJvcGRvd24tbWVudScpO1xucmVxdWlyZSgnQHJhZGl4LXVpL3JlYWN0LXJhZGlvLWdyb3VwJyk7XG52YXIgcmVhY3RJY29ucyA9IHJlcXVpcmUoJ0ByYWRpeC11aS9yZWFjdC1pY29ucycpO1xudmFyIENoZWNrYm94ID0gcmVxdWlyZSgnQHJhZGl4LXVpL3JlYWN0LWNoZWNrYm94Jyk7XG52YXIgY3JlYXRlUmVhY3QgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnenVzdGFuZCcpKTtcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG5cbiAgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShvLCBhbGxvd0FycmF5TGlrZSkge1xuICB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKGl0KSByZXR1cm4gKGl0ID0gaXQuY2FsbChvKSkubmV4dC5iaW5kKGl0KTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKGl0KSBvID0gaXQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogb1tpKytdXG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbihmdW5jdGlvbiAoVExEcmF3VG9vbFR5cGUpIHtcbiAgVExEcmF3VG9vbFR5cGVbXCJEcmF3XCJdID0gXCJkcmF3XCI7XG4gIFRMRHJhd1Rvb2xUeXBlW1wiQm91bmRzXCJdID0gXCJib3VuZHNcIjtcbiAgVExEcmF3VG9vbFR5cGVbXCJQb2ludFwiXSA9IFwicG9pbnRcIjtcbiAgVExEcmF3VG9vbFR5cGVbXCJIYW5kbGVcIl0gPSBcImhhbmRsZVwiO1xuICBUTERyYXdUb29sVHlwZVtcIlBvaW50c1wiXSA9IFwicG9pbnRzXCI7XG59KShleHBvcnRzLlRMRHJhd1Rvb2xUeXBlIHx8IChleHBvcnRzLlRMRHJhd1Rvb2xUeXBlID0ge30pKTtcblxuKGZ1bmN0aW9uIChUTERyYXdTaGFwZVR5cGUpIHtcbiAgVExEcmF3U2hhcGVUeXBlW1wiRWxsaXBzZVwiXSA9IFwiZWxsaXBzZVwiO1xuICBUTERyYXdTaGFwZVR5cGVbXCJSZWN0YW5nbGVcIl0gPSBcInJlY3RhbmdsZVwiO1xuICBUTERyYXdTaGFwZVR5cGVbXCJEcmF3XCJdID0gXCJkcmF3XCI7XG4gIFRMRHJhd1NoYXBlVHlwZVtcIkFycm93XCJdID0gXCJhcnJvd1wiO1xufSkoZXhwb3J0cy5UTERyYXdTaGFwZVR5cGUgfHwgKGV4cG9ydHMuVExEcmF3U2hhcGVUeXBlID0ge30pKTtcblxuKGZ1bmN0aW9uIChEZWNvcmF0aW9uKSB7XG4gIERlY29yYXRpb25bXCJBcnJvd1wiXSA9IFwiQXJyb3dcIjtcbn0pKGV4cG9ydHMuRGVjb3JhdGlvbiB8fCAoZXhwb3J0cy5EZWNvcmF0aW9uID0ge30pKTtcblxudmFyIFRMRHJhd1NoYXBlVXRpbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1RMU2hhcGVVdGlsKSB7XG4gIF9pbmhlcml0c0xvb3NlKFRMRHJhd1NoYXBlVXRpbCwgX1RMU2hhcGVVdGlsKTtcblxuICBmdW5jdGlvbiBUTERyYXdTaGFwZVV0aWwoKSB7XG4gICAgcmV0dXJuIF9UTFNoYXBlVXRpbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICByZXR1cm4gVExEcmF3U2hhcGVVdGlsO1xufShjb3JlLlRMU2hhcGVVdGlsKTtcblxuKGZ1bmN0aW9uIChDb2xvclN0eWxlKSB7XG4gIENvbG9yU3R5bGVbXCJXaGl0ZVwiXSA9IFwiV2hpdGVcIjtcbiAgQ29sb3JTdHlsZVtcIkxpZ2h0R3JheVwiXSA9IFwiTGlnaHRHcmF5XCI7XG4gIENvbG9yU3R5bGVbXCJHcmF5XCJdID0gXCJHcmF5XCI7XG4gIENvbG9yU3R5bGVbXCJCbGFja1wiXSA9IFwiQmxhY2tcIjtcbiAgQ29sb3JTdHlsZVtcIkdyZWVuXCJdID0gXCJHcmVlblwiO1xuICBDb2xvclN0eWxlW1wiQ3lhblwiXSA9IFwiQ3lhblwiO1xuICBDb2xvclN0eWxlW1wiQmx1ZVwiXSA9IFwiQmx1ZVwiO1xuICBDb2xvclN0eWxlW1wiSW5kaWdvXCJdID0gXCJJbmRpZ29cIjtcbiAgQ29sb3JTdHlsZVtcIlZpb2xldFwiXSA9IFwiVmlvbGV0XCI7XG4gIENvbG9yU3R5bGVbXCJSZWRcIl0gPSBcIlJlZFwiO1xuICBDb2xvclN0eWxlW1wiT3JhbmdlXCJdID0gXCJPcmFuZ2VcIjtcbiAgQ29sb3JTdHlsZVtcIlllbGxvd1wiXSA9IFwiWWVsbG93XCI7XG59KShleHBvcnRzLkNvbG9yU3R5bGUgfHwgKGV4cG9ydHMuQ29sb3JTdHlsZSA9IHt9KSk7XG5cbihmdW5jdGlvbiAoU2l6ZVN0eWxlKSB7XG4gIFNpemVTdHlsZVtcIlNtYWxsXCJdID0gXCJTbWFsbFwiO1xuICBTaXplU3R5bGVbXCJNZWRpdW1cIl0gPSBcIk1lZGl1bVwiO1xuICBTaXplU3R5bGVbXCJMYXJnZVwiXSA9IFwiTGFyZ2VcIjtcbn0pKGV4cG9ydHMuU2l6ZVN0eWxlIHx8IChleHBvcnRzLlNpemVTdHlsZSA9IHt9KSk7XG5cbihmdW5jdGlvbiAoRGFzaFN0eWxlKSB7XG4gIERhc2hTdHlsZVtcIkRyYXdcIl0gPSBcIkRyYXdcIjtcbiAgRGFzaFN0eWxlW1wiU29saWRcIl0gPSBcIlNvbGlkXCI7XG4gIERhc2hTdHlsZVtcIkRhc2hlZFwiXSA9IFwiRGFzaGVkXCI7XG4gIERhc2hTdHlsZVtcIkRvdHRlZFwiXSA9IFwiRG90dGVkXCI7XG59KShleHBvcnRzLkRhc2hTdHlsZSB8fCAoZXhwb3J0cy5EYXNoU3R5bGUgPSB7fSkpO1xuXG4oZnVuY3Rpb24gKEZvbnRTaXplKSB7XG4gIEZvbnRTaXplW1wiU21hbGxcIl0gPSBcIlNtYWxsXCI7XG4gIEZvbnRTaXplW1wiTWVkaXVtXCJdID0gXCJNZWRpdW1cIjtcbiAgRm9udFNpemVbXCJMYXJnZVwiXSA9IFwiTGFyZ2VcIjtcbiAgRm9udFNpemVbXCJFeHRyYUxhcmdlXCJdID0gXCJFeHRyYUxhcmdlXCI7XG59KShleHBvcnRzLkZvbnRTaXplIHx8IChleHBvcnRzLkZvbnRTaXplID0ge30pKTtcblxudmFyIF9jb2xvcnMsIF9leHRlbmRzMiwgX2V4dGVuZHMzLCBfc3Ryb2tlV2lkdGhzLCBfZm9udFNpemVzO1xudmFyIGNhbnZhc0xpZ2h0ID0gJyNmYWZhZmEnO1xudmFyIGNhbnZhc0RhcmsgPSAnIzM0M2Q0NSc7XG52YXIgY29sb3JzID0gKF9jb2xvcnMgPSB7fSwgX2NvbG9yc1tleHBvcnRzLkNvbG9yU3R5bGUuQmxhY2tdID0gJyMyMTI1MjgnLCBfY29sb3JzW2V4cG9ydHMuQ29sb3JTdHlsZS5XaGl0ZV0gPSAnI2YwZjFmMycsIF9jb2xvcnNbZXhwb3J0cy5Db2xvclN0eWxlLkxpZ2h0R3JheV0gPSAnI2M2Y2JkMScsIF9jb2xvcnNbZXhwb3J0cy5Db2xvclN0eWxlLkdyYXldID0gJyM3ODg0OTInLCBfY29sb3JzW2V4cG9ydHMuQ29sb3JTdHlsZS5HcmVlbl0gPSAnIzM2YjI0ZCcsIF9jb2xvcnNbZXhwb3J0cy5Db2xvclN0eWxlLkN5YW5dID0gJyMwZTk4YWQnLCBfY29sb3JzW2V4cG9ydHMuQ29sb3JTdHlsZS5CbHVlXSA9ICcjMWM3ZWQ2JywgX2NvbG9yc1tleHBvcnRzLkNvbG9yU3R5bGUuSW5kaWdvXSA9ICcjNDI2M2ViJywgX2NvbG9yc1tleHBvcnRzLkNvbG9yU3R5bGUuVmlvbGV0XSA9ICcjNzc0NmYxJywgX2NvbG9yc1tleHBvcnRzLkNvbG9yU3R5bGUuUmVkXSA9ICcjZmYyMTMzJywgX2NvbG9yc1tleHBvcnRzLkNvbG9yU3R5bGUuT3JhbmdlXSA9ICcjZmY5NDMzJywgX2NvbG9yc1tleHBvcnRzLkNvbG9yU3R5bGUuWWVsbG93XSA9ICcjZmZjOTM2JywgX2NvbG9ycyk7XG52YXIgc3Ryb2tlcyA9IHtcbiAgbGlnaHQ6IGNvbG9ycyxcbiAgZGFyazogLyojX19QVVJFX18qL19leHRlbmRzKHt9LCAvKiNfX1BVUkVfXyovT2JqZWN0LmZyb21FbnRyaWVzKCAvKiNfX1BVUkVfXyovT2JqZWN0LmVudHJpZXMoY29sb3JzKS5tYXAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgayA9IF9yZWZbMF0sXG4gICAgICAgIHYgPSBfcmVmWzFdO1xuICAgIHJldHVybiBbaywgY29yZS5VdGlscy5sZXJwQ29sb3IodiwgY2FudmFzRGFyaywgMC4xKV07XG4gIH0pKSwgKF9leHRlbmRzMiA9IHt9LCBfZXh0ZW5kczJbZXhwb3J0cy5Db2xvclN0eWxlLldoaXRlXSA9ICcjZmZmZmZmJywgX2V4dGVuZHMyW2V4cG9ydHMuQ29sb3JTdHlsZS5CbGFja10gPSAnIzAwMCcsIF9leHRlbmRzMikpXG59O1xudmFyIGZpbGxzID0ge1xuICBsaWdodDogLyojX19QVVJFX18qL19leHRlbmRzKHt9LCAvKiNfX1BVUkVfXyovT2JqZWN0LmZyb21FbnRyaWVzKCAvKiNfX1BVUkVfXyovT2JqZWN0LmVudHJpZXMoY29sb3JzKS5tYXAoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgdmFyIGsgPSBfcmVmMlswXSxcbiAgICAgICAgdiA9IF9yZWYyWzFdO1xuICAgIHJldHVybiBbaywgY29yZS5VdGlscy5sZXJwQ29sb3IodiwgY2FudmFzTGlnaHQsIDAuODIpXTtcbiAgfSkpLCAoX2V4dGVuZHMzID0ge30sIF9leHRlbmRzM1tleHBvcnRzLkNvbG9yU3R5bGUuV2hpdGVdID0gJyNmZmZmZmYnLCBfZXh0ZW5kczNbZXhwb3J0cy5Db2xvclN0eWxlLkJsYWNrXSA9ICcjZmZmZmZmJywgX2V4dGVuZHMzKSksXG4gIGRhcms6IC8qI19fUFVSRV9fKi9PYmplY3QuZnJvbUVudHJpZXMoIC8qI19fUFVSRV9fKi9PYmplY3QuZW50cmllcyhjb2xvcnMpLm1hcChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICB2YXIgayA9IF9yZWYzWzBdLFxuICAgICAgICB2ID0gX3JlZjNbMV07XG4gICAgcmV0dXJuIFtrLCBjb3JlLlV0aWxzLmxlcnBDb2xvcih2LCBjYW52YXNEYXJrLCAwLjYxOCldO1xuICB9KSlcbn07XG52YXIgc3Ryb2tlV2lkdGhzID0gKF9zdHJva2VXaWR0aHMgPSB7fSwgX3N0cm9rZVdpZHRoc1tleHBvcnRzLlNpemVTdHlsZS5TbWFsbF0gPSAyLCBfc3Ryb2tlV2lkdGhzW2V4cG9ydHMuU2l6ZVN0eWxlLk1lZGl1bV0gPSA0LCBfc3Ryb2tlV2lkdGhzW2V4cG9ydHMuU2l6ZVN0eWxlLkxhcmdlXSA9IDgsIF9zdHJva2VXaWR0aHMpO1xudmFyIGZvbnRTaXplcyA9IChfZm9udFNpemVzID0ge30sIF9mb250U2l6ZXNbZXhwb3J0cy5TaXplU3R5bGUuU21hbGxdID0gMjQsIF9mb250U2l6ZXNbZXhwb3J0cy5TaXplU3R5bGUuTWVkaXVtXSA9IDQ4LCBfZm9udFNpemVzW2V4cG9ydHMuU2l6ZVN0eWxlLkxhcmdlXSA9IDcyLCBfZm9udFNpemVzLmF1dG8gPSAnYXV0bycsIF9mb250U2l6ZXMpO1xuZnVuY3Rpb24gZ2V0U3Ryb2tlV2lkdGgoc2l6ZSkge1xuICByZXR1cm4gc3Ryb2tlV2lkdGhzW3NpemVdO1xufVxuZnVuY3Rpb24gZ2V0Rm9udFNpemUoc2l6ZSkge1xuICByZXR1cm4gZm9udFNpemVzW3NpemVdO1xufVxuZnVuY3Rpb24gZ2V0Rm9udFN0eWxlKHNjYWxlLCBzdHlsZSkge1xuICB2YXIgZm9udFNpemUgPSBnZXRGb250U2l6ZShzdHlsZS5zaXplKTtcbiAgcmV0dXJuIGZvbnRTaXplICogc2NhbGUgKyBcInB4LzEuNCBWZXJ2ZWluZSBSZWd1bGFyXCI7XG59XG5mdW5jdGlvbiBnZXRTaGFwZVN0eWxlKHN0eWxlLCBpc0RhcmtNb2RlKSB7XG4gIGlmIChpc0RhcmtNb2RlID09PSB2b2lkIDApIHtcbiAgICBpc0RhcmtNb2RlID0gZmFsc2U7XG4gIH1cblxuICB2YXIgY29sb3IgPSBzdHlsZS5jb2xvcixcbiAgICAgIHNpemUgPSBzdHlsZS5zaXplLFxuICAgICAgaXNGaWxsZWQgPSBzdHlsZS5pc0ZpbGxlZDtcbiAgdmFyIHN0cm9rZVdpZHRoID0gZ2V0U3Ryb2tlV2lkdGgoc2l6ZSk7XG4gIHZhciB0aGVtZSA9IGlzRGFya01vZGUgPyAnZGFyaycgOiAnbGlnaHQnO1xuICByZXR1cm4ge1xuICAgIHN0cm9rZTogc3Ryb2tlc1t0aGVtZV1bY29sb3JdLFxuICAgIGZpbGw6IGlzRmlsbGVkID8gZmlsbHNbdGhlbWVdW2NvbG9yXSA6ICdub25lJyxcbiAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGhcbiAgfTtcbn1cbnZhciBkZWZhdWx0U3R5bGUgPSB7XG4gIGNvbG9yOiBleHBvcnRzLkNvbG9yU3R5bGUuQmxhY2ssXG4gIHNpemU6IGV4cG9ydHMuU2l6ZVN0eWxlLk1lZGl1bSxcbiAgaXNGaWxsZWQ6IGZhbHNlLFxuICBkYXNoOiBleHBvcnRzLkRhc2hTdHlsZS5EcmF3XG59O1xuLyoqXHJcbiAqIEdldCBiYWxhbmNlZCBkYXNoLXN0cm9rZWFycmF5IGFuZCBkYXNoLXN0cm9rZW9mZnNldCBwcm9wZXJ0aWVzIGZvciBhIHBhdGggb2YgYSBnaXZlbiBsZW5ndGguXHJcbiAqIEBwYXJhbSBsZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgcGF0aC5cclxuICogQHBhcmFtIHN0cm9rZVdpZHRoIFRoZSBzaGFwZSdzIHN0cm9rZS13aWR0aCBwcm9wZXJ0eS5cclxuICogQHBhcmFtIHN0eWxlIFRoZSBzdHJva2UncyBzdHlsZTogXCJkYXNoZWRcIiBvciBcImRvdHRlZFwiIChkZWZhdWx0IFwiZGFzaGVkXCIpLlxyXG4gKiBAcGFyYW0gc25hcCBBbiBpbnRlcnZhbCBmb3IgZGFzaGVzIChlLmcuIDQgd2lsbCBwcm9kdWNlIGFycmF5cyB3aXRoIDQsIDgsIDE2LCBldGMgZGFzaGVzKS5cclxuICovXG5cbmZ1bmN0aW9uIGdldFBlcmZlY3REYXNoUHJvcHMobGVuZ3RoLCBzdHJva2VXaWR0aCwgc3R5bGUsIHNuYXApIHtcbiAgaWYgKHNuYXAgPT09IHZvaWQgMCkge1xuICAgIHNuYXAgPSAxO1xuICB9XG5cbiAgdmFyIGRhc2hMZW5ndGg7XG4gIHZhciBzdHJva2VEYXNob2Zmc2V0O1xuICB2YXIgcmF0aW87XG5cbiAgaWYgKHN0eWxlID09PSBleHBvcnRzLkRhc2hTdHlsZS5Tb2xpZCB8fCBzdHlsZSA9PT0gZXhwb3J0cy5EYXNoU3R5bGUuRHJhdykge1xuICAgIHJldHVybiB7XG4gICAgICBzdHJva2VEYXNoYXJyYXk6ICdub25lJyxcbiAgICAgIHN0cm9rZURhc2hvZmZzZXQ6ICdub25lJ1xuICAgIH07XG4gIH0gZWxzZSBpZiAoc3R5bGUgPT09IGV4cG9ydHMuRGFzaFN0eWxlLkRhc2hlZCkge1xuICAgIGRhc2hMZW5ndGggPSBzdHJva2VXaWR0aCAqIDI7XG4gICAgcmF0aW8gPSAxO1xuICAgIHN0cm9rZURhc2hvZmZzZXQgPSAoZGFzaExlbmd0aCAvIDIpLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgZGFzaExlbmd0aCA9IHN0cm9rZVdpZHRoIC8gMTAwO1xuICAgIHJhdGlvID0gMTAwO1xuICAgIHN0cm9rZURhc2hvZmZzZXQgPSAnMCc7XG4gIH1cblxuICB2YXIgZGFzaGVzID0gTWF0aC5mbG9vcihsZW5ndGggLyBkYXNoTGVuZ3RoIC8gKDIgKiByYXRpbykpO1xuICBkYXNoZXMgLT0gZGFzaGVzICUgc25hcDtcbiAgaWYgKGRhc2hlcyA9PT0gMCkgZGFzaGVzID0gMTtcbiAgdmFyIGdhcExlbmd0aCA9IChsZW5ndGggLSBkYXNoZXMgKiBkYXNoTGVuZ3RoKSAvIGRhc2hlcztcbiAgcmV0dXJuIHtcbiAgICBzdHJva2VEYXNoYXJyYXk6IFtkYXNoTGVuZ3RoLCBnYXBMZW5ndGhdLmpvaW4oJyAnKSxcbiAgICBzdHJva2VEYXNob2Zmc2V0OiBzdHJva2VEYXNob2Zmc2V0XG4gIH07XG59XG5cbnZhciBEcmF3ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVExEcmF3U2hhcGVVdGlsKSB7XG4gIF9pbmhlcml0c0xvb3NlKERyYXcsIF9UTERyYXdTaGFwZVV0aWwpO1xuXG4gIGZ1bmN0aW9uIERyYXcoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX1RMRHJhd1NoYXBlVXRpbC5jYWxsLmFwcGx5KF9UTERyYXdTaGFwZVV0aWwsIFt0aGlzXS5jb25jYXQoYXJncykpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IGV4cG9ydHMuVExEcmF3U2hhcGVUeXBlLkRyYXc7XG4gICAgX3RoaXMudG9vbFR5cGUgPSBleHBvcnRzLlRMRHJhd1Rvb2xUeXBlLkRyYXc7XG4gICAgX3RoaXMucG9pbnRzQm91bmRzQ2FjaGUgPSBuZXcgV2Vha01hcChbXSk7XG4gICAgX3RoaXMucm90YXRlZENhY2hlID0gbmV3IFdlYWtNYXAoW10pO1xuICAgIF90aGlzLmRyYXdQYXRoQ2FjaGUgPSBuZXcgV2Vha01hcChbXSk7XG4gICAgX3RoaXMuc2ltcGxlUGF0aENhY2hlID0gbmV3IFdlYWtNYXAoW10pO1xuICAgIF90aGlzLnBvbHlnb25DYWNoZSA9IG5ldyBXZWFrTWFwKFtdKTtcbiAgICBfdGhpcy5kZWZhdWx0UHJvcHMgPSB7XG4gICAgICBpZDogJ2lkJyxcbiAgICAgIHR5cGU6IGV4cG9ydHMuVExEcmF3U2hhcGVUeXBlLkRyYXcsXG4gICAgICBuYW1lOiAnRHJhdycsXG4gICAgICBwYXJlbnRJZDogJ3BhZ2UnLFxuICAgICAgY2hpbGRJbmRleDogMSxcbiAgICAgIHBvaW50OiBbMCwgMF0sXG4gICAgICBwb2ludHM6IFtbMCwgMCwgMC41XV0sXG4gICAgICByb3RhdGlvbjogMCxcbiAgICAgIHJhZGl1czogMCxcbiAgICAgIHN0eWxlOiBkZWZhdWx0U3R5bGVcbiAgICB9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBEcmF3LnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKHNoYXBlLCBfcmVmKSB7XG4gICAgdmFyIF9EYXNoU3R5bGUkRHJhdyREYXNoUywgX0Rhc2hTdHlsZSREcmF3JERhc2hTMjtcblxuICAgIHZhciBpc0hvdmVyZWQgPSBfcmVmLmlzSG92ZXJlZCxcbiAgICAgICAgaXNEYXJrTW9kZSA9IF9yZWYuaXNEYXJrTW9kZTtcbiAgICB2YXIgcG9pbnRzID0gc2hhcGUucG9pbnRzLFxuICAgICAgICBzdHlsZSA9IHNoYXBlLnN0eWxlO1xuICAgIHZhciBzdHlsZXMgPSBnZXRTaGFwZVN0eWxlKHN0eWxlLCBpc0RhcmtNb2RlKTtcbiAgICB2YXIgc3Ryb2tlV2lkdGggPSArc3R5bGVzLnN0cm9rZVdpZHRoO1xuICAgIHZhciBzaG91bGRGaWxsID0gc3R5bGUuaXNGaWxsZWQgJiYgcG9pbnRzLmxlbmd0aCA+IDMgJiYgY29yZS5WZWMuZGlzdChwb2ludHNbMF0sIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0pIDwgK3N0eWxlcy5zdHJva2VXaWR0aCAqIDI7IC8vIEZvciB2ZXJ5IHNob3J0IGxpbmVzLCBkcmF3IGEgcG9pbnQgaW5zdGVhZCBvZiBhIGxpbmVcblxuICAgIGlmIChwb2ludHMubGVuZ3RoID4gMCAmJiBwb2ludHMubGVuZ3RoIDwgMykge1xuICAgICAgdmFyIF9zdyA9IHN0cm9rZVdpZHRoICogMC42MTg7XG5cbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIsIHtcbiAgICAgICAgcjogc3Ryb2tlV2lkdGggKiAwLjYxOCxcbiAgICAgICAgZmlsbDogc3R5bGVzLnN0cm9rZSxcbiAgICAgICAgc3Ryb2tlOiBzdHlsZXMuc3Ryb2tlLFxuICAgICAgICBzdHJva2VXaWR0aDogX3N3LFxuICAgICAgICBwb2ludGVyRXZlbnRzOiBcImFsbFwiLFxuICAgICAgICBmaWx0ZXI6IGlzSG92ZXJlZCA/ICd1cmwoI2V4cGFuZCknIDogJ25vbmUnXG4gICAgICB9KTtcbiAgICB9IC8vIEZvciBkcmF3biBsaW5lcywgZHJhdyBhIGxpbmUgZnJvbSB0aGUgcGF0aCBjYWNoZVxuXG5cbiAgICBpZiAoc2hhcGUuc3R5bGUuZGFzaCA9PT0gZXhwb3J0cy5EYXNoU3R5bGUuRHJhdykge1xuICAgICAgdmFyIHBvbHlnb25QYXRoRGF0YSA9IGNvcmUuVXRpbHMuZ2V0RnJvbUNhY2hlKHRoaXMucG9seWdvbkNhY2hlLCBwb2ludHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGdldEZpbGxQYXRoKHNoYXBlKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGRyYXdQYXRoRGF0YSA9IGNvcmUuVXRpbHMuZ2V0RnJvbUNhY2hlKHRoaXMuZHJhd1BhdGhDYWNoZSwgcG9pbnRzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBnZXREcmF3U3Ryb2tlUGF0aChzaGFwZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBzaG91bGRGaWxsICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICAgICAgZDogcG9seWdvblBhdGhEYXRhLFxuICAgICAgICBzdHJva2U6IFwibm9uZVwiLFxuICAgICAgICBmaWxsOiBzdHlsZXMuZmlsbCxcbiAgICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIixcbiAgICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiBcImZpbGxcIlxuICAgICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICAgICAgZDogZHJhd1BhdGhEYXRhLFxuICAgICAgICBmaWxsOiBzdHlsZXMuc3Ryb2tlLFxuICAgICAgICBzdHJva2U6IHN0eWxlcy5zdHJva2UsXG4gICAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIixcbiAgICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiBcImFsbFwiLFxuICAgICAgICBmaWx0ZXI6IGlzSG92ZXJlZCA/ICd1cmwoI2V4cGFuZCknIDogJ25vbmUnXG4gICAgICB9KSk7XG4gICAgfSAvLyBGb3Igc29saWQsIGRhc2ggYW5kIGRvdHRlZCBsaW5lcywgZHJhdyBhIHJlZ3VsYXIgc3Ryb2tlIHBhdGhcblxuXG4gICAgdmFyIHN0cm9rZURhc2hhcnJheSA9IChfRGFzaFN0eWxlJERyYXckRGFzaFMgPSB7fSwgX0Rhc2hTdHlsZSREcmF3JERhc2hTW2V4cG9ydHMuRGFzaFN0eWxlLkRyYXddID0gJ25vbmUnLCBfRGFzaFN0eWxlJERyYXckRGFzaFNbZXhwb3J0cy5EYXNoU3R5bGUuU29saWRdID0gXCJub25lXCIsIF9EYXNoU3R5bGUkRHJhdyREYXNoU1tleHBvcnRzLkRhc2hTdHlsZS5Eb3R0ZWRdID0gc3Ryb2tlV2lkdGggLyAxMCArIFwiIFwiICsgc3Ryb2tlV2lkdGggKiAzLCBfRGFzaFN0eWxlJERyYXckRGFzaFNbZXhwb3J0cy5EYXNoU3R5bGUuRGFzaGVkXSA9IHN0cm9rZVdpZHRoICogMyArIFwiIFwiICsgc3Ryb2tlV2lkdGggKiAzLCBfRGFzaFN0eWxlJERyYXckRGFzaFMpW3N0eWxlLmRhc2hdO1xuICAgIHZhciBzdHJva2VEYXNob2Zmc2V0ID0gKF9EYXNoU3R5bGUkRHJhdyREYXNoUzIgPSB7fSwgX0Rhc2hTdHlsZSREcmF3JERhc2hTMltleHBvcnRzLkRhc2hTdHlsZS5EcmF3XSA9ICdub25lJywgX0Rhc2hTdHlsZSREcmF3JERhc2hTMltleHBvcnRzLkRhc2hTdHlsZS5Tb2xpZF0gPSBcIm5vbmVcIiwgX0Rhc2hTdHlsZSREcmF3JERhc2hTMltleHBvcnRzLkRhc2hTdHlsZS5Eb3R0ZWRdID0gXCItXCIgKyBzdHJva2VXaWR0aCAvIDIwLCBfRGFzaFN0eWxlJERyYXckRGFzaFMyW2V4cG9ydHMuRGFzaFN0eWxlLkRhc2hlZF0gPSBcIi1cIiArIHN0cm9rZVdpZHRoLCBfRGFzaFN0eWxlJERyYXckRGFzaFMyKVtzdHlsZS5kYXNoXTtcbiAgICB2YXIgcGF0aCA9IGNvcmUuVXRpbHMuZ2V0RnJvbUNhY2hlKHRoaXMuc2ltcGxlUGF0aENhY2hlLCBwb2ludHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBnZXRTb2xpZFN0cm9rZVBhdGgoc2hhcGUpO1xuICAgIH0pO1xuICAgIHZhciBzdyA9IHN0cm9rZVdpZHRoICogMS42MTg7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICAgIGQ6IHBhdGgsXG4gICAgICBmaWxsOiBzaG91bGRGaWxsID8gc3R5bGVzLmZpbGwgOiAnbm9uZScsXG4gICAgICBzdHJva2U6IFwidHJhbnNwYXJlbnRcIixcbiAgICAgIHN0cm9rZVdpZHRoOiBNYXRoLm1pbig0LCBzdHJva2VXaWR0aCAqIDIpLFxuICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIixcbiAgICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgICAgIHBvaW50ZXJFdmVudHM6IHNob3VsZEZpbGwgPyAnYWxsJyA6ICdzdHJva2UnXG4gICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICAgIGQ6IHBhdGgsXG4gICAgICBmaWxsOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICBzdHJva2U6IHN0eWxlcy5zdHJva2UsXG4gICAgICBzdHJva2VXaWR0aDogc3csXG4gICAgICBzdHJva2VEYXNoYXJyYXk6IHN0cm9rZURhc2hhcnJheSxcbiAgICAgIHN0cm9rZURhc2hvZmZzZXQ6IHN0cm9rZURhc2hvZmZzZXQsXG4gICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLFxuICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAgcG9pbnRlckV2ZW50czogXCJzdHJva2VcIixcbiAgICAgIGZpbHRlcjogaXNIb3ZlcmVkID8gJ3VybCgjZXhwYW5kKScgOiAnbm9uZSdcbiAgICB9KSk7XG4gIH07XG5cbiAgX3Byb3RvLmdldEJvdW5kcyA9IGZ1bmN0aW9uIGdldEJvdW5kcyhzaGFwZSkge1xuICAgIHJldHVybiBjb3JlLlV0aWxzLnRyYW5zbGF0ZUJvdW5kcyhjb3JlLlV0aWxzLmdldEZyb21DYWNoZSh0aGlzLnBvaW50c0JvdW5kc0NhY2hlLCBzaGFwZS5wb2ludHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjb3JlLlV0aWxzLmdldEJvdW5kc0Zyb21Qb2ludHMoc2hhcGUucG9pbnRzKTtcbiAgICB9KSwgc2hhcGUucG9pbnQpO1xuICB9O1xuXG4gIF9wcm90by5nZXRSb3RhdGVkQm91bmRzID0gZnVuY3Rpb24gZ2V0Um90YXRlZEJvdW5kcyhzaGFwZSkge1xuICAgIHJldHVybiBjb3JlLlV0aWxzLnRyYW5zbGF0ZUJvdW5kcyhjb3JlLlV0aWxzLmdldEJvdW5kc0Zyb21Qb2ludHMoc2hhcGUucG9pbnRzLCBzaGFwZS5yb3RhdGlvbiksIHNoYXBlLnBvaW50KTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0Q2VudGVyID0gZnVuY3Rpb24gZ2V0Q2VudGVyKHNoYXBlKSB7XG4gICAgcmV0dXJuIGNvcmUuVXRpbHMuZ2V0Qm91bmRzQ2VudGVyKHRoaXMuZ2V0Qm91bmRzKHNoYXBlKSk7XG4gIH07XG5cbiAgX3Byb3RvLmhpdFRlc3QgPSBmdW5jdGlvbiBoaXRUZXN0KHNoYXBlLCBwb2ludCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9wcm90by5oaXRUZXN0Qm91bmRzID0gZnVuY3Rpb24gaGl0VGVzdEJvdW5kcyhzaGFwZSwgYnJ1c2hCb3VuZHMpIHtcbiAgICAvLyBUZXN0IGF4aXMtYWxpZ25lZCBzaGFwZVxuICAgIGlmICghc2hhcGUucm90YXRpb24pIHtcbiAgICAgIHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kcyhzaGFwZSk7XG4gICAgICByZXR1cm4gY29yZS5VdGlscy5ib3VuZHNDb250YWluKGJydXNoQm91bmRzLCBib3VuZHMpIHx8IChjb3JlLlV0aWxzLmJvdW5kc0NvbnRhaW4oYm91bmRzLCBicnVzaEJvdW5kcykgfHwgY29yZS5JbnRlcnNlY3QuYm91bmRzLmJvdW5kcyhib3VuZHMsIGJydXNoQm91bmRzKS5sZW5ndGggPiAwKSAmJiBjb3JlLkludGVyc2VjdC5wb2x5bGluZS5ib3VuZHMoc2hhcGUucG9pbnRzLCBjb3JlLlV0aWxzLnRyYW5zbGF0ZUJvdW5kcyhicnVzaEJvdW5kcywgY29yZS5WZWMubmVnKHNoYXBlLnBvaW50KSkpLmxlbmd0aCA+IDA7XG4gICAgfSAvLyBUZXN0IHJvdGF0ZWQgc2hhcGVcblxuXG4gICAgdmFyIHJCb3VuZHMgPSB0aGlzLmdldFJvdGF0ZWRCb3VuZHMoc2hhcGUpO1xuICAgIHZhciByb3RhdGVkQm91bmRzID0gY29yZS5VdGlscy5nZXRGcm9tQ2FjaGUodGhpcy5yb3RhdGVkQ2FjaGUsIHNoYXBlLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYyA9IGNvcmUuVXRpbHMuZ2V0Qm91bmRzQ2VudGVyKGNvcmUuVXRpbHMuZ2V0Qm91bmRzRnJvbVBvaW50cyhzaGFwZS5wb2ludHMpKTtcbiAgICAgIHJldHVybiBzaGFwZS5wb2ludHMubWFwKGZ1bmN0aW9uIChwdCkge1xuICAgICAgICByZXR1cm4gY29yZS5WZWMucm90V2l0aChwdCwgYywgc2hhcGUucm90YXRpb24gfHwgMCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29yZS5VdGlscy5ib3VuZHNDb250YWluKGJydXNoQm91bmRzLCByQm91bmRzKSB8fCBjb3JlLkludGVyc2VjdC5ib3VuZHMucG9seWxpbmUoY29yZS5VdGlscy50cmFuc2xhdGVCb3VuZHMoYnJ1c2hCb3VuZHMsIGNvcmUuVmVjLm5lZyhzaGFwZS5wb2ludCkpLCByb3RhdGVkQm91bmRzKS5sZW5ndGggPiAwO1xuICB9O1xuXG4gIF9wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbiB0cmFuc2Zvcm0oc2hhcGUsIGJvdW5kcywgX3JlZjIpIHtcbiAgICB2YXIgaW5pdGlhbFNoYXBlID0gX3JlZjIuaW5pdGlhbFNoYXBlLFxuICAgICAgICBzY2FsZVggPSBfcmVmMi5zY2FsZVgsXG4gICAgICAgIHNjYWxlWSA9IF9yZWYyLnNjYWxlWTtcbiAgICB2YXIgaW5pdGlhbFNoYXBlQm91bmRzID0gY29yZS5VdGlscy5nZXRGcm9tQ2FjaGUodGhpcy5ib3VuZHNDYWNoZSwgaW5pdGlhbFNoYXBlLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gY29yZS5VdGlscy5nZXRCb3VuZHNGcm9tUG9pbnRzKGluaXRpYWxTaGFwZS5wb2ludHMpO1xuICAgIH0pO1xuICAgIHZhciBwb2ludHMgPSBpbml0aWFsU2hhcGUucG9pbnRzLm1hcChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgIHZhciB4ID0gX3JlZjNbMF0sXG4gICAgICAgICAgeSA9IF9yZWYzWzFdLFxuICAgICAgICAgIHIgPSBfcmVmM1syXTtcbiAgICAgIHJldHVybiBbYm91bmRzLndpZHRoICogKHNjYWxlWCA8IDAgLy8gKiBzaW4/XG4gICAgICA/IDEgLSB4IC8gaW5pdGlhbFNoYXBlQm91bmRzLndpZHRoIDogeCAvIGluaXRpYWxTaGFwZUJvdW5kcy53aWR0aCksIGJvdW5kcy5oZWlnaHQgKiAoc2NhbGVZIDwgMCAvLyAqIGNvcz9cbiAgICAgID8gMSAtIHkgLyBpbml0aWFsU2hhcGVCb3VuZHMuaGVpZ2h0IDogeSAvIGluaXRpYWxTaGFwZUJvdW5kcy5oZWlnaHQpLCByXTtcbiAgICB9KTtcbiAgICB2YXIgbmV3Qm91bmRzID0gY29yZS5VdGlscy5nZXRCb3VuZHNGcm9tUG9pbnRzKHNoYXBlLnBvaW50cyk7XG4gICAgdmFyIHBvaW50ID0gY29yZS5WZWMuc3ViKFtib3VuZHMubWluWCwgYm91bmRzLm1pblldLCBbbmV3Qm91bmRzLm1pblgsIG5ld0JvdW5kcy5taW5ZXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvaW50czogcG9pbnRzLFxuICAgICAgcG9pbnQ6IHBvaW50XG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8udHJhbnNmb3JtU2luZ2xlID0gZnVuY3Rpb24gdHJhbnNmb3JtU2luZ2xlKHNoYXBlLCBib3VuZHMsIGluZm8pIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oc2hhcGUsIGJvdW5kcywgaW5mbyk7XG4gIH07XG5cbiAgX3Byb3RvLm9uU2Vzc2lvbkNvbXBsZXRlID0gZnVuY3Rpb24gb25TZXNzaW9uQ29tcGxldGUoc2hhcGUpIHtcbiAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoc2hhcGUpO1xuXG4gICAgdmFyIF9WZWMkc3ViID0gY29yZS5WZWMuc3ViKFtib3VuZHMubWluWCwgYm91bmRzLm1pblldLCBzaGFwZS5wb2ludCksXG4gICAgICAgIHgxID0gX1ZlYyRzdWJbMF0sXG4gICAgICAgIHkxID0gX1ZlYyRzdWJbMV07XG5cbiAgICByZXR1cm4ge1xuICAgICAgcG9pbnRzOiBzaGFwZS5wb2ludHMubWFwKGZ1bmN0aW9uIChfcmVmNCkge1xuICAgICAgICB2YXIgeDAgPSBfcmVmNFswXSxcbiAgICAgICAgICAgIHkwID0gX3JlZjRbMV0sXG4gICAgICAgICAgICBwID0gX3JlZjRbMl07XG4gICAgICAgIHJldHVybiBbeDAgLSB4MSwgeTAgLSB5MSwgcF07XG4gICAgICB9KSxcbiAgICAgIHBvaW50OiBjb3JlLlZlYy5hZGQoc2hhcGUucG9pbnQsIFt4MSwgeTFdKVxuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIERyYXc7XG59KFRMRHJhd1NoYXBlVXRpbCk7XG52YXIgc2ltdWxhdGVQcmVzc3VyZVNldHRpbmdzID0ge1xuICBzaW11bGF0ZVByZXNzdXJlOiB0cnVlXG59O1xudmFyIHJlYWxQcmVzc3VyZVNldHRpbmdzID0ge1xuICBlYXNpbmc6IGZ1bmN0aW9uIGVhc2luZyh0KSB7XG4gICAgcmV0dXJuIHQgKiB0O1xuICB9LFxuICBzaW11bGF0ZVByZXNzdXJlOiBmYWxzZSxcbiAgc3RhcnQ6IHtcbiAgICB0YXBlcjogMVxuICB9LFxuICBlbmQ6IHtcbiAgICB0YXBlcjogMVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRGaWxsUGF0aChzaGFwZSkge1xuICB2YXIgc3R5bGVzID0gZ2V0U2hhcGVTdHlsZShzaGFwZS5zdHlsZSk7XG5cbiAgaWYgKHNoYXBlLnBvaW50cy5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcmV0dXJuIGNvcmUuVXRpbHMuZ2V0U3ZnUGF0aEZyb21TdHJva2UoZ2V0U3Ryb2tlLmdldFN0cm9rZVBvaW50cyhzaGFwZS5wb2ludHMsIHtcbiAgICBzaXplOiAxICsgK3N0eWxlcy5zdHJva2VXaWR0aCAqIDIsXG4gICAgdGhpbm5pbmc6IDAuODUsXG4gICAgZW5kOiB7XG4gICAgICB0YXBlcjogK3N0eWxlcy5zdHJva2VXaWR0aCAqIDIwXG4gICAgfSxcbiAgICBzdGFydDoge1xuICAgICAgdGFwZXI6ICtzdHlsZXMuc3Ryb2tlV2lkdGggKiAyMFxuICAgIH1cbiAgfSkubWFwKGZ1bmN0aW9uIChwdCkge1xuICAgIHJldHVybiBwdC5wb2ludDtcbiAgfSkpO1xufVxuXG5mdW5jdGlvbiBnZXREcmF3U3Ryb2tlUGF0aChzaGFwZSkge1xuICB2YXIgc3R5bGVzID0gZ2V0U2hhcGVTdHlsZShzaGFwZS5zdHlsZSk7XG5cbiAgaWYgKHNoYXBlLnBvaW50cy5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSBzaGFwZS5wb2ludHNbMV1bMl0gPT09IDAuNSA/IHNpbXVsYXRlUHJlc3N1cmVTZXR0aW5ncyA6IHJlYWxQcmVzc3VyZVNldHRpbmdzO1xuICB2YXIgc3Ryb2tlID0gZ2V0U3Ryb2tlX19kZWZhdWx0KHNoYXBlLnBvaW50cywgX2V4dGVuZHMoe1xuICAgIHNpemU6IDEgKyArc3R5bGVzLnN0cm9rZVdpZHRoICogMixcbiAgICB0aGlubmluZzogMC44NSxcbiAgICBlbmQ6IHtcbiAgICAgIHRhcGVyOiArc3R5bGVzLnN0cm9rZVdpZHRoICogMTBcbiAgICB9LFxuICAgIHN0YXJ0OiB7XG4gICAgICB0YXBlcjogK3N0eWxlcy5zdHJva2VXaWR0aCAqIDEwXG4gICAgfVxuICB9LCBvcHRpb25zKSk7XG4gIHJldHVybiBjb3JlLlV0aWxzLmdldFN2Z1BhdGhGcm9tU3Ryb2tlKHN0cm9rZSk7XG59XG5cbmZ1bmN0aW9uIGdldFNvbGlkU3Ryb2tlUGF0aChzaGFwZSkge1xuICB2YXIgcG9pbnRzID0gc2hhcGUucG9pbnRzO1xuICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuICdNIDAgMCBMIDAgMCc7XG4gIGlmIChsZW4gPCAzKSByZXR1cm4gXCJNIFwiICsgcG9pbnRzWzBdWzBdICsgXCIgXCIgKyBwb2ludHNbMF1bMV07XG4gIHBvaW50cyA9IGdldFN0cm9rZS5nZXRTdHJva2VQb2ludHMocG9pbnRzKS5tYXAoZnVuY3Rpb24gKHB0KSB7XG4gICAgcmV0dXJuIHB0LnBvaW50O1xuICB9KTtcbiAgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgdmFyIGQgPSBwb2ludHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIF9yZWY1LCBpLCBhcnIpIHtcbiAgICB2YXIgeDAgPSBfcmVmNVswXSxcbiAgICAgICAgeTAgPSBfcmVmNVsxXTtcblxuICAgIGlmIChpID09PSBsZW4gLSAxKSB7XG4gICAgICBhY2MucHVzaCgnTCcsIHgwLCB5MCk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cblxuICAgIHZhciBfYXJyID0gYXJyW2kgKyAxXSxcbiAgICAgICAgeDEgPSBfYXJyWzBdLFxuICAgICAgICB5MSA9IF9hcnJbMV07XG4gICAgYWNjLnB1c2goeDAudG9GaXhlZCgyKSwgeTAudG9GaXhlZCgyKSwgKCh4MCArIHgxKSAvIDIpLnRvRml4ZWQoMiksICgoeTAgKyB5MSkgLyAyKS50b0ZpeGVkKDIpKTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCBbJ00nLCBwb2ludHNbMF1bMF0sIHBvaW50c1swXVsxXSwgJ1EnXSk7XG4gIHZhciBwYXRoID0gZC5qb2luKCcgJykucmVwbGFjZUFsbCgvKFxcc1swLTldKlxcLlswLTldezJ9KShbMC05XSopXFxiL2csICckMScpO1xuICByZXR1cm4gcGF0aDtcbn1cblxudmFyIEFycm93ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVExEcmF3U2hhcGVVdGlsKSB7XG4gIF9pbmhlcml0c0xvb3NlKEFycm93LCBfVExEcmF3U2hhcGVVdGlsKTtcblxuICBmdW5jdGlvbiBBcnJvdygpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfVExEcmF3U2hhcGVVdGlsLmNhbGwuYXBwbHkoX1RMRHJhd1NoYXBlVXRpbCwgW3RoaXNdLmNvbmNhdChhcmdzKSkgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gZXhwb3J0cy5UTERyYXdTaGFwZVR5cGUuQXJyb3c7XG4gICAgX3RoaXMudG9vbFR5cGUgPSBleHBvcnRzLlRMRHJhd1Rvb2xUeXBlLkhhbmRsZTtcbiAgICBfdGhpcy5jYW5TdHlsZUZpbGwgPSBmYWxzZTtcbiAgICBfdGhpcy5kZWZhdWx0UHJvcHMgPSB7XG4gICAgICBpZDogJ2lkJyxcbiAgICAgIHR5cGU6IGV4cG9ydHMuVExEcmF3U2hhcGVUeXBlLkFycm93LFxuICAgICAgbmFtZTogJ0Fycm93JyxcbiAgICAgIHBhcmVudElkOiAncGFnZScsXG4gICAgICBjaGlsZEluZGV4OiAxLFxuICAgICAgcG9pbnQ6IFswLCAwXSxcbiAgICAgIHJvdGF0aW9uOiAwLFxuICAgICAgYmVuZDogMCxcbiAgICAgIGhhbmRsZXM6IHtcbiAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICBpZDogJ3N0YXJ0JyxcbiAgICAgICAgICBpbmRleDogMCxcbiAgICAgICAgICBwb2ludDogWzAsIDBdLFxuICAgICAgICAgIGNhbkJpbmQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgZW5kOiB7XG4gICAgICAgICAgaWQ6ICdlbmQnLFxuICAgICAgICAgIGluZGV4OiAxLFxuICAgICAgICAgIHBvaW50OiBbMSwgMV0sXG4gICAgICAgICAgY2FuQmluZDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBiZW5kOiB7XG4gICAgICAgICAgaWQ6ICdiZW5kJyxcbiAgICAgICAgICBpbmRleDogMixcbiAgICAgICAgICBwb2ludDogWzAuNSwgMC41XVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVjb3JhdGlvbnM6IHtcbiAgICAgICAgZW5kOiBleHBvcnRzLkRlY29yYXRpb24uQXJyb3dcbiAgICAgIH0sXG4gICAgICBzdHlsZTogX2V4dGVuZHMoe30sIGRlZmF1bHRTdHlsZSwge1xuICAgICAgICBpc0ZpbGxlZDogZmFsc2VcbiAgICAgIH0pXG4gICAgfTtcblxuICAgIF90aGlzLnNob3VsZFJlbmRlciA9IGZ1bmN0aW9uIChwcmV2LCBuZXh0KSB7XG4gICAgICByZXR1cm4gbmV4dC5oYW5kbGVzICE9PSBwcmV2LmhhbmRsZXMgfHwgbmV4dC5zdHlsZSAhPT0gcHJldi5zdHlsZTtcbiAgICB9O1xuXG4gICAgX3RoaXMucmVuZGVyID0gZnVuY3Rpb24gKHNoYXBlLCBfcmVmKSB7XG4gICAgICB2YXIgX3NoYXBlJGRlY29yYXRpb25zLCBfc2hhcGUkZGVjb3JhdGlvbnMyO1xuXG4gICAgICB2YXIgaXNEYXJrTW9kZSA9IF9yZWYuaXNEYXJrTW9kZTtcbiAgICAgIHZhciBiZW5kID0gc2hhcGUuYmVuZCxcbiAgICAgICAgICBoYW5kbGVzID0gc2hhcGUuaGFuZGxlcyxcbiAgICAgICAgICBzdHlsZSA9IHNoYXBlLnN0eWxlO1xuICAgICAgdmFyIHN0YXJ0ID0gaGFuZGxlcy5zdGFydCxcbiAgICAgICAgICBlbmQgPSBoYW5kbGVzLmVuZCxcbiAgICAgICAgICBfYmVuZCA9IGhhbmRsZXMuYmVuZDtcbiAgICAgIHZhciBpc1N0cmFpZ2h0TGluZSA9IGNvcmUuVmVjLmRpc3QoX2JlbmQucG9pbnQsIGNvcmUuVmVjLnJvdW5kKGNvcmUuVmVjLm1lZChzdGFydC5wb2ludCwgZW5kLnBvaW50KSkpIDwgMTtcbiAgICAgIHZhciBpc0RyYXcgPSBzaGFwZS5zdHlsZS5kYXNoID09PSBleHBvcnRzLkRhc2hTdHlsZS5EcmF3O1xuICAgICAgdmFyIHN0eWxlcyA9IGdldFNoYXBlU3R5bGUoc3R5bGUsIGlzRGFya01vZGUpO1xuICAgICAgdmFyIHN0cm9rZVdpZHRoID0gc3R5bGVzLnN0cm9rZVdpZHRoO1xuICAgICAgdmFyIGFycm93RGlzdCA9IGNvcmUuVmVjLmRpc3Qoc3RhcnQucG9pbnQsIGVuZC5wb2ludCk7XG4gICAgICB2YXIgYXJyb3dIZWFkbGVuZ3RoID0gTWF0aC5taW4oYXJyb3dEaXN0IC8gMywgc3Ryb2tlV2lkdGggKiA4KTtcbiAgICAgIHZhciBzaGFmdFBhdGg7XG4gICAgICB2YXIgaW5zZXRTdGFydDtcbiAgICAgIHZhciBpbnNldEVuZDtcblxuICAgICAgaWYgKGlzU3RyYWlnaHRMaW5lKSB7XG4gICAgICAgIHZhciBfc3cgPSBzdHJva2VXaWR0aCAqIChpc0RyYXcgPyAwLjYxOCA6IDEuNjE4KTtcblxuICAgICAgICB2YXIgcGF0aCA9IGlzRHJhdyA/IHJlbmRlckZyZWVoYW5kQXJyb3dTaGFmdChzaGFwZSkgOiAnTScgKyBjb3JlLlZlYy5yb3VuZChzdGFydC5wb2ludCkgKyAnTCcgKyBjb3JlLlZlYy5yb3VuZChlbmQucG9pbnQpO1xuXG4gICAgICAgIHZhciBfZ2V0UGVyZmVjdERhc2hQcm9wcyA9IGdldFBlcmZlY3REYXNoUHJvcHMoYXJyb3dEaXN0LCBfc3csIHNoYXBlLnN0eWxlLmRhc2gsIDIpLFxuICAgICAgICAgICAgc3Ryb2tlRGFzaGFycmF5ID0gX2dldFBlcmZlY3REYXNoUHJvcHMuc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgICAgICAgc3Ryb2tlRGFzaG9mZnNldCA9IF9nZXRQZXJmZWN0RGFzaFByb3BzLnN0cm9rZURhc2hvZmZzZXQ7XG5cbiAgICAgICAgaW5zZXRTdGFydCA9IGNvcmUuVmVjLm51ZGdlKHN0YXJ0LnBvaW50LCBlbmQucG9pbnQsIGFycm93SGVhZGxlbmd0aCk7XG4gICAgICAgIGluc2V0RW5kID0gY29yZS5WZWMubnVkZ2UoZW5kLnBvaW50LCBzdGFydC5wb2ludCwgYXJyb3dIZWFkbGVuZ3RoKTsgLy8gU3RyYWlnaHQgYXJyb3cgcGF0aFxuXG4gICAgICAgIHNoYWZ0UGF0aCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICAgICAgICBkOiBwYXRoLFxuICAgICAgICAgIGZpbGw6IFwibm9uZVwiLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiBNYXRoLm1heCg4LCBzdHJva2VXaWR0aCAqIDIpLFxuICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogXCJub25lXCIsXG4gICAgICAgICAgc3Ryb2tlRGFzaG9mZnNldDogXCJub25lXCIsXG4gICAgICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCJcbiAgICAgICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICAgICAgICBkOiBwYXRoLFxuICAgICAgICAgIGZpbGw6IHN0eWxlcy5zdHJva2UsXG4gICAgICAgICAgc3Ryb2tlOiBzdHlsZXMuc3Ryb2tlLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiBfc3csXG4gICAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiBzdHJva2VEYXNoYXJyYXksXG4gICAgICAgICAgc3Ryb2tlRGFzaG9mZnNldDogc3Ryb2tlRGFzaG9mZnNldCxcbiAgICAgICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY2lyY2xlID0gZ2V0Q3RwKHNoYXBlKTtcblxuICAgICAgICB2YXIgX3N3MiA9IHN0cm9rZVdpZHRoICogKGlzRHJhdyA/IDAuNjE4IDogMS42MTgpO1xuXG4gICAgICAgIHZhciBfcGF0aCA9IGlzRHJhdyA/IHJlbmRlckN1cnZlZEZyZWVoYW5kQXJyb3dTaGFmdChzaGFwZSwgY2lyY2xlKSA6IGdldEFycm93QXJjUGF0aChzdGFydCwgZW5kLCBjaXJjbGUsIGJlbmQpO1xuXG4gICAgICAgIHZhciBhcmNMZW5ndGggPSBjb3JlLlV0aWxzLmdldEFyY0xlbmd0aChbY2lyY2xlWzBdLCBjaXJjbGVbMV1dLCBjaXJjbGVbMl0sIHN0YXJ0LnBvaW50LCBlbmQucG9pbnQpO1xuXG4gICAgICAgIHZhciBfZ2V0UGVyZmVjdERhc2hQcm9wczIgPSBnZXRQZXJmZWN0RGFzaFByb3BzKGFyY0xlbmd0aCAtIDEsIF9zdzIsIHNoYXBlLnN0eWxlLmRhc2gsIDIpLFxuICAgICAgICAgICAgX3N0cm9rZURhc2hhcnJheSA9IF9nZXRQZXJmZWN0RGFzaFByb3BzMi5zdHJva2VEYXNoYXJyYXksXG4gICAgICAgICAgICBfc3Ryb2tlRGFzaG9mZnNldCA9IF9nZXRQZXJmZWN0RGFzaFByb3BzMi5zdHJva2VEYXNob2Zmc2V0O1xuXG4gICAgICAgIHZhciBjZW50ZXIgPSBbY2lyY2xlWzBdLCBjaXJjbGVbMV1dO1xuICAgICAgICB2YXIgcmFkaXVzID0gY2lyY2xlWzJdO1xuICAgICAgICB2YXIgc2EgPSBjb3JlLlZlYy5hbmdsZShjZW50ZXIsIHN0YXJ0LnBvaW50KTtcbiAgICAgICAgdmFyIGVhID0gY29yZS5WZWMuYW5nbGUoY2VudGVyLCBlbmQucG9pbnQpO1xuICAgICAgICB2YXIgdCA9IGFycm93SGVhZGxlbmd0aCAvIE1hdGguYWJzKGFyY0xlbmd0aCk7XG4gICAgICAgIGluc2V0U3RhcnQgPSBjb3JlLlZlYy5udWRnZUF0QW5nbGUoY2VudGVyLCBjb3JlLlV0aWxzLmxlcnBBbmdsZXMoc2EsIGVhLCB0KSwgcmFkaXVzKTtcbiAgICAgICAgaW5zZXRFbmQgPSBjb3JlLlZlYy5udWRnZUF0QW5nbGUoY2VudGVyLCBjb3JlLlV0aWxzLmxlcnBBbmdsZXMoZWEsIHNhLCB0KSwgcmFkaXVzKTsgLy8gQ3VydmVkIGFycm93IHBhdGhcblxuICAgICAgICBzaGFmdFBhdGggPSBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgICAgICAgZDogX3BhdGgsXG4gICAgICAgICAgZmlsbDogXCJub25lXCIsXG4gICAgICAgICAgc3Ryb2tlOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IE1hdGgubWF4KDgsIHN0cm9rZVdpZHRoICogMiksXG4gICAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiBcIm5vbmVcIixcbiAgICAgICAgICBzdHJva2VEYXNob2Zmc2V0OiBcIm5vbmVcIixcbiAgICAgICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxuICAgICAgICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgICAgICAgIGQ6IF9wYXRoLFxuICAgICAgICAgIGZpbGw6IGlzRHJhdyA/IHN0eWxlcy5zdHJva2UgOiAnbm9uZScsXG4gICAgICAgICAgc3Ryb2tlOiBzdHlsZXMuc3Ryb2tlLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiBfc3cyLFxuICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogX3N0cm9rZURhc2hhcnJheSxcbiAgICAgICAgICBzdHJva2VEYXNob2Zmc2V0OiBfc3Ryb2tlRGFzaG9mZnNldCxcbiAgICAgICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdyA9IHN0cm9rZVdpZHRoICogMS42MTg7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIiwge1xuICAgICAgICBwb2ludGVyRXZlbnRzOiBcImFsbFwiXG4gICAgICB9LCBzaGFmdFBhdGgsICgoX3NoYXBlJGRlY29yYXRpb25zID0gc2hhcGUuZGVjb3JhdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfc2hhcGUkZGVjb3JhdGlvbnMuc3RhcnQpID09PSBleHBvcnRzLkRlY29yYXRpb24uQXJyb3cgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgICAgICBkOiBnZXRBcnJvd0hlYWRQYXRoKHNoYXBlLCBzdGFydC5wb2ludCwgaW5zZXRTdGFydCksXG4gICAgICAgIGZpbGw6IFwibm9uZVwiLFxuICAgICAgICBzdHJva2U6IHN0eWxlcy5zdHJva2UsXG4gICAgICAgIHN0cm9rZVdpZHRoOiBzdyxcbiAgICAgICAgc3Ryb2tlRGFzaG9mZnNldDogXCJub25lXCIsXG4gICAgICAgIHN0cm9rZURhc2hhcnJheTogXCJub25lXCIsXG4gICAgICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIixcbiAgICAgICAgcG9pbnRlckV2ZW50czogXCJzdHJva2VcIlxuICAgICAgfSksICgoX3NoYXBlJGRlY29yYXRpb25zMiA9IHNoYXBlLmRlY29yYXRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX3NoYXBlJGRlY29yYXRpb25zMi5lbmQpID09PSBleHBvcnRzLkRlY29yYXRpb24uQXJyb3cgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgICAgICBkOiBnZXRBcnJvd0hlYWRQYXRoKHNoYXBlLCBlbmQucG9pbnQsIGluc2V0RW5kKSxcbiAgICAgICAgZmlsbDogXCJub25lXCIsXG4gICAgICAgIHN0cm9rZTogc3R5bGVzLnN0cm9rZSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHN3LFxuICAgICAgICBzdHJva2VEYXNob2Zmc2V0OiBcIm5vbmVcIixcbiAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiBcIm5vbmVcIixcbiAgICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiBcInN0cm9rZVwiXG4gICAgICB9KSk7XG4gICAgfTtcblxuICAgIF90aGlzLmdldEJvdW5kcyA9IGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgdmFyIGJvdW5kcyA9IGNvcmUuVXRpbHMuZ2V0RnJvbUNhY2hlKF90aGlzLmJvdW5kc0NhY2hlLCBzaGFwZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3NoYXBlJGhhbmRsZXMgPSBzaGFwZS5oYW5kbGVzLFxuICAgICAgICAgICAgc3RhcnQgPSBfc2hhcGUkaGFuZGxlcy5zdGFydCxcbiAgICAgICAgICAgIGJlbmQgPSBfc2hhcGUkaGFuZGxlcy5iZW5kLFxuICAgICAgICAgICAgZW5kID0gX3NoYXBlJGhhbmRsZXMuZW5kO1xuICAgICAgICByZXR1cm4gY29yZS5VdGlscy5nZXRCb3VuZHNGcm9tUG9pbnRzKFtzdGFydC5wb2ludCwgYmVuZC5wb2ludCwgZW5kLnBvaW50XSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb3JlLlV0aWxzLnRyYW5zbGF0ZUJvdW5kcyhib3VuZHMsIHNoYXBlLnBvaW50KTtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0Um90YXRlZEJvdW5kcyA9IGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgdmFyIF9zaGFwZSRoYW5kbGVzMiA9IHNoYXBlLmhhbmRsZXMsXG4gICAgICAgICAgc3RhcnQgPSBfc2hhcGUkaGFuZGxlczIuc3RhcnQsXG4gICAgICAgICAgYmVuZCA9IF9zaGFwZSRoYW5kbGVzMi5iZW5kLFxuICAgICAgICAgIGVuZCA9IF9zaGFwZSRoYW5kbGVzMi5lbmQ7XG4gICAgICByZXR1cm4gY29yZS5VdGlscy50cmFuc2xhdGVCb3VuZHMoY29yZS5VdGlscy5nZXRCb3VuZHNGcm9tUG9pbnRzKFtzdGFydC5wb2ludCwgYmVuZC5wb2ludCwgZW5kLnBvaW50XSwgc2hhcGUucm90YXRpb24pLCBzaGFwZS5wb2ludCk7XG4gICAgfTtcblxuICAgIF90aGlzLmdldENlbnRlciA9IGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgdmFyIF9zaGFwZSRoYW5kbGVzMyA9IHNoYXBlLmhhbmRsZXMsXG4gICAgICAgICAgc3RhcnQgPSBfc2hhcGUkaGFuZGxlczMuc3RhcnQsXG4gICAgICAgICAgZW5kID0gX3NoYXBlJGhhbmRsZXMzLmVuZDtcbiAgICAgIHJldHVybiBjb3JlLlZlYy5hZGQoc2hhcGUucG9pbnQsIGNvcmUuVmVjLm1lZChzdGFydC5wb2ludCwgZW5kLnBvaW50KSk7XG4gICAgfTtcblxuICAgIF90aGlzLmhpdFRlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGl0VGVzdEJvdW5kcyA9IGZ1bmN0aW9uIChzaGFwZSwgYnJ1c2hCb3VuZHMpIHtcbiAgICAgIHZhciBfc2hhcGUkaGFuZGxlczQgPSBzaGFwZS5oYW5kbGVzLFxuICAgICAgICAgIHN0YXJ0ID0gX3NoYXBlJGhhbmRsZXM0LnN0YXJ0LFxuICAgICAgICAgIGVuZCA9IF9zaGFwZSRoYW5kbGVzNC5lbmQsXG4gICAgICAgICAgYmVuZCA9IF9zaGFwZSRoYW5kbGVzNC5iZW5kO1xuICAgICAgdmFyIHNwID0gY29yZS5WZWMuYWRkKHNoYXBlLnBvaW50LCBzdGFydC5wb2ludCk7XG4gICAgICB2YXIgZXAgPSBjb3JlLlZlYy5hZGQoc2hhcGUucG9pbnQsIGVuZC5wb2ludCk7XG5cbiAgICAgIGlmIChjb3JlLlV0aWxzLnBvaW50SW5Cb3VuZHMoc3AsIGJydXNoQm91bmRzKSB8fCBjb3JlLlV0aWxzLnBvaW50SW5Cb3VuZHMoZXAsIGJydXNoQm91bmRzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvcmUuVmVjLmlzRXF1YWwoY29yZS5WZWMubWVkKHN0YXJ0LnBvaW50LCBlbmQucG9pbnQpLCBiZW5kLnBvaW50KSkge1xuICAgICAgICByZXR1cm4gY29yZS5JbnRlcnNlY3QubGluZVNlZ21lbnQuYm91bmRzKHNwLCBlcCwgYnJ1c2hCb3VuZHMpLmxlbmd0aCA+IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2dldEN0cCA9IGdldEN0cChzaGFwZSksXG4gICAgICAgICAgICBjeCA9IF9nZXRDdHBbMF0sXG4gICAgICAgICAgICBjeSA9IF9nZXRDdHBbMV0sXG4gICAgICAgICAgICByID0gX2dldEN0cFsyXTtcblxuICAgICAgICB2YXIgY3AgPSBjb3JlLlZlYy5hZGQoc2hhcGUucG9pbnQsIFtjeCwgY3ldKTtcbiAgICAgICAgcmV0dXJuIGNvcmUuSW50ZXJzZWN0LmFyYy5ib3VuZHMoY3AsIHIsIHNwLCBlcCwgYnJ1c2hCb3VuZHMpLmxlbmd0aCA+IDA7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChfc2hhcGUsIGJvdW5kcywgX3JlZjIpIHtcbiAgICAgIHZhciBpbml0aWFsU2hhcGUgPSBfcmVmMi5pbml0aWFsU2hhcGUsXG4gICAgICAgICAgc2NhbGVYID0gX3JlZjIuc2NhbGVYLFxuICAgICAgICAgIHNjYWxlWSA9IF9yZWYyLnNjYWxlWTtcblxuICAgICAgdmFyIGluaXRpYWxTaGFwZUJvdW5kcyA9IF90aGlzLmdldEJvdW5kcyhpbml0aWFsU2hhcGUpO1xuXG4gICAgICB2YXIgaGFuZGxlcyA9IFsnc3RhcnQnLCAnZW5kJ107XG5cbiAgICAgIHZhciBuZXh0SGFuZGxlcyA9IF9leHRlbmRzKHt9LCBpbml0aWFsU2hhcGUuaGFuZGxlcyk7XG5cbiAgICAgIGhhbmRsZXMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlKSB7XG4gICAgICAgIHZhciBfbmV4dEhhbmRsZXMkaGFuZGxlJHAgPSBuZXh0SGFuZGxlc1toYW5kbGVdLnBvaW50LFxuICAgICAgICAgICAgeCA9IF9uZXh0SGFuZGxlcyRoYW5kbGUkcFswXSxcbiAgICAgICAgICAgIHkgPSBfbmV4dEhhbmRsZXMkaGFuZGxlJHBbMV07XG4gICAgICAgIHZhciBudyA9IHggLyBpbml0aWFsU2hhcGVCb3VuZHMud2lkdGg7XG4gICAgICAgIHZhciBuaCA9IHkgLyBpbml0aWFsU2hhcGVCb3VuZHMuaGVpZ2h0O1xuICAgICAgICBuZXh0SGFuZGxlc1toYW5kbGVdID0gX2V4dGVuZHMoe30sIG5leHRIYW5kbGVzW2hhbmRsZV0sIHtcbiAgICAgICAgICBwb2ludDogW2JvdW5kcy53aWR0aCAqIChzY2FsZVggPCAwID8gMSAtIG53IDogbncpLCBib3VuZHMuaGVpZ2h0ICogKHNjYWxlWSA8IDAgPyAxIC0gbmggOiBuaCldXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB2YXIgc3RhcnQgPSBuZXh0SGFuZGxlcy5zdGFydCxcbiAgICAgICAgICBiZW5kID0gbmV4dEhhbmRsZXMuYmVuZCxcbiAgICAgICAgICBlbmQgPSBuZXh0SGFuZGxlcy5lbmQ7XG4gICAgICB2YXIgZGlzdCA9IGNvcmUuVmVjLmRpc3Qoc3RhcnQucG9pbnQsIGVuZC5wb2ludCk7XG4gICAgICB2YXIgbWlkUG9pbnQgPSBjb3JlLlZlYy5tZWQoc3RhcnQucG9pbnQsIGVuZC5wb2ludCk7XG4gICAgICB2YXIgYmVuZERpc3QgPSBkaXN0IC8gMiAqIGluaXRpYWxTaGFwZS5iZW5kO1xuICAgICAgdmFyIHUgPSBjb3JlLlZlYy51bmkoY29yZS5WZWMudmVjKHN0YXJ0LnBvaW50LCBlbmQucG9pbnQpKTtcbiAgICAgIHZhciBwb2ludCA9IGNvcmUuVmVjLmFkZChtaWRQb2ludCwgY29yZS5WZWMubXVsKGNvcmUuVmVjLnBlcih1KSwgYmVuZERpc3QpKTtcbiAgICAgIG5leHRIYW5kbGVzWydiZW5kJ10gPSBfZXh0ZW5kcyh7fSwgYmVuZCwge1xuICAgICAgICBwb2ludDogTWF0aC5hYnMoYmVuZERpc3QpIDwgMTAgPyBtaWRQb2ludCA6IHBvaW50XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvaW50OiBbYm91bmRzLm1pblgsIGJvdW5kcy5taW5ZXSxcbiAgICAgICAgaGFuZGxlczogbmV4dEhhbmRsZXNcbiAgICAgIH07XG4gICAgfTtcblxuICAgIF90aGlzLm9uRG91YmxlQ2xpY2tIYW5kbGUgPSBmdW5jdGlvbiAoc2hhcGUsIGhhbmRsZSkge1xuICAgICAgc3dpdGNoIChoYW5kbGUpIHtcbiAgICAgICAgY2FzZSAnYmVuZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgYmVuZDogMCxcbiAgICAgICAgICAgICAgaGFuZGxlczogX2V4dGVuZHMoe30sIHNoYXBlLmhhbmRsZXMsIHtcbiAgICAgICAgICAgICAgICBiZW5kOiBfZXh0ZW5kcyh7fSwgc2hhcGUuaGFuZGxlcy5iZW5kLCB7XG4gICAgICAgICAgICAgICAgICBwb2ludDogZ2V0QmVuZFBvaW50KHNoYXBlLmhhbmRsZXMsIHNoYXBlLmJlbmQpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX3NoYXBlJGRlY29yYXRpb25zMztcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZGVjb3JhdGlvbnM6IF9leHRlbmRzKHt9LCBzaGFwZS5kZWNvcmF0aW9ucywge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiAoX3NoYXBlJGRlY29yYXRpb25zMyA9IHNoYXBlLmRlY29yYXRpb25zKSAhPSBudWxsICYmIF9zaGFwZSRkZWNvcmF0aW9uczMuc3RhcnQgPyB1bmRlZmluZWQgOiBleHBvcnRzLkRlY29yYXRpb24uQXJyb3dcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9zaGFwZSRkZWNvcmF0aW9uczQ7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRlY29yYXRpb25zOiBfZXh0ZW5kcyh7fSwgc2hhcGUuZGVjb3JhdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBlbmQ6IChfc2hhcGUkZGVjb3JhdGlvbnM0ID0gc2hhcGUuZGVjb3JhdGlvbnMpICE9IG51bGwgJiYgX3NoYXBlJGRlY29yYXRpb25zNC5lbmQgPyB1bmRlZmluZWQgOiBleHBvcnRzLkRlY29yYXRpb24uQXJyb3dcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyk7XG4gICAgfTtcblxuICAgIF90aGlzLm9uSGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gKHNoYXBlLCBoYW5kbGVzLCBfcmVmMykge1xuICAgICAgdmFyIHNoaWZ0S2V5ID0gX3JlZjMuc2hpZnRLZXk7XG4gICAgICB2YXIgbmV4dEhhbmRsZXMgPSBjb3JlLlV0aWxzLmRlZXBNZXJnZShzaGFwZS5oYW5kbGVzLCBoYW5kbGVzKTtcbiAgICAgIHZhciBuZXh0QmVuZCA9IHNoYXBlLmJlbmQ7IC8vIElmIHRoZSB1c2VyIGlzIGhvbGRpbmcgc2hpZnQsIHdlIHdhbnQgdG8gc25hcCB0aGUgaGFuZGxlcyB0byBhbmdsZXNcblxuICAgICAgZm9yICh2YXIgaWQgaW4gaGFuZGxlcykge1xuICAgICAgICBpZiAoKGlkID09PSAnc3RhcnQnIHx8IGlkID09PSAnZW5kJykgJiYgc2hpZnRLZXkpIHtcbiAgICAgICAgICB2YXIgX2V4dGVuZHMyO1xuXG4gICAgICAgICAgdmFyIHBvaW50ID0gaGFuZGxlc1tpZF0ucG9pbnQ7XG4gICAgICAgICAgdmFyIG90aGVyID0gaWQgPT09ICdzdGFydCcgPyBzaGFwZS5oYW5kbGVzLmVuZCA6IHNoYXBlLmhhbmRsZXMuc3RhcnQ7XG4gICAgICAgICAgdmFyIGFuZ2xlID0gY29yZS5WZWMuYW5nbGUob3RoZXIucG9pbnQsIHBvaW50KTtcbiAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBjb3JlLlZlYy5kaXN0KG90aGVyLnBvaW50LCBwb2ludCk7XG4gICAgICAgICAgdmFyIG5ld0FuZ2xlID0gY29yZS5VdGlscy5jbGFtcFRvUm90YXRpb25Ub1NlZ21lbnRzKGFuZ2xlLCAyNCk7XG4gICAgICAgICAgbmV4dEhhbmRsZXMgPSBfZXh0ZW5kcyh7fSwgbmV4dEhhbmRsZXMsIChfZXh0ZW5kczIgPSB7fSwgX2V4dGVuZHMyW2lkXSA9IF9leHRlbmRzKHt9LCBuZXh0SGFuZGxlc1tpZF0sIHtcbiAgICAgICAgICAgIHBvaW50OiBjb3JlLlZlYy5udWRnZUF0QW5nbGUob3RoZXIucG9pbnQsIG5ld0FuZ2xlLCBkaXN0YW5jZSlcbiAgICAgICAgICB9KSwgX2V4dGVuZHMyKSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gSWYgdGhlIHVzZXIgaXMgbW92aW5nIHRoZSBiZW5kIGhhbmRsZSwgd2Ugd2FudCB0byBtb3ZlIHRoZSBiZW5kIHBvaW50XG5cblxuICAgICAgaWYgKCdiZW5kJyBpbiBoYW5kbGVzKSB7XG4gICAgICAgIHZhciBfbmV4dEhhbmRsZXMgPSBuZXh0SGFuZGxlcyxcbiAgICAgICAgICAgIHN0YXJ0ID0gX25leHRIYW5kbGVzLnN0YXJ0LFxuICAgICAgICAgICAgZW5kID0gX25leHRIYW5kbGVzLmVuZCxcbiAgICAgICAgICAgIGJlbmQgPSBfbmV4dEhhbmRsZXMuYmVuZDtcblxuICAgICAgICB2YXIgX2Rpc3RhbmNlID0gY29yZS5WZWMuZGlzdChzdGFydC5wb2ludCwgZW5kLnBvaW50KTtcblxuICAgICAgICB2YXIgbWlkUG9pbnQgPSBjb3JlLlZlYy5tZWQoc3RhcnQucG9pbnQsIGVuZC5wb2ludCk7XG5cbiAgICAgICAgdmFyIF9hbmdsZSA9IGNvcmUuVmVjLmFuZ2xlKHN0YXJ0LnBvaW50LCBlbmQucG9pbnQpO1xuXG4gICAgICAgIHZhciB1ID0gY29yZS5WZWMudW5pKGNvcmUuVmVjLnZlYyhzdGFydC5wb2ludCwgZW5kLnBvaW50KSk7IC8vIENyZWF0ZSBhIGxpbmUgc2VnbWVudCBwZXJlbmRpY3VsYXIgdG8gdGhlIGxpbmUgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludHNcblxuICAgICAgICB2YXIgYXAgPSBjb3JlLlZlYy5hZGQobWlkUG9pbnQsIGNvcmUuVmVjLm11bChjb3JlLlZlYy5wZXIodSksIF9kaXN0YW5jZSAvIDIpKTtcbiAgICAgICAgdmFyIGJwID0gY29yZS5WZWMuc3ViKG1pZFBvaW50LCBjb3JlLlZlYy5tdWwoY29yZS5WZWMucGVyKHUpLCBfZGlzdGFuY2UgLyAyKSk7XG4gICAgICAgIHZhciBiZW5kUG9pbnQgPSBjb3JlLlZlYy5uZWFyZXN0UG9pbnRPbkxpbmVTZWdtZW50KGFwLCBicCwgYmVuZC5wb2ludCwgdHJ1ZSk7IC8vIEZpbmQgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIG1pZHBvaW50IGFuZCB0aGUgbmVhcmVzdCBwb2ludCBvbiB0aGVcbiAgICAgICAgLy8gbGluZSBzZWdtZW50IHRvIHRoZSBiZW5kIGhhbmRsZSdzIGRyYWdnZWQgcG9pbnRcblxuICAgICAgICB2YXIgYmVuZERpc3QgPSBjb3JlLlZlYy5kaXN0KG1pZFBvaW50LCBiZW5kUG9pbnQpOyAvLyBUaGUgc2hhcGUncyBcImJlbmRcIiBpcyB0aGUgcmF0aW8gb2YgdGhlIGJlbmQgdG8gdGhlIGRpc3RhbmNlIGJldHdlZW5cbiAgICAgICAgLy8gdGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnRzLiBJZiB0aGUgYmVuZCBpcyBiZWxvdyBhIGNlcnRhaW4gYW1vdW50LCB0aGVcbiAgICAgICAgLy8gYmVuZCBzaG91bGQgYmUgemVyby5cblxuICAgICAgICBuZXh0QmVuZCA9IGNvcmUuVXRpbHMuY2xhbXAoYmVuZERpc3QgLyAoX2Rpc3RhbmNlIC8gMiksIC0wLjk5LCAwLjk5KTsgLy8gSWYgdGhlIHBvaW50IGlzIHRvIHRoZSBsZWZ0IG9mIHRoZSBsaW5lIHNlZ21lbnQsIHdlIG1ha2UgdGhlIGJlbmRcbiAgICAgICAgLy8gbmVnYXRpdmUsIG90aGVyd2lzZSBpdCdzIHBvc2l0aXZlLlxuXG4gICAgICAgIHZhciBhbmdsZVRvQmVuZCA9IGNvcmUuVmVjLmFuZ2xlKHN0YXJ0LnBvaW50LCBiZW5kUG9pbnQpO1xuXG4gICAgICAgIGlmIChjb3JlLlV0aWxzLmlzQW5nbGVCZXR3ZWVuKF9hbmdsZSwgX2FuZ2xlICsgTWF0aC5QSSwgYW5nbGVUb0JlbmQpKSB7XG4gICAgICAgICAgbmV4dEJlbmQgKj0gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV4dEhhbmRsZXMgPSBfZXh0ZW5kcyh7fSwgbmV4dEhhbmRsZXMsIHtcbiAgICAgICAgc3RhcnQ6IF9leHRlbmRzKHt9LCBuZXh0SGFuZGxlcy5zdGFydCwge1xuICAgICAgICAgIHBvaW50OiBjb3JlLlZlYy5yb3VuZChuZXh0SGFuZGxlcy5zdGFydC5wb2ludClcbiAgICAgICAgfSksXG4gICAgICAgIGVuZDogX2V4dGVuZHMoe30sIG5leHRIYW5kbGVzLmVuZCwge1xuICAgICAgICAgIHBvaW50OiBjb3JlLlZlYy5yb3VuZChuZXh0SGFuZGxlcy5lbmQucG9pbnQpXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJlbmQ6IG5leHRCZW5kLFxuICAgICAgICBoYW5kbGVzOiBfZXh0ZW5kcyh7fSwgbmV4dEhhbmRsZXMsIHtcbiAgICAgICAgICBiZW5kOiBfZXh0ZW5kcyh7fSwgbmV4dEhhbmRsZXMuYmVuZCwge1xuICAgICAgICAgICAgcG9pbnQ6IGdldEJlbmRQb2ludChuZXh0SGFuZGxlcywgbmV4dEJlbmQpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfTtcblxuICAgIF90aGlzLm9uU2Vzc2lvbkNvbXBsZXRlID0gZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICB2YXIgYm91bmRzID0gX3RoaXMuZ2V0Qm91bmRzKHNoYXBlKTtcblxuICAgICAgdmFyIG9mZnNldCA9IGNvcmUuVmVjLnN1YihbYm91bmRzLm1pblgsIGJvdW5kcy5taW5ZXSwgc2hhcGUucG9pbnQpO1xuICAgICAgdmFyIF9zaGFwZSRoYW5kbGVzNSA9IHNoYXBlLmhhbmRsZXMsXG4gICAgICAgICAgc3RhcnQgPSBfc2hhcGUkaGFuZGxlczUuc3RhcnQsXG4gICAgICAgICAgZW5kID0gX3NoYXBlJGhhbmRsZXM1LmVuZCxcbiAgICAgICAgICBiZW5kID0gX3NoYXBlJGhhbmRsZXM1LmJlbmQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb2ludDogY29yZS5WZWMuYWRkKHNoYXBlLnBvaW50LCBvZmZzZXQpLFxuICAgICAgICBoYW5kbGVzOiB7XG4gICAgICAgICAgc3RhcnQ6IF9leHRlbmRzKHt9LCBzdGFydCwge1xuICAgICAgICAgICAgcG9pbnQ6IGNvcmUuVmVjLnJvdW5kKGNvcmUuVmVjLnN1YihzdGFydC5wb2ludCwgb2Zmc2V0KSlcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBlbmQ6IF9leHRlbmRzKHt9LCBlbmQsIHtcbiAgICAgICAgICAgIHBvaW50OiBjb3JlLlZlYy5yb3VuZChjb3JlLlZlYy5zdWIoZW5kLnBvaW50LCBvZmZzZXQpKVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGJlbmQ6IF9leHRlbmRzKHt9LCBiZW5kLCB7XG4gICAgICAgICAgICBwb2ludDogY29yZS5WZWMucm91bmQoY29yZS5WZWMuc3ViKGJlbmQucG9pbnQsIG9mZnNldCkpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIEFycm93O1xufShUTERyYXdTaGFwZVV0aWwpO1xuXG5mdW5jdGlvbiBnZXRBcnJvd0FyY1BhdGgoc3RhcnQsIGVuZCwgY2lyY2xlLCBiZW5kKSB7XG4gIHJldHVybiBbJ00nLCBzdGFydC5wb2ludFswXSwgc3RhcnQucG9pbnRbMV0sICdBJywgY2lyY2xlWzJdLCBjaXJjbGVbMl0sIDAsIDAsIGJlbmQgPCAwID8gMCA6IDEsIGVuZC5wb2ludFswXSwgZW5kLnBvaW50WzFdXS5qb2luKCcgJyk7XG59XG5cbmZ1bmN0aW9uIGdldEJlbmRQb2ludChoYW5kbGVzLCBiZW5kKSB7XG4gIHZhciBzdGFydCA9IGhhbmRsZXMuc3RhcnQsXG4gICAgICBlbmQgPSBoYW5kbGVzLmVuZDtcbiAgdmFyIGRpc3QgPSBjb3JlLlZlYy5kaXN0KHN0YXJ0LnBvaW50LCBlbmQucG9pbnQpO1xuICB2YXIgbWlkUG9pbnQgPSBjb3JlLlZlYy5tZWQoc3RhcnQucG9pbnQsIGVuZC5wb2ludCk7XG4gIHZhciBiZW5kRGlzdCA9IGRpc3QgLyAyICogYmVuZDtcbiAgdmFyIHUgPSBjb3JlLlZlYy51bmkoY29yZS5WZWMudmVjKHN0YXJ0LnBvaW50LCBlbmQucG9pbnQpKTtcbiAgdmFyIHBvaW50ID0gY29yZS5WZWMucm91bmQoTWF0aC5hYnMoYmVuZERpc3QpIDwgMTAgPyBtaWRQb2ludCA6IGNvcmUuVmVjLmFkZChtaWRQb2ludCwgY29yZS5WZWMubXVsKGNvcmUuVmVjLnBlcih1KSwgYmVuZERpc3QpKSk7XG4gIHJldHVybiBwb2ludDtcbn1cblxuZnVuY3Rpb24gcmVuZGVyRnJlZWhhbmRBcnJvd1NoYWZ0KHNoYXBlKSB7XG4gIHZhciBzdHlsZSA9IHNoYXBlLnN0eWxlLFxuICAgICAgaWQgPSBzaGFwZS5pZDtcbiAgdmFyIF9zaGFwZSRoYW5kbGVzNiA9IHNoYXBlLmhhbmRsZXMsXG4gICAgICBzdGFydCA9IF9zaGFwZSRoYW5kbGVzNi5zdGFydCxcbiAgICAgIGVuZCA9IF9zaGFwZSRoYW5kbGVzNi5lbmQ7XG4gIHZhciBnZXRSYW5kb20gPSBjb3JlLlV0aWxzLnJuZyhpZCk7XG4gIHZhciBzdHJva2VXaWR0aCA9ICtnZXRTaGFwZVN0eWxlKHN0eWxlKS5zdHJva2VXaWR0aCAqIDI7XG4gIHZhciBzdCA9IE1hdGguYWJzKGdldFJhbmRvbSgpKTtcbiAgdmFyIHN0cm9rZSA9IGdldFN0cm9rZV9fZGVmYXVsdChbXS5jb25jYXQoY29yZS5WZWMucG9pbnRzQmV0d2VlbihzdGFydC5wb2ludCwgZW5kLnBvaW50KSwgW2VuZC5wb2ludCwgZW5kLnBvaW50LCBlbmQucG9pbnQsIGVuZC5wb2ludF0pLCB7XG4gICAgc2l6ZTogc3Ryb2tlV2lkdGggLyAyLFxuICAgIHRoaW5uaW5nOiAwLjUgKyBnZXRSYW5kb20oKSAqIDAuMyxcbiAgICBlYXNpbmc6IGZ1bmN0aW9uIGVhc2luZyh0KSB7XG4gICAgICByZXR1cm4gdCAqIHQ7XG4gICAgfSxcbiAgICBlbmQ6IHtcbiAgICAgIHRhcGVyOiAxXG4gICAgfSxcbiAgICBzdGFydDoge1xuICAgICAgdGFwZXI6IDEgKyAzMiAqIChzdCAqIHN0ICogc3QpXG4gICAgfSxcbiAgICBzaW11bGF0ZVByZXNzdXJlOiB0cnVlLFxuICAgIGxhc3Q6IHRydWVcbiAgfSk7XG4gIHZhciBwYXRoID0gY29yZS5VdGlscy5nZXRTdmdQYXRoRnJvbVN0cm9rZShzdHJva2UpO1xuICByZXR1cm4gcGF0aDtcbn1cblxuZnVuY3Rpb24gcmVuZGVyQ3VydmVkRnJlZWhhbmRBcnJvd1NoYWZ0KHNoYXBlLCBjaXJjbGUpIHtcbiAgdmFyIF9zaGFwZSRkZWNvcmF0aW9uczUsIF9zaGFwZSRkZWNvcmF0aW9uczY7XG5cbiAgdmFyIHN0eWxlID0gc2hhcGUuc3R5bGUsXG4gICAgICBpZCA9IHNoYXBlLmlkO1xuICB2YXIgX3NoYXBlJGhhbmRsZXM3ID0gc2hhcGUuaGFuZGxlcyxcbiAgICAgIHN0YXJ0ID0gX3NoYXBlJGhhbmRsZXM3LnN0YXJ0LFxuICAgICAgZW5kID0gX3NoYXBlJGhhbmRsZXM3LmVuZDtcbiAgdmFyIGdldFJhbmRvbSA9IGNvcmUuVXRpbHMucm5nKGlkKTtcbiAgdmFyIHN0cm9rZVdpZHRoID0gK2dldFNoYXBlU3R5bGUoc3R5bGUpLnN0cm9rZVdpZHRoICogMjtcbiAgdmFyIHN0ID0gTWF0aC5hYnMoZ2V0UmFuZG9tKCkpO1xuICB2YXIgY2VudGVyID0gW2NpcmNsZVswXSwgY2lyY2xlWzFdXTtcbiAgdmFyIHJhZGl1cyA9IGNpcmNsZVsyXTtcbiAgdmFyIHN0YXJ0QW5nbGUgPSBjb3JlLlZlYy5hbmdsZShjZW50ZXIsIHN0YXJ0LnBvaW50KTtcbiAgdmFyIGVuZEFuZ2xlID0gY29yZS5WZWMuYW5nbGUoY2VudGVyLCBlbmQucG9pbnQpO1xuICB2YXIgcG9pbnRzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyMTsgaSsrKSB7XG4gICAgdmFyIHQgPSBpIC8gMjA7XG4gICAgdmFyIGFuZ2xlID0gY29yZS5VdGlscy5sZXJwQW5nbGVzKHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCB0KTtcbiAgICBwb2ludHMucHVzaChjb3JlLlZlYy5yb3VuZChjb3JlLlZlYy5udWRnZUF0QW5nbGUoY2VudGVyLCBhbmdsZSwgcmFkaXVzKSkpO1xuICB9XG5cbiAgdmFyIHN0cm9rZSA9IGdldFN0cm9rZV9fZGVmYXVsdChbXS5jb25jYXQocG9pbnRzLCBbZW5kLnBvaW50LCBlbmQucG9pbnRdKSwge1xuICAgIHNpemU6IHN0cm9rZVdpZHRoIC8gMixcbiAgICB0aGlubmluZzogMC41ICsgZ2V0UmFuZG9tKCkgKiAwLjMsXG4gICAgZWFzaW5nOiBmdW5jdGlvbiBlYXNpbmcodCkge1xuICAgICAgcmV0dXJuIHQgKiB0O1xuICAgIH0sXG4gICAgZW5kOiB7XG4gICAgICB0YXBlcjogKF9zaGFwZSRkZWNvcmF0aW9uczUgPSBzaGFwZS5kZWNvcmF0aW9ucykgIT0gbnVsbCAmJiBfc2hhcGUkZGVjb3JhdGlvbnM1LmVuZCA/IDEgOiAxICsgc3Ryb2tlV2lkdGggKiA1ICogKHN0ICogc3QgKiBzdClcbiAgICB9LFxuICAgIHN0YXJ0OiB7XG4gICAgICB0YXBlcjogKF9zaGFwZSRkZWNvcmF0aW9uczYgPSBzaGFwZS5kZWNvcmF0aW9ucykgIT0gbnVsbCAmJiBfc2hhcGUkZGVjb3JhdGlvbnM2LnN0YXJ0ID8gMSA6IDEgKyBzdHJva2VXaWR0aCAqIDUgKiAoc3QgKiBzdCAqIHN0KVxuICAgIH0sXG4gICAgc2ltdWxhdGVQcmVzc3VyZTogdHJ1ZSxcbiAgICBzdHJlYW1saW5lOiAwLjAxLFxuICAgIGxhc3Q6IHRydWVcbiAgfSk7XG4gIHZhciBwYXRoID0gY29yZS5VdGlscy5nZXRTdmdQYXRoRnJvbVN0cm9rZShzdHJva2UpO1xuICByZXR1cm4gcGF0aDtcbn1cblxuZnVuY3Rpb24gZ2V0QXJyb3dIZWFkUGF0aChzaGFwZSwgcG9pbnQsIGluc2V0KSB7XG4gIHZhciBfZ2V0QXJyb3dIZWFkUG9pbnRzID0gZ2V0QXJyb3dIZWFkUG9pbnRzKHNoYXBlLCBwb2ludCwgaW5zZXQpLFxuICAgICAgbGVmdCA9IF9nZXRBcnJvd0hlYWRQb2ludHMubGVmdCxcbiAgICAgIHJpZ2h0ID0gX2dldEFycm93SGVhZFBvaW50cy5yaWdodDtcblxuICByZXR1cm4gWydNJywgbGVmdCwgJ0wnLCBwb2ludCwgcmlnaHRdLmpvaW4oJyAnKTtcbn1cblxuZnVuY3Rpb24gZ2V0QXJyb3dIZWFkUG9pbnRzKHNoYXBlLCBwb2ludCwgaW5zZXQpIHtcbiAgLy8gVXNlIHRoZSBzaGFwZSdzIHJhbmRvbSBzZWVkIHRvIGNyZWF0ZSBtaW5vciBvZmZzZXRzIGZvciB0aGUgYW5nbGVzXG4gIHZhciBnZXRSYW5kb20gPSBjb3JlLlV0aWxzLnJuZyhzaGFwZS5pZCk7XG4gIHJldHVybiB7XG4gICAgbGVmdDogY29yZS5WZWMucm90V2l0aChpbnNldCwgcG9pbnQsIE1hdGguUEkgLyA2ICsgTWF0aC5QSSAvIDEyICogZ2V0UmFuZG9tKCkpLFxuICAgIHJpZ2h0OiBjb3JlLlZlYy5yb3RXaXRoKGluc2V0LCBwb2ludCwgLU1hdGguUEkgLyA2ICsgTWF0aC5QSSAvIDEyICogZ2V0UmFuZG9tKCkpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEN0cChzaGFwZSkge1xuICB2YXIgX3NoYXBlJGhhbmRsZXM4ID0gc2hhcGUuaGFuZGxlcyxcbiAgICAgIHN0YXJ0ID0gX3NoYXBlJGhhbmRsZXM4LnN0YXJ0LFxuICAgICAgZW5kID0gX3NoYXBlJGhhbmRsZXM4LmVuZCxcbiAgICAgIGJlbmQgPSBfc2hhcGUkaGFuZGxlczguYmVuZDtcbiAgcmV0dXJuIGNvcmUuVXRpbHMuY2lyY2xlRnJvbVRocmVlUG9pbnRzKHN0YXJ0LnBvaW50LCBlbmQucG9pbnQsIGJlbmQucG9pbnQpO1xufVxuXG52YXIgUmVjdGFuZ2xlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVExEcmF3U2hhcGVVdGlsKSB7XG4gIF9pbmhlcml0c0xvb3NlKFJlY3RhbmdsZSwgX1RMRHJhd1NoYXBlVXRpbCk7XG5cbiAgZnVuY3Rpb24gUmVjdGFuZ2xlKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9UTERyYXdTaGFwZVV0aWwuY2FsbC5hcHBseShfVExEcmF3U2hhcGVVdGlsLCBbdGhpc10uY29uY2F0KGFyZ3MpKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBleHBvcnRzLlRMRHJhd1NoYXBlVHlwZS5SZWN0YW5nbGU7XG4gICAgX3RoaXMudG9vbFR5cGUgPSBleHBvcnRzLlRMRHJhd1Rvb2xUeXBlLkJvdW5kcztcbiAgICBfdGhpcy5wYXRoQ2FjaGUgPSBuZXcgV2Vha01hcChbXSk7XG4gICAgX3RoaXMuZGVmYXVsdFByb3BzID0ge1xuICAgICAgaWQ6ICdpZCcsXG4gICAgICB0eXBlOiBleHBvcnRzLlRMRHJhd1NoYXBlVHlwZS5SZWN0YW5nbGUsXG4gICAgICBuYW1lOiAnUmVjdGFuZ2xlJyxcbiAgICAgIHBhcmVudElkOiAncGFnZScsXG4gICAgICBjaGlsZEluZGV4OiAxLFxuICAgICAgcG9pbnQ6IFswLCAwXSxcbiAgICAgIHNpemU6IFsxLCAxXSxcbiAgICAgIHJvdGF0aW9uOiAwLFxuICAgICAgcmFkaXVzOiAwLFxuICAgICAgc3R5bGU6IGRlZmF1bHRTdHlsZVxuICAgIH07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFJlY3RhbmdsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihzaGFwZSwgX3JlZikge1xuICAgIHZhciBpc0JpbmRpbmcgPSBfcmVmLmlzQmluZGluZyxcbiAgICAgICAgaXNIb3ZlcmVkID0gX3JlZi5pc0hvdmVyZWQsXG4gICAgICAgIGlzRGFya01vZGUgPSBfcmVmLmlzRGFya01vZGU7XG4gICAgdmFyIGlkID0gc2hhcGUuaWQsXG4gICAgICAgIHNpemUgPSBzaGFwZS5zaXplLFxuICAgICAgICBzdHlsZSA9IHNoYXBlLnN0eWxlO1xuICAgIHZhciBzdHlsZXMgPSBnZXRTaGFwZVN0eWxlKHN0eWxlLCBpc0RhcmtNb2RlKTtcbiAgICB2YXIgc3Ryb2tlV2lkdGggPSArc3R5bGVzLnN0cm9rZVdpZHRoO1xuXG4gICAgaWYgKHN0eWxlLmRhc2ggPT09IGV4cG9ydHMuRGFzaFN0eWxlLkRyYXcpIHtcbiAgICAgIHZhciBwYXRoRGF0YSA9IGNvcmUuVXRpbHMuZ2V0RnJvbUNhY2hlKHRoaXMucGF0aENhY2hlLCBzaGFwZS5zaXplLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZW5kZXJQYXRoKHNoYXBlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGlzQmluZGluZyAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJ0bC1iaW5kaW5nLWluZGljYXRvclwiLFxuICAgICAgICB4OiBzdHJva2VXaWR0aCAvIDIgLSAzMixcbiAgICAgICAgeTogc3Ryb2tlV2lkdGggLyAyIC0gMzIsXG4gICAgICAgIHdpZHRoOiBNYXRoLm1heCgwLCBzaXplWzBdIC0gc3Ryb2tlV2lkdGggLyAyKSArIDY0LFxuICAgICAgICBoZWlnaHQ6IE1hdGgubWF4KDAsIHNpemVbMV0gLSBzdHJva2VXaWR0aCAvIDIpICsgNjRcbiAgICAgIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7XG4gICAgICAgIHg6ICtzdHlsZXMuc3Ryb2tlV2lkdGggLyAyLFxuICAgICAgICB5OiArc3R5bGVzLnN0cm9rZVdpZHRoIC8gMixcbiAgICAgICAgd2lkdGg6IE1hdGgubWF4KDAsIHNpemVbMF0gLSBzdHJva2VXaWR0aCksXG4gICAgICAgIGhlaWdodDogTWF0aC5tYXgoMCwgc2l6ZVsxXSAtIHN0cm9rZVdpZHRoKSxcbiAgICAgICAgZmlsbDogc3R5bGUuaXNGaWxsZWQgPyBzdHlsZXMuZmlsbCA6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgIHN0cm9rZTogXCJub25lXCIsXG4gICAgICAgIHBvaW50ZXJFdmVudHM6IFwiYWxsXCJcbiAgICAgIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgICAgIGQ6IHBhdGhEYXRhLFxuICAgICAgICBmaWxsOiBzdHlsZXMuc3Ryb2tlLFxuICAgICAgICBzdHJva2U6IHN0eWxlcy5zdHJva2UsXG4gICAgICAgIHN0cm9rZVdpZHRoOiBzdHlsZXMuc3Ryb2tlV2lkdGgsXG4gICAgICAgIGZpbHRlcjogaXNIb3ZlcmVkID8gJ3VybCgjZXhwYW5kKScgOiAnbm9uZScsXG4gICAgICAgIHBvaW50ZXJFdmVudHM6IFwiYWxsXCJcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICB2YXIgc3cgPSBzdHJva2VXaWR0aCAqIDEuNjE4O1xuICAgIHZhciB3ID0gTWF0aC5tYXgoMCwgc2l6ZVswXSAtIHN3IC8gMik7XG4gICAgdmFyIGggPSBNYXRoLm1heCgwLCBzaXplWzFdIC0gc3cgLyAyKTtcbiAgICB2YXIgc3Ryb2tlcyA9IFtbW3N3IC8gMiwgc3cgLyAyXSwgW3csIHN3IC8gMl0sIHcgLSBzdyAvIDJdLCBbW3csIHN3IC8gMl0sIFt3LCBoXSwgaCAtIHN3IC8gMl0sIFtbdywgaF0sIFtzdyAvIDIsIGhdLCB3IC0gc3cgLyAyXSwgW1tzdyAvIDIsIGhdLCBbc3cgLyAyLCBzdyAvIDJdLCBoIC0gc3cgLyAyXV07XG4gICAgdmFyIHBhdGhzID0gc3Ryb2tlcy5tYXAoZnVuY3Rpb24gKF9yZWYyLCBpKSB7XG4gICAgICB2YXIgc3RhcnQgPSBfcmVmMlswXSxcbiAgICAgICAgICBlbmQgPSBfcmVmMlsxXSxcbiAgICAgICAgICBsZW5ndGggPSBfcmVmMlsyXTtcblxuICAgICAgdmFyIF9nZXRQZXJmZWN0RGFzaFByb3BzID0gZ2V0UGVyZmVjdERhc2hQcm9wcyhsZW5ndGgsIHN3LCBzaGFwZS5zdHlsZS5kYXNoKSxcbiAgICAgICAgICBzdHJva2VEYXNoYXJyYXkgPSBfZ2V0UGVyZmVjdERhc2hQcm9wcy5zdHJva2VEYXNoYXJyYXksXG4gICAgICAgICAgc3Ryb2tlRGFzaG9mZnNldCA9IF9nZXRQZXJmZWN0RGFzaFByb3BzLnN0cm9rZURhc2hvZmZzZXQ7XG5cbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGluZVwiLCB7XG4gICAgICAgIGtleTogaWQgKyAnXycgKyBpLFxuICAgICAgICB4MTogc3RhcnRbMF0sXG4gICAgICAgIHkxOiBzdGFydFsxXSxcbiAgICAgICAgeDI6IGVuZFswXSxcbiAgICAgICAgeTI6IGVuZFsxXSxcbiAgICAgICAgc3Ryb2tlOiBzdHlsZXMuc3Ryb2tlLFxuICAgICAgICBzdHJva2VXaWR0aDogc3csXG4gICAgICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiBzdHJva2VEYXNoYXJyYXksXG4gICAgICAgIHN0cm9rZURhc2hvZmZzZXQ6IHN0cm9rZURhc2hvZmZzZXRcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBpc0JpbmRpbmcgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xuICAgICAgY2xhc3NOYW1lOiBcInRsLWJpbmRpbmctaW5kaWNhdG9yXCIsXG4gICAgICB4OiBzdyAvIDIgLSAzMixcbiAgICAgIHk6IHN3IC8gMiAtIDMyLFxuICAgICAgd2lkdGg6IHcgKyA2NCxcbiAgICAgIGhlaWdodDogaCArIDY0XG4gICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIsIHtcbiAgICAgIHg6IHN3IC8gMixcbiAgICAgIHk6IHN3IC8gMixcbiAgICAgIHdpZHRoOiB3LFxuICAgICAgaGVpZ2h0OiBoLFxuICAgICAgZmlsbDogc3R5bGVzLmZpbGwsXG4gICAgICBzdHJva2U6IFwidHJhbnNwYXJlbnRcIixcbiAgICAgIHN0cm9rZVdpZHRoOiBzdyxcbiAgICAgIHBvaW50ZXJFdmVudHM6IFwiYWxsXCJcbiAgICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIiwge1xuICAgICAgZmlsdGVyOiBpc0hvdmVyZWQgPyAndXJsKCNleHBhbmQpJyA6ICdub25lJyxcbiAgICAgIHBvaW50ZXJFdmVudHM6IFwic3Ryb2tlXCJcbiAgICB9LCBwYXRocykpO1xuICB9O1xuXG4gIF9wcm90by5nZXRCb3VuZHMgPSBmdW5jdGlvbiBnZXRCb3VuZHMoc2hhcGUpIHtcbiAgICB2YXIgYm91bmRzID0gY29yZS5VdGlscy5nZXRGcm9tQ2FjaGUodGhpcy5ib3VuZHNDYWNoZSwgc2hhcGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfc2hhcGUkc2l6ZSA9IHNoYXBlLnNpemUsXG4gICAgICAgICAgd2lkdGggPSBfc2hhcGUkc2l6ZVswXSxcbiAgICAgICAgICBoZWlnaHQgPSBfc2hhcGUkc2l6ZVsxXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pblg6IDAsXG4gICAgICAgIG1heFg6IHdpZHRoLFxuICAgICAgICBtaW5ZOiAwLFxuICAgICAgICBtYXhZOiBoZWlnaHQsXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvcmUuVXRpbHMudHJhbnNsYXRlQm91bmRzKGJvdW5kcywgc2hhcGUucG9pbnQpO1xuICB9O1xuXG4gIF9wcm90by5nZXRSb3RhdGVkQm91bmRzID0gZnVuY3Rpb24gZ2V0Um90YXRlZEJvdW5kcyhzaGFwZSkge1xuICAgIHJldHVybiBjb3JlLlV0aWxzLmdldEJvdW5kc0Zyb21Qb2ludHMoY29yZS5VdGlscy5nZXRSb3RhdGVkQ29ybmVycyh0aGlzLmdldEJvdW5kcyhzaGFwZSksIHNoYXBlLnJvdGF0aW9uKSk7XG4gIH07XG5cbiAgX3Byb3RvLmdldENlbnRlciA9IGZ1bmN0aW9uIGdldENlbnRlcihzaGFwZSkge1xuICAgIHJldHVybiBjb3JlLlV0aWxzLmdldEJvdW5kc0NlbnRlcih0aGlzLmdldEJvdW5kcyhzaGFwZSkpO1xuICB9O1xuXG4gIF9wcm90by5oaXRUZXN0ID0gZnVuY3Rpb24gaGl0VGVzdChzaGFwZSwgcG9pbnQpIHtcbiAgICByZXR1cm4gY29yZS5VdGlscy5wb2ludEluQm91bmRzKHBvaW50LCB0aGlzLmdldEJvdW5kcyhzaGFwZSkpO1xuICB9O1xuXG4gIF9wcm90by5oaXRUZXN0Qm91bmRzID0gZnVuY3Rpb24gaGl0VGVzdEJvdW5kcyhzaGFwZSwgYm91bmRzKSB7XG4gICAgdmFyIHJvdGF0ZWRDb3JuZXJzID0gY29yZS5VdGlscy5nZXRSb3RhdGVkQ29ybmVycyh0aGlzLmdldEJvdW5kcyhzaGFwZSksIHNoYXBlLnJvdGF0aW9uKTtcbiAgICByZXR1cm4gcm90YXRlZENvcm5lcnMuZXZlcnkoZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICByZXR1cm4gY29yZS5VdGlscy5wb2ludEluQm91bmRzKHBvaW50LCBib3VuZHMpO1xuICAgIH0pIHx8IGNvcmUuSW50ZXJzZWN0LnBvbHlsaW5lLmJvdW5kcyhyb3RhdGVkQ29ybmVycywgYm91bmRzKS5sZW5ndGggPiAwO1xuICB9O1xuXG4gIF9wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbiB0cmFuc2Zvcm0oc2hhcGUsIGJvdW5kcywgX3JlZjMpIHtcbiAgICB2YXIgaW5pdGlhbFNoYXBlID0gX3JlZjMuaW5pdGlhbFNoYXBlLFxuICAgICAgICB0cmFuc2Zvcm1PcmlnaW4gPSBfcmVmMy50cmFuc2Zvcm1PcmlnaW4sXG4gICAgICAgIHNjYWxlWCA9IF9yZWYzLnNjYWxlWCxcbiAgICAgICAgc2NhbGVZID0gX3JlZjMuc2NhbGVZO1xuXG4gICAgaWYgKCFzaGFwZS5yb3RhdGlvbiAmJiAhc2hhcGUuaXNBc3BlY3RSYXRpb0xvY2tlZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcG9pbnQ6IGNvcmUuVmVjLnJvdW5kKFtib3VuZHMubWluWCwgYm91bmRzLm1pblldKSxcbiAgICAgICAgc2l6ZTogY29yZS5WZWMucm91bmQoW2JvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodF0pXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2l6ZSA9IGNvcmUuVmVjLnJvdW5kKGNvcmUuVmVjLm11bChpbml0aWFsU2hhcGUuc2l6ZSwgTWF0aC5taW4oTWF0aC5hYnMoc2NhbGVYKSwgTWF0aC5hYnMoc2NhbGVZKSkpKTtcbiAgICAgIHZhciBwb2ludCA9IGNvcmUuVmVjLnJvdW5kKFtib3VuZHMubWluWCArIChib3VuZHMud2lkdGggLSBzaGFwZS5zaXplWzBdKSAqIChzY2FsZVggPCAwID8gMSAtIHRyYW5zZm9ybU9yaWdpblswXSA6IHRyYW5zZm9ybU9yaWdpblswXSksIGJvdW5kcy5taW5ZICsgKGJvdW5kcy5oZWlnaHQgLSBzaGFwZS5zaXplWzFdKSAqIChzY2FsZVkgPCAwID8gMSAtIHRyYW5zZm9ybU9yaWdpblsxXSA6IHRyYW5zZm9ybU9yaWdpblsxXSldKTtcbiAgICAgIHZhciByb3RhdGlvbiA9IHNjYWxlWCA8IDAgJiYgc2NhbGVZID49IDAgfHwgc2NhbGVZIDwgMCAmJiBzY2FsZVggPj0gMCA/IGluaXRpYWxTaGFwZS5yb3RhdGlvbiA/IC1pbml0aWFsU2hhcGUucm90YXRpb24gOiAwIDogaW5pdGlhbFNoYXBlLnJvdGF0aW9uO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICByb3RhdGlvbjogcm90YXRpb25cbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by50cmFuc2Zvcm1TaW5nbGUgPSBmdW5jdGlvbiB0cmFuc2Zvcm1TaW5nbGUoc2hhcGUsIGJvdW5kcywgaW5mbykge1xuICAgIHJldHVybiB7XG4gICAgICBzaXplOiBjb3JlLlZlYy5yb3VuZChbYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0XSksXG4gICAgICBwb2ludDogY29yZS5WZWMucm91bmQoW2JvdW5kcy5taW5YLCBib3VuZHMubWluWV0pXG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4gUmVjdGFuZ2xlO1xufShUTERyYXdTaGFwZVV0aWwpO1xuXG5mdW5jdGlvbiByZW5kZXJQYXRoKHNoYXBlKSB7XG4gIHZhciBzdHlsZXMgPSBnZXRTaGFwZVN0eWxlKHNoYXBlLnN0eWxlKTtcbiAgdmFyIGdldFJhbmRvbSA9IGNvcmUuVXRpbHMucm5nKHNoYXBlLmlkKTtcbiAgdmFyIHN0cm9rZVdpZHRoID0gK3N0eWxlcy5zdHJva2VXaWR0aDtcbiAgdmFyIGJhc2VPZmZzZXQgPSBzdHJva2VXaWR0aCAvIDI7XG4gIHZhciBvZmZzZXRzID0gQXJyYXkuZnJvbShBcnJheSg0KSkubWFwKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gW2dldFJhbmRvbSgpICogYmFzZU9mZnNldCwgZ2V0UmFuZG9tKCkgKiBiYXNlT2Zmc2V0XTtcbiAgfSk7XG4gIHZhciBzdyA9IHN0cm9rZVdpZHRoO1xuICB2YXIgdyA9IE1hdGgubWF4KDAsIHNoYXBlLnNpemVbMF0gLSBzdyAvIDIpO1xuICB2YXIgaCA9IE1hdGgubWF4KDAsIHNoYXBlLnNpemVbMV0gLSBzdyAvIDIpO1xuICB2YXIgdGwgPSBjb3JlLlZlYy5hZGQoW3N3IC8gMiwgc3cgLyAyXSwgb2Zmc2V0c1swXSk7XG4gIHZhciB0ciA9IGNvcmUuVmVjLmFkZChbdywgc3cgLyAyXSwgb2Zmc2V0c1sxXSk7XG4gIHZhciBiciA9IGNvcmUuVmVjLmFkZChbdywgaF0sIG9mZnNldHNbMl0pO1xuICB2YXIgYmwgPSBjb3JlLlZlYy5hZGQoW3N3IC8gMiwgaF0sIG9mZnNldHNbM10pO1xuICB2YXIgbGluZXMgPSBjb3JlLlV0aWxzLnNodWZmbGVBcnIoW2NvcmUuVmVjLnBvaW50c0JldHdlZW4odHIsIGJyKSwgY29yZS5WZWMucG9pbnRzQmV0d2VlbihiciwgYmwpLCBjb3JlLlZlYy5wb2ludHNCZXR3ZWVuKGJsLCB0bCksIGNvcmUuVmVjLnBvaW50c0JldHdlZW4odGwsIHRyKV0sIE1hdGguZmxvb3IoNSArIGdldFJhbmRvbSgpICogNCkpO1xuICB2YXIgc3Ryb2tlID0gZ2V0U3Ryb2tlX19kZWZhdWx0KFtdLmNvbmNhdChsaW5lcy5mbGF0KCkuc2xpY2UoMiksIGxpbmVzWzBdLCBsaW5lc1swXS5zbGljZSg0KSksIHtcbiAgICBzaXplOiAxICsgK3N0eWxlcy5zdHJva2VXaWR0aCxcbiAgICB0aGlubmluZzogMC42LFxuICAgIGVhc2luZzogZnVuY3Rpb24gZWFzaW5nKHQpIHtcbiAgICAgIHJldHVybiB0ICogdCAqIHQgKiB0O1xuICAgIH0sXG4gICAgZW5kOiB7XG4gICAgICB0YXBlcjogK3N0eWxlcy5zdHJva2VXaWR0aCAqIDIwXG4gICAgfSxcbiAgICBzdGFydDoge1xuICAgICAgdGFwZXI6ICtzdHlsZXMuc3Ryb2tlV2lkdGggKiAyMFxuICAgIH0sXG4gICAgc2ltdWxhdGVQcmVzc3VyZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBjb3JlLlV0aWxzLmdldFN2Z1BhdGhGcm9tU3Ryb2tlKHN0cm9rZSk7XG59XG5cbnZhciBFbGxpcHNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVExEcmF3U2hhcGVVdGlsKSB7XG4gIF9pbmhlcml0c0xvb3NlKEVsbGlwc2UsIF9UTERyYXdTaGFwZVV0aWwpO1xuXG4gIGZ1bmN0aW9uIEVsbGlwc2UoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX1RMRHJhd1NoYXBlVXRpbC5jYWxsLmFwcGx5KF9UTERyYXdTaGFwZVV0aWwsIFt0aGlzXS5jb25jYXQoYXJncykpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IGV4cG9ydHMuVExEcmF3U2hhcGVUeXBlLkVsbGlwc2U7XG4gICAgX3RoaXMudG9vbFR5cGUgPSBleHBvcnRzLlRMRHJhd1Rvb2xUeXBlLkJvdW5kcztcbiAgICBfdGhpcy5wYXRoQ2FjaGUgPSBuZXcgV2Vha01hcChbXSk7XG4gICAgX3RoaXMuZGVmYXVsdFByb3BzID0ge1xuICAgICAgaWQ6ICdpZCcsXG4gICAgICB0eXBlOiBleHBvcnRzLlRMRHJhd1NoYXBlVHlwZS5FbGxpcHNlLFxuICAgICAgbmFtZTogJ0VsbGlwc2UnLFxuICAgICAgcGFyZW50SWQ6ICdwYWdlJyxcbiAgICAgIGNoaWxkSW5kZXg6IDEsXG4gICAgICBwb2ludDogWzAsIDBdLFxuICAgICAgcmFkaXVzOiBbMSwgMV0sXG4gICAgICByb3RhdGlvbjogMCxcbiAgICAgIHN0eWxlOiBkZWZhdWx0U3R5bGVcbiAgICB9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBFbGxpcHNlLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKHNoYXBlLCBfcmVmKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgaXNEYXJrTW9kZSA9IF9yZWYuaXNEYXJrTW9kZSxcbiAgICAgICAgaXNCaW5kaW5nID0gX3JlZi5pc0JpbmRpbmc7XG4gICAgdmFyIF9zaGFwZSRyYWRpdXMgPSBzaGFwZS5yYWRpdXMsXG4gICAgICAgIHJhZGl1c1ggPSBfc2hhcGUkcmFkaXVzWzBdLFxuICAgICAgICByYWRpdXNZID0gX3NoYXBlJHJhZGl1c1sxXSxcbiAgICAgICAgc3R5bGUgPSBzaGFwZS5zdHlsZTtcbiAgICB2YXIgc3R5bGVzID0gZ2V0U2hhcGVTdHlsZShzdHlsZSwgaXNEYXJrTW9kZSk7XG4gICAgdmFyIHN0cm9rZVdpZHRoID0gK3N0eWxlcy5zdHJva2VXaWR0aDtcbiAgICB2YXIgcnggPSBNYXRoLm1heCgwLCByYWRpdXNYIC0gc3Ryb2tlV2lkdGggLyAyKTtcbiAgICB2YXIgcnkgPSBNYXRoLm1heCgwLCByYWRpdXNZIC0gc3Ryb2tlV2lkdGggLyAyKTtcblxuICAgIGlmIChzdHlsZS5kYXNoID09PSBleHBvcnRzLkRhc2hTdHlsZS5EcmF3KSB7XG4gICAgICB2YXIgcGF0aCA9IGNvcmUuVXRpbHMuZ2V0RnJvbUNhY2hlKHRoaXMucGF0aENhY2hlLCBzaGFwZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVuZGVyUGF0aCQxKHNoYXBlLCBfdGhpczIuZ2V0Q2VudGVyKHNoYXBlKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBpc0JpbmRpbmcgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcImVsbGlwc2VcIiwge1xuICAgICAgICBjbGFzc05hbWU6IFwidGwtYmluZGluZy1pbmRpY2F0b3JcIixcbiAgICAgICAgY3g6IHJhZGl1c1gsXG4gICAgICAgIGN5OiByYWRpdXNZLFxuICAgICAgICByeDogcnggKyAyLFxuICAgICAgICByeTogcnkgKyAyXG4gICAgICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImVsbGlwc2VcIiwge1xuICAgICAgICBjeDogcmFkaXVzWCxcbiAgICAgICAgY3k6IHJhZGl1c1ksXG4gICAgICAgIHJ4OiByeCxcbiAgICAgICAgcnk6IHJ5LFxuICAgICAgICBzdHJva2U6IFwibm9uZVwiLFxuICAgICAgICBmaWxsOiBzdHlsZS5pc0ZpbGxlZCA/IHN0eWxlcy5maWxsIDogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgcG9pbnRlckV2ZW50czogXCJhbGxcIlxuICAgICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICAgICAgZDogcGF0aCxcbiAgICAgICAgZmlsbDogc3R5bGVzLnN0cm9rZSxcbiAgICAgICAgc3Ryb2tlOiBzdHlsZXMuc3Ryb2tlLFxuICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICAgIHBvaW50ZXJFdmVudHM6IFwiYWxsXCIsXG4gICAgICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIlxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHZhciBoID0gTWF0aC5wb3cocnggLSByeSwgMikgLyBNYXRoLnBvdyhyeCArIHJ5LCAyKTtcbiAgICB2YXIgcGVyaW1ldGVyID0gTWF0aC5QSSAqIChyeCArIHJ5KSAqICgxICsgMyAqIGggLyAoMTAgKyBNYXRoLnNxcnQoNCAtIDMgKiBoKSkpO1xuXG4gICAgdmFyIF9nZXRQZXJmZWN0RGFzaFByb3BzID0gZ2V0UGVyZmVjdERhc2hQcm9wcyhwZXJpbWV0ZXIsIHN0cm9rZVdpZHRoICogMS42MTgsIHNoYXBlLnN0eWxlLmRhc2gsIDQpLFxuICAgICAgICBzdHJva2VEYXNoYXJyYXkgPSBfZ2V0UGVyZmVjdERhc2hQcm9wcy5zdHJva2VEYXNoYXJyYXksXG4gICAgICAgIHN0cm9rZURhc2hvZmZzZXQgPSBfZ2V0UGVyZmVjdERhc2hQcm9wcy5zdHJva2VEYXNob2Zmc2V0O1xuXG4gICAgdmFyIHN3ID0gc3Ryb2tlV2lkdGggKiAxLjYxODtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgaXNCaW5kaW5nICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJlbGxpcHNlXCIsIHtcbiAgICAgIGNsYXNzTmFtZTogXCJ0bC1iaW5kaW5nLWluZGljYXRvclwiLFxuICAgICAgY3g6IHJhZGl1c1gsXG4gICAgICBjeTogcmFkaXVzWSxcbiAgICAgIHJ4OiByeCArIDMyLFxuICAgICAgcnk6IHJ5ICsgMzJcbiAgICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImVsbGlwc2VcIiwge1xuICAgICAgY3g6IHJhZGl1c1gsXG4gICAgICBjeTogcmFkaXVzWSxcbiAgICAgIHJ4OiByeCxcbiAgICAgIHJ5OiByeSxcbiAgICAgIGZpbGw6IHN0eWxlcy5maWxsLFxuICAgICAgc3Ryb2tlOiBzdHlsZXMuc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGg6IHN3LFxuICAgICAgc3Ryb2tlRGFzaGFycmF5OiBzdHJva2VEYXNoYXJyYXksXG4gICAgICBzdHJva2VEYXNob2Zmc2V0OiBzdHJva2VEYXNob2Zmc2V0LFxuICAgICAgcG9pbnRlckV2ZW50czogXCJhbGxcIixcbiAgICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCJcbiAgICB9KSk7XG4gIH07XG5cbiAgX3Byb3RvLmdldEJvdW5kcyA9IGZ1bmN0aW9uIGdldEJvdW5kcyhzaGFwZSkge1xuICAgIHJldHVybiBjb3JlLlV0aWxzLmdldEZyb21DYWNoZSh0aGlzLmJvdW5kc0NhY2hlLCBzaGFwZSwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGNvcmUuVXRpbHMuZ2V0Um90YXRlZEVsbGlwc2VCb3VuZHMoc2hhcGUucG9pbnRbMF0sIHNoYXBlLnBvaW50WzFdLCBzaGFwZS5yYWRpdXNbMF0sIHNoYXBlLnJhZGl1c1sxXSwgc2hhcGUucm90YXRpb24gfHwgMCk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmdldFJvdGF0ZWRCb3VuZHMgPSBmdW5jdGlvbiBnZXRSb3RhdGVkQm91bmRzKHNoYXBlKSB7XG4gICAgcmV0dXJuIGNvcmUuVXRpbHMuZ2V0Qm91bmRzRnJvbVBvaW50cyhjb3JlLlV0aWxzLmdldFJvdGF0ZWRDb3JuZXJzKHRoaXMuZ2V0Qm91bmRzKHNoYXBlKSwgc2hhcGUucm90YXRpb24pKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0Q2VudGVyID0gZnVuY3Rpb24gZ2V0Q2VudGVyKHNoYXBlKSB7XG4gICAgcmV0dXJuIGNvcmUuVXRpbHMuZ2V0Qm91bmRzQ2VudGVyKHRoaXMuZ2V0Qm91bmRzKHNoYXBlKSk7XG4gIH07XG5cbiAgX3Byb3RvLmhpdFRlc3QgPSBmdW5jdGlvbiBoaXRUZXN0KHNoYXBlLCBwb2ludCkge1xuICAgIHJldHVybiBjb3JlLlV0aWxzLnBvaW50SW5Cb3VuZHMocG9pbnQsIHRoaXMuZ2V0Qm91bmRzKHNoYXBlKSk7XG4gIH07XG5cbiAgX3Byb3RvLmhpdFRlc3RCb3VuZHMgPSBmdW5jdGlvbiBoaXRUZXN0Qm91bmRzKHNoYXBlLCBib3VuZHMpIHtcbiAgICB2YXIgcm90YXRlZENvcm5lcnMgPSBjb3JlLlV0aWxzLmdldFJvdGF0ZWRDb3JuZXJzKHRoaXMuZ2V0Qm91bmRzKHNoYXBlKSwgc2hhcGUucm90YXRpb24pO1xuICAgIHJldHVybiByb3RhdGVkQ29ybmVycy5ldmVyeShmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIHJldHVybiBjb3JlLlV0aWxzLnBvaW50SW5Cb3VuZHMocG9pbnQsIGJvdW5kcyk7XG4gICAgfSkgfHwgY29yZS5JbnRlcnNlY3QucG9seWxpbmUuYm91bmRzKHJvdGF0ZWRDb3JuZXJzLCBib3VuZHMpLmxlbmd0aCA+IDA7XG4gIH07XG5cbiAgX3Byb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIHRyYW5zZm9ybShzaGFwZSwgYm91bmRzLCBfcmVmMikge1xuICAgIHZhciBzY2FsZVggPSBfcmVmMi5zY2FsZVgsXG4gICAgICAgIHNjYWxlWSA9IF9yZWYyLnNjYWxlWSxcbiAgICAgICAgaW5pdGlhbFNoYXBlID0gX3JlZjIuaW5pdGlhbFNoYXBlO1xuICAgIHZhciBfaW5pdGlhbFNoYXBlJHJvdGF0aW8gPSBpbml0aWFsU2hhcGUucm90YXRpb24sXG4gICAgICAgIHJvdGF0aW9uID0gX2luaXRpYWxTaGFwZSRyb3RhdGlvID09PSB2b2lkIDAgPyAwIDogX2luaXRpYWxTaGFwZSRyb3RhdGlvO1xuICAgIHJldHVybiB7XG4gICAgICBwb2ludDogW2JvdW5kcy5taW5YLCBib3VuZHMubWluWV0sXG4gICAgICByYWRpdXM6IFtib3VuZHMud2lkdGggLyAyLCBib3VuZHMuaGVpZ2h0IC8gMl0sXG4gICAgICByb3RhdGlvbjogc2NhbGVYIDwgMCAmJiBzY2FsZVkgPj0gMCB8fCBzY2FsZVkgPCAwICYmIHNjYWxlWCA+PSAwID8gLShyb3RhdGlvbiB8fCAwKSA6IHJvdGF0aW9uIHx8IDBcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by50cmFuc2Zvcm1TaW5nbGUgPSBmdW5jdGlvbiB0cmFuc2Zvcm1TaW5nbGUoc2hhcGUsIGJvdW5kcykge1xuICAgIHJldHVybiB7XG4gICAgICBwb2ludDogY29yZS5WZWMucm91bmQoW2JvdW5kcy5taW5YLCBib3VuZHMubWluWV0pLFxuICAgICAgcmFkaXVzOiBjb3JlLlZlYy5kaXYoW2JvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodF0sIDIpXG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4gRWxsaXBzZTtcbn0oVExEcmF3U2hhcGVVdGlsKTtcblxuZnVuY3Rpb24gcmVuZGVyUGF0aCQxKHNoYXBlLCBib3VuZHNDZW50ZXIpIHtcbiAgdmFyIHN0eWxlID0gc2hhcGUuc3R5bGUsXG4gICAgICBpZCA9IHNoYXBlLmlkLFxuICAgICAgX3NoYXBlJHJhZGl1czIgPSBzaGFwZS5yYWRpdXMsXG4gICAgICByYWRpdXNYID0gX3NoYXBlJHJhZGl1czJbMF0sXG4gICAgICByYWRpdXNZID0gX3NoYXBlJHJhZGl1czJbMV0sXG4gICAgICBwb2ludCA9IHNoYXBlLnBvaW50O1xuICB2YXIgZ2V0UmFuZG9tID0gY29yZS5VdGlscy5ybmcoaWQpO1xuICB2YXIgY2VudGVyID0gY29yZS5WZWMuc3ViKGJvdW5kc0NlbnRlciwgcG9pbnQpO1xuICB2YXIgc3Ryb2tlV2lkdGggPSArZ2V0U2hhcGVTdHlsZShzdHlsZSkuc3Ryb2tlV2lkdGg7XG4gIHZhciByeCA9IHJhZGl1c1ggKyBnZXRSYW5kb20oKSAqIHN0cm9rZVdpZHRoIC0gc3Ryb2tlV2lkdGggLyAyO1xuICB2YXIgcnkgPSByYWRpdXNZICsgZ2V0UmFuZG9tKCkgKiBzdHJva2VXaWR0aCAtIHN0cm9rZVdpZHRoIC8gMjtcbiAgdmFyIHBvaW50cyA9IFtdO1xuICB2YXIgc3RhcnQgPSBNYXRoLlBJICsgTWF0aC5QSSAqIGdldFJhbmRvbSgpO1xuICB2YXIgb3ZlcmxhcCA9IE1hdGguUEkgLyAxMjtcblxuICBmb3IgKHZhciBpID0gMjsgaSA8IDg7IGkrKykge1xuICAgIHZhciByYWRzID0gc3RhcnQgKyBvdmVybGFwICogMiAqIChpIC8gOCk7XG4gICAgdmFyIHggPSByeCAqIE1hdGguY29zKHJhZHMpICsgY2VudGVyWzBdO1xuICAgIHZhciB5ID0gcnkgKiBNYXRoLnNpbihyYWRzKSArIGNlbnRlclsxXTtcbiAgICBwb2ludHMucHVzaChbeCwgeV0pO1xuICB9XG5cbiAgZm9yICh2YXIgX2kgPSA1OyBfaSA8IDMyOyBfaSsrKSB7XG4gICAgdmFyIHQgPSBfaSAvIDM1O1xuXG4gICAgdmFyIF9yYWRzID0gc3RhcnQgKyBvdmVybGFwICogMiArIE1hdGguUEkgKiAyLjUgKiAodCAqIHQgKiB0KTtcblxuICAgIHZhciBfeCA9IHJ4ICogTWF0aC5jb3MoX3JhZHMpICsgY2VudGVyWzBdO1xuXG4gICAgdmFyIF95ID0gcnkgKiBNYXRoLnNpbihfcmFkcykgKyBjZW50ZXJbMV07XG5cbiAgICBwb2ludHMucHVzaChbX3gsIF95XSk7XG4gIH1cblxuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCA4OyBfaTIrKykge1xuICAgIHZhciBfcmFkczIgPSBzdGFydCArIG92ZXJsYXAgKiAyICogKF9pMiAvIDQpO1xuXG4gICAgdmFyIF94MiA9IHJ4ICogTWF0aC5jb3MoX3JhZHMyKSArIGNlbnRlclswXTtcblxuICAgIHZhciBfeTIgPSByeSAqIE1hdGguc2luKF9yYWRzMikgKyBjZW50ZXJbMV07XG5cbiAgICBwb2ludHMucHVzaChbX3gyLCBfeTJdKTtcbiAgfVxuXG4gIHZhciBzdHJva2UgPSBnZXRTdHJva2VfX2RlZmF1bHQocG9pbnRzLCB7XG4gICAgc2l6ZTogMSArIHN0cm9rZVdpZHRoLFxuICAgIHRoaW5uaW5nOiAwLjYsXG4gICAgZWFzaW5nOiBmdW5jdGlvbiBlYXNpbmcodCkge1xuICAgICAgcmV0dXJuIHQgKiB0ICogdCAqIHQ7XG4gICAgfSxcbiAgICBlbmQ6IHtcbiAgICAgIHRhcGVyOiBzdHJva2VXaWR0aCAqIDIwXG4gICAgfSxcbiAgICBzdGFydDoge1xuICAgICAgdGFwZXI6IHN0cm9rZVdpZHRoICogMjBcbiAgICB9LFxuICAgIHNpbXVsYXRlUHJlc3N1cmU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gY29yZS5VdGlscy5nZXRTdmdQYXRoRnJvbVN0cm9rZShzdHJva2UpO1xufVxuXG52YXIgdGxkcmF3U2hhcGVVdGlscyA9IHtcbiAgcmVjdGFuZ2xlOiAvKiNfX1BVUkVfXyovbmV3IFJlY3RhbmdsZSgpLFxuICBlbGxpcHNlOiAvKiNfX1BVUkVfXyovbmV3IEVsbGlwc2UoKSxcbiAgZHJhdzogLyojX19QVVJFX18qL25ldyBEcmF3KCksXG4gIGFycm93OiAvKiNfX1BVUkVfXyovbmV3IEFycm93KClcbn07XG5mdW5jdGlvbiBnZXRTaGFwZVV0aWxzKHNoYXBlKSB7XG4gIHJldHVybiB0bGRyYXdTaGFwZVV0aWxzW3NoYXBlLnR5cGVdO1xufVxuZnVuY3Rpb24gY3JlYXRlU2hhcGUodHlwZSwgcHJvcHMpIHtcbiAgcmV0dXJuIHRsZHJhd1NoYXBlVXRpbHNbdHlwZV0uY3JlYXRlKHByb3BzKTtcbn1cblxuZnVuY3Rpb24gdXNlS2V5Ym9hcmRTaG9ydGN1dHModGxzdGF0ZSkge1xuICBSZWFjdF9fZGVmYXVsdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYW5kbGVLZXlEb3duID0gZnVuY3Rpb24gaGFuZGxlS2V5RG93bihlKSB7XG4gICAgICB2YXIgaW5mbyA9IGNvcmUuaW5wdXRzLmtleWRvd24oZSk7XG4gICAgICB0bHN0YXRlLm9uS2V5RG93bihlLmtleSwgaW5mbyk7XG4gICAgfTtcblxuICAgIHZhciBoYW5kbGVLZXlVcCA9IGZ1bmN0aW9uIGhhbmRsZUtleVVwKGUpIHtcbiAgICAgIHZhciBpbmZvID0gY29yZS5pbnB1dHMua2V5dXAoZSk7XG4gICAgICB0bHN0YXRlLm9uS2V5VXAoZS5rZXksIGluZm8pO1xuICAgIH07XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZUtleURvd24pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGhhbmRsZUtleVVwKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIGhhbmRsZUtleVVwKTtcbiAgICB9O1xuICB9LCBbdGxzdGF0ZV0pO1xuICByZWFjdEhvdGtleXNIb29rLnVzZUhvdGtleXMoJ2NvbW1hbmQreicsIGZ1bmN0aW9uIChlKSB7XG4gICAgdGxzdGF0ZS51bmRvKCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9KTtcbiAgcmVhY3RIb3RrZXlzSG9vay51c2VIb3RrZXlzKCdjdHJsK3NoaWZ0LXosY29tbWFuZCtzaGlmdCt6JywgZnVuY3Rpb24gKGUpIHtcbiAgICB0bHN0YXRlLnJlZG8oKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xuICByZWFjdEhvdGtleXNIb29rLnVzZUhvdGtleXMoJ2N0cmwrZCxjb21tYW5kK2QnLCBmdW5jdGlvbiAoZSkge1xuICAgIHRsc3RhdGUuZHVwbGljYXRlKCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9KTtcbiAgcmVhY3RIb3RrZXlzSG9vay51c2VIb3RrZXlzKCdjdHJsK3MsY29tbWFuZCtzJywgZnVuY3Rpb24gKGUpIHtcbiAgICB0bHN0YXRlLnNhdmUoKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xuICByZWFjdEhvdGtleXNIb29rLnVzZUhvdGtleXMoJ2N0cmwrPSxjb21tYW5kKz0nLCBmdW5jdGlvbiAoZSkge1xuICAgIHRsc3RhdGUuem9vbUluKCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9KTtcbiAgcmVhY3RIb3RrZXlzSG9vay51c2VIb3RrZXlzKCdjdHJsKy0sY29tbWFuZCstJywgZnVuY3Rpb24gKGUpIHtcbiAgICB0bHN0YXRlLnpvb21PdXQoKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xuICByZWFjdEhvdGtleXNIb29rLnVzZUhvdGtleXMoJ3NoaWZ0KzEnLCBmdW5jdGlvbiAoZSkge1xuICAgIHRsc3RhdGUuem9vbVRvRml0KCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9KTtcbiAgcmVhY3RIb3RrZXlzSG9vay51c2VIb3RrZXlzKCdzaGlmdCsyJywgZnVuY3Rpb24gKGUpIHtcbiAgICB0bHN0YXRlLnpvb21Ub1NlbGVjdGlvbigpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG4gIHJlYWN0SG90a2V5c0hvb2sudXNlSG90a2V5cygnc2hpZnQrMCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgdGxzdGF0ZS56b29tVG9BY3R1YWwoKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xuICByZWFjdEhvdGtleXNIb29rLnVzZUhvdGtleXMoJ2VzY2FwZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgdGxzdGF0ZS5jYW5jZWwoKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xuICByZWFjdEhvdGtleXNIb29rLnVzZUhvdGtleXMoJ2JhY2tzcGFjZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgdGxzdGF0ZVtcImRlbGV0ZVwiXSgpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG4gIHJlYWN0SG90a2V5c0hvb2sudXNlSG90a2V5cygnY29tbWFuZCthLGN0cmwrYScsIGZ1bmN0aW9uIChlKSB7XG4gICAgdGxzdGF0ZS5zZWxlY3RBbGwoKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xuICByZWFjdEhvdGtleXNIb29rLnVzZUhvdGtleXMoJ3VwJywgZnVuY3Rpb24gKGUpIHtcbiAgICB0bHN0YXRlLm51ZGdlKFswLCAtMV0sIGZhbHNlKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xuICByZWFjdEhvdGtleXNIb29rLnVzZUhvdGtleXMoJ3JpZ2h0JywgZnVuY3Rpb24gKGUpIHtcbiAgICB0bHN0YXRlLm51ZGdlKFsxLCAwXSwgZmFsc2UpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG4gIHJlYWN0SG90a2V5c0hvb2sudXNlSG90a2V5cygnZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgdGxzdGF0ZS5udWRnZShbMCwgMV0sIGZhbHNlKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xuICByZWFjdEhvdGtleXNIb29rLnVzZUhvdGtleXMoJ2xlZnQnLCBmdW5jdGlvbiAoZSkge1xuICAgIHRsc3RhdGUubnVkZ2UoWy0xLCAwXSwgZmFsc2UpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG4gIHJlYWN0SG90a2V5c0hvb2sudXNlSG90a2V5cygnc2hpZnQrdXAnLCBmdW5jdGlvbiAoZSkge1xuICAgIHRsc3RhdGUubnVkZ2UoWzAsIC0xXSwgdHJ1ZSk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9KTtcbiAgcmVhY3RIb3RrZXlzSG9vay51c2VIb3RrZXlzKCdzaGlmdCtyaWdodCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgdGxzdGF0ZS5udWRnZShbMSwgMF0sIHRydWUpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG4gIHJlYWN0SG90a2V5c0hvb2sudXNlSG90a2V5cygnc2hpZnQrZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgdGxzdGF0ZS5udWRnZShbMCwgMV0sIHRydWUpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG4gIHJlYWN0SG90a2V5c0hvb2sudXNlSG90a2V5cygnc2hpZnQrbGVmdCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgdGxzdGF0ZS5udWRnZShbLTEsIDBdLCB0cnVlKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xuICByZWFjdEhvdGtleXNIb29rLnVzZUhvdGtleXMoJ1snLCBmdW5jdGlvbiAoZSkge1xuICAgIHRsc3RhdGUubW92ZUJhY2t3YXJkKCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9KTtcbiAgcmVhY3RIb3RrZXlzSG9vay51c2VIb3RrZXlzKCddJywgZnVuY3Rpb24gKGUpIHtcbiAgICB0bHN0YXRlLm1vdmVGb3J3YXJkKCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9KTtcbiAgcmVhY3RIb3RrZXlzSG9vay51c2VIb3RrZXlzKCdzaGlmdCtbJywgZnVuY3Rpb24gKGUpIHtcbiAgICB0bHN0YXRlLm1vdmVUb0JhY2soKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xuICByZWFjdEhvdGtleXNIb29rLnVzZUhvdGtleXMoJ3NoaWZ0K10nLCBmdW5jdGlvbiAoZSkge1xuICAgIHRsc3RhdGUubW92ZVRvRnJvbnQoKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xuICByZWFjdEhvdGtleXNIb29rLnVzZUhvdGtleXMoJ3YsMScsIGZ1bmN0aW9uIChlKSB7XG4gICAgdGxzdGF0ZS5zZWxlY3RUb29sKCdzZWxlY3QnKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xuICByZWFjdEhvdGtleXNIb29rLnVzZUhvdGtleXMoJ2QsMicsIGZ1bmN0aW9uIChlKSB7XG4gICAgdGxzdGF0ZS5zZWxlY3RUb29sKGV4cG9ydHMuVExEcmF3U2hhcGVUeXBlLkRyYXcpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG4gIHJlYWN0SG90a2V5c0hvb2sudXNlSG90a2V5cygnciwzJywgZnVuY3Rpb24gKGUpIHtcbiAgICB0bHN0YXRlLnNlbGVjdFRvb2woZXhwb3J0cy5UTERyYXdTaGFwZVR5cGUuUmVjdGFuZ2xlKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xuICByZWFjdEhvdGtleXNIb29rLnVzZUhvdGtleXMoJ2UsNCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgdGxzdGF0ZS5zZWxlY3RUb29sKGV4cG9ydHMuVExEcmF3U2hhcGVUeXBlLkVsbGlwc2UpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG4gIHJlYWN0SG90a2V5c0hvb2sudXNlSG90a2V5cygnYSw1JywgZnVuY3Rpb24gKGUpIHtcbiAgICB0bHN0YXRlLnNlbGVjdFRvb2woZXhwb3J0cy5UTERyYXdTaGFwZVR5cGUuQXJyb3cpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG59XG5cbnZhciBUTERyYXdDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQoe30pO1xuZnVuY3Rpb24gdXNlVExEcmF3Q29udGV4dCgpIHtcbiAgdmFyIGNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KFRMRHJhd0NvbnRleHQpO1xuICByZXR1cm4gY29udGV4dDtcbn1cblxuZnVuY3Rpb24gdXNlVGhlbWUoKSB7XG4gIHJldHVybiB7XG4gICAgdGhlbWU6ICdsaWdodCcsXG4gICAgdG9nZ2xlOiBmdW5jdGlvbiB0b2dnbGUoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG59XG5cbnZhciBfY3JlYXRlQ3NzID0gLyojX19QVVJFX18qL3JlYWN0LmNyZWF0ZUNzcyh7XG4gIHRoZW1lTWFwOiAvKiNfX1BVUkVfXyovX2V4dGVuZHMoe30sIHJlYWN0LmRlZmF1bHRUaGVtZU1hcCksXG4gIHRoZW1lOiB7XG4gICAgY29sb3JzOiB7XG4gICAgICBjb2RlSGw6ICdyZ2JhKDE0NCwgMTQ0LCAxNDQsIC4xNSknLFxuICAgICAgYnJ1c2hGaWxsOiAncmdiYSgwLDAsMCwuMDUpJyxcbiAgICAgIGJydXNoU3Ryb2tlOiAncmdiYSgwLDAsMCwuMjUpJyxcbiAgICAgIGhpbnQ6ICdyZ2JhKDIxNiwgMjI2LCAyNDksIDEuMDAwKScsXG4gICAgICBzZWxlY3RlZDogJ3JnYmEoNjYsIDEzMywgMjQ0LCAxLjAwMCknLFxuICAgICAgYm91bmRzOiAncmdiYSg2NSwgMTMyLCAyNDQsIDEuMDAwKScsXG4gICAgICBib3VuZHNCZzogJ3JnYmEoNjUsIDEzMiwgMjQ0LCAwLjA1KScsXG4gICAgICBoaWdobGlnaHQ6ICdyZ2JhKDY1LCAxMzIsIDI0NCwgMC4xNSknLFxuICAgICAgb3ZlcmxheTogJ3JnYmEoMCwgMCwgMCwgMC4xNSknLFxuICAgICAgb3ZlcmxheUNvbnRyYXN0OiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjE1KScsXG4gICAgICBib3JkZXI6ICcjYWFhYWFhJyxcbiAgICAgIGNhbnZhczogJyNmOGY5ZmEnLFxuICAgICAgcGFuZWw6ICcjZmVmZWZlJyxcbiAgICAgIGluYWN0aXZlOiAnI2NjY2NjZicsXG4gICAgICBob3ZlcjogJyNlZmVmZWYnLFxuICAgICAgdGV4dDogJyMzMzMzMzMnLFxuICAgICAgdG9vbHRpcEJnOiAnIzFkMWQxZCcsXG4gICAgICB0b29sdGlwVGV4dDogJyNmZmZmZmYnLFxuICAgICAgbXV0ZWQ6ICcjNzc3Nzc3JyxcbiAgICAgIGlucHV0OiAnI2YzZjNmMycsXG4gICAgICBpbnB1dEJvcmRlcjogJyNkZGRkZGQnLFxuICAgICAgd2FybjogJ3JnYmEoMjU1LCAxMDAsIDEwMCwgMSknLFxuICAgICAgbGluZUVycm9yOiAncmdiYSgyNTUsIDAsIDAsIC4xKSdcbiAgICB9LFxuICAgIHNoYWRvd3M6IHtcbiAgICAgIDI6ICcwcHggMXB4IDFweCByZ2JhKDAsIDAsIDAsIDAuMTQpJyxcbiAgICAgIDM6ICcwcHggMnB4IDNweCByZ2JhKDAsIDAsIDAsIDAuMTQpJyxcbiAgICAgIDQ6ICcwcHggNHB4IDVweCAtMXB4IHJnYmEoMCwgMCwgMCwgMC4xNCknLFxuICAgICAgODogJzBweCAxMnB4IDE3cHggcmdiYSgwLCAwLCAwLCAwLjE0KScsXG4gICAgICAxMjogJzBweCAxMnB4IDE3cHggcmdiYSgwLCAwLCAwLCAwLjE0KScsXG4gICAgICAyNDogJzBweCAyNHB4IDM4cHggcmdiYSgwLCAwLCAwLCAwLjE0KScsXG4gICAgICBrZXk6ICcxcHggMXB4IHJnYmEoMCwwLDAsMSknXG4gICAgfSxcbiAgICBzcGFjZToge1xuICAgICAgMDogJzJweCcsXG4gICAgICAxOiAnM3B4JyxcbiAgICAgIDI6ICc0cHgnLFxuICAgICAgMzogJzhweCcsXG4gICAgICA0OiAnMTJweCcsXG4gICAgICA1OiAnMTZweCdcbiAgICB9LFxuICAgIGZvbnRTaXplczoge1xuICAgICAgMDogJzEwcHgnLFxuICAgICAgMTogJzEycHgnLFxuICAgICAgMjogJzEzcHgnLFxuICAgICAgMzogJzE2cHgnLFxuICAgICAgNDogJzE4cHgnXG4gICAgfSxcbiAgICBmb250czoge1xuICAgICAgdWk6ICdcIlJlY3Vyc2l2ZVwiLCBzeXN0ZW0tdWksIHNhbnMtc2VyaWYnLFxuICAgICAgYm9keTogJ1wiUmVjdXJzaXZlXCIsIHN5c3RlbS11aSwgc2Fucy1zZXJpZicsXG4gICAgICBtb25vOiAnXCJSZWN1cnNpdmUgTW9ub1wiLCBtb25vc3BhY2UnXG4gICAgfSxcbiAgICBmb250V2VpZ2h0czoge30sXG4gICAgbGluZUhlaWdodHM6IHt9LFxuICAgIGxldHRlclNwYWNpbmdzOiB7fSxcbiAgICBzaXplczoge30sXG4gICAgYm9yZGVyV2lkdGhzOiB7XG4gICAgICAwOiAnJDEnXG4gICAgfSxcbiAgICBib3JkZXJTdHlsZXM6IHt9LFxuICAgIHJhZGlpOiB7XG4gICAgICAwOiAnMnB4JyxcbiAgICAgIDE6ICc0cHgnLFxuICAgICAgMjogJzhweCdcbiAgICB9LFxuICAgIHpJbmRpY2VzOiB7fSxcbiAgICB0cmFuc2l0aW9uczoge31cbiAgfSxcbiAgbWVkaWE6IHtcbiAgICBzbTogJyhtaW4td2lkdGg6IDY0MHB4KScsXG4gICAgbWQ6ICcobWluLXdpZHRoOiA3NjhweCknXG4gIH0sXG4gIHV0aWxzOiB7XG4gICAgekRhc2g6IGZ1bmN0aW9uIHpEYXNoKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogXCJjYWxjKFwiICsgdmFsdWUgKyBcInB4IC8gdmFyKC0tY2FtZXJhLXpvb20pKSBjYWxjKFwiICsgdmFsdWUgKyBcInB4IC8gdmFyKC0tY2FtZXJhLXpvb20pKVwiXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH0sXG4gICAgelN0cm9rZVdpZHRoOiBmdW5jdGlvbiB6U3Ryb2tlV2lkdGgoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdHJva2VXaWR0aDogXCJjYWxjKFwiICsgdmFsdWVbMF0gKyBcInB4IC8gdmFyKC0tY2FtZXJhLXpvb20pKVwiXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiY2FsYyhcIiArIHZhbHVlICsgXCJweCAvIHZhcigtLWNhbWVyYS16b29tKSlcIlxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9XG4gIH1cbn0pLFxuICAgIHN0eWxlZCA9IF9jcmVhdGVDc3Muc3R5bGVkO1xuXG5mdW5jdGlvbiBjb21tYW5kS2V5KCkge1xuICByZXR1cm4gY29yZS5VdGlscy5pc0RhcndpbigpID8gJ+KMmCcgOiAnQ3RybCc7XG59XG5mdW5jdGlvbiBLYmQoX3JlZikge1xuICB2YXIgdmFyaWFudCA9IF9yZWYudmFyaWFudCxcbiAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcbiAgaWYgKGNvcmUuVXRpbHMuaXNNb2JpbGUoKSkgcmV0dXJuIG51bGw7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFN0eWxlZEtiZCwge1xuICAgIHZhcmlhbnQ6IHZhcmlhbnRcbiAgfSwgY2hpbGRyZW4ucmVwbGFjZUFsbCgnIycsIGNvbW1hbmRLZXkoKSkuc3BsaXQoJycpLm1hcChmdW5jdGlvbiAoaywgaSkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICBrZXk6IGlcbiAgICB9LCBrKTtcbiAgfSkpO1xufVxudmFyIFN0eWxlZEtiZCA9IC8qI19fUFVSRV9fKi9zdHlsZWQoJ2tiZCcsIHtcbiAgbWFyZ2luTGVmdDogJyQzJyxcbiAgdGV4dFNoYWRvdzogJyQyJyxcbiAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgZm9udFNpemU6ICckMCcsXG4gIGZvbnRGYW1pbHk6ICckdWknLFxuICBmb250V2VpZ2h0OiA0MDAsXG4gIGdhcDogJyQxJyxcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgJyYgPiBzcGFuJzoge1xuICAgIHBhZGRpbmc6ICckMCcsXG4gICAgYm9yZGVyUmFkaXVzOiAnJDAnLFxuICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcidcbiAgfSxcbiAgdmFyaWFudHM6IHtcbiAgICB2YXJpYW50OiB7XG4gICAgICB0b29sdGlwOiB7XG4gICAgICAgICcmID4gc3Bhbic6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiAnJG92ZXJsYXlDb250cmFzdCcsXG4gICAgICAgICAgYm94U2hhZG93OiAnJGtleScsXG4gICAgICAgICAgd2lkdGg6ICcyMHB4JyxcbiAgICAgICAgICBoZWlnaHQ6ICcyMHB4J1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWVudToge31cbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBUb29sdGlwKF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGxhYmVsID0gX3JlZi5sYWJlbCxcbiAgICAgIGtiZCA9IF9yZWYua2JkLFxuICAgICAgX3JlZiRzaWRlID0gX3JlZi5zaWRlLFxuICAgICAgc2lkZSA9IF9yZWYkc2lkZSA9PT0gdm9pZCAwID8gJ3RvcCcgOiBfcmVmJHNpZGU7XG4gIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJhZGl4VG9vbHRpcC5Sb290LCBudWxsLCBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJhZGl4VG9vbHRpcC5UcmlnZ2VyLCB7XG4gICAgYXM6IFwic3BhblwiXG4gIH0sIGNoaWxkcmVuKSwgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTdHlsZWRDb250ZW50LCB7XG4gICAgc2lkZTogc2lkZSxcbiAgICBzaWRlT2Zmc2V0OiA4XG4gIH0sIGxhYmVsLCBrYmQgPyBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEtiZCwge1xuICAgIHZhcmlhbnQ6IFwidG9vbHRpcFwiXG4gIH0sIGtiZCkgOiBudWxsLCBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFN0eWxlZEFycm93LCBudWxsKSkpO1xufVxudmFyIFN0eWxlZENvbnRlbnQgPSAvKiNfX1BVUkVfXyovc3R5bGVkKFJhZGl4VG9vbHRpcC5Db250ZW50LCB7XG4gIGJvcmRlclJhZGl1czogMyxcbiAgcGFkZGluZzogJyQzICQzICQzICQzJyxcbiAgZm9udFNpemU6ICckMScsXG4gIGJhY2tncm91bmRDb2xvcjogJyR0b29sdGlwQmcnLFxuICBjb2xvcjogJyR0b29sdGlwVGV4dCcsXG4gIGJveFNoYWRvdzogJyQzJyxcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgZm9udEZhbWlseTogJyR1aSdcbn0pO1xudmFyIFN0eWxlZEFycm93ID0gLyojX19QVVJFX18qL3N0eWxlZChSYWRpeFRvb2x0aXAuQXJyb3csIHtcbiAgZmlsbDogJyR0b29sdGlwQmcnLFxuICBtYXJnaW46ICcwIDhweCdcbn0pO1xuXG52YXIgX2V4Y2x1ZGVkID0gW1wic2l6ZVwiXTtcblxudmFyIF9wYWdlQnV0dG9uO1xudmFyIGJyZWFrcG9pbnRzID0ge1xuICAnQGluaXRpYWwnOiAnbW9iaWxlJyxcbiAgJ0BzbSc6ICdzbWFsbCdcbn07XG52YXIgSWNvbkJ1dHRvbiA9IC8qI19fUFVSRV9fKi9zdHlsZWQoJ2J1dHRvbicsIHtcbiAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gIGhlaWdodDogJzMycHgnLFxuICB3aWR0aDogJzMycHgnLFxuICBiYWNrZ3JvdW5kQ29sb3I6ICckcGFuZWwnLFxuICBib3JkZXJSYWRpdXM6ICc0cHgnLFxuICBwYWRkaW5nOiAnMCcsXG4gIG1hcmdpbjogJzAnLFxuICBkaXNwbGF5OiAnZ3JpZCcsXG4gIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gIG91dGxpbmU6ICdub25lJyxcbiAgYm9yZGVyOiAnbm9uZScsXG4gIHBvaW50ZXJFdmVudHM6ICdhbGwnLFxuICBmb250U2l6ZTogJyQwJyxcbiAgY29sb3I6ICckdGV4dCcsXG4gIGN1cnNvcjogJ3BvaW50ZXInLFxuICAnJiA+IConOiB7XG4gICAgZ3JpZFJvdzogMSxcbiAgICBncmlkQ29sdW1uOiAxXG4gIH0sXG4gICcmOmRpc2FibGVkJzoge1xuICAgIG9wYWNpdHk6ICcwLjUnXG4gIH0sXG4gICcmID4gc3Bhbic6IHtcbiAgICB3aWR0aDogJzEwMCUnLFxuICAgIGhlaWdodDogJzEwMCUnLFxuICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJ1xuICB9LFxuICB2YXJpYW50czoge1xuICAgIGJwOiB7XG4gICAgICBtb2JpbGU6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnXG4gICAgICB9LFxuICAgICAgc21hbGw6IHtcbiAgICAgICAgJyY6aG92ZXI6bm90KDpkaXNhYmxlZCknOiB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnJGhvdmVyJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBzaXplOiB7XG4gICAgICBzbWFsbDoge1xuICAgICAgICBoZWlnaHQ6IDMyLFxuICAgICAgICB3aWR0aDogMzIsXG4gICAgICAgICcmIHN2ZzpudGgtb2YtdHlwZSgxKSc6IHtcbiAgICAgICAgICBoZWlnaHQ6ICcxNnB4JyxcbiAgICAgICAgICB3aWR0aDogJzE2cHgnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtZWRpdW06IHtcbiAgICAgICAgaGVpZ2h0OiA0NCxcbiAgICAgICAgd2lkdGg6IDQ0LFxuICAgICAgICAnJiBzdmc6bnRoLW9mLXR5cGUoMSknOiB7XG4gICAgICAgICAgaGVpZ2h0OiAnMThweCcsXG4gICAgICAgICAgd2lkdGg6ICcxOHB4J1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbGFyZ2U6IHtcbiAgICAgICAgaGVpZ2h0OiA0NCxcbiAgICAgICAgd2lkdGg6IDQ0LFxuICAgICAgICAnJiBzdmc6bnRoLW9mLXR5cGUoMSknOiB7XG4gICAgICAgICAgaGVpZ2h0OiAnMjBweCcsXG4gICAgICAgICAgd2lkdGg6ICcyMHB4J1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBpc0FjdGl2ZToge1xuICAgICAgXCJ0cnVlXCI6IHtcbiAgICAgICAgY29sb3I6ICckc2VsZWN0ZWQnXG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbnZhciBSb3dCdXR0b24gPSAvKiNfX1BVUkVfXyovc3R5bGVkKCdidXR0b24nLCB7XG4gIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHdpZHRoOiAnMTAwJScsXG4gIGJhY2tncm91bmQ6ICdub25lJyxcbiAgaGVpZ2h0OiAnMzJweCcsXG4gIGJvcmRlcjogJ25vbmUnLFxuICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgY29sb3I6ICckdGV4dCcsXG4gIG91dGxpbmU6ICdub25lJyxcbiAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gIGZvbnRGYW1pbHk6ICckdWknLFxuICBmb250V2VpZ2h0OiA0MDAsXG4gIGZvbnRTaXplOiAnJDEnLFxuICBqdXN0aWZ5Q29udGVudDogJ3NwYWNlLWJldHdlZW4nLFxuICBwYWRkaW5nOiAnNHB4IDhweCA0cHggMTJweCcsXG4gIGJvcmRlclJhZGl1czogNCxcbiAgdXNlclNlbGVjdDogJ25vbmUnLFxuICAnJiBsYWJlbCc6IHtcbiAgICBmb250V2VpZ2h0OiAnJDEnLFxuICAgIG1hcmdpbjogMCxcbiAgICBwYWRkaW5nOiAwXG4gIH0sXG4gICcmIHN2Zyc6IHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICBzdHJva2U6ICckb3ZlcmxheScsXG4gICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgekluZGV4OiAxXG4gIH0sXG4gICcmW2RhdGEtZGlzYWJsZWRdJzoge1xuICAgIG9wYWNpdHk6IDAuM1xuICB9LFxuICAnJjpkaXNhYmxlZCc6IHtcbiAgICBvcGFjaXR5OiAwLjNcbiAgfSxcbiAgdmFyaWFudHM6IHtcbiAgICBicDoge1xuICAgICAgbW9iaWxlOiB7fSxcbiAgICAgIHNtYWxsOiB7XG4gICAgICAgICcmICpbZGF0YS1zaHk9XCJ0cnVlXCJdJzoge1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSxcbiAgICAgICAgJyY6aG92ZXI6bm90KDpkaXNhYmxlZCknOiB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnJGhvdmVyJyxcbiAgICAgICAgICAnJiAqW2RhdGEtc2h5PVwidHJ1ZVwiXSc6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHNpemU6IHtcbiAgICAgIGljb246IHtcbiAgICAgICAgcGFkZGluZzogJzRweCAnLFxuICAgICAgICB3aWR0aDogJ2F1dG8nXG4gICAgICB9XG4gICAgfSxcbiAgICB2YXJpYW50OiB7XG4gICAgICBub0ljb246IHtcbiAgICAgICAgcGFkZGluZzogJzRweCAxMnB4J1xuICAgICAgfSxcbiAgICAgIHBhZ2VCdXR0b246IChfcGFnZUJ1dHRvbiA9IHtcbiAgICAgICAgZGlzcGxheTogJ2dyaWQnLFxuICAgICAgICBncmlkVGVtcGxhdGVDb2x1bW5zOiAnMjRweCBhdXRvJyxcbiAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgcGFkZGluZ0xlZnQ6ICckMScsXG4gICAgICAgIGdhcDogJyQzJyxcbiAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdmbGV4LXN0YXJ0J1xuICAgICAgfSwgX3BhZ2VCdXR0b25bXCImID4gKltkYXRhLXN0YXRlPVxcXCJjaGVja2VkXFxcIl1cIl0gPSB7XG4gICAgICAgIGdyaWRSb3c6IDEsXG4gICAgICAgIGdyaWRDb2x1bW46IDFcbiAgICAgIH0sIF9wYWdlQnV0dG9uWycmID4gc3BhbiddID0ge1xuICAgICAgICBncmlkUm93OiAxLFxuICAgICAgICBncmlkQ29sdW1uOiAyLFxuICAgICAgICB3aWR0aDogJzEwMCUnXG4gICAgICB9LCBfcGFnZUJ1dHRvbilcbiAgICB9LFxuICAgIHdhcm46IHtcbiAgICAgIFwidHJ1ZVwiOiB7XG4gICAgICAgIGNvbG9yOiAnJHdhcm4nXG4gICAgICB9XG4gICAgfSxcbiAgICBpc0FjdGl2ZToge1xuICAgICAgXCJ0cnVlXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnJGhvdmVyJ1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG52YXIgSWNvbldyYXBwZXIgPSAvKiNfX1BVUkVfXyovc3R5bGVkKCdkaXYnLCB7XG4gIGhlaWdodDogJzEwMCUnLFxuICBib3JkZXJSYWRpdXM6ICc0cHgnLFxuICBtYXJnaW5SaWdodDogJzFweCcsXG4gIGRpc3BsYXk6ICdncmlkJyxcbiAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcbiAgb3V0bGluZTogJ25vbmUnLFxuICBib3JkZXI6ICdub25lJyxcbiAgcG9pbnRlckV2ZW50czogJ2FsbCcsXG4gIGN1cnNvcjogJ3BvaW50ZXInLFxuICBjb2xvcjogJyR0ZXh0JyxcbiAgJyYgc3ZnJzoge1xuICAgIGhlaWdodDogMjIsXG4gICAgd2lkdGg6IDIyLFxuICAgIHN0cm9rZVdpZHRoOiAxXG4gIH0sXG4gICcmID4gKic6IHtcbiAgICBncmlkUm93OiAxLFxuICAgIGdyaWRDb2x1bW46IDFcbiAgfSxcbiAgdmFyaWFudHM6IHtcbiAgICBzaXplOiB7XG4gICAgICBzbWFsbDoge1xuICAgICAgICAnJiBzdmcnOiB7XG4gICAgICAgICAgaGVpZ2h0OiAnMTZweCcsXG4gICAgICAgICAgd2lkdGg6ICcxNnB4J1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWVkaXVtOiB7XG4gICAgICAgICcmIHN2Zyc6IHtcbiAgICAgICAgICBoZWlnaHQ6ICcyMnB4JyxcbiAgICAgICAgICB3aWR0aDogJzIycHgnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xudmFyIEJ1dHRvbnNSb3cgPSAvKiNfX1BVUkVfXyovc3R5bGVkKCdkaXYnLCB7XG4gIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHdpZHRoOiAnMTAwJScsXG4gIGJhY2tncm91bmQ6ICdub25lJyxcbiAgYm9yZGVyOiAnbm9uZScsXG4gIGN1cnNvcjogJ3BvaW50ZXInLFxuICBvdXRsaW5lOiAnbm9uZScsXG4gIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICBqdXN0aWZ5Q29udGVudDogJ2ZsZXgtc3RhcnQnLFxuICBwYWRkaW5nOiAwXG59KTtcbnZhciBGbG9hdGluZ0NvbnRhaW5lciA9IC8qI19fUFVSRV9fKi9zdHlsZWQoJ2RpdicsIHtcbiAgYmFja2dyb3VuZENvbG9yOiAnJHBhbmVsJyxcbiAgYm9yZGVyOiAnMXB4IHNvbGlkICRwYW5lbCcsXG4gIGJvcmRlclJhZGl1czogJzRweCcsXG4gIGJveFNoYWRvdzogJyQ0JyxcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICBoZWlnaHQ6ICdmaXQtY29udGVudCcsXG4gIHBhZGRpbmc6ICckMCcsXG4gIHBvaW50ZXJFdmVudHM6ICdhbGwnLFxuICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgdXNlclNlbGVjdDogJ25vbmUnLFxuICB6SW5kZXg6IDIwMCxcbiAgdmFyaWFudHM6IHtcbiAgICBkaXJlY3Rpb246IHtcbiAgICAgIHJvdzoge1xuICAgICAgICBmbGV4RGlyZWN0aW9uOiAncm93J1xuICAgICAgfSxcbiAgICAgIGNvbHVtbjoge1xuICAgICAgICBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJ1xuICAgICAgfVxuICAgIH0sXG4gICAgZWxldmF0aW9uOiB7XG4gICAgICAwOiB7XG4gICAgICAgIGJveFNoYWRvdzogJ25vbmUnXG4gICAgICB9LFxuICAgICAgMjoge1xuICAgICAgICBib3hTaGFkb3c6ICckMidcbiAgICAgIH0sXG4gICAgICAzOiB7XG4gICAgICAgIGJveFNoYWRvdzogJyQzJ1xuICAgICAgfSxcbiAgICAgIDQ6IHtcbiAgICAgICAgYm94U2hhZG93OiAnJDQnXG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbi8qICAgICAgICAgICAgICAgICAgICAgICAgTWVudXMgICAgICAgICAgICAgICAgICAgICAgICovXG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbnZhciBNZW51Q29udGVudCA9IC8qI19fUFVSRV9fKi9zdHlsZWQoJ2RpdicsIHtcbiAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgdXNlclNlbGVjdDogJ25vbmUnLFxuICB6SW5kZXg6IDE4MCxcbiAgbWluV2lkdGg6IDE4MCxcbiAgcG9pbnRlckV2ZW50czogJ2FsbCcsXG4gIGJhY2tncm91bmRDb2xvcjogJyRwYW5lbCcsXG4gIGJvcmRlcjogJzFweCBzb2xpZCAkcGFuZWwnLFxuICBwYWRkaW5nOiAnJDAnLFxuICBib3hTaGFkb3c6ICckNCcsXG4gIGJvcmRlclJhZGl1czogJzRweCcsXG4gIGZvbnQ6ICckdWknXG59KTtcbnZhciBEaXZpZGVyID0gLyojX19QVVJFX18qL3N0eWxlZCgnZGl2Jywge1xuICBiYWNrZ3JvdW5kQ29sb3I6ICckaG92ZXInLFxuICBoZWlnaHQ6IDEsXG4gIG1hcmdpblRvcDogJyQyJyxcbiAgbWFyZ2luUmlnaHQ6ICctJDInLFxuICBtYXJnaW5Cb3R0b206ICckMicsXG4gIG1hcmdpbkxlZnQ6ICctJDInXG59KTtcbmZ1bmN0aW9uIERyb3Bkb3duTWVudUljb25UcmlnZ2VyQnV0dG9uKF9yZWY2KSB7XG4gIHZhciBsYWJlbCA9IF9yZWY2LmxhYmVsLFxuICAgICAga2JkID0gX3JlZjYua2JkLFxuICAgICAgY2hpbGRyZW4gPSBfcmVmNi5jaGlsZHJlbixcbiAgICAgIF9yZWY2JGRpc2FibGVkID0gX3JlZjYuZGlzYWJsZWQsXG4gICAgICBkaXNhYmxlZCA9IF9yZWY2JGRpc2FibGVkID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWY2JGRpc2FibGVkO1xuICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChEcm9wZG93bk1lbnUuVHJpZ2dlciwge1xuICAgIGFzOiBJY29uQnV0dG9uLFxuICAgIGJwOiBicmVha3BvaW50cyxcbiAgICBkaXNhYmxlZDogZGlzYWJsZWRcbiAgfSwgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChUb29sdGlwLCB7XG4gICAgbGFiZWw6IGxhYmVsLFxuICAgIGtiZDoga2JkXG4gIH0sIGNoaWxkcmVuKSk7XG59XG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4vKiAgICAgICAgICAgICAgICAgICAgQ29udGV4dCBNZW51ICAgICAgICAgICAgICAgICAgICovXG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbmZ1bmN0aW9uIENvbnRleHRNZW51Um9vdChfcmVmOCkge1xuICB2YXIgb25PcGVuQ2hhbmdlID0gX3JlZjgub25PcGVuQ2hhbmdlLFxuICAgICAgY2hpbGRyZW4gPSBfcmVmOC5jaGlsZHJlbjtcbiAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmFkaXhDb250ZXh0TWVudS5Sb290LCB7XG4gICAgZGlyOiBcImx0clwiLFxuICAgIG9uT3BlbkNoYW5nZTogb25PcGVuQ2hhbmdlXG4gIH0sIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIENvbnRleHRNZW51U3ViTWVudShfcmVmOSkge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmOS5jaGlsZHJlbixcbiAgICAgIGxhYmVsID0gX3JlZjkubGFiZWw7XG4gIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJhZGl4Q29udGV4dE1lbnUuUm9vdCwge1xuICAgIGRpcjogXCJsdHJcIlxuICB9LCBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJhZGl4Q29udGV4dE1lbnUuVHJpZ2dlckl0ZW0sIHtcbiAgICBhczogUm93QnV0dG9uLFxuICAgIGJwOiBicmVha3BvaW50c1xuICB9LCBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCBsYWJlbCksIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoSWNvbldyYXBwZXIsIHtcbiAgICBzaXplOiBcInNtYWxsXCJcbiAgfSwgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChyZWFjdEljb25zLkNoZXZyb25SaWdodEljb24sIG51bGwpKSksIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmFkaXhDb250ZXh0TWVudS5Db250ZW50LCB7XG4gICAgYXM6IE1lbnVDb250ZW50LFxuICAgIHNpZGVPZmZzZXQ6IDIsXG4gICAgYWxpZ25PZmZzZXQ6IC0yXG4gIH0sIGNoaWxkcmVuLCBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KENvbnRleHRNZW51QXJyb3csIHtcbiAgICBvZmZzZXQ6IDEzXG4gIH0pKSk7XG59XG52YXIgQ29udGV4dE1lbnVEaXZpZGVyID0gLyojX19QVVJFX18qL3N0eWxlZChSYWRpeENvbnRleHRNZW51LlNlcGFyYXRvciwge1xuICBiYWNrZ3JvdW5kQ29sb3I6ICckaG92ZXInLFxuICBoZWlnaHQ6IDEsXG4gIG1hcmdpbjogJyQyIC0kMidcbn0pO1xudmFyIENvbnRleHRNZW51QXJyb3cgPSAvKiNfX1BVUkVfXyovc3R5bGVkKFJhZGl4Q29udGV4dE1lbnUuQXJyb3csIHtcbiAgZmlsbDogJyRwYW5lbCdcbn0pO1xuZnVuY3Rpb24gQ29udGV4dE1lbnVCdXR0b24oX3JlZjEwKSB7XG4gIHZhciBvblNlbGVjdCA9IF9yZWYxMC5vblNlbGVjdCxcbiAgICAgIGNoaWxkcmVuID0gX3JlZjEwLmNoaWxkcmVuLFxuICAgICAgX3JlZjEwJGRpc2FibGVkID0gX3JlZjEwLmRpc2FibGVkLFxuICAgICAgZGlzYWJsZWQgPSBfcmVmMTAkZGlzYWJsZWQgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjEwJGRpc2FibGVkO1xuICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChSb3dCdXR0b24sIHtcbiAgICBhczogUmFkaXhDb250ZXh0TWVudS5JdGVtLFxuICAgIGJwOiBicmVha3BvaW50cyxcbiAgICBkaXNhYmxlZDogZGlzYWJsZWQsXG4gICAgb25TZWxlY3Q6IG9uU2VsZWN0XG4gIH0sIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIENvbnRleHRNZW51SWNvbkJ1dHRvbihfcmVmMTEpIHtcbiAgdmFyIG9uU2VsZWN0ID0gX3JlZjExLm9uU2VsZWN0LFxuICAgICAgY2hpbGRyZW4gPSBfcmVmMTEuY2hpbGRyZW4sXG4gICAgICBfcmVmMTEkZGlzYWJsZWQgPSBfcmVmMTEuZGlzYWJsZWQsXG4gICAgICBkaXNhYmxlZCA9IF9yZWYxMSRkaXNhYmxlZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMTEkZGlzYWJsZWQ7XG4gIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJhZGl4Q29udGV4dE1lbnUuSXRlbSwge1xuICAgIGFzOiBJY29uQnV0dG9uLFxuICAgIGJwOiBicmVha3BvaW50cyxcbiAgICBkaXNhYmxlZDogZGlzYWJsZWQsXG4gICAgb25TZWxlY3Q6IG9uU2VsZWN0XG4gIH0sIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIENpcmNsZUljb24ocHJvcHMpIHtcbiAgdmFyIF9wcm9wcyRzaXplID0gcHJvcHMuc2l6ZSxcbiAgICAgIHNpemUgPSBfcHJvcHMkc2l6ZSA9PT0gdm9pZCAwID8gMTYgOiBfcHJvcHMkc2l6ZSxcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkKTtcblxuICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInN2Z1wiLCBfZXh0ZW5kcyh7XG4gICAgd2lkdGg6IDI0LFxuICAgIGhlaWdodDogMjRcbiAgfSwgcmVzdCksIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIiwge1xuICAgIGN4OiAxMixcbiAgICBjeTogMTIsXG4gICAgcjogc2l6ZSAvIDJcbiAgfSkpO1xufVxuXG4oZnVuY3Rpb24gKE1vdmVUeXBlKSB7XG4gIE1vdmVUeXBlW1wiQmFja3dhcmRcIl0gPSBcImJhY2t3YXJkXCI7XG4gIE1vdmVUeXBlW1wiRm9yd2FyZFwiXSA9IFwiZm9yd2FyZFwiO1xuICBNb3ZlVHlwZVtcIlRvRnJvbnRcIl0gPSBcInRvRnJvbnRcIjtcbiAgTW92ZVR5cGVbXCJUb0JhY2tcIl0gPSBcInRvQmFja1wiO1xufSkoZXhwb3J0cy5Nb3ZlVHlwZSB8fCAoZXhwb3J0cy5Nb3ZlVHlwZSA9IHt9KSk7XG5cbihmdW5jdGlvbiAoQWxpZ25UeXBlKSB7XG4gIEFsaWduVHlwZVtcIlRvcFwiXSA9IFwidG9wXCI7XG4gIEFsaWduVHlwZVtcIkNlbnRlclZlcnRpY2FsXCJdID0gXCJjZW50ZXJWZXJ0aWNhbFwiO1xuICBBbGlnblR5cGVbXCJCb3R0b21cIl0gPSBcImJvdHRvbVwiO1xuICBBbGlnblR5cGVbXCJMZWZ0XCJdID0gXCJsZWZ0XCI7XG4gIEFsaWduVHlwZVtcIkNlbnRlckhvcml6b250YWxcIl0gPSBcImNlbnRlckhvcml6b250YWxcIjtcbiAgQWxpZ25UeXBlW1wiUmlnaHRcIl0gPSBcInJpZ2h0XCI7XG59KShleHBvcnRzLkFsaWduVHlwZSB8fCAoZXhwb3J0cy5BbGlnblR5cGUgPSB7fSkpO1xuXG4oZnVuY3Rpb24gKFN0cmV0Y2hUeXBlKSB7XG4gIFN0cmV0Y2hUeXBlW1wiSG9yaXpvbnRhbFwiXSA9IFwiaG9yaXpvbnRhbFwiO1xuICBTdHJldGNoVHlwZVtcIlZlcnRpY2FsXCJdID0gXCJ2ZXJ0aWNhbFwiO1xufSkoZXhwb3J0cy5TdHJldGNoVHlwZSB8fCAoZXhwb3J0cy5TdHJldGNoVHlwZSA9IHt9KSk7XG5cbihmdW5jdGlvbiAoRGlzdHJpYnV0ZVR5cGUpIHtcbiAgRGlzdHJpYnV0ZVR5cGVbXCJIb3Jpem9udGFsXCJdID0gXCJob3Jpem9udGFsXCI7XG4gIERpc3RyaWJ1dGVUeXBlW1wiVmVydGljYWxcIl0gPSBcInZlcnRpY2FsXCI7XG59KShleHBvcnRzLkRpc3RyaWJ1dGVUeXBlIHx8IChleHBvcnRzLkRpc3RyaWJ1dGVUeXBlID0ge30pKTtcblxudmFyIGhhczFTZWxlY3RlZElkc1NlbGVjdG9yID0gZnVuY3Rpb24gaGFzMVNlbGVjdGVkSWRzU2VsZWN0b3Iocykge1xuICByZXR1cm4gcy5wYWdlU3RhdGUuc2VsZWN0ZWRJZHMubGVuZ3RoID4gMDtcbn07XG5cbnZhciBoYXMyU2VsZWN0ZWRJZHNTZWxlY3RvciA9IGZ1bmN0aW9uIGhhczJTZWxlY3RlZElkc1NlbGVjdG9yKHMpIHtcbiAgcmV0dXJuIHMucGFnZVN0YXRlLnNlbGVjdGVkSWRzLmxlbmd0aCA+IDE7XG59O1xuXG52YXIgaGFzM1NlbGVjdGVkSWRzU2VsZWN0b3IgPSBmdW5jdGlvbiBoYXMzU2VsZWN0ZWRJZHNTZWxlY3RvcihzKSB7XG4gIHJldHVybiBzLnBhZ2VTdGF0ZS5zZWxlY3RlZElkcy5sZW5ndGggPiAyO1xufTtcblxudmFyIGlzRGVidWdNb2RlU2VsZWN0b3IgPSBmdW5jdGlvbiBpc0RlYnVnTW9kZVNlbGVjdG9yKHMpIHtcbiAgcmV0dXJuIHMuc2V0dGluZ3MuaXNEZWJ1Z01vZGU7XG59O1xuXG52YXIgaGFzR3JvdXBTZWxlY3RlZFNlbGVjdG9yID0gZnVuY3Rpb24gaGFzR3JvdXBTZWxlY3RlZFNlbGVjdG9yKHMpIHtcbiAgcmV0dXJuIHMucGFnZVN0YXRlLnNlbGVjdGVkSWRzLnNvbWUoZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIHMucGFnZS5zaGFwZXNbaWRdLmNoaWxkcmVuICE9PSB1bmRlZmluZWQ7XG4gIH0pO1xufTtcblxudmFyIENvbnRleHRNZW51ID0gLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcblxuICB2YXIgX3VzZVRMRHJhd0NvbnRleHQgPSB1c2VUTERyYXdDb250ZXh0KCksXG4gICAgICB0bHN0YXRlID0gX3VzZVRMRHJhd0NvbnRleHQudGxzdGF0ZSxcbiAgICAgIHVzZUFwcFN0YXRlID0gX3VzZVRMRHJhd0NvbnRleHQudXNlQXBwU3RhdGU7XG5cbiAgdmFyIGhhc1NlbGVjdGlvbiA9IHVzZUFwcFN0YXRlKGhhczFTZWxlY3RlZElkc1NlbGVjdG9yKTtcbiAgdmFyIGhhc1R3b09yTW9yZSA9IHVzZUFwcFN0YXRlKGhhczJTZWxlY3RlZElkc1NlbGVjdG9yKTtcbiAgdmFyIGhhc1RocmVlT3JNb3JlID0gdXNlQXBwU3RhdGUoaGFzM1NlbGVjdGVkSWRzU2VsZWN0b3IpO1xuICB2YXIgaXNEZWJ1Z01vZGUgPSB1c2VBcHBTdGF0ZShpc0RlYnVnTW9kZVNlbGVjdG9yKTtcbiAgdmFyIGhhc0dyb3VwU2VsZWN0ZWQgPSB1c2VBcHBTdGF0ZShoYXNHcm91cFNlbGVjdGVkU2VsZWN0b3IpO1xuICB2YXIgckNvbnRlbnQgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHZhciBoYW5kbGVEdXBsaWNhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5kdXBsaWNhdGUoKTtcbiAgfSwgW3Rsc3RhdGVdKTtcbiAgdmFyIGhhbmRsZUdyb3VwID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHRsc3RhdGUuZ3JvdXAoKTtcbiAgfSwgW3Rsc3RhdGVdKTtcbiAgdmFyIGhhbmRsZU1vdmVUb0JhY2sgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5tb3ZlVG9CYWNrKCk7XG4gIH0sIFt0bHN0YXRlXSk7XG4gIHZhciBoYW5kbGVNb3ZlQmFja3dhcmQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5tb3ZlQmFja3dhcmQoKTtcbiAgfSwgW3Rsc3RhdGVdKTtcbiAgdmFyIGhhbmRsZU1vdmVGb3J3YXJkID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHRsc3RhdGUubW92ZUZvcndhcmQoKTtcbiAgfSwgW3Rsc3RhdGVdKTtcbiAgdmFyIGhhbmRsZU1vdmVUb0Zyb250ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHRsc3RhdGUubW92ZVRvRnJvbnQoKTtcbiAgfSwgW3Rsc3RhdGVdKTtcbiAgdmFyIGhhbmRsZURlbGV0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB0bHN0YXRlW1wiZGVsZXRlXCJdKCk7XG4gIH0sIFt0bHN0YXRlXSk7XG4gIHZhciBoYW5kbGVDb3B5QXNKc29uID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHRsc3RhdGUuY29weUFzSnNvbigpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICB2YXIgaGFuZGxlQ29weUFzU3ZnID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHRsc3RhdGUuY29weUFzU3ZnKCk7XG4gIH0sIFt0bHN0YXRlXSk7XG4gIHZhciBoYW5kbGVVbmRvID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHRsc3RhdGUudW5kbygpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICB2YXIgaGFuZGxlUmVkbyA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB0bHN0YXRlLnJlZG8oKTtcbiAgfSwgW3Rsc3RhdGVdKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dE1lbnVSb290LCBudWxsLCBSZWFjdC5jcmVhdGVFbGVtZW50KFJhZGl4Q29udGV4dE1lbnUuVHJpZ2dlciwgbnVsbCwgY2hpbGRyZW4pLCBSZWFjdC5jcmVhdGVFbGVtZW50KE1lbnVDb250ZW50LCB7XG4gICAgYXM6IFJhZGl4Q29udGV4dE1lbnUuQ29udGVudCxcbiAgICByZWY6IHJDb250ZW50XG4gIH0sIGhhc1NlbGVjdGlvbiA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dE1lbnVCdXR0b24sIHtcbiAgICBvblNlbGVjdDogaGFuZGxlRHVwbGljYXRlXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIFwiRHVwbGljYXRlXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEtiZCwge1xuICAgIHZhcmlhbnQ6IFwibWVudVwiXG4gIH0sIFwiI0RcIikpLCBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHRNZW51RGl2aWRlciwgbnVsbCksIGhhc0dyb3VwU2VsZWN0ZWQgfHwgaGFzVHdvT3JNb3JlICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGhhc0dyb3VwU2VsZWN0ZWQgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0TWVudUJ1dHRvbiwge1xuICAgIG9uU2VsZWN0OiBoYW5kbGVHcm91cFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCBcIlVuZ3JvdXBcIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoS2JkLCB7XG4gICAgdmFyaWFudDogXCJtZW51XCJcbiAgfSwgXCIjXFx1MjFFN0dcIikpLCBoYXNUd29Pck1vcmUgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0TWVudUJ1dHRvbiwge1xuICAgIG9uU2VsZWN0OiBoYW5kbGVHcm91cFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCBcIkdyb3VwXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEtiZCwge1xuICAgIHZhcmlhbnQ6IFwibWVudVwiXG4gIH0sIFwiI0dcIikpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0TWVudVN1Yk1lbnUsIHtcbiAgICBsYWJlbDogXCJNb3ZlXCJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0TWVudUJ1dHRvbiwge1xuICAgIG9uU2VsZWN0OiBoYW5kbGVNb3ZlVG9Gcm9udFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCBcIlRvIEZyb250XCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEtiZCwge1xuICAgIHZhcmlhbnQ6IFwibWVudVwiXG4gIH0sIFwiIyBcXHUyMUU3IF1cIikpLCBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHRNZW51QnV0dG9uLCB7XG4gICAgb25TZWxlY3Q6IGhhbmRsZU1vdmVGb3J3YXJkXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIFwiRm9yd2FyZFwiKSwgUmVhY3QuY3JlYXRlRWxlbWVudChLYmQsIHtcbiAgICB2YXJpYW50OiBcIm1lbnVcIlxuICB9LCBcIiMgXVwiKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dE1lbnVCdXR0b24sIHtcbiAgICBvblNlbGVjdDogaGFuZGxlTW92ZUJhY2t3YXJkXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIFwiQmFja3dhcmRcIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoS2JkLCB7XG4gICAgdmFyaWFudDogXCJtZW51XCJcbiAgfSwgXCIjIFtcIikpLCBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHRNZW51QnV0dG9uLCB7XG4gICAgb25TZWxlY3Q6IGhhbmRsZU1vdmVUb0JhY2tcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgXCJUbyBCYWNrXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEtiZCwge1xuICAgIHZhcmlhbnQ6IFwibWVudVwiXG4gIH0sIFwiIyBcXHUyMUU3IFtcIikpKSwgaGFzVHdvT3JNb3JlICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQWxpZ25EaXN0cmlidXRlU3ViTWVudSwge1xuICAgIGhhc1R3b09yTW9yZTogaGFzVHdvT3JNb3JlLFxuICAgIGhhc1RocmVlT3JNb3JlOiBoYXNUaHJlZU9yTW9yZVxuICB9KSwgaXNEZWJ1Z01vZGUgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0TWVudUJ1dHRvbiwge1xuICAgIG9uU2VsZWN0OiBoYW5kbGVDb3B5QXNKc29uXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIFwiQ29weSBEYXRhXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEtiZCwge1xuICAgIHZhcmlhbnQ6IFwibWVudVwiXG4gIH0sIFwiIyBcXHUyMUU3IENcIikpLCBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHRNZW51QnV0dG9uLCB7XG4gICAgb25TZWxlY3Q6IGhhbmRsZUNvcHlBc1N2Z1xuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCBcIkNvcHkgdG8gU1ZHXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEtiZCwge1xuICAgIHZhcmlhbnQ6IFwibWVudVwiXG4gIH0sIFwiIyBcXHUyMUU3IENcIikpLCBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHRNZW51RGl2aWRlciwgbnVsbCksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dE1lbnVCdXR0b24sIHtcbiAgICBvblNlbGVjdDogaGFuZGxlRGVsZXRlXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIFwiRGVsZXRlXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEtiZCwge1xuICAgIHZhcmlhbnQ6IFwibWVudVwiXG4gIH0sIFwiXFx1MjMyQlwiKSkpIDogUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0TWVudUJ1dHRvbiwge1xuICAgIG9uU2VsZWN0OiBoYW5kbGVVbmRvXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIFwiVW5kb1wiKSwgUmVhY3QuY3JlYXRlRWxlbWVudChLYmQsIHtcbiAgICB2YXJpYW50OiBcIm1lbnVcIlxuICB9LCBcIiMgWlwiKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dE1lbnVCdXR0b24sIHtcbiAgICBvblNlbGVjdDogaGFuZGxlUmVkb1xuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCBcIlJlZG9cIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoS2JkLCB7XG4gICAgdmFyaWFudDogXCJtZW51XCJcbiAgfSwgXCIjIFxcdTIxRTcgWlwiKSkpKSk7XG59KTtcblxuZnVuY3Rpb24gQWxpZ25EaXN0cmlidXRlU3ViTWVudShfcmVmMikge1xuICB2YXIgaGFzVGhyZWVPck1vcmUgPSBfcmVmMi5oYXNUaHJlZU9yTW9yZTtcblxuICB2YXIgX3VzZVRMRHJhd0NvbnRleHQyID0gdXNlVExEcmF3Q29udGV4dCgpLFxuICAgICAgdGxzdGF0ZSA9IF91c2VUTERyYXdDb250ZXh0Mi50bHN0YXRlO1xuXG4gIHZhciBhbGlnblRvcCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB0bHN0YXRlLmFsaWduKGV4cG9ydHMuQWxpZ25UeXBlLlRvcCk7XG4gIH0sIFt0bHN0YXRlXSk7XG4gIHZhciBhbGlnbkNlbnRlclZlcnRpY2FsID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHRsc3RhdGUuYWxpZ24oZXhwb3J0cy5BbGlnblR5cGUuQ2VudGVyVmVydGljYWwpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICB2YXIgYWxpZ25Cb3R0b20gPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5hbGlnbihleHBvcnRzLkFsaWduVHlwZS5Cb3R0b20pO1xuICB9LCBbdGxzdGF0ZV0pO1xuICB2YXIgc3RyZXRjaFZlcnRpY2FsbHkgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5zdHJldGNoKGV4cG9ydHMuU3RyZXRjaFR5cGUuVmVydGljYWwpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICB2YXIgZGlzdHJpYnV0ZVZlcnRpY2FsbHkgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5kaXN0cmlidXRlKGV4cG9ydHMuRGlzdHJpYnV0ZVR5cGUuVmVydGljYWwpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICB2YXIgYWxpZ25MZWZ0ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHRsc3RhdGUuYWxpZ24oZXhwb3J0cy5BbGlnblR5cGUuTGVmdCk7XG4gIH0sIFt0bHN0YXRlXSk7XG4gIHZhciBhbGlnbkNlbnRlckhvcml6b250YWwgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5hbGlnbihleHBvcnRzLkFsaWduVHlwZS5DZW50ZXJIb3Jpem9udGFsKTtcbiAgfSwgW3Rsc3RhdGVdKTtcbiAgdmFyIGFsaWduUmlnaHQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5hbGlnbihleHBvcnRzLkFsaWduVHlwZS5SaWdodCk7XG4gIH0sIFt0bHN0YXRlXSk7XG4gIHZhciBzdHJldGNoSG9yaXpvbnRhbGx5ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHRsc3RhdGUuc3RyZXRjaChleHBvcnRzLlN0cmV0Y2hUeXBlLkhvcml6b250YWwpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICB2YXIgZGlzdHJpYnV0ZUhvcml6b250YWxseSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB0bHN0YXRlLmRpc3RyaWJ1dGUoZXhwb3J0cy5EaXN0cmlidXRlVHlwZS5Ib3Jpem9udGFsKTtcbiAgfSwgW3Rsc3RhdGVdKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dE1lbnVSb290LCBudWxsLCBSZWFjdC5jcmVhdGVFbGVtZW50KFJhZGl4Q29udGV4dE1lbnUuVHJpZ2dlckl0ZW0sIHtcbiAgICBhczogUm93QnV0dG9uLFxuICAgIGJwOiBicmVha3BvaW50c1xuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCBcIkFsaWduIC8gRGlzdHJpYnV0ZVwiKSwgUmVhY3QuY3JlYXRlRWxlbWVudChJY29uV3JhcHBlciwge1xuICAgIHNpemU6IFwic21hbGxcIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0SWNvbnMuQ2hldnJvblJpZ2h0SWNvbiwgbnVsbCkpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChTdHlsZWRHcmlkLCB7XG4gICAgYXM6IFJhZGl4Q29udGV4dE1lbnUuQ29udGVudCxcbiAgICBzaWRlT2Zmc2V0OiAyLFxuICAgIGFsaWduT2Zmc2V0OiAtMixcbiAgICBzZWxlY3RlZFN0eWxlOiBoYXNUaHJlZU9yTW9yZSA/ICd0aHJlZU9yTW9yZScgOiAndHdvT3JNb3JlJ1xuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHRNZW51SWNvbkJ1dHRvbiwge1xuICAgIG9uU2VsZWN0OiBhbGlnbkxlZnRcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChyZWFjdEljb25zLkFsaWduTGVmdEljb24sIG51bGwpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0TWVudUljb25CdXR0b24sIHtcbiAgICBvblNlbGVjdDogYWxpZ25DZW50ZXJIb3Jpem9udGFsXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3RJY29ucy5BbGlnbkNlbnRlckhvcml6b250YWxseUljb24sIG51bGwpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0TWVudUljb25CdXR0b24sIHtcbiAgICBvblNlbGVjdDogYWxpZ25SaWdodFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0SWNvbnMuQWxpZ25SaWdodEljb24sIG51bGwpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0TWVudUljb25CdXR0b24sIHtcbiAgICBvblNlbGVjdDogc3RyZXRjaEhvcml6b250YWxseVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0SWNvbnMuU3RyZXRjaEhvcml6b250YWxseUljb24sIG51bGwpKSwgaGFzVGhyZWVPck1vcmUgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0TWVudUljb25CdXR0b24sIHtcbiAgICBvblNlbGVjdDogZGlzdHJpYnV0ZUhvcml6b250YWxseVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0SWNvbnMuU3BhY2VFdmVubHlIb3Jpem9udGFsbHlJY29uLCBudWxsKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dE1lbnVJY29uQnV0dG9uLCB7XG4gICAgb25TZWxlY3Q6IGFsaWduVG9wXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3RJY29ucy5BbGlnblRvcEljb24sIG51bGwpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0TWVudUljb25CdXR0b24sIHtcbiAgICBvblNlbGVjdDogYWxpZ25DZW50ZXJWZXJ0aWNhbFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0SWNvbnMuQWxpZ25DZW50ZXJWZXJ0aWNhbGx5SWNvbiwgbnVsbCkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHRNZW51SWNvbkJ1dHRvbiwge1xuICAgIG9uU2VsZWN0OiBhbGlnbkJvdHRvbVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0SWNvbnMuQWxpZ25Cb3R0b21JY29uLCBudWxsKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dE1lbnVJY29uQnV0dG9uLCB7XG4gICAgb25TZWxlY3Q6IHN0cmV0Y2hWZXJ0aWNhbGx5XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3RJY29ucy5TdHJldGNoVmVydGljYWxseUljb24sIG51bGwpKSwgaGFzVGhyZWVPck1vcmUgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0TWVudUljb25CdXR0b24sIHtcbiAgICBvblNlbGVjdDogZGlzdHJpYnV0ZVZlcnRpY2FsbHlcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChyZWFjdEljb25zLlNwYWNlRXZlbmx5VmVydGljYWxseUljb24sIG51bGwpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0TWVudUFycm93LCB7XG4gICAgb2Zmc2V0OiAxM1xuICB9KSkpO1xufVxuXG52YXIgU3R5bGVkR3JpZCA9IC8qI19fUFVSRV9fKi9zdHlsZWQoTWVudUNvbnRlbnQsIHtcbiAgZGlzcGxheTogJ2dyaWQnLFxuICB2YXJpYW50czoge1xuICAgIHNlbGVjdGVkU3R5bGU6IHtcbiAgICAgIHRocmVlT3JNb3JlOiB7XG4gICAgICAgIGdyaWRUZW1wbGF0ZUNvbHVtbnM6ICdyZXBlYXQoNSwgYXV0byknXG4gICAgICB9LFxuICAgICAgdHdvT3JNb3JlOiB7XG4gICAgICAgIGdyaWRUZW1wbGF0ZUNvbHVtbnM6ICdyZXBlYXQoNCwgYXV0byknXG4gICAgICB9XG4gICAgfVxuICB9XG59KTsgLy8gZnVuY3Rpb24gTW92ZVRvUGFnZU1lbnUoKSB7XG4vLyAgIGNvbnN0IGRvY3VtZW50UGFnZXMgPSB1c2VTZWxlY3RvcigocykgPT4gcy5kYXRhLmRvY3VtZW50LnBhZ2VzKVxuLy8gICBjb25zdCBjdXJyZW50UGFnZUlkID0gdXNlU2VsZWN0b3IoKHMpID0+IHMuZGF0YS5jdXJyZW50UGFnZUlkKVxuLy8gICBpZiAoIWRvY3VtZW50UGFnZXNbY3VycmVudFBhZ2VJZF0pIHJldHVybiBudWxsXG4vLyAgIGNvbnN0IHNvcnRlZCA9IE9iamVjdC52YWx1ZXMoZG9jdW1lbnRQYWdlcylcbi8vICAgICAuc29ydCgoYSwgYikgPT4gYS5jaGlsZEluZGV4IC0gYi5jaGlsZEluZGV4KVxuLy8gICAgIC5maWx0ZXIoKGEpID0+IGEuaWQgIT09IGN1cnJlbnRQYWdlSWQpXG4vLyAgIGlmIChzb3J0ZWQubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbFxuLy8gICByZXR1cm4gKFxuLy8gICAgIDxDb250ZXh0TWVudVJvb3Q+XG4vLyAgICAgICA8Q29udGV4dE1lbnVCdXR0b24+XG4vLyAgICAgICAgIDxzcGFuPk1vdmUgVG8gUGFnZTwvc3Bhbj5cbi8vICAgICAgICAgPEljb25XcmFwcGVyIHNpemU9XCJzbWFsbFwiPlxuLy8gICAgICAgICAgIDxDaGV2cm9uUmlnaHRJY29uIC8+XG4vLyAgICAgICAgIDwvSWNvbldyYXBwZXI+XG4vLyAgICAgICA8L0NvbnRleHRNZW51QnV0dG9uPlxuLy8gICAgICAgPE1lbnVDb250ZW50IGFzPXtSYWRpeENvbnRleHRNZW51LkNvbnRlbnR9IHNpZGVPZmZzZXQ9ezJ9IGFsaWduT2Zmc2V0PXstMn0+XG4vLyAgICAgICAgIHtzb3J0ZWQubWFwKCh7IGlkLCBuYW1lIH0pID0+IChcbi8vICAgICAgICAgICA8Q29udGV4dE1lbnVCdXR0b25cbi8vICAgICAgICAgICAgIGtleT17aWR9XG4vLyAgICAgICAgICAgICBkaXNhYmxlZD17aWQgPT09IGN1cnJlbnRQYWdlSWR9XG4vLyAgICAgICAgICAgICBvblNlbGVjdD17KCkgPT4gc3RhdGUuc2VuZCgnTU9WRURfVE9fUEFHRScsIHsgaWQgfSl9XG4vLyAgICAgICAgICAgPlxuLy8gICAgICAgICAgICAgPHNwYW4+e25hbWV9PC9zcGFuPlxuLy8gICAgICAgICAgIDwvQ29udGV4dE1lbnVCdXR0b24+XG4vLyAgICAgICAgICkpfVxuLy8gICAgICAgICA8Q29udGV4dE1lbnVBcnJvdyBvZmZzZXQ9ezEzfSAvPlxuLy8gICAgICAgPC9NZW51Q29udGVudD5cbi8vICAgICA8L0NvbnRleHRNZW51Um9vdD5cbi8vICAgKVxuLy8gfVxuXG5mdW5jdGlvbiBTdmdSZWRvKHByb3BzKSB7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIF9leHRlbmRzKHtcbiAgICB2aWV3Qm94OiBcIjAgMCAxNSAxNVwiLFxuICAgIGZpbGw6IFwiY3VycmVudENvbG9yXCIsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICB9LCBwcm9wcyksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgIGQ6IFwiTTEyLjUgMi40OTVhLjUuNSAwIDAwLS41LjV2Mi41SDkuNWEuNS41IDAgMTAwIDFoM2EuNS41IDAgMDAuNS0uNXYtM2EuNS41IDAgMDAtLjUtLjV6XCJcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgIGQ6IFwiTTcuNjk3IDIuMDQ5YTUgNSAwIDEwNC4wMiA2LjYxMy41LjUgMCAxMC0uOTQ0LS4zMzIgNCA0IDAgMTEtLjk0Ni00LjE2bC4wMS4wMSAyLjMyIDIuMThhLjUuNSAwIDAwLjY4NS0uNzI5bC0yLjMxNC0yLjE3NUE1IDUgMCAwMDcuNjk3IDIuMDV6XCJcbiAgfSkpO1xufVxuXG5mdW5jdGlvbiBTdmdUcmFzaChwcm9wcykge1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCBfZXh0ZW5kcyh7XG4gICAgdmlld0JveDogXCIwIDAgMTUgMTVcIixcbiAgICBmaWxsOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgfSwgcHJvcHMpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIixcbiAgICBkOiBcIk0yIDQuNjU2YS41LjUgMCAwMS41LS41aDkuN2EuNS41IDAgMDEwIDFIMi41YS41LjUgMCAwMS0uNS0uNXpcIlxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICBjbGlwUnVsZTogXCJldmVub2RkXCIsXG4gICAgZDogXCJNNi4yNzIgM2EuNTc4LjU3OCAwIDAwLS41NzguNTc4di41NzhoMy4zMTF2LS41NzhBLjU3OC41NzggMCAwMDguNDI4IDNINi4yNzJ6bTMuNzMzIDEuMTU2di0uNTc4QTEuNTc4IDEuNTc4IDAgMDA4LjQyOCAySDYuMjcyYTEuNTc4IDEuNTc4IDAgMDAtMS41NzggMS41Nzh2LjU3OEgzLjU3OGEuNS41IDAgMDAtLjUuNVYxMi4yYTEuNTc4IDEuNTc4IDAgMDAxLjU3NyAxLjU3OGg1LjM5YTEuNTc4IDEuNTc4IDAgMDAxLjU3Ny0xLjU3OFY0LjY1NmEuNS41IDAgMDAtLjUtLjVoLTEuMTE3em0tNS45MjcgMVYxMi4yYS41NzguNTc4IDAgMDAuNTc3LjU3OGg1LjM5YS41NzguNTc4IDAgMDAuNTc3LS41NzhWNS4xNTZINC4wNzh6XCJcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgIGQ6IFwiTTYuMjcyIDYuODVhLjUuNSAwIDAxLjUuNXYzLjIzM2EuNS41IDAgMTEtMSAwVjcuMzVhLjUuNSAwIDAxLjUtLjV6TTguNDI4IDYuODVhLjUuNSAwIDAxLjUuNXYzLjIzM2EuNS41IDAgMTEtMSAwVjcuMzVhLjUuNSAwIDAxLjUtLjV6XCJcbiAgfSkpO1xufVxuXG5mdW5jdGlvbiBTdmdVbmRvKHByb3BzKSB7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIF9leHRlbmRzKHtcbiAgICB2aWV3Qm94OiBcIjAgMCAxNSAxNVwiLFxuICAgIGZpbGw6IFwiY3VycmVudENvbG9yXCIsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICB9LCBwcm9wcyksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgIGQ6IFwiTTIuNSAyLjQ5NWEuNS41IDAgMDEuNS41djIuNWgyLjVhLjUuNSAwIDExMCAxaC0zYS41LjUgMCAwMS0uNS0uNXYtM2EuNS41IDAgMDEuNS0uNXpcIlxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICBjbGlwUnVsZTogXCJldmVub2RkXCIsXG4gICAgZDogXCJNNy4zMDMgMi4wNDlhNSA1IDAgMTEtNC4wMiA2LjYxMy41LjUgMCAwMS45NDQtLjMzMiA0IDQgMCAxMC45NDYtNC4xNmwtLjAxLjAxLTIuMzIgMi4xOGEuNS41IDAgMDEtLjY4NS0uNzI5bDIuMzE0LTIuMTc1QTUgNSAwIDAxNy4zMDMgMi4wNXpcIlxuICB9KSk7XG59XG5cbnZhciBpc0FsbExvY2tlZFNlbGVjdG9yID0gZnVuY3Rpb24gaXNBbGxMb2NrZWRTZWxlY3RvcihzKSB7XG4gIHZhciBzZWxlY3RlZElkcyA9IHMucGFnZVN0YXRlLnNlbGVjdGVkSWRzO1xuICByZXR1cm4gc2VsZWN0ZWRJZHMuZXZlcnkoZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIHMucGFnZS5zaGFwZXNbaWRdLmlzTG9ja2VkO1xuICB9KTtcbn07XG5cbnZhciBpc0FsbEFzcGVjdExvY2tlZFNlbGVjdG9yID0gZnVuY3Rpb24gaXNBbGxBc3BlY3RMb2NrZWRTZWxlY3RvcihzKSB7XG4gIHZhciBzZWxlY3RlZElkcyA9IHMucGFnZVN0YXRlLnNlbGVjdGVkSWRzO1xuICByZXR1cm4gc2VsZWN0ZWRJZHMuZXZlcnkoZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIHMucGFnZS5zaGFwZXNbaWRdLmlzQXNwZWN0UmF0aW9Mb2NrZWQ7XG4gIH0pO1xufTtcblxudmFyIGlzQWxsR3JvdXBlZFNlbGVjdG9yID0gZnVuY3Rpb24gaXNBbGxHcm91cGVkU2VsZWN0b3Iocykge1xuICB2YXIgc2VsZWN0ZWRTaGFwZXMgPSBzLnBhZ2VTdGF0ZS5zZWxlY3RlZElkcy5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIHMucGFnZS5zaGFwZXNbaWRdO1xuICB9KTtcbiAgcmV0dXJuIHNlbGVjdGVkU2hhcGVzLmV2ZXJ5KGZ1bmN0aW9uIChzaGFwZSkge1xuICAgIHJldHVybiBzaGFwZS5jaGlsZHJlbiAhPT0gdW5kZWZpbmVkIHx8IHNoYXBlLnBhcmVudElkID09PSBzZWxlY3RlZFNoYXBlc1swXS5wYXJlbnRJZCAmJiBzZWxlY3RlZFNoYXBlc1swXS5wYXJlbnRJZCAhPT0gcy5hcHBTdGF0ZS5jdXJyZW50UGFnZUlkO1xuICB9KTtcbn07XG5cbnZhciBoYXNTZWxlY3Rpb25TZWxlY3RvciA9IGZ1bmN0aW9uIGhhc1NlbGVjdGlvblNlbGVjdG9yKHMpIHtcbiAgcmV0dXJuIHMucGFnZVN0YXRlLnNlbGVjdGVkSWRzLmxlbmd0aCA+IDA7XG59O1xuXG52YXIgaGFzTXVsdGlwbGVTZWxlY3Rpb25TZWxlY3RvciA9IGZ1bmN0aW9uIGhhc011bHRpcGxlU2VsZWN0aW9uU2VsZWN0b3Iocykge1xuICByZXR1cm4gcy5wYWdlU3RhdGUuc2VsZWN0ZWRJZHMubGVuZ3RoID4gMTtcbn07XG5cbnZhciBTaGFwZXNGdW5jdGlvbnMgPSAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyhmdW5jdGlvbiAoKSB7XG4gIHZhciBfdXNlVExEcmF3Q29udGV4dCA9IHVzZVRMRHJhd0NvbnRleHQoKSxcbiAgICAgIHRsc3RhdGUgPSBfdXNlVExEcmF3Q29udGV4dC50bHN0YXRlLFxuICAgICAgdXNlQXBwU3RhdGUgPSBfdXNlVExEcmF3Q29udGV4dC51c2VBcHBTdGF0ZTtcblxuICB2YXIgaXNBbGxMb2NrZWQgPSB1c2VBcHBTdGF0ZShpc0FsbExvY2tlZFNlbGVjdG9yKTtcbiAgdmFyIGlzQWxsQXNwZWN0TG9ja2VkID0gdXNlQXBwU3RhdGUoaXNBbGxBc3BlY3RMb2NrZWRTZWxlY3Rvcik7XG4gIHZhciBpc0FsbEdyb3VwZWQgPSB1c2VBcHBTdGF0ZShpc0FsbEdyb3VwZWRTZWxlY3Rvcik7XG4gIHZhciBoYXNTZWxlY3Rpb24gPSB1c2VBcHBTdGF0ZShoYXNTZWxlY3Rpb25TZWxlY3Rvcik7XG4gIHZhciBoYXNNdWx0aXBsZVNlbGVjdGlvbiA9IHVzZUFwcFN0YXRlKGhhc011bHRpcGxlU2VsZWN0aW9uU2VsZWN0b3IpO1xuICB2YXIgaGFuZGxlUm90YXRlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHRsc3RhdGUucm90YXRlKCk7XG4gIH0sIFt0bHN0YXRlXSk7XG4gIHZhciBoYW5kbGVEdXBsaWNhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5kdXBsaWNhdGUoKTtcbiAgfSwgW3Rsc3RhdGVdKTtcbiAgdmFyIGhhbmRsZVRvZ2dsZUxvY2tlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB0bHN0YXRlLnRvZ2dsZUxvY2tlZCgpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICB2YXIgaGFuZGxlVG9nZ2xlQXNwZWN0UmF0aW8gPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS50b2dnbGVBc3BlY3RSYXRpb0xvY2tlZCgpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICB2YXIgaGFuZGxlR3JvdXAgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5ncm91cCgpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICB2YXIgaGFuZGxlTW92ZVRvQmFjayA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB0bHN0YXRlLm1vdmVUb0JhY2soKTtcbiAgfSwgW3Rsc3RhdGVdKTtcbiAgdmFyIGhhbmRsZU1vdmVCYWNrd2FyZCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB0bHN0YXRlLm1vdmVCYWNrd2FyZCgpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICB2YXIgaGFuZGxlTW92ZUZvcndhcmQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5tb3ZlRm9yd2FyZCgpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICB2YXIgaGFuZGxlTW92ZVRvRnJvbnQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5tb3ZlVG9Gcm9udCgpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICB2YXIgaGFuZGxlRGVsZXRlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHRsc3RhdGVbXCJkZWxldGVcIl0oKTtcbiAgfSwgW3Rsc3RhdGVdKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQnV0dG9uc1JvdywgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChJY29uQnV0dG9uLCB7XG4gICAgYnA6IGJyZWFrcG9pbnRzLFxuICAgIGRpc2FibGVkOiAhaGFzU2VsZWN0aW9uLFxuICAgIHNpemU6IFwic21hbGxcIixcbiAgICBvbkNsaWNrOiBoYW5kbGVEdXBsaWNhdGVcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChUb29sdGlwLCB7XG4gICAgbGFiZWw6IFwiRHVwbGljYXRlXCIsXG4gICAga2JkOiBcIiNEXCJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChyZWFjdEljb25zLkNvcHlJY29uLCBudWxsKSkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEljb25CdXR0b24sIHtcbiAgICBkaXNhYmxlZDogIWhhc1NlbGVjdGlvbixcbiAgICBzaXplOiBcInNtYWxsXCIsXG4gICAgb25DbGljazogaGFuZGxlUm90YXRlXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVG9vbHRpcCwge1xuICAgIGxhYmVsOiBcIlJvdGF0ZVwiXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3RJY29ucy5Sb3RhdGVDb3VudGVyQ2xvY2t3aXNlSWNvbiwgbnVsbCkpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChJY29uQnV0dG9uLCB7XG4gICAgYnA6IGJyZWFrcG9pbnRzLFxuICAgIGRpc2FibGVkOiAhaGFzU2VsZWN0aW9uLFxuICAgIHNpemU6IFwic21hbGxcIixcbiAgICBvbkNsaWNrOiBoYW5kbGVUb2dnbGVMb2NrZWRcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChUb29sdGlwLCB7XG4gICAgbGFiZWw6IFwiVG9vZ2xlIExvY2tlZFwiLFxuICAgIGtiZDogXCIjTFwiXG4gIH0sIGlzQWxsTG9ja2VkID8gUmVhY3QuY3JlYXRlRWxlbWVudChyZWFjdEljb25zLkxvY2tDbG9zZWRJY29uLCBudWxsKSA6IFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3RJY29ucy5Mb2NrT3BlbjFJY29uLCB7XG4gICAgb3BhY2l0eTogMC40XG4gIH0pKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSWNvbkJ1dHRvbiwge1xuICAgIGJwOiBicmVha3BvaW50cyxcbiAgICBkaXNhYmxlZDogIWhhc1NlbGVjdGlvbixcbiAgICBzaXplOiBcInNtYWxsXCIsXG4gICAgb25DbGljazogaGFuZGxlVG9nZ2xlQXNwZWN0UmF0aW9cbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChUb29sdGlwLCB7XG4gICAgbGFiZWw6IFwiVG9vZ2xlIEFzcGVjdCBSYXRpbyBMb2NrXCJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChyZWFjdEljb25zLkFzcGVjdFJhdGlvSWNvbiwge1xuICAgIG9wYWNpdHk6IGlzQWxsQXNwZWN0TG9ja2VkID8gMSA6IDAuNFxuICB9KSkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEljb25CdXR0b24sIHtcbiAgICBicDogYnJlYWtwb2ludHMsXG4gICAgZGlzYWJsZWQ6ICFpc0FsbEdyb3VwZWQgJiYgIWhhc011bHRpcGxlU2VsZWN0aW9uLFxuICAgIHNpemU6IFwic21hbGxcIixcbiAgICBvbkNsaWNrOiBoYW5kbGVHcm91cFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFRvb2x0aXAsIHtcbiAgICBsYWJlbDogXCJHcm91cFwiLFxuICAgIGtiZDogXCIjR1wiXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3RJY29ucy5Hcm91cEljb24sIHtcbiAgICBvcGFjaXR5OiBpc0FsbEdyb3VwZWQgPyAxIDogMC40XG4gIH0pKSkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEJ1dHRvbnNSb3csIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSWNvbkJ1dHRvbiwge1xuICAgIGJwOiBicmVha3BvaW50cyxcbiAgICBkaXNhYmxlZDogIWhhc1NlbGVjdGlvbixcbiAgICBzaXplOiBcInNtYWxsXCIsXG4gICAgb25DbGljazogaGFuZGxlTW92ZVRvQmFja1xuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFRvb2x0aXAsIHtcbiAgICBsYWJlbDogXCJNb3ZlIHRvIEJhY2tcIixcbiAgICBrYmQ6IFwiI1xcdTIxRTdbXCJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChyZWFjdEljb25zLlBpbkJvdHRvbUljb24sIG51bGwpKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSWNvbkJ1dHRvbiwge1xuICAgIGJwOiBicmVha3BvaW50cyxcbiAgICBkaXNhYmxlZDogIWhhc1NlbGVjdGlvbixcbiAgICBzaXplOiBcInNtYWxsXCIsXG4gICAgb25DbGljazogaGFuZGxlTW92ZUJhY2t3YXJkXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVG9vbHRpcCwge1xuICAgIGxhYmVsOiBcIk1vdmUgQmFja3dhcmRcIixcbiAgICBrYmQ6IFwiI1tcIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0SWNvbnMuQXJyb3dEb3duSWNvbiwgbnVsbCkpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChJY29uQnV0dG9uLCB7XG4gICAgYnA6IGJyZWFrcG9pbnRzLFxuICAgIGRpc2FibGVkOiAhaGFzU2VsZWN0aW9uLFxuICAgIHNpemU6IFwic21hbGxcIixcbiAgICBvbkNsaWNrOiBoYW5kbGVNb3ZlRm9yd2FyZFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFRvb2x0aXAsIHtcbiAgICBsYWJlbDogXCJNb3ZlIEZvcndhcmRcIixcbiAgICBrYmQ6IFwiI11cIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0SWNvbnMuQXJyb3dVcEljb24sIG51bGwpKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSWNvbkJ1dHRvbiwge1xuICAgIGJwOiBicmVha3BvaW50cyxcbiAgICBkaXNhYmxlZDogIWhhc1NlbGVjdGlvbixcbiAgICBzaXplOiBcInNtYWxsXCIsXG4gICAgb25DbGljazogaGFuZGxlTW92ZVRvRnJvbnRcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChUb29sdGlwLCB7XG4gICAgbGFiZWw6IFwiTW9yZSB0byBGcm9udFwiLFxuICAgIGtiZDogXCIjXFx1MjFFN11cIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0SWNvbnMuUGluVG9wSWNvbiwgbnVsbCkpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChJY29uQnV0dG9uLCB7XG4gICAgYnA6IGJyZWFrcG9pbnRzLFxuICAgIGRpc2FibGVkOiAhaGFzU2VsZWN0aW9uLFxuICAgIHNpemU6IFwic21hbGxcIixcbiAgICBvbkNsaWNrOiBoYW5kbGVEZWxldGVcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChUb29sdGlwLCB7XG4gICAgbGFiZWw6IFwiRGVsZXRlXCIsXG4gICAga2JkOiBcIlxcdTIzMkJcIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFN2Z1RyYXNoLCBudWxsKSkpKSk7XG59KTtcblxudmFyIEFsaWduRGlzdHJpYnV0ZSA9IC8qI19fUFVSRV9fKi9SZWFjdC5tZW1vKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBoYXNUd29Pck1vcmUgPSBfcmVmLmhhc1R3b09yTW9yZSxcbiAgICAgIGhhc1RocmVlT3JNb3JlID0gX3JlZi5oYXNUaHJlZU9yTW9yZTtcblxuICB2YXIgX3VzZVRMRHJhd0NvbnRleHQgPSB1c2VUTERyYXdDb250ZXh0KCksXG4gICAgICB0bHN0YXRlID0gX3VzZVRMRHJhd0NvbnRleHQudGxzdGF0ZTtcblxuICB2YXIgYWxpZ25Ub3AgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5hbGlnbihleHBvcnRzLkFsaWduVHlwZS5Ub3ApO1xuICB9LCBbdGxzdGF0ZV0pO1xuICB2YXIgYWxpZ25DZW50ZXJWZXJ0aWNhbCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB0bHN0YXRlLmFsaWduKGV4cG9ydHMuQWxpZ25UeXBlLkNlbnRlclZlcnRpY2FsKTtcbiAgfSwgW3Rsc3RhdGVdKTtcbiAgdmFyIGFsaWduQm90dG9tID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHRsc3RhdGUuYWxpZ24oZXhwb3J0cy5BbGlnblR5cGUuQm90dG9tKTtcbiAgfSwgW3Rsc3RhdGVdKTtcbiAgdmFyIHN0cmV0Y2hWZXJ0aWNhbGx5ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHRsc3RhdGUuc3RyZXRjaChleHBvcnRzLlN0cmV0Y2hUeXBlLlZlcnRpY2FsKTtcbiAgfSwgW3Rsc3RhdGVdKTtcbiAgdmFyIGRpc3RyaWJ1dGVWZXJ0aWNhbGx5ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHRsc3RhdGUuZGlzdHJpYnV0ZShleHBvcnRzLkRpc3RyaWJ1dGVUeXBlLlZlcnRpY2FsKTtcbiAgfSwgW3Rsc3RhdGVdKTtcbiAgdmFyIGFsaWduTGVmdCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB0bHN0YXRlLmFsaWduKGV4cG9ydHMuQWxpZ25UeXBlLkxlZnQpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICB2YXIgYWxpZ25DZW50ZXJIb3Jpem9udGFsID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHRsc3RhdGUuYWxpZ24oZXhwb3J0cy5BbGlnblR5cGUuQ2VudGVySG9yaXpvbnRhbCk7XG4gIH0sIFt0bHN0YXRlXSk7XG4gIHZhciBhbGlnblJpZ2h0ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHRsc3RhdGUuYWxpZ24oZXhwb3J0cy5BbGlnblR5cGUuUmlnaHQpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICB2YXIgc3RyZXRjaEhvcml6b250YWxseSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB0bHN0YXRlLnN0cmV0Y2goZXhwb3J0cy5TdHJldGNoVHlwZS5Ib3Jpem9udGFsKTtcbiAgfSwgW3Rsc3RhdGVdKTtcbiAgdmFyIGRpc3RyaWJ1dGVIb3Jpem9udGFsbHkgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5kaXN0cmlidXRlKGV4cG9ydHMuRGlzdHJpYnV0ZVR5cGUuSG9yaXpvbnRhbCk7XG4gIH0sIFt0bHN0YXRlXSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBSZWFjdC5jcmVhdGVFbGVtZW50KEJ1dHRvbnNSb3csIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSWNvbkJ1dHRvbiwge1xuICAgIGJwOiBicmVha3BvaW50cyxcbiAgICBzaXplOiBcInNtYWxsXCIsXG4gICAgZGlzYWJsZWQ6ICFoYXNUd29Pck1vcmUsXG4gICAgb25DbGljazogYWxpZ25MZWZ0XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3RJY29ucy5BbGlnbkxlZnRJY29uLCBudWxsKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSWNvbkJ1dHRvbiwge1xuICAgIGJwOiBicmVha3BvaW50cyxcbiAgICBzaXplOiBcInNtYWxsXCIsXG4gICAgZGlzYWJsZWQ6ICFoYXNUd29Pck1vcmUsXG4gICAgb25DbGljazogYWxpZ25DZW50ZXJIb3Jpem9udGFsXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3RJY29ucy5BbGlnbkNlbnRlckhvcml6b250YWxseUljb24sIG51bGwpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChJY29uQnV0dG9uLCB7XG4gICAgYnA6IGJyZWFrcG9pbnRzLFxuICAgIHNpemU6IFwic21hbGxcIixcbiAgICBkaXNhYmxlZDogIWhhc1R3b09yTW9yZSxcbiAgICBvbkNsaWNrOiBhbGlnblJpZ2h0XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3RJY29ucy5BbGlnblJpZ2h0SWNvbiwgbnVsbCkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEljb25CdXR0b24sIHtcbiAgICBicDogYnJlYWtwb2ludHMsXG4gICAgc2l6ZTogXCJzbWFsbFwiLFxuICAgIGRpc2FibGVkOiAhaGFzVHdvT3JNb3JlLFxuICAgIG9uQ2xpY2s6IHN0cmV0Y2hIb3Jpem9udGFsbHlcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChyZWFjdEljb25zLlN0cmV0Y2hIb3Jpem9udGFsbHlJY29uLCBudWxsKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSWNvbkJ1dHRvbiwge1xuICAgIGJwOiBicmVha3BvaW50cyxcbiAgICBzaXplOiBcInNtYWxsXCIsXG4gICAgZGlzYWJsZWQ6ICFoYXNUaHJlZU9yTW9yZSxcbiAgICBvbkNsaWNrOiBkaXN0cmlidXRlSG9yaXpvbnRhbGx5XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3RJY29ucy5TcGFjZUV2ZW5seUhvcml6b250YWxseUljb24sIG51bGwpKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQnV0dG9uc1JvdywgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChJY29uQnV0dG9uLCB7XG4gICAgYnA6IGJyZWFrcG9pbnRzLFxuICAgIHNpemU6IFwic21hbGxcIixcbiAgICBkaXNhYmxlZDogIWhhc1R3b09yTW9yZSxcbiAgICBvbkNsaWNrOiBhbGlnblRvcFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0SWNvbnMuQWxpZ25Ub3BJY29uLCBudWxsKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSWNvbkJ1dHRvbiwge1xuICAgIGJwOiBicmVha3BvaW50cyxcbiAgICBzaXplOiBcInNtYWxsXCIsXG4gICAgZGlzYWJsZWQ6ICFoYXNUd29Pck1vcmUsXG4gICAgb25DbGljazogYWxpZ25DZW50ZXJWZXJ0aWNhbFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0SWNvbnMuQWxpZ25DZW50ZXJWZXJ0aWNhbGx5SWNvbiwgbnVsbCkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEljb25CdXR0b24sIHtcbiAgICBicDogYnJlYWtwb2ludHMsXG4gICAgc2l6ZTogXCJzbWFsbFwiLFxuICAgIGRpc2FibGVkOiAhaGFzVHdvT3JNb3JlLFxuICAgIG9uQ2xpY2s6IGFsaWduQm90dG9tXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3RJY29ucy5BbGlnbkJvdHRvbUljb24sIG51bGwpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChJY29uQnV0dG9uLCB7XG4gICAgYnA6IGJyZWFrcG9pbnRzLFxuICAgIHNpemU6IFwic21hbGxcIixcbiAgICBkaXNhYmxlZDogIWhhc1R3b09yTW9yZSxcbiAgICBvbkNsaWNrOiBzdHJldGNoVmVydGljYWxseVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0SWNvbnMuU3RyZXRjaFZlcnRpY2FsbHlJY29uLCBudWxsKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSWNvbkJ1dHRvbiwge1xuICAgIGJwOiBicmVha3BvaW50cyxcbiAgICBzaXplOiBcInNtYWxsXCIsXG4gICAgZGlzYWJsZWQ6ICFoYXNUaHJlZU9yTW9yZSxcbiAgICBvbkNsaWNrOiBkaXN0cmlidXRlVmVydGljYWxseVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0SWNvbnMuU3BhY2VFdmVubHlWZXJ0aWNhbGx5SWNvbiwgbnVsbCkpKSk7XG59KTtcblxudmFyIFN0eWxlRHJvcGRvd25Db250ZW50ID0gLyojX19QVVJFX18qL3N0eWxlZCgnZGl2Jywge1xuICBkaXNwbGF5OiAnZ3JpZCcsXG4gIHBhZGRpbmc6IDQsXG4gIGdyaWRUZW1wbGF0ZUNvbHVtbnM6ICdyZXBlYXQoNCwgMWZyKScsXG4gIGJhY2tncm91bmRDb2xvcjogJyRwYW5lbCcsXG4gIGJvcmRlclJhZGl1czogNCxcbiAgYm9yZGVyOiAnMXB4IHNvbGlkICRwYW5lbCcsXG4gIGJveFNoYWRvdzogJyQ0JyxcbiAgdmFyaWFudHM6IHtcbiAgICBkaXJlY3Rpb246IHtcbiAgICAgIHZlcnRpY2FsOiB7XG4gICAgICAgIGdyaWRUZW1wbGF0ZUNvbHVtbnM6ICcxZnInXG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbnZhciBTdHlsZURyb3Bkb3duSXRlbSA9IC8qI19fUFVSRV9fKi9zdHlsZWQoJ2J1dHRvbicsIHtcbiAgaGVpZ2h0OiAnMzJweCcsXG4gIHdpZHRoOiAnMzJweCcsXG4gIGJhY2tncm91bmRDb2xvcjogJyRwYW5lbCcsXG4gIGJvcmRlclJhZGl1czogJzRweCcsXG4gIHBhZGRpbmc6ICcwJyxcbiAgbWFyZ2luOiAnMCcsXG4gIGRpc3BsYXk6ICdmbGV4JyxcbiAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcbiAgb3V0bGluZTogJ25vbmUnLFxuICBib3JkZXI6ICdub25lJyxcbiAgcG9pbnRlckV2ZW50czogJ2FsbCcsXG4gIGN1cnNvcjogJ3BvaW50ZXInLFxuICAnJjpmb2N1cyc6IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICckaG92ZXInXG4gIH0sXG4gICcmOmhvdmVyOm5vdCg6ZGlzYWJsZWQpJzoge1xuICAgIGJhY2tncm91bmRDb2xvcjogJyRob3ZlcidcbiAgfSxcbiAgJyY6ZGlzYWJsZWQnOiB7XG4gICAgb3BhY2l0eTogJzAuNSdcbiAgfSxcbiAgdmFyaWFudHM6IHtcbiAgICBpc0FjdGl2ZToge1xuICAgICAgXCJ0cnVlXCI6IHtcbiAgICAgICAgJyYgc3ZnJzoge1xuICAgICAgICAgIGZpbGw6ICckdGV4dCcsXG4gICAgICAgICAgc3Ryb2tlOiAnJHRleHQnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImZhbHNlXCI6IHtcbiAgICAgICAgJyYgc3ZnJzoge1xuICAgICAgICAgIGZpbGw6ICckaW5hY3RpdmUnLFxuICAgICAgICAgIHN0cm9rZTogJyRpbmFjdGl2ZSdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5mdW5jdGlvbiBCb3hJY29uKF9yZWYpIHtcbiAgdmFyIF9yZWYkZmlsbCA9IF9yZWYuZmlsbCxcbiAgICAgIGZpbGwgPSBfcmVmJGZpbGwgPT09IHZvaWQgMCA/ICdub25lJyA6IF9yZWYkZmlsbCxcbiAgICAgIF9yZWYkc3Ryb2tlID0gX3JlZi5zdHJva2UsXG4gICAgICBzdHJva2UgPSBfcmVmJHN0cm9rZSA9PT0gdm9pZCAwID8gJ2N1cnJlbnRDb2xvcicgOiBfcmVmJHN0cm9rZTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwge1xuICAgIHdpZHRoOiBcIjI0XCIsXG4gICAgaGVpZ2h0OiBcIjI0XCIsXG4gICAgdmlld0JveDogXCIwIDAgMjQgMjRcIixcbiAgICBzdHJva2U6IHN0cm9rZSxcbiAgICBmaWxsOiBmaWxsLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xuICAgIHg6IFwiNFwiLFxuICAgIHk6IFwiNFwiLFxuICAgIHdpZHRoOiBcIjE2XCIsXG4gICAgaGVpZ2h0OiBcIjE2XCIsXG4gICAgcng6IFwiMlwiLFxuICAgIHN0cm9rZVdpZHRoOiBcIjJcIlxuICB9KSk7XG59XG5mdW5jdGlvbiBEYXNoU29saWRJY29uKCkge1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7XG4gICAgd2lkdGg6IFwiMjRcIixcbiAgICBoZWlnaHQ6IFwiMjRcIixcbiAgICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIsIHtcbiAgICBjeDogMTIsXG4gICAgY3k6IDEyLFxuICAgIHI6IDgsXG4gICAgZmlsbDogXCJub25lXCIsXG4gICAgc3Ryb2tlV2lkdGg6IDIsXG4gICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiXG4gIH0pKTtcbn1cbmZ1bmN0aW9uIERhc2hEYXNoZWRJY29uKCkge1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7XG4gICAgd2lkdGg6IFwiMjRcIixcbiAgICBoZWlnaHQ6IFwiMjRcIixcbiAgICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIsIHtcbiAgICBjeDogMTIsXG4gICAgY3k6IDEyLFxuICAgIHI6IDgsXG4gICAgZmlsbDogXCJub25lXCIsXG4gICAgc3Ryb2tlV2lkdGg6IDIuNSxcbiAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgc3Ryb2tlRGFzaGFycmF5OiA1MC4yNjU0OCAqIDAuMVxuICB9KSk7XG59XG52YXIgZG90dGVkRGFzaGFycmF5ID0gNTAuMjY1NDggKiAwLjAyNSArIFwiIFwiICsgNTAuMjY1NDggKiAwLjE7XG5mdW5jdGlvbiBEYXNoRG90dGVkSWNvbigpIHtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwge1xuICAgIHdpZHRoOiBcIjI0XCIsXG4gICAgaGVpZ2h0OiBcIjI0XCIsXG4gICAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImNpcmNsZVwiLCB7XG4gICAgY3g6IDEyLFxuICAgIGN5OiAxMixcbiAgICByOiA4LFxuICAgIGZpbGw6IFwibm9uZVwiLFxuICAgIHN0cm9rZVdpZHRoOiAyLjUsXG4gICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgIHN0cm9rZURhc2hhcnJheTogZG90dGVkRGFzaGFycmF5XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIERhc2hEcmF3SWNvbigpIHtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwge1xuICAgIHdpZHRoOiBcIjI0XCIsXG4gICAgaGVpZ2h0OiBcIjI0XCIsXG4gICAgdmlld0JveDogXCIxIDEuNSAyMSAyMlwiLFxuICAgIGZpbGw6IFwiY3VycmVudENvbG9yXCIsXG4gICAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTEwLjAxNjIgMTkuMjc2OEMxMC4wMTYyIDE5LjI3NjggOS45MDY3OSAxOS4yNTE3IDkuNjg3OSAxOS4yMDE3QzkuNDYyNzUgMTkuMTQ1NCA5LjEyODE2IDE5LjA0MjIgOC42ODQxMyAxOC44OTIxQzguMjMzODQgMTguNzM1OCA3LjgxNDgyIDE4LjU0NSA3LjQyNzA3IDE4LjMxOTlDNy4wMzMwNyAxOC4xMDEgNi42MjM0MyAxNy43ODgzIDYuMTk4MTYgMTcuMzgxOEM1Ljc3Mjg5IDE2Ljk3NTMgNS4zMzUxMSAxNi4zNzE4IDQuODg0ODIgMTUuNTcxM0M0LjQzNDUzIDE0Ljc2NDUgNC4xNTMxIDEzLjg1NDUgNC4wNDA1MyAxMi44NDE0QzMuOTI3OTUgMTEuODIyIDQuMDQ5OTEgMTAuODQ2NCA0LjQwNjM5IDkuOTE0NTFDNC43NjI4NiA4Ljk4MjY2IDUuMzk0NTIgOC4xMDA4NCA2LjMwMTM1IDcuMjY5MDZDNy4yMTQ0NCA2LjQ0MzUzIDguMjkzMjUgNS44MzM3NyA5LjUzNzggNS40Mzk3NkMxMC43ODIzIDUuMDUyMDIgMTEuODMzIDQuOTIwNjggMTIuNjg5OCA1LjA0NTc2QzEzLjU0NjYgNS4xNjQ1OSAxNC4zODc4IDUuNDM2NjQgMTUuMjEzMyA1Ljg2MTkxQzE2LjAzODggNi4yODcxOCAxNi43NzY4IDYuODY4OCAxNy40MjcyIDcuNjA2NzhDMTguMDcxNCA4LjM0NDc1IDE4LjU0MDQgOS4yMTQwNiAxOC44MzQ0IDEwLjIxNDdDMTkuMTI4MyAxMS4yMTUzIDE5LjE3MjEgMTIuMjU5OCAxOC45NjU3IDEzLjM0OEMxOC43NTkzIDE0LjQyOTkgMTguMjg3MiAxNS40MzM3IDE3LjU0OTIgMTYuMzU5M0MxNi44MTEyIDE3LjI4NDkgMTUuOTI2MyAxOC4wMDcyIDE0Ljg5NDQgMTguNTI2M0MxMy44NjI0IDE5LjAzOTEgMTIuOTA1NiAxOS4zMTc0IDEyLjAyMzggMTkuMzYxMkMxMS4xNDIgMTkuNDA1IDEwLjIxMDEgMTkuMjcwNSA5LjIyODIzIDE4Ljk1NzhDOC4yNDYzNSAxOC42NDUxIDcuMzU4MjggMTguMTUxIDYuNTY0MDIgMTcuNDc1NkM1Ljc3NjAxIDE2LjgwMDIgNi4wODg3MSAxNi44NjU4IDcuNTAyMTIgMTcuNjcyNkM4LjkwOTI3IDE4LjQ3MzEgMTAuMTQ0NCAxOC44NDg0IDExLjIwNzYgMTguNzk4M0MxMi4yNjQ1IDE4Ljc1NDUgMTMuMjk2NSAxOC40ODI1IDE0LjMwMzQgMTcuOTgyMkMxNS4zMTAyIDE3LjQ4MTkgMTYuMTI2NCAxNi44MjIxIDE2Ljc1MTggMTYuMDAyOEMxNy4zNzcyIDE1LjE4MzUgMTcuNzY4MSAxNC4zMTExIDE3LjkyNDQgMTMuMzg1NUMxOC4wODA4IDEyLjQ1OTkgMTguMDQwMSAxMS41NzgxIDE3LjgwMjUgMTAuNzRDMTcuNTU4NiA5LjkwMiAxNy4xNzM5IDkuMTU0NjQgMTYuNjQ4NiA4LjQ5Nzk3QzE2LjEyMzMgNy44NDEzIDE1LjIyODkgNy4yNzg0NCAxMy45NjU2IDYuODA5MzlDMTIuNzA4NiA2LjM0MDM0IDExLjQyMDMgNi4yMDkwMSAxMC4xMDA3IDYuNDE1MzlDOC43ODczMiA2LjYxNTUyIDcuNjk1OTkgNy4wNjg5MyA2LjgyNjY5IDcuNzc1NjRDNS45NjM2MyA4LjQ4ODU5IDUuMzQ3NjEgOS4yNjQwOSA0Ljk3ODYzIDEwLjEwMjFDNC42MDk2NCAxMC45NDAyIDQuNDUzMjkgMTEuODM3NiA0LjUwOTU4IDEyLjc5NDVDNC41NjU4NiAxMy43NTEzIDQuNzkxMDEgMTQuNjIzOCA1LjE4NTAxIDE1LjQxMThDNS41NzI3NiAxNi4xOTk4IDUuOTYzNjMgMTYuODAwMiA2LjM1NzY0IDE3LjIxMjlDNi43NTE2NCAxNy42MjU3IDcuMTMzMTMgMTcuOTUwOSA3LjUwMjEyIDE4LjE4ODZDNy44NzczNiAxOC40MzI1IDguMjgwNzQgMTguNjQyIDguNzEyMjcgMTguODE3MUM5LjE1MDA1IDE4Ljk5MjIgOS40NzgzOSAxOS4xMTEgOS42OTcyOCAxOS4xNzM2QzkuOTE2MTcgMTkuMjM2MSAxMC4wMjU2IDE5LjI3MDUgMTAuMDI1NiAxOS4yNzY4SDEwLjAxNjJaXCIsXG4gICAgc3Ryb2tlV2lkdGg6IFwiMlwiXG4gIH0pKTtcbn1cbmZ1bmN0aW9uIElzRmlsbGVkRmlsbEljb24oKSB7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHtcbiAgICB3aWR0aDogXCIyNFwiLFxuICAgIGhlaWdodDogXCIyNFwiLFxuICAgIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsXG4gICAgZmlsbDogXCJjdXJyZW50Q29sb3JcIixcbiAgICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgZDogXCJNMi42MTY4IDExLjEzMDNDMi42MTY4IDExLjEzMDMgMi43MDIzIDExLjAxMzEgMi44NzMzIDEwLjc3ODhDMy4wNDQzIDEwLjU0NDQgMy4xMjk4IDEwLjQyNzIgMy4xMjk4IDEwLjQyNzJDMy4xMjk4IDEwLjQyNzIgMy4yMzMzMyAxMC4yODIzIDMuNDQwNCA5Ljk5MjM2QzMuNjQ3NDYgOS43MDI0NiAzLjg1ODg5IDkuNDAzNDEgNC4wNzQ3IDkuMDk1MjFDNC4yOTA1IDguNzg3MDEgNC41MDYwNiA4LjQ3NTc0IDQuNzIxMzkgOC4xNjE0MUM0LjkzNjcxIDcuODQ3MDggNS4xNDMzOCA3LjU0MTM5IDUuMzQxNCA3LjI0NDMyQzUuNTM5NDMgNi45NDcyNiA1LjcyMDY4IDYuNjcxNjIgNS44ODUxNyA2LjQxNzQyQzYuMDQ5NjYgNi4xNjMyMSA2LjIxMTYgNS45MTQ3NyA2LjM3MDk5IDUuNjcyMTFDNi41MzAzOCA1LjQyOTQ0IDYuNjk1MjggNS4xODgwNiA2Ljg2NTY4IDQuOTQ3OTZDNy4wMzYwOCA0LjcwNzg2IDcuMjE2OTQgNC40Njk5IDcuNDA4MjQgNC4yMzQwOUM3LjU5OTU1IDMuOTk4MjggNy44MTA2MyAzLjc2Mjg3IDguMDQxNSAzLjUyNzg3QzguMjcyMzYgMy4yOTI4NiA4LjcxMTE0IDMuMDI2NyA5LjM1NzgyIDIuNzI5MzdDMTAuMDA0NSAyLjQzMjAzIDEwLjQ3MTMgMi4zNTI4MSAxMC43NTgxIDIuNDkxNjlDMTEuMDQ1IDIuNjMwNTcgMTEuMjYzNyAyLjg0MDQ5IDExLjQxNDEgMy4xMjE0NkMxMS41NjQ1IDMuNDAyNDMgMTEuNjE4IDMuNzAwNzkgMTEuNTc0NiA0LjAxNjUzQzExLjUzMTIgNC4zMzIyNyAxMS40NjI3IDQuNTk4OTEgMTEuMzY5MSA0LjgxNjQ2QzExLjI3NTYgNS4wMzQwMSAxMS4wODU4IDUuNDM5MTggMTAuNzk5OCA2LjAzMTk5QzEwLjUxMzkgNi42MjQ3OSAxMC4yMTIyIDcuMTc2MTcgOS44OTQ5OSA3LjY4NjEyQzkuNTc3NzMgOC4xOTYwNyA5LjI1MDQ4IDguNzE1MjkgOC45MTMyMyA5LjI0Mzc5QzguNTc1OTggOS43NzIyOSA4LjI0MTkzIDEwLjMwMzggNy45MTEwNyAxMC44MzgyQzcuNTgwMjEgMTEuMzcyNiA3LjI4MjggMTEuODcyOSA3LjAxODg1IDEyLjMzOUM2Ljc1NDg5IDEyLjgwNTEgNi41MzcxMSAxMy4yMjU5IDYuMzY1NTIgMTMuNjAxNEM2LjE5MzkzIDEzLjk3NyA2LjAxMzIgMTQuMzk1MSA1LjgyMzMyIDE0Ljg1NTdDNS42MzM0NCAxNS4zMTYzIDUuNDM3NzEgMTUuNjE3IDUuMjM2MTIgMTUuNzU3OEM1LjAzNDUzIDE1Ljg5ODYgNC44MDUzNyAxNS43OTkzIDQuNTQ4NjUgMTUuNDU5OUM0LjI5MTkzIDE1LjEyMDUgNC4xMTI0NCAxNC44NzIyIDQuMDEwMiAxNC43MTQ4QzMuOTA3OTYgMTQuNTU3NSAzLjk3MDA4IDE0LjM4MDIgNC4xOTY1NyAxNC4xODNDNC40MjMwNiAxMy45ODU4IDQuNjkwMTYgMTMuNzU4NCA0Ljk5Nzg5IDEzLjUwMDlDNS4zMDU2MSAxMy4yNDM0IDUuNjQyNDUgMTIuOTYxNyA2LjAwODM5IDEyLjY1NTlDNi4zNzQzNCAxMi4zNSA2LjY3NjE3IDEyLjA5NjcgNi45MTM4OSAxMS44OTU4QzcuMTUxNjEgMTEuNjk1IDcuMzkwMjYgMTEuNDkyNiA3LjYyOTg1IDExLjI4ODVDNy44Njk0NCAxMS4wODQ0IDguMTUzMzIgMTAuODQ2NyA4LjQ4MTQ4IDEwLjU3NTRDOC44MDk2NSAxMC4zMDQyIDkuMjM5MDcgOS45NTc3IDkuNzY5NzIgOS41MzYwNEMxMC4zMDA0IDkuMTE0MzkgMTAuODY3IDguNjY2MDQgMTEuNDY5NSA4LjE5MTAyQzEyLjA3MiA3LjcxNTk5IDEyLjY4NjkgNy4yMjk3NSAxMy4zMTQyIDYuNzMyMjlDMTMuOTQxNSA2LjIzNDgzIDE0LjU3NDEgNS43MzM3OCAxNS4yMTIxIDUuMjI5MTRDMTUuODUgNC43MjQ1IDE2LjQxNjggNC4yNjk1MyAxNi45MTI1IDMuODY0MjNDMTcuNDA4MSAzLjQ1ODkyIDE3Ljc3MzkgMy4xNDcxNSAxOC4wMDk5IDIuOTI4OTFDMTguMjQ1OSAyLjcxMDY2IDE4LjU5NjkgMi41MDkxMiAxOS4wNjMxIDIuMzI0MjdDMTkuNTI5MiAyLjEzOTQyIDE5Ljg3NTQgMi4xMDk0NyAyMC4xMDE3IDIuMjM0NDNDMjAuMzI4IDIuMzU5MzkgMjAuNDk1OSAyLjUzODkyIDIwLjYwNTYgMi43NzMwMkMyMC43MTUyIDMuMDA3MTIgMjAuNzQ1NSAzLjI1MTA4IDIwLjY5NjYgMy41MDQ4OUMyMC42NDc3IDMuNzU4NzEgMjAuNjEwOCAzLjkzNTM3IDIwLjU4NTkgNC4wMzQ4N0MyMC41NjEgNC4xMzQzNyAyMC40OTk4IDQuMzIzMDQgMjAuNDAyMyA0LjYwMDg4QzIwLjMwNDcgNC44Nzg3MiAyMC4xNjIxIDUuMTc0NDkgMTkuOTc0NSA1LjQ4ODJDMTkuNzg2OSA1LjgwMTkxIDE5LjU3NiA2LjE0NjY5IDE5LjM0MTkgNi41MjI1NkMxOS4xMDc4IDYuODk4NDIgMTguOTA4NiA3LjIxMzMxIDE4Ljc0NDMgNy40NjcyMkMxOC41OCA3LjcyMTEzIDE4LjQxNDIgNy45NzU5IDE4LjI0NjkgOC4yMzE1M0MxOC4wNzk2IDguNDg3MTYgMTcuODgzNiA4Ljc3ODYxIDE3LjY1ODggOS4xMDU4OEMxNy40MzQgOS40MzMxNiAxNy4xNDQ4IDkuODQyMDUgMTYuNzkxMiAxMC4zMzI2QzE2LjQzNzYgMTAuODIzMSAxNi4wNjU5IDExLjM0MiAxNS42NzYgMTEuODg5M0MxNS4yODYyIDEyLjQzNjUgMTQuOTAwMSAxMi45OTY4IDE0LjUxNzggMTMuNTcwMUMxNC4xMzU2IDE0LjE0MzUgMTMuNzY4MiAxNC43MjY0IDEzLjQxNTkgMTUuMzE5MUMxMy4wNjM1IDE1LjkxMTggMTIuNzU3OSAxNi40NjcxIDEyLjQ5ODkgMTYuOTg1QzEyLjI0IDE3LjUwMyAxMi4wNTMzIDE3Ljk1MjcgMTEuOTM4OSAxOC4zMzQyQzExLjgyNDQgMTguNzE1NiAxMS43MjI0IDE5LjEzNDcgMTEuNjMyNiAxOS41OTEyQzExLjU0MjkgMjAuMDQ3NyAxMS4zNzg4IDIwLjYwNDMgMTEuMTQwMiAyMS4yNjA5QzEwLjkwMTYgMjEuOTE3NSAxMC42NDI1IDIyLjI5OSAxMC4zNjI5IDIyLjQwNTRDMTAuMDgzMiAyMi41MTE4IDkuNzk4OTUgMjIuNTI1OCA5LjUxMDE1IDIyLjQ0NzVDOS4yMjEzNiAyMi4zNjkyIDguOTgzMTUgMjIuMjEzNSA4Ljc5NTU0IDIxLjk4MDRDOC42MDc5MyAyMS43NDczIDguNTMxNDEgMjEuNTQ0MyA4LjU2NTk3IDIxLjM3MTRDOC42MDA1NCAyMS4xOTg1IDguNjgwNSAyMC45MDU1IDguODA1ODYgMjAuNDkyNEM4LjkzMTIyIDIwLjA3OTQgOS4xMDY1NCAxOS43MzIyIDkuMzMxODIgMTkuNDUxMUM5LjU1NzA5IDE5LjE3IDkuODM5NiAxOC44MzQ3IDEwLjE3OTMgMTguNDQ1NEMxMC41MTkxIDE4LjA1NiAxMC44NTg4IDE3LjY3NTYgMTEuMTk4NSAxNy4zMDQxQzExLjUzODEgMTYuOTMyNiAxMS44Njc2IDE2LjU3OTggMTIuMTg3MSAxNi4yNDU3QzEyLjUwNjUgMTUuOTExNyAxMi44NDgxIDE1LjU1OTIgMTMuMjEyMSAxNS4xODgyQzEzLjU3NiAxNC44MTczIDEzLjk1NjcgMTQuNDQxOCAxNC4zNTQyIDE0LjA2MTZDMTQuNzUxNyAxMy42ODE0IDE1LjE2NjYgMTMuMzA4MiAxNS41OTkgMTIuOTQxOEMxNi4wMzEzIDEyLjU3NTUgMTYuNDM3IDEyLjI0ODkgMTYuODE1OSAxMS45NjJDMTcuMTk0OCAxMS42NzUyIDE3LjUxMDIgMTEuNDQyMyAxNy43NjIgMTEuMjYzNEMxOC4wMTM4IDExLjA4NDQgMTguMzA4NCAxMC44OTAyIDE4LjY0NTcgMTAuNjgwN0MxOC45ODMgMTAuNDcxMSAxOS4zNzQ0IDEwLjMyNDMgMTkuODIgMTAuMjQwMUMyMC4yNjU2IDEwLjE1NTkgMjAuNjUzNCAxMC4yNjkzIDIwLjk4MzQgMTAuNTgwM0MyMS4zMTM0IDEwLjg5MTMgMjEuNDQ5NiAxMS4yNzE3IDIxLjM5MiAxMS43MjE1QzIxLjMzNDQgMTIuMTcxMyAyMS4xMDY3IDEyLjUwNTEgMjAuNzA4OSAxMi43MjI5QzIwLjMxMTIgMTIuOTQwNiAxOS45MDczIDEyLjk1MjYgMTkuNDk3MyAxMi43NTg4QzE5LjA4NzMgMTIuNTY1IDE4Ljg0MDIgMTIuMjQ1MyAxOC43NTYxIDExLjc5OTdDMTguNjcxOSAxMS4zNTQxIDE4Ljc4NTMgMTAuOTY2MyAxOS4wOTYzIDEwLjYzNjNDMTkuNDA3MyAxMC4zMDYzIDE5Ljc4NzcgMTAuMTcwMSAyMC4yMzc1IDEwLjIyNzdDMjAuNjg3MyAxMC4yODUzIDIxLjAyMTEgMTAuNTEzIDIxLjIzODggMTAuOTEwOEMyMS40NTY2IDExLjMwODYgMjEuNDY4NiAxMS43MTI0IDIxLjI3NDggMTIuMTIyNEMyMS4wODEgMTIuNTMyNCAyMC44MDk1IDEyLjgzNDQgMjAuNDYwMyAxMy4wMjg2QzIwLjExMTEgMTMuMjIyNyAxOS44MDM4IDEzLjQwMDUgMTkuNTM4NCAxMy41NjE5QzE5LjI3MyAxMy43MjMzIDE4Ljk3MzIgMTMuOTMwNCAxOC42Mzg3IDE0LjE4MzRDMTguMzA0MyAxNC40MzY0IDE3Ljk0OTkgMTQuNzMwOSAxNy41NzU1IDE1LjA2NzFDMTcuMjAxIDE1LjQwMzIgMTYuODMzOCAxNS43NTY4IDE2LjQ3MzkgMTYuMTI3OEMxNi4xMTQgMTYuNDk4NyAxNS43NjIgMTYuODczOCAxNS40MTggMTcuMjUzQzE1LjA3NDEgMTcuNjMyMSAxNC43NDY3IDE3Ljk5MzkgMTQuNDM1OCAxOC4zMzgzQzE0LjEyNSAxOC42ODI2IDEzLjgwMDYgMTkuMDM0NiAxMy40NjI3IDE5LjM5NDFDMTMuMTI0OCAxOS43NTM3IDEyLjc4NDMgMjAuMTE1MSAxMi40NDExIDIwLjQ3ODRDMTIuMDk3OSAyMC44NDE3IDExLjc4MTEgMjEuMTc4NCAxMS40OTA3IDIxLjQ4ODVDMTEuMjAwMyAyMS43OTg3IDExLjAwOTcgMjIuMDAyNSAxMC45MTg3IDIyLjA5OThDMTAuODI3OCAyMi4xOTcxIDEwLjY0MjUgMjIuMjk5IDEwLjM2MjkgMjIuNDA1NEMxMC4wODMyIDIyLjUxMTggOS43OTg5NSAyMi41MjU4IDkuNTEwMTUgMjIuNDQ3NUM5LjIyMTM2IDIyLjM2OTIgOC45ODMxNSAyMi4yMTM1IDguNzk1NTQgMjEuOTgwNEM4LjYwNzkzIDIxLjc0NzMgOC41NjM2MSAyMS4yOTE1IDguNjYyNiAyMC42MTI5QzguNzYxNTggMTkuOTM0NCA4Ljg2MDI1IDE5LjQzMzYgOC45NTg2MSAxOS4xMTA0QzkuMDU2OTcgMTguNzg3MyA5LjE1OTc3IDE4LjQ3OTIgOS4yNjcgMTguMTg2QzkuMzc0MjMgMTcuODkyOSA5LjUxMDU5IDE3LjU3MjIgOS42NzYwOSAxNy4yMjQxQzkuODQxNTkgMTYuODc1OSAxMC4wNjE3IDE2LjQyMDggMTAuMzM2NSAxNS44NTg2QzEwLjYxMTMgMTUuMjk2MyAxMC45MTczIDE0LjY5MjggMTEuMjU0NCAxNC4wNDgxQzExLjU5MTUgMTMuNDAzMyAxMS45MzcxIDEyLjc3MDkgMTIuMjkxMSAxMi4xNTA5QzEyLjY0NSAxMS41MzA5IDEyLjk5ODUgMTAuOTI4IDEzLjM1MTUgMTAuMzQyMUMxMy43MDQ1IDkuNzU2MjggMTQuMDQzIDkuMjA1OTMgMTQuMzY2OSA4LjY5MTFDMTQuNjkwOCA4LjE3NjI4IDE0Ljk2MzcgNy43NTM3MSAxNS4xODU2IDcuNDIzMzlDMTUuNDA3NSA3LjA5MzA4IDE1LjYwNjQgNi44MDM2MiAxNS43ODI1IDYuNTU1MDFDMTUuOTU4NSA2LjMwNjQgMTYuMTMzNyA2LjA2MDA2IDE2LjMwNzggNS44MTU5OEMxNi40ODIgNS41NzE5IDE2LjY1MzMgNS4zMzI4OCAxNi44MjE3IDUuMDk4OTFDMTYuOTkwMSA0Ljg2NDk0IDE3LjIxNiA0LjU5NzM2IDE3LjQ5OTMgNC4yOTYxNUMxNy43ODI2IDMuOTk0OTUgMTguMTQ2MyAzLjYyNzEgMTguNTkwNCAzLjE5MjZDMTkuMDM0NSAyLjc1ODEgMTkuMzQwOSAyLjQ1ODU1IDE5LjUwOTQgMi4yOTM5MkMxOS42NzggMi4xMjkzIDE5Ljg3NTQgMi4xMDk0NyAyMC4xMDE3IDIuMjM0NDNDMjAuMzI4IDIuMzU5MzkgMjAuNDk1OSAyLjUzODkyIDIwLjYwNTYgMi43NzMwMkMyMC43MTUyIDMuMDA3MTIgMjAuNzQ1NSAzLjI1MTA4IDIwLjY5NjYgMy41MDQ4OUMyMC42NDc3IDMuNzU4NzEgMjAuMzU4NCA0LjA1NjkzIDE5LjgyODggNC4zOTk1N0MxOS4yOTkzIDQuNzQyMiAxOC43OTUzIDUuMTE3MTEgMTguMzE2OCA1LjUyNDMxQzE3LjgzODQgNS45MzE1MSAxNy4zMDU3IDYuNDA5MDcgMTYuNzE4OSA2Ljk1NzAxQzE2LjEzMjEgNy41MDQ5NSAxNS41NTQgOC4wNTg1IDE0Ljk4NDYgOC42MTc2NkMxNC40MTUxIDkuMTc2ODIgMTMuODU3MSA5LjcyOTM2IDEzLjMxMDQgMTAuMjc1M0MxMi43NjM3IDEwLjgyMTIgMTIuMjQzOSAxMS4zMzM0IDExLjc1MDkgMTEuODExOUMxMS4yNTggMTIuMjkwNSAxMC44NTE2IDEyLjY3NDcgMTAuNTMxOSAxMi45NjQ1QzEwLjIxMjIgMTMuMjU0MyA5LjkzMTAyIDEzLjUwMyA5LjY4ODQ0IDEzLjcxMDVDOS40NDU4NiAxMy45MTggOS4yMDM3NiAxNC4xMjQyIDguOTYyMTQgMTQuMzI5QzguNzIwNTEgMTQuNTMzOSA4LjQxMjIyIDE0Ljc5MTcgOC4wMzcyOCAxNS4xMDI3QzcuNjYyMzMgMTUuNDEzNiA3LjMwNTIgMTUuNzA0MiA2Ljk2NTg3IDE1Ljk3NDRDNi42MjY1NSAxNi4yNDQ3IDYuMzA2MTUgMTYuNDg2NyA2LjAwNDY4IDE2LjcwMDVDNS43MDMyMSAxNi45MTQzIDUuNDAyOCAxNy4xMDEyIDUuMTAzNDUgMTcuMjYxMUM0LjgwNDEgMTcuNDIxIDQuNDY1MjcgMTcuNDgyNyA0LjA4Njk3IDE3LjQ0NjJDMy43MDg2NyAxNy40MDk4IDMuMzYxNTcgMTcuMjA5IDMuMDQ1NjYgMTYuODQzOUMyLjcyOTc1IDE2LjQ3ODggMi41Nzc1IDE2LjA3ODUgMi41ODg5MSAxNS42NDMyQzIuNjAwMzMgMTUuMjA3OSAyLjcwNjc0IDE0Ljc2ODQgMi45MDgxNSAxNC4zMjQ4QzMuMTA5NTYgMTMuODgxMSAzLjI5NTQ2IDEzLjQ5MzkgMy40NjU4NiAxMy4xNjNDMy42MzYyNSAxMi44MzIgMy44MDc5OSAxMi41MTE2IDMuOTgxMDcgMTIuMjAxNkM0LjE1NDE1IDExLjg5MTYgNC4zNzIyMyAxMS40OTA0IDQuNjM1MyAxMC45OTc5QzQuODk4MzggMTAuNTA1NSA1LjE4MTQ4IDkuOTc4NjQgNS40ODQ2MSA5LjQxNzI3QzUuNzg3NzMgOC44NTU5IDYuMDg3MjMgOC4zMDQ3NyA2LjM4MzEgNy43NjM5QzYuNjc4OTggNy4yMjMwMiA2Ljk2MjEzIDYuNjk5NzYgNy4yMzI1NyA2LjE5NDEyQzcuNTAzMDEgNS42ODg0NyA3Ljc1NTg1IDUuMjQ0MDQgNy45OTEwOSA0Ljg2MDgxQzguMjI2MzMgNC40Nzc1OSA4LjU3NTA1IDQuMDQ2NzUgOS4wMzcyNSAzLjU2ODMxQzkuNDk5NDYgMy4wODk4NyA5LjgzMDEgMi43NTYxIDEwLjAyOTIgMi41NjcwMUMxMC4yMjgzIDIuMzc3OTEgMTAuNDcxMyAyLjM1MjgxIDEwLjc1ODEgMi40OTE2OUMxMS4wNDUgMi42MzA1NyAxMS4yNjM3IDIuODQwNDkgMTEuNDE0MSAzLjEyMTQ2QzExLjU2NDUgMy40MDI0MyAxMS42MTggMy43MDA3OSAxMS41NzQ2IDQuMDE2NTNDMTEuNTMxMiA0LjMzMjI3IDExLjE0MzkgNC43NzI3OCAxMC40MTI4IDUuMzM4MDdDOS42ODE3MyA1LjkwMzM2IDkuMTc4ODYgNi4zMDcxOCA4LjkwNDIxIDYuNTQ5NTNDOC42Mjk1NSA2Ljc5MTg4IDguMzgyNzMgNy4wMTM2NiA4LjE2Mzc0IDcuMjE0ODVDNy45NDQ3NSA3LjQxNjA1IDcuNzE1NTEgNy42MjE2IDcuNDc2MDMgNy44MzE1MUM3LjIzNjU1IDguMDQxNDEgNi45NzIyOSA4LjI2MzkxIDYuNjgzMjYgOC40OTkwMUM2LjM5NDIzIDguNzM0MSA2LjA5MjMzIDguOTY4NzYgNS43Nzc1NiA5LjIwMjk3QzUuNDYyNzkgOS40MzcxOSA1LjE0NjkgOS42NjE2IDQuODI5OSA5Ljg3NjIyQzQuNTEyOSAxMC4wOTA4IDQuMjAyMTEgMTAuMjkzMiAzLjg5NzUzIDEwLjQ4MzRMMi42MTY4IDExLjEzMDNaXCIsXG4gICAgc3Ryb2tlV2lkdGg6IFwiMC41XCIsXG4gICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiXG4gIH0pKTtcbn1cblxudmFyIHNlbGVjdENvbG9yID0gZnVuY3Rpb24gc2VsZWN0Q29sb3IoZGF0YSkge1xuICByZXR1cm4gZGF0YS5hcHBTdGF0ZS5zZWxlY3RlZFN0eWxlLmNvbG9yO1xufTtcblxudmFyIFF1aWNrQ29sb3JTZWxlY3QgPSAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyhmdW5jdGlvbiAoKSB7XG4gIHZhciBfdXNlVGhlbWUgPSB1c2VUaGVtZSgpLFxuICAgICAgdGhlbWUgPSBfdXNlVGhlbWUudGhlbWU7XG5cbiAgdmFyIF91c2VUTERyYXdDb250ZXh0ID0gdXNlVExEcmF3Q29udGV4dCgpLFxuICAgICAgdGxzdGF0ZSA9IF91c2VUTERyYXdDb250ZXh0LnRsc3RhdGUsXG4gICAgICB1c2VBcHBTdGF0ZSA9IF91c2VUTERyYXdDb250ZXh0LnVzZUFwcFN0YXRlO1xuXG4gIHZhciBjb2xvciA9IHVzZUFwcFN0YXRlKHNlbGVjdENvbG9yKTtcbiAgdmFyIGhhbmRsZUNvbG9yQ2hhbmdlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgdGxzdGF0ZS5zdHlsZSh7XG4gICAgICBjb2xvcjogY29sb3JcbiAgICB9KTtcbiAgfSwgW3Rsc3RhdGVdKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRHJvcGRvd25NZW51LlJvb3QsIHtcbiAgICBkaXI6IFwibHRyXCJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChEcm9wZG93bk1lbnVJY29uVHJpZ2dlckJ1dHRvbiwge1xuICAgIGxhYmVsOiBcIkNvbG9yXCJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChCb3hJY29uLCB7XG4gICAgZmlsbDogc3Ryb2tlc1t0aGVtZV1bY29sb3JdLFxuICAgIHN0cm9rZTogc3Ryb2tlc1t0aGVtZV1bY29sb3JdXG4gIH0pKSwgUmVhY3QuY3JlYXRlRWxlbWVudChEcm9wZG93bk1lbnUuQ29udGVudCwge1xuICAgIHNpZGVPZmZzZXQ6IDhcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChEcm9wZG93bk1lbnUuRHJvcGRvd25NZW51UmFkaW9Hcm91cCwge1xuICAgIHZhbHVlOiBjb2xvcixcbiAgICBvblZhbHVlQ2hhbmdlOiBoYW5kbGVDb2xvckNoYW5nZSxcbiAgICBhczogU3R5bGVEcm9wZG93bkNvbnRlbnRcbiAgfSwgT2JqZWN0LmtleXMoc3Ryb2tlc1t0aGVtZV0pLm1hcChmdW5jdGlvbiAoY29sb3JTdHlsZSkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KERyb3Bkb3duTWVudS5Ecm9wZG93bk1lbnVSYWRpb0l0ZW0sIHtcbiAgICAgIGFzOiBTdHlsZURyb3Bkb3duSXRlbSxcbiAgICAgIGtleTogY29sb3JTdHlsZSxcbiAgICAgIHRpdGxlOiBjb2xvclN0eWxlLFxuICAgICAgdmFsdWU6IGNvbG9yU3R5bGVcbiAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KEJveEljb24sIHtcbiAgICAgIGZpbGw6IHN0cm9rZXNbdGhlbWVdW2NvbG9yU3R5bGVdLFxuICAgICAgc3Ryb2tlOiBzdHJva2VzW3RoZW1lXVtjb2xvclN0eWxlXVxuICAgIH0pKTtcbiAgfSkpKSk7XG59KTtcblxudmFyIF9zaXplcztcbnZhciBzaXplcyA9IChfc2l6ZXMgPSB7fSwgX3NpemVzW2V4cG9ydHMuU2l6ZVN0eWxlLlNtYWxsXSA9IDYsIF9zaXplc1tleHBvcnRzLlNpemVTdHlsZS5NZWRpdW1dID0gMTIsIF9zaXplc1tleHBvcnRzLlNpemVTdHlsZS5MYXJnZV0gPSAyMiwgX3NpemVzKTtcblxudmFyIHNlbGVjdFNpemUgPSBmdW5jdGlvbiBzZWxlY3RTaXplKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuYXBwU3RhdGUuc2VsZWN0ZWRTdHlsZS5zaXplO1xufTtcblxudmFyIFF1aWNrU2l6ZVNlbGVjdCA9IC8qI19fUFVSRV9fKi9SZWFjdC5tZW1vKGZ1bmN0aW9uICgpIHtcbiAgdmFyIF91c2VUTERyYXdDb250ZXh0ID0gdXNlVExEcmF3Q29udGV4dCgpLFxuICAgICAgdGxzdGF0ZSA9IF91c2VUTERyYXdDb250ZXh0LnRsc3RhdGUsXG4gICAgICB1c2VBcHBTdGF0ZSA9IF91c2VUTERyYXdDb250ZXh0LnVzZUFwcFN0YXRlO1xuXG4gIHZhciBzaXplID0gdXNlQXBwU3RhdGUoc2VsZWN0U2l6ZSk7XG4gIHZhciBjaGFuZ2VTaXplU3R5bGUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoc2l6ZSkge1xuICAgIHRsc3RhdGUuc3R5bGUoe1xuICAgICAgc2l6ZTogc2l6ZVxuICAgIH0pO1xuICB9LCBbdGxzdGF0ZV0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChEcm9wZG93bk1lbnUuUm9vdCwge1xuICAgIGRpcjogXCJsdHJcIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KERyb3Bkb3duTWVudUljb25UcmlnZ2VyQnV0dG9uLCB7XG4gICAgbGFiZWw6IFwiU2l6ZVwiXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2lyY2xlSWNvbiwge1xuICAgIHNpemU6IHNpemVzW3NpemVdLFxuICAgIHN0cm9rZTogXCJub25lXCIsXG4gICAgZmlsbDogXCJjdXJyZW50Q29sb3JcIlxuICB9KSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRHJvcGRvd25NZW51LkNvbnRlbnQsIHtcbiAgICBzaWRlT2Zmc2V0OiA4XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRHJvcGRvd25NZW51LkRyb3Bkb3duTWVudVJhZGlvR3JvdXAsIHtcbiAgICBhczogU3R5bGVEcm9wZG93bkNvbnRlbnQsXG4gICAgZGlyZWN0aW9uOiBcInZlcnRpY2FsXCIsXG4gICAgdmFsdWU6IHNpemUsXG4gICAgb25WYWx1ZUNoYW5nZTogY2hhbmdlU2l6ZVN0eWxlXG4gIH0sIE9iamVjdC5rZXlzKGV4cG9ydHMuU2l6ZVN0eWxlKS5tYXAoZnVuY3Rpb24gKHNpemVTdHlsZSkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KERyb3Bkb3duTWVudS5Ecm9wZG93bk1lbnVSYWRpb0l0ZW0sIHtcbiAgICAgIGtleTogc2l6ZVN0eWxlLFxuICAgICAgYXM6IFN0eWxlRHJvcGRvd25JdGVtLFxuICAgICAgaXNBY3RpdmU6IHNpemUgPT09IHNpemVTdHlsZSxcbiAgICAgIHZhbHVlOiBzaXplU3R5bGVcbiAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KENpcmNsZUljb24sIHtcbiAgICAgIHNpemU6IHNpemVzW3NpemVTdHlsZV1cbiAgICB9KSk7XG4gIH0pKSkpO1xufSk7XG5cbnZhciBfZGFzaGVzO1xudmFyIGRhc2hlcyA9IChfZGFzaGVzID0ge30sIF9kYXNoZXNbZXhwb3J0cy5EYXNoU3R5bGUuRHJhd10gPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEYXNoRHJhd0ljb24sIG51bGwpLCBfZGFzaGVzW2V4cG9ydHMuRGFzaFN0eWxlLlNvbGlkXSA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KERhc2hTb2xpZEljb24sIG51bGwpLCBfZGFzaGVzW2V4cG9ydHMuRGFzaFN0eWxlLkRhc2hlZF0gPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEYXNoRGFzaGVkSWNvbiwgbnVsbCksIF9kYXNoZXNbZXhwb3J0cy5EYXNoU3R5bGUuRG90dGVkXSA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KERhc2hEb3R0ZWRJY29uLCBudWxsKSwgX2Rhc2hlcyk7XG5cbnZhciBzZWxlY3REYXNoID0gZnVuY3Rpb24gc2VsZWN0RGFzaChkYXRhKSB7XG4gIHJldHVybiBkYXRhLmFwcFN0YXRlLnNlbGVjdGVkU3R5bGUuZGFzaDtcbn07XG5cbnZhciBRdWlja0Rhc2hTZWxlY3QgPSAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyhmdW5jdGlvbiAoKSB7XG4gIHZhciBfdXNlVExEcmF3Q29udGV4dCA9IHVzZVRMRHJhd0NvbnRleHQoKSxcbiAgICAgIHRsc3RhdGUgPSBfdXNlVExEcmF3Q29udGV4dC50bHN0YXRlLFxuICAgICAgdXNlQXBwU3RhdGUgPSBfdXNlVExEcmF3Q29udGV4dC51c2VBcHBTdGF0ZTtcblxuICB2YXIgZGFzaCA9IHVzZUFwcFN0YXRlKHNlbGVjdERhc2gpO1xuICB2YXIgY2hhbmdlRGFzaFN0eWxlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGRhc2gpIHtcbiAgICB0bHN0YXRlLnN0eWxlKHtcbiAgICAgIGRhc2g6IGRhc2hcbiAgICB9KTtcbiAgfSwgW3Rsc3RhdGVdKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRHJvcGRvd25NZW51LlJvb3QsIHtcbiAgICBkaXI6IFwibHRyXCJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChEcm9wZG93bk1lbnVJY29uVHJpZ2dlckJ1dHRvbiwge1xuICAgIGxhYmVsOiBcIkRhc2hcIlxuICB9LCBkYXNoZXNbZGFzaF0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KERyb3Bkb3duTWVudS5Db250ZW50LCB7XG4gICAgc2lkZU9mZnNldDogOFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KERyb3Bkb3duTWVudS5Ecm9wZG93bk1lbnVSYWRpb0dyb3VwLCB7XG4gICAgYXM6IFN0eWxlRHJvcGRvd25Db250ZW50LFxuICAgIGRpcmVjdGlvbjogXCJ2ZXJ0aWNhbFwiLFxuICAgIHZhbHVlOiBkYXNoLFxuICAgIG9uVmFsdWVDaGFuZ2U6IGNoYW5nZURhc2hTdHlsZVxuICB9LCBPYmplY3Qua2V5cyhleHBvcnRzLkRhc2hTdHlsZSkubWFwKGZ1bmN0aW9uIChkYXNoU3R5bGUpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChEcm9wZG93bk1lbnUuRHJvcGRvd25NZW51UmFkaW9JdGVtLCB7XG4gICAgICBhczogU3R5bGVEcm9wZG93bkl0ZW0sXG4gICAgICBrZXk6IGRhc2hTdHlsZSxcbiAgICAgIGlzQWN0aXZlOiBkYXNoID09PSBkYXNoU3R5bGUsXG4gICAgICB2YWx1ZTogZGFzaFN0eWxlXG4gICAgfSwgZGFzaGVzW2Rhc2hTdHlsZV0pO1xuICB9KSkpKTtcbn0pO1xuXG52YXIgaXNGaWxsZWRTZWxlY3RvciA9IGZ1bmN0aW9uIGlzRmlsbGVkU2VsZWN0b3IoZGF0YSkge1xuICByZXR1cm4gZGF0YS5hcHBTdGF0ZS5zZWxlY3RlZFN0eWxlLmlzRmlsbGVkO1xufTtcblxudmFyIFF1aWNrRmlsbFNlbGVjdCA9IC8qI19fUFVSRV9fKi9SZWFjdC5tZW1vKGZ1bmN0aW9uICgpIHtcbiAgdmFyIF91c2VUTERyYXdDb250ZXh0ID0gdXNlVExEcmF3Q29udGV4dCgpLFxuICAgICAgdGxzdGF0ZSA9IF91c2VUTERyYXdDb250ZXh0LnRsc3RhdGUsXG4gICAgICB1c2VBcHBTdGF0ZSA9IF91c2VUTERyYXdDb250ZXh0LnVzZUFwcFN0YXRlO1xuXG4gIHZhciBpc0ZpbGxlZCA9IHVzZUFwcFN0YXRlKGlzRmlsbGVkU2VsZWN0b3IpO1xuICB2YXIgaGFuZGxlSXNGaWxsZWRDaGFuZ2UgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoaXNGaWxsZWQpIHtcbiAgICB0bHN0YXRlLnN0eWxlKHtcbiAgICAgIGlzRmlsbGVkOiBpc0ZpbGxlZFxuICAgIH0pO1xuICB9LCBbdGxzdGF0ZV0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDaGVja2JveC5Sb290LCB7XG4gICAgZGlyOiBcImx0clwiLFxuICAgIGFzOiBJY29uQnV0dG9uLFxuICAgIGJwOiBicmVha3BvaW50cyxcbiAgICBjaGVja2VkOiBpc0ZpbGxlZCxcbiAgICBvbkNoZWNrZWRDaGFuZ2U6IGhhbmRsZUlzRmlsbGVkQ2hhbmdlXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVG9vbHRpcCwge1xuICAgIGxhYmVsOiBcIkZpbGxcIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KEljb25XcmFwcGVyLCBudWxsLCBSZWFjdC5jcmVhdGVFbGVtZW50KEJveEljb24sIG51bGwpLCBSZWFjdC5jcmVhdGVFbGVtZW50KENoZWNrYm94LkluZGljYXRvciwgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChJc0ZpbGxlZEZpbGxJY29uLCBudWxsKSkpKSk7XG59KTtcblxudmFyIGlzU3R5bGVPcGVuU2VsZWN0b3IgPSBmdW5jdGlvbiBpc1N0eWxlT3BlblNlbGVjdG9yKHMpIHtcbiAgcmV0dXJuIHMuYXBwU3RhdGUuaXNTdHlsZU9wZW47XG59O1xuXG5mdW5jdGlvbiBTdHlsZVBhbmVsKCkge1xuICB2YXIgX3VzZVRMRHJhd0NvbnRleHQgPSB1c2VUTERyYXdDb250ZXh0KCksXG4gICAgICB0bHN0YXRlID0gX3VzZVRMRHJhd0NvbnRleHQudGxzdGF0ZSxcbiAgICAgIHVzZUFwcFN0YXRlID0gX3VzZVRMRHJhd0NvbnRleHQudXNlQXBwU3RhdGU7XG5cbiAgdmFyIGlzT3BlbiA9IHVzZUFwcFN0YXRlKGlzU3R5bGVPcGVuU2VsZWN0b3IpO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChGbG9hdGluZ0NvbnRhaW5lciwge1xuICAgIGRpcmVjdGlvbjogXCJjb2x1bW5cIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KEJ1dHRvbnNSb3csIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUXVpY2tDb2xvclNlbGVjdCwgbnVsbCksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUXVpY2tTaXplU2VsZWN0LCBudWxsKSwgUmVhY3QuY3JlYXRlRWxlbWVudChRdWlja0Rhc2hTZWxlY3QsIG51bGwpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFF1aWNrRmlsbFNlbGVjdCwgbnVsbCksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSWNvbkJ1dHRvbiwge1xuICAgIGJwOiBicmVha3BvaW50cyxcbiAgICB0aXRsZTogXCJTdHlsZVwiLFxuICAgIHNpemU6IFwic21hbGxcIixcbiAgICBvblBvaW50ZXJEb3duOiB0bHN0YXRlLnRvZ2dsZVN0eWxlUGFuZWxcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChUb29sdGlwLCB7XG4gICAgbGFiZWw6IGlzT3BlbiA/ICdDbG9zZScgOiAnTW9yZSdcbiAgfSwgaXNPcGVuID8gUmVhY3QuY3JlYXRlRWxlbWVudChyZWFjdEljb25zLkNyb3NzMkljb24sIG51bGwpIDogUmVhY3QuY3JlYXRlRWxlbWVudChyZWFjdEljb25zLkRvdHNIb3Jpem9udGFsSWNvbiwgbnVsbCkpKSksIGlzT3BlbiAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KFNlbGVjdGVkU2hhcGVDb250ZW50LCBudWxsKSk7XG59XG52YXIgc2hvd0tiZHMgPSAhIC8qI19fUFVSRV9fKi9jb3JlLlV0aWxzLmlzTW9iaWxlKCk7XG5cbnZhciBzZWxlY3RlZFNoYXBlc0NvdW50U2VsZWN0b3IgPSBmdW5jdGlvbiBzZWxlY3RlZFNoYXBlc0NvdW50U2VsZWN0b3Iocykge1xuICByZXR1cm4gcy5wYWdlU3RhdGUuc2VsZWN0ZWRJZHMubGVuZ3RoO1xufTtcblxuZnVuY3Rpb24gU2VsZWN0ZWRTaGFwZUNvbnRlbnQoKSB7XG4gIHZhciBfdXNlVExEcmF3Q29udGV4dDIgPSB1c2VUTERyYXdDb250ZXh0KCksXG4gICAgICB0bHN0YXRlID0gX3VzZVRMRHJhd0NvbnRleHQyLnRsc3RhdGUsXG4gICAgICB1c2VBcHBTdGF0ZSA9IF91c2VUTERyYXdDb250ZXh0Mi51c2VBcHBTdGF0ZTtcblxuICB2YXIgc2VsZWN0ZWRTaGFwZXNDb3VudCA9IHVzZUFwcFN0YXRlKHNlbGVjdGVkU2hhcGVzQ291bnRTZWxlY3Rvcik7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBSZWFjdC5jcmVhdGVFbGVtZW50KERpdmlkZXIsIG51bGwpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFNoYXBlc0Z1bmN0aW9ucywgbnVsbCksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRGl2aWRlciwgbnVsbCksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQWxpZ25EaXN0cmlidXRlLCB7XG4gICAgaGFzVHdvT3JNb3JlOiBzZWxlY3RlZFNoYXBlc0NvdW50ID4gMSxcbiAgICBoYXNUaHJlZU9yTW9yZTogc2VsZWN0ZWRTaGFwZXNDb3VudCA+IDJcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRGl2aWRlciwgbnVsbCksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm93QnV0dG9uLCB7XG4gICAgYnA6IGJyZWFrcG9pbnRzLFxuICAgIGRpc2FibGVkOiBzZWxlY3RlZFNoYXBlc0NvdW50ID09PSAwLFxuICAgIG9uQ2xpY2s6IHRsc3RhdGUuY29weVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCBcIkNvcHlcIiksIHNob3dLYmRzICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoS2JkLCB7XG4gICAgdmFyaWFudDogXCJtZW51XCJcbiAgfSwgXCIjQ1wiKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm93QnV0dG9uLCB7XG4gICAgYnA6IGJyZWFrcG9pbnRzLFxuICAgIG9uQ2xpY2s6IHRsc3RhdGUucGFzdGVcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgXCJQYXN0ZVwiKSwgc2hvd0tiZHMgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChLYmQsIHtcbiAgICB2YXJpYW50OiBcIm1lbnVcIlxuICB9LCBcIiNWXCIpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChSb3dCdXR0b24sIHtcbiAgICBicDogYnJlYWtwb2ludHMsXG4gICAgb25DbGljazogdGxzdGF0ZS5jb3B5QXNTdmdcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgXCJDb3B5IHRvIFNWR1wiKSwgc2hvd0tiZHMgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChLYmQsIHtcbiAgICB2YXJpYW50OiBcIm1lbnVcIlxuICB9LCBcIlxcdTIxRTcjQ1wiKSkpO1xufVxuXG52YXIgYWN0aXZlVG9vbFNlbGVjdG9yID0gZnVuY3Rpb24gYWN0aXZlVG9vbFNlbGVjdG9yKHMpIHtcbiAgcmV0dXJuIHMuYXBwU3RhdGUuYWN0aXZlVG9vbDtcbn07XG5cbmZ1bmN0aW9uIFN0YXR1c0JhcigpIHtcbiAgdmFyIF91c2VUTERyYXdDb250ZXh0ID0gdXNlVExEcmF3Q29udGV4dCgpLFxuICAgICAgdXNlQXBwU3RhdGUgPSBfdXNlVExEcmF3Q29udGV4dC51c2VBcHBTdGF0ZTtcblxuICB2YXIgYWN0aXZlVG9vbCA9IHVzZUFwcFN0YXRlKGFjdGl2ZVRvb2xTZWxlY3Rvcik7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFN0YXR1c0JhckNvbnRhaW5lciwge1xuICAgIHNpemU6IHtcbiAgICAgICdAc20nOiAnc21hbGwnXG4gICAgfVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFNlY3Rpb24sIG51bGwsIGFjdGl2ZVRvb2wpKTtcbn1cbnZhciBTdGF0dXNCYXJDb250YWluZXIgPSAvKiNfX1BVUkVfXyovc3R5bGVkKCdkaXYnLCB7XG4gIGhlaWdodDogNDAsXG4gIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgYm9yZGVyVG9wOiAnMXB4IHNvbGlkICRib3JkZXInLFxuICBncmlkQXJlYTogJ3N0YXR1cycsXG4gIGRpc3BsYXk6ICdmbGV4JyxcbiAgY29sb3I6ICckdGV4dCcsXG4gIGp1c3RpZnlDb250ZW50OiAnc3BhY2UtYmV0d2VlbicsXG4gIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICBiYWNrZ3JvdW5kQ29sb3I6ICckcGFuZWwnLFxuICBnYXA6IDgsXG4gIGZvbnRGYW1pbHk6ICckdWknLFxuICBmb250U2l6ZTogJyQwJyxcbiAgcGFkZGluZzogJzAgMTZweCcsXG4gIHZhcmlhbnRzOiB7XG4gICAgc2l6ZToge1xuICAgICAgc21hbGw6IHtcbiAgICAgICAgZm9udFNpemU6ICckMSdcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xudmFyIFNlY3Rpb24gPSAvKiNfX1BVUkVfXyovc3R5bGVkKCdkaXYnLCB7XG4gIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICBvdmVyZmxvdzogJ2hpZGRlbidcbn0pO1xuXG52YXIgVG9vbEJ1dHRvbiA9IC8qI19fUFVSRV9fKi9zdHlsZWQoJ2J1dHRvbicsIHtcbiAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gIGhlaWdodDogJzMycHgnLFxuICB3aWR0aDogJzMycHgnLFxuICBjb2xvcjogJyR0ZXh0JyxcbiAgYmFja2dyb3VuZENvbG9yOiAnJHBhbmVsJyxcbiAgYm9yZGVyUmFkaXVzOiAnNHB4JyxcbiAgcGFkZGluZzogJzAnLFxuICBtYXJnaW46ICcwJyxcbiAgZGlzcGxheTogJ2dyaWQnLFxuICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxuICBvdXRsaW5lOiAnbm9uZScsXG4gIGJvcmRlcjogJ25vbmUnLFxuICBwb2ludGVyRXZlbnRzOiAnYWxsJyxcbiAgZm9udFNpemU6ICckMCcsXG4gIGN1cnNvcjogJ3BvaW50ZXInLFxuICAnJiA+IConOiB7XG4gICAgZ3JpZFJvdzogMSxcbiAgICBncmlkQ29sdW1uOiAxXG4gIH0sXG4gICcmOmRpc2FibGVkJzoge1xuICAgIG9wYWNpdHk6ICcwLjUnXG4gIH0sXG4gICcmID4gc3Bhbic6IHtcbiAgICB3aWR0aDogJzEwMCUnLFxuICAgIGhlaWdodDogJzEwMCUnLFxuICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJ1xuICB9XG59KTtcbnZhciBQcmltYXJ5VG9vbEJ1dHRvbiA9IC8qI19fUFVSRV9fKi9zdHlsZWQoVG9vbEJ1dHRvbiwge1xuICB2YXJpYW50czoge1xuICAgIGJwOiB7XG4gICAgICBtb2JpbGU6IHtcbiAgICAgICAgaGVpZ2h0OiA0NCxcbiAgICAgICAgd2lkdGg6IDQ0LFxuICAgICAgICAnJiBzdmc6bnRoLW9mLXR5cGUoMSknOiB7XG4gICAgICAgICAgaGVpZ2h0OiAnMjBweCcsXG4gICAgICAgICAgd2lkdGg6ICcyMHB4J1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc21hbGw6IHtcbiAgICAgICAgJyY6aG92ZXI6bm90KDpkaXNhYmxlZCknOiB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnJGhvdmVyJ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWVkaXVtOiB7fSxcbiAgICAgIGxhcmdlOiB7fVxuICAgIH0sXG4gICAgaXNBY3RpdmU6IHtcbiAgICAgIFwidHJ1ZVwiOiB7XG4gICAgICAgIGNvbG9yOiAnJHNlbGVjdGVkJ1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG52YXIgU2Vjb25kYXJ5VG9vbEJ1dHRvbiA9IC8qI19fUFVSRV9fKi9zdHlsZWQoVG9vbEJ1dHRvbiwge1xuICB2YXJpYW50czoge1xuICAgIGJwOiB7XG4gICAgICBtb2JpbGU6IHtcbiAgICAgICAgaGVpZ2h0OiA0NCxcbiAgICAgICAgd2lkdGg6IDQ0LFxuICAgICAgICAnJiBzdmc6bnRoLW9mLXR5cGUoMSknOiB7XG4gICAgICAgICAgaGVpZ2h0OiAnMThweCcsXG4gICAgICAgICAgd2lkdGg6ICcxOHB4J1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc21hbGw6IHtcbiAgICAgICAgJyY6aG92ZXI6bm90KDpkaXNhYmxlZCknOiB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnJGhvdmVyJ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWVkaXVtOiB7fSxcbiAgICAgIGxhcmdlOiB7fVxuICAgIH0sXG4gICAgaXNBY3RpdmU6IHtcbiAgICAgIFwidHJ1ZVwiOiB7XG4gICAgICAgIGNvbG9yOiAnJHNlbGVjdGVkJ1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG52YXIgVGVydGlhcnlUb29sQnV0dG9uID0gLyojX19QVVJFX18qL3N0eWxlZChUb29sQnV0dG9uLCB7XG4gIHZhcmlhbnRzOiB7XG4gICAgYnA6IHtcbiAgICAgIG1vYmlsZToge1xuICAgICAgICBoZWlnaHQ6IDMyLFxuICAgICAgICB3aWR0aDogNDQsXG4gICAgICAgICcmIHN2ZzpudGgtb2YtdHlwZSgxKSc6IHtcbiAgICAgICAgICBoZWlnaHQ6ICcxNnB4JyxcbiAgICAgICAgICB3aWR0aDogJzE2cHgnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzbWFsbDoge1xuICAgICAgICBoZWlnaHQ6IDQwLFxuICAgICAgICB3aWR0aDogNDAsXG4gICAgICAgICcmIHN2ZzpudGgtb2YtdHlwZSgxKSc6IHtcbiAgICAgICAgICBoZWlnaHQ6ICcxOHB4JyxcbiAgICAgICAgICB3aWR0aDogJzE4cHgnXG4gICAgICAgIH0sXG4gICAgICAgICcmOmhvdmVyOm5vdCg6ZGlzYWJsZWQpJzoge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyRob3ZlcidcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1lZGl1bToge30sXG4gICAgICBsYXJnZToge31cbiAgICB9XG4gIH1cbn0pO1xuZnVuY3Rpb24gUHJpbWFyeUJ1dHRvbihfcmVmKSB7XG4gIHZhciBsYWJlbCA9IF9yZWYubGFiZWwsXG4gICAgICBrYmQgPSBfcmVmLmtiZCxcbiAgICAgIG9uQ2xpY2sgPSBfcmVmLm9uQ2xpY2ssXG4gICAgICBvbkRvdWJsZUNsaWNrID0gX3JlZi5vbkRvdWJsZUNsaWNrLFxuICAgICAgaXNBY3RpdmUgPSBfcmVmLmlzQWN0aXZlLFxuICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChUb29sdGlwLCB7XG4gICAgbGFiZWw6IGxhYmVsWzBdLnRvVXBwZXJDYXNlKCkgKyBsYWJlbC5zbGljZSgxKSxcbiAgICBrYmQ6IGtiZFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFByaW1hcnlUb29sQnV0dG9uLCB7XG4gICAgbmFtZTogbGFiZWwsXG4gICAgYnA6IHtcbiAgICAgICdAaW5pdGlhbCc6ICdtb2JpbGUnLFxuICAgICAgJ0BzbSc6ICdzbWFsbCcsXG4gICAgICAnQG1kJzogJ21lZGl1bScsXG4gICAgICAnQGxnJzogJ2xhcmdlJ1xuICAgIH0sXG4gICAgb25DbGljazogb25DbGljayxcbiAgICBvbkRvdWJsZUNsaWNrOiBvbkRvdWJsZUNsaWNrLFxuICAgIGlzQWN0aXZlOiBpc0FjdGl2ZVxuICB9LCBjaGlsZHJlbikpO1xufVxuZnVuY3Rpb24gU2Vjb25kYXJ5QnV0dG9uKF9yZWYyKSB7XG4gIHZhciBsYWJlbCA9IF9yZWYyLmxhYmVsLFxuICAgICAga2JkID0gX3JlZjIua2JkLFxuICAgICAgb25DbGljayA9IF9yZWYyLm9uQ2xpY2ssXG4gICAgICBvbkRvdWJsZUNsaWNrID0gX3JlZjIub25Eb3VibGVDbGljayxcbiAgICAgIGlzQWN0aXZlID0gX3JlZjIuaXNBY3RpdmUsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYyLmNoaWxkcmVuO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChUb29sdGlwLCB7XG4gICAgbGFiZWw6IGxhYmVsWzBdLnRvVXBwZXJDYXNlKCkgKyBsYWJlbC5zbGljZSgxKSxcbiAgICBrYmQ6IGtiZFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFNlY29uZGFyeVRvb2xCdXR0b24sIHtcbiAgICBuYW1lOiBsYWJlbCxcbiAgICBicDoge1xuICAgICAgJ0Bpbml0aWFsJzogJ21vYmlsZScsXG4gICAgICAnQHNtJzogJ3NtYWxsJyxcbiAgICAgICdAbWQnOiAnbWVkaXVtJyxcbiAgICAgICdAbGcnOiAnbGFyZ2UnXG4gICAgfSxcbiAgICBvbkNsaWNrOiBvbkNsaWNrLFxuICAgIG9uRG91YmxlQ2xpY2s6IG9uRG91YmxlQ2xpY2ssXG4gICAgaXNBY3RpdmU6IGlzQWN0aXZlXG4gIH0sIGNoaWxkcmVuKSk7XG59XG5mdW5jdGlvbiBUZXJ0aWFyeUJ1dHRvbihfcmVmMykge1xuICB2YXIgbGFiZWwgPSBfcmVmMy5sYWJlbCxcbiAgICAgIGtiZCA9IF9yZWYzLmtiZCxcbiAgICAgIG9uQ2xpY2sgPSBfcmVmMy5vbkNsaWNrLFxuICAgICAgb25Eb3VibGVDbGljayA9IF9yZWYzLm9uRG91YmxlQ2xpY2ssXG4gICAgICBjaGlsZHJlbiA9IF9yZWYzLmNoaWxkcmVuO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChUb29sdGlwLCB7XG4gICAgbGFiZWw6IGxhYmVsWzBdLnRvVXBwZXJDYXNlKCkgKyBsYWJlbC5zbGljZSgxKSxcbiAgICBrYmQ6IGtiZFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFRlcnRpYXJ5VG9vbEJ1dHRvbiwge1xuICAgIG5hbWU6IGxhYmVsLFxuICAgIGJwOiB7XG4gICAgICAnQGluaXRpYWwnOiAnbW9iaWxlJyxcbiAgICAgICdAc20nOiAnc21hbGwnLFxuICAgICAgJ0BtZCc6ICdtZWRpdW0nLFxuICAgICAgJ0BsZyc6ICdsYXJnZSdcbiAgICB9LFxuICAgIG9uQ2xpY2s6IG9uQ2xpY2ssXG4gICAgb25Eb3VibGVDbGljazogb25Eb3VibGVDbGlja1xuICB9LCBjaGlsZHJlbikpO1xufVxudmFyIFRlcnRpYXJ5QnV0dG9uc0NvbnRhaW5lciA9IC8qI19fUFVSRV9fKi9zdHlsZWQoRmxvYXRpbmdDb250YWluZXIsIHtcbiAgYm94U2hhZG93OiAnJDMnLFxuICB2YXJpYW50czoge1xuICAgIGJwOiB7XG4gICAgICBtb2JpbGU6IHtcbiAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nXG4gICAgICB9LFxuICAgICAgc21hbGw6IHtcbiAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgIGZsZXhEaXJlY3Rpb246ICdyb3cnXG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcblxudmFyIFVuZG9SZWRvID0gLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oZnVuY3Rpb24gKCkge1xuICB2YXIgX3VzZVRMRHJhd0NvbnRleHQgPSB1c2VUTERyYXdDb250ZXh0KCksXG4gICAgICB0bHN0YXRlID0gX3VzZVRMRHJhd0NvbnRleHQudGxzdGF0ZTtcblxuICB2YXIgaGFuZGxlRGVsZXRlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHRsc3RhdGVbXCJkZWxldGVcIl0oKTtcbiAgfSwgW3Rsc3RhdGVdKTtcbiAgdmFyIGhhbmRsZUNsZWFyID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHRsc3RhdGUuY2xlYXIoKTtcbiAgfSwgW3Rsc3RhdGVdKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGVydGlhcnlCdXR0b25zQ29udGFpbmVyLCB7XG4gICAgYnA6IHtcbiAgICAgICdAaW5pdGlhbCc6ICdtb2JpbGUnLFxuICAgICAgJ0BzbSc6ICdzbWFsbCdcbiAgICB9XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGVydGlhcnlCdXR0b24sIHtcbiAgICBsYWJlbDogXCJVbmRvXCIsXG4gICAga2JkOiBcIiNaXCIsXG4gICAgb25DbGljazogdGxzdGF0ZS51bmRvXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU3ZnVW5kbywgbnVsbCkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFRlcnRpYXJ5QnV0dG9uLCB7XG4gICAgbGFiZWw6IFwiUmVkb1wiLFxuICAgIGtiZDogXCIjXFx1MjFFN1wiLFxuICAgIG9uQ2xpY2s6IHRsc3RhdGUucmVkb1xuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFN2Z1JlZG8sIG51bGwpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChUZXJ0aWFyeUJ1dHRvbiwge1xuICAgIGxhYmVsOiBcIkRlbGV0ZVwiLFxuICAgIGtiZDogXCJcXHUyMzJCXCIsXG4gICAgb25DbGljazogaGFuZGxlRGVsZXRlLFxuICAgIG9uRG91YmxlQ2xpY2s6IGhhbmRsZUNsZWFyXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU3ZnVHJhc2gsIG51bGwpKSk7XG59KTtcblxudmFyIFpvb20gPSAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyhmdW5jdGlvbiAoKSB7XG4gIHZhciBfdXNlVExEcmF3Q29udGV4dCA9IHVzZVRMRHJhd0NvbnRleHQoKSxcbiAgICAgIHRsc3RhdGUgPSBfdXNlVExEcmF3Q29udGV4dC50bHN0YXRlO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFRlcnRpYXJ5QnV0dG9uc0NvbnRhaW5lciwge1xuICAgIGJwOiB7XG4gICAgICAnQGluaXRpYWwnOiAnbW9iaWxlJyxcbiAgICAgICdAc20nOiAnc21hbGwnXG4gICAgfVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFRlcnRpYXJ5QnV0dG9uLCB7XG4gICAgbGFiZWw6IFwiWm9vbSBPdXRcIixcbiAgICBrYmQ6IFwiI1xcdTIyMTJcIixcbiAgICBvbkNsaWNrOiB0bHN0YXRlLnpvb21PdXRcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChyZWFjdEljb25zLlpvb21PdXRJY29uLCBudWxsKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGVydGlhcnlCdXR0b24sIHtcbiAgICBsYWJlbDogXCJab29tIEluXCIsXG4gICAga2JkOiBcIiMrXCIsXG4gICAgb25DbGljazogdGxzdGF0ZS56b29tSW5cbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChyZWFjdEljb25zLlpvb21Jbkljb24sIG51bGwpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChab29tQ291bnRlciwgbnVsbCkpO1xufSk7XG5cbnZhciB6b29tU2VsZWN0b3IgPSBmdW5jdGlvbiB6b29tU2VsZWN0b3Iocykge1xuICByZXR1cm4gcy5wYWdlU3RhdGUuY2FtZXJhLnpvb207XG59O1xuXG5mdW5jdGlvbiBab29tQ291bnRlcigpIHtcbiAgdmFyIF91c2VUTERyYXdDb250ZXh0MiA9IHVzZVRMRHJhd0NvbnRleHQoKSxcbiAgICAgIHRsc3RhdGUgPSBfdXNlVExEcmF3Q29udGV4dDIudGxzdGF0ZSxcbiAgICAgIHVzZUFwcFN0YXRlID0gX3VzZVRMRHJhd0NvbnRleHQyLnVzZUFwcFN0YXRlO1xuXG4gIHZhciB6b29tID0gdXNlQXBwU3RhdGUoem9vbVNlbGVjdG9yKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGVydGlhcnlCdXR0b24sIHtcbiAgICBsYWJlbDogXCJSZXNldCBab29tXCIsXG4gICAga2JkOiBcIlxcdTIxRTcwXCIsXG4gICAgb25DbGljazogdGxzdGF0ZS56b29tVG9BY3R1YWwsXG4gICAgb25Eb3VibGVDbGljazogdGxzdGF0ZS56b29tVG9GaXRcbiAgfSwgTWF0aC5yb3VuZCh6b29tICogMTAwKSwgXCIlXCIpO1xufVxuXG52YXIgaXNFbXB0eUNhbnZhc1NlbGVjdG9yID0gZnVuY3Rpb24gaXNFbXB0eUNhbnZhc1NlbGVjdG9yKHMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHMucGFnZS5zaGFwZXMpLmxlbmd0aCA+IDAgJiYgcy5hcHBTdGF0ZS5pc0VtcHR5Q2FudmFzO1xufTtcblxudmFyIEJhY2tUb0NvbnRlbnQgPSAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyhmdW5jdGlvbiAoKSB7XG4gIHZhciBfdXNlVExEcmF3Q29udGV4dCA9IHVzZVRMRHJhd0NvbnRleHQoKSxcbiAgICAgIHRsc3RhdGUgPSBfdXNlVExEcmF3Q29udGV4dC50bHN0YXRlLFxuICAgICAgdXNlQXBwU3RhdGUgPSBfdXNlVExEcmF3Q29udGV4dC51c2VBcHBTdGF0ZTtcblxuICB2YXIgaXNFbXB0eUNhbnZhcyA9IHVzZUFwcFN0YXRlKGlzRW1wdHlDYW52YXNTZWxlY3Rvcik7XG4gIGlmICghaXNFbXB0eUNhbnZhcykgcmV0dXJuIG51bGw7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEJhY2tUb0NvbnRlbnRCdXR0b24sIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm93QnV0dG9uLCB7XG4gICAgb25DbGljazogdGxzdGF0ZS56b29tVG9Db250ZW50XG4gIH0sIFwiQmFjayB0byBjb250ZW50XCIpKTtcbn0pO1xudmFyIEJhY2tUb0NvbnRlbnRCdXR0b24gPSAvKiNfX1BVUkVfXyovc3R5bGVkKEZsb2F0aW5nQ29udGFpbmVyLCB7XG4gIHBvaW50ZXJFdmVudHM6ICdhbGwnLFxuICB3aWR0aDogJ2ZpdC1jb250ZW50JyxcbiAgZ3JpZFJvdzogMSxcbiAgZmxleEdyb3c6IDIsXG4gIGRpc3BsYXk6ICdibG9jaydcbn0pO1xuXG52YXIgYWN0aXZlVG9vbFNlbGVjdG9yJDEgPSBmdW5jdGlvbiBhY3RpdmVUb29sU2VsZWN0b3Iocykge1xuICByZXR1cm4gcy5hcHBTdGF0ZS5hY3RpdmVUb29sO1xufTtcblxudmFyIGlzVG9vbExvY2tlZFNlbGVjdG9yID0gZnVuY3Rpb24gaXNUb29sTG9ja2VkU2VsZWN0b3Iocykge1xuICByZXR1cm4gcy5hcHBTdGF0ZS5pc1Rvb2xMb2NrZWQ7XG59O1xuXG52YXIgaXNEZWJ1Z01vZGVTZWxlY3RvciQxID0gZnVuY3Rpb24gaXNEZWJ1Z01vZGVTZWxlY3RvcihzKSB7XG4gIHJldHVybiBzLnNldHRpbmdzLmlzRGVidWdNb2RlO1xufTtcblxudmFyIFRvb2xzUGFuZWwgPSAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyhmdW5jdGlvbiAoKSB7XG4gIHZhciBfdXNlVExEcmF3Q29udGV4dCA9IHVzZVRMRHJhd0NvbnRleHQoKSxcbiAgICAgIHRsc3RhdGUgPSBfdXNlVExEcmF3Q29udGV4dC50bHN0YXRlLFxuICAgICAgdXNlQXBwU3RhdGUgPSBfdXNlVExEcmF3Q29udGV4dC51c2VBcHBTdGF0ZTtcblxuICB2YXIgYWN0aXZlVG9vbCA9IHVzZUFwcFN0YXRlKGFjdGl2ZVRvb2xTZWxlY3RvciQxKTtcbiAgdmFyIGlzVG9vbExvY2tlZCA9IHVzZUFwcFN0YXRlKGlzVG9vbExvY2tlZFNlbGVjdG9yKTtcbiAgdmFyIGlzRGVidWdNb2RlID0gdXNlQXBwU3RhdGUoaXNEZWJ1Z01vZGVTZWxlY3RvciQxKTtcbiAgdmFyIHNlbGVjdFNlbGVjdFRvb2wgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5zZWxlY3RUb29sKCdzZWxlY3QnKTtcbiAgfSwgW3Rsc3RhdGVdKTtcbiAgdmFyIHNlbGVjdERyYXdUb29sID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHRsc3RhdGUuc2VsZWN0VG9vbChleHBvcnRzLlRMRHJhd1NoYXBlVHlwZS5EcmF3KTtcbiAgfSwgW3Rsc3RhdGVdKTtcbiAgdmFyIHNlbGVjdFJlY3RhbmdsZVRvb2wgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5zZWxlY3RUb29sKGV4cG9ydHMuVExEcmF3U2hhcGVUeXBlLlJlY3RhbmdsZSk7XG4gIH0sIFt0bHN0YXRlXSk7XG4gIHZhciBzZWxlY3RFbGxpcHNlVG9vbCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB0bHN0YXRlLnNlbGVjdFRvb2woZXhwb3J0cy5UTERyYXdTaGFwZVR5cGUuRWxsaXBzZSk7XG4gIH0sIFt0bHN0YXRlXSk7XG4gIHZhciBzZWxlY3RBcnJvd1Rvb2wgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5zZWxlY3RUb29sKGV4cG9ydHMuVExEcmF3U2hhcGVUeXBlLkFycm93KTtcbiAgfSwgW3Rsc3RhdGVdKTsgLy8gY29uc3Qgc2VsZWN0VGV4dFRvb2wgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gIC8vICAgdGxzdGF0ZS5zZWxlY3RUb29sKFRMRHJhd1NoYXBlVHlwZS5FbGxpcHNlKVxuICAvLyB9LCBbdGxzdGF0ZV0pXG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVG9vbHNQYW5lbENvbnRhaW5lciwgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChMZWZ0V3JhcCwge1xuICAgIHNpemU6IHtcbiAgICAgICdAaW5pdGlhbCc6ICdtb2JpbGUnLFxuICAgICAgJ0BzbSc6ICdzbWFsbCdcbiAgICB9XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoWm9vbSwgbnVsbCksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRmxvYXRpbmdDb250YWluZXIsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2Vjb25kYXJ5QnV0dG9uLCB7XG4gICAgbGFiZWw6ICdTZWxlY3QnLFxuICAgIGtiZDogJzEnLFxuICAgIG9uQ2xpY2s6IHNlbGVjdFNlbGVjdFRvb2wsXG4gICAgaXNBY3RpdmU6IGFjdGl2ZVRvb2wgPT09ICdzZWxlY3QnXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3RJY29ucy5DdXJzb3JBcnJvd0ljb24sIG51bGwpKSkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KENlbnRlcldyYXAsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQmFja1RvQ29udGVudCwgbnVsbCksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRmxvYXRpbmdDb250YWluZXIsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUHJpbWFyeUJ1dHRvbiwge1xuICAgIGtiZDogJzInLFxuICAgIGxhYmVsOiBleHBvcnRzLlRMRHJhd1NoYXBlVHlwZS5EcmF3LFxuICAgIG9uQ2xpY2s6IHNlbGVjdERyYXdUb29sLFxuICAgIGlzQWN0aXZlOiBhY3RpdmVUb29sID09PSBleHBvcnRzLlRMRHJhd1NoYXBlVHlwZS5EcmF3XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3RJY29ucy5QZW5jaWwxSWNvbiwgbnVsbCkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFByaW1hcnlCdXR0b24sIHtcbiAgICBrYmQ6ICczJyxcbiAgICBsYWJlbDogZXhwb3J0cy5UTERyYXdTaGFwZVR5cGUuUmVjdGFuZ2xlLFxuICAgIG9uQ2xpY2s6IHNlbGVjdFJlY3RhbmdsZVRvb2wsXG4gICAgaXNBY3RpdmU6IGFjdGl2ZVRvb2wgPT09IGV4cG9ydHMuVExEcmF3U2hhcGVUeXBlLlJlY3RhbmdsZVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0SWNvbnMuU3F1YXJlSWNvbiwgbnVsbCkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFByaW1hcnlCdXR0b24sIHtcbiAgICBrYmQ6ICc0JyxcbiAgICBsYWJlbDogZXhwb3J0cy5UTERyYXdTaGFwZVR5cGUuRHJhdyxcbiAgICBvbkNsaWNrOiBzZWxlY3RFbGxpcHNlVG9vbCxcbiAgICBpc0FjdGl2ZTogYWN0aXZlVG9vbCA9PT0gZXhwb3J0cy5UTERyYXdTaGFwZVR5cGUuRWxsaXBzZVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0SWNvbnMuQ2lyY2xlSWNvbiwgbnVsbCkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFByaW1hcnlCdXR0b24sIHtcbiAgICBrYmQ6ICc1JyxcbiAgICBsYWJlbDogZXhwb3J0cy5UTERyYXdTaGFwZVR5cGUuQXJyb3csXG4gICAgb25DbGljazogc2VsZWN0QXJyb3dUb29sLFxuICAgIGlzQWN0aXZlOiBhY3RpdmVUb29sID09PSBleHBvcnRzLlRMRHJhd1NoYXBlVHlwZS5BcnJvd1xuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0SWNvbnMuQXJyb3dUb3BSaWdodEljb24sIG51bGwpKSkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFJpZ2h0V3JhcCwge1xuICAgIHNpemU6IHtcbiAgICAgICdAaW5pdGlhbCc6ICdtb2JpbGUnLFxuICAgICAgJ0BzbSc6ICdzbWFsbCdcbiAgICB9XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRmxvYXRpbmdDb250YWluZXIsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2Vjb25kYXJ5QnV0dG9uLCB7XG4gICAga2JkOiAnNycsXG4gICAgbGFiZWw6ICdMb2NrIFRvb2wnLFxuICAgIG9uQ2xpY2s6IHRsc3RhdGUudG9nZ2xlVG9vbExvY2ssXG4gICAgaXNBY3RpdmU6IGlzVG9vbExvY2tlZFxuICB9LCBpc1Rvb2xMb2NrZWQgPyBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0SWNvbnMuTG9ja0Nsb3NlZEljb24sIG51bGwpIDogUmVhY3QuY3JlYXRlRWxlbWVudChyZWFjdEljb25zLkxvY2tPcGVuMUljb24sIG51bGwpKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVW5kb1JlZG8sIG51bGwpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChTdGF0dXNXcmFwLCBudWxsLCBpc0RlYnVnTW9kZSAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KFN0YXR1c0JhciwgbnVsbCkpKTtcbn0pO1xudmFyIFRvb2xzUGFuZWxDb250YWluZXIgPSAvKiNfX1BVUkVfXyovc3R5bGVkKCdkaXYnLCB7XG4gIHBvc2l0aW9uOiAnZml4ZWQnLFxuICBib3R0b206IDAsXG4gIGxlZnQ6IDAsXG4gIHJpZ2h0OiAwLFxuICB3aWR0aDogJzEwMCUnLFxuICBtaW5XaWR0aDogMCxcbiAgbWF4V2lkdGg6ICcxMDAlJyxcbiAgZGlzcGxheTogJ2dyaWQnLFxuICBncmlkVGVtcGxhdGVDb2x1bW5zOiAnMWZyIGF1dG8gMWZyJyxcbiAgcGFkZGluZzogJzAnLFxuICBhbGlnbkl0ZW1zOiAnZmxleC1lbmQnLFxuICB6SW5kZXg6IDIwMCxcbiAgZ3JpZEdhcDogJyQ0JyxcbiAgZ3JpZFJvd0dhcDogJyQ0JyxcbiAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAnJiA+IGRpdiA+IConOiB7XG4gICAgcG9pbnRlckV2ZW50czogJ2FsbCdcbiAgfVxufSk7XG52YXIgQ2VudGVyV3JhcCA9IC8qI19fUFVSRV9fKi9zdHlsZWQoJ2RpdicsIHtcbiAgZ3JpZFJvdzogMSxcbiAgZ3JpZENvbHVtbjogMixcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICB3aWR0aDogJ2ZpdC1jb250ZW50JyxcbiAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcbiAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gIGdhcDogMTJcbn0pO1xudmFyIExlZnRXcmFwID0gLyojX19QVVJFX18qL3N0eWxlZCgnZGl2Jywge1xuICBncmlkUm93OiAxLFxuICBncmlkQ29sdW1uOiAxLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHBhZGRpbmdMZWZ0OiAnJDMnLFxuICB2YXJpYW50czoge1xuICAgIHNpemU6IHtcbiAgICAgIG1vYmlsZToge1xuICAgICAgICBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdmbGV4LWVuZCcsXG4gICAgICAgIGFsaWduSXRlbXM6ICdmbGV4LXN0YXJ0JyxcbiAgICAgICAgJyYgPiAqOm50aC1vZi10eXBlKDEpJzoge1xuICAgICAgICAgIG1hcmdpbkJvdHRvbTogJzhweCdcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNtYWxsOiB7XG4gICAgICAgIGZsZXhEaXJlY3Rpb246ICdyb3cnLFxuICAgICAgICBhbGlnbkl0ZW1zOiAnZmxleC1lbmQnLFxuICAgICAgICBqdXN0aWZ5Q29udGVudDogJ3NwYWNlLWJldHdlZW4nLFxuICAgICAgICAnJiA+ICo6bnRoLW9mLXR5cGUoMSknOiB7XG4gICAgICAgICAgbWFyZ2luQm90dG9tOiAnMHB4J1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbnZhciBSaWdodFdyYXAgPSAvKiNfX1BVUkVfXyovc3R5bGVkKCdkaXYnLCB7XG4gIGdyaWRSb3c6IDEsXG4gIGdyaWRDb2x1bW46IDMsXG4gIGRpc3BsYXk6ICdmbGV4JyxcbiAgcGFkZGluZ1JpZ2h0OiAnJDMnLFxuICB2YXJpYW50czoge1xuICAgIHNpemU6IHtcbiAgICAgIG1vYmlsZToge1xuICAgICAgICBmbGV4RGlyZWN0aW9uOiAnY29sdW1uLXJldmVyc2UnLFxuICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2ZsZXgtZW5kJyxcbiAgICAgICAgYWxpZ25JdGVtczogJ2ZsZXgtZW5kJyxcbiAgICAgICAgJyYgPiAqOm50aC1vZi10eXBlKDIpJzoge1xuICAgICAgICAgIG1hcmdpbkJvdHRvbTogJzhweCdcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNtYWxsOiB7XG4gICAgICAgIGZsZXhEaXJlY3Rpb246ICdyb3cnLFxuICAgICAgICBhbGlnbkl0ZW1zOiAnZmxleC1lbmQnLFxuICAgICAgICBqdXN0aWZ5Q29udGVudDogJ3NwYWNlLWJldHdlZW4nLFxuICAgICAgICAnJiA+ICo6bnRoLW9mLXR5cGUoMiknOiB7XG4gICAgICAgICAgbWFyZ2luQm90dG9tOiAnMHB4J1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbnZhciBTdGF0dXNXcmFwID0gLyojX19QVVJFX18qL3N0eWxlZCgnZGl2Jywge1xuICBncmlkUm93OiAyLFxuICBncmlkQ29sdW1uOiAnMSAvIHNwYW4gMydcbn0pO1xuXG52YXIgVExEUiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRMRFIoKSB7fVxuXG4gIFRMRFIuZ2V0U2hhcGVVdGlscyA9IGZ1bmN0aW9uIGdldFNoYXBlVXRpbHMkMShzaGFwZSkge1xuICAgIHJldHVybiBnZXRTaGFwZVV0aWxzKHNoYXBlKTtcbiAgfTtcblxuICBUTERSLmdldFNlbGVjdGVkU2hhcGVzID0gZnVuY3Rpb24gZ2V0U2VsZWN0ZWRTaGFwZXMoZGF0YSkge1xuICAgIHJldHVybiBkYXRhLnBhZ2VTdGF0ZS5zZWxlY3RlZElkcy5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgICByZXR1cm4gZGF0YS5wYWdlLnNoYXBlc1tpZF07XG4gICAgfSk7XG4gIH07XG5cbiAgVExEUi5zY3JlZW5Ub1dvcmxkID0gZnVuY3Rpb24gc2NyZWVuVG9Xb3JsZChkYXRhLCBwb2ludCkge1xuICAgIHZhciBjYW1lcmEgPSBkYXRhLnBhZ2VTdGF0ZS5jYW1lcmE7XG4gICAgcmV0dXJuIGNvcmUuVmVjLnN1Yihjb3JlLlZlYy5kaXYocG9pbnQsIGNhbWVyYS56b29tKSwgY2FtZXJhLnBvaW50KTtcbiAgfTtcblxuICBUTERSLmdldFZpZXdwb3J0ID0gZnVuY3Rpb24gZ2V0Vmlld3BvcnQoZGF0YSkge1xuICAgIHZhciBfdGhpcyRzY3JlZW5Ub1dvcmxkID0gdGhpcy5zY3JlZW5Ub1dvcmxkKGRhdGEsIFswLCAwXSksXG4gICAgICAgIG1pblggPSBfdGhpcyRzY3JlZW5Ub1dvcmxkWzBdLFxuICAgICAgICBtaW5ZID0gX3RoaXMkc2NyZWVuVG9Xb3JsZFsxXTtcblxuICAgIHZhciBfdGhpcyRzY3JlZW5Ub1dvcmxkMiA9IHRoaXMuc2NyZWVuVG9Xb3JsZChkYXRhLCBbd2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodF0pLFxuICAgICAgICBtYXhYID0gX3RoaXMkc2NyZWVuVG9Xb3JsZDJbMF0sXG4gICAgICAgIG1heFkgPSBfdGhpcyRzY3JlZW5Ub1dvcmxkMlsxXTtcblxuICAgIHJldHVybiB7XG4gICAgICBtaW5YOiBtaW5YLFxuICAgICAgbWluWTogbWluWSxcbiAgICAgIG1heFg6IG1heFgsXG4gICAgICBtYXhZOiBtYXhZLFxuICAgICAgaGVpZ2h0OiBtYXhYIC0gbWluWCxcbiAgICAgIHdpZHRoOiBtYXhZIC0gbWluWVxuICAgIH07XG4gIH07XG5cbiAgVExEUi5nZXRDYW1lcmFab29tID0gZnVuY3Rpb24gZ2V0Q2FtZXJhWm9vbSh6b29tKSB7XG4gICAgcmV0dXJuIGNvcmUuVXRpbHMuY2xhbXAoem9vbSwgMC4xLCA1KTtcbiAgfTtcblxuICBUTERSLmdldEN1cnJlbnRDYW1lcmEgPSBmdW5jdGlvbiBnZXRDdXJyZW50Q2FtZXJhKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5wYWdlU3RhdGUuY2FtZXJhO1xuICB9O1xuXG4gIFRMRFIuZ2V0UGFnZSA9IGZ1bmN0aW9uIGdldFBhZ2UoZGF0YSkge1xuICAgIHJldHVybiBkYXRhLnBhZ2U7XG4gIH07XG5cbiAgVExEUi5nZXRQYWdlU3RhdGUgPSBmdW5jdGlvbiBnZXRQYWdlU3RhdGUoZGF0YSkge1xuICAgIHJldHVybiBkYXRhLnBhZ2VTdGF0ZTtcbiAgfTtcblxuICBUTERSLmdldFNlbGVjdGVkSWRzID0gZnVuY3Rpb24gZ2V0U2VsZWN0ZWRJZHMoZGF0YSkge1xuICAgIHJldHVybiBkYXRhLnBhZ2VTdGF0ZS5zZWxlY3RlZElkcztcbiAgfTtcblxuICBUTERSLmdldFNoYXBlcyA9IGZ1bmN0aW9uIGdldFNoYXBlcyhkYXRhKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoZGF0YS5wYWdlLnNoYXBlcyk7XG4gIH07XG5cbiAgVExEUi5nZXRDYW1lcmEgPSBmdW5jdGlvbiBnZXRDYW1lcmEoZGF0YSkge1xuICAgIHJldHVybiBkYXRhLnBhZ2VTdGF0ZS5jYW1lcmE7XG4gIH07XG5cbiAgVExEUi5nZXRTaGFwZSA9IGZ1bmN0aW9uIGdldFNoYXBlKGRhdGEsIHNoYXBlSWQpIHtcbiAgICByZXR1cm4gZGF0YS5wYWdlLnNoYXBlc1tzaGFwZUlkXTtcbiAgfTtcblxuICBUTERSLmdldEJvdW5kcyA9IGZ1bmN0aW9uIGdldEJvdW5kcyhzaGFwZSkge1xuICAgIHJldHVybiBnZXRTaGFwZVV0aWxzKHNoYXBlKS5nZXRCb3VuZHMoc2hhcGUpO1xuICB9O1xuXG4gIFRMRFIuZ2V0Um90YXRlZEJvdW5kcyA9IGZ1bmN0aW9uIGdldFJvdGF0ZWRCb3VuZHMoc2hhcGUpIHtcbiAgICByZXR1cm4gZ2V0U2hhcGVVdGlscyhzaGFwZSkuZ2V0Um90YXRlZEJvdW5kcyhzaGFwZSk7XG4gIH07XG5cbiAgVExEUi5nZXRTZWxlY3RlZEJvdW5kcyA9IGZ1bmN0aW9uIGdldFNlbGVjdGVkQm91bmRzKGRhdGEpIHtcbiAgICByZXR1cm4gY29yZS5VdGlscy5nZXRDb21tb25Cb3VuZHModGhpcy5nZXRTZWxlY3RlZFNoYXBlcyhkYXRhKS5tYXAoZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICByZXR1cm4gZ2V0U2hhcGVVdGlscyhzaGFwZSkuZ2V0Qm91bmRzKHNoYXBlKTtcbiAgICB9KSk7XG4gIH07XG5cbiAgVExEUi5nZXRQYXJlbnRJZCA9IGZ1bmN0aW9uIGdldFBhcmVudElkKGRhdGEsIGlkKSB7XG4gICAgdmFyIHNoYXBlID0gZGF0YS5wYWdlLnNoYXBlc1tpZF07XG4gICAgcmV0dXJuIHNoYXBlLnBhcmVudElkO1xuICB9O1xuXG4gIFRMRFIuZ2V0UG9pbnRlZElkID0gZnVuY3Rpb24gZ2V0UG9pbnRlZElkKGRhdGEsIGlkKSB7XG4gICAgdmFyIHNoYXBlID0gZGF0YS5wYWdlLnNoYXBlc1tpZF07XG4gICAgaWYgKCFzaGFwZSkgcmV0dXJuIGlkO1xuICAgIHJldHVybiBzaGFwZS5wYXJlbnRJZCA9PT0gZGF0YS5wYWdlU3RhdGUuY3VycmVudFBhcmVudElkIHx8IHNoYXBlLnBhcmVudElkID09PSBkYXRhLnBhZ2UuaWQgPyBpZCA6IHRoaXMuZ2V0UG9pbnRlZElkKGRhdGEsIHNoYXBlLnBhcmVudElkKTtcbiAgfTtcblxuICBUTERSLmdldERyaWxsZWRQb2ludGVkSWQgPSBmdW5jdGlvbiBnZXREcmlsbGVkUG9pbnRlZElkKGRhdGEsIGlkKSB7XG4gICAgdmFyIHNoYXBlID0gZGF0YS5wYWdlLnNoYXBlc1tpZF07XG4gICAgdmFyIF9kYXRhJHBhZ2VTdGF0ZSA9IGRhdGEucGFnZVN0YXRlLFxuICAgICAgICBjdXJyZW50UGFyZW50SWQgPSBfZGF0YSRwYWdlU3RhdGUuY3VycmVudFBhcmVudElkLFxuICAgICAgICBwb2ludGVkSWQgPSBfZGF0YSRwYWdlU3RhdGUucG9pbnRlZElkO1xuICAgIHJldHVybiBzaGFwZS5wYXJlbnRJZCA9PT0gZGF0YS5wYWdlLmlkIHx8IHNoYXBlLnBhcmVudElkID09PSBwb2ludGVkSWQgfHwgc2hhcGUucGFyZW50SWQgPT09IGN1cnJlbnRQYXJlbnRJZCA/IGlkIDogdGhpcy5nZXREcmlsbGVkUG9pbnRlZElkKGRhdGEsIHNoYXBlLnBhcmVudElkKTtcbiAgfTtcblxuICBUTERSLmdldFRvcFBhcmVudElkID0gZnVuY3Rpb24gZ2V0VG9wUGFyZW50SWQoZGF0YSwgaWQpIHtcbiAgICB2YXIgc2hhcGUgPSBkYXRhLnBhZ2Uuc2hhcGVzW2lkXTtcblxuICAgIGlmIChzaGFwZS5wYXJlbnRJZCA9PT0gc2hhcGUuaWQpIHtcbiAgICAgIHRocm93IEVycm9yKFwiU2hhcGUgaGFzIHRoZSBzYW1lIGlkIGFzIGl0cyBwYXJlbnQhIFwiICsgc2hhcGUuaWQpO1xuICAgIH1cblxuICAgIHJldHVybiBzaGFwZS5wYXJlbnRJZCA9PT0gZGF0YS5wYWdlLmlkIHx8IHNoYXBlLnBhcmVudElkID09PSBkYXRhLnBhZ2VTdGF0ZS5jdXJyZW50UGFyZW50SWQgPyBpZCA6IHRoaXMuZ2V0VG9wUGFyZW50SWQoZGF0YSwgc2hhcGUucGFyZW50SWQpO1xuICB9IC8vIEdldCBhbiBhcnJheSBvZiBhIHNoYXBlIGlkIGFuZCBpdHMgZGVzY2VuZGFudCBzaGFwZXMnIGlkc1xuICA7XG5cbiAgVExEUi5nZXREb2N1bWVudEJyYW5jaCA9IGZ1bmN0aW9uIGdldERvY3VtZW50QnJhbmNoKGRhdGEsIGlkKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBzaGFwZSA9IGRhdGEucGFnZS5zaGFwZXNbaWRdO1xuICAgIGlmIChzaGFwZS5jaGlsZHJlbiA9PT0gdW5kZWZpbmVkKSByZXR1cm4gW2lkXTtcbiAgICByZXR1cm4gW2lkXS5jb25jYXQoc2hhcGUuY2hpbGRyZW4uZmxhdE1hcChmdW5jdGlvbiAoY2hpbGRJZCkge1xuICAgICAgcmV0dXJuIF90aGlzLmdldERvY3VtZW50QnJhbmNoKGRhdGEsIGNoaWxkSWQpO1xuICAgIH0pKTtcbiAgfTtcblxuICBUTERSLmdldFNlbGVjdGVkQnJhbmNoU25hcHNob3QgPSBmdW5jdGlvbiBnZXRTZWxlY3RlZEJyYW5jaFNuYXBzaG90KGRhdGEsIGZuKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgcGFnZSA9IHRoaXMuZ2V0UGFnZShkYXRhKTtcbiAgICB2YXIgY29waWVzID0gdGhpcy5nZXRTZWxlY3RlZElkcyhkYXRhKS5mbGF0TWFwKGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuIF90aGlzMi5nZXREb2N1bWVudEJyYW5jaChkYXRhLCBpZCkubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gcGFnZS5zaGFwZXNbaWRdO1xuICAgICAgfSk7XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgcmV0dXJuICFzaGFwZS5pc0xvY2tlZDtcbiAgICB9KS5tYXAoY29yZS5VdGlscy5kZWVwQ2xvbmUpO1xuXG4gICAgaWYgKGZuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBjb3BpZXMubWFwKGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICAgIGlkOiBzaGFwZS5pZFxuICAgICAgICB9LCBmbihzaGFwZSkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvcGllcztcbiAgfTtcblxuICBUTERSLmdldFNlbGVjdGVkU2hhcGVTbmFwc2hvdCA9IGZ1bmN0aW9uIGdldFNlbGVjdGVkU2hhcGVTbmFwc2hvdChkYXRhLCBmbikge1xuICAgIHZhciBjb3BpZXMgPSB0aGlzLmdldFNlbGVjdGVkU2hhcGVzKGRhdGEpLmZpbHRlcihmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgIHJldHVybiAhc2hhcGUuaXNMb2NrZWQ7XG4gICAgfSkubWFwKGNvcmUuVXRpbHMuZGVlcENsb25lKTtcblxuICAgIGlmIChmbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gY29waWVzLm1hcChmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgICBpZDogc2hhcGUuaWRcbiAgICAgICAgfSwgZm4oc2hhcGUpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBjb3BpZXM7XG4gIH0gLy8gRm9yIGEgZ2l2ZW4gYXJyYXkgb2Ygc2hhcGUgaWRzLCBhbiBhcnJheSBvZiBhbGwgb3RoZXIgc2hhcGVzIHRoYXQgbWF5IGJlIGFmZmVjdGVkIGJ5IGEgbXV0YXRpb24gdG8gaXQuXG4gIC8vIFVzZSB0aGlzIHRvIGRlY2lkZSB3aGljaCBzaGFwZXMgdG8gY2xvbmUgYXMgYmVmb3JlIC8gYWZ0ZXIgZm9yIGEgY29tbWFuZC5cbiAgO1xuXG4gIFRMRFIuZ2V0QWxsRWZmZWN0ZWRTaGFwZUlkcyA9IGZ1bmN0aW9uIGdldEFsbEVmZmVjdGVkU2hhcGVJZHMoZGF0YSwgaWRzKSB7XG4gICAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KGlkcyk7XG4gICAgaWRzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICB2YXIgc2hhcGUgPSBkYXRhLnBhZ2Uuc2hhcGVzW2lkXTsgLy8gQWRkIGRlc2NlbmRhbnQgc2hhcGVzXG5cbiAgICAgIGZ1bmN0aW9uIGNvbGxlY3REZXNjZW5kYW50cyhzaGFwZSkge1xuICAgICAgICBpZiAoc2hhcGUuY2hpbGRyZW4gPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgICBzaGFwZS5jaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkSWQpIHtcbiAgICAgICAgICByZXR1cm4gIXZpc2l0ZWQuaGFzKGNoaWxkSWQpO1xuICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZElkKSB7XG4gICAgICAgICAgdmlzaXRlZC5hZGQoY2hpbGRJZCk7XG4gICAgICAgICAgY29sbGVjdERlc2NlbmRhbnRzKGRhdGEucGFnZS5zaGFwZXNbY2hpbGRJZF0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29sbGVjdERlc2NlbmRhbnRzKHNoYXBlKTsgLy8gQWRkIGFzZWNlbmRhbnQgc2hhcGVzXG5cbiAgICAgIGZ1bmN0aW9uIGNvbGxlY3RBc2NlbmRhbnRzKHNoYXBlKSB7XG4gICAgICAgIHZhciBwYXJlbnRJZCA9IHNoYXBlLnBhcmVudElkO1xuICAgICAgICBpZiAocGFyZW50SWQgPT09IGRhdGEucGFnZS5pZCkgcmV0dXJuO1xuICAgICAgICBpZiAodmlzaXRlZC5oYXMocGFyZW50SWQpKSByZXR1cm47XG4gICAgICAgIHZpc2l0ZWQuYWRkKHBhcmVudElkKTtcbiAgICAgICAgY29sbGVjdEFzY2VuZGFudHMoZGF0YS5wYWdlLnNoYXBlc1twYXJlbnRJZF0pO1xuICAgICAgfVxuXG4gICAgICBjb2xsZWN0QXNjZW5kYW50cyhzaGFwZSk7IC8vIEFkZCBiaW5kaW5ncyB0aGF0IGFyZSB0byBvciBmcm9tIGFueSBvZiB0aGUgdmlzaXRlZCBzaGFwZXMgKHRoaXMgZG9lcyBub3QgaGF2ZSB0byBiZSByZWN1cnNpdmUpXG5cbiAgICAgIHZpc2l0ZWQuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhkYXRhLnBhZ2UuYmluZGluZ3MpLmZpbHRlcihmdW5jdGlvbiAoYmluZGluZykge1xuICAgICAgICAgIHJldHVybiBiaW5kaW5nLmZyb21JZCA9PT0gaWQgfHwgYmluZGluZy50b0lkID09PSBpZDtcbiAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoYmluZGluZykge1xuICAgICAgICAgIHJldHVybiB2aXNpdGVkLmFkZChiaW5kaW5nLmZyb21JZCA9PT0gaWQgPyBiaW5kaW5nLnRvSWQgOiBiaW5kaW5nLmZyb21JZCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7IC8vIFJldHVybiB0aGUgdW5pcXVlIGFycmF5IG9mIHZpc2l0ZWQgc2hhcGVzXG5cbiAgICByZXR1cm4gQXJyYXkuZnJvbSh2aXNpdGVkLnZhbHVlcygpKTtcbiAgfTtcblxuICBUTERSLnJlY3Vyc2l2ZWx5VXBkYXRlQ2hpbGRyZW4gPSBmdW5jdGlvbiByZWN1cnNpdmVseVVwZGF0ZUNoaWxkcmVuKGRhdGEsIGlkLCBiZWZvcmVTaGFwZXMsIGFmdGVyU2hhcGVzKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICBpZiAoYmVmb3JlU2hhcGVzID09PSB2b2lkIDApIHtcbiAgICAgIGJlZm9yZVNoYXBlcyA9IHt9O1xuICAgIH1cblxuICAgIGlmIChhZnRlclNoYXBlcyA9PT0gdm9pZCAwKSB7XG4gICAgICBhZnRlclNoYXBlcyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBzaGFwZSA9IGRhdGEucGFnZS5zaGFwZXNbaWRdO1xuXG4gICAgaWYgKHNoYXBlLmNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBkZWx0YXMgPSB0aGlzLmdldFNoYXBlVXRpbHMoc2hhcGUpLnVwZGF0ZUNoaWxkcmVuKHNoYXBlLCBzaGFwZS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkSWQpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEucGFnZS5zaGFwZXNbY2hpbGRJZF07XG4gICAgICB9KSk7XG5cbiAgICAgIGlmIChkZWx0YXMpIHtcbiAgICAgICAgcmV0dXJuIGRlbHRhcy5yZWR1Y2UoZnVuY3Rpb24gKGNEYXRhLCBkZWx0YSkge1xuICAgICAgICAgIHZhciBkZWx0YVNoYXBlID0gY0RhdGEucGFnZS5zaGFwZXNbZGVsdGEuaWRdO1xuXG4gICAgICAgICAgaWYgKCFiZWZvcmVTaGFwZXNbZGVsdGFTaGFwZS5pZF0pIHtcbiAgICAgICAgICAgIGJlZm9yZVNoYXBlc1tkZWx0YVNoYXBlLmlkXSA9IGRlbHRhU2hhcGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY0RhdGEucGFnZS5zaGFwZXNbZGVsdGFTaGFwZS5pZF0gPSBfdGhpczMuZ2V0U2hhcGVVdGlscyhkZWx0YVNoYXBlKS5tdXRhdGUoZGVsdGFTaGFwZSwgZGVsdGEpO1xuICAgICAgICAgIGFmdGVyU2hhcGVzW2RlbHRhU2hhcGUuaWRdID0gY0RhdGEucGFnZS5zaGFwZXNbZGVsdGFTaGFwZS5pZF07XG5cbiAgICAgICAgICBpZiAoZGVsdGFTaGFwZS5jaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBfdGhpczMucmVjdXJzaXZlbHlVcGRhdGVDaGlsZHJlbihjRGF0YSwgZGVsdGFTaGFwZS5pZCwgYmVmb3JlU2hhcGVzLCBhZnRlclNoYXBlcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNEYXRhO1xuICAgICAgICB9LCBkYXRhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcblxuICBUTERSLnJlY3Vyc2l2ZWx5VXBkYXRlUGFyZW50cyA9IGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VXBkYXRlUGFyZW50cyhkYXRhLCBpZCwgYmVmb3JlU2hhcGVzLCBhZnRlclNoYXBlcykge1xuICAgIGlmIChiZWZvcmVTaGFwZXMgPT09IHZvaWQgMCkge1xuICAgICAgYmVmb3JlU2hhcGVzID0ge307XG4gICAgfVxuXG4gICAgaWYgKGFmdGVyU2hhcGVzID09PSB2b2lkIDApIHtcbiAgICAgIGFmdGVyU2hhcGVzID0ge307XG4gICAgfVxuXG4gICAgdmFyIHNoYXBlID0gZGF0YS5wYWdlLnNoYXBlc1tpZF07XG5cbiAgICBpZiAoc2hhcGUucGFyZW50SWQgIT09IGRhdGEucGFnZS5pZCkge1xuICAgICAgdmFyIHBhcmVudCA9IGRhdGEucGFnZS5zaGFwZXNbc2hhcGUucGFyZW50SWRdO1xuICAgICAgdmFyIGRlbHRhID0gdGhpcy5nZXRTaGFwZVV0aWxzKHNoYXBlKS5vbkNoaWxkcmVuQ2hhbmdlKHBhcmVudCwgcGFyZW50LmNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGRJZCkge1xuICAgICAgICByZXR1cm4gZGF0YS5wYWdlLnNoYXBlc1tjaGlsZElkXTtcbiAgICAgIH0pKTtcblxuICAgICAgaWYgKGRlbHRhKSB7XG4gICAgICAgIGlmICghYmVmb3JlU2hhcGVzW3BhcmVudC5pZF0pIHtcbiAgICAgICAgICBiZWZvcmVTaGFwZXNbcGFyZW50LmlkXSA9IHBhcmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEucGFnZS5zaGFwZXNbcGFyZW50LmlkXSA9IHRoaXMuZ2V0U2hhcGVVdGlscyhwYXJlbnQpLm11dGF0ZShwYXJlbnQsIGRlbHRhKTtcbiAgICAgICAgYWZ0ZXJTaGFwZXNbcGFyZW50LmlkXSA9IGRhdGEucGFnZS5zaGFwZXNbcGFyZW50LmlkXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmVudC5wYXJlbnRJZCAhPT0gZGF0YS5wYWdlLmlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY3Vyc2l2ZWx5VXBkYXRlUGFyZW50cyhkYXRhLCBwYXJlbnQucGFyZW50SWQsIGJlZm9yZVNoYXBlcywgYWZ0ZXJTaGFwZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9O1xuXG4gIFRMRFIudXBkYXRlQmluZGluZ3MgPSBmdW5jdGlvbiB1cGRhdGVCaW5kaW5ncyhkYXRhLCBpZCwgYmVmb3JlU2hhcGVzLCBhZnRlclNoYXBlcykge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgaWYgKGJlZm9yZVNoYXBlcyA9PT0gdm9pZCAwKSB7XG4gICAgICBiZWZvcmVTaGFwZXMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoYWZ0ZXJTaGFwZXMgPT09IHZvaWQgMCkge1xuICAgICAgYWZ0ZXJTaGFwZXMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhkYXRhLnBhZ2UuYmluZGluZ3MpLmZpbHRlcihmdW5jdGlvbiAoYmluZGluZykge1xuICAgICAgcmV0dXJuIGJpbmRpbmcuZnJvbUlkID09PSBpZCB8fCBiaW5kaW5nLnRvSWQgPT09IGlkO1xuICAgIH0pLnJlZHVjZShmdW5jdGlvbiAoY0RhdGEsIGJpbmRpbmcpIHtcbiAgICAgIGlmICghYmVmb3JlU2hhcGVzW2JpbmRpbmcuaWRdKSB7XG4gICAgICAgIGJlZm9yZVNoYXBlc1tiaW5kaW5nLmZyb21JZF0gPSBjb3JlLlV0aWxzLmRlZXBDbG9uZShjRGF0YS5wYWdlLnNoYXBlc1tiaW5kaW5nLmZyb21JZF0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWJlZm9yZVNoYXBlc1tiaW5kaW5nLnRvSWRdKSB7XG4gICAgICAgIGJlZm9yZVNoYXBlc1tiaW5kaW5nLnRvSWRdID0gY29yZS5VdGlscy5kZWVwQ2xvbmUoY0RhdGEucGFnZS5zaGFwZXNbYmluZGluZy50b0lkXSk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzNC5vbkJpbmRpbmdDaGFuZ2UoY0RhdGEsIGNEYXRhLnBhZ2Uuc2hhcGVzW2JpbmRpbmcuZnJvbUlkXSwgYmluZGluZywgY0RhdGEucGFnZS5zaGFwZXNbYmluZGluZy50b0lkXSk7XG5cbiAgICAgIGFmdGVyU2hhcGVzW2JpbmRpbmcuZnJvbUlkXSA9IGNvcmUuVXRpbHMuZGVlcENsb25lKGNEYXRhLnBhZ2Uuc2hhcGVzW2JpbmRpbmcuZnJvbUlkXSk7XG4gICAgICBhZnRlclNoYXBlc1tiaW5kaW5nLnRvSWRdID0gY29yZS5VdGlscy5kZWVwQ2xvbmUoY0RhdGEucGFnZS5zaGFwZXNbYmluZGluZy50b0lkXSk7XG4gICAgICByZXR1cm4gY0RhdGE7XG4gICAgfSwgZGF0YSk7XG4gIH07XG5cbiAgVExEUi5nZXRDaGlsZEluZGV4QWJvdmUgPSBmdW5jdGlvbiBnZXRDaGlsZEluZGV4QWJvdmUoZGF0YSwgaWQpIHtcbiAgICB2YXIgcGFnZSA9IHRoaXMuZ2V0UGFnZShkYXRhKTtcbiAgICB2YXIgc2hhcGUgPSBwYWdlLnNoYXBlc1tpZF07XG4gICAgdmFyIHNpYmxpbmdzID0gT2JqZWN0LnZhbHVlcyhwYWdlLnNoYXBlcykuZmlsdGVyKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgcGFyZW50SWQgPSBfcmVmLnBhcmVudElkO1xuICAgICAgcmV0dXJuIHBhcmVudElkID09PSBzaGFwZS5wYXJlbnRJZDtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5jaGlsZEluZGV4IC0gYi5jaGlsZEluZGV4O1xuICAgIH0pO1xuICAgIHZhciBpbmRleCA9IHNpYmxpbmdzLmluZGV4T2Yoc2hhcGUpO1xuICAgIHZhciBuZXh0U2libGluZyA9IHNpYmxpbmdzW2luZGV4ICsgMV07XG4gICAgaWYgKCFuZXh0U2libGluZykgcmV0dXJuIHNoYXBlLmNoaWxkSW5kZXggKyAxO1xuICAgIHJldHVybiAoc2hhcGUuY2hpbGRJbmRleCArIG5leHRTaWJsaW5nLmNoaWxkSW5kZXgpIC8gMjtcbiAgfVxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gIC8qICAgICAgICAgICAgICAgICAgICAgIE11dGF0aW9ucyAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgO1xuXG4gIFRMRFIuc2V0U2VsZWN0ZWRJZHMgPSBmdW5jdGlvbiBzZXRTZWxlY3RlZElkcyhkYXRhLCBpZHMpIHtcbiAgICBkYXRhLnBhZ2VTdGF0ZS5zZWxlY3RlZElkcyA9IGlkcztcbiAgfTtcblxuICBUTERSLmRlc2VsZWN0QWxsID0gZnVuY3Rpb24gZGVzZWxlY3RBbGwoZGF0YSkge1xuICAgIHRoaXMuc2V0U2VsZWN0ZWRJZHMoZGF0YSwgW10pO1xuICB9O1xuXG4gIFRMRFIubXV0YXRlU2hhcGVzID0gZnVuY3Rpb24gbXV0YXRlU2hhcGVzKGRhdGEsIGlkcywgZm4pIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgIHZhciBiZWZvcmVTaGFwZXMgPSB7fTtcbiAgICB2YXIgYWZ0ZXJTaGFwZXMgPSB7fTtcbiAgICBpZHMuZm9yRWFjaChmdW5jdGlvbiAoaWQsIGkpIHtcbiAgICAgIHZhciBzaGFwZSA9IGRhdGEucGFnZS5zaGFwZXNbaWRdO1xuICAgICAgdmFyIGNoYW5nZSA9IGZuKHNoYXBlLCBpKTtcbiAgICAgIGJlZm9yZVNoYXBlc1tpZF0gPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmtleXMoY2hhbmdlKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gW2tleSwgc2hhcGVba2V5XV07XG4gICAgICB9KSk7XG4gICAgICBhZnRlclNoYXBlc1tpZF0gPSBjaGFuZ2U7XG4gICAgICBkYXRhLnBhZ2Uuc2hhcGVzW2lkXSA9IF90aGlzNS5nZXRTaGFwZVV0aWxzKHNoYXBlKS5tdXRhdGUoc2hhcGUsIGNoYW5nZSk7XG4gICAgfSk7XG4gICAgdmFyIGRhdGFXaXRoQ2hpbGRyZW5DaGFuZ2VzID0gaWRzLnJlZHVjZShmdW5jdGlvbiAoY0RhdGEsIGlkKSB7XG4gICAgICByZXR1cm4gX3RoaXM1LnJlY3Vyc2l2ZWx5VXBkYXRlQ2hpbGRyZW4oY0RhdGEsIGlkLCBiZWZvcmVTaGFwZXMsIGFmdGVyU2hhcGVzKTtcbiAgICB9LCBkYXRhKTtcbiAgICB2YXIgZGF0YVdpdGhQYXJlbnRDaGFuZ2VzID0gaWRzLnJlZHVjZShmdW5jdGlvbiAoY0RhdGEsIGlkKSB7XG4gICAgICByZXR1cm4gX3RoaXM1LnJlY3Vyc2l2ZWx5VXBkYXRlUGFyZW50cyhjRGF0YSwgaWQsIGJlZm9yZVNoYXBlcywgYWZ0ZXJTaGFwZXMpO1xuICAgIH0sIGRhdGFXaXRoQ2hpbGRyZW5DaGFuZ2VzKTtcbiAgICB2YXIgZGF0YVdpdGhCaW5kaW5nQ2hhbmdlcyA9IGlkcy5yZWR1Y2UoZnVuY3Rpb24gKGNEYXRhLCBpZCkge1xuICAgICAgcmV0dXJuIF90aGlzNS51cGRhdGVCaW5kaW5ncyhjRGF0YSwgaWQsIGJlZm9yZVNoYXBlcywgYWZ0ZXJTaGFwZXMpO1xuICAgIH0sIGRhdGFXaXRoUGFyZW50Q2hhbmdlcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJlZm9yZTogYmVmb3JlU2hhcGVzLFxuICAgICAgYWZ0ZXI6IGFmdGVyU2hhcGVzLFxuICAgICAgZGF0YTogZGF0YVdpdGhCaW5kaW5nQ2hhbmdlc1xuICAgIH07XG4gIH07XG5cbiAgVExEUi5jcmVhdGVTaGFwZXMgPSBmdW5jdGlvbiBjcmVhdGVTaGFwZXMoZGF0YSwgc2hhcGVzKSB7XG4gICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICB2YXIgcGFnZSA9IHRoaXMuZ2V0UGFnZShkYXRhKTtcbiAgICB2YXIgc2hhcGVJZHMgPSBzaGFwZXMubWFwKGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgcmV0dXJuIHNoYXBlLmlkO1xuICAgIH0pOyAvLyBVcGRhdGUgc2VsZWN0ZWQgaWRzXG5cbiAgICB0aGlzLnNldFNlbGVjdGVkSWRzKGRhdGEsIHNoYXBlSWRzKTsgLy8gUmVzdG9yZSBkZWxldGVkIHNoYXBlc1xuXG4gICAgc2hhcGVzLmZvckVhY2goZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICB2YXIgbmV3U2hhcGUgPSBfZXh0ZW5kcyh7fSwgc2hhcGUpO1xuXG4gICAgICBwYWdlLnNoYXBlc1tzaGFwZS5pZF0gPSBuZXdTaGFwZTtcbiAgICB9KTsgLy8gVXBkYXRlIHBhcmVudHNcblxuICAgIHNoYXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgaWYgKHNoYXBlLnBhcmVudElkID09PSBkYXRhLnBhZ2UuaWQpIHJldHVybjtcbiAgICAgIHZhciBwYXJlbnQgPSBwYWdlLnNoYXBlc1tzaGFwZS5wYXJlbnRJZF07XG5cbiAgICAgIF90aGlzNi5tdXRhdGUoZGF0YSwgcGFyZW50LCB7XG4gICAgICAgIGNoaWxkcmVuOiBwYXJlbnQuY2hpbGRyZW4uaW5jbHVkZXMoc2hhcGUuaWQpID8gcGFyZW50LmNoaWxkcmVuIDogW10uY29uY2F0KHBhcmVudC5jaGlsZHJlbiwgW3NoYXBlLmlkXSlcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIFRMRFIub25TZXNzaW9uQ29tcGxldGUgPSBmdW5jdGlvbiBvblNlc3Npb25Db21wbGV0ZShkYXRhLCBzaGFwZSkge1xuICAgIHZhciBkZWx0YSA9IGdldFNoYXBlVXRpbHMoc2hhcGUpLm9uU2Vzc2lvbkNvbXBsZXRlKHNoYXBlKTtcblxuICAgIGlmICghZGVsdGEpIHJldHVybiBzaGFwZTtcbiAgICByZXR1cm4gdGhpcy5tdXRhdGUoZGF0YSwgc2hhcGUsIGRlbHRhKTtcbiAgfTtcblxuICBUTERSLm9uQ2hpbGRyZW5DaGFuZ2UgPSBmdW5jdGlvbiBvbkNoaWxkcmVuQ2hhbmdlKGRhdGEsIHNoYXBlKSB7XG4gICAgdmFyIGRlbHRhID0gZ2V0U2hhcGVVdGlscyhzaGFwZSkub25DaGlsZHJlbkNoYW5nZShzaGFwZSwgc2hhcGUuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuIGRhdGEucGFnZS5zaGFwZXNbaWRdO1xuICAgIH0pKTtcblxuICAgIGlmICghZGVsdGEpIHJldHVybiBzaGFwZTtcbiAgICByZXR1cm4gdGhpcy5tdXRhdGUoZGF0YSwgc2hhcGUsIGRlbHRhKTtcbiAgfTtcblxuICBUTERSLm9uQmluZGluZ0NoYW5nZSA9IGZ1bmN0aW9uIG9uQmluZGluZ0NoYW5nZShkYXRhLCBzaGFwZSwgYmluZGluZywgb3RoZXJTaGFwZSkge1xuICAgIHZhciBkZWx0YSA9IGdldFNoYXBlVXRpbHMoc2hhcGUpLm9uQmluZGluZ0NoYW5nZShzaGFwZSwgYmluZGluZywgb3RoZXJTaGFwZSwgZ2V0U2hhcGVVdGlscyhvdGhlclNoYXBlKS5nZXRCb3VuZHMob3RoZXJTaGFwZSkpO1xuXG4gICAgaWYgKCFkZWx0YSkgcmV0dXJuIHNoYXBlO1xuICAgIHJldHVybiB0aGlzLm11dGF0ZShkYXRhLCBzaGFwZSwgZGVsdGEpO1xuICB9O1xuXG4gIFRMRFIudHJhbnNmb3JtID0gZnVuY3Rpb24gdHJhbnNmb3JtKGRhdGEsIHNoYXBlLCBib3VuZHMsIGluZm8pIHtcbiAgICByZXR1cm4gdGhpcy5tdXRhdGUoZGF0YSwgc2hhcGUsIGdldFNoYXBlVXRpbHMoc2hhcGUpLnRyYW5zZm9ybShzaGFwZSwgYm91bmRzLCBpbmZvKSk7XG4gIH07XG5cbiAgVExEUi50cmFuc2Zvcm1TaW5nbGUgPSBmdW5jdGlvbiB0cmFuc2Zvcm1TaW5nbGUoZGF0YSwgc2hhcGUsIGJvdW5kcywgaW5mbykge1xuICAgIHJldHVybiB0aGlzLm11dGF0ZShkYXRhLCBzaGFwZSwgZ2V0U2hhcGVVdGlscyhzaGFwZSkudHJhbnNmb3JtU2luZ2xlKHNoYXBlLCBib3VuZHMsIGluZm8pKTtcbiAgfTtcblxuICBUTERSLm11dGF0ZSA9IGZ1bmN0aW9uIG11dGF0ZShkYXRhLCBzaGFwZSwgcHJvcHMpIHtcbiAgICB2YXIgbmV4dCA9IGdldFNoYXBlVXRpbHMoc2hhcGUpLm11dGF0ZShzaGFwZSwgcHJvcHMpO1xuXG4gICAgaWYgKCdjaGlsZHJlbicgaW4gcHJvcHMpIHtcbiAgICAgIG5leHQgPSB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoZGF0YSwgbmV4dCk7XG4gICAgfVxuXG4gICAgZGF0YS5wYWdlLnNoYXBlc1tuZXh0LmlkXSA9IG5leHQ7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAvKiAgICAgICAgICAgICAgICAgICAgICAgUGFyZW50cyAgICAgICAgICAgICAgICAgICAgICAqL1xuXG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gIDtcblxuICBUTERSLnVwZGF0ZVBhcmVudHMgPSBmdW5jdGlvbiB1cGRhdGVQYXJlbnRzKGRhdGEsIGNoYW5nZWRTaGFwZUlkcykge1xuICAgIGlmIChjaGFuZ2VkU2hhcGVJZHMubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICB2YXIgX3RoaXMkZ2V0UGFnZSA9IHRoaXMuZ2V0UGFnZShkYXRhKSxcbiAgICAgICAgc2hhcGVzID0gX3RoaXMkZ2V0UGFnZS5zaGFwZXM7XG5cbiAgICB2YXIgcGFyZW50VG9VcGRhdGVJZHMgPSBBcnJheS5mcm9tKG5ldyBTZXQoY2hhbmdlZFNoYXBlSWRzLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHJldHVybiBzaGFwZXNbaWRdLnBhcmVudElkO1xuICAgIH0pLnZhbHVlcygpKSkuZmlsdGVyKGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuIGlkICE9PSBkYXRhLnBhZ2UuaWQ7XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHBhcmVudFRvVXBkYXRlSWRzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspIHtcbiAgICAgIHZhciBwYXJlbnRJZCA9IF9zdGVwLnZhbHVlO1xuICAgICAgdmFyIHBhcmVudCA9IHNoYXBlc1twYXJlbnRJZF07XG5cbiAgICAgIGlmICghcGFyZW50LmNoaWxkcmVuKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdBIHNoYXBlIGlzIHBhcmVudGVkIHRvIGEgc2hhcGUgd2l0aG91dCBhIGNoaWxkcmVuIGFycmF5LicpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoZGF0YSwgcGFyZW50KTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVBhcmVudHMoZGF0YSwgcGFyZW50VG9VcGRhdGVJZHMpO1xuICB9O1xuXG4gIFRMRFIuZ2V0U2VsZWN0ZWRTdHlsZSA9IGZ1bmN0aW9uIGdldFNlbGVjdGVkU3R5bGUoZGF0YSkge1xuICAgIHZhciBwYWdlID0gZGF0YS5wYWdlLFxuICAgICAgICBwYWdlU3RhdGUgPSBkYXRhLnBhZ2VTdGF0ZSxcbiAgICAgICAgY3VycmVudFN0eWxlID0gZGF0YS5hcHBTdGF0ZS5jdXJyZW50U3R5bGU7XG5cbiAgICBpZiAocGFnZVN0YXRlLnNlbGVjdGVkSWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRTdHlsZTtcbiAgICB9XG5cbiAgICB2YXIgc2hhcGVTdHlsZXMgPSBkYXRhLnBhZ2VTdGF0ZS5zZWxlY3RlZElkcy5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgICByZXR1cm4gcGFnZS5zaGFwZXNbaWRdLnN0eWxlO1xuICAgIH0pO1xuICAgIHZhciBjb21tb25TdHlsZSA9IHt9O1xuICAgIHZhciBvdmVycmlkZXMgPSBuZXcgU2V0KFtdKTtcblxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgdmFyIHNoYXBlU3R5bGUgPSBfc3RlcDIudmFsdWU7XG4gICAgICBPYmplY3Qua2V5cyhjdXJyZW50U3R5bGUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAob3ZlcnJpZGVzLmhhcyhrZXkpKSByZXR1cm47XG5cbiAgICAgICAgaWYgKGNvbW1vblN0eWxlW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBjb21tb25TdHlsZVtrZXldID0gc2hhcGVTdHlsZVtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjb21tb25TdHlsZVtrZXldID09PSBzaGFwZVN0eWxlW2tleV0pIHJldHVybjsgLy8gQHRzLWlnbm9yZVxuXG4gICAgICAgICAgY29tbW9uU3R5bGVba2V5XSA9IGN1cnJlbnRTdHlsZVtrZXldO1xuICAgICAgICAgIG92ZXJyaWRlcy5hZGQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHNoYXBlU3R5bGVzKSwgX3N0ZXAyOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIoKSkuZG9uZTspIHtcbiAgICAgIF9sb29wKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbW1vblN0eWxlO1xuICB9XG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgLyogICAgICAgICAgICAgICAgICAgICAgQmluZGluZ3MgICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuICA7XG5cbiAgVExEUi5nZXRCaW5kaW5nID0gZnVuY3Rpb24gZ2V0QmluZGluZyhkYXRhLCBpZCkge1xuICAgIHJldHVybiB0aGlzLmdldFBhZ2UoZGF0YSkuYmluZGluZ3NbaWRdO1xuICB9O1xuXG4gIFRMRFIuZ2V0QmluZGluZ3MgPSBmdW5jdGlvbiBnZXRCaW5kaW5ncyhkYXRhKSB7XG4gICAgdmFyIHBhZ2UgPSB0aGlzLmdldFBhZ2UoZGF0YSk7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMocGFnZS5iaW5kaW5ncyk7XG4gIH07XG5cbiAgVExEUi5nZXRCaW5kaW5nc1dpdGhTaGFwZUlkcyA9IGZ1bmN0aW9uIGdldEJpbmRpbmdzV2l0aFNoYXBlSWRzKGRhdGEsIGlkcykge1xuICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQodGhpcy5nZXRCaW5kaW5ncyhkYXRhKS5maWx0ZXIoZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgICAgIHJldHVybiBpZHMuaW5jbHVkZXMoYmluZGluZy50b0lkKSB8fCBpZHMuaW5jbHVkZXMoYmluZGluZy5mcm9tSWQpO1xuICAgIH0pKS52YWx1ZXMoKSk7XG4gIH07XG5cbiAgVExEUi5jcmVhdGVCaW5kaW5ncyA9IGZ1bmN0aW9uIGNyZWF0ZUJpbmRpbmdzKGRhdGEsIGJpbmRpbmdzKSB7XG4gICAgdmFyIHBhZ2UgPSB0aGlzLmdldFBhZ2UoZGF0YSk7XG4gICAgYmluZGluZ3MuZm9yRWFjaChmdW5jdGlvbiAoYmluZGluZykge1xuICAgICAgcmV0dXJuIHBhZ2UuYmluZGluZ3NbYmluZGluZy5pZF0gPSBiaW5kaW5nO1xuICAgIH0pO1xuICB9O1xuXG4gIFRMRFIuZGVsZXRlQmluZGluZ3MgPSBmdW5jdGlvbiBkZWxldGVCaW5kaW5ncyhkYXRhLCBpZHMpIHtcbiAgICBpZiAoaWRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIHZhciBwYWdlID0gdGhpcy5nZXRQYWdlKGRhdGEpO1xuICAgIGlkcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuIGRlbGV0ZSBwYWdlLmJpbmRpbmdzW2lkXTtcbiAgICB9KTtcbiAgfVxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gIC8qICAgICAgICAgICAgICAgICAgICAgQXNzZXJ0aW9ucyAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgO1xuXG4gIFRMRFIuYXNzZXJ0U2hhcGVIYXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIGFzc2VydFNoYXBlSGFzUHJvcGVydHkoc2hhcGUsIHByb3ApIHtcbiAgICBpZiAoc2hhcGVbcHJvcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBUTERSO1xufSgpO1xuXG5mdW5jdGlvbiBhbGlnbihkYXRhLCBpZHMsIHR5cGUpIHtcbiAgdmFyIGluaXRpYWxTaGFwZXMgPSBpZHMubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgIHJldHVybiBUTERSLmdldFNoYXBlKGRhdGEsIGlkKTtcbiAgfSk7XG4gIHZhciBib3VuZHNGb3JTaGFwZXMgPSBpbml0aWFsU2hhcGVzLm1hcChmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHNoYXBlLmlkLFxuICAgICAgcG9pbnQ6IFtdLmNvbmNhdChzaGFwZS5wb2ludCksXG4gICAgICBib3VuZHM6IFRMRFIuZ2V0U2hhcGVVdGlscyhzaGFwZSkuZ2V0Qm91bmRzKHNoYXBlKVxuICAgIH07XG4gIH0pO1xuICB2YXIgY29tbW9uQm91bmRzID0gY29yZS5VdGlscy5nZXRDb21tb25Cb3VuZHMoYm91bmRzRm9yU2hhcGVzLm1hcChmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBib3VuZHMgPSBfcmVmLmJvdW5kcztcbiAgICByZXR1cm4gYm91bmRzO1xuICB9KSk7XG4gIHZhciBtaWRYID0gY29tbW9uQm91bmRzLm1pblggKyBjb21tb25Cb3VuZHMud2lkdGggLyAyO1xuICB2YXIgbWlkWSA9IGNvbW1vbkJvdW5kcy5taW5ZICsgY29tbW9uQm91bmRzLmhlaWdodCAvIDI7XG4gIHZhciBkZWx0YU1hcCA9IE9iamVjdC5mcm9tRW50cmllcyhib3VuZHNGb3JTaGFwZXMubWFwKGZ1bmN0aW9uIChfcmVmMikge1xuICAgIHZhciBfQWxpZ25UeXBlJENlbnRlclZlcnQ7XG5cbiAgICB2YXIgaWQgPSBfcmVmMi5pZCxcbiAgICAgICAgcG9pbnQgPSBfcmVmMi5wb2ludCxcbiAgICAgICAgYm91bmRzID0gX3JlZjIuYm91bmRzO1xuICAgIHJldHVybiBbaWQsIHtcbiAgICAgIHByZXY6IHBvaW50LFxuICAgICAgbmV4dDogKF9BbGlnblR5cGUkQ2VudGVyVmVydCA9IHt9LCBfQWxpZ25UeXBlJENlbnRlclZlcnRbZXhwb3J0cy5BbGlnblR5cGUuQ2VudGVyVmVydGljYWxdID0gW3BvaW50WzBdLCBtaWRZIC0gYm91bmRzLmhlaWdodCAvIDJdLCBfQWxpZ25UeXBlJENlbnRlclZlcnRbZXhwb3J0cy5BbGlnblR5cGUuQ2VudGVySG9yaXpvbnRhbF0gPSBbbWlkWCAtIGJvdW5kcy53aWR0aCAvIDIsIHBvaW50WzFdXSwgX0FsaWduVHlwZSRDZW50ZXJWZXJ0W2V4cG9ydHMuQWxpZ25UeXBlLlRvcF0gPSBbcG9pbnRbMF0sIGNvbW1vbkJvdW5kcy5taW5ZXSwgX0FsaWduVHlwZSRDZW50ZXJWZXJ0W2V4cG9ydHMuQWxpZ25UeXBlLkJvdHRvbV0gPSBbcG9pbnRbMF0sIGNvbW1vbkJvdW5kcy5tYXhZIC0gYm91bmRzLmhlaWdodF0sIF9BbGlnblR5cGUkQ2VudGVyVmVydFtleHBvcnRzLkFsaWduVHlwZS5MZWZ0XSA9IFtjb21tb25Cb3VuZHMubWluWCwgcG9pbnRbMV1dLCBfQWxpZ25UeXBlJENlbnRlclZlcnRbZXhwb3J0cy5BbGlnblR5cGUuUmlnaHRdID0gW2NvbW1vbkJvdW5kcy5tYXhYIC0gYm91bmRzLndpZHRoLCBwb2ludFsxXV0sIF9BbGlnblR5cGUkQ2VudGVyVmVydClbdHlwZV1cbiAgICB9XTtcbiAgfSkpO1xuXG4gIHZhciBfVExEUiRtdXRhdGVTaGFwZXMgPSBUTERSLm11dGF0ZVNoYXBlcyhkYXRhLCBpZHMsIGZ1bmN0aW9uIChzaGFwZSkge1xuICAgIGlmICghZGVsdGFNYXBbc2hhcGUuaWRdKSByZXR1cm4gc2hhcGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvaW50OiBkZWx0YU1hcFtzaGFwZS5pZF0ubmV4dFxuICAgIH07XG4gIH0pLFxuICAgICAgYmVmb3JlID0gX1RMRFIkbXV0YXRlU2hhcGVzLmJlZm9yZSxcbiAgICAgIGFmdGVyID0gX1RMRFIkbXV0YXRlU2hhcGVzLmFmdGVyO1xuXG4gIHJldHVybiB7XG4gICAgaWQ6ICdhbGlnbl9zaGFwZXMnLFxuICAgIGJlZm9yZToge1xuICAgICAgcGFnZToge1xuICAgICAgICBzaGFwZXM6IF9leHRlbmRzKHt9LCBiZWZvcmUpXG4gICAgICB9XG4gICAgfSxcbiAgICBhZnRlcjoge1xuICAgICAgcGFnZToge1xuICAgICAgICBzaGFwZXM6IF9leHRlbmRzKHt9LCBhZnRlcilcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRpc3RyaWJ1dGUoZGF0YSwgaWRzLCB0eXBlKSB7XG4gIHZhciBpbml0aWFsU2hhcGVzID0gaWRzLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gZGF0YS5wYWdlLnNoYXBlc1tpZF07XG4gIH0pO1xuICB2YXIgZGVsdGFNYXAgPSBPYmplY3QuZnJvbUVudHJpZXMoZ2V0RGlzdHJpYnV0aW9ucyhpbml0aWFsU2hhcGVzLCB0eXBlKS5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gW2QuaWQsIGRdO1xuICB9KSk7XG5cbiAgdmFyIF9UTERSJG11dGF0ZVNoYXBlcyA9IFRMRFIubXV0YXRlU2hhcGVzKGRhdGEsIGlkcywgZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgaWYgKCFkZWx0YU1hcFtzaGFwZS5pZF0pIHJldHVybiBzaGFwZTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9pbnQ6IGRlbHRhTWFwW3NoYXBlLmlkXS5uZXh0XG4gICAgfTtcbiAgfSksXG4gICAgICBiZWZvcmUgPSBfVExEUiRtdXRhdGVTaGFwZXMuYmVmb3JlLFxuICAgICAgYWZ0ZXIgPSBfVExEUiRtdXRhdGVTaGFwZXMuYWZ0ZXI7XG5cbiAgcmV0dXJuIHtcbiAgICBpZDogJ2Rpc3RyaWJ1dGVfc2hhcGVzJyxcbiAgICBiZWZvcmU6IHtcbiAgICAgIHBhZ2U6IHtcbiAgICAgICAgc2hhcGVzOiBfZXh0ZW5kcyh7fSwgYmVmb3JlKVxuICAgICAgfVxuICAgIH0sXG4gICAgYWZ0ZXI6IHtcbiAgICAgIHBhZ2U6IHtcbiAgICAgICAgc2hhcGVzOiBfZXh0ZW5kcyh7fSwgYWZ0ZXIpXG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXREaXN0cmlidXRpb25zKGluaXRpYWxTaGFwZXMsIHR5cGUpIHtcbiAgdmFyIGVudHJpZXMgPSBpbml0aWFsU2hhcGVzLm1hcChmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICB2YXIgdXRpbHMgPSBUTERSLmdldFNoYXBlVXRpbHMoc2hhcGUpO1xuICAgIHJldHVybiB7XG4gICAgICBpZDogc2hhcGUuaWQsXG4gICAgICBwb2ludDogW10uY29uY2F0KHNoYXBlLnBvaW50KSxcbiAgICAgIGJvdW5kczogdXRpbHMuZ2V0Qm91bmRzKHNoYXBlKSxcbiAgICAgIGNlbnRlcjogdXRpbHMuZ2V0Q2VudGVyKHNoYXBlKVxuICAgIH07XG4gIH0pO1xuICB2YXIgbGVuID0gZW50cmllcy5sZW5ndGg7XG4gIHZhciBjb21tb25Cb3VuZHMgPSBjb3JlLlV0aWxzLmdldENvbW1vbkJvdW5kcyhlbnRyaWVzLm1hcChmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBib3VuZHMgPSBfcmVmLmJvdW5kcztcbiAgICByZXR1cm4gYm91bmRzO1xuICB9KSk7XG4gIHZhciByZXN1bHRzID0gW107XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBleHBvcnRzLkRpc3RyaWJ1dGVUeXBlLkhvcml6b250YWw6XG4gICAgICB7XG4gICAgICAgIHZhciBzcGFuID0gZW50cmllcy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGMpIHtcbiAgICAgICAgICByZXR1cm4gYSArIGMuYm91bmRzLndpZHRoO1xuICAgICAgICB9LCAwKTtcblxuICAgICAgICBpZiAoc3BhbiA+IGNvbW1vbkJvdW5kcy53aWR0aCkge1xuICAgICAgICAgIHZhciBsZWZ0ID0gZW50cmllcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5ib3VuZHMubWluWCAtIGIuYm91bmRzLm1pblg7XG4gICAgICAgICAgfSlbMF07XG4gICAgICAgICAgdmFyIHJpZ2h0ID0gZW50cmllcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5ib3VuZHMubWF4WCAtIGEuYm91bmRzLm1heFg7XG4gICAgICAgICAgfSlbMF07XG4gICAgICAgICAgdmFyIGVudHJpZXNUb01vdmUgPSBlbnRyaWVzLmZpbHRlcihmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgcmV0dXJuIGEgIT09IGxlZnQgJiYgYSAhPT0gcmlnaHQ7XG4gICAgICAgICAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEuY2VudGVyWzBdIC0gYi5jZW50ZXJbMF07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHN0ZXAgPSAocmlnaHQuY2VudGVyWzBdIC0gbGVmdC5jZW50ZXJbMF0pIC8gKGxlbiAtIDEpO1xuICAgICAgICAgIHZhciB4ID0gbGVmdC5jZW50ZXJbMF0gKyBzdGVwO1xuICAgICAgICAgIGVudHJpZXNUb01vdmUuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjIsIGkpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IF9yZWYyLmlkLFxuICAgICAgICAgICAgICAgIHBvaW50ID0gX3JlZjIucG9pbnQsXG4gICAgICAgICAgICAgICAgYm91bmRzID0gX3JlZjIuYm91bmRzO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICBwcmV2OiBwb2ludCxcbiAgICAgICAgICAgICAgbmV4dDogW3ggKyBzdGVwICogaSAtIGJvdW5kcy53aWR0aCAvIDIsIGJvdW5kcy5taW5ZXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9lbnRyaWVzVG9Nb3ZlID0gZW50cmllcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5jZW50ZXJbMF0gLSBiLmNlbnRlclswXTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfeCA9IGNvbW1vbkJvdW5kcy5taW5YO1xuXG4gICAgICAgICAgdmFyIF9zdGVwID0gKGNvbW1vbkJvdW5kcy53aWR0aCAtIHNwYW4pIC8gKGxlbiAtIDEpO1xuXG4gICAgICAgICAgX2VudHJpZXNUb01vdmUuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjMsIGkpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IF9yZWYzLmlkLFxuICAgICAgICAgICAgICAgIHBvaW50ID0gX3JlZjMucG9pbnQsXG4gICAgICAgICAgICAgICAgYm91bmRzID0gX3JlZjMuYm91bmRzO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICBwcmV2OiBwb2ludCxcbiAgICAgICAgICAgICAgbmV4dDogW194LCBib3VuZHMubWluWV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3ggKz0gYm91bmRzLndpZHRoICsgX3N0ZXA7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgZXhwb3J0cy5EaXN0cmlidXRlVHlwZS5WZXJ0aWNhbDpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9zcGFuID0gZW50cmllcy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGMpIHtcbiAgICAgICAgICByZXR1cm4gYSArIGMuYm91bmRzLmhlaWdodDtcbiAgICAgICAgfSwgMCk7XG5cbiAgICAgICAgaWYgKF9zcGFuID4gY29tbW9uQm91bmRzLmhlaWdodCkge1xuICAgICAgICAgIHZhciB0b3AgPSBlbnRyaWVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLmJvdW5kcy5taW5ZIC0gYi5ib3VuZHMubWluWTtcbiAgICAgICAgICB9KVswXTtcbiAgICAgICAgICB2YXIgYm90dG9tID0gZW50cmllcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5ib3VuZHMubWF4WSAtIGEuYm91bmRzLm1heFk7XG4gICAgICAgICAgfSlbMF07XG5cbiAgICAgICAgICB2YXIgX2VudHJpZXNUb01vdmUyID0gZW50cmllcy5maWx0ZXIoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHJldHVybiBhICE9PSB0b3AgJiYgYSAhPT0gYm90dG9tO1xuICAgICAgICAgIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLmNlbnRlclsxXSAtIGIuY2VudGVyWzFdO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9zdGVwMiA9IChib3R0b20uY2VudGVyWzFdIC0gdG9wLmNlbnRlclsxXSkgLyAobGVuIC0gMSk7XG5cbiAgICAgICAgICB2YXIgeSA9IHRvcC5jZW50ZXJbMV0gKyBfc3RlcDI7XG5cbiAgICAgICAgICBfZW50cmllc1RvTW92ZTIuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjQsIGkpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IF9yZWY0LmlkLFxuICAgICAgICAgICAgICAgIHBvaW50ID0gX3JlZjQucG9pbnQsXG4gICAgICAgICAgICAgICAgYm91bmRzID0gX3JlZjQuYm91bmRzO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICBwcmV2OiBwb2ludCxcbiAgICAgICAgICAgICAgbmV4dDogW2JvdW5kcy5taW5YLCB5ICsgX3N0ZXAyICogaSAtIGJvdW5kcy5oZWlnaHQgLyAyXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9lbnRyaWVzVG9Nb3ZlMyA9IGVudHJpZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEuY2VudGVyWzFdIC0gYi5jZW50ZXJbMV07XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX3kgPSBjb21tb25Cb3VuZHMubWluWTtcblxuICAgICAgICAgIHZhciBfc3RlcDMgPSAoY29tbW9uQm91bmRzLmhlaWdodCAtIF9zcGFuKSAvIChsZW4gLSAxKTtcblxuICAgICAgICAgIF9lbnRyaWVzVG9Nb3ZlMy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmNSwgaSkge1xuICAgICAgICAgICAgdmFyIGlkID0gX3JlZjUuaWQsXG4gICAgICAgICAgICAgICAgcG9pbnQgPSBfcmVmNS5wb2ludCxcbiAgICAgICAgICAgICAgICBib3VuZHMgPSBfcmVmNS5ib3VuZHM7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgIHByZXY6IHBvaW50LFxuICAgICAgICAgICAgICBuZXh0OiBbYm91bmRzLm1pblgsIF95XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfeSArPSBib3VuZHMuaGVpZ2h0ICsgX3N0ZXAzO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gc3R5bGUoZGF0YSwgaWRzLCBjaGFuZ2VzKSB7XG4gIHZhciBfVExEUiRtdXRhdGVTaGFwZXMgPSBUTERSLm11dGF0ZVNoYXBlcyhkYXRhLCBpZHMsIGZ1bmN0aW9uIChzaGFwZSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdHlsZTogX2V4dGVuZHMoe30sIHNoYXBlLnN0eWxlLCBjaGFuZ2VzKVxuICAgIH07XG4gIH0pLFxuICAgICAgYmVmb3JlID0gX1RMRFIkbXV0YXRlU2hhcGVzLmJlZm9yZSxcbiAgICAgIGFmdGVyID0gX1RMRFIkbXV0YXRlU2hhcGVzLmFmdGVyO1xuXG4gIHJldHVybiB7XG4gICAgaWQ6ICdzdHlsZV9zaGFwZXMnLFxuICAgIGJlZm9yZToge1xuICAgICAgcGFnZToge1xuICAgICAgICBzaGFwZXM6IF9leHRlbmRzKHt9LCBiZWZvcmUpXG4gICAgICB9LFxuICAgICAgYXBwU3RhdGU6IHtcbiAgICAgICAgY3VycmVudFN0eWxlOiBfZXh0ZW5kcyh7fSwgZGF0YS5hcHBTdGF0ZS5jdXJyZW50U3R5bGUpXG4gICAgICB9XG4gICAgfSxcbiAgICBhZnRlcjoge1xuICAgICAgcGFnZToge1xuICAgICAgICBzaGFwZXM6IF9leHRlbmRzKHt9LCBhZnRlcilcbiAgICAgIH0sXG4gICAgICBhcHBTdGF0ZToge1xuICAgICAgICBjdXJyZW50U3R5bGU6IF9leHRlbmRzKHt9LCBkYXRhLmFwcFN0YXRlLmN1cnJlbnRTdHlsZSwgY2hhbmdlcylcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGR1cGxpY2F0ZShkYXRhLCBpZHMpIHtcbiAgdmFyIGRlbHRhID0gY29yZS5WZWMuZGl2KFsxNiwgMTZdLCBkYXRhLnBhZ2VTdGF0ZS5jYW1lcmEuem9vbSk7XG4gIHZhciBhZnRlciA9IE9iamVjdC5mcm9tRW50cmllcyhUTERSLmdldFNlbGVjdGVkSWRzKGRhdGEpLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gZGF0YS5wYWdlLnNoYXBlc1tpZF07XG4gIH0pLm1hcChmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICB2YXIgaWQgPSBjb3JlLlV0aWxzLnVuaXF1ZUlkKCk7XG4gICAgcmV0dXJuIFtpZCwgX2V4dGVuZHMoe30sIGNvcmUuVXRpbHMuZGVlcENsb25lKHNoYXBlKSwge1xuICAgICAgaWQ6IGlkLFxuICAgICAgcG9pbnQ6IGNvcmUuVmVjLmFkZChzaGFwZS5wb2ludCwgZGVsdGEpXG4gICAgfSldO1xuICB9KSk7XG4gIHZhciBiZWZvcmUgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmtleXMoYWZ0ZXIpLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gW2lkLCB1bmRlZmluZWRdO1xuICB9KSk7XG4gIHJldHVybiB7XG4gICAgaWQ6ICdkdXBsaWNhdGUnLFxuICAgIGJlZm9yZToge1xuICAgICAgcGFnZToge1xuICAgICAgICBzaGFwZXM6IF9leHRlbmRzKHt9LCBiZWZvcmUpXG4gICAgICB9LFxuICAgICAgcGFnZVN0YXRlOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlU3RhdGUsIHtcbiAgICAgICAgc2VsZWN0ZWRJZHM6IGlkc1xuICAgICAgfSlcbiAgICB9LFxuICAgIGFmdGVyOiB7XG4gICAgICBwYWdlOiB7XG4gICAgICAgIHNoYXBlczogX2V4dGVuZHMoe30sIGFmdGVyKVxuICAgICAgfSxcbiAgICAgIHBhZ2VTdGF0ZTogX2V4dGVuZHMoe30sIGRhdGEucGFnZVN0YXRlLCB7XG4gICAgICAgIHNlbGVjdGVkSWRzOiBPYmplY3Qua2V5cyhhZnRlcilcbiAgICAgIH0pXG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtb3ZlKGRhdGEsIGlkcywgdHlwZSkge1xuICB2YXIgX3Jlc3VsdCwgX3Jlc3VsdDI7XG5cbiAgLy8gR2V0IHRoZSB1bmlxdWUgcGFyZW50IGlkcyBmb3IgdGhlIHNlbGVjdGVkIGVsZW1lbnRzXG4gIHZhciBwYXJlbnRJZHMgPSBuZXcgU2V0KGlkcy5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIGRhdGEucGFnZS5zaGFwZXNbaWRdLnBhcmVudElkO1xuICB9KSk7XG4gIHZhciByZXN1bHQgPSB7XG4gICAgYmVmb3JlOiB7fSxcbiAgICBhZnRlcjoge31cbiAgfTtcbiAgdmFyIHN0YXJ0SW5kZXg7XG4gIHZhciBzdGFydENoaWxkSW5kZXg7XG4gIHZhciBzdGVwOyAvLyBDb2xsZWN0IHNoYXBlcyB3aXRoIGNvbW1vbiBwYXJlbnRzIGludG8gYSB0YWJsZSB1bmRlciB0aGVpciBwYXJlbnQgaWRcblxuICBBcnJheS5mcm9tKHBhcmVudElkcy52YWx1ZXMoKSkuZm9yRWFjaChmdW5jdGlvbiAocGFyZW50SWQpIHtcbiAgICB2YXIgc29ydGVkQ2hpbGRyZW4gPSBwYXJlbnRJZCA9PT0gZGF0YS5wYWdlLmlkID8gT2JqZWN0LnZhbHVlcyhkYXRhLnBhZ2Uuc2hhcGVzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5jaGlsZEluZGV4IC0gYi5jaGlsZEluZGV4O1xuICAgIH0pIDogZGF0YS5wYWdlLnNoYXBlc1twYXJlbnRJZF0uY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZElkKSB7XG4gICAgICByZXR1cm4gZGF0YS5wYWdlLnNoYXBlc1tjaGlsZElkXTtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5jaGlsZEluZGV4IC0gYi5jaGlsZEluZGV4O1xuICAgIH0pO1xuICAgIHZhciBzb3J0ZWRDaGlsZElkcyA9IHNvcnRlZENoaWxkcmVuLm1hcChmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgIHJldHVybiBzaGFwZS5pZDtcbiAgICB9KTtcbiAgICB2YXIgc29ydGVkSW5kaWNlc1RvTW92ZSA9IGlkcy5maWx0ZXIoZnVuY3Rpb24gKGlkKSB7XG4gICAgICByZXR1cm4gc29ydGVkQ2hpbGRJZHMuaW5jbHVkZXMoaWQpO1xuICAgIH0pLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHJldHVybiBzb3J0ZWRDaGlsZElkcy5pbmRleE9mKGlkKTtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYSAtIGI7XG4gICAgfSk7XG4gICAgaWYgKHNvcnRlZEluZGljZXNUb01vdmUubGVuZ3RoID09PSBzb3J0ZWRDaGlsZElkcy5sZW5ndGgpIHJldHVybjtcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBleHBvcnRzLk1vdmVUeXBlLlRvQmFjazpcbiAgICAgICAge1xuICAgICAgICAgIC8vICAgICAgICAgICAgICAgYSAgICAgICBiICBjXG4gICAgICAgICAgLy8gSW5pdGlhbCAgIDEgICAyICAgIDMgIDQgIDUgIDYgIDdcbiAgICAgICAgICAvLyBGaW5hbCAgIC4yNSAgLjUgIC43NSAgMSAgMyAgNiAgN1xuICAgICAgICAgIC8vICAgICAgICAgICBhICAgYiAgICBjXG4gICAgICAgICAgLy8gRmluZCB0aGUgbG93ZXN0IFwib3BlblwiIGluZGV4XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3J0ZWRDaGlsZElkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHNvcnRlZEluZGljZXNUb01vdmUuaW5jbHVkZXMoaSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgc3RhcnRJbmRleCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IC8vIEZpbmQgdGhlIGxvd2VzdCBjaGlsZCBpbmRleCB0aGF0IGlzbid0IGluIHNvcnRlZEluZGljZXNUb01vdmVcblxuXG4gICAgICAgICAgc3RhcnRDaGlsZEluZGV4ID0gc29ydGVkQ2hpbGRyZW5bc3RhcnRJbmRleF0uY2hpbGRJbmRleDsgLy8gRmluZCB0aGUgc3RlcCBmb3IgZWFjaCBhZGRpdGlvbmFsIGNoaWxkXG5cbiAgICAgICAgICBzdGVwID0gc3RhcnRDaGlsZEluZGV4IC8gKHNvcnRlZEluZGljZXNUb01vdmUubGVuZ3RoICsgMSk7IC8vIEdldCB0aGUgcmVzdWx0cyBvZiBtb3ZpbmcgdGhlIHNlbGVjdGVkIHNoYXBlcyBiZWxvdyB0aGUgZmlyc3Qgb3BlbiBpbmRleCdzIHNoYXBlXG5cbiAgICAgICAgICByZXN1bHQgPSBUTERSLm11dGF0ZVNoYXBlcyhkYXRhLCBzb3J0ZWRJbmRpY2VzVG9Nb3ZlLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgcmV0dXJuIHNvcnRlZENoaWxkcmVuW2ldLmlkO1xuICAgICAgICAgIH0pLnJldmVyc2UoKSwgZnVuY3Rpb24gKF9zaGFwZSwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgY2hpbGRJbmRleDogc3RhcnRDaGlsZEluZGV4IC0gKGkgKyAxKSAqIHN0ZXBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBleHBvcnRzLk1vdmVUeXBlLlRvRnJvbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyAgICAgICAgICAgICAgYSAgICAgYiAgY1xuICAgICAgICAgIC8vIEluaXRpYWwgICAxICAyICAzICA0ICA1ICA2ICAgN1xuICAgICAgICAgIC8vIEZpbmFsICAgICAxICAzICA2ICA3ICA4ICA5ICAxMFxuICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICBhICBiICAgY1xuICAgICAgICAgIC8vIEZpbmQgdGhlIGhpZ2hlc3QgXCJvcGVuXCIgaW5kZXhcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IHNvcnRlZENoaWxkSWRzLmxlbmd0aCAtIDE7IF9pID49IDA7IF9pLS0pIHtcbiAgICAgICAgICAgIGlmIChzb3J0ZWRJbmRpY2VzVG9Nb3ZlLmluY2x1ZGVzKF9pKSkgY29udGludWU7XG4gICAgICAgICAgICBzdGFydEluZGV4ID0gX2k7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IC8vIEZpbmQgdGhlIGxvd2VzdCBjaGlsZCBpbmRleCB0aGF0IGlzbid0IGluIHNvcnRlZEluZGljZXNUb01vdmVcblxuXG4gICAgICAgICAgc3RhcnRDaGlsZEluZGV4ID0gc29ydGVkQ2hpbGRyZW5bc3RhcnRJbmRleF0uY2hpbGRJbmRleDsgLy8gRmluZCB0aGUgc3RlcCBmb3IgZWFjaCBhZGRpdGlvbmFsIGNoaWxkXG5cbiAgICAgICAgICBzdGVwID0gMTsgLy8gR2V0IHRoZSByZXN1bHRzIG9mIG1vdmluZyB0aGUgc2VsZWN0ZWQgc2hhcGVzIGJlbG93IHRoZSBmaXJzdCBvcGVuIGluZGV4J3Mgc2hhcGVcblxuICAgICAgICAgIHJlc3VsdCA9IFRMRFIubXV0YXRlU2hhcGVzKGRhdGEsIHNvcnRlZEluZGljZXNUb01vdmUubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICByZXR1cm4gc29ydGVkQ2hpbGRyZW5baV0uaWQ7XG4gICAgICAgICAgfSksIGZ1bmN0aW9uIChfc2hhcGUsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGNoaWxkSW5kZXg6IHN0YXJ0Q2hpbGRJbmRleCArIChpICsgMSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBleHBvcnRzLk1vdmVUeXBlLkJhY2t3YXJkOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gICAgICAgICAgICAgICBhICAgICAgICAgICBiICBjXG4gICAgICAgICAgLy8gSW5pdGlhbCAgICAxICAyICAgICAzICAgICA0ICA1ICA2ICA3XG4gICAgICAgICAgLy8gRmluYWwgICAgIC41ICAxICAxLjY2ICAyLjMzICAzICA2ICA3XG4gICAgICAgICAgLy8gICAgICAgICAgIGEgICAgICAgICBiICAgICBjXG4gICAgICAgICAgdmFyIGluZGV4TWFwID0ge307IC8vIFN0YXJ0aW5nIGZyb20gdGhlIHRvcC4uLlxuXG4gICAgICAgICAgZm9yICh2YXIgX2kyID0gc29ydGVkQ2hpbGRJZHMubGVuZ3RoIC0gMTsgX2kyID49IDA7IF9pMi0tKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBmb3VuZCBhIG1vdmluZyBpbmRleC4uLlxuICAgICAgICAgICAgaWYgKHNvcnRlZEluZGljZXNUb01vdmUuaW5jbHVkZXMoX2kyKSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gX2kyOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGUgZG93bndhcmQgdW50aWwgd2UgZmluZCBhbiBvcGVuIHNwb3RcbiAgICAgICAgICAgICAgICBpZiAoIXNvcnRlZEluZGljZXNUb01vdmUuaW5jbHVkZXMoaikpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGkgPSB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGNsb3NlZCBzcG90XG4gICAgICAgICAgICAgICAgICAvLyBqID0gdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBvcGVuIHNwb3RcbiAgICAgICAgICAgICAgICAgIHN0YXJ0Q2hpbGRJbmRleCA9IGogPT09IDAgPyBzb3J0ZWRDaGlsZHJlbltqXS5jaGlsZEluZGV4IC8gMiA6IHNvcnRlZENoaWxkcmVuW2ogLSAxXS5jaGlsZEluZGV4O1xuXG4gICAgICAgICAgICAgICAgICB2YXIgX3N0ZXAgPSAoc29ydGVkQ2hpbGRyZW5bal0uY2hpbGRJbmRleCAtIHN0YXJ0Q2hpbGRJbmRleCkgLyAoX2kyIC0gaiArIDEpO1xuXG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IF9pMiAtIGo7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBpbmRleE1hcFtzb3J0ZWRDaGlsZHJlbltqICsgayArIDFdLmlkXSA9IHN0YXJ0Q2hpbGRJbmRleCArIF9zdGVwICogKGsgKyAxKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKE9iamVjdC52YWx1ZXMoaW5kZXhNYXApLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgcmVzdWx0cyBvZiBtb3ZpbmcgdGhlIHNlbGVjdGVkIHNoYXBlcyBiZWxvdyB0aGUgZmlyc3Qgb3BlbiBpbmRleCdzIHNoYXBlXG4gICAgICAgICAgICByZXN1bHQgPSBUTERSLm11dGF0ZVNoYXBlcyhkYXRhLCBzb3J0ZWRJbmRpY2VzVG9Nb3ZlLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICByZXR1cm4gc29ydGVkQ2hpbGRyZW5baV0uaWQ7XG4gICAgICAgICAgICB9KSwgZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleDogaW5kZXhNYXBbc2hhcGUuaWRdXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIGV4cG9ydHMuTW92ZVR5cGUuRm9yd2FyZDpcbiAgICAgICAge1xuICAgICAgICAgIC8vICAgICAgICAgICAgIGEgICAgIGIgY1xuICAgICAgICAgIC8vIEluaXRpYWwgICAxIDIgICAzIDQgNSA2IDdcbiAgICAgICAgICAvLyBGaW5hbCAgICAgMSAzIDMuNSA2IDcgOCA5XG4gICAgICAgICAgLy8gICAgICAgICAgICAgICAgIGEgICAgIGIgY1xuICAgICAgICAgIHZhciBfaW5kZXhNYXAgPSB7fTsgLy8gU3RhcnRpbmcgZnJvbSB0aGUgdG9wLi4uXG5cbiAgICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBzb3J0ZWRDaGlsZElkcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBmb3VuZCBhIG1vdmluZyBpbmRleC4uLlxuICAgICAgICAgICAgaWYgKHNvcnRlZEluZGljZXNUb01vdmUuaW5jbHVkZXMoX2kzKSkge1xuICAgICAgICAgICAgICAvLyBTZWFyY2ggZm9yIHRoZSBmaXJzdCBvcGVuIHNwb3QgYWJvdmUgdGhpcyBvbmVcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2ogPSBfaTM7IF9qIDwgc29ydGVkQ2hpbGRJZHMubGVuZ3RoOyBfaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzb3J0ZWRJbmRpY2VzVG9Nb3ZlLmluY2x1ZGVzKF9qKSkge1xuICAgICAgICAgICAgICAgICAgLy8gaSA9IHRoZSBsb3cgaW5kZXggb2YgdGhlIGZpcnN0IGNsb3NlZCBzcG90XG4gICAgICAgICAgICAgICAgICAvLyBqID0gdGhlIGhpZ2ggaW5kZXggb2YgdGhlIGZpcnN0IG9wZW4gc3BvdFxuICAgICAgICAgICAgICAgICAgc3RhcnRDaGlsZEluZGV4ID0gc29ydGVkQ2hpbGRyZW5bX2pdLmNoaWxkSW5kZXg7XG5cbiAgICAgICAgICAgICAgICAgIHZhciBfc3RlcDIgPSBfaiA9PT0gc29ydGVkQ2hpbGRJZHMubGVuZ3RoIC0gMSA/IDEgOiAoc29ydGVkQ2hpbGRyZW5bX2ogKyAxXS5jaGlsZEluZGV4IC0gc3RhcnRDaGlsZEluZGV4KSAvIChfaiAtIF9pMyArIDEpO1xuXG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBfayA9IDA7IF9rIDwgX2ogLSBfaTM7IF9rKyspIHtcbiAgICAgICAgICAgICAgICAgICAgX2luZGV4TWFwW3NvcnRlZENoaWxkcmVuW19pMyArIF9rXS5pZF0gPSBzdGFydENoaWxkSW5kZXggKyBfc3RlcDIgKiAoX2sgKyAxKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKE9iamVjdC52YWx1ZXMoX2luZGV4TWFwKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIHJlc3VsdHMgb2YgbW92aW5nIHRoZSBzZWxlY3RlZCBzaGFwZXMgYmVsb3cgdGhlIGZpcnN0IG9wZW4gaW5kZXgncyBzaGFwZVxuICAgICAgICAgICAgcmVzdWx0ID0gVExEUi5tdXRhdGVTaGFwZXMoZGF0YSwgc29ydGVkSW5kaWNlc1RvTW92ZS5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNvcnRlZENoaWxkcmVuW2ldLmlkO1xuICAgICAgICAgICAgfSksIGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXg6IF9pbmRleE1hcFtzaGFwZS5pZF1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBpZDogJ21vdmVfc2hhcGVzJyxcbiAgICBiZWZvcmU6IHtcbiAgICAgIHBhZ2U6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2UsIHtcbiAgICAgICAgc2hhcGVzOiAoKF9yZXN1bHQgPSByZXN1bHQpID09IG51bGwgPyB2b2lkIDAgOiBfcmVzdWx0LmJlZm9yZSkgfHwge31cbiAgICAgIH0pXG4gICAgfSxcbiAgICBhZnRlcjoge1xuICAgICAgcGFnZTogX2V4dGVuZHMoe30sIGRhdGEucGFnZSwge1xuICAgICAgICBzaGFwZXM6ICgoX3Jlc3VsdDIgPSByZXN1bHQpID09IG51bGwgPyB2b2lkIDAgOiBfcmVzdWx0Mi5hZnRlcikgfHwge31cbiAgICAgIH0pXG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGUoZGF0YSwgaWRzLCBkZWx0YSkge1xuICB2YXIgX1RMRFIkbXV0YXRlU2hhcGVzID0gVExEUi5tdXRhdGVTaGFwZXMoZGF0YSwgaWRzLCBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcG9pbnQ6IGNvcmUuVmVjLmFkZChzaGFwZS5wb2ludCwgZGVsdGEpXG4gICAgfTtcbiAgfSksXG4gICAgICBiZWZvcmUgPSBfVExEUiRtdXRhdGVTaGFwZXMuYmVmb3JlLFxuICAgICAgYWZ0ZXIgPSBfVExEUiRtdXRhdGVTaGFwZXMuYWZ0ZXI7XG5cbiAgcmV0dXJuIHtcbiAgICBpZDogJ3RyYW5zbGF0ZV9zaGFwZXMnLFxuICAgIGJlZm9yZToge1xuICAgICAgcGFnZTogX2V4dGVuZHMoe30sIGRhdGEucGFnZSwge1xuICAgICAgICBzaGFwZXM6IF9leHRlbmRzKHt9LCBiZWZvcmUpXG4gICAgICB9KVxuICAgIH0sXG4gICAgYWZ0ZXI6IHtcbiAgICAgIHBhZ2U6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2UsIHtcbiAgICAgICAgc2hhcGVzOiBfZXh0ZW5kcyh7fSwgYWZ0ZXIpXG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdG9nZ2xlKGRhdGEsIGlkcywgcHJvcCkge1xuICB2YXIgaW5pdGlhbFNoYXBlcyA9IGlkcy5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIGRhdGEucGFnZS5zaGFwZXNbaWRdO1xuICB9KTtcbiAgdmFyIGlzQWxsVG9nZ2xlZCA9IGluaXRpYWxTaGFwZXMuZXZlcnkoZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgcmV0dXJuIHNoYXBlW3Byb3BdO1xuICB9KTtcblxuICB2YXIgX1RMRFIkbXV0YXRlU2hhcGVzID0gVExEUi5tdXRhdGVTaGFwZXMoZGF0YSwgVExEUi5nZXRTZWxlY3RlZElkcyhkYXRhKSwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgcmV0dXJuIF9yZWYgPSB7fSwgX3JlZltwcm9wXSA9ICFpc0FsbFRvZ2dsZWQsIF9yZWY7XG4gIH0pLFxuICAgICAgYmVmb3JlID0gX1RMRFIkbXV0YXRlU2hhcGVzLmJlZm9yZSxcbiAgICAgIGFmdGVyID0gX1RMRFIkbXV0YXRlU2hhcGVzLmFmdGVyO1xuXG4gIHJldHVybiB7XG4gICAgaWQ6ICd0b2dnbGVfc2hhcGVzJyxcbiAgICBiZWZvcmU6IHtcbiAgICAgIHBhZ2U6IHtcbiAgICAgICAgc2hhcGVzOiBfZXh0ZW5kcyh7fSwgYmVmb3JlKVxuICAgICAgfVxuICAgIH0sXG4gICAgYWZ0ZXI6IHtcbiAgICAgIHBhZ2U6IHtcbiAgICAgICAgc2hhcGVzOiBfZXh0ZW5kcyh7fSwgYWZ0ZXIpXG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBkZWxldGVTaGFwZXMoZGF0YSwgaWRzKSB7XG4gIHJldHVybiB7XG4gICAgaWQ6ICd0b2dnbGVfc2hhcGVzJyxcbiAgICBiZWZvcmU6IHtcbiAgICAgIHBhZ2U6IHtcbiAgICAgICAgc2hhcGVzOiBPYmplY3QuZnJvbUVudHJpZXMoaWRzLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICByZXR1cm4gW2lkLCBkYXRhLnBhZ2Uuc2hhcGVzW2lkXV07XG4gICAgICAgIH0pKVxuICAgICAgfSxcbiAgICAgIHBhZ2VTdGF0ZToge1xuICAgICAgICBzZWxlY3RlZElkczogW10uY29uY2F0KGRhdGEucGFnZVN0YXRlLnNlbGVjdGVkSWRzKVxuICAgICAgfVxuICAgIH0sXG4gICAgYWZ0ZXI6IHtcbiAgICAgIHBhZ2U6IHtcbiAgICAgICAgc2hhcGVzOiBPYmplY3QuZnJvbUVudHJpZXMoaWRzLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICByZXR1cm4gW2lkLCB1bmRlZmluZWRdO1xuICAgICAgICB9KSlcbiAgICAgIH0sXG4gICAgICBwYWdlU3RhdGU6IHtcbiAgICAgICAgc2VsZWN0ZWRJZHM6IFtdXG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgUEkyID0gTWF0aC5QSSAqIDI7XG5mdW5jdGlvbiByb3RhdGUoZGF0YSwgaWRzLCBkZWx0YSkge1xuICBpZiAoZGVsdGEgPT09IHZvaWQgMCkge1xuICAgIGRlbHRhID0gLVBJMiAvIDQ7XG4gIH1cblxuICB2YXIgaW5pdGlhbFNoYXBlcyA9IGlkcy5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIGRhdGEucGFnZS5zaGFwZXNbaWRdO1xuICB9KTtcbiAgdmFyIGJvdW5kc0ZvclNoYXBlcyA9IGluaXRpYWxTaGFwZXMubWFwKGZ1bmN0aW9uIChzaGFwZSkge1xuICAgIHZhciB1dGlscyA9IFRMRFIuZ2V0U2hhcGVVdGlscyhzaGFwZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBzaGFwZS5pZCxcbiAgICAgIHBvaW50OiBbXS5jb25jYXQoc2hhcGUucG9pbnQpLFxuICAgICAgYm91bmRzOiB1dGlscy5nZXRCb3VuZHMoc2hhcGUpLFxuICAgICAgY2VudGVyOiB1dGlscy5nZXRDZW50ZXIoc2hhcGUpLFxuICAgICAgcm90YXRpb246IHNoYXBlLnJvdGF0aW9uXG4gICAgfTtcbiAgfSk7XG4gIHZhciBjb21tb25Cb3VuZHMgPSBjb3JlLlV0aWxzLmdldENvbW1vbkJvdW5kcyhib3VuZHNGb3JTaGFwZXMubWFwKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIGJvdW5kcyA9IF9yZWYuYm91bmRzO1xuICAgIHJldHVybiBib3VuZHM7XG4gIH0pKTtcbiAgdmFyIGNvbW1vbkJvdW5kc0NlbnRlciA9IGNvcmUuVXRpbHMuZ2V0Qm91bmRzQ2VudGVyKGNvbW1vbkJvdW5kcyk7XG4gIHZhciByb3RhdGlvbnMgPSBPYmplY3QuZnJvbUVudHJpZXMoYm91bmRzRm9yU2hhcGVzLm1hcChmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICB2YXIgaWQgPSBfcmVmMi5pZCxcbiAgICAgICAgcG9pbnQgPSBfcmVmMi5wb2ludCxcbiAgICAgICAgY2VudGVyID0gX3JlZjIuY2VudGVyLFxuICAgICAgICByb3RhdGlvbiA9IF9yZWYyLnJvdGF0aW9uO1xuICAgIHZhciBvZmZzZXQgPSBjb3JlLlZlYy5zdWIoY2VudGVyLCBwb2ludCk7XG4gICAgdmFyIG5leHRQb2ludCA9IGNvcmUuVmVjLnN1Yihjb3JlLlZlYy5yb3RXaXRoKGNlbnRlciwgY29tbW9uQm91bmRzQ2VudGVyLCAtKFBJMiAvIDQpKSwgb2Zmc2V0KTtcbiAgICB2YXIgbmV4dFJvdGF0aW9uID0gKFBJMiArICgocm90YXRpb24gfHwgMCkgKyBkZWx0YSkpICUgUEkyO1xuICAgIHJldHVybiBbaWQsIHtcbiAgICAgIHBvaW50OiBuZXh0UG9pbnQsXG4gICAgICByb3RhdGlvbjogbmV4dFJvdGF0aW9uXG4gICAgfV07XG4gIH0pKTtcbiAgdmFyIHByZXZCb3VuZHNSb3RhdGlvbiA9IGRhdGEucGFnZVN0YXRlLmJvdW5kc1JvdGF0aW9uO1xuICB2YXIgbmV4dEJvdW5kc1JvdGF0aW9uID0gKFBJMiArICgoZGF0YS5wYWdlU3RhdGUuYm91bmRzUm90YXRpb24gfHwgMCkgKyBkZWx0YSkpICUgUEkyO1xuXG4gIHZhciBfVExEUiRtdXRhdGVTaGFwZXMgPSBUTERSLm11dGF0ZVNoYXBlcyhkYXRhLCBpZHMsIGZ1bmN0aW9uIChzaGFwZSkge1xuICAgIHJldHVybiByb3RhdGlvbnNbc2hhcGUuaWRdO1xuICB9KSxcbiAgICAgIGJlZm9yZSA9IF9UTERSJG11dGF0ZVNoYXBlcy5iZWZvcmUsXG4gICAgICBhZnRlciA9IF9UTERSJG11dGF0ZVNoYXBlcy5hZnRlcjtcblxuICByZXR1cm4ge1xuICAgIGlkOiAndG9nZ2xlX3NoYXBlcycsXG4gICAgYmVmb3JlOiB7XG4gICAgICBwYWdlOiB7XG4gICAgICAgIHNoYXBlczogX2V4dGVuZHMoe30sIGJlZm9yZSlcbiAgICAgIH0sXG4gICAgICBwYWdlU3RhdGU6IHtcbiAgICAgICAgYm91bmRzUm90YXRpb246IHByZXZCb3VuZHNSb3RhdGlvblxuICAgICAgfVxuICAgIH0sXG4gICAgYWZ0ZXI6IHtcbiAgICAgIHBhZ2U6IHtcbiAgICAgICAgc2hhcGVzOiBfZXh0ZW5kcyh7fSwgYWZ0ZXIpXG4gICAgICB9LFxuICAgICAgcGFnZVN0YXRlOiB7XG4gICAgICAgIGJvdW5kc1JvdGF0aW9uOiBuZXh0Qm91bmRzUm90YXRpb25cbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0cmV0Y2goZGF0YSwgaWRzLCB0eXBlKSB7XG4gIHZhciBpbml0aWFsU2hhcGVzID0gaWRzLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gZGF0YS5wYWdlLnNoYXBlc1tpZF07XG4gIH0pO1xuICB2YXIgYm91bmRzRm9yU2hhcGVzID0gaW5pdGlhbFNoYXBlcy5tYXAoZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgcmV0dXJuIFRMRFIuZ2V0Qm91bmRzKHNoYXBlKTtcbiAgfSk7XG4gIHZhciBjb21tb25Cb3VuZHMgPSBjb3JlLlV0aWxzLmdldENvbW1vbkJvdW5kcyhib3VuZHNGb3JTaGFwZXMpO1xuXG4gIHZhciBfVExEUiRtdXRhdGVTaGFwZXMgPSBUTERSLm11dGF0ZVNoYXBlcyhkYXRhLCBpZHMsIGZ1bmN0aW9uIChzaGFwZSkge1xuICAgIHZhciBib3VuZHMgPSBUTERSLmdldEJvdW5kcyhzaGFwZSk7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgZXhwb3J0cy5TdHJldGNoVHlwZS5Ib3Jpem9udGFsOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIG5ld0JvdW5kcyA9IF9leHRlbmRzKHt9LCBib3VuZHMsIHtcbiAgICAgICAgICAgIG1pblg6IGNvbW1vbkJvdW5kcy5taW5YLFxuICAgICAgICAgICAgbWF4WDogY29tbW9uQm91bmRzLm1heFgsXG4gICAgICAgICAgICB3aWR0aDogY29tbW9uQm91bmRzLndpZHRoXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gVExEUi5nZXRTaGFwZVV0aWxzKHNoYXBlKS50cmFuc2Zvcm1TaW5nbGUoc2hhcGUsIG5ld0JvdW5kcywge1xuICAgICAgICAgICAgdHlwZTogY29yZS5UTEJvdW5kc0Nvcm5lci5Ub3BMZWZ0LFxuICAgICAgICAgICAgc2NhbGVYOiBuZXdCb3VuZHMud2lkdGggLyBib3VuZHMud2lkdGgsXG4gICAgICAgICAgICBzY2FsZVk6IDEsXG4gICAgICAgICAgICBpbml0aWFsU2hhcGU6IHNoYXBlLFxuICAgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiBbMC41LCAwLjVdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBleHBvcnRzLlN0cmV0Y2hUeXBlLlZlcnRpY2FsOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9uZXdCb3VuZHMgPSBfZXh0ZW5kcyh7fSwgYm91bmRzLCB7XG4gICAgICAgICAgICBtaW5ZOiBjb21tb25Cb3VuZHMubWluWSxcbiAgICAgICAgICAgIG1heFk6IGNvbW1vbkJvdW5kcy5tYXhZLFxuICAgICAgICAgICAgaGVpZ2h0OiBjb21tb25Cb3VuZHMuaGVpZ2h0XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gVExEUi5nZXRTaGFwZVV0aWxzKHNoYXBlKS50cmFuc2Zvcm1TaW5nbGUoc2hhcGUsIF9uZXdCb3VuZHMsIHtcbiAgICAgICAgICAgIHR5cGU6IGNvcmUuVExCb3VuZHNDb3JuZXIuVG9wTGVmdCxcbiAgICAgICAgICAgIHNjYWxlWDogMSxcbiAgICAgICAgICAgIHNjYWxlWTogX25ld0JvdW5kcy5oZWlnaHQgLyBib3VuZHMuaGVpZ2h0LFxuICAgICAgICAgICAgaW5pdGlhbFNoYXBlOiBzaGFwZSxcbiAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbjogWzAuNSwgMC41XVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICB9KSxcbiAgICAgIGJlZm9yZSA9IF9UTERSJG11dGF0ZVNoYXBlcy5iZWZvcmUsXG4gICAgICBhZnRlciA9IF9UTERSJG11dGF0ZVNoYXBlcy5hZnRlcjtcblxuICByZXR1cm4ge1xuICAgIGlkOiAnc3RyZXRjaF9zaGFwZXMnLFxuICAgIGJlZm9yZToge1xuICAgICAgcGFnZToge1xuICAgICAgICBzaGFwZXM6IF9leHRlbmRzKHt9LCBiZWZvcmUpXG4gICAgICB9XG4gICAgfSxcbiAgICBhZnRlcjoge1xuICAgICAgcGFnZToge1xuICAgICAgICBzaGFwZXM6IF9leHRlbmRzKHt9LCBhZnRlcilcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZShkYXRhLCBzaGFwZXMpIHtcbiAgcmV0dXJuIHtcbiAgICBpZDogJ3RvZ2dsZV9zaGFwZXMnLFxuICAgIGJlZm9yZToge1xuICAgICAgcGFnZToge1xuICAgICAgICBzaGFwZXM6IE9iamVjdC5mcm9tRW50cmllcyhzaGFwZXMubWFwKGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgICAgIHJldHVybiBbc2hhcGUuaWQsIHVuZGVmaW5lZF07XG4gICAgICAgIH0pKVxuICAgICAgfVxuICAgIH0sXG4gICAgYWZ0ZXI6IHtcbiAgICAgIHBhZ2U6IHtcbiAgICAgICAgc2hhcGVzOiBPYmplY3QuZnJvbUVudHJpZXMoc2hhcGVzLm1hcChmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgICAgICByZXR1cm4gW3NoYXBlLmlkLCBzaGFwZV07XG4gICAgICAgIH0pKVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxudmFyIEJydXNoU2Vzc2lvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJydXNoU2Vzc2lvbihfZGF0YSwgX3BvaW50KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuaWQgPSAnYnJ1c2gnO1xuICAgIHRoaXMub3JpZ2luID0gdm9pZCAwO1xuICAgIHRoaXMuc25hcHNob3QgPSB2b2lkIDA7XG5cbiAgICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICB0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBwb2ludCwgY29udGFpbk1vZGUpIHtcbiAgICAgIGlmIChjb250YWluTW9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRhaW5Nb2RlID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBzbmFwc2hvdCA9IF90aGlzLnNuYXBzaG90LFxuICAgICAgICAgIG9yaWdpbiA9IF90aGlzLm9yaWdpbjsgLy8gQ3JlYXRlIGEgYm91bmRpbmcgYm94IGJldHdlZW4gdGhlIG9yaWdpbiBhbmQgdGhlIG5ldyBwb2ludFxuXG4gICAgICB2YXIgYnJ1c2ggPSBjb3JlLlV0aWxzLmdldEJvdW5kc0Zyb21Qb2ludHMoW29yaWdpbiwgcG9pbnRdKTtcbiAgICAgIGNvcmUuYnJ1c2hVcGRhdGVyLnNldChicnVzaCk7IC8vIEZpbmQgaWRzIG9mIGJydXNoZWQgc2hhcGVzXG5cbiAgICAgIHZhciBoaXRzID0gbmV3IFNldCgpO1xuICAgICAgdmFyIHNlbGVjdGVkSWRzID0gbmV3IFNldChzbmFwc2hvdC5zZWxlY3RlZElkcyk7XG4gICAgICBzbmFwc2hvdC5zaGFwZXNUb1Rlc3QuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgaWQgPSBfcmVmLmlkLFxuICAgICAgICAgICAgdXRpbCA9IF9yZWYudXRpbCxcbiAgICAgICAgICAgIHNlbGVjdElkID0gX3JlZi5zZWxlY3RJZDtcbiAgICAgICAgaWYgKHNlbGVjdGVkSWRzLmhhcyhpZCkpIHJldHVybjtcbiAgICAgICAgdmFyIHNoYXBlID0gZGF0YS5wYWdlLnNoYXBlc1tpZF07XG5cbiAgICAgICAgaWYgKCFoaXRzLmhhcyhzZWxlY3RJZCkpIHtcbiAgICAgICAgICBpZiAoY29udGFpbk1vZGUgPyBjb3JlLlV0aWxzLmJvdW5kc0NvbnRhaW4oYnJ1c2gsIHV0aWwuZ2V0Qm91bmRzKHNoYXBlKSkgOiB1dGlsLmhpdFRlc3RCb3VuZHMoc2hhcGUsIGJydXNoKSkge1xuICAgICAgICAgICAgaGl0cy5hZGQoc2VsZWN0SWQpOyAvLyBXaGVuIGJydXNoaW5nIGEgc2hhcGUsIHNlbGVjdCBpdHMgdG9wIGdyb3VwIHBhcmVudC5cblxuICAgICAgICAgICAgaWYgKCFzZWxlY3RlZElkcy5oYXMoc2VsZWN0SWQpKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGVkSWRzLmFkZChzZWxlY3RJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChzZWxlY3RlZElkcy5oYXMoc2VsZWN0SWQpKSB7XG4gICAgICAgICAgICBzZWxlY3RlZElkc1tcImRlbGV0ZVwiXShzZWxlY3RJZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHNlbGVjdGVkSWRzLnNpemUgPT09IGRhdGEucGFnZVN0YXRlLnNlbGVjdGVkSWRzLmxlbmd0aCAmJiBkYXRhLnBhZ2VTdGF0ZS5zZWxlY3RlZElkcy5ldmVyeShmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkSWRzLmhhcyhpZCk7XG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBkYXRhLCB7XG4gICAgICAgIHBhZ2VTdGF0ZTogX2V4dGVuZHMoe30sIGRhdGEucGFnZVN0YXRlLCB7XG4gICAgICAgICAgc2VsZWN0ZWRJZHM6IEFycmF5LmZyb20oc2VsZWN0ZWRJZHMudmFsdWVzKCkpXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5vcmlnaW4gPSBjb3JlLlZlYy5yb3VuZChfcG9pbnQpO1xuICAgIHRoaXMuc25hcHNob3QgPSBnZXRCcnVzaFNuYXBzaG90KF9kYXRhKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBCcnVzaFNlc3Npb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5jYW5jZWwgPSBmdW5jdGlvbiBjYW5jZWwoZGF0YSkge1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgZGF0YSwge1xuICAgICAgcGFnZVN0YXRlOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlU3RhdGUsIHtcbiAgICAgICAgc2VsZWN0ZWRJZHM6IHRoaXMuc25hcHNob3Quc2VsZWN0ZWRJZHNcbiAgICAgIH0pXG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBsZXRlID0gZnVuY3Rpb24gY29tcGxldGUoZGF0YSkge1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgZGF0YSwge1xuICAgICAgcGFnZVN0YXRlOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlU3RhdGUsIHtcbiAgICAgICAgc2VsZWN0ZWRJZHM6IFtdLmNvbmNhdChkYXRhLnBhZ2VTdGF0ZS5zZWxlY3RlZElkcylcbiAgICAgIH0pXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEJydXNoU2Vzc2lvbjtcbn0oKTtcbi8qKlxyXG4gKiBHZXQgYSBzbmFwc2hvdCBvZiB0aGUgY3VycmVudCBzZWxlY3RlZCBpZHMsIGZvciBlYWNoIHNoYXBlIHRoYXQgaXNcclxuICogbm90IGFscmVhZHkgc2VsZWN0ZWQsIHRoZSBzaGFwZSdzIGlkIGFuZCBhIHRlc3QgdG8gc2VlIHdoZXRoZXIgdGhlXHJcbiAqIGJydXNoIHdpbGwgaW50ZXJzZWN0IHRoYXQgc2hhcGUuIEZvciB0ZXN0cywgc3RhcnQgYnJvYWQgLT4gZmluZS5cclxuICovXG5cbmZ1bmN0aW9uIGdldEJydXNoU25hcHNob3QoZGF0YSkge1xuICB2YXIgc2VsZWN0ZWRJZHMgPSBbXS5jb25jYXQoZGF0YS5wYWdlU3RhdGUuc2VsZWN0ZWRJZHMpO1xuICB2YXIgc2hhcGVzVG9UZXN0ID0gVExEUi5nZXRTaGFwZXMoZGF0YSkuZmlsdGVyKGZ1bmN0aW9uIChzaGFwZSkge1xuICAgIHJldHVybiAhKHNoYXBlLmlzSGlkZGVuIHx8IHNoYXBlLmNoaWxkcmVuICE9PSB1bmRlZmluZWQgfHwgc2VsZWN0ZWRJZHMuaW5jbHVkZXMoc2hhcGUuaWQpIHx8IHNlbGVjdGVkSWRzLmluY2x1ZGVzKHNoYXBlLnBhcmVudElkKSk7XG4gIH0pLm1hcChmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHNoYXBlLmlkLFxuICAgICAgdXRpbDogZ2V0U2hhcGVVdGlscyhzaGFwZSksXG4gICAgICBib3VuZHM6IGdldFNoYXBlVXRpbHMoc2hhcGUpLmdldEJvdW5kcyhzaGFwZSksXG4gICAgICBzZWxlY3RJZDogVExEUi5nZXRUb3BQYXJlbnRJZChkYXRhLCBzaGFwZS5pZClcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBzZWxlY3RlZElkczogc2VsZWN0ZWRJZHMsXG4gICAgc2hhcGVzVG9UZXN0OiBzaGFwZXNUb1Rlc3RcbiAgfTtcbn1cblxudmFyIFRyYW5zbGF0ZVNlc3Npb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUcmFuc2xhdGVTZXNzaW9uKF9kYXRhLCBfcG9pbnQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5pZCA9ICd0cmFuc2xhdGUnO1xuICAgIHRoaXMuZGVsdGEgPSBbMCwgMF07XG4gICAgdGhpcy5wcmV2ID0gWzAsIDBdO1xuICAgIHRoaXMub3JpZ2luID0gdm9pZCAwO1xuICAgIHRoaXMuc25hcHNob3QgPSB2b2lkIDA7XG4gICAgdGhpcy5pc0Nsb25pbmcgPSBmYWxzZTtcblxuICAgIHRoaXMuc3RhcnQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuICAgIHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIHBvaW50LCBpc0FsaWduZWQsIGlzQ2xvbmluZykge1xuICAgICAgaWYgKGlzQWxpZ25lZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlzQWxpZ25lZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNDbG9uaW5nID09PSB2b2lkIDApIHtcbiAgICAgICAgaXNDbG9uaW5nID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBfdGhpcyRzbmFwc2hvdCA9IF90aGlzLnNuYXBzaG90LFxuICAgICAgICAgIGNsb25lcyA9IF90aGlzJHNuYXBzaG90LmNsb25lcyxcbiAgICAgICAgICBpbml0aWFsU2hhcGVzID0gX3RoaXMkc25hcHNob3QuaW5pdGlhbFNoYXBlcztcblxuICAgICAgdmFyIG5leHQgPSBfZXh0ZW5kcyh7fSwgZGF0YSwge1xuICAgICAgICBwYWdlOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlKSxcbiAgICAgICAgc2hhcGVzOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlLnNoYXBlcyksXG4gICAgICAgIHBhZ2VTdGF0ZTogX2V4dGVuZHMoe30sIGRhdGEucGFnZVN0YXRlKVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBkZWx0YSA9IGNvcmUuVmVjLnN1Yihwb2ludCwgX3RoaXMub3JpZ2luKTtcblxuICAgICAgaWYgKGlzQWxpZ25lZCkge1xuICAgICAgICBpZiAoTWF0aC5hYnMoZGVsdGFbMF0pIDwgTWF0aC5hYnMoZGVsdGFbMV0pKSB7XG4gICAgICAgICAgZGVsdGFbMF0gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbHRhWzFdID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdHJ1ZURlbHRhID0gY29yZS5WZWMuc3ViKGRlbHRhLCBfdGhpcy5wcmV2KTtcbiAgICAgIF90aGlzLmRlbHRhID0gZGVsdGE7XG4gICAgICBfdGhpcy5wcmV2ID0gZGVsdGE7IC8vIElmIGNsb25pbmcuLi5cblxuICAgICAgaWYgKGlzQ2xvbmluZykge1xuICAgICAgICAvLyBOb3QgQ2xvbmluZyAtPiBDbG9uaW5nXG4gICAgICAgIGlmICghX3RoaXMuaXNDbG9uaW5nKSB7XG4gICAgICAgICAgX3RoaXMuaXNDbG9uaW5nID0gdHJ1ZTsgLy8gTW92ZSBvcmlnaW5hbCBzaGFwZXMgYmFjayB0byBzdGFydFxuXG4gICAgICAgICAgbmV4dC5wYWdlLnNoYXBlcyA9IF9leHRlbmRzKHt9LCBuZXh0LnBhZ2Uuc2hhcGVzLCBPYmplY3QuZnJvbUVudHJpZXMoaW5pdGlhbFNoYXBlcy5tYXAoZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gW3NoYXBlLmlkLCBfZXh0ZW5kcyh7fSwgbmV4dC5wYWdlLnNoYXBlc1tzaGFwZS5pZF0sIHtcbiAgICAgICAgICAgICAgcG9pbnQ6IHNoYXBlLnBvaW50XG4gICAgICAgICAgICB9KV07XG4gICAgICAgICAgfSkpKTtcbiAgICAgICAgICBuZXh0LnBhZ2Uuc2hhcGVzID0gX2V4dGVuZHMoe30sIG5leHQucGFnZS5zaGFwZXMsIE9iamVjdC5mcm9tRW50cmllcyhjbG9uZXMubWFwKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtjbG9uZS5pZCwgX2V4dGVuZHMoe30sIGNsb25lLCB7XG4gICAgICAgICAgICAgIHBvaW50OiBjb3JlLlZlYy5hZGQoY2xvbmUucG9pbnQsIGRlbHRhKVxuICAgICAgICAgICAgfSldO1xuICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgbmV4dC5wYWdlU3RhdGUuc2VsZWN0ZWRJZHMgPSBjbG9uZXMubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4gYy5pZDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBFaXRoZXIgd2F5LCBtb3ZlIHRoZSBjbG9uZXNcblxuXG4gICAgICAgIG5leHQucGFnZS5zaGFwZXMgPSBfZXh0ZW5kcyh7fSwgbmV4dC5wYWdlLnNoYXBlcywgT2JqZWN0LmZyb21FbnRyaWVzKGNsb25lcy5tYXAoZnVuY3Rpb24gKGNsb25lKSB7XG4gICAgICAgICAgcmV0dXJuIFtjbG9uZS5pZCwgX2V4dGVuZHMoe30sIGNsb25lLCB7XG4gICAgICAgICAgICBwb2ludDogY29yZS5WZWMuYWRkKG5leHQucGFnZS5zaGFwZXNbY2xvbmUuaWRdLnBvaW50LCB0cnVlRGVsdGEpXG4gICAgICAgICAgfSldO1xuICAgICAgICB9KSkpO1xuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgIH0gLy8gSWYgbm90IGNsb25pbmcuLi5cbiAgICAgIC8vIENsb25pbmcgLT4gTm90IENsb25pbmdcblxuXG4gICAgICBpZiAoX3RoaXMuaXNDbG9uaW5nKSB7XG4gICAgICAgIF90aGlzLmlzQ2xvbmluZyA9IGZhbHNlOyAvLyBEZWxldGUgdGhlIGNsb25lc1xuXG4gICAgICAgIGNsb25lcy5mb3JFYWNoKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgICAgIHJldHVybiBkZWxldGUgbmV4dC5wYWdlLnNoYXBlc1tjbG9uZS5pZF07XG4gICAgICAgIH0pOyAvLyBNb3ZlIHRoZSBvcmlnaW5hbCBzaGFwZXMgYmFjayB0byB0aGUgY3Vyc29yIHBvc2l0aW9uXG5cbiAgICAgICAgbmV4dC5wYWdlLnNoYXBlcyA9IF9leHRlbmRzKHt9LCBuZXh0LnBhZ2Uuc2hhcGVzLCBPYmplY3QuZnJvbUVudHJpZXMoaW5pdGlhbFNoYXBlcy5tYXAoZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICAgICAgcmV0dXJuIFtzaGFwZS5pZCwgX2V4dGVuZHMoe30sIG5leHQucGFnZS5zaGFwZXNbc2hhcGUuaWRdLCB7XG4gICAgICAgICAgICBwb2ludDogY29yZS5WZWMuYWRkKHNoYXBlLnBvaW50LCBkZWx0YSlcbiAgICAgICAgICB9KV07XG4gICAgICAgIH0pKSk7IC8vIFNldCBzZWxlY3RlZCBpZHNcblxuICAgICAgICBuZXh0LnBhZ2VTdGF0ZS5zZWxlY3RlZElkcyA9IGluaXRpYWxTaGFwZXMubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgcmV0dXJuIGMuaWQ7XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBNb3ZlIHRoZSBzaGFwZXMgYnkgdGhlIGRlbHRhXG5cblxuICAgICAgbmV4dC5wYWdlLnNoYXBlcyA9IF9leHRlbmRzKHt9LCBuZXh0LnBhZ2Uuc2hhcGVzLCBPYmplY3QuZnJvbUVudHJpZXMoaW5pdGlhbFNoYXBlcy5tYXAoZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICAgIHJldHVybiBbc2hhcGUuaWQsIF9leHRlbmRzKHt9LCBuZXh0LnBhZ2Uuc2hhcGVzW3NoYXBlLmlkXSwge1xuICAgICAgICAgIHBvaW50OiBjb3JlLlZlYy5hZGQobmV4dC5wYWdlLnNoYXBlc1tzaGFwZS5pZF0ucG9pbnQsIHRydWVEZWx0YSlcbiAgICAgICAgfSldO1xuICAgICAgfSkpKTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG5cbiAgICB0aGlzLmNhbmNlbCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGRhdGEsIHtcbiAgICAgICAgcGFnZTogX2V4dGVuZHMoe30sIGRhdGEucGFnZSwge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLSBXZSBuZWVkIHRvIHNldCBkZWxldGVkIHNoYXBlcyB0byB1bmRlZmluZWQgaW4gb3JkZXIgdG8gY29ycmVjdGx5IGRlZXAgbWVyZ2UgdGhlbSBhd2F5LlxuICAgICAgICAgIHNoYXBlczogX2V4dGVuZHMoe30sIGRhdGEucGFnZS5zaGFwZXMsIE9iamVjdC5mcm9tRW50cmllcyhfdGhpcy5zbmFwc2hvdC5jbG9uZXMubWFwKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtjbG9uZS5pZCwgdW5kZWZpbmVkXTtcbiAgICAgICAgICB9KSksIE9iamVjdC5mcm9tRW50cmllcyhfdGhpcy5zbmFwc2hvdC5pbml0aWFsU2hhcGVzLm1hcChmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgICAgICAgIHJldHVybiBbc2hhcGUuaWQsIF9leHRlbmRzKHt9LCBkYXRhLnBhZ2Uuc2hhcGVzW3NoYXBlLmlkXSwge1xuICAgICAgICAgICAgICBwb2ludDogc2hhcGUucG9pbnRcbiAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICB9KSkpXG4gICAgICAgIH0pLFxuICAgICAgICBwYWdlU3RhdGU6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2VTdGF0ZSwge1xuICAgICAgICAgIHNlbGVjdGVkSWRzOiBfdGhpcy5zbmFwc2hvdC5zZWxlY3RlZElkc1xuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMub3JpZ2luID0gX3BvaW50O1xuICAgIHRoaXMuc25hcHNob3QgPSBnZXRUcmFuc2xhdGVTbmFwc2hvdChfZGF0YSk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVHJhbnNsYXRlU2Vzc2lvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBsZXRlID0gZnVuY3Rpb24gY29tcGxldGUoZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogJ3RyYW5zbGF0ZScsXG4gICAgICBiZWZvcmU6IF9leHRlbmRzKHt9LCBkYXRhLCB7XG4gICAgICAgIHBhZ2U6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2UsIHtcbiAgICAgICAgICBzaGFwZXM6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2Uuc2hhcGVzLCBPYmplY3QuZnJvbUVudHJpZXModGhpcy5zbmFwc2hvdC5jbG9uZXMubWFwKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtjbG9uZS5pZCwgdW5kZWZpbmVkXTtcbiAgICAgICAgICB9KSksIE9iamVjdC5mcm9tRW50cmllcyh0aGlzLnNuYXBzaG90LmluaXRpYWxTaGFwZXMubWFwKGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtzaGFwZS5pZCwge1xuICAgICAgICAgICAgICBwb2ludDogc2hhcGUucG9pbnRcbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgIH0pKSlcbiAgICAgICAgfSksXG4gICAgICAgIHBhZ2VTdGF0ZTogX2V4dGVuZHMoe30sIGRhdGEucGFnZVN0YXRlLCB7XG4gICAgICAgICAgc2VsZWN0ZWRJZHM6IHRoaXMuc25hcHNob3Quc2VsZWN0ZWRJZHNcbiAgICAgICAgfSlcbiAgICAgIH0pLFxuICAgICAgYWZ0ZXI6IF9leHRlbmRzKHt9LCBkYXRhLCB7XG4gICAgICAgIHBhZ2U6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2UsIHtcbiAgICAgICAgICBzaGFwZXM6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2Uuc2hhcGVzLCBPYmplY3QuZnJvbUVudHJpZXModGhpcy5zbmFwc2hvdC5jbG9uZXMubWFwKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtjbG9uZS5pZCwgZGF0YS5wYWdlLnNoYXBlc1tjbG9uZS5pZF1dO1xuICAgICAgICAgIH0pKSwgT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuc25hcHNob3QuaW5pdGlhbFNoYXBlcy5tYXAoZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gW3NoYXBlLmlkLCB7XG4gICAgICAgICAgICAgIHBvaW50OiBkYXRhLnBhZ2Uuc2hhcGVzW3NoYXBlLmlkXS5wb2ludFxuICAgICAgICAgICAgfV07XG4gICAgICAgICAgfSkpKVxuICAgICAgICB9KSxcbiAgICAgICAgcGFnZVN0YXRlOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlU3RhdGUsIHtcbiAgICAgICAgICBzZWxlY3RlZElkczogW10uY29uY2F0KGRhdGEucGFnZVN0YXRlLnNlbGVjdGVkSWRzKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBUcmFuc2xhdGVTZXNzaW9uO1xufSgpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuXG5mdW5jdGlvbiBnZXRUcmFuc2xhdGVTbmFwc2hvdChkYXRhKSB7XG4gIHZhciBzZWxlY3RlZFNoYXBlcyA9IFRMRFIuZ2V0U2VsZWN0ZWRTaGFwZVNuYXBzaG90KGRhdGEpO1xuICB2YXIgaGFzVW5sb2NrZWRTaGFwZXMgPSBzZWxlY3RlZFNoYXBlcy5sZW5ndGggPiAwO1xuICB2YXIgaW5pdGlhbFBhcmVudHMgPSBBcnJheS5mcm9tKG5ldyBTZXQoc2VsZWN0ZWRTaGFwZXMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHMucGFyZW50SWQ7XG4gIH0pKS52YWx1ZXMoKSkuZmlsdGVyKGZ1bmN0aW9uIChpZCkge1xuICAgIHJldHVybiBpZCAhPT0gZGF0YS5wYWdlLmlkO1xuICB9KS5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIHNoYXBlID0gVExEUi5nZXRTaGFwZShkYXRhLCBpZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGNoaWxkcmVuOiBzaGFwZS5jaGlsZHJlblxuICAgIH07XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHNlbGVjdGVkSWRzOiBUTERSLmdldFNlbGVjdGVkSWRzKGRhdGEpLFxuICAgIGhhc1VubG9ja2VkU2hhcGVzOiBoYXNVbmxvY2tlZFNoYXBlcyxcbiAgICBpbml0aWFsUGFyZW50czogaW5pdGlhbFBhcmVudHMsXG4gICAgaW5pdGlhbFNoYXBlczogc2VsZWN0ZWRTaGFwZXMubWFwKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgaWQgPSBfcmVmLmlkLFxuICAgICAgICAgIHBvaW50ID0gX3JlZi5wb2ludCxcbiAgICAgICAgICBwYXJlbnRJZCA9IF9yZWYucGFyZW50SWQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgcGFyZW50SWQ6IHBhcmVudElkXG4gICAgICB9O1xuICAgIH0pLFxuICAgIGNsb25lczogc2VsZWN0ZWRTaGFwZXMuZmlsdGVyKGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgcmV0dXJuIHNoYXBlLmNoaWxkcmVuID09PSB1bmRlZmluZWQ7XG4gICAgfSkuZmxhdE1hcChmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgIHZhciBjbG9uZSA9IF9leHRlbmRzKHt9LCBzaGFwZSwge1xuICAgICAgICBpZDogY29yZS5VdGlscy51bmlxdWVJZCgpLFxuICAgICAgICBwYXJlbnRJZDogc2hhcGUucGFyZW50SWQsXG4gICAgICAgIGNoaWxkSW5kZXg6IFRMRFIuZ2V0Q2hpbGRJbmRleEFib3ZlKGRhdGEsIHNoYXBlLmlkKVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9KVxuICB9O1xufVxuXG52YXIgVHJhbnNmb3JtU2luZ2xlU2Vzc2lvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRyYW5zZm9ybVNpbmdsZVNlc3Npb24oX2RhdGEsIF9wb2ludCwgX3RyYW5zZm9ybVR5cGUsIGNvbW1hbmRJZCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoX3RyYW5zZm9ybVR5cGUgPT09IHZvaWQgMCkge1xuICAgICAgX3RyYW5zZm9ybVR5cGUgPSBjb3JlLlRMQm91bmRzQ29ybmVyLkJvdHRvbVJpZ2h0O1xuICAgIH1cblxuICAgIGlmIChjb21tYW5kSWQgPT09IHZvaWQgMCkge1xuICAgICAgY29tbWFuZElkID0gJ3RyYW5zZm9ybV9zaW5nbGUnO1xuICAgIH1cblxuICAgIHRoaXMuaWQgPSAndHJhbnNmb3JtX3NpbmdsZSc7XG4gICAgdGhpcy5jb21tYW5kSWQgPSB2b2lkIDA7XG4gICAgdGhpcy50cmFuc2Zvcm1UeXBlID0gdm9pZCAwO1xuICAgIHRoaXMub3JpZ2luID0gdm9pZCAwO1xuICAgIHRoaXMuc2NhbGVYID0gMTtcbiAgICB0aGlzLnNjYWxlWSA9IDE7XG4gICAgdGhpcy5zbmFwc2hvdCA9IHZvaWQgMDtcblxuICAgIHRoaXMuc3RhcnQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuICAgIHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIHBvaW50LCBpc0FzcGVjdFJhdGlvTG9ja2VkKSB7XG4gICAgICB2YXIgX2V4dGVuZHMyO1xuXG4gICAgICBpZiAoaXNBc3BlY3RSYXRpb0xvY2tlZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlzQXNwZWN0UmF0aW9Mb2NrZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRyYW5zZm9ybVR5cGUgPSBfdGhpcy50cmFuc2Zvcm1UeXBlO1xuICAgICAgdmFyIF90aGlzJHNuYXBzaG90ID0gX3RoaXMuc25hcHNob3QsXG4gICAgICAgICAgaW5pdGlhbFNoYXBlQm91bmRzID0gX3RoaXMkc25hcHNob3QuaW5pdGlhbFNoYXBlQm91bmRzLFxuICAgICAgICAgIGluaXRpYWxTaGFwZSA9IF90aGlzJHNuYXBzaG90LmluaXRpYWxTaGFwZSxcbiAgICAgICAgICBpZCA9IF90aGlzJHNuYXBzaG90LmlkO1xuICAgICAgdmFyIHNoYXBlID0gZGF0YS5wYWdlLnNoYXBlc1tpZF07XG4gICAgICB2YXIgdXRpbHMgPSBUTERSLmdldFNoYXBlVXRpbHMoc2hhcGUpO1xuICAgICAgdmFyIG5ld0JvdW5kcyA9IGNvcmUuVXRpbHMuZ2V0VHJhbnNmb3JtZWRCb3VuZGluZ0JveChpbml0aWFsU2hhcGVCb3VuZHMsIHRyYW5zZm9ybVR5cGUsIGNvcmUuVmVjLnN1Yihwb2ludCwgX3RoaXMub3JpZ2luKSwgc2hhcGUucm90YXRpb24sIGlzQXNwZWN0UmF0aW9Mb2NrZWQgfHwgc2hhcGUuaXNBc3BlY3RSYXRpb0xvY2tlZCB8fCB1dGlscy5pc0FzcGVjdFJhdGlvTG9ja2VkKTtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgZGF0YSwge1xuICAgICAgICBwYWdlOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlLCB7XG4gICAgICAgICAgc2hhcGVzOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlLnNoYXBlcywgKF9leHRlbmRzMiA9IHt9LCBfZXh0ZW5kczJbc2hhcGUuaWRdID0gX2V4dGVuZHMoe30sIGluaXRpYWxTaGFwZSwgVExEUi5nZXRTaGFwZVV0aWxzKHNoYXBlKS50cmFuc2Zvcm1TaW5nbGUoc2hhcGUsIG5ld0JvdW5kcywge1xuICAgICAgICAgICAgaW5pdGlhbFNoYXBlOiBpbml0aWFsU2hhcGUsXG4gICAgICAgICAgICB0eXBlOiBfdGhpcy50cmFuc2Zvcm1UeXBlLFxuICAgICAgICAgICAgc2NhbGVYOiBuZXdCb3VuZHMuc2NhbGVYLFxuICAgICAgICAgICAgc2NhbGVZOiBuZXdCb3VuZHMuc2NhbGVZLFxuICAgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiBbMC41LCAwLjVdXG4gICAgICAgICAgfSkpLCBfZXh0ZW5kczIpKVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMuY2FuY2VsID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHZhciBfZXh0ZW5kczM7XG5cbiAgICAgIHZhciBfdGhpcyRzbmFwc2hvdDIgPSBfdGhpcy5zbmFwc2hvdCxcbiAgICAgICAgICBpZCA9IF90aGlzJHNuYXBzaG90Mi5pZCxcbiAgICAgICAgICBpbml0aWFsU2hhcGUgPSBfdGhpcyRzbmFwc2hvdDIuaW5pdGlhbFNoYXBlO1xuICAgICAgZGF0YS5wYWdlLnNoYXBlc1tpZF0gPSBpbml0aWFsU2hhcGU7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGRhdGEsIHtcbiAgICAgICAgcGFnZTogX2V4dGVuZHMoe30sIGRhdGEucGFnZSwge1xuICAgICAgICAgIHNoYXBlczogX2V4dGVuZHMoe30sIGRhdGEucGFnZS5zaGFwZXMsIChfZXh0ZW5kczMgPSB7fSwgX2V4dGVuZHMzW2lkXSA9IGluaXRpYWxTaGFwZSwgX2V4dGVuZHMzKSlcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLm9yaWdpbiA9IF9wb2ludDtcbiAgICB0aGlzLnRyYW5zZm9ybVR5cGUgPSBfdHJhbnNmb3JtVHlwZTtcbiAgICB0aGlzLnNuYXBzaG90ID0gZ2V0VHJhbnNmb3JtU2luZ2xlU25hcHNob3QoX2RhdGEsIF90cmFuc2Zvcm1UeXBlKTtcbiAgICB0aGlzLmNvbW1hbmRJZCA9IGNvbW1hbmRJZDtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBUcmFuc2Zvcm1TaW5nbGVTZXNzaW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uY29tcGxldGUgPSBmdW5jdGlvbiBjb21wbGV0ZShkYXRhKSB7XG4gICAgdmFyIF9zaGFwZXMsIF9zaGFwZXMyO1xuXG4gICAgaWYgKCF0aGlzLnNuYXBzaG90Lmhhc1VubG9ja2VkU2hhcGUpIHJldHVybiBkYXRhO1xuICAgIHJldHVybiB7XG4gICAgICBpZDogdGhpcy5jb21tYW5kSWQsXG4gICAgICBiZWZvcmU6IHtcbiAgICAgICAgcGFnZToge1xuICAgICAgICAgIHNoYXBlczogKF9zaGFwZXMgPSB7fSwgX3NoYXBlc1t0aGlzLnNuYXBzaG90LmlkXSA9IHRoaXMuc25hcHNob3QuaW5pdGlhbFNoYXBlLCBfc2hhcGVzKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYWZ0ZXI6IHtcbiAgICAgICAgcGFnZToge1xuICAgICAgICAgIHNoYXBlczogKF9zaGFwZXMyID0ge30sIF9zaGFwZXMyW3RoaXMuc25hcHNob3QuaWRdID0gVExEUi5vblNlc3Npb25Db21wbGV0ZShkYXRhLCBkYXRhLnBhZ2Uuc2hhcGVzW3RoaXMuc25hcHNob3QuaWRdKSwgX3NoYXBlczIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBUcmFuc2Zvcm1TaW5nbGVTZXNzaW9uO1xufSgpO1xuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtU2luZ2xlU25hcHNob3QoZGF0YSwgdHJhbnNmb3JtVHlwZSkge1xuICB2YXIgc2hhcGUgPSBkYXRhLnBhZ2Uuc2hhcGVzW2RhdGEucGFnZVN0YXRlLnNlbGVjdGVkSWRzWzBdXTtcblxuICBpZiAoIXNoYXBlKSB7XG4gICAgdGhyb3cgRXJyb3IoJ1lvdSBtdXN0IGhhdmUgb25lIHNoYXBlIHNlbGVjdGVkLicpO1xuICB9XG5cbiAgdmFyIGJvdW5kcyA9IFRMRFIuZ2V0Qm91bmRzKHNoYXBlKTtcbiAgcmV0dXJuIHtcbiAgICBpZDogc2hhcGUuaWQsXG4gICAgaGFzVW5sb2NrZWRTaGFwZTogIXNoYXBlLmlzTG9ja2VkLFxuICAgIHR5cGU6IHRyYW5zZm9ybVR5cGUsXG4gICAgaW5pdGlhbFNoYXBlOiBjb3JlLlV0aWxzLmRlZXBDbG9uZShzaGFwZSksXG4gICAgaW5pdGlhbFNoYXBlQm91bmRzOiBib3VuZHNcbiAgfTtcbn1cblxudmFyIFRyYW5zZm9ybVNlc3Npb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUcmFuc2Zvcm1TZXNzaW9uKF9kYXRhLCBfcG9pbnQsIF90cmFuc2Zvcm1UeXBlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmIChfdHJhbnNmb3JtVHlwZSA9PT0gdm9pZCAwKSB7XG4gICAgICBfdHJhbnNmb3JtVHlwZSA9IGNvcmUuVExCb3VuZHNDb3JuZXIuQm90dG9tUmlnaHQ7XG4gICAgfVxuXG4gICAgdGhpcy5pZCA9ICd0cmFuc2Zvcm0nO1xuICAgIHRoaXMuc2NhbGVYID0gMTtcbiAgICB0aGlzLnNjYWxlWSA9IDE7XG4gICAgdGhpcy50cmFuc2Zvcm1UeXBlID0gdm9pZCAwO1xuICAgIHRoaXMub3JpZ2luID0gdm9pZCAwO1xuICAgIHRoaXMuc25hcHNob3QgPSB2b2lkIDA7XG5cbiAgICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICB0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBwb2ludCwgaXNBc3BlY3RSYXRpb0xvY2tlZCwgX2FsdEtleSkge1xuICAgICAgaWYgKGlzQXNwZWN0UmF0aW9Mb2NrZWQgPT09IHZvaWQgMCkge1xuICAgICAgICBpc0FzcGVjdFJhdGlvTG9ja2VkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciB0cmFuc2Zvcm1UeXBlID0gX3RoaXMudHJhbnNmb3JtVHlwZSxcbiAgICAgICAgICBfdGhpcyRzbmFwc2hvdCA9IF90aGlzLnNuYXBzaG90LFxuICAgICAgICAgIHNoYXBlQm91bmRzID0gX3RoaXMkc25hcHNob3Quc2hhcGVCb3VuZHMsXG4gICAgICAgICAgaW5pdGlhbEJvdW5kcyA9IF90aGlzJHNuYXBzaG90LmluaXRpYWxCb3VuZHMsXG4gICAgICAgICAgaXNBbGxBc3BlY3RSYXRpb0xvY2tlZCA9IF90aGlzJHNuYXBzaG90LmlzQWxsQXNwZWN0UmF0aW9Mb2NrZWQ7XG5cbiAgICAgIHZhciBuZXh0ID0gX2V4dGVuZHMoe30sIGRhdGEsIHtcbiAgICAgICAgcGFnZTogX2V4dGVuZHMoe30sIGRhdGEucGFnZSlcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgc2hhcGVzID0gbmV4dC5wYWdlLnNoYXBlcztcbiAgICAgIHZhciBuZXdCb3VuZGluZ0JveCA9IGNvcmUuVXRpbHMuZ2V0VHJhbnNmb3JtZWRCb3VuZGluZ0JveChpbml0aWFsQm91bmRzLCB0cmFuc2Zvcm1UeXBlLCBjb3JlLlZlYy52ZWMoX3RoaXMub3JpZ2luLCBwb2ludCksIGRhdGEucGFnZVN0YXRlLmJvdW5kc1JvdGF0aW9uLCBpc0FzcGVjdFJhdGlvTG9ja2VkIHx8IGlzQWxsQXNwZWN0UmF0aW9Mb2NrZWQpOyAvLyBOb3cgd29yayBiYWNrd2FyZCB0byBjYWxjdWxhdGUgYSBuZXcgYm91bmRpbmcgYm94IGZvciBlYWNoIG9mIHRoZSBzaGFwZXMuXG5cbiAgICAgIF90aGlzLnNjYWxlWCA9IG5ld0JvdW5kaW5nQm94LnNjYWxlWDtcbiAgICAgIF90aGlzLnNjYWxlWSA9IG5ld0JvdW5kaW5nQm94LnNjYWxlWTtcbiAgICAgIG5leHQucGFnZS5zaGFwZXMgPSBfZXh0ZW5kcyh7fSwgbmV4dC5wYWdlLnNoYXBlcywgT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHNoYXBlQm91bmRzKS5tYXAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIGlkID0gX3JlZlswXSxcbiAgICAgICAgICAgIF9yZWYkID0gX3JlZlsxXSxcbiAgICAgICAgICAgIGluaXRpYWxTaGFwZSA9IF9yZWYkLmluaXRpYWxTaGFwZSxcbiAgICAgICAgICAgIGluaXRpYWxTaGFwZUJvdW5kcyA9IF9yZWYkLmluaXRpYWxTaGFwZUJvdW5kcyxcbiAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbiA9IF9yZWYkLnRyYW5zZm9ybU9yaWdpbjtcbiAgICAgICAgdmFyIG5ld1NoYXBlQm91bmRzID0gY29yZS5VdGlscy5nZXRSZWxhdGl2ZVRyYW5zZm9ybWVkQm91bmRpbmdCb3gobmV3Qm91bmRpbmdCb3gsIGluaXRpYWxCb3VuZHMsIGluaXRpYWxTaGFwZUJvdW5kcywgX3RoaXMuc2NhbGVYIDwgMCwgX3RoaXMuc2NhbGVZIDwgMCk7XG4gICAgICAgIHZhciBzaGFwZSA9IHNoYXBlc1tpZF07XG4gICAgICAgIHJldHVybiBbaWQsIF9leHRlbmRzKHt9LCBpbml0aWFsU2hhcGUsIFRMRFIudHJhbnNmb3JtKG5leHQsIHNoYXBlLCBuZXdTaGFwZUJvdW5kcywge1xuICAgICAgICAgIHR5cGU6IF90aGlzLnRyYW5zZm9ybVR5cGUsXG4gICAgICAgICAgaW5pdGlhbFNoYXBlOiBpbml0aWFsU2hhcGUsXG4gICAgICAgICAgc2NhbGVYOiBfdGhpcy5zY2FsZVgsXG4gICAgICAgICAgc2NhbGVZOiBfdGhpcy5zY2FsZVksXG4gICAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiB0cmFuc2Zvcm1PcmlnaW5cbiAgICAgICAgfSkpXTtcbiAgICAgIH0pKSk7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuXG4gICAgdGhpcy5jYW5jZWwgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdmFyIHNoYXBlQm91bmRzID0gX3RoaXMuc25hcHNob3Quc2hhcGVCb3VuZHM7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGRhdGEsIHtcbiAgICAgICAgcGFnZTogX2V4dGVuZHMoe30sIGRhdGEucGFnZSwge1xuICAgICAgICAgIHNoYXBlczogX2V4dGVuZHMoe30sIGRhdGEucGFnZS5zaGFwZXMsIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhzaGFwZUJvdW5kcykubWFwKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICAgICAgdmFyIGlkID0gX3JlZjJbMF0sXG4gICAgICAgICAgICAgICAgaW5pdGlhbFNoYXBlID0gX3JlZjJbMV0uaW5pdGlhbFNoYXBlO1xuICAgICAgICAgICAgcmV0dXJuIFtpZCwgaW5pdGlhbFNoYXBlXTtcbiAgICAgICAgICB9KSkpXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5vcmlnaW4gPSBfcG9pbnQ7XG4gICAgdGhpcy50cmFuc2Zvcm1UeXBlID0gX3RyYW5zZm9ybVR5cGU7XG4gICAgdGhpcy5zbmFwc2hvdCA9IGdldFRyYW5zZm9ybVNuYXBzaG90KF9kYXRhLCBfdHJhbnNmb3JtVHlwZSk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVHJhbnNmb3JtU2Vzc2lvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBsZXRlID0gZnVuY3Rpb24gY29tcGxldGUoZGF0YSkge1xuICAgIHZhciBfdGhpcyRzbmFwc2hvdDIgPSB0aGlzLnNuYXBzaG90LFxuICAgICAgICBoYXNVbmxvY2tlZFNoYXBlcyA9IF90aGlzJHNuYXBzaG90Mi5oYXNVbmxvY2tlZFNoYXBlcyxcbiAgICAgICAgc2hhcGVCb3VuZHMgPSBfdGhpcyRzbmFwc2hvdDIuc2hhcGVCb3VuZHM7XG4gICAgaWYgKCFoYXNVbmxvY2tlZFNoYXBlcykgcmV0dXJuIGRhdGE7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiAndHJhbnNmb3JtJyxcbiAgICAgIGJlZm9yZToge1xuICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgc2hhcGVzOiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoc2hhcGVCb3VuZHMpLm1hcChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IF9yZWYzWzBdLFxuICAgICAgICAgICAgICAgIGluaXRpYWxTaGFwZSA9IF9yZWYzWzFdLmluaXRpYWxTaGFwZTtcbiAgICAgICAgICAgIHJldHVybiBbaWQsIGluaXRpYWxTaGFwZV07XG4gICAgICAgICAgfSkpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhZnRlcjoge1xuICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgc2hhcGVzOiBPYmplY3QuZnJvbUVudHJpZXModGhpcy5zbmFwc2hvdC5pbml0aWFsU2hhcGVzLm1hcChmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgICAgICAgIHJldHVybiBbc2hhcGUuaWQsIFRMRFIub25TZXNzaW9uQ29tcGxldGUoZGF0YSwgZGF0YS5wYWdlLnNoYXBlc1tzaGFwZS5pZF0pXTtcbiAgICAgICAgICB9KSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIFRyYW5zZm9ybVNlc3Npb247XG59KCk7XG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1TbmFwc2hvdChkYXRhLCB0cmFuc2Zvcm1UeXBlKSB7XG4gIHZhciBpbml0aWFsU2hhcGVzID0gVExEUi5nZXRTZWxlY3RlZEJyYW5jaFNuYXBzaG90KGRhdGEpO1xuICB2YXIgaGFzVW5sb2NrZWRTaGFwZXMgPSBpbml0aWFsU2hhcGVzLmxlbmd0aCA+IDA7XG4gIHZhciBpc0FsbEFzcGVjdFJhdGlvTG9ja2VkID0gaW5pdGlhbFNoYXBlcy5ldmVyeShmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICByZXR1cm4gc2hhcGUuaXNBc3BlY3RSYXRpb0xvY2tlZCB8fCBUTERSLmdldFNoYXBlVXRpbHMoc2hhcGUpLmlzQXNwZWN0UmF0aW9Mb2NrZWQ7XG4gIH0pO1xuICB2YXIgc2hhcGVzQm91bmRzID0gT2JqZWN0LmZyb21FbnRyaWVzKGluaXRpYWxTaGFwZXMubWFwKGZ1bmN0aW9uIChzaGFwZSkge1xuICAgIHJldHVybiBbc2hhcGUuaWQsIFRMRFIuZ2V0Qm91bmRzKHNoYXBlKV07XG4gIH0pKTtcbiAgdmFyIGJvdW5kc0FyciA9IE9iamVjdC52YWx1ZXMoc2hhcGVzQm91bmRzKTtcbiAgdmFyIGNvbW1vbkJvdW5kcyA9IGNvcmUuVXRpbHMuZ2V0Q29tbW9uQm91bmRzKGJvdW5kc0Fycik7XG4gIHZhciBpbml0aWFsSW5uZXJCb3VuZHMgPSBjb3JlLlV0aWxzLmdldEJvdW5kc0Zyb21Qb2ludHMoYm91bmRzQXJyLm1hcChjb3JlLlV0aWxzLmdldEJvdW5kc0NlbnRlcikpOyAvLyBSZXR1cm4gYSBtYXBwaW5nIG9mIHNoYXBlcyB0byBib3VuZHMgdG9nZXRoZXIgd2l0aCB0aGUgcmVsYXRpdmVcbiAgLy8gcG9zaXRpb25zIG9mIHRoZSBzaGFwZSdzIGJvdW5kcyB3aXRoaW4gdGhlIGNvbW1vbiBib3VuZHMgc2hhcGUuXG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0cmFuc2Zvcm1UeXBlLFxuICAgIGhhc1VubG9ja2VkU2hhcGVzOiBoYXNVbmxvY2tlZFNoYXBlcyxcbiAgICBpc0FsbEFzcGVjdFJhdGlvTG9ja2VkOiBpc0FsbEFzcGVjdFJhdGlvTG9ja2VkLFxuICAgIGluaXRpYWxTaGFwZXM6IGluaXRpYWxTaGFwZXMsXG4gICAgaW5pdGlhbEJvdW5kczogY29tbW9uQm91bmRzLFxuICAgIHNoYXBlQm91bmRzOiBPYmplY3QuZnJvbUVudHJpZXMoaW5pdGlhbFNoYXBlcy5tYXAoZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICB2YXIgaW5pdGlhbFNoYXBlQm91bmRzID0gc2hhcGVzQm91bmRzW3NoYXBlLmlkXTtcbiAgICAgIHZhciBpYyA9IGNvcmUuVXRpbHMuZ2V0Qm91bmRzQ2VudGVyKGluaXRpYWxTaGFwZUJvdW5kcyk7XG4gICAgICB2YXIgaXggPSAoaWNbMF0gLSBpbml0aWFsSW5uZXJCb3VuZHMubWluWCkgLyBpbml0aWFsSW5uZXJCb3VuZHMud2lkdGg7XG4gICAgICB2YXIgaXkgPSAoaWNbMV0gLSBpbml0aWFsSW5uZXJCb3VuZHMubWluWSkgLyBpbml0aWFsSW5uZXJCb3VuZHMuaGVpZ2h0O1xuICAgICAgcmV0dXJuIFtzaGFwZS5pZCwge1xuICAgICAgICBpbml0aWFsU2hhcGU6IHNoYXBlLFxuICAgICAgICBpbml0aWFsU2hhcGVCb3VuZHM6IGluaXRpYWxTaGFwZUJvdW5kcyxcbiAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiBbaXgsIGl5XVxuICAgICAgfV07XG4gICAgfSkpXG4gIH07XG59XG5cbnZhciBEcmF3U2Vzc2lvbiA9IGZ1bmN0aW9uIERyYXdTZXNzaW9uKF9kYXRhLCBpZCwgX3BvaW50KSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5pZCA9ICdkcmF3JztcbiAgdGhpcy5vcmlnaW4gPSB2b2lkIDA7XG4gIHRoaXMucHJldmlvdXMgPSB2b2lkIDA7XG4gIHRoaXMubGFzdCA9IHZvaWQgMDtcbiAgdGhpcy5wb2ludHMgPSB2b2lkIDA7XG4gIHRoaXMuc25hcHNob3QgPSB2b2lkIDA7XG4gIHRoaXMuaXNMb2NrZWQgPSB2b2lkIDA7XG4gIHRoaXMubG9ja2VkRGlyZWN0aW9uID0gdm9pZCAwO1xuXG4gIHRoaXMuc3RhcnQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9O1xuXG4gIHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIHBvaW50LCBwcmVzc3VyZSwgaXNMb2NrZWQpIHtcbiAgICB2YXIgX2V4dGVuZHMyO1xuXG4gICAgaWYgKGlzTG9ja2VkID09PSB2b2lkIDApIHtcbiAgICAgIGlzTG9ja2VkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHNuYXBzaG90ID0gX3RoaXMuc25hcHNob3Q7IC8vIERyYXdpbmcgd2hpbGUgaG9sZGluZyBzaGlmdCB3aWxsIFwibG9ja1wiIHRoZSBwZW4gdG8gZWl0aGVyIHRoZVxuICAgIC8vIHggb3IgeSBheGlzLCBkZXBlbmRpbmcgb24gd2hpY2ggZGlyZWN0aW9uIGhhcyB0aGUgZ3JlYXRlclxuICAgIC8vIGRlbHRhLiBQcmVzc2luZyBzaGlmdCB3aWxsIGFsc28gYWRkIG1vcmUgcG9pbnRzIHRvIFwicmV0dXJuXCJcbiAgICAvLyB0aGUgcGVuIHRvIHRoZSBheGlzLlxuXG4gICAgaWYgKGlzTG9ja2VkKSB7XG4gICAgICBpZiAoIV90aGlzLmlzTG9ja2VkICYmIF90aGlzLnBvaW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBib3VuZHMgPSBjb3JlLlV0aWxzLmdldEJvdW5kc0Zyb21Qb2ludHMoX3RoaXMucG9pbnRzKTtcblxuICAgICAgICBpZiAoYm91bmRzLndpZHRoID4gOCB8fCBib3VuZHMuaGVpZ2h0ID4gOCkge1xuICAgICAgICAgIF90aGlzLmlzTG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgcmV0dXJuaW5nID0gW10uY29uY2F0KF90aGlzLnByZXZpb3VzKTtcbiAgICAgICAgICB2YXIgaXNWZXJ0aWNhbCA9IGJvdW5kcy5oZWlnaHQgPiA4O1xuXG4gICAgICAgICAgaWYgKGlzVmVydGljYWwpIHtcbiAgICAgICAgICAgIF90aGlzLmxvY2tlZERpcmVjdGlvbiA9ICd2ZXJ0aWNhbCc7XG4gICAgICAgICAgICByZXR1cm5pbmdbMF0gPSBfdGhpcy5vcmlnaW5bMF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLmxvY2tlZERpcmVjdGlvbiA9ICdob3Jpem9udGFsJztcbiAgICAgICAgICAgIHJldHVybmluZ1sxXSA9IF90aGlzLm9yaWdpblsxXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpcy5wcmV2aW91cyA9IHJldHVybmluZztcblxuICAgICAgICAgIF90aGlzLnBvaW50cy5wdXNoKGNvcmUuVmVjLnN1YihyZXR1cm5pbmcsIF90aGlzLm9yaWdpbikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfdGhpcy5pc0xvY2tlZCkge1xuICAgICAgX3RoaXMuaXNMb2NrZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoX3RoaXMuaXNMb2NrZWQpIHtcbiAgICAgIGlmIChfdGhpcy5sb2NrZWREaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgcG9pbnRbMF0gPSBfdGhpcy5vcmlnaW5bMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb2ludFsxXSA9IF90aGlzLm9yaWdpblsxXTtcbiAgICAgIH1cbiAgICB9IC8vIExvdyBwYXNzIHRoZSBjdXJyZW50IGlucHV0IHBvaW50IGFnYWluc3QgdGhlIHByZXZpb3VzIG9uZVxuXG5cbiAgICB2YXIgbmV4dFByZXYgPSBjb3JlLlZlYy5tZWQoX3RoaXMucHJldmlvdXMsIHBvaW50KTtcbiAgICBfdGhpcy5wcmV2aW91cyA9IG5leHRQcmV2OyAvLyBEb24ndCBhZGQgZHVwbGljYXRlIHBvaW50cy4gSXQncyBpbXBvcnRhbnQgdG8gdGVzdCBhZ2FpbnN0IHRoZVxuICAgIC8vIGFkanVzdGVkIChsb3ctcGFzc2VkKSBwb2ludCByYXRoZXIgdGhhbiB0aGUgaW5wdXQgcG9pbnQuXG5cbiAgICB2YXIgbmV3UG9pbnQgPSBjb3JlLlZlYy5yb3VuZChbXS5jb25jYXQoY29yZS5WZWMuc3ViKF90aGlzLnByZXZpb3VzLCBfdGhpcy5vcmlnaW4pLCBbcHJlc3N1cmVdKSk7XG4gICAgaWYgKGNvcmUuVmVjLmlzRXF1YWwoX3RoaXMubGFzdCwgbmV3UG9pbnQpKSByZXR1cm4gZGF0YTtcbiAgICBfdGhpcy5sYXN0ID0gbmV3UG9pbnQ7XG5cbiAgICBfdGhpcy5wb2ludHMucHVzaChuZXdQb2ludCk7IC8vIFdlIGRyYXcgYSBkb3Qgd2hlbiB0aGUgbnVtYmVyIG9mIHBvaW50cyBpcyAxIG9yIDIsIHNvIHRoaXMgZ3VhcmRcbiAgICAvLyBwcmV2ZW50cyBhIFwiZmxhc2hcIiBvZiBhIGRvdCB3aGVuIGEgdXNlciBiZWdpbnMgZHJhd2luZyBhIGxpbmUuXG5cblxuICAgIGlmIChfdGhpcy5wb2ludHMubGVuZ3RoIDw9IDIpIHJldHVybiBkYXRhO1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgZGF0YSwge1xuICAgICAgcGFnZTogX2V4dGVuZHMoe30sIGRhdGEucGFnZSwge1xuICAgICAgICBzaGFwZXM6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2Uuc2hhcGVzLCAoX2V4dGVuZHMyID0ge30sIF9leHRlbmRzMltzbmFwc2hvdC5pZF0gPSBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlLnNoYXBlc1tzbmFwc2hvdC5pZF0sIHtcbiAgICAgICAgICBwb2ludHM6IFtdLmNvbmNhdChfdGhpcy5wb2ludHMpXG4gICAgICAgIH0pLCBfZXh0ZW5kczIpKVxuICAgICAgfSksXG4gICAgICBwYWdlU3RhdGU6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2VTdGF0ZSwge1xuICAgICAgICBzZWxlY3RlZElkczogW3NuYXBzaG90LmlkXVxuICAgICAgfSlcbiAgICB9KTtcbiAgfTtcblxuICB0aGlzLmNhbmNlbCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIF9leHRlbmRzMztcblxuICAgIHZhciBzbmFwc2hvdCA9IF90aGlzLnNuYXBzaG90O1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgZGF0YSwge1xuICAgICAgcGFnZTogX2V4dGVuZHMoe30sIGRhdGEucGFnZSwge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHNoYXBlczogX2V4dGVuZHMoe30sIGRhdGEucGFnZS5zaGFwZXMsIChfZXh0ZW5kczMgPSB7fSwgX2V4dGVuZHMzW3NuYXBzaG90LmlkXSA9IHVuZGVmaW5lZCwgX2V4dGVuZHMzKSlcbiAgICAgIH0pLFxuICAgICAgcGFnZVN0YXRlOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlU3RhdGUsIHtcbiAgICAgICAgc2VsZWN0ZWRJZHM6IFtdXG4gICAgICB9KVxuICAgIH0pO1xuICB9O1xuXG4gIHRoaXMuY29tcGxldGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBfc2hhcGVzLCBfc2hhcGVzMjtcblxuICAgIHZhciBzbmFwc2hvdCA9IF90aGlzLnNuYXBzaG90O1xuICAgIHJldHVybiB7XG4gICAgICBpZDogJ2NyZWF0ZV9kcmF3JyxcbiAgICAgIGJlZm9yZToge1xuICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgc2hhcGVzOiAoX3NoYXBlcyA9IHt9LCBfc2hhcGVzW3NuYXBzaG90LmlkXSA9IHVuZGVmaW5lZCwgX3NoYXBlcylcbiAgICAgICAgfSxcbiAgICAgICAgcGFnZVN0YXRlOiB7XG4gICAgICAgICAgc2VsZWN0ZWRJZHM6IFtdXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhZnRlcjoge1xuICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgc2hhcGVzOiAoX3NoYXBlczIgPSB7fSwgX3NoYXBlczJbc25hcHNob3QuaWRdID0gVExEUi5vblNlc3Npb25Db21wbGV0ZShkYXRhLCBkYXRhLnBhZ2Uuc2hhcGVzW3NuYXBzaG90LmlkXSksIF9zaGFwZXMyKVxuICAgICAgICB9LFxuICAgICAgICBwYWdlU3RhdGU6IHtcbiAgICAgICAgICBzZWxlY3RlZElkczogW11cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgdGhpcy5vcmlnaW4gPSBfcG9pbnQ7XG4gIHRoaXMucHJldmlvdXMgPSBfcG9pbnQ7XG4gIHRoaXMubGFzdCA9IF9wb2ludDtcbiAgdGhpcy5zbmFwc2hvdCA9IGdldERyYXdTbmFwc2hvdChfZGF0YSwgaWQpOyAvLyBBZGQgYSBmaXJzdCBwb2ludCBidXQgZG9uJ3QgdXBkYXRlIHRoZSBzaGFwZSB5ZXQuIFdlJ2xsIHVwZGF0ZVxuICAvLyB3aGVuIHRoZSBkcmF3IHNlc3Npb24gZW5kczsgaWYgdGhlIHVzZXIgaGFzbid0IGFkZGVkIGFkZGl0aW9uYWxcbiAgLy8gcG9pbnRzLCB0aGlzIHNpbmdsZSBwb2ludCB3aWxsIGJlIGludGVycHJldGVkIGFzIGEgXCJkb3RcIiBzaGFwZS5cblxuICB0aGlzLnBvaW50cyA9IFtbMCwgMCwgMC41XV07XG59OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuXG5mdW5jdGlvbiBnZXREcmF3U25hcHNob3QoZGF0YSwgc2hhcGVJZCkge1xuICB2YXIgcGFnZSA9IGRhdGEucGFnZTtcblxuICB2YXIgX1V0aWxzJGRlZXBDbG9uZSA9IGNvcmUuVXRpbHMuZGVlcENsb25lKHBhZ2Uuc2hhcGVzW3NoYXBlSWRdKSxcbiAgICAgIHBvaW50cyA9IF9VdGlscyRkZWVwQ2xvbmUucG9pbnRzLFxuICAgICAgcG9pbnQgPSBfVXRpbHMkZGVlcENsb25lLnBvaW50O1xuXG4gIHJldHVybiB7XG4gICAgaWQ6IHNoYXBlSWQsXG4gICAgcG9pbnQ6IHBvaW50LFxuICAgIHBvaW50czogcG9pbnRzXG4gIH07XG59XG5cbnZhciBQSTIkMSA9IE1hdGguUEkgKiAyO1xudmFyIFJvdGF0ZVNlc3Npb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSb3RhdGVTZXNzaW9uKF9kYXRhLCBfcG9pbnQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5pZCA9ICdyb3RhdGUnO1xuICAgIHRoaXMuZGVsdGEgPSBbMCwgMF07XG4gICAgdGhpcy5vcmlnaW4gPSB2b2lkIDA7XG4gICAgdGhpcy5zbmFwc2hvdCA9IHZvaWQgMDtcbiAgICB0aGlzLnByZXYgPSAwO1xuXG4gICAgdGhpcy5zdGFydCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuXG4gICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgcG9pbnQsIGlzTG9ja2VkKSB7XG4gICAgICBpZiAoaXNMb2NrZWQgPT09IHZvaWQgMCkge1xuICAgICAgICBpc0xvY2tlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3RoaXMkc25hcHNob3QgPSBfdGhpcy5zbmFwc2hvdCxcbiAgICAgICAgICBjb21tb25Cb3VuZHNDZW50ZXIgPSBfdGhpcyRzbmFwc2hvdC5jb21tb25Cb3VuZHNDZW50ZXIsXG4gICAgICAgICAgaW5pdGlhbFNoYXBlcyA9IF90aGlzJHNuYXBzaG90LmluaXRpYWxTaGFwZXM7XG5cbiAgICAgIHZhciBuZXh0ID0gX2V4dGVuZHMoe30sIGRhdGEsIHtcbiAgICAgICAgcGFnZTogX2V4dGVuZHMoe30sIGRhdGEucGFnZSksXG4gICAgICAgIHBhZ2VTdGF0ZTogX2V4dGVuZHMoe30sIGRhdGEucGFnZVN0YXRlKVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBwYWdlID0gbmV4dC5wYWdlLFxuICAgICAgICAgIHBhZ2VTdGF0ZSA9IG5leHQucGFnZVN0YXRlO1xuICAgICAgdmFyIGExID0gY29yZS5WZWMuYW5nbGUoY29tbW9uQm91bmRzQ2VudGVyLCBfdGhpcy5vcmlnaW4pO1xuICAgICAgdmFyIGEyID0gY29yZS5WZWMuYW5nbGUoY29tbW9uQm91bmRzQ2VudGVyLCBwb2ludCk7XG4gICAgICB2YXIgcm90ID0gYTIgLSBhMTtcbiAgICAgIF90aGlzLnByZXYgPSByb3Q7XG5cbiAgICAgIGlmIChpc0xvY2tlZCkge1xuICAgICAgICByb3QgPSBjb3JlLlV0aWxzLmNsYW1wVG9Sb3RhdGlvblRvU2VnbWVudHMocm90LCAyNCk7XG4gICAgICB9XG5cbiAgICAgIHBhZ2VTdGF0ZS5ib3VuZHNSb3RhdGlvbiA9IChQSTIkMSArIChfdGhpcy5zbmFwc2hvdC5ib3VuZHNSb3RhdGlvbiArIHJvdCkpICUgUEkyJDE7XG4gICAgICBuZXh0LnBhZ2Uuc2hhcGVzID0gX2V4dGVuZHMoe30sIG5leHQucGFnZS5zaGFwZXMsIE9iamVjdC5mcm9tRW50cmllcyhpbml0aWFsU2hhcGVzLm1hcChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgaWQgPSBfcmVmLmlkLFxuICAgICAgICAgICAgY2VudGVyID0gX3JlZi5jZW50ZXIsXG4gICAgICAgICAgICBvZmZzZXQgPSBfcmVmLm9mZnNldCxcbiAgICAgICAgICAgIF9yZWYkc2hhcGUkcm90YXRpb24gPSBfcmVmLnNoYXBlLnJvdGF0aW9uLFxuICAgICAgICAgICAgcm90YXRpb24gPSBfcmVmJHNoYXBlJHJvdGF0aW9uID09PSB2b2lkIDAgPyAwIDogX3JlZiRzaGFwZSRyb3RhdGlvbjtcbiAgICAgICAgdmFyIHNoYXBlID0gcGFnZS5zaGFwZXNbaWRdO1xuICAgICAgICB2YXIgbmV4dFJvdGF0aW9uID0gaXNMb2NrZWQgPyBjb3JlLlV0aWxzLmNsYW1wVG9Sb3RhdGlvblRvU2VnbWVudHMocm90YXRpb24gKyByb3QsIDI0KSA6IHJvdGF0aW9uICsgcm90O1xuICAgICAgICB2YXIgbmV4dFBvaW50ID0gY29yZS5WZWMuc3ViKGNvcmUuVmVjLnJvdFdpdGgoY2VudGVyLCBjb21tb25Cb3VuZHNDZW50ZXIsIHJvdCksIG9mZnNldCk7XG4gICAgICAgIHJldHVybiBbaWQsIF9leHRlbmRzKHt9LCBuZXh0LnBhZ2Uuc2hhcGVzW2lkXSwgVExEUi5tdXRhdGUoZGF0YSwgc2hhcGUsIHtcbiAgICAgICAgICBwb2ludDogbmV4dFBvaW50LFxuICAgICAgICAgIHJvdGF0aW9uOiAoUEkyJDEgKyBuZXh0Um90YXRpb24pICUgUEkyJDFcbiAgICAgICAgfSkpXTtcbiAgICAgIH0pKSk7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuXG4gICAgdGhpcy5jYW5jZWwgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdmFyIGluaXRpYWxTaGFwZXMgPSBfdGhpcy5zbmFwc2hvdC5pbml0aWFsU2hhcGVzO1xuXG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKGluaXRpYWxTaGFwZXMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBfc3RlcC52YWx1ZSxcbiAgICAgICAgICAgIGlkID0gX3N0ZXAkdmFsdWUuaWQsXG4gICAgICAgICAgICBzaGFwZSA9IF9zdGVwJHZhbHVlLnNoYXBlO1xuICAgICAgICBkYXRhLnBhZ2Uuc2hhcGVzW2lkXSA9IF9leHRlbmRzKHt9LCBzaGFwZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgZGF0YSwge1xuICAgICAgICBwYWdlOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlLCB7XG4gICAgICAgICAgc2hhcGVzOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlLnNoYXBlcywgT2JqZWN0LmZyb21FbnRyaWVzKGluaXRpYWxTaGFwZXMubWFwKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICAgICAgdmFyIGlkID0gX3JlZjIuaWQsXG4gICAgICAgICAgICAgICAgc2hhcGUgPSBfcmVmMi5zaGFwZTtcbiAgICAgICAgICAgIHJldHVybiBbaWQsIFRMRFIub25TZXNzaW9uQ29tcGxldGUoZGF0YSwgc2hhcGUpXTtcbiAgICAgICAgICB9KSkpXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5vcmlnaW4gPSBfcG9pbnQ7XG4gICAgdGhpcy5zbmFwc2hvdCA9IGdldFJvdGF0ZVNuYXBzaG90KF9kYXRhKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBSb3RhdGVTZXNzaW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uY29tcGxldGUgPSBmdW5jdGlvbiBjb21wbGV0ZShkYXRhKSB7XG4gICAgdmFyIF90aGlzJHNuYXBzaG90MiA9IHRoaXMuc25hcHNob3QsXG4gICAgICAgIGhhc1VubG9ja2VkU2hhcGVzID0gX3RoaXMkc25hcHNob3QyLmhhc1VubG9ja2VkU2hhcGVzLFxuICAgICAgICBpbml0aWFsU2hhcGVzID0gX3RoaXMkc25hcHNob3QyLmluaXRpYWxTaGFwZXM7XG4gICAgaWYgKCFoYXNVbmxvY2tlZFNoYXBlcykgcmV0dXJuIGRhdGE7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiAncm90YXRlJyxcbiAgICAgIGJlZm9yZToge1xuICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgc2hhcGVzOiBPYmplY3QuZnJvbUVudHJpZXMoaW5pdGlhbFNoYXBlcy5tYXAoZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgICAgICB2YXIgX3JlZjMkc2hhcGUgPSBfcmVmMy5zaGFwZSxcbiAgICAgICAgICAgICAgICBpZCA9IF9yZWYzJHNoYXBlLmlkLFxuICAgICAgICAgICAgICAgIHBvaW50ID0gX3JlZjMkc2hhcGUucG9pbnQsXG4gICAgICAgICAgICAgICAgX3JlZjMkc2hhcGUkcm90YXRpb24gPSBfcmVmMyRzaGFwZS5yb3RhdGlvbixcbiAgICAgICAgICAgICAgICByb3RhdGlvbiA9IF9yZWYzJHNoYXBlJHJvdGF0aW9uID09PSB2b2lkIDAgPyB1bmRlZmluZWQgOiBfcmVmMyRzaGFwZSRyb3RhdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBbaWQsIHtcbiAgICAgICAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICAgICAgICByb3RhdGlvbjogcm90YXRpb25cbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgIH0pKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYWZ0ZXI6IHtcbiAgICAgICAgcGFnZToge1xuICAgICAgICAgIHNoYXBlczogT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuc25hcHNob3QuaW5pdGlhbFNoYXBlcy5tYXAoZnVuY3Rpb24gKF9yZWY0KSB7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBfcmVmNC5zaGFwZTtcbiAgICAgICAgICAgIHZhciBfZGF0YSRwYWdlJHNoYXBlcyRzaGEgPSBkYXRhLnBhZ2Uuc2hhcGVzW3NoYXBlLmlkXSxcbiAgICAgICAgICAgICAgICBwb2ludCA9IF9kYXRhJHBhZ2Ukc2hhcGVzJHNoYS5wb2ludCxcbiAgICAgICAgICAgICAgICByb3RhdGlvbiA9IF9kYXRhJHBhZ2Ukc2hhcGVzJHNoYS5yb3RhdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBbc2hhcGUuaWQsIHtcbiAgICAgICAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICAgICAgICByb3RhdGlvbjogcm90YXRpb25cbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgIH0pKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4gUm90YXRlU2Vzc2lvbjtcbn0oKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcblxuZnVuY3Rpb24gZ2V0Um90YXRlU25hcHNob3QoZGF0YSkge1xuICB2YXIgaW5pdGlhbFNoYXBlcyA9IFRMRFIuZ2V0U2VsZWN0ZWRCcmFuY2hTbmFwc2hvdChkYXRhKTtcblxuICBpZiAoaW5pdGlhbFNoYXBlcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBFcnJvcignTm8gc2VsZWN0ZWQgc2hhcGVzIScpO1xuICB9XG5cbiAgdmFyIGhhc1VubG9ja2VkU2hhcGVzID0gaW5pdGlhbFNoYXBlcy5sZW5ndGggPiAwO1xuICB2YXIgc2hhcGVzQm91bmRzID0gT2JqZWN0LmZyb21FbnRyaWVzKGluaXRpYWxTaGFwZXMubWFwKGZ1bmN0aW9uIChzaGFwZSkge1xuICAgIHJldHVybiBbc2hhcGUuaWQsIFRMRFIuZ2V0Qm91bmRzKHNoYXBlKV07XG4gIH0pKTtcbiAgdmFyIHJvdGF0ZWRCb3VuZHMgPSBPYmplY3QuZnJvbUVudHJpZXMoaW5pdGlhbFNoYXBlcy5tYXAoZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgcmV0dXJuIFtzaGFwZS5pZCwgVExEUi5nZXRSb3RhdGVkQm91bmRzKHNoYXBlKV07XG4gIH0pKTtcbiAgdmFyIGJvdW5kcyA9IGNvcmUuVXRpbHMuZ2V0Q29tbW9uQm91bmRzKE9iamVjdC52YWx1ZXMoc2hhcGVzQm91bmRzKSk7XG4gIHZhciBjb21tb25Cb3VuZHNDZW50ZXIgPSBjb3JlLlV0aWxzLmdldEJvdW5kc0NlbnRlcihib3VuZHMpO1xuICByZXR1cm4ge1xuICAgIGhhc1VubG9ja2VkU2hhcGVzOiBoYXNVbmxvY2tlZFNoYXBlcyxcbiAgICBib3VuZHNSb3RhdGlvbjogZGF0YS5wYWdlU3RhdGUuYm91bmRzUm90YXRpb24gfHwgMCxcbiAgICBjb21tb25Cb3VuZHNDZW50ZXI6IGNvbW1vbkJvdW5kc0NlbnRlcixcbiAgICBpbml0aWFsU2hhcGVzOiBpbml0aWFsU2hhcGVzLmZpbHRlcihmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgIHJldHVybiBzaGFwZS5jaGlsZHJlbiA9PT0gdW5kZWZpbmVkO1xuICAgIH0pLm1hcChmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgIHZhciBib3VuZHMgPSBUTERSLmdldEJvdW5kcyhzaGFwZSk7XG4gICAgICB2YXIgY2VudGVyID0gY29yZS5VdGlscy5nZXRCb3VuZHNDZW50ZXIoYm91bmRzKTtcbiAgICAgIHZhciBvZmZzZXQgPSBjb3JlLlZlYy5zdWIoY2VudGVyLCBzaGFwZS5wb2ludCk7XG4gICAgICB2YXIgcm90YXRpb25PZmZzZXQgPSBjb3JlLlZlYy5zdWIoY2VudGVyLCBjb3JlLlV0aWxzLmdldEJvdW5kc0NlbnRlcihyb3RhdGVkQm91bmRzW3NoYXBlLmlkXSkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IHNoYXBlLmlkLFxuICAgICAgICBzaGFwZTogY29yZS5VdGlscy5kZWVwQ2xvbmUoc2hhcGUpLFxuICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgcm90YXRpb25PZmZzZXQ6IHJvdGF0aW9uT2Zmc2V0LFxuICAgICAgICBjZW50ZXI6IGNlbnRlclxuICAgICAgfTtcbiAgICB9KVxuICB9O1xufVxuXG52YXIgSGFuZGxlU2Vzc2lvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEhhbmRsZVNlc3Npb24oX2RhdGEsIF9oYW5kbGVJZCwgX3BvaW50LCBjb21tYW5kSWQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKGNvbW1hbmRJZCA9PT0gdm9pZCAwKSB7XG4gICAgICBjb21tYW5kSWQgPSAnbW92ZV9oYW5kbGUnO1xuICAgIH1cblxuICAgIHRoaXMuaWQgPSAndHJhbnNmb3JtX3NpbmdsZSc7XG4gICAgdGhpcy5jb21tYW5kSWQgPSB2b2lkIDA7XG4gICAgdGhpcy5kZWx0YSA9IFswLCAwXTtcbiAgICB0aGlzLm9yaWdpbiA9IHZvaWQgMDtcbiAgICB0aGlzLnNoaWZ0S2V5ID0gZmFsc2U7XG4gICAgdGhpcy5pbml0aWFsU2hhcGUgPSB2b2lkIDA7XG4gICAgdGhpcy5oYW5kbGVJZCA9IHZvaWQgMDtcblxuICAgIHRoaXMuc3RhcnQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuICAgIHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIHBvaW50LCBzaGlmdEtleSwgYWx0S2V5LCBtZXRhS2V5KSB7XG4gICAgICB2YXIgX1RMRFIkZ2V0U2hhcGVVdGlscyRvLCBfZXh0ZW5kczI7XG5cbiAgICAgIHZhciBpbml0aWFsU2hhcGUgPSBfdGhpcy5pbml0aWFsU2hhcGUsXG4gICAgICAgICAgb3JpZ2luID0gX3RoaXMub3JpZ2luO1xuICAgICAgdmFyIHNoYXBlID0gVExEUi5nZXRTaGFwZShkYXRhLCBpbml0aWFsU2hhcGUuaWQpO1xuICAgICAgVExEUi5hc3NlcnRTaGFwZUhhc1Byb3BlcnR5KHNoYXBlLCAnaGFuZGxlcycpO1xuICAgICAgX3RoaXMuc2hpZnRLZXkgPSBzaGlmdEtleTtcbiAgICAgIHZhciBkZWx0YSA9IGNvcmUuVmVjLnZlYyhvcmlnaW4sIHBvaW50KTtcbiAgICAgIHZhciBoYW5kbGVzID0gaW5pdGlhbFNoYXBlLmhhbmRsZXM7XG4gICAgICB2YXIgaGFuZGxlSWQgPSBfdGhpcy5oYW5kbGVJZDtcbiAgICAgIHZhciBjaGFuZ2UgPSBUTERSLmdldFNoYXBlVXRpbHMoc2hhcGUpLm9uSGFuZGxlQ2hhbmdlKHNoYXBlLCAoX1RMRFIkZ2V0U2hhcGVVdGlscyRvID0ge30sIF9UTERSJGdldFNoYXBlVXRpbHMkb1toYW5kbGVJZF0gPSBfZXh0ZW5kcyh7fSwgc2hhcGUuaGFuZGxlc1toYW5kbGVJZF0sIHtcbiAgICAgICAgcG9pbnQ6IGNvcmUuVmVjLnJvdW5kKGNvcmUuVmVjLmFkZChoYW5kbGVzW2hhbmRsZUlkXS5wb2ludCwgZGVsdGEpKSAvLyBWZWMucm90KGRlbHRhLCBzaGFwZS5yb3RhdGlvbikpLFxuXG4gICAgICB9KSwgX1RMRFIkZ2V0U2hhcGVVdGlscyRvKSwge1xuICAgICAgICBkZWx0YTogZGVsdGEsXG4gICAgICAgIHNoaWZ0S2V5OiBzaGlmdEtleSxcbiAgICAgICAgYWx0S2V5OiBhbHRLZXksXG4gICAgICAgIG1ldGFLZXk6IG1ldGFLZXlcbiAgICAgIH0pO1xuICAgICAgaWYgKCFjaGFuZ2UpIHJldHVybiBkYXRhO1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBkYXRhLCB7XG4gICAgICAgIHBhZ2U6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2UsIHtcbiAgICAgICAgICBzaGFwZXM6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2Uuc2hhcGVzLCAoX2V4dGVuZHMyID0ge30sIF9leHRlbmRzMltzaGFwZS5pZF0gPSBfZXh0ZW5kcyh7fSwgc2hhcGUsIGNoYW5nZSksIF9leHRlbmRzMikpXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5jYW5jZWwgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdmFyIF9leHRlbmRzMztcblxuICAgICAgdmFyIGluaXRpYWxTaGFwZSA9IF90aGlzLmluaXRpYWxTaGFwZTtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgZGF0YSwge1xuICAgICAgICBwYWdlOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlLCB7XG4gICAgICAgICAgc2hhcGVzOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlLnNoYXBlcywgKF9leHRlbmRzMyA9IHt9LCBfZXh0ZW5kczNbaW5pdGlhbFNoYXBlLmlkXSA9IGluaXRpYWxTaGFwZSwgX2V4dGVuZHMzKSlcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgc2hhcGVJZCA9IF9kYXRhLnBhZ2VTdGF0ZS5zZWxlY3RlZElkc1swXTtcbiAgICB0aGlzLm9yaWdpbiA9IF9wb2ludDtcbiAgICB0aGlzLmhhbmRsZUlkID0gX2hhbmRsZUlkO1xuICAgIHRoaXMuaW5pdGlhbFNoYXBlID0gVExEUi5nZXRTaGFwZShfZGF0YSwgc2hhcGVJZCk7XG4gICAgdGhpcy5jb21tYW5kSWQgPSBjb21tYW5kSWQ7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gSGFuZGxlU2Vzc2lvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBsZXRlID0gZnVuY3Rpb24gY29tcGxldGUoZGF0YSkge1xuICAgIHZhciBfc2hhcGVzLCBfc2hhcGVzMjtcblxuICAgIHJldHVybiB7XG4gICAgICBpZDogdGhpcy5jb21tYW5kSWQsXG4gICAgICBiZWZvcmU6IHtcbiAgICAgICAgcGFnZToge1xuICAgICAgICAgIHNoYXBlczogKF9zaGFwZXMgPSB7fSwgX3NoYXBlc1t0aGlzLmluaXRpYWxTaGFwZS5pZF0gPSB0aGlzLmluaXRpYWxTaGFwZSwgX3NoYXBlcylcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFmdGVyOiB7XG4gICAgICAgIHBhZ2U6IHtcbiAgICAgICAgICBzaGFwZXM6IChfc2hhcGVzMiA9IHt9LCBfc2hhcGVzMlt0aGlzLmluaXRpYWxTaGFwZS5pZF0gPSBUTERSLm9uU2Vzc2lvbkNvbXBsZXRlKGRhdGEsIGRhdGEucGFnZS5zaGFwZXNbdGhpcy5pbml0aWFsU2hhcGUuaWRdKSwgX3NoYXBlczIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBIYW5kbGVTZXNzaW9uO1xufSgpO1xuXG52YXIgaW5pdGlhbERhdGEgPSB7XG4gIHNldHRpbmdzOiB7XG4gICAgaXNQZW5Nb2RlOiBmYWxzZSxcbiAgICBpc0RhcmtNb2RlOiBmYWxzZSxcbiAgICBpc0RlYnVnTW9kZTogXCJkZXZlbG9wbWVudFwiID09PSAnZGV2ZWxvcG1lbnQnLFxuICAgIGlzUmVhZG9ubHlNb2RlOiBmYWxzZSxcbiAgICBudWRnZURpc3RhbmNlTGFyZ2U6IDEwLFxuICAgIG51ZGdlRGlzdGFuY2VTbWFsbDogMVxuICB9LFxuICBhcHBTdGF0ZToge1xuICAgIGFjdGl2ZVRvb2xUeXBlOiB1bmRlZmluZWQsXG4gICAgYWN0aXZlVG9vbDogJ3NlbGVjdCcsXG4gICAgaG92ZXJlZElkOiB1bmRlZmluZWQsXG4gICAgY3VycmVudFBhZ2VJZDogJ3BhZ2UnLFxuICAgIHBhZ2VzOiBbe1xuICAgICAgaWQ6ICdwYWdlJ1xuICAgIH1dLFxuICAgIGN1cnJlbnRTdHlsZTogZGVmYXVsdFN0eWxlLFxuICAgIHNlbGVjdGVkU3R5bGU6IGRlZmF1bHRTdHlsZSxcbiAgICBpc1Rvb2xMb2NrZWQ6IGZhbHNlLFxuICAgIGlzU3R5bGVPcGVuOiBmYWxzZSxcbiAgICBpc0VtcHR5Q2FudmFzOiBmYWxzZVxuICB9LFxuICBwYWdlOiB7XG4gICAgaWQ6ICdwYWdlJyxcbiAgICBjaGlsZEluZGV4OiAxLFxuICAgIHNoYXBlczoge30sXG4gICAgYmluZGluZ3M6IHt9XG4gIH0sXG4gIHBhZ2VTdGF0ZToge1xuICAgIGlkOiAncGFnZScsXG4gICAgc2VsZWN0ZWRJZHM6IFtdLFxuICAgIGNhbWVyYToge1xuICAgICAgcG9pbnQ6IFswLCAwXSxcbiAgICAgIHpvb206IDFcbiAgICB9XG4gIH1cbn07XG52YXIgVExEcmF3U3RhdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUTERyYXdTdGF0ZSgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5zdG9yZSA9IGNyZWF0ZVJlYWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpbml0aWFsRGF0YTtcbiAgICB9KTtcbiAgICB0aGlzLmhpc3RvcnkgPSB7XG4gICAgICBzdGFjazogW10sXG4gICAgICBwb2ludGVyOiAtMVxuICAgIH07XG4gICAgdGhpcy5zZXNzaW9uID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhdHVzID0ge1xuICAgICAgY3VycmVudDogJ2lkbGUnLFxuICAgICAgcHJldmlvdXM6ICdpZGxlJ1xuICAgIH07XG4gICAgdGhpcy5wb2ludGVkSWQgPSB2b2lkIDA7XG4gICAgdGhpcy5wb2ludGVkSGFuZGxlID0gdm9pZCAwO1xuICAgIHRoaXMucG9pbnRlZEJvdW5kc0hhbmRsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmN1cnJlbnREb2N1bWVudElkID0gJ2RvYyc7XG4gICAgdGhpcy5jdXJyZW50UGFnZUlkID0gJ3BhZ2UnO1xuICAgIHRoaXMucGFnZXMgPSB7XG4gICAgICBwYWdlOiBpbml0aWFsRGF0YS5wYWdlXG4gICAgfTtcbiAgICB0aGlzLnBhZ2VTdGF0ZXMgPSB7XG4gICAgICBwYWdlOiBpbml0aWFsRGF0YS5wYWdlU3RhdGVcbiAgICB9O1xuICAgIHRoaXMuX29uQ2hhbmdlID0gdm9pZCAwO1xuICAgIHRoaXMuZ2V0U3RhdGUgPSB0aGlzLnN0b3JlLmdldFN0YXRlO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB2YXIgY3VycmVudCA9IF90aGlzLmdldFN0YXRlKCk7IC8vIEFwcGx5IGluY29taW5nIGNoYW5nZVxuXG5cbiAgICAgIHZhciByZXN1bHQgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJyA/IGRhdGEoY3VycmVudCkgOiBkYXRhO1xuXG4gICAgICB2YXIgbmV4dCA9IF9leHRlbmRzKHt9LCBjdXJyZW50LCByZXN1bHQpO1xuXG4gICAgICBpZiAoJ3BhZ2UnIGluIHJlc3VsdCkge1xuICAgICAgICBuZXh0LnBhZ2UgPSBfZXh0ZW5kcyh7fSwgbmV4dC5wYWdlLCB7XG4gICAgICAgICAgc2hhcGVzOiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMobmV4dC5wYWdlLnNoYXBlcykuZmlsdGVyKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBfcmVmWzFdO1xuICAgICAgICAgICAgcmV0dXJuIHNoYXBlICYmIChzaGFwZS5wYXJlbnRJZCA9PT0gbmV4dC5wYWdlLmlkIHx8IG5leHQucGFnZS5zaGFwZXNbc2hhcGUucGFyZW50SWRdKTtcbiAgICAgICAgICB9KSlcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIEFwcGx5IHNlbGVjdGVkIHN0eWxlIGNoYW5nZSwgaWYgYW55XG5cblxuICAgICAgdmFyIG5ld1NlbGVjdGVkU3R5bGUgPSBUTERSLmdldFNlbGVjdGVkU3R5bGUobmV4dCk7XG5cbiAgICAgIGlmIChuZXdTZWxlY3RlZFN0eWxlKSB7XG4gICAgICAgIG5leHQgPSBfZXh0ZW5kcyh7fSwgbmV4dCwge1xuICAgICAgICAgIGFwcFN0YXRlOiBfZXh0ZW5kcyh7fSwgY3VycmVudC5hcHBTdGF0ZSwgbmV4dC5hcHBTdGF0ZSwge1xuICAgICAgICAgICAgc2VsZWN0ZWRTdHlsZTogbmV3U2VsZWN0ZWRTdHlsZVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5zdG9yZS5zZXRTdGF0ZShuZXh0KTtcblxuICAgICAgX3RoaXMucGFnZXNbbmV4dC5wYWdlLmlkXSA9IG5leHQucGFnZTtcbiAgICAgIF90aGlzLnBhZ2VTdGF0ZXNbbmV4dC5wYWdlLmlkXSA9IG5leHQucGFnZVN0YXRlO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLmdldFNoYXBlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICByZXR1cm4gX3RoaXMuZ2V0U3RhdGUoKS5wYWdlLnNoYXBlc1tpZF07XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0UGFnZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgaWYgKGlkID09PSB2b2lkIDApIHtcbiAgICAgICAgaWQgPSBfdGhpcy5jdXJyZW50UGFnZUlkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3RoaXMucGFnZXNbaWRdO1xuICAgIH07XG5cbiAgICB0aGlzLmdldFBhZ2VTdGF0ZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgaWYgKGlkID09PSB2b2lkIDApIHtcbiAgICAgICAgaWQgPSBfdGhpcy5jdXJyZW50UGFnZUlkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3RoaXMucGFnZVN0YXRlc1tpZF07XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0QXBwU3RhdGUgPSBmdW5jdGlvbiAoaWQpIHtcblxuICAgICAgcmV0dXJuIF90aGlzLmdldFN0YXRlKCkuYXBwU3RhdGU7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0UGFnZVBvaW50ID0gZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICB2YXIgX3RoaXMkZ2V0UGFnZVN0YXRlID0gX3RoaXMuZ2V0UGFnZVN0YXRlKCksXG4gICAgICAgICAgY2FtZXJhID0gX3RoaXMkZ2V0UGFnZVN0YXRlLmNhbWVyYTtcblxuICAgICAgcmV0dXJuIGNvcmUuVmVjLnN1Yihjb3JlLlZlYy5kaXYocG9pbnQsIGNhbWVyYS56b29tKSwgY2FtZXJhLnBvaW50KTtcbiAgICB9O1xuXG4gICAgdGhpcy50b2dnbGVTdHlsZVBhbmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhcHBTdGF0ZTogX2V4dGVuZHMoe30sIGRhdGEuYXBwU3RhdGUsIHtcbiAgICAgICAgICAgIGlzU3R5bGVPcGVuOiAhZGF0YS5hcHBTdGF0ZS5pc1N0eWxlT3BlblxuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLmNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBUT0RPXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMucGFzdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBUT0RPXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMuY29weUFzU3ZnID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVE9ET1xuICAgICAgcmV0dXJuICc8c3ZnLz4nO1xuICAgIH07XG5cbiAgICB0aGlzLmNvcHlBc0pzb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBUT0RPXG4gICAgICByZXR1cm4ge307XG4gICAgfTtcblxuICAgIHRoaXMudG9nZ2xlUGVuTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc2V0dGluZ3M6IF9leHRlbmRzKHt9LCBkYXRhLnNldHRpbmdzLCB7XG4gICAgICAgICAgICBpc1Blbk1vZGU6ICFkYXRhLnNldHRpbmdzLmlzUGVuTW9kZVxuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLnRvZ2dsZURhcmtNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzZXR0aW5nczogX2V4dGVuZHMoe30sIGRhdGEuc2V0dGluZ3MsIHtcbiAgICAgICAgICAgIGlzRGFya01vZGU6ICFkYXRhLnNldHRpbmdzLmlzRGFya01vZGVcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYXBwU3RhdGU6IF9leHRlbmRzKHt9LCBkYXRhLmFwcFN0YXRlLCBpbml0aWFsRGF0YS5hcHBTdGF0ZSksXG4gICAgICAgICAgc2V0dGluZ3M6IF9leHRlbmRzKHt9LCBkYXRhLmFwcFN0YXRlLCBpbml0aWFsRGF0YS5zZXR0aW5ncylcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICBfdGhpcy5fb25DaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzLl9vbkNoYW5nZShfdGhpcywgXCJyZXNldFwiKTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5zZWxlY3RUb29sID0gZnVuY3Rpb24gKHRvb2wpIHtcbiAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYXBwU3RhdGU6IF9leHRlbmRzKHt9LCBkYXRhLmFwcFN0YXRlLCB7XG4gICAgICAgICAgICBhY3RpdmVUb29sOiB0b29sLFxuICAgICAgICAgICAgYWN0aXZlVG9vbFR5cGU6IHRvb2wgPT09ICdzZWxlY3QnID8gJ3NlbGVjdCcgOiBUTERSLmdldFNoYXBlVXRpbHMoe1xuICAgICAgICAgICAgICB0eXBlOiB0b29sXG4gICAgICAgICAgICB9KS50b29sVHlwZVxuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLnRvZ2dsZVRvb2xMb2NrID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhcHBTdGF0ZTogX2V4dGVuZHMoe30sIGRhdGEuYXBwU3RhdGUsIHtcbiAgICAgICAgICAgIGlzVG9vbExvY2tlZDogdHJ1ZVxuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLnpvb21JbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpID0gTWF0aC5yb3VuZChfdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLnBhZ2VTdGF0ZS5jYW1lcmEuem9vbSAqIDEwMCAvIDI1KTtcbiAgICAgIHZhciBuZXh0Wm9vbSA9IFRMRFIuZ2V0Q2FtZXJhWm9vbSgoaSArIDEpICogMC4yNSk7XG5cbiAgICAgIF90aGlzLnpvb21UbyhuZXh0Wm9vbSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy56b29tT3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGkgPSBNYXRoLnJvdW5kKF90aGlzLnN0b3JlLmdldFN0YXRlKCkucGFnZVN0YXRlLmNhbWVyYS56b29tICogMTAwIC8gMjUpO1xuICAgICAgdmFyIG5leHRab29tID0gVExEUi5nZXRDYW1lcmFab29tKChpIC0gMSkgKiAwLjI1KTtcblxuICAgICAgX3RoaXMuem9vbVRvKG5leHRab29tKTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLnpvb21Ub0ZpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBzaGFwZXMgPSBPYmplY3QudmFsdWVzKGRhdGEucGFnZS5zaGFwZXMpO1xuICAgICAgICBpZiAoc2hhcGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHtcbiAgICAgICAgICBwYWdlU3RhdGU6IGRhdGEucGFnZVN0YXRlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBib3VuZHMgPSBjb3JlLlV0aWxzLmdldENvbW1vbkJvdW5kcyhPYmplY3QudmFsdWVzKHNoYXBlcykubWFwKFRMRFIuZ2V0Qm91bmRzKSk7XG4gICAgICAgIHZhciB6b29tID0gVExEUi5nZXRDYW1lcmFab29tKGJvdW5kcy53aWR0aCA+IGJvdW5kcy5oZWlnaHQgPyAod2luZG93LmlubmVyV2lkdGggLSAxMjgpIC8gYm91bmRzLndpZHRoIDogKHdpbmRvdy5pbm5lckhlaWdodCAtIDEyOCkgLyBib3VuZHMuaGVpZ2h0KTtcbiAgICAgICAgdmFyIG14ID0gKHdpbmRvdy5pbm5lcldpZHRoIC0gYm91bmRzLndpZHRoICogem9vbSkgLyAyIC8gem9vbTtcbiAgICAgICAgdmFyIG15ID0gKHdpbmRvdy5pbm5lckhlaWdodCAtIGJvdW5kcy5oZWlnaHQgKiB6b29tKSAvIDIgLyB6b29tO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhZ2VTdGF0ZTogX2V4dGVuZHMoe30sIGRhdGEucGFnZVN0YXRlLCB7XG4gICAgICAgICAgICBjYW1lcmE6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2VTdGF0ZS5jYW1lcmEsIHtcbiAgICAgICAgICAgICAgcG9pbnQ6IGNvcmUuVmVjLmFkZChbLWJvdW5kcy5taW5YLCAtYm91bmRzLm1pblldLCBbbXgsIG15XSksXG4gICAgICAgICAgICAgIHpvb206IHpvb21cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMuem9vbVRvU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKFRMRFIuZ2V0U2VsZWN0ZWRJZHMoZGF0YSkubGVuZ3RoID09PSAwKSByZXR1cm4ge1xuICAgICAgICAgIHBhZ2VTdGF0ZTogZGF0YS5wYWdlU3RhdGVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJvdW5kcyA9IFRMRFIuZ2V0U2VsZWN0ZWRCb3VuZHMoZGF0YSk7XG4gICAgICAgIHZhciB6b29tID0gVExEUi5nZXRDYW1lcmFab29tKGJvdW5kcy53aWR0aCA+IGJvdW5kcy5oZWlnaHQgPyAod2luZG93LmlubmVyV2lkdGggLSAxMjgpIC8gYm91bmRzLndpZHRoIDogKHdpbmRvdy5pbm5lckhlaWdodCAtIDEyOCkgLyBib3VuZHMuaGVpZ2h0KTtcbiAgICAgICAgdmFyIG14ID0gKHdpbmRvdy5pbm5lcldpZHRoIC0gYm91bmRzLndpZHRoICogem9vbSkgLyAyIC8gem9vbTtcbiAgICAgICAgdmFyIG15ID0gKHdpbmRvdy5pbm5lckhlaWdodCAtIGJvdW5kcy5oZWlnaHQgKiB6b29tKSAvIDIgLyB6b29tO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhZ2VTdGF0ZTogX2V4dGVuZHMoe30sIGRhdGEucGFnZVN0YXRlLCB7XG4gICAgICAgICAgICBjYW1lcmE6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2VTdGF0ZS5jYW1lcmEsIHtcbiAgICAgICAgICAgICAgcG9pbnQ6IGNvcmUuVmVjLmFkZChbLWJvdW5kcy5taW5YLCAtYm91bmRzLm1pblldLCBbbXgsIG15XSksXG4gICAgICAgICAgICAgIHpvb206IHpvb21cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMucmVzZXRDYW1lcmEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhZ2VTdGF0ZTogX2V4dGVuZHMoe30sIGRhdGEucGFnZVN0YXRlLCB7XG4gICAgICAgICAgICBjYW1lcmE6IHtcbiAgICAgICAgICAgICAgem9vbTogMSxcbiAgICAgICAgICAgICAgcG9pbnQ6IFt3aW5kb3cuaW5uZXJXaWR0aCAvIDIsIHdpbmRvdy5pbm5lckhlaWdodCAvIDJdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMuem9vbVRvQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBzaGFwZXMgPSBPYmplY3QudmFsdWVzKGRhdGEucGFnZS5zaGFwZXMpO1xuICAgICAgICBpZiAoc2hhcGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHtcbiAgICAgICAgICBwYWdlU3RhdGU6IGRhdGEucGFnZVN0YXRlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBib3VuZHMgPSBjb3JlLlV0aWxzLmdldENvbW1vbkJvdW5kcyhPYmplY3QudmFsdWVzKHNoYXBlcykubWFwKFRMRFIuZ2V0Qm91bmRzKSk7XG4gICAgICAgIHZhciB6b29tID0gZGF0YS5wYWdlU3RhdGUuY2FtZXJhLnpvb207XG4gICAgICAgIHZhciBteCA9ICh3aW5kb3cuaW5uZXJXaWR0aCAtIGJvdW5kcy53aWR0aCAqIHpvb20pIC8gMiAvIHpvb207XG4gICAgICAgIHZhciBteSA9ICh3aW5kb3cuaW5uZXJIZWlnaHQgLSBib3VuZHMuaGVpZ2h0ICogem9vbSkgLyAyIC8gem9vbTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYWdlU3RhdGU6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2VTdGF0ZSwge1xuICAgICAgICAgICAgY2FtZXJhOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlU3RhdGUuY2FtZXJhLCB7XG4gICAgICAgICAgICAgIHBvaW50OiBjb3JlLlZlYy5hZGQoWy1ib3VuZHMubWluWCwgLWJvdW5kcy5taW5ZXSwgW214LCBteV0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLnpvb21Ub0FjdHVhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnpvb21UbygxKTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLmxvYWREb2N1bWVudCA9IGZ1bmN0aW9uIChkb2N1bWVudCwgb25DaGFuZ2UpIHtcbiAgICAgIF90aGlzLl9vbkNoYW5nZSA9IG9uQ2hhbmdlO1xuICAgICAgX3RoaXMuY3VycmVudERvY3VtZW50SWQgPSBkb2N1bWVudC5pZDtcbiAgICAgIF90aGlzLnBhZ2VzID0gY29yZS5VdGlscy5kZWVwQ2xvbmUoZG9jdW1lbnQucGFnZXMpO1xuICAgICAgX3RoaXMucGFnZVN0YXRlcyA9IGNvcmUuVXRpbHMuZGVlcENsb25lKGRvY3VtZW50LnBhZ2VTdGF0ZXMpO1xuICAgICAgX3RoaXMuY3VycmVudFBhZ2VJZCA9IE9iamVjdC52YWx1ZXMoX3RoaXMucGFnZXMpWzBdLmlkO1xuXG4gICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhZ2U6IF90aGlzLnBhZ2VzW190aGlzLmN1cnJlbnRQYWdlSWRdLFxuICAgICAgICAgIHBhZ2VTdGF0ZTogX3RoaXMucGFnZVN0YXRlc1tfdGhpcy5jdXJyZW50UGFnZUlkXSxcbiAgICAgICAgICBhcHBTdGF0ZTogX2V4dGVuZHMoe30sIGRhdGEuYXBwU3RhdGUsIHtcbiAgICAgICAgICAgIHBhZ2VJZHM6IE9iamVjdC52YWx1ZXMoX3RoaXMucGFnZXMpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIChhLmNoaWxkSW5kZXggfHwgMCkgLSAoYi5jaGlsZEluZGV4IHx8IDApO1xuICAgICAgICAgICAgfSkubWFwKGZ1bmN0aW9uIChwYWdlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYWdlLmlkO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy51bmRvID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGhpc3RvcnkgPSBfdGhpcy5oaXN0b3J5O1xuICAgICAgaWYgKGhpc3RvcnkucG9pbnRlciA8PSAtMSkgcmV0dXJuIF90aGlzO1xuICAgICAgdmFyIGNvbW1hbmQgPSBoaXN0b3J5LnN0YWNrW2hpc3RvcnkucG9pbnRlcl07XG5cbiAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBjb3JlLlV0aWxzLmRlZXBNZXJnZShkYXRhLCBjb21tYW5kLmJlZm9yZSk7XG4gICAgICB9KTtcblxuICAgICAgaGlzdG9yeS5wb2ludGVyLS07XG4gICAgICBfdGhpcy5fb25DaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzLl9vbkNoYW5nZShfdGhpcywgXCJ1bmRvOlwiICsgY29tbWFuZC5pZCk7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMucmVkbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBoaXN0b3J5ID0gX3RoaXMuaGlzdG9yeTtcbiAgICAgIGlmIChoaXN0b3J5LnBvaW50ZXIgPj0gaGlzdG9yeS5zdGFjay5sZW5ndGggLSAxKSByZXR1cm4gX3RoaXM7XG4gICAgICBoaXN0b3J5LnBvaW50ZXIrKztcbiAgICAgIHZhciBjb21tYW5kID0gaGlzdG9yeS5zdGFja1toaXN0b3J5LnBvaW50ZXJdO1xuXG4gICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gY29yZS5VdGlscy5kZWVwTWVyZ2UoZGF0YSwgY29tbWFuZC5hZnRlcik7XG4gICAgICB9KTtcblxuICAgICAgX3RoaXMuX29uQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcy5fb25DaGFuZ2UoX3RoaXMsIFwicmVkbzpcIiArIGNvbW1hbmQuaWQpO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLnNlbGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBpZHMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGlkc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuc2V0U2VsZWN0ZWRJZHMoaWRzKTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLnNlbGVjdEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYXBwU3RhdGU6IF9leHRlbmRzKHt9LCBkYXRhLmFwcFN0YXRlLCB7XG4gICAgICAgICAgICBhY3RpdmVUb29sOiAnc2VsZWN0JyxcbiAgICAgICAgICAgIGFjdGl2ZVRvb2xUeXBlOiAnc2VsZWN0J1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIHBhZ2VTdGF0ZTogX2V4dGVuZHMoe30sIGRhdGEucGFnZVN0YXRlLCB7XG4gICAgICAgICAgICBzZWxlY3RlZElkczogT2JqZWN0LmtleXMoZGF0YS5wYWdlLnNoYXBlcylcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5kZXNlbGVjdEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnNldFNlbGVjdGVkSWRzKFtdKTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLnN0eWxlID0gZnVuY3Rpb24gKHN0eWxlJDEsIGlkcykge1xuICAgICAgdmFyIGRhdGEgPSBfdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICB2YXIgaWRzVG9NdXRhdGUgPSBpZHMgPyBpZHMgOiBkYXRhLnBhZ2VTdGF0ZS5zZWxlY3RlZElkcztcblxuICAgICAgX3RoaXNbXCJkb1wiXShzdHlsZShkYXRhLCBpZHNUb011dGF0ZSwgc3R5bGUkMSkpO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMuYWxpZ24gPSBmdW5jdGlvbiAodHlwZSwgaWRzKSB7XG4gICAgICB2YXIgZGF0YSA9IF90aGlzLnN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAgIHZhciBpZHNUb011dGF0ZSA9IGlkcyA/IGlkcyA6IGRhdGEucGFnZVN0YXRlLnNlbGVjdGVkSWRzO1xuXG4gICAgICBfdGhpc1tcImRvXCJdKGFsaWduKGRhdGEsIGlkc1RvTXV0YXRlLCB0eXBlKSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5kaXN0cmlidXRlID0gZnVuY3Rpb24gKHR5cGUsIGlkcykge1xuICAgICAgdmFyIGRhdGEgPSBfdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICB2YXIgaWRzVG9NdXRhdGUgPSBpZHMgPyBpZHMgOiBkYXRhLnBhZ2VTdGF0ZS5zZWxlY3RlZElkcztcblxuICAgICAgX3RoaXNbXCJkb1wiXShkaXN0cmlidXRlKGRhdGEsIGlkc1RvTXV0YXRlLCB0eXBlKSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5zdHJldGNoID0gZnVuY3Rpb24gKHR5cGUsIGlkcykge1xuICAgICAgdmFyIGRhdGEgPSBfdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICB2YXIgaWRzVG9NdXRhdGUgPSBpZHMgPyBpZHMgOiBkYXRhLnBhZ2VTdGF0ZS5zZWxlY3RlZElkcztcblxuICAgICAgX3RoaXNbXCJkb1wiXShzdHJldGNoKGRhdGEsIGlkc1RvTXV0YXRlLCB0eXBlKSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5tb3ZlVG9CYWNrID0gZnVuY3Rpb24gKGlkcykge1xuICAgICAgdmFyIGRhdGEgPSBfdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICB2YXIgaWRzVG9NdXRhdGUgPSBpZHMgPyBpZHMgOiBkYXRhLnBhZ2VTdGF0ZS5zZWxlY3RlZElkcztcblxuICAgICAgX3RoaXNbXCJkb1wiXShtb3ZlKGRhdGEsIGlkc1RvTXV0YXRlLCBleHBvcnRzLk1vdmVUeXBlLlRvQmFjaykpO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMubW92ZUJhY2t3YXJkID0gZnVuY3Rpb24gKGlkcykge1xuICAgICAgdmFyIGRhdGEgPSBfdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICB2YXIgaWRzVG9NdXRhdGUgPSBpZHMgPyBpZHMgOiBkYXRhLnBhZ2VTdGF0ZS5zZWxlY3RlZElkcztcblxuICAgICAgX3RoaXNbXCJkb1wiXShtb3ZlKGRhdGEsIGlkc1RvTXV0YXRlLCBleHBvcnRzLk1vdmVUeXBlLkJhY2t3YXJkKSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5tb3ZlRm9yd2FyZCA9IGZ1bmN0aW9uIChpZHMpIHtcbiAgICAgIHZhciBkYXRhID0gX3RoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgICAgdmFyIGlkc1RvTXV0YXRlID0gaWRzID8gaWRzIDogZGF0YS5wYWdlU3RhdGUuc2VsZWN0ZWRJZHM7XG5cbiAgICAgIF90aGlzW1wiZG9cIl0obW92ZShkYXRhLCBpZHNUb011dGF0ZSwgZXhwb3J0cy5Nb3ZlVHlwZS5Gb3J3YXJkKSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5tb3ZlVG9Gcm9udCA9IGZ1bmN0aW9uIChpZHMpIHtcbiAgICAgIHZhciBkYXRhID0gX3RoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgICAgdmFyIGlkc1RvTXV0YXRlID0gaWRzID8gaWRzIDogZGF0YS5wYWdlU3RhdGUuc2VsZWN0ZWRJZHM7XG5cbiAgICAgIF90aGlzW1wiZG9cIl0obW92ZShkYXRhLCBpZHNUb011dGF0ZSwgZXhwb3J0cy5Nb3ZlVHlwZS5Ub0Zyb250KSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5udWRnZSA9IGZ1bmN0aW9uIChkZWx0YSwgaXNNYWpvciwgaWRzKSB7XG4gICAgICBpZiAoaXNNYWpvciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlzTWFqb3IgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRhdGEgPSBfdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICB2YXIgaWRzVG9NdXRhdGUgPSBpZHMgPyBpZHMgOiBkYXRhLnBhZ2VTdGF0ZS5zZWxlY3RlZElkcztcblxuICAgICAgX3RoaXNbXCJkb1wiXSh0cmFuc2xhdGUoZGF0YSwgaWRzVG9NdXRhdGUsIGNvcmUuVmVjLm11bChkZWx0YSwgaXNNYWpvciA/IDEwIDogMSkpKTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLmR1cGxpY2F0ZSA9IGZ1bmN0aW9uIChpZHMpIHtcbiAgICAgIHZhciBkYXRhID0gX3RoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgICAgdmFyIGlkc1RvTXV0YXRlID0gaWRzID8gaWRzIDogZGF0YS5wYWdlU3RhdGUuc2VsZWN0ZWRJZHM7XG5cbiAgICAgIF90aGlzW1wiZG9cIl0oZHVwbGljYXRlKGRhdGEsIGlkc1RvTXV0YXRlKSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy50b2dnbGVIaWRkZW4gPSBmdW5jdGlvbiAoaWRzKSB7XG4gICAgICB2YXIgZGF0YSA9IF90aGlzLnN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAgIHZhciBpZHNUb011dGF0ZSA9IGlkcyA/IGlkcyA6IGRhdGEucGFnZVN0YXRlLnNlbGVjdGVkSWRzO1xuXG4gICAgICBfdGhpc1tcImRvXCJdKHRvZ2dsZShkYXRhLCBpZHNUb011dGF0ZSwgJ2lzSGlkZGVuJykpO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMudG9nZ2xlTG9ja2VkID0gZnVuY3Rpb24gKGlkcykge1xuICAgICAgdmFyIGRhdGEgPSBfdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICB2YXIgaWRzVG9NdXRhdGUgPSBpZHMgPyBpZHMgOiBkYXRhLnBhZ2VTdGF0ZS5zZWxlY3RlZElkcztcblxuICAgICAgX3RoaXNbXCJkb1wiXSh0b2dnbGUoZGF0YSwgaWRzVG9NdXRhdGUsICdpc0xvY2tlZCcpKTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLnRvZ2dsZUFzcGVjdFJhdGlvTG9ja2VkID0gZnVuY3Rpb24gKGlkcykge1xuICAgICAgdmFyIGRhdGEgPSBfdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICB2YXIgaWRzVG9NdXRhdGUgPSBpZHMgPyBpZHMgOiBkYXRhLnBhZ2VTdGF0ZS5zZWxlY3RlZElkcztcblxuICAgICAgX3RoaXNbXCJkb1wiXSh0b2dnbGUoZGF0YSwgaWRzVG9NdXRhdGUsICdpc0FzcGVjdFJhdGlvTG9ja2VkJykpO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMucm90YXRlID0gZnVuY3Rpb24gKGRlbHRhLCBpZHMpIHtcbiAgICAgIGlmIChkZWx0YSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRlbHRhID0gTWF0aC5QSSAqIC0wLjU7XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRhID0gX3RoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgICAgdmFyIGlkc1RvTXV0YXRlID0gaWRzID8gaWRzIDogZGF0YS5wYWdlU3RhdGUuc2VsZWN0ZWRJZHM7XG5cbiAgICAgIF90aGlzW1wiZG9cIl0ocm90YXRlKGRhdGEsIGlkc1RvTXV0YXRlLCBkZWx0YSkpO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMuZ3JvdXAgPSBmdW5jdGlvbiAoaWRzKSB7XG4gICAgICAvLyBUT0RPXG4gICAgICAvLyBjb25zdCBkYXRhID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpXG4gICAgICAvLyBjb25zdCBpZHNUb011dGF0ZSA9IGlkcyA/IGlkcyA6IGRhdGEucGFnZVN0YXRlLnNlbGVjdGVkSWRzXG4gICAgICAvLyB0aGlzLmRvKGNvbW1hbmRzLnRvZ2dsZShkYXRhLCBpZHNUb011dGF0ZSwgJ2lzQXNwZWN0UmF0aW9Mb2NrZWQnKSlcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZGF0YSA9IF90aGlzLnN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgc2hhcGVzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIHNoYXBlc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBfdGhpc1tcImRvXCJdKGNyZWF0ZShkYXRhLCBzaGFwZXMpKTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzW1wiZGVsZXRlXCJdID0gZnVuY3Rpb24gKGlkcykge1xuICAgICAgdmFyIGRhdGEgPSBfdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICB2YXIgaWRzVG9NdXRhdGUgPSBpZHMgPyBpZHMgOiBkYXRhLnBhZ2VTdGF0ZS5zZWxlY3RlZElkcztcbiAgICAgIGlmIChpZHNUb011dGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBfdGhpcztcblxuICAgICAgX3RoaXNbXCJkb1wiXShkZWxldGVTaGFwZXMoZGF0YSwgaWRzVG9NdXRhdGUpKTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuc2VsZWN0QWxsKCk7XG5cbiAgICAgIF90aGlzW1wiZGVsZXRlXCJdKCk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzd2l0Y2ggKF90aGlzLnN0YXR1cy5jdXJyZW50KSB7XG4gICAgICAgIGNhc2UgJ2lkbGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIF90aGlzLmRlc2VsZWN0QWxsKCk7XG5cbiAgICAgICAgICAgIF90aGlzLnNlbGVjdFRvb2woJ3NlbGVjdCcpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnYnJ1c2hpbmcnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIF90aGlzLmNhbmNlbFNlc3Npb24oKTtcblxuICAgICAgICAgICAgY29yZS5icnVzaFVwZGF0ZXIuY2xlYXIoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICd0cmFuc2xhdGluZyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgX3RoaXMuY2FuY2VsU2Vzc2lvbigpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAndHJhbnNmb3JtaW5nJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBfdGhpcy5jYW5jZWxTZXNzaW9uKCk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdyb3RhdGluZyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgX3RoaXMuY2FuY2VsU2Vzc2lvbigpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnY3JlYXRpbmcnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIF90aGlzLmNhbmNlbFNlc3Npb24oKTtcblxuICAgICAgICAgICAgX3RoaXNbXCJkZWxldGVcIl0oKTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMuc2F2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFRPRE9cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5zdGFydEJydXNoU2Vzc2lvbiA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgX3RoaXMuc2V0U3RhdHVzKCdicnVzaGluZycpO1xuXG4gICAgICBfdGhpcy5zdGFydFNlc3Npb24obmV3IEJydXNoU2Vzc2lvbihfdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLCBwb2ludCkpO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMudXBkYXRlQnJ1c2hTZXNzaW9uID0gZnVuY3Rpb24gKHBvaW50LCBtZXRhS2V5KSB7XG4gICAgICBpZiAobWV0YUtleSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG1ldGFLZXkgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMudXBkYXRlU2Vzc2lvbihwb2ludCwgbWV0YUtleSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5zdGFydFRyYW5zbGF0ZVNlc3Npb24gPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIF90aGlzLnNldFN0YXR1cygndHJhbnNsYXRpbmcnKTtcblxuICAgICAgX3RoaXMuc3RhcnRTZXNzaW9uKG5ldyBUcmFuc2xhdGVTZXNzaW9uKF90aGlzLnN0b3JlLmdldFN0YXRlKCksIHBvaW50KSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy51cGRhdGVUcmFuc2xhdGVTZXNzaW9uID0gZnVuY3Rpb24gKHBvaW50LCBzaGlmdEtleSwgYWx0S2V5KSB7XG4gICAgICBpZiAoc2hpZnRLZXkgPT09IHZvaWQgMCkge1xuICAgICAgICBzaGlmdEtleSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWx0S2V5ID09PSB2b2lkIDApIHtcbiAgICAgICAgYWx0S2V5ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnVwZGF0ZVNlc3Npb24ocG9pbnQsIHNoaWZ0S2V5LCBhbHRLZXkpO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMuc3RhcnRUcmFuc2Zvcm1TZXNzaW9uID0gZnVuY3Rpb24gKHBvaW50LCBoYW5kbGUsIGNvbW1hbmRJZCkge1xuICAgICAgdmFyIHNlbGVjdGVkSWRzID0gX3RoaXMuc2VsZWN0ZWRJZHM7XG4gICAgICBpZiAoc2VsZWN0ZWRJZHMubGVuZ3RoID09PSAwKSByZXR1cm4gX3RoaXM7XG5cbiAgICAgIF90aGlzLnNldFN0YXR1cygndHJhbnNmb3JtaW5nJyk7XG5cbiAgICAgIF90aGlzLnBvaW50ZWRCb3VuZHNIYW5kbGUgPSBoYW5kbGU7XG5cbiAgICAgIGlmIChfdGhpcy5wb2ludGVkQm91bmRzSGFuZGxlID09PSAncm90YXRlJykge1xuICAgICAgICBfdGhpcy5zdGFydFNlc3Npb24obmV3IFJvdGF0ZVNlc3Npb24oX3RoaXMuc3RvcmUuZ2V0U3RhdGUoKSwgcG9pbnQpKTtcbiAgICAgIH0gZWxzZSBpZiAoX3RoaXMuc2VsZWN0ZWRJZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIF90aGlzLnN0YXJ0U2Vzc2lvbihuZXcgVHJhbnNmb3JtU2luZ2xlU2Vzc2lvbihfdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLCBwb2ludCwgX3RoaXMucG9pbnRlZEJvdW5kc0hhbmRsZSwgY29tbWFuZElkKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5zdGFydFNlc3Npb24obmV3IFRyYW5zZm9ybVNlc3Npb24oX3RoaXMuc3RvcmUuZ2V0U3RhdGUoKSwgcG9pbnQsIF90aGlzLnBvaW50ZWRCb3VuZHNIYW5kbGUpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybVNlc3Npb24gPSBmdW5jdGlvbiAocG9pbnQsIHNoaWZ0S2V5LCBhbHRLZXkpIHtcbiAgICAgIGlmIChzaGlmdEtleSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHNoaWZ0S2V5ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbHRLZXkgPT09IHZvaWQgMCkge1xuICAgICAgICBhbHRLZXkgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMudXBkYXRlU2Vzc2lvbihwb2ludCwgc2hpZnRLZXksIGFsdEtleSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5zdGFydERyYXdTZXNzaW9uID0gZnVuY3Rpb24gKGlkLCBwb2ludCkge1xuICAgICAgX3RoaXMuc2V0U3RhdHVzKCdjcmVhdGluZycpO1xuXG4gICAgICBfdGhpcy5zdGFydFNlc3Npb24obmV3IERyYXdTZXNzaW9uKF90aGlzLnN0b3JlLmdldFN0YXRlKCksIGlkLCBwb2ludCkpO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMudXBkYXRlRHJhd1Nlc3Npb24gPSBmdW5jdGlvbiAocG9pbnQsIHByZXNzdXJlLCBzaGlmdEtleSkge1xuICAgICAgaWYgKHNoaWZ0S2V5ID09PSB2b2lkIDApIHtcbiAgICAgICAgc2hpZnRLZXkgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMudXBkYXRlU2Vzc2lvbihwb2ludCwgcHJlc3N1cmUsIHNoaWZ0S2V5KTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLnN0YXJ0SGFuZGxlU2Vzc2lvbiA9IGZ1bmN0aW9uIChwb2ludCwgaGFuZGxlSWQsIGNvbW1hbmRJZCkge1xuICAgICAgX3RoaXMuc3RhcnRTZXNzaW9uKG5ldyBIYW5kbGVTZXNzaW9uKF90aGlzLnN0b3JlLmdldFN0YXRlKCksIGhhbmRsZUlkLCBwb2ludCwgY29tbWFuZElkKSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy51cGRhdGVIYW5kbGVTZXNzaW9uID0gZnVuY3Rpb24gKHBvaW50LCBzaGlmdEtleSwgYWx0S2V5LCBtZXRhS2V5KSB7XG4gICAgICBpZiAoc2hpZnRLZXkgPT09IHZvaWQgMCkge1xuICAgICAgICBzaGlmdEtleSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWx0S2V5ID09PSB2b2lkIDApIHtcbiAgICAgICAgYWx0S2V5ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChtZXRhS2V5ID09PSB2b2lkIDApIHtcbiAgICAgICAgbWV0YUtleSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy51cGRhdGVTZXNzaW9uKHBvaW50LCBzaGlmdEtleSwgYWx0S2V5LCBtZXRhS2V5KTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLnVwZGF0ZVNlc3Npb25zT25Qb2ludGVyTW92ZSA9IGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICBzd2l0Y2ggKF90aGlzLnN0YXR1cy5jdXJyZW50KSB7XG4gICAgICAgIGNhc2UgJ3BvaW50aW5nQm91bmRzSGFuZGxlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoY29yZS5WZWMuZGlzdChpbmZvLm9yaWdpbiwgaW5mby5wb2ludCkgPiA0KSB7XG4gICAgICAgICAgICAgIF90aGlzLnNldFN0YXR1cygndHJhbnNmb3JtaW5nJyk7XG5cbiAgICAgICAgICAgICAgX3RoaXMuc3RhcnRUcmFuc2Zvcm1TZXNzaW9uKF90aGlzLmdldFBhZ2VQb2ludChpbmZvLm9yaWdpbiksIF90aGlzLnBvaW50ZWRCb3VuZHNIYW5kbGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAncG9pbnRpbmdIYW5kbGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChjb3JlLlZlYy5kaXN0KGluZm8ub3JpZ2luLCBpbmZvLnBvaW50KSA+IDQpIHtcbiAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdHVzKCd0cmFuc2xhdGluZ0hhbmRsZScpO1xuXG4gICAgICAgICAgICAgIF90aGlzLnN0YXJ0SGFuZGxlU2Vzc2lvbihfdGhpcy5nZXRQYWdlUG9pbnQoaW5mby5vcmlnaW4pLCBfdGhpcy5wb2ludGVkSGFuZGxlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3BvaW50aW5nQm91bmRzJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoY29yZS5WZWMuZGlzdChpbmZvLm9yaWdpbiwgaW5mby5wb2ludCkgPiA0KSB7XG4gICAgICAgICAgICAgIF90aGlzLnNldFN0YXR1cygndHJhbnNsYXRpbmcnKTtcblxuICAgICAgICAgICAgICBfdGhpcy5zdGFydFRyYW5zbGF0ZVNlc3Npb24oX3RoaXMuZ2V0UGFnZVBvaW50KGluZm8ub3JpZ2luKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdicnVzaGluZyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgX3RoaXMudXBkYXRlQnJ1c2hTZXNzaW9uKF90aGlzLmdldFBhZ2VQb2ludChpbmZvLnBvaW50KSwgaW5mby5tZXRhS2V5KTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3RyYW5zbGF0aW5nJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBfdGhpcy51cGRhdGVUcmFuc2xhdGVTZXNzaW9uKF90aGlzLmdldFBhZ2VQb2ludChpbmZvLnBvaW50KSwgaW5mby5zaGlmdEtleSwgaW5mby5hbHRLZXkpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAndHJhbnNmb3JtaW5nJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBfdGhpcy51cGRhdGVUcmFuc2Zvcm1TZXNzaW9uKF90aGlzLmdldFBhZ2VQb2ludChpbmZvLnBvaW50KSwgaW5mby5zaGlmdEtleSwgaW5mby5hbHRLZXkpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAndHJhbnNsYXRpbmdIYW5kbGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZUhhbmRsZVNlc3Npb24oX3RoaXMuZ2V0UGFnZVBvaW50KGluZm8ucG9pbnQpLCBpbmZvLnNoaWZ0S2V5LCBpbmZvLmFsdEtleSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdjcmVhdGluZyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgc3dpdGNoIChfdGhpcy5hcHBTdGF0ZS5hY3RpdmVUb29sVHlwZSkge1xuICAgICAgICAgICAgICBjYXNlICdkcmF3JzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVEcmF3U2Vzc2lvbihfdGhpcy5nZXRQYWdlUG9pbnQoaW5mby5wb2ludCksIGluZm8ucHJlc3N1cmUsIGluZm8uc2hpZnRLZXkpO1xuXG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY2FzZSAnYm91bmRzJzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVUcmFuc2Zvcm1TZXNzaW9uKF90aGlzLmdldFBhZ2VQb2ludChpbmZvLnBvaW50KSwgaW5mby5zaGlmdEtleSk7XG5cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjYXNlICdoYW5kbGUnOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZUhhbmRsZVNlc3Npb24oX3RoaXMuZ2V0UGFnZVBvaW50KGluZm8ucG9pbnQpLCBpbmZvLnNoaWZ0S2V5LCBpbmZvLmFsdEtleSk7XG5cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm9uS2V5RG93biA9IGZ1bmN0aW9uIChrZXksIGluZm8pIHtcbiAgICAgIGlmIChrZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgIF90aGlzLmNhbmNlbCgpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChfdGhpcy5zdGF0dXMuY3VycmVudCkge1xuICAgICAgICBjYXNlICdpZGxlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnYnJ1c2hpbmcnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdNZXRhJyB8fCBrZXkgPT09ICdDb250cm9sJykge1xuICAgICAgICAgICAgICBfdGhpcy51cGRhdGVCcnVzaFNlc3Npb24oX3RoaXMuZ2V0UGFnZVBvaW50KGluZm8ucG9pbnQpLCBpbmZvLm1ldGFLZXkpO1xuXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3RyYW5zbGF0aW5nJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnRXNjYXBlJykge1xuICAgICAgICAgICAgICBfdGhpcy5jYW5jZWxTZXNzaW9uKF90aGlzLmdldFBhZ2VQb2ludChpbmZvLnBvaW50KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdTaGlmdCcgfHwga2V5ID09PSAnQWx0Jykge1xuICAgICAgICAgICAgICBfdGhpcy51cGRhdGVUcmFuc2xhdGVTZXNzaW9uKF90aGlzLmdldFBhZ2VQb2ludChpbmZvLnBvaW50KSwgaW5mby5zaGlmdEtleSwgaW5mby5hbHRLZXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAndHJhbnNmb3JtaW5nJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnRXNjYXBlJykge1xuICAgICAgICAgICAgICBfdGhpcy5jYW5jZWxTZXNzaW9uKF90aGlzLmdldFBhZ2VQb2ludChpbmZvLnBvaW50KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdTaGlmdCcgfHwga2V5ID09PSAnQWx0Jykge1xuICAgICAgICAgICAgICBfdGhpcy51cGRhdGVUcmFuc2Zvcm1TZXNzaW9uKF90aGlzLmdldFBhZ2VQb2ludChpbmZvLnBvaW50KSwgaW5mby5zaGlmdEtleSwgaW5mby5hbHRLZXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMub25LZXlVcCA9IGZ1bmN0aW9uIChrZXksIGluZm8pIHtcbiAgICAgIHN3aXRjaCAoX3RoaXMuc3RhdHVzLmN1cnJlbnQpIHtcbiAgICAgICAgY2FzZSAnYnJ1c2hpbmcnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdNZXRhJyB8fCBrZXkgPT09ICdDb250cm9sJykge1xuICAgICAgICAgICAgICBfdGhpcy51cGRhdGVCcnVzaFNlc3Npb24oX3RoaXMuZ2V0UGFnZVBvaW50KGluZm8ucG9pbnQpLCBpbmZvLm1ldGFLZXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAndHJhbnNmb3JtaW5nJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnU2hpZnQnIHx8IGtleSA9PT0gJ0FsdCcpIHtcbiAgICAgICAgICAgICAgX3RoaXMudXBkYXRlVHJhbnNmb3JtU2Vzc2lvbihfdGhpcy5nZXRQYWdlUG9pbnQoaW5mby5wb2ludCksIGluZm8uc2hpZnRLZXksIGluZm8uYWx0S2V5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3RyYW5zbGF0aW5nJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnU2hpZnQnIHx8IGtleSA9PT0gJ0FsdCcpIHtcbiAgICAgICAgICAgICAgX3RoaXMudXBkYXRlVHJhbnNmb3JtU2Vzc2lvbihfdGhpcy5nZXRQYWdlUG9pbnQoaW5mby5wb2ludCksIGluZm8uc2hpZnRLZXksIGluZm8uYWx0S2V5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm9uUGluY2hTdGFydCA9IGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICBfdGhpcy5zZXRTdGF0dXMoJ3BpbmNoaW5nJyk7XG4gICAgfTtcblxuICAgIHRoaXMub25QaW5jaEVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnNldFN0YXR1cyhfdGhpcy5zdGF0dXMucHJldmlvdXMpO1xuICAgIH07XG5cbiAgICB0aGlzLm9uUGluY2ggPSBmdW5jdGlvbiAoaW5mbywgZSkge1xuICAgICAgaWYgKF90aGlzLnN0YXR1cy5jdXJyZW50ICE9PSAncGluY2hpbmcnKSByZXR1cm47XG5cbiAgICAgIF90aGlzLnBpbmNoWm9vbShpbmZvLm9yaWdpbiwgaW5mby5kZWx0YSwgaW5mby5kZWx0YVsyXSAvIDM1MCk7XG5cbiAgICAgIF90aGlzLnVwZGF0ZVNlc3Npb25zT25Qb2ludGVyTW92ZShpbmZvLCBlKTtcbiAgICB9O1xuXG4gICAgdGhpcy5vblBhbiA9IGZ1bmN0aW9uIChpbmZvLCBlKSB7XG4gICAgICB2YXIgZGVsdGEgPSBjb3JlLlZlYy5kaXYoaW5mby5kZWx0YSwgX3RoaXMuZ2V0UGFnZVN0YXRlKCkuY2FtZXJhLnpvb20pO1xuXG4gICAgICB2YXIgcHJldiA9IF90aGlzLmdldFBhZ2VTdGF0ZSgpLmNhbWVyYS5wb2ludDtcblxuICAgICAgdmFyIG5leHQgPSBjb3JlLlZlYy5zdWIocHJldiwgZGVsdGEpO1xuICAgICAgaWYgKGNvcmUuVmVjLmlzRXF1YWwobmV4dCwgcHJldikpIHJldHVybjtcblxuICAgICAgX3RoaXMucGFuKGRlbHRhKTtcblxuICAgICAgX3RoaXMudXBkYXRlU2Vzc2lvbnNPblBvaW50ZXJNb3ZlKGluZm8sIGUpO1xuICAgIH07XG5cbiAgICB0aGlzLm9uWm9vbSA9IGZ1bmN0aW9uIChpbmZvLCBlKSB7XG4gICAgICBfdGhpcy56b29tKGluZm8uZGVsdGFbMl0gLyAxMDApO1xuXG4gICAgICBfdGhpcy51cGRhdGVTZXNzaW9uc09uUG9pbnRlck1vdmUoaW5mbywgZSk7XG4gICAgfTtcblxuICAgIHRoaXMub25Qb2ludGVyRG93biA9IGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICBzd2l0Y2ggKF90aGlzLnN0YXR1cy5jdXJyZW50KSB7XG4gICAgICAgIGNhc2UgJ2lkbGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX3RoaXMuYXBwU3RhdGUuYWN0aXZlVG9vbCkge1xuICAgICAgICAgICAgICBjYXNlICdkcmF3JzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0dXMoJ2NyZWF0aW5nJyk7XG5cbiAgICAgICAgICAgICAgICAgIF90aGlzLmNyZWF0ZUFjdGl2ZVRvb2xTaGFwZShpbmZvLnBvaW50KTtcblxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNhc2UgJ3JlY3RhbmdsZSc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdHVzKCdjcmVhdGluZycpO1xuXG4gICAgICAgICAgICAgICAgICBfdGhpcy5jcmVhdGVBY3RpdmVUb29sU2hhcGUoaW5mby5wb2ludCk7XG5cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjYXNlICdlbGxpcHNlJzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0dXMoJ2NyZWF0aW5nJyk7XG5cbiAgICAgICAgICAgICAgICAgIF90aGlzLmNyZWF0ZUFjdGl2ZVRvb2xTaGFwZShpbmZvLnBvaW50KTtcblxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNhc2UgJ2Fycm93JzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0dXMoJ2NyZWF0aW5nJyk7XG5cbiAgICAgICAgICAgICAgICAgIF90aGlzLmNyZWF0ZUFjdGl2ZVRvb2xTaGFwZShpbmZvLnBvaW50KTtcblxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5vblBvaW50ZXJNb3ZlID0gZnVuY3Rpb24gKGluZm8sIGUpIHtcbiAgICAgIF90aGlzLnVwZGF0ZVNlc3Npb25zT25Qb2ludGVyTW92ZShpbmZvLCBlKTtcbiAgICB9O1xuXG4gICAgdGhpcy5vblBvaW50ZXJVcCA9IGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICB2YXIgZGF0YSA9IF90aGlzLmdldFN0YXRlKCk7XG5cbiAgICAgIHN3aXRjaCAoX3RoaXMuc3RhdHVzLmN1cnJlbnQpIHtcbiAgICAgICAgY2FzZSAncG9pbnRpbmdCb3VuZHMnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChpbmZvLnRhcmdldCA9PT0gJ2JvdW5kcycpIHtcbiAgICAgICAgICAgICAgLy8gSWYgd2UganVzdCBjbGlja2VkIHRoZSBzZWxlY3RpbmcgYm91bmRzJ3MgYmFja2dyb3VuZCwgY2xlYXIgdGhlIHNlbGVjdGlvblxuICAgICAgICAgICAgICBfdGhpcy5kZXNlbGVjdEFsbCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLnBhZ2VTdGF0ZS5zZWxlY3RlZElkcy5pbmNsdWRlcyhpbmZvLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgLy8gSWYgd2UncmUgaG9sZGluZyBzaGlmdC4uLlxuICAgICAgICAgICAgICBpZiAoaW5mby5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIC8vIFVubGVzcyB3ZSBqdXN0IHNoaWZ0LXNlbGVjdGVkIHRoZSBzaGFwZSwgcmVtb3ZlIGl0IGZyb20gdGhlIHNlbGVjdGVkIHNoYXBlc1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5wb2ludGVkSWQgIT09IGluZm8udGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy5zZXRTZWxlY3RlZElkcyhkYXRhLnBhZ2VTdGF0ZS5zZWxlY3RlZElkcy5maWx0ZXIoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpZCAhPT0gaW5mby50YXJnZXQ7XG4gICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF90aGlzLnNldFN0YXR1cygnaWRsZScpO1xuXG4gICAgICAgICAgICBfdGhpcy5wb2ludGVkSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAncG9pbnRpbmdCb3VuZHNIYW5kbGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXR1cygnaWRsZScpO1xuXG4gICAgICAgICAgICBfdGhpcy5wb2ludGVkQm91bmRzSGFuZGxlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3BvaW50aW5nSGFuZGxlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0dXMoJ2lkbGUnKTtcblxuICAgICAgICAgICAgX3RoaXMucG9pbnRlZEhhbmRsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICd0cmFuc2xhdGluZ0hhbmRsZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgX3RoaXMuY29tcGxldGVTZXNzaW9uKCk7XG5cbiAgICAgICAgICAgIF90aGlzLnBvaW50ZWRIYW5kbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnYnJ1c2hpbmcnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIF90aGlzLmNvbXBsZXRlU2Vzc2lvbigpO1xuXG4gICAgICAgICAgICBjb3JlLmJydXNoVXBkYXRlci5jbGVhcigpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3RyYW5zbGF0aW5nJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBfdGhpcy5jb21wbGV0ZVNlc3Npb24oX3RoaXMuZ2V0UGFnZVBvaW50KGluZm8ucG9pbnQpKTtcblxuICAgICAgICAgICAgX3RoaXMucG9pbnRlZElkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3RyYW5zZm9ybWluZyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgX3RoaXMuY29tcGxldGVTZXNzaW9uKF90aGlzLmdldFBhZ2VQb2ludChpbmZvLnBvaW50KSk7XG5cbiAgICAgICAgICAgIF90aGlzLnBvaW50ZWRCb3VuZHNIYW5kbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnY3JlYXRpbmcnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIF90aGlzLmNvbXBsZXRlU2Vzc2lvbihfdGhpcy5nZXRQYWdlUG9pbnQoaW5mby5wb2ludCkpO1xuXG4gICAgICAgICAgICBfdGhpcy5wb2ludGVkSGFuZGxlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5vblBvaW50Q2FudmFzID0gZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgIHN3aXRjaCAoX3RoaXMuc3RhdHVzLmN1cnJlbnQpIHtcbiAgICAgICAgY2FzZSAnaWRsZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgc3dpdGNoIChfdGhpcy5hcHBTdGF0ZS5hY3RpdmVUb29sKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgLy8gVW5sZXNzIHRoZSB1c2VyIGlzIGhvbGRpbmcgc2hpZnQgb3IgbWV0YSwgY2xlYXIgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICBpZiAoIShpbmZvLnNoaWZ0S2V5IHx8IGluZm8ubWV0YUtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGVzZWxlY3RBbGwoKTtcbiAgICAgICAgICAgICAgICAgIH0gLy8gU3RhcnQgYSBicnVzaCBzZXNzaW9uXG5cblxuICAgICAgICAgICAgICAgICAgX3RoaXMuc3RhcnRCcnVzaFNlc3Npb24oX3RoaXMuZ2V0UGFnZVBvaW50KGluZm8ucG9pbnQpKTtcblxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5vbkRvdWJsZUNsaWNrQ2FudmFzID0gZnVuY3Rpb24gKCkgey8vIFVudXNlZFxuICAgIH07XG5cbiAgICB0aGlzLm9uUmlnaHRQb2ludENhbnZhcyA9IGZ1bmN0aW9uICgpIHsvLyBVbnVzZWRcbiAgICB9O1xuXG4gICAgdGhpcy5vbkRyYWdDYW52YXMgPSBmdW5jdGlvbiAoKSB7Ly8gVW51c2VkXG4gICAgfTtcblxuICAgIHRoaXMub25SZWxlYXNlQ2FudmFzID0gZnVuY3Rpb24gKCkgey8vIFVudXNlZFxuICAgIH07XG5cbiAgICB0aGlzLm9uUG9pbnRTaGFwZSA9IGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICB2YXIgZGF0YSA9IF90aGlzLmdldFN0YXRlKCk7XG5cbiAgICAgIHN3aXRjaCAoX3RoaXMuc3RhdHVzLmN1cnJlbnQpIHtcbiAgICAgICAgY2FzZSAnaWRsZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgc3dpdGNoIChfdGhpcy5hcHBTdGF0ZS5hY3RpdmVUb29sKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKGluZm8ubWV0YUtleSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGlsZSBob2xkaW5nIGNvbW1hbmQga2V5LCBhbGxvdyBldmVudCB0byBwYXNzIHRocm91Z2ggdG8gY2FudmFzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhLnBhZ2VTdGF0ZS5zZWxlY3RlZElkcy5pbmNsdWRlcyhpbmZvLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBwb2ludGVkIElEIHRvIHRoZSBzaGFwZSB0aGF0IHdhcyBjbGlja2VkLlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wb2ludGVkSWQgPSBpbmZvLnRhcmdldDsgLy8gSWYgdGhlIHNoYXBlIGlzIG5vdCBzZWxlY3RlZDsgdGhlbiBpZiB0aGUgdXNlciBpcyBwcmVzc2luZyBzaGlmdCxcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBzaGFwZSB0byB0aGUgY3VycmVudCBzZWxlY3Rpb247IG90aGVyd2lzZSwgc2V0IHRoZSBzaGFwZSBhc1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgb25seSBzZWxlY3RlZCBzaGFwZS5cblxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRTZWxlY3RlZElkcyhbaW5mby50YXJnZXRdLCBpbmZvLnNoaWZ0S2V5KTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdHVzKCdwb2ludGluZ0JvdW5kcycpO1xuXG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm9uUmVsZWFzZVNoYXBlID0gZnVuY3Rpb24gKGluZm8pIHsvLyBjb25zdCBkYXRhID0gdGhpcy5nZXRTdGF0ZSgpXG4gICAgICAvLyBzd2l0Y2ggKHRoaXMuc3RhdHVzLmN1cnJlbnQpIHtcbiAgICAgIC8vICAgY2FzZSAncG9pbnRpbmdCb3VuZHMnOiB7XG4gICAgICAvLyAgICAgaWYgKGluZm8ubWV0YUtleSkge1xuICAgICAgLy8gICAgICAgLy8gV2hpbGUgaG9sZGluZyBjb21tYW5kIGtleSwgYWxsb3cgZXZlbnQgdG8gcGFzcyB0aHJvdWdoIHRvIGNhbnZhc1xuICAgICAgLy8gICAgICAgcmV0dXJuXG4gICAgICAvLyAgICAgfVxuICAgICAgLy8gICAgIC8vIElmIHRoZSBzaGFwZSBpcyBzZWxlY3RlZC4uLlxuICAgICAgLy8gICAgIGlmIChcbiAgICAgIC8vICAgICAgIGRhdGEucGFnZVN0YXRlLnNlbGVjdGVkSWRzLmluY2x1ZGVzKGluZm8udGFyZ2V0KSAmJlxuICAgICAgLy8gICAgICAgdGhpcy5wb2ludGVkSWQgIT09IGluZm8udGFyZ2V0ICYmXG4gICAgICAvLyAgICAgICBpbmZvLnNoaWZ0S2V5XG4gICAgICAvLyAgICAgKSB7XG4gICAgICAvLyAgICAgICAvLyBJZiB0aGUgc2hhcGUgaXMgbm90IHNlbGVjdGVkOyB0aGVuIGlmIHRoZSB1c2VyIGlzIHByZXNzaW5nIHNoaWZ0LFxuICAgICAgLy8gICAgICAgLy8gYWRkIHRoZSBzaGFwZSB0byB0aGUgY3VycmVudCBzZWxlY3Rpb247IG90aGVyd2lzZSwgc2V0IHRoZSBzaGFwZSBhc1xuICAgICAgLy8gICAgICAgLy8gdGhlIG9ubHkgc2VsZWN0ZWQgc2hhcGUuXG4gICAgICAvLyAgICAgICB0aGlzLnNldFNlbGVjdGVkSWRzKGRhdGEucGFnZVN0YXRlLnNlbGVjdGVkSWRzLmZpbHRlcigoaWQpID0+IGlkICE9PSBpbmZvLnRhcmdldCkpXG4gICAgICAvLyAgICAgfVxuICAgICAgLy8gICAgIHRoaXMuc2V0U3RhdHVzKCdwb2ludGluZ0JvdW5kcycpXG4gICAgICAvLyAgICAgYnJlYWtcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfVxuICAgIH07XG5cbiAgICB0aGlzLm9uRG91YmxlQ2xpY2tTaGFwZSA9IGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICBpZiAoX3RoaXMuc2VsZWN0ZWRJZHMuaW5jbHVkZXMoaW5mby50YXJnZXQpKSB7XG4gICAgICAgIF90aGlzLnNldFNlbGVjdGVkSWRzKFtpbmZvLnRhcmdldF0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm9uUmlnaHRQb2ludFNoYXBlID0gZnVuY3Rpb24gKCkgey8vIFRPRE9cbiAgICB9O1xuXG4gICAgdGhpcy5vbkRyYWdTaGFwZSA9IGZ1bmN0aW9uIChpbmZvKSB7Ly8gVW51c2VkXG4gICAgfTtcblxuICAgIHRoaXMub25Ib3ZlclNoYXBlID0gZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYXBwU3RhdGU6IF9leHRlbmRzKHt9LCBkYXRhLmFwcFN0YXRlLCB7XG4gICAgICAgICAgICBob3ZlcmVkSWQ6IGluZm8udGFyZ2V0XG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLm9uVW5ob3ZlclNoYXBlID0gZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMuZ2V0U3RhdGUoKS5hcHBTdGF0ZS5ob3ZlcmVkSWQgPT09IGluZm8udGFyZ2V0KSB7XG4gICAgICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGFwcFN0YXRlOiBfZXh0ZW5kcyh7fSwgZGF0YS5hcHBTdGF0ZSwge1xuICAgICAgICAgICAgICAgIGhvdmVyZWRJZDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LCAxMCk7XG4gICAgfTtcblxuICAgIHRoaXMub25Qb2ludEJvdW5kcyA9IGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICBfdGhpcy5zZXRTdGF0dXMoJ3BvaW50aW5nQm91bmRzJyk7XG4gICAgfTtcblxuICAgIHRoaXMub25Eb3VibGVDbGlja0JvdW5kcyA9IGZ1bmN0aW9uICgpIHsvLyBUT0RPXG4gICAgfTtcblxuICAgIHRoaXMub25SaWdodFBvaW50Qm91bmRzID0gZnVuY3Rpb24gKCkgey8vIFRPRE9cbiAgICB9O1xuXG4gICAgdGhpcy5vbkRyYWdCb3VuZHMgPSBmdW5jdGlvbiAoaW5mbykgey8vIFVudXNlZFxuICAgIH07XG5cbiAgICB0aGlzLm9uSG92ZXJCb3VuZHMgPSBmdW5jdGlvbiAoKSB7Ly8gVE9ET1xuICAgIH07XG5cbiAgICB0aGlzLm9uVW5ob3ZlckJvdW5kcyA9IGZ1bmN0aW9uICgpIHsvLyBUT0RPXG4gICAgfTtcblxuICAgIHRoaXMub25SZWxlYXNlQm91bmRzID0gZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgIHN3aXRjaCAoX3RoaXMuc3RhdHVzLmN1cnJlbnQpIHtcbiAgICAgICAgY2FzZSAndHJhbnNsYXRpbmcnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIF90aGlzLmNvbXBsZXRlU2Vzc2lvbihfdGhpcy5nZXRQYWdlUG9pbnQoaW5mby5wb2ludCkpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnYnJ1c2hpbmcnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIF90aGlzLmNvbXBsZXRlU2Vzc2lvbigpO1xuXG4gICAgICAgICAgICBjb3JlLmJydXNoVXBkYXRlci5jbGVhcigpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm9uUG9pbnRCb3VuZHNIYW5kbGUgPSBmdW5jdGlvbiAoaW5mbykge1xuICAgICAgX3RoaXMucG9pbnRlZEJvdW5kc0hhbmRsZSA9IGluZm8udGFyZ2V0O1xuXG4gICAgICBfdGhpcy5zZXRTdGF0dXMoJ3BvaW50aW5nQm91bmRzSGFuZGxlJyk7XG4gICAgfTtcblxuICAgIHRoaXMub25Eb3VibGVDbGlja0JvdW5kc0hhbmRsZSA9IGZ1bmN0aW9uICgpIHsvLyBUT0RPXG4gICAgfTtcblxuICAgIHRoaXMub25SaWdodFBvaW50Qm91bmRzSGFuZGxlID0gZnVuY3Rpb24gKCkgey8vIFRPRE9cbiAgICB9O1xuXG4gICAgdGhpcy5vbkRyYWdCb3VuZHNIYW5kbGUgPSBmdW5jdGlvbiAoKSB7Ly8gVW51c2VkXG4gICAgfTtcblxuICAgIHRoaXMub25Ib3ZlckJvdW5kc0hhbmRsZSA9IGZ1bmN0aW9uICgpIHsvLyBUT0RPXG4gICAgfTtcblxuICAgIHRoaXMub25VbmhvdmVyQm91bmRzSGFuZGxlID0gZnVuY3Rpb24gKCkgey8vIFRPRE9cbiAgICB9O1xuXG4gICAgdGhpcy5vblJlbGVhc2VCb3VuZHNIYW5kbGUgPSBmdW5jdGlvbiAoKSB7Ly8gVE9ET1xuICAgIH07XG5cbiAgICB0aGlzLm9uUG9pbnRIYW5kbGUgPSBmdW5jdGlvbiAoaW5mbykge1xuICAgICAgX3RoaXMucG9pbnRlZEhhbmRsZSA9IGluZm8udGFyZ2V0O1xuXG4gICAgICBfdGhpcy5zZXRTdGF0dXMoJ3BvaW50aW5nSGFuZGxlJyk7XG4gICAgfTtcblxuICAgIHRoaXMub25Eb3VibGVDbGlja0hhbmRsZSA9IGZ1bmN0aW9uICgpIHsvLyBUT0RPXG4gICAgfTtcblxuICAgIHRoaXMub25SaWdodFBvaW50SGFuZGxlID0gZnVuY3Rpb24gKCkgey8vIFRPRE9cbiAgICB9O1xuXG4gICAgdGhpcy5vbkRyYWdIYW5kbGUgPSBmdW5jdGlvbiAoKSB7Ly8gVE9ET1xuICAgIH07XG5cbiAgICB0aGlzLm9uSG92ZXJIYW5kbGUgPSBmdW5jdGlvbiAoKSB7Ly8gVE9ET1xuICAgIH07XG5cbiAgICB0aGlzLm9uVW5ob3ZlckhhbmRsZSA9IGZ1bmN0aW9uICgpIHsvLyBUT0RPXG4gICAgfTtcblxuICAgIHRoaXMub25SZWxlYXNlSGFuZGxlID0gZnVuY3Rpb24gKCkgey8vIFVudXNlZFxuICAgIH07XG5cbiAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKGlkcykge1xuICAgICAgdmFyIGFwcFN0YXRlID0gX3RoaXMuZ2V0QXBwU3RhdGUoKTtcblxuICAgICAgaWYgKGFwcFN0YXRlLmlzRW1wdHlDYW52YXMgJiYgaWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXBwU3RhdGU6IF9leHRlbmRzKHt9LCBkYXRhLmFwcFN0YXRlLCB7XG4gICAgICAgICAgICAgIGlzRW1wdHlDYW52YXM6IGZhbHNlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICghYXBwU3RhdGUuaXNFbXB0eUNhbnZhcyAmJiBpZHMubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXBwU3RhdGU6IF9leHRlbmRzKHt9LCBkYXRhLmFwcFN0YXRlLCB7XG4gICAgICAgICAgICAgIGlzRW1wdHlDYW52YXM6IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMub25FcnJvciA9IGZ1bmN0aW9uIChlcnJvcikgey8vIFRPRE9cbiAgICB9O1xuXG4gICAgdGhpcy5vbkJsdXJFZGl0aW5nU2hhcGUgPSBmdW5jdGlvbiAoKSB7Ly8gVE9ET1xuICAgIH07XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVExEcmF3U3RhdGUucHJvdG90eXBlO1xuXG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLSBTdGF0dXMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gIF9wcm90by5zZXRTdGF0dXMgPSBmdW5jdGlvbiBzZXRTdGF0dXMoc3RhdHVzKSB7XG4gICAgdGhpcy5zdGF0dXMucHJldmlvdXMgPSB0aGlzLnN0YXR1cy5jdXJyZW50O1xuICAgIHRoaXMuc3RhdHVzLmN1cnJlbnQgPSBzdGF0dXM7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNvbnNvbGUubG9nKHRoaXMuc3RhdHVzLnByZXZpb3VzLCAnIC0+ICcsIHRoaXMuc3RhdHVzLmN1cnJlbnQpXG4gIH1cbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0gQXBwIFN0YXRlIC0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgO1xuXG4gIF9wcm90by5waW5jaFpvb20gPSBmdW5jdGlvbiBwaW5jaFpvb20ocG9pbnQsIGRlbHRhLCB6b29tRGVsdGEpIHtcbiAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB2YXIgY2FtZXJhID0gZGF0YS5wYWdlU3RhdGUuY2FtZXJhO1xuICAgICAgdmFyIG5leHRQb2ludCA9IGNvcmUuVmVjLmFkZChjYW1lcmEucG9pbnQsIGNvcmUuVmVjLmRpdihkZWx0YSwgY2FtZXJhLnpvb20pKTtcbiAgICAgIHZhciBuZXh0Wm9vbSA9IFRMRFIuZ2V0Q2FtZXJhWm9vbShjYW1lcmEuem9vbSAtIHpvb21EZWx0YSAqIGNhbWVyYS56b29tKTtcbiAgICAgIHZhciBwMCA9IGNvcmUuVmVjLnN1Yihjb3JlLlZlYy5kaXYocG9pbnQsIGNhbWVyYS56b29tKSwgbmV4dFBvaW50KTtcbiAgICAgIHZhciBwMSA9IGNvcmUuVmVjLnN1Yihjb3JlLlZlYy5kaXYocG9pbnQsIG5leHRab29tKSwgbmV4dFBvaW50KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhZ2VTdGF0ZTogX2V4dGVuZHMoe30sIGRhdGEucGFnZVN0YXRlLCB7XG4gICAgICAgICAgY2FtZXJhOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlU3RhdGUuY2FtZXJhLCB7XG4gICAgICAgICAgICBwb2ludDogY29yZS5WZWMuYWRkKG5leHRQb2ludCwgY29yZS5WZWMuc3ViKHAxLCBwMCkpLFxuICAgICAgICAgICAgem9vbTogbmV4dFpvb21cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uem9vbVRvID0gZnVuY3Rpb24gem9vbVRvKG5leHQpIHtcbiAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB2YXIgX1RMRFIkZ2V0Q3VycmVudENhbWVyID0gVExEUi5nZXRDdXJyZW50Q2FtZXJhKGRhdGEpLFxuICAgICAgICAgIHpvb20gPSBfVExEUiRnZXRDdXJyZW50Q2FtZXIuem9vbSxcbiAgICAgICAgICBwb2ludCA9IF9UTERSJGdldEN1cnJlbnRDYW1lci5wb2ludDtcblxuICAgICAgdmFyIGNlbnRlciA9IFt3aW5kb3cuaW5uZXJXaWR0aCAvIDIsIHdpbmRvdy5pbm5lckhlaWdodCAvIDJdO1xuICAgICAgdmFyIHAwID0gY29yZS5WZWMuc3ViKGNvcmUuVmVjLmRpdihjZW50ZXIsIHpvb20pLCBwb2ludCk7XG4gICAgICB2YXIgcDEgPSBjb3JlLlZlYy5zdWIoY29yZS5WZWMuZGl2KGNlbnRlciwgbmV4dCksIHBvaW50KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhZ2VTdGF0ZTogX2V4dGVuZHMoe30sIGRhdGEucGFnZVN0YXRlLCB7XG4gICAgICAgICAgY2FtZXJhOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlU3RhdGUuY2FtZXJhLCB7XG4gICAgICAgICAgICBwb2ludDogY29yZS5WZWMuYWRkKHBvaW50LCBjb3JlLlZlYy5zdWIocDEsIHAwKSksXG4gICAgICAgICAgICB6b29tOiBuZXh0XG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnpvb20gPSBmdW5jdGlvbiB6b29tKGRlbHRhKSB7XG4gICAgdmFyIHpvb20gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCkucGFnZVN0YXRlLmNhbWVyYS56b29tO1xuICAgIHZhciBuZXh0Wm9vbSA9IFRMRFIuZ2V0Q2FtZXJhWm9vbSh6b29tIC0gZGVsdGEgKiB6b29tKTtcbiAgICB0aGlzLnpvb21UbyhuZXh0Wm9vbSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnBhbiA9IGZ1bmN0aW9uIHBhbihkZWx0YSkge1xuICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHZhciBfVExEUiRnZXRDdXJyZW50Q2FtZXIyID0gVExEUi5nZXRDdXJyZW50Q2FtZXJhKGRhdGEpLFxuICAgICAgICAgIHBvaW50ID0gX1RMRFIkZ2V0Q3VycmVudENhbWVyMi5wb2ludDtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFnZVN0YXRlOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlU3RhdGUsIHtcbiAgICAgICAgICBjYW1lcmE6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2VTdGF0ZS5jYW1lcmEsIHtcbiAgICAgICAgICAgIHBvaW50OiBjb3JlLlZlYy5zdWIocG9pbnQsIGRlbHRhKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRG9jdW1lbnQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gIDtcblxuICBfcHJvdG8uc2V0Q3VycmVudFBhZ2VJZCA9IGZ1bmN0aW9uIHNldEN1cnJlbnRQYWdlSWQocGFnZUlkKSB7XG4gICAgaWYgKHBhZ2VJZCA9PT0gdGhpcy5jdXJyZW50UGFnZUlkKSByZXR1cm4gdGhpcztcbiAgICB0aGlzLmN1cnJlbnRQYWdlSWQgPSBwYWdlSWQ7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBwYWdlOiB0aGlzLnBhZ2VzW3BhZ2VJZF0sXG4gICAgICBwYWdlU3RhdGU6IHRoaXMucGFnZVN0YXRlc1twYWdlSWRdXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0gU2Vzc2lvbnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgO1xuXG4gIF9wcm90by5zdGFydFNlc3Npb24gPSBmdW5jdGlvbiBzdGFydFNlc3Npb24oc2Vzc2lvbikge1xuICAgIHZhciBfdGhpcyRfb25DaGFuZ2U7XG5cbiAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMgPiAxID8gX2xlbjMgLSAxIDogMCksIF9rZXkzID0gMTsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgYXJnc1tfa2V5MyAtIDFdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICB9XG5cbiAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHJldHVybiBzZXNzaW9uLnN0YXJ0LmFwcGx5KHNlc3Npb24sIFtkYXRhXS5jb25jYXQoYXJncykpO1xuICAgIH0pO1xuICAgIChfdGhpcyRfb25DaGFuZ2UgPSB0aGlzLl9vbkNoYW5nZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJF9vbkNoYW5nZS5jYWxsKHRoaXMsIHRoaXMsIFwic2Vzc2lvbjpzdGFydF9cIiArIHNlc3Npb24uaWQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by51cGRhdGVTZXNzaW9uID0gZnVuY3Rpb24gdXBkYXRlU2Vzc2lvbigpIHtcbiAgICB2YXIgX3RoaXMkX29uQ2hhbmdlMjtcblxuICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNCksIF9rZXk0ID0gMDsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgICAgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgIH1cblxuICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgIGlmICghc2Vzc2lvbikgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgcmV0dXJuIHNlc3Npb24udXBkYXRlLmFwcGx5KHNlc3Npb24sIFtkYXRhXS5jb25jYXQoYXJncykpO1xuICAgIH0pO1xuICAgIChfdGhpcyRfb25DaGFuZ2UyID0gdGhpcy5fb25DaGFuZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRfb25DaGFuZ2UyLmNhbGwodGhpcywgdGhpcywgXCJzZXNzaW9uOnVwZGF0ZTpcIiArIHNlc3Npb24uaWQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5jYW5jZWxTZXNzaW9uID0gZnVuY3Rpb24gY2FuY2VsU2Vzc2lvbigpIHtcbiAgICB2YXIgX3RoaXMkX29uQ2hhbmdlMztcblxuICAgIGZvciAodmFyIF9sZW41ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNSksIF9rZXk1ID0gMDsgX2tleTUgPCBfbGVuNTsgX2tleTUrKykge1xuICAgICAgYXJnc1tfa2V5NV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICAgIH1cblxuICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgIGlmICghc2Vzc2lvbikgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgcmV0dXJuIHNlc3Npb24uY2FuY2VsLmFwcGx5KHNlc3Npb24sIFtkYXRhXS5jb25jYXQoYXJncykpO1xuICAgIH0pO1xuICAgIHRoaXMuc2V0U3RhdHVzKCdpZGxlJyk7XG4gICAgdGhpcy5zZXNzaW9uID0gdW5kZWZpbmVkO1xuICAgIChfdGhpcyRfb25DaGFuZ2UzID0gdGhpcy5fb25DaGFuZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRfb25DaGFuZ2UzLmNhbGwodGhpcywgdGhpcywgXCJzZXNzaW9uOmNhbmNlbDpcIiArIHNlc3Npb24uaWQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5jb21wbGV0ZVNlc3Npb24gPSBmdW5jdGlvbiBjb21wbGV0ZVNlc3Npb24oKSB7XG4gICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG4gICAgaWYgKCFzZXNzaW9uKSByZXR1cm4gdGhpcztcbiAgICB0aGlzLnNldFN0YXR1cygnaWRsZScpO1xuXG4gICAgZm9yICh2YXIgX2xlbjYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42KSwgX2tleTYgPSAwOyBfa2V5NiA8IF9sZW42OyBfa2V5NisrKSB7XG4gICAgICBhcmdzW19rZXk2XSA9IGFyZ3VtZW50c1tfa2V5Nl07XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IHNlc3Npb24uY29tcGxldGUuYXBwbHkoc2Vzc2lvbiwgW3RoaXMuc3RvcmUuZ2V0U3RhdGUoKV0uY29uY2F0KGFyZ3MpKTtcblxuICAgIGlmICgnYWZ0ZXInIGluIHJlc3VsdCkge1xuICAgICAgdGhpc1tcImRvXCJdKHJlc3VsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfdGhpcyRfb25DaGFuZ2U0O1xuXG4gICAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBjb3JlLlV0aWxzLmRlZXBNZXJnZShkYXRhLCByZXN1bHQpO1xuICAgICAgfSk7XG4gICAgICAoX3RoaXMkX29uQ2hhbmdlNCA9IHRoaXMuX29uQ2hhbmdlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkX29uQ2hhbmdlNC5jYWxsKHRoaXMsIHRoaXMsIFwic2Vzc2lvbjpjb21wbGV0ZTpcIiArIHNlc3Npb24uaWQpO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyRhcHBTdGF0ZSA9IHRoaXMuYXBwU3RhdGUsXG4gICAgICAgIGlzVG9vbExvY2tlZCA9IF90aGlzJGFwcFN0YXRlLmlzVG9vbExvY2tlZCxcbiAgICAgICAgYWN0aXZlVG9vbCA9IF90aGlzJGFwcFN0YXRlLmFjdGl2ZVRvb2w7XG5cbiAgICBpZiAoIWlzVG9vbExvY2tlZCAmJiBhY3RpdmVUb29sICE9PSAnZHJhdycpIHtcbiAgICAgIHRoaXMuc2VsZWN0VG9vbCgnc2VsZWN0Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXNzaW9uID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tIENvbW1hbmRzIC0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gIDtcblxuICBfcHJvdG9bXCJkb1wiXSA9IGZ1bmN0aW9uIF9kbyhjb21tYW5kKSB7XG4gICAgdmFyIF90aGlzJF9vbkNoYW5nZTU7XG5cbiAgICB2YXIgaGlzdG9yeSA9IHRoaXMuaGlzdG9yeTtcblxuICAgIGlmIChoaXN0b3J5LnBvaW50ZXIgIT09IGhpc3Rvcnkuc3RhY2subGVuZ3RoIC0gMSkge1xuICAgICAgaGlzdG9yeS5zdGFjayA9IGhpc3Rvcnkuc3RhY2suc2xpY2UoMCwgaGlzdG9yeS5wb2ludGVyICsgMSk7XG4gICAgfVxuXG4gICAgaGlzdG9yeS5zdGFjay5wdXNoKGNvbW1hbmQpO1xuICAgIGhpc3RvcnkucG9pbnRlciA9IGhpc3Rvcnkuc3RhY2subGVuZ3RoIC0gMTtcbiAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICByZXR1cm4gY29yZS5VdGlscy5kZWVwTWVyZ2UoZGF0YSwgaGlzdG9yeS5zdGFja1toaXN0b3J5LnBvaW50ZXJdLmFmdGVyKTtcbiAgICB9KTtcbiAgICAoX3RoaXMkX29uQ2hhbmdlNSA9IHRoaXMuX29uQ2hhbmdlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkX29uQ2hhbmdlNS5jYWxsKHRoaXMsIHRoaXMsIFwiY29tbWFuZDpcIiArIGNvbW1hbmQuaWQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tIFNlbGVjdGlvbiAtLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gIF9wcm90by5zZXRTZWxlY3RlZElkcyA9IGZ1bmN0aW9uIHNldFNlbGVjdGVkSWRzKGlkcywgcHVzaCkge1xuICAgIGlmIChwdXNoID09PSB2b2lkIDApIHtcbiAgICAgIHB1c2ggPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYWdlU3RhdGU6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2VTdGF0ZSwge1xuICAgICAgICAgIHNlbGVjdGVkSWRzOiBwdXNoID8gW10uY29uY2F0KGRhdGEucGFnZVN0YXRlLnNlbGVjdGVkSWRzLCBpZHMpIDogW10uY29uY2F0KGlkcylcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLmNyZWF0ZUFjdGl2ZVRvb2xTaGFwZSA9IGZ1bmN0aW9uIGNyZWF0ZUFjdGl2ZVRvb2xTaGFwZShwb2ludCkge1xuICAgIHZhciBpZCA9IGNvcmUuVXRpbHMudW5pcXVlSWQoKTtcbiAgICB2YXIgcGFnZVBvaW50ID0gY29yZS5WZWMucm91bmQodGhpcy5nZXRQYWdlUG9pbnQocG9pbnQpKTtcbiAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB2YXIgX2V4dGVuZHMyO1xuXG4gICAgICB2YXIgX2RhdGEkYXBwU3RhdGUgPSBkYXRhLmFwcFN0YXRlLFxuICAgICAgICAgIGFjdGl2ZVRvb2wgPSBfZGF0YSRhcHBTdGF0ZS5hY3RpdmVUb29sLFxuICAgICAgICAgIGFjdGl2ZVRvb2xUeXBlID0gX2RhdGEkYXBwU3RhdGUuYWN0aXZlVG9vbFR5cGU7XG4gICAgICBpZiAoYWN0aXZlVG9vbCA9PT0gJ3NlbGVjdCcpIHJldHVybiBkYXRhO1xuICAgICAgaWYgKCFhY3RpdmVUb29sVHlwZSkgdGhyb3cgRXJyb3I7XG4gICAgICB2YXIgdXRpbHMgPSBUTERSLmdldFNoYXBlVXRpbHMoe1xuICAgICAgICB0eXBlOiBhY3RpdmVUb29sXG4gICAgICB9KTtcbiAgICAgIHZhciBzaGFwZXMgPSBPYmplY3QudmFsdWVzKGRhdGEucGFnZS5zaGFwZXMpO1xuICAgICAgdmFyIGNoaWxkSW5kZXggPSBzaGFwZXMubGVuZ3RoID09PSAwID8gMSA6IHNoYXBlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBiLmNoaWxkSW5kZXggLSBhLmNoaWxkSW5kZXg7XG4gICAgICB9KVswXS5jaGlsZEluZGV4ICsgMTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhZ2U6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2UsIHtcbiAgICAgICAgICBzaGFwZXM6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2Uuc2hhcGVzLCAoX2V4dGVuZHMyID0ge30sIF9leHRlbmRzMltpZF0gPSB1dGlscy5jcmVhdGUoe1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgcGFyZW50SWQ6IGRhdGEucGFnZS5pZCxcbiAgICAgICAgICAgIGNoaWxkSW5kZXg6IGNoaWxkSW5kZXgsXG4gICAgICAgICAgICBwb2ludDogcGFnZVBvaW50LFxuICAgICAgICAgICAgc3R5bGU6IF9leHRlbmRzKHt9LCBkYXRhLmFwcFN0YXRlLmN1cnJlbnRTdHlsZSlcbiAgICAgICAgICB9KSwgX2V4dGVuZHMyKSlcbiAgICAgICAgfSksXG4gICAgICAgIHBhZ2VTdGF0ZTogX2V4dGVuZHMoe30sIGRhdGEucGFnZVN0YXRlLCB7XG4gICAgICAgICAgc2VsZWN0ZWRJZHM6IFtpZF1cbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICB2YXIgX3RoaXMkZ2V0QXBwU3RhdGUgPSB0aGlzLmdldEFwcFN0YXRlKCksXG4gICAgICAgIGFjdGl2ZVRvb2wgPSBfdGhpcyRnZXRBcHBTdGF0ZS5hY3RpdmVUb29sLFxuICAgICAgICBhY3RpdmVUb29sVHlwZSA9IF90aGlzJGdldEFwcFN0YXRlLmFjdGl2ZVRvb2xUeXBlO1xuXG4gICAgc3dpdGNoIChhY3RpdmVUb29sVHlwZSkge1xuICAgICAgY2FzZSAnZHJhdyc6XG4gICAgICAgIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0RHJhd1Nlc3Npb24oaWQsIHBhZ2VQb2ludCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnYm91bmRzJzpcbiAgICAgICAge1xuICAgICAgICAgIHRoaXMuc3RhcnRUcmFuc2Zvcm1TZXNzaW9uKHBhZ2VQb2ludCwgY29yZS5UTEJvdW5kc0Nvcm5lci5Cb3R0b21SaWdodCwgXCJjcmVhdGVfXCIgKyBhY3RpdmVUb29sKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdoYW5kbGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5zdGFydEhhbmRsZVNlc3Npb24ocGFnZVBvaW50LCAnZW5kJywgXCJjcmVhdGVfXCIgKyBhY3RpdmVUb29sKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0gRXZlbnRzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuICA7XG5cbiAgX2NyZWF0ZUNsYXNzKFRMRHJhd1N0YXRlLCBbe1xuICAgIGtleTogXCJkb2N1bWVudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IHRoaXMuY3VycmVudERvY3VtZW50SWQsXG4gICAgICAgIHBhZ2VzOiB0aGlzLnBhZ2VzLFxuICAgICAgICBwYWdlU3RhdGVzOiB0aGlzLnBhZ2VTdGF0ZXNcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRhdGFcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFN0YXRlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlbGVjdGVkSWRzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYWdlU3RhdGUuc2VsZWN0ZWRJZHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhZ2VcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhZ2VzW3RoaXMuY3VycmVudFBhZ2VJZF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhZ2VTdGF0ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFnZVN0YXRlc1t0aGlzLmN1cnJlbnRQYWdlSWRdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBTdGF0ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YS5hcHBTdGF0ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVExEcmF3U3RhdGU7XG59KCk7XG5cbnZhciBoaWRlQm91bmRzU2VsZWN0b3IgPSBmdW5jdGlvbiBoaWRlQm91bmRzU2VsZWN0b3Iocykge1xuICByZXR1cm4gcy5hcHBTdGF0ZS5hY3RpdmVUb29sICE9PSAnc2VsZWN0JyB8fCBzLnBhZ2VTdGF0ZS5zZWxlY3RlZElkcy5sZW5ndGggPT09IDEgJiYgcy5wYWdlU3RhdGUuc2VsZWN0ZWRJZHMuZXZlcnkoZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIHMucGFnZS5zaGFwZXNbaWRdLmhhbmRsZXMgIT09IHVuZGVmaW5lZDtcbiAgfSk7XG59O1xuXG52YXIgcGFnZVNlbGVjdG9yID0gZnVuY3Rpb24gcGFnZVNlbGVjdG9yKHMpIHtcbiAgcmV0dXJuIHMucGFnZTtcbn07XG5cbnZhciBwYWdlU3RhdGVTZWxlY3RvciA9IGZ1bmN0aW9uIHBhZ2VTdGF0ZVNlbGVjdG9yKHMpIHtcbiAgcmV0dXJuIHMucGFnZVN0YXRlO1xufTtcblxuZnVuY3Rpb24gVExEcmF3KF9yZWYpIHtcbiAgdmFyIGRvY3VtZW50ID0gX3JlZi5kb2N1bWVudCxcbiAgICAgIGN1cnJlbnRQYWdlSWQgPSBfcmVmLmN1cnJlbnRQYWdlSWQsXG4gICAgICBvbk1vdW50ID0gX3JlZi5vbk1vdW50LFxuICAgICAgX29uQ2hhbmdlID0gX3JlZi5vbkNoYW5nZTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgVExEcmF3U3RhdGUoKTtcbiAgfSksXG4gICAgICB0bHN0YXRlID0gX1JlYWN0JHVzZVN0YXRlWzBdO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUyID0gUmVhY3QudXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0bHN0YXRlOiB0bHN0YXRlLFxuICAgICAgdXNlQXBwU3RhdGU6IHRsc3RhdGUuc3RvcmVcbiAgICB9O1xuICB9KSxcbiAgICAgIGNvbnRleHQgPSBfUmVhY3QkdXNlU3RhdGUyWzBdO1xuXG4gIHVzZUtleWJvYXJkU2hvcnRjdXRzKHRsc3RhdGUpO1xuICB2YXIgaGlkZUJvdW5kcyA9IGNvbnRleHQudXNlQXBwU3RhdGUoaGlkZUJvdW5kc1NlbGVjdG9yKTtcbiAgdmFyIHBhZ2UgPSBjb250ZXh0LnVzZUFwcFN0YXRlKHBhZ2VTZWxlY3Rvcik7XG4gIHZhciBwYWdlU3RhdGUgPSBjb250ZXh0LnVzZUFwcFN0YXRlKHBhZ2VTdGF0ZVNlbGVjdG9yKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWRvY3VtZW50KSByZXR1cm47XG4gICAgdGxzdGF0ZS5sb2FkRG9jdW1lbnQoZG9jdW1lbnQsIF9vbkNoYW5nZSk7XG4gIH0sIFtkb2N1bWVudCwgdGxzdGF0ZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICghY3VycmVudFBhZ2VJZCkgcmV0dXJuO1xuICAgIHRsc3RhdGUuc2V0Q3VycmVudFBhZ2VJZChjdXJyZW50UGFnZUlkKTtcbiAgfSwgW2N1cnJlbnRQYWdlSWQsIHRsc3RhdGVdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBvbk1vdW50ID09IG51bGwgPyB2b2lkIDAgOiBvbk1vdW50KHRsc3RhdGUpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtdKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVExEcmF3Q29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3RJZC5JZFByb3ZpZGVyLCBudWxsLCBSZWFjdC5jcmVhdGVFbGVtZW50KExheW91dCwgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0TWVudSwgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChjb3JlLlJlbmRlcmVyLCB7XG4gICAgcGFnZTogcGFnZSxcbiAgICBwYWdlU3RhdGU6IHBhZ2VTdGF0ZSxcbiAgICBzaGFwZVV0aWxzOiB0bGRyYXdTaGFwZVV0aWxzLFxuICAgIGhpZGVCb3VuZHM6IGhpZGVCb3VuZHMsXG4gICAgb25QaW5jaFN0YXJ0OiB0bHN0YXRlLm9uUGluY2hTdGFydCxcbiAgICBvblBpbmNoRW5kOiB0bHN0YXRlLm9uUGluY2hFbmQsXG4gICAgb25QaW5jaDogdGxzdGF0ZS5vblBpbmNoLFxuICAgIG9uUGFuOiB0bHN0YXRlLm9uUGFuLFxuICAgIG9uWm9vbTogdGxzdGF0ZS5vblpvb20sXG4gICAgb25Qb2ludGVyRG93bjogdGxzdGF0ZS5vblBvaW50ZXJEb3duLFxuICAgIG9uUG9pbnRlck1vdmU6IHRsc3RhdGUub25Qb2ludGVyTW92ZSxcbiAgICBvblBvaW50ZXJVcDogdGxzdGF0ZS5vblBvaW50ZXJVcCxcbiAgICBvblBvaW50Q2FudmFzOiB0bHN0YXRlLm9uUG9pbnRDYW52YXMsXG4gICAgb25Eb3VibGVDbGlja0NhbnZhczogdGxzdGF0ZS5vbkRvdWJsZUNsaWNrQ2FudmFzLFxuICAgIG9uUmlnaHRQb2ludENhbnZhczogdGxzdGF0ZS5vblJpZ2h0UG9pbnRDYW52YXMsXG4gICAgb25EcmFnQ2FudmFzOiB0bHN0YXRlLm9uRHJhZ0NhbnZhcyxcbiAgICBvblJlbGVhc2VDYW52YXM6IHRsc3RhdGUub25SZWxlYXNlQ2FudmFzLFxuICAgIG9uUG9pbnRTaGFwZTogdGxzdGF0ZS5vblBvaW50U2hhcGUsXG4gICAgb25Eb3VibGVDbGlja1NoYXBlOiB0bHN0YXRlLm9uRG91YmxlQ2xpY2tTaGFwZSxcbiAgICBvblJpZ2h0UG9pbnRTaGFwZTogdGxzdGF0ZS5vblJpZ2h0UG9pbnRTaGFwZSxcbiAgICBvbkRyYWdTaGFwZTogdGxzdGF0ZS5vbkRyYWdTaGFwZSxcbiAgICBvbkhvdmVyU2hhcGU6IHRsc3RhdGUub25Ib3ZlclNoYXBlLFxuICAgIG9uVW5ob3ZlclNoYXBlOiB0bHN0YXRlLm9uVW5ob3ZlclNoYXBlLFxuICAgIG9uUmVsZWFzZVNoYXBlOiB0bHN0YXRlLm9uUmVsZWFzZVNoYXBlLFxuICAgIG9uUG9pbnRCb3VuZHM6IHRsc3RhdGUub25Qb2ludEJvdW5kcyxcbiAgICBvbkRvdWJsZUNsaWNrQm91bmRzOiB0bHN0YXRlLm9uRG91YmxlQ2xpY2tCb3VuZHMsXG4gICAgb25SaWdodFBvaW50Qm91bmRzOiB0bHN0YXRlLm9uUmlnaHRQb2ludEJvdW5kcyxcbiAgICBvbkRyYWdCb3VuZHM6IHRsc3RhdGUub25EcmFnQm91bmRzLFxuICAgIG9uSG92ZXJCb3VuZHM6IHRsc3RhdGUub25Ib3ZlckJvdW5kcyxcbiAgICBvblVuaG92ZXJCb3VuZHM6IHRsc3RhdGUub25VbmhvdmVyQm91bmRzLFxuICAgIG9uUmVsZWFzZUJvdW5kczogdGxzdGF0ZS5vblJlbGVhc2VCb3VuZHMsXG4gICAgb25Qb2ludEJvdW5kc0hhbmRsZTogdGxzdGF0ZS5vblBvaW50Qm91bmRzSGFuZGxlLFxuICAgIG9uRG91YmxlQ2xpY2tCb3VuZHNIYW5kbGU6IHRsc3RhdGUub25Eb3VibGVDbGlja0JvdW5kc0hhbmRsZSxcbiAgICBvblJpZ2h0UG9pbnRCb3VuZHNIYW5kbGU6IHRsc3RhdGUub25SaWdodFBvaW50Qm91bmRzSGFuZGxlLFxuICAgIG9uRHJhZ0JvdW5kc0hhbmRsZTogdGxzdGF0ZS5vbkRyYWdCb3VuZHNIYW5kbGUsXG4gICAgb25Ib3ZlckJvdW5kc0hhbmRsZTogdGxzdGF0ZS5vbkhvdmVyQm91bmRzSGFuZGxlLFxuICAgIG9uVW5ob3ZlckJvdW5kc0hhbmRsZTogdGxzdGF0ZS5vblVuaG92ZXJCb3VuZHNIYW5kbGUsXG4gICAgb25SZWxlYXNlQm91bmRzSGFuZGxlOiB0bHN0YXRlLm9uUmVsZWFzZUJvdW5kc0hhbmRsZSxcbiAgICBvblBvaW50SGFuZGxlOiB0bHN0YXRlLm9uUG9pbnRIYW5kbGUsXG4gICAgb25Eb3VibGVDbGlja0hhbmRsZTogdGxzdGF0ZS5vbkRvdWJsZUNsaWNrSGFuZGxlLFxuICAgIG9uUmlnaHRQb2ludEhhbmRsZTogdGxzdGF0ZS5vblJpZ2h0UG9pbnRIYW5kbGUsXG4gICAgb25EcmFnSGFuZGxlOiB0bHN0YXRlLm9uRHJhZ0hhbmRsZSxcbiAgICBvbkhvdmVySGFuZGxlOiB0bHN0YXRlLm9uSG92ZXJIYW5kbGUsXG4gICAgb25VbmhvdmVySGFuZGxlOiB0bHN0YXRlLm9uVW5ob3ZlckhhbmRsZSxcbiAgICBvblJlbGVhc2VIYW5kbGU6IHRsc3RhdGUub25SZWxlYXNlSGFuZGxlLFxuICAgIG9uQ2hhbmdlOiB0bHN0YXRlLm9uQ2hhbmdlLFxuICAgIG9uRXJyb3I6IHRsc3RhdGUub25FcnJvcixcbiAgICBvbkJsdXJFZGl0aW5nU2hhcGU6IHRsc3RhdGUub25CbHVyRWRpdGluZ1NoYXBlXG4gIH0pKSwgUmVhY3QuY3JlYXRlRWxlbWVudChTcGFjZXIsIG51bGwpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFN0eWxlUGFuZWwsIG51bGwpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFRvb2xzUGFuZWwsIG51bGwpKSkpO1xufVxudmFyIFNwYWNlciA9IC8qI19fUFVSRV9fKi9zdHlsZWQoJ2RpdicsIHtcbiAgZmxleEdyb3c6IDJcbn0pOyAvLyBjb25zdCBNZW51QnV0dG9ucyA9IHN0eWxlZCgnZGl2Jywge1xuLy8gICBkaXNwbGF5OiAnZmxleCcsXG4vLyAgIGdhcDogOCxcbi8vIH0pXG5cbnZhciBMYXlvdXQgPSAvKiNfX1BVUkVfXyovc3R5bGVkKCdtYWluJywge1xuICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICB0b3A6IDAsXG4gIGxlZnQ6IDAsXG4gIGJvdHRvbTogMCxcbiAgcmlnaHQ6IDAsXG4gIGhlaWdodDogJzEwMCUnLFxuICB3aWR0aDogJzEwMCUnLFxuICBwYWRkaW5nOiAnOHB4IDhweCAwIDhweCcsXG4gIHpJbmRleDogMjAwLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIGFsaWduSXRlbXM6ICdmbGV4LXN0YXJ0JyxcbiAganVzdGlmeUNvbnRlbnQ6ICdmbGV4LXN0YXJ0JyxcbiAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gIG91dGxpbmU6ICdub25lJyxcbiAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAnJiA+IConOiB7XG4gICAgcG9pbnRlckV2ZW50czogJ2FsbCdcbiAgfSxcbiAgJyYgLnRsLWNvbnRhaW5lcic6IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMFxuICB9XG59KTtcblxuZXhwb3J0cy5UTERyYXcgPSBUTERyYXc7XG5leHBvcnRzLlRMRHJhd1NoYXBlVXRpbCA9IFRMRHJhd1NoYXBlVXRpbDtcbmV4cG9ydHMuVExEcmF3U3RhdGUgPSBUTERyYXdTdGF0ZTtcbmV4cG9ydHMuY3JlYXRlU2hhcGUgPSBjcmVhdGVTaGFwZTtcbmV4cG9ydHMuZGVmYXVsdFN0eWxlID0gZGVmYXVsdFN0eWxlO1xuZXhwb3J0cy5maWxscyA9IGZpbGxzO1xuZXhwb3J0cy5nZXRGb250U2l6ZSA9IGdldEZvbnRTaXplO1xuZXhwb3J0cy5nZXRGb250U3R5bGUgPSBnZXRGb250U3R5bGU7XG5leHBvcnRzLmdldFBlcmZlY3REYXNoUHJvcHMgPSBnZXRQZXJmZWN0RGFzaFByb3BzO1xuZXhwb3J0cy5nZXRTaGFwZVN0eWxlID0gZ2V0U2hhcGVTdHlsZTtcbmV4cG9ydHMuZ2V0U2hhcGVVdGlscyA9IGdldFNoYXBlVXRpbHM7XG5leHBvcnRzLmdldFN0cm9rZVdpZHRoID0gZ2V0U3Ryb2tlV2lkdGg7XG5leHBvcnRzLnN0cm9rZXMgPSBzdHJva2VzO1xuZXhwb3J0cy50bGRyYXdTaGFwZVV0aWxzID0gdGxkcmF3U2hhcGVVdGlscztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRsZHJhdy5janMuZGV2ZWxvcG1lbnQuanMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../packages/tldraw/dist/tldraw.cjs.development.js\n");

/***/ })

};
;