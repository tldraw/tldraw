/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "components_editor_tsx";
exports.ids = ["components_editor_tsx"];
exports.modules = {

/***/ "./components/editor.tsx":
/*!*******************************!*\
  !*** ./components/editor.tsx ***!
  \*******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Editor; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _tldraw_tldraw__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tldraw/tldraw */ \"../packages/tldraw/dist/index.js\");\n/* harmony import */ var _tldraw_tldraw__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_tldraw_tldraw__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _hooks_usePersistence__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../hooks/usePersistence */ \"./hooks/usePersistence.tsx\");\n\nvar _jsxFileName = \"/Users/steve/Developer/Github/tldraw/www/components/editor.tsx\";\n\n\n\n\nconst initialDoc = {\n  id: 'doc',\n  pages: {\n    page1: {\n      id: 'page1',\n      shapes: {\n        rect1: {\n          id: 'rect1',\n          parentId: 'page1',\n          name: 'Rectangle',\n          childIndex: 1,\n          type: _tldraw_tldraw__WEBPACK_IMPORTED_MODULE_2__.TLDrawShapeType.Rectangle,\n          point: [32, 32],\n          size: [100, 100],\n          style: {\n            dash: _tldraw_tldraw__WEBPACK_IMPORTED_MODULE_2__.DashStyle.Draw,\n            size: _tldraw_tldraw__WEBPACK_IMPORTED_MODULE_2__.SizeStyle.Medium,\n            color: _tldraw_tldraw__WEBPACK_IMPORTED_MODULE_2__.ColorStyle.Blue\n          }\n        },\n        ellipse1: {\n          id: 'ellipse1',\n          parentId: 'page1',\n          name: 'Ellipse',\n          childIndex: 2,\n          type: _tldraw_tldraw__WEBPACK_IMPORTED_MODULE_2__.TLDrawShapeType.Ellipse,\n          point: [132, 132],\n          radius: [50, 50],\n          style: {\n            dash: _tldraw_tldraw__WEBPACK_IMPORTED_MODULE_2__.DashStyle.Draw,\n            size: _tldraw_tldraw__WEBPACK_IMPORTED_MODULE_2__.SizeStyle.Medium,\n            color: _tldraw_tldraw__WEBPACK_IMPORTED_MODULE_2__.ColorStyle.Cyan\n          }\n        },\n        draw1: {\n          id: 'draw1',\n          parentId: 'page1',\n          name: 'Draw',\n          childIndex: 3,\n          type: _tldraw_tldraw__WEBPACK_IMPORTED_MODULE_2__.TLDrawShapeType.Draw,\n          point: [232, 232],\n          points: [[50, 0], [100, 100], [0, 100], [50, 0], [100, 100], [0, 100], [50, 0], [56, 5]],\n          style: {\n            dash: _tldraw_tldraw__WEBPACK_IMPORTED_MODULE_2__.DashStyle.Draw,\n            size: _tldraw_tldraw__WEBPACK_IMPORTED_MODULE_2__.SizeStyle.Medium,\n            color: _tldraw_tldraw__WEBPACK_IMPORTED_MODULE_2__.ColorStyle.Green\n          }\n        }\n      },\n      bindings: {}\n    }\n  },\n  pageStates: {\n    page1: {\n      id: 'page1',\n      selectedIds: [],\n      currentParentId: 'page1',\n      camera: {\n        point: [0, 0],\n        zoom: 1\n      }\n    }\n  }\n};\nfunction Editor() {\n  const {\n    value,\n    setValue,\n    status\n  } = (0,_hooks_usePersistence__WEBPACK_IMPORTED_MODULE_3__.usePersistence)('doc', initialDoc);\n  const handleChange = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((tlstate, reason) => {\n    if (reason.startsWith('session')) {\n      return;\n    }\n\n    setValue(tlstate.document);\n  }, [setValue]);\n\n  if (status === 'loading' || value === null) {\n    return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 95,\n      columnNumber: 12\n    }, this);\n  }\n\n  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_tldraw_tldraw__WEBPACK_IMPORTED_MODULE_2__.TLDraw, {\n    document: value,\n    onChange: handleChange\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 98,\n    columnNumber: 10\n  }, this);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdGxkcmF3L3d3dy8uL2NvbXBvbmVudHMvZWRpdG9yLnRzeD84NWFkIl0sIm5hbWVzIjpbImluaXRpYWxEb2MiLCJpZCIsInBhZ2VzIiwicGFnZTEiLCJzaGFwZXMiLCJyZWN0MSIsInBhcmVudElkIiwibmFtZSIsImNoaWxkSW5kZXgiLCJ0eXBlIiwiVExEcmF3U2hhcGVUeXBlIiwicG9pbnQiLCJzaXplIiwic3R5bGUiLCJkYXNoIiwiRGFzaFN0eWxlIiwiU2l6ZVN0eWxlIiwiY29sb3IiLCJDb2xvclN0eWxlIiwiQmx1ZSIsImVsbGlwc2UxIiwicmFkaXVzIiwiQ3lhbiIsImRyYXcxIiwicG9pbnRzIiwiR3JlZW4iLCJiaW5kaW5ncyIsInBhZ2VTdGF0ZXMiLCJzZWxlY3RlZElkcyIsImN1cnJlbnRQYXJlbnRJZCIsImNhbWVyYSIsInpvb20iLCJFZGl0b3IiLCJ2YWx1ZSIsInNldFZhbHVlIiwic3RhdHVzIiwidXNlUGVyc2lzdGVuY2UiLCJoYW5kbGVDaGFuZ2UiLCJSZWFjdCIsInRsc3RhdGUiLCJyZWFzb24iLCJzdGFydHNXaXRoIiwiZG9jdW1lbnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBLE1BQU1BLFVBQTBCLEdBQUc7QUFDakNDLElBQUUsRUFBRSxLQUQ2QjtBQUVqQ0MsT0FBSyxFQUFFO0FBQ0xDLFNBQUssRUFBRTtBQUNMRixRQUFFLEVBQUUsT0FEQztBQUVMRyxZQUFNLEVBQUU7QUFDTkMsYUFBSyxFQUFFO0FBQ0xKLFlBQUUsRUFBRSxPQURDO0FBRUxLLGtCQUFRLEVBQUUsT0FGTDtBQUdMQyxjQUFJLEVBQUUsV0FIRDtBQUlMQyxvQkFBVSxFQUFFLENBSlA7QUFLTEMsY0FBSSxFQUFFQyxxRUFMRDtBQU1MQyxlQUFLLEVBQUUsQ0FBQyxFQUFELEVBQUssRUFBTCxDQU5GO0FBT0xDLGNBQUksRUFBRSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBUEQ7QUFRTEMsZUFBSyxFQUFFO0FBQ0xDLGdCQUFJLEVBQUVDLDBEQUREO0FBRUxILGdCQUFJLEVBQUVJLDREQUZEO0FBR0xDLGlCQUFLLEVBQUVDLDJEQUFlQztBQUhqQjtBQVJGLFNBREQ7QUFlTkMsZ0JBQVEsRUFBRTtBQUNSbkIsWUFBRSxFQUFFLFVBREk7QUFFUkssa0JBQVEsRUFBRSxPQUZGO0FBR1JDLGNBQUksRUFBRSxTQUhFO0FBSVJDLG9CQUFVLEVBQUUsQ0FKSjtBQUtSQyxjQUFJLEVBQUVDLG1FQUxFO0FBTVJDLGVBQUssRUFBRSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBTkM7QUFPUlUsZ0JBQU0sRUFBRSxDQUFDLEVBQUQsRUFBSyxFQUFMLENBUEE7QUFRUlIsZUFBSyxFQUFFO0FBQ0xDLGdCQUFJLEVBQUVDLDBEQUREO0FBRUxILGdCQUFJLEVBQUVJLDREQUZEO0FBR0xDLGlCQUFLLEVBQUVDLDJEQUFlSTtBQUhqQjtBQVJDLFNBZko7QUE2Qk5DLGFBQUssRUFBRTtBQUNMdEIsWUFBRSxFQUFFLE9BREM7QUFFTEssa0JBQVEsRUFBRSxPQUZMO0FBR0xDLGNBQUksRUFBRSxNQUhEO0FBSUxDLG9CQUFVLEVBQUUsQ0FKUDtBQUtMQyxjQUFJLEVBQUVDLGdFQUxEO0FBTUxDLGVBQUssRUFBRSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBTkY7QUFPTGEsZ0JBQU0sRUFBRSxDQUNOLENBQUMsRUFBRCxFQUFLLENBQUwsQ0FETSxFQUVOLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FGTSxFQUdOLENBQUMsQ0FBRCxFQUFJLEdBQUosQ0FITSxFQUlOLENBQUMsRUFBRCxFQUFLLENBQUwsQ0FKTSxFQUtOLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FMTSxFQU1OLENBQUMsQ0FBRCxFQUFJLEdBQUosQ0FOTSxFQU9OLENBQUMsRUFBRCxFQUFLLENBQUwsQ0FQTSxFQVFOLENBQUMsRUFBRCxFQUFLLENBQUwsQ0FSTSxDQVBIO0FBaUJMWCxlQUFLLEVBQUU7QUFDTEMsZ0JBQUksRUFBRUMsMERBREQ7QUFFTEgsZ0JBQUksRUFBRUksNERBRkQ7QUFHTEMsaUJBQUssRUFBRUMsNERBQWdCTztBQUhsQjtBQWpCRjtBQTdCRCxPQUZIO0FBdURMQyxjQUFRLEVBQUU7QUF2REw7QUFERixHQUYwQjtBQTZEakNDLFlBQVUsRUFBRTtBQUNWeEIsU0FBSyxFQUFFO0FBQ0xGLFFBQUUsRUFBRSxPQURDO0FBRUwyQixpQkFBVyxFQUFFLEVBRlI7QUFHTEMscUJBQWUsRUFBRSxPQUhaO0FBSUxDLFlBQU0sRUFBRTtBQUNObkIsYUFBSyxFQUFFLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FERDtBQUVOb0IsWUFBSSxFQUFFO0FBRkE7QUFKSDtBQURHO0FBN0RxQixDQUFuQztBQTBFZSxTQUFTQyxNQUFULEdBQWtCO0FBQy9CLFFBQU07QUFBRUMsU0FBRjtBQUFTQyxZQUFUO0FBQW1CQztBQUFuQixNQUE4QkMscUVBQWMsQ0FBQyxLQUFELEVBQVFwQyxVQUFSLENBQWxEO0FBRUEsUUFBTXFDLFlBQVksR0FBR0MsOENBQUEsQ0FDbkIsQ0FBQ0MsT0FBRCxFQUF1QkMsTUFBdkIsS0FBMEM7QUFDeEMsUUFBSUEsTUFBTSxDQUFDQyxVQUFQLENBQWtCLFNBQWxCLENBQUosRUFBa0M7QUFDaEM7QUFDRDs7QUFFRFAsWUFBUSxDQUFDSyxPQUFPLENBQUNHLFFBQVQsQ0FBUjtBQUNELEdBUGtCLEVBUW5CLENBQUNSLFFBQUQsQ0FSbUIsQ0FBckI7O0FBV0EsTUFBSUMsTUFBTSxLQUFLLFNBQVgsSUFBd0JGLEtBQUssS0FBSyxJQUF0QyxFQUE0QztBQUMxQyx3QkFBTztBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQVA7QUFDRDs7QUFFRCxzQkFBTyw4REFBQyxrREFBRDtBQUFRLFlBQVEsRUFBRUEsS0FBbEI7QUFBeUIsWUFBUSxFQUFFSTtBQUFuQztBQUFBO0FBQUE7QUFBQTtBQUFBLFVBQVA7QUFDRCIsImZpbGUiOiIuL2NvbXBvbmVudHMvZWRpdG9yLnRzeC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgQ29sb3JTdHlsZSwgRGFzaFN0eWxlLCBTaXplU3R5bGUsIFRMRHJhd1NoYXBlVHlwZSwgVExEcmF3U3RhdGUgfSBmcm9tICdAdGxkcmF3L3RsZHJhdydcbmltcG9ydCB7IFRMRHJhdywgVExEcmF3RG9jdW1lbnQgfSBmcm9tICdAdGxkcmF3L3RsZHJhdydcbmltcG9ydCB7IHVzZVBlcnNpc3RlbmNlIH0gZnJvbSAnLi4vaG9va3MvdXNlUGVyc2lzdGVuY2UnXG5cbmNvbnN0IGluaXRpYWxEb2M6IFRMRHJhd0RvY3VtZW50ID0ge1xuICBpZDogJ2RvYycsXG4gIHBhZ2VzOiB7XG4gICAgcGFnZTE6IHtcbiAgICAgIGlkOiAncGFnZTEnLFxuICAgICAgc2hhcGVzOiB7XG4gICAgICAgIHJlY3QxOiB7XG4gICAgICAgICAgaWQ6ICdyZWN0MScsXG4gICAgICAgICAgcGFyZW50SWQ6ICdwYWdlMScsXG4gICAgICAgICAgbmFtZTogJ1JlY3RhbmdsZScsXG4gICAgICAgICAgY2hpbGRJbmRleDogMSxcbiAgICAgICAgICB0eXBlOiBUTERyYXdTaGFwZVR5cGUuUmVjdGFuZ2xlLFxuICAgICAgICAgIHBvaW50OiBbMzIsIDMyXSxcbiAgICAgICAgICBzaXplOiBbMTAwLCAxMDBdLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBkYXNoOiBEYXNoU3R5bGUuRHJhdyxcbiAgICAgICAgICAgIHNpemU6IFNpemVTdHlsZS5NZWRpdW0sXG4gICAgICAgICAgICBjb2xvcjogQ29sb3JTdHlsZS5CbHVlLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGVsbGlwc2UxOiB7XG4gICAgICAgICAgaWQ6ICdlbGxpcHNlMScsXG4gICAgICAgICAgcGFyZW50SWQ6ICdwYWdlMScsXG4gICAgICAgICAgbmFtZTogJ0VsbGlwc2UnLFxuICAgICAgICAgIGNoaWxkSW5kZXg6IDIsXG4gICAgICAgICAgdHlwZTogVExEcmF3U2hhcGVUeXBlLkVsbGlwc2UsXG4gICAgICAgICAgcG9pbnQ6IFsxMzIsIDEzMl0sXG4gICAgICAgICAgcmFkaXVzOiBbNTAsIDUwXSxcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgZGFzaDogRGFzaFN0eWxlLkRyYXcsXG4gICAgICAgICAgICBzaXplOiBTaXplU3R5bGUuTWVkaXVtLFxuICAgICAgICAgICAgY29sb3I6IENvbG9yU3R5bGUuQ3lhbixcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBkcmF3MToge1xuICAgICAgICAgIGlkOiAnZHJhdzEnLFxuICAgICAgICAgIHBhcmVudElkOiAncGFnZTEnLFxuICAgICAgICAgIG5hbWU6ICdEcmF3JyxcbiAgICAgICAgICBjaGlsZEluZGV4OiAzLFxuICAgICAgICAgIHR5cGU6IFRMRHJhd1NoYXBlVHlwZS5EcmF3LFxuICAgICAgICAgIHBvaW50OiBbMjMyLCAyMzJdLFxuICAgICAgICAgIHBvaW50czogW1xuICAgICAgICAgICAgWzUwLCAwXSxcbiAgICAgICAgICAgIFsxMDAsIDEwMF0sXG4gICAgICAgICAgICBbMCwgMTAwXSxcbiAgICAgICAgICAgIFs1MCwgMF0sXG4gICAgICAgICAgICBbMTAwLCAxMDBdLFxuICAgICAgICAgICAgWzAsIDEwMF0sXG4gICAgICAgICAgICBbNTAsIDBdLFxuICAgICAgICAgICAgWzU2LCA1XSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBkYXNoOiBEYXNoU3R5bGUuRHJhdyxcbiAgICAgICAgICAgIHNpemU6IFNpemVTdHlsZS5NZWRpdW0sXG4gICAgICAgICAgICBjb2xvcjogQ29sb3JTdHlsZS5HcmVlbixcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIGJpbmRpbmdzOiB7fSxcbiAgICB9LFxuICB9LFxuICBwYWdlU3RhdGVzOiB7XG4gICAgcGFnZTE6IHtcbiAgICAgIGlkOiAncGFnZTEnLFxuICAgICAgc2VsZWN0ZWRJZHM6IFtdLFxuICAgICAgY3VycmVudFBhcmVudElkOiAncGFnZTEnLFxuICAgICAgY2FtZXJhOiB7XG4gICAgICAgIHBvaW50OiBbMCwgMF0sXG4gICAgICAgIHpvb206IDEsXG4gICAgICB9LFxuICAgIH0sXG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEVkaXRvcigpIHtcbiAgY29uc3QgeyB2YWx1ZSwgc2V0VmFsdWUsIHN0YXR1cyB9ID0gdXNlUGVyc2lzdGVuY2UoJ2RvYycsIGluaXRpYWxEb2MpXG5cbiAgY29uc3QgaGFuZGxlQ2hhbmdlID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKHRsc3RhdGU6IFRMRHJhd1N0YXRlLCByZWFzb246IHN0cmluZykgPT4ge1xuICAgICAgaWYgKHJlYXNvbi5zdGFydHNXaXRoKCdzZXNzaW9uJykpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHNldFZhbHVlKHRsc3RhdGUuZG9jdW1lbnQpXG4gICAgfSxcbiAgICBbc2V0VmFsdWVdXG4gIClcblxuICBpZiAoc3RhdHVzID09PSAnbG9hZGluZycgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gPGRpdiAvPlxuICB9XG5cbiAgcmV0dXJuIDxUTERyYXcgZG9jdW1lbnQ9e3ZhbHVlfSBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfSAvPlxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/editor.tsx\n");

/***/ }),

/***/ "./hooks/usePersistence.tsx":
/*!**********************************!*\
  !*** ./hooks/usePersistence.tsx ***!
  \**********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"usePersistence\": function() { return /* binding */ usePersistence; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! idb */ \"idb\");\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(idb__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nfunction getId(id) {\n  return '0.0.0-' + id;\n}\n\n/**\n * Persist a value in indexdb. This hook is designed to be used primarily through\n * its methods, `setValue` and `forceUpdate`. The `setValue` method will update the\n * value in the database, howeever it will NOT cause the hook's component to update.\n * The `forceUpdate` method will cause the component to update with the latest value\n * in the database.\n *\n * ### Example\n *\n *```ts\n * const {status, value, setValue, forceUpdate} = usePersistence()\n *```\n */\nfunction usePersistence(id, doc) {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const [status, setStatus] = react__WEBPACK_IMPORTED_MODULE_0__.useState('loading');\n  const [value, _setValue] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null); // A function that other parts of the program can use to manually update\n  // the state to the latest value in the database.\n\n  const forceUpdate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    _setValue(null);\n\n    setStatus('loading');\n    (0,idb__WEBPACK_IMPORTED_MODULE_1__.openDB)('db', 1).then(db => db.get('documents', id).then(v => {\n      if (!v) throw Error(`Could not find document with id: ${id}`);\n\n      _setValue(v);\n\n      setStatus('ready');\n    }));\n  }, [id]); // A function that other parts of the program can use to manually set the\n  // value in the database.\n\n  const setValue = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(doc => {\n    (0,idb__WEBPACK_IMPORTED_MODULE_1__.openDB)('db', 1).then(db => db.put('documents', doc, id));\n  }, [id]); // Whenever the id or doc changes, save the new value to the database and update\n  // the state.\n\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    async function handleLoad() {\n      const db = await (0,idb__WEBPACK_IMPORTED_MODULE_1__.openDB)('db', 1, {\n        upgrade(db) {\n          db.createObjectStore('documents');\n        }\n\n      });\n      let savedDoc;\n\n      try {\n        const restoredDoc = await db.get('documents', id);\n        if (!restoredDoc) throw Error('No document');\n        savedDoc = restoredDoc;\n      } catch (e) {\n        await db.put('documents', doc, id);\n        savedDoc = doc;\n      }\n\n      _setValue(savedDoc);\n\n      setStatus('ready');\n    }\n\n    handleLoad();\n  }, [id, doc]);\n  return {\n    value,\n    status,\n    setValue,\n    forceUpdate\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdGxkcmF3L3d3dy8uL2hvb2tzL3VzZVBlcnNpc3RlbmNlLnRzeD9hNWVlIl0sIm5hbWVzIjpbImdldElkIiwiaWQiLCJ1c2VQZXJzaXN0ZW5jZSIsImRvYyIsInN0YXR1cyIsInNldFN0YXR1cyIsIlJlYWN0IiwidmFsdWUiLCJfc2V0VmFsdWUiLCJmb3JjZVVwZGF0ZSIsIm9wZW5EQiIsInRoZW4iLCJkYiIsImdldCIsInYiLCJFcnJvciIsInNldFZhbHVlIiwicHV0IiwiaGFuZGxlTG9hZCIsInVwZ3JhZGUiLCJjcmVhdGVPYmplY3RTdG9yZSIsInNhdmVkRG9jIiwicmVzdG9yZWREb2MiLCJlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7O0FBR0EsU0FBU0EsS0FBVCxDQUFlQyxFQUFmLEVBQTJCO0FBQ3pCLFNBQU8sV0FBV0EsRUFBbEI7QUFDRDs7QUFTRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVNDLGNBQVQsQ0FBd0JELEVBQXhCLEVBQW9DRSxHQUFwQyxFQUF5RDtBQUM5RDtBQUNBLFFBQU0sQ0FBQ0MsTUFBRCxFQUFTQyxTQUFULElBQXNCQywyQ0FBQSxDQUFvQyxTQUFwQyxDQUE1QjtBQUNBLFFBQU0sQ0FBQ0MsS0FBRCxFQUFRQyxTQUFSLElBQXFCRiwyQ0FBQSxDQUFzQyxJQUF0QyxDQUEzQixDQUg4RCxDQUs5RDtBQUNBOztBQUNBLFFBQU1HLFdBQVcsR0FBR0gsOENBQUEsQ0FBa0IsTUFBTTtBQUMxQ0UsYUFBUyxDQUFDLElBQUQsQ0FBVDs7QUFDQUgsYUFBUyxDQUFDLFNBQUQsQ0FBVDtBQUVBSywrQ0FBTSxDQUFhLElBQWIsRUFBbUIsQ0FBbkIsQ0FBTixDQUE0QkMsSUFBNUIsQ0FBaUNDLEVBQUUsSUFDakNBLEVBQUUsQ0FBQ0MsR0FBSCxDQUFPLFdBQVAsRUFBb0JaLEVBQXBCLEVBQXdCVSxJQUF4QixDQUE2QkcsQ0FBQyxJQUFJO0FBQ2hDLFVBQUksQ0FBQ0EsQ0FBTCxFQUFRLE1BQU1DLEtBQUssQ0FBRSxvQ0FBbUNkLEVBQUcsRUFBeEMsQ0FBWDs7QUFDUk8sZUFBUyxDQUFDTSxDQUFELENBQVQ7O0FBQ0FULGVBQVMsQ0FBQyxPQUFELENBQVQ7QUFDRCxLQUpELENBREY7QUFPRCxHQVhtQixFQVdqQixDQUFDSixFQUFELENBWGlCLENBQXBCLENBUDhELENBb0I5RDtBQUNBOztBQUNBLFFBQU1lLFFBQVEsR0FBR1YsOENBQUEsQ0FDZEgsR0FBRCxJQUF5QjtBQUN2Qk8sK0NBQU0sQ0FBYSxJQUFiLEVBQW1CLENBQW5CLENBQU4sQ0FBNEJDLElBQTVCLENBQWlDQyxFQUFFLElBQUlBLEVBQUUsQ0FBQ0ssR0FBSCxDQUFPLFdBQVAsRUFBb0JkLEdBQXBCLEVBQXlCRixFQUF6QixDQUF2QztBQUNELEdBSGMsRUFJZixDQUFDQSxFQUFELENBSmUsQ0FBakIsQ0F0QjhELENBNkI5RDtBQUNBOztBQUNBSyw4Q0FBQSxDQUFnQixNQUFNO0FBQ3BCLG1CQUFlWSxVQUFmLEdBQTRCO0FBQzFCLFlBQU1OLEVBQUUsR0FBRyxNQUFNRiwyQ0FBTSxDQUFhLElBQWIsRUFBbUIsQ0FBbkIsRUFBc0I7QUFDM0NTLGVBQU8sQ0FBQ1AsRUFBRCxFQUFLO0FBQ1ZBLFlBQUUsQ0FBQ1EsaUJBQUgsQ0FBcUIsV0FBckI7QUFDRDs7QUFIMEMsT0FBdEIsQ0FBdkI7QUFNQSxVQUFJQyxRQUFKOztBQUVBLFVBQUk7QUFDRixjQUFNQyxXQUFXLEdBQUcsTUFBTVYsRUFBRSxDQUFDQyxHQUFILENBQU8sV0FBUCxFQUFvQlosRUFBcEIsQ0FBMUI7QUFDQSxZQUFJLENBQUNxQixXQUFMLEVBQWtCLE1BQU1QLEtBQUssQ0FBQyxhQUFELENBQVg7QUFDbEJNLGdCQUFRLEdBQUdDLFdBQVg7QUFDRCxPQUpELENBSUUsT0FBT0MsQ0FBUCxFQUFVO0FBQ1YsY0FBTVgsRUFBRSxDQUFDSyxHQUFILENBQU8sV0FBUCxFQUFvQmQsR0FBcEIsRUFBeUJGLEVBQXpCLENBQU47QUFDQW9CLGdCQUFRLEdBQUdsQixHQUFYO0FBQ0Q7O0FBRURLLGVBQVMsQ0FBQ2EsUUFBRCxDQUFUOztBQUNBaEIsZUFBUyxDQUFDLE9BQUQsQ0FBVDtBQUNEOztBQUVEYSxjQUFVO0FBQ1gsR0F4QkQsRUF3QkcsQ0FBQ2pCLEVBQUQsRUFBS0UsR0FBTCxDQXhCSDtBQTBCQSxTQUFPO0FBQUVJLFNBQUY7QUFBU0gsVUFBVDtBQUFpQlksWUFBakI7QUFBMkJQO0FBQTNCLEdBQVA7QUFDRCIsImZpbGUiOiIuL2hvb2tzL3VzZVBlcnNpc3RlbmNlLnRzeC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgb3BlbkRCLCBkZWxldGVEQiwgd3JhcCwgdW53cmFwLCBJREJQRGF0YWJhc2UsIERCU2NoZW1hIH0gZnJvbSAnaWRiJ1xuaW1wb3J0IHsgVExEcmF3RG9jdW1lbnQgfSBmcm9tICdAdGxkcmF3L3RsZHJhdydcblxuZnVuY3Rpb24gZ2V0SWQoaWQ6IHN0cmluZykge1xuICByZXR1cm4gJzAuMC4wLScgKyBpZFxufVxuXG5pbnRlcmZhY2UgVExEYXRhYmFzZSBleHRlbmRzIERCU2NoZW1hIHtcbiAgZG9jdW1lbnRzOiB7XG4gICAga2V5OiBzdHJpbmdcbiAgICB2YWx1ZTogVExEcmF3RG9jdW1lbnRcbiAgfVxufVxuXG4vKipcbiAqIFBlcnNpc3QgYSB2YWx1ZSBpbiBpbmRleGRiLiBUaGlzIGhvb2sgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBwcmltYXJpbHkgdGhyb3VnaFxuICogaXRzIG1ldGhvZHMsIGBzZXRWYWx1ZWAgYW5kIGBmb3JjZVVwZGF0ZWAuIFRoZSBgc2V0VmFsdWVgIG1ldGhvZCB3aWxsIHVwZGF0ZSB0aGVcbiAqIHZhbHVlIGluIHRoZSBkYXRhYmFzZSwgaG93ZWV2ZXIgaXQgd2lsbCBOT1QgY2F1c2UgdGhlIGhvb2sncyBjb21wb25lbnQgdG8gdXBkYXRlLlxuICogVGhlIGBmb3JjZVVwZGF0ZWAgbWV0aG9kIHdpbGwgY2F1c2UgdGhlIGNvbXBvbmVudCB0byB1cGRhdGUgd2l0aCB0aGUgbGF0ZXN0IHZhbHVlXG4gKiBpbiB0aGUgZGF0YWJhc2UuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKmBgYHRzXG4gKiBjb25zdCB7c3RhdHVzLCB2YWx1ZSwgc2V0VmFsdWUsIGZvcmNlVXBkYXRlfSA9IHVzZVBlcnNpc3RlbmNlKClcbiAqYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VQZXJzaXN0ZW5jZShpZDogc3RyaW5nLCBkb2M6IFRMRHJhd0RvY3VtZW50KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgY29uc3QgW3N0YXR1cywgc2V0U3RhdHVzXSA9IFJlYWN0LnVzZVN0YXRlPCdsb2FkaW5nJyB8ICdyZWFkeSc+KCdsb2FkaW5nJylcbiAgY29uc3QgW3ZhbHVlLCBfc2V0VmFsdWVdID0gUmVhY3QudXNlU3RhdGU8VExEcmF3RG9jdW1lbnQgfCBudWxsPihudWxsKVxuXG4gIC8vIEEgZnVuY3Rpb24gdGhhdCBvdGhlciBwYXJ0cyBvZiB0aGUgcHJvZ3JhbSBjYW4gdXNlIHRvIG1hbnVhbGx5IHVwZGF0ZVxuICAvLyB0aGUgc3RhdGUgdG8gdGhlIGxhdGVzdCB2YWx1ZSBpbiB0aGUgZGF0YWJhc2UuXG4gIGNvbnN0IGZvcmNlVXBkYXRlID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIF9zZXRWYWx1ZShudWxsKVxuICAgIHNldFN0YXR1cygnbG9hZGluZycpXG5cbiAgICBvcGVuREI8VExEYXRhYmFzZT4oJ2RiJywgMSkudGhlbihkYiA9PlxuICAgICAgZGIuZ2V0KCdkb2N1bWVudHMnLCBpZCkudGhlbih2ID0+IHtcbiAgICAgICAgaWYgKCF2KSB0aHJvdyBFcnJvcihgQ291bGQgbm90IGZpbmQgZG9jdW1lbnQgd2l0aCBpZDogJHtpZH1gKVxuICAgICAgICBfc2V0VmFsdWUodilcbiAgICAgICAgc2V0U3RhdHVzKCdyZWFkeScpXG4gICAgICB9KVxuICAgIClcbiAgfSwgW2lkXSlcblxuICAvLyBBIGZ1bmN0aW9uIHRoYXQgb3RoZXIgcGFydHMgb2YgdGhlIHByb2dyYW0gY2FuIHVzZSB0byBtYW51YWxseSBzZXQgdGhlXG4gIC8vIHZhbHVlIGluIHRoZSBkYXRhYmFzZS5cbiAgY29uc3Qgc2V0VmFsdWUgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoZG9jOiBUTERyYXdEb2N1bWVudCkgPT4ge1xuICAgICAgb3BlbkRCPFRMRGF0YWJhc2U+KCdkYicsIDEpLnRoZW4oZGIgPT4gZGIucHV0KCdkb2N1bWVudHMnLCBkb2MsIGlkKSlcbiAgICB9LFxuICAgIFtpZF1cbiAgKVxuXG4gIC8vIFdoZW5ldmVyIHRoZSBpZCBvciBkb2MgY2hhbmdlcywgc2F2ZSB0aGUgbmV3IHZhbHVlIHRvIHRoZSBkYXRhYmFzZSBhbmQgdXBkYXRlXG4gIC8vIHRoZSBzdGF0ZS5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBhc3luYyBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgY29uc3QgZGIgPSBhd2FpdCBvcGVuREI8VExEYXRhYmFzZT4oJ2RiJywgMSwge1xuICAgICAgICB1cGdyYWRlKGRiKSB7XG4gICAgICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoJ2RvY3VtZW50cycpXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBsZXQgc2F2ZWREb2M6IFRMRHJhd0RvY3VtZW50XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3RvcmVkRG9jID0gYXdhaXQgZGIuZ2V0KCdkb2N1bWVudHMnLCBpZClcbiAgICAgICAgaWYgKCFyZXN0b3JlZERvYykgdGhyb3cgRXJyb3IoJ05vIGRvY3VtZW50JylcbiAgICAgICAgc2F2ZWREb2MgPSByZXN0b3JlZERvY1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBhd2FpdCBkYi5wdXQoJ2RvY3VtZW50cycsIGRvYywgaWQpXG4gICAgICAgIHNhdmVkRG9jID0gZG9jXG4gICAgICB9XG5cbiAgICAgIF9zZXRWYWx1ZShzYXZlZERvYylcbiAgICAgIHNldFN0YXR1cygncmVhZHknKVxuICAgIH1cblxuICAgIGhhbmRsZUxvYWQoKVxuICB9LCBbaWQsIGRvY10pXG5cbiAgcmV0dXJuIHsgdmFsdWUsIHN0YXR1cywgc2V0VmFsdWUsIGZvcmNlVXBkYXRlIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./hooks/usePersistence.tsx\n");

/***/ }),

/***/ "../packages/core/dist/core.cjs.development.js":
/*!*****************************************************!*\
  !*** ../packages/core/dist/core.cjs.development.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar React = __webpack_require__(/*! react */ \"react\");\nvar reactErrorBoundary = __webpack_require__(/*! react-error-boundary */ \"react-error-boundary\");\nvar deepmerge = _interopDefault(__webpack_require__(/*! deepmerge */ \"deepmerge\"));\nvar reactUseGesture = __webpack_require__(/*! react-use-gesture */ \"react-use-gesture\");\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _taggedTemplateLiteralLoose(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n\n  strings.raw = raw;\n  return strings;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar TLContext = /*#__PURE__*/React.createContext({});\nfunction useTLContext() {\n  var context = React.useContext(TLContext);\n  return context;\n}\n\n(function (TLBoundsEdge) {\n  TLBoundsEdge[\"Top\"] = \"top_edge\";\n  TLBoundsEdge[\"Right\"] = \"right_edge\";\n  TLBoundsEdge[\"Bottom\"] = \"bottom_edge\";\n  TLBoundsEdge[\"Left\"] = \"left_edge\";\n})(exports.TLBoundsEdge || (exports.TLBoundsEdge = {}));\n\n(function (TLBoundsCorner) {\n  TLBoundsCorner[\"TopLeft\"] = \"top_left_corner\";\n  TLBoundsCorner[\"TopRight\"] = \"top_right_corner\";\n  TLBoundsCorner[\"BottomRight\"] = \"bottom_right_corner\";\n  TLBoundsCorner[\"BottomLeft\"] = \"bottom_left_corner\";\n})(exports.TLBoundsCorner || (exports.TLBoundsCorner = {}));\n/* -------------------------------------------------- */\n\n/*                   Shape Utility                    */\n\n/* -------------------------------------------------- */\n\n\nvar TLShapeUtil = /*#__PURE__*/function () {\n  function TLShapeUtil() {\n    this.boundsCache = new WeakMap();\n    this.isEditableText = false;\n    this.isAspectRatioLocked = false;\n    this.canEdit = false;\n  }\n\n  var _proto = TLShapeUtil.prototype;\n\n  _proto.shouldRender = function shouldRender(_prev, _next) {\n    return true;\n  };\n\n  _proto.shouldDelete = function shouldDelete(_shape) {\n    return false;\n  };\n\n  _proto.getCenter = function getCenter(shape) {\n    var bounds = this.getBounds(shape);\n    return [bounds.width / 2, bounds.height / 2];\n  };\n\n  _proto.create = function create(props) {\n    return _extends({}, this.defaultProps, props);\n  };\n\n  _proto.mutate = function mutate(shape, props) {\n    return _extends({}, shape, props);\n  };\n\n  _proto.updateChildren = function updateChildren(_shape, _children) {\n    return;\n  };\n\n  _proto.onChildrenChange = function onChildrenChange(_shape, _children) {\n    return;\n  };\n\n  _proto.onBindingChange = function onBindingChange(_shape, _binding, _target, _targetBounds) {\n    return;\n  };\n\n  _proto.onHandleChange = function onHandleChange(_shape, _handle, _info) {\n    return;\n  };\n\n  _proto.onRightPointHandle = function onRightPointHandle(_shape, _handle, _info) {\n    return;\n  };\n\n  _proto.onDoubleClickHandle = function onDoubleClickHandle(_shape, _handle, _info) {\n    return;\n  };\n\n  _proto.onSessionComplete = function onSessionComplete(_shape) {\n    return;\n  };\n\n  _proto.onBoundsReset = function onBoundsReset(_shape) {\n    return;\n  };\n\n  return TLShapeUtil;\n}();\n\n// A big collection of vector utilities. Collected into a class to improve logging / packaging.\n\n/* ----------------- Start Copy Here ---------------- */\nvar Vec = /*#__PURE__*/function () {\n  function Vec() {}\n\n  Vec.clamp = function clamp(n, min, max) {\n    return Math.max(min, typeof max !== 'undefined' ? Math.min(n, max) : n);\n  }\n  /**\r\n   * Negate a vector.\r\n   * @param A\r\n   */\n  ;\n\n  return Vec;\n}();\n\nVec.neg = function (A) {\n  return [-A[0], -A[1]];\n};\n\nVec.add = function (A, B) {\n  return [A[0] + B[0], A[1] + B[1]];\n};\n\nVec.addScalar = function (A, n) {\n  return [A[0] + n, A[1] + n];\n};\n\nVec.sub = function (A, B) {\n  return [A[0] - B[0], A[1] - B[1]];\n};\n\nVec.subScalar = function (A, n) {\n  return [A[0] - n, A[1] - n];\n};\n\nVec.vec = function (A, B) {\n  // A, B as vectors get the vector from A to B\n  return [B[0] - A[0], B[1] - A[1]];\n};\n\nVec.mul = function (A, n) {\n  return [A[0] * n, A[1] * n];\n};\n\nVec.mulV = function (A, B) {\n  return [A[0] * B[0], A[1] * B[1]];\n};\n\nVec.div = function (A, n) {\n  return [A[0] / n, A[1] / n];\n};\n\nVec.divV = function (A, B) {\n  return [A[0] / B[0], A[1] / B[1]];\n};\n\nVec.per = function (A) {\n  return [A[1], -A[0]];\n};\n\nVec.dpr = function (A, B) {\n  return A[0] * B[0] + A[1] * B[1];\n};\n\nVec.cpr = function (A, B) {\n  return A[0] * B[1] - B[0] * A[1];\n};\n\nVec.len2 = function (A) {\n  return A[0] * A[0] + A[1] * A[1];\n};\n\nVec.len = function (A) {\n  return Math.hypot(A[0], A[1]);\n};\n\nVec.pry = function (A, B) {\n  return Vec.dpr(A, B) / Vec.len(B);\n};\n\nVec.uni = function (A) {\n  return Vec.div(A, Vec.len(A));\n};\n\nVec.normalize = function (A) {\n  return Vec.uni(A);\n};\n\nVec.tangent = function (A, B) {\n  return Vec.normalize(Vec.sub(A, B));\n};\n\nVec.dist2 = function (A, B) {\n  return Vec.len2(Vec.sub(A, B));\n};\n\nVec.dist = function (A, B) {\n  return Math.hypot(A[1] - B[1], A[0] - B[0]);\n};\n\nVec.fastDist = function (A, B) {\n  var V = [B[0] - A[0], B[1] - A[1]];\n  var aV = [Math.abs(V[0]), Math.abs(V[1])];\n  var r = 1 / Math.max(aV[0], aV[1]);\n  r = r * (1.29289 - (aV[0] + aV[1]) * r * 0.29289);\n  return [V[0] * r, V[1] * r];\n};\n\nVec.ang = function (A, B) {\n  return Math.atan2(Vec.cpr(A, B), Vec.dpr(A, B));\n};\n\nVec.angle = function (A, B) {\n  return Math.atan2(B[1] - A[1], B[0] - A[0]);\n};\n\nVec.med = function (A, B) {\n  return Vec.mul(Vec.add(A, B), 0.5);\n};\n\nVec.rot = function (A, r) {\n  return [A[0] * Math.cos(r) - A[1] * Math.sin(r), A[0] * Math.sin(r) + A[1] * Math.cos(r)];\n};\n\nVec.rotWith = function (A, C, r) {\n  if (r === 0) return A;\n  var s = Math.sin(r);\n  var c = Math.cos(r);\n  var px = A[0] - C[0];\n  var py = A[1] - C[1];\n  var nx = px * c - py * s;\n  var ny = px * s + py * c;\n  return [nx + C[0], ny + C[1]];\n};\n\nVec.isEqual = function (A, B) {\n  return A[0] === B[0] && A[1] === B[1];\n};\n\nVec.lrp = function (A, B, t) {\n  return Vec.add(A, Vec.mul(Vec.vec(A, B), t));\n};\n\nVec[\"int\"] = function (A, B, from, to, s) {\n  if (s === void 0) {\n    s = 1;\n  }\n\n  var t = (Vec.clamp(from, to) - from) / (to - from);\n  return Vec.add(Vec.mul(A, 1 - t), Vec.mul(B, s));\n};\n\nVec.ang3 = function (p1, pc, p2) {\n  // this,\n  var v1 = Vec.vec(pc, p1);\n  var v2 = Vec.vec(pc, p2);\n  return Vec.ang(v1, v2);\n};\n\nVec.abs = function (A) {\n  return [Math.abs(A[0]), Math.abs(A[1])];\n};\n\nVec.rescale = function (a, n) {\n  var l = Vec.len(a);\n  return [n * a[0] / l, n * a[1] / l];\n};\n\nVec.isLeft = function (p1, pc, p2) {\n  //  isLeft: >0 for counterclockwise\n  //          =0 for none (degenerate)\n  //          <0 for clockwise\n  return (pc[0] - p1[0]) * (p2[1] - p1[1]) - (p2[0] - p1[0]) * (pc[1] - p1[1]);\n};\n\nVec.clockwise = function (p1, pc, p2) {\n  return Vec.isLeft(p1, pc, p2) > 0;\n};\n\nVec.round = function (a, d) {\n  if (d === void 0) {\n    d = 5;\n  }\n\n  return a.map(function (v) {\n    return +v.toPrecision(d);\n  });\n};\n\nVec.nearestPointOnLineThroughPoint = function (A, u, P) {\n  return Vec.add(A, Vec.mul(u, Vec.pry(Vec.sub(P, A), u)));\n};\n\nVec.distanceToLineThroughPoint = function (A, u, P) {\n  return Vec.dist(P, Vec.nearestPointOnLineThroughPoint(A, u, P));\n};\n\nVec.nearestPointOnLineSegment = function (A, B, P, clamp) {\n  if (clamp === void 0) {\n    clamp = true;\n  }\n\n  var delta = Vec.sub(B, A);\n  var length = Vec.len(delta);\n  var u = Vec.div(delta, length);\n  var pt = Vec.add(A, Vec.mul(u, Vec.pry(Vec.sub(P, A), u)));\n\n  if (clamp) {\n    var da = Vec.dist(A, pt);\n    var db = Vec.dist(B, pt);\n    if (db < da && da > length) return B;\n    if (da < db && db > length) return A;\n  }\n\n  return pt;\n};\n\nVec.distanceToLineSegment = function (A, B, P, clamp) {\n  if (clamp === void 0) {\n    clamp = true;\n  }\n\n  return Vec.dist(P, Vec.nearestPointOnLineSegment(A, B, P, clamp));\n};\n\nVec.nudge = function (A, B, d) {\n  return Vec.add(A, Vec.mul(Vec.uni(Vec.vec(A, B)), d));\n};\n\nVec.nudgeAtAngle = function (A, a, d) {\n  return [Math.cos(a) * d + A[0], Math.sin(a) * d + A[1]];\n};\n\nVec.toPrecision = function (a, n) {\n  if (n === void 0) {\n    n = 4;\n  }\n\n  return [+a[0].toPrecision(n), +a[1].toPrecision(n)];\n};\n\nVec.pointsBetween = function (a, b, steps) {\n  if (steps === void 0) {\n    steps = 6;\n  }\n\n  return Array.from(Array(steps)).map(function (_, i) {\n    var t = i / steps;\n    return t * t * t;\n  }).map(function (t) {\n    return Vec.round([].concat(Vec.lrp(a, b, t), [(1 - t) / 2]));\n  });\n};\n\n/* eslint-disable @typescript-eslint/ban-ts-comment */\n\n/* eslint-disable no-extend-native */\n\n/**\r\n * String.prototype.replaceAll() polyfill\r\n * https://gomakethings.com/how-to-replace-a-section-of-a-string-with-another-one-with-vanilla-js/\r\n * @author Chris Ferdinandi\r\n * @license MIT\r\n */\nif (!String.prototype.replaceAll) {\n  // @ts-ignore\n  String.prototype.replaceAll = function (str, newStr) {\n    // If a regex pattern\n    if (Object.prototype.toString.call(str).toLowerCase() === '[object regexp]') {\n      return this.replace(str, newStr);\n    } // If a string\n\n\n    return this.replace(new RegExp(str, 'g'), newStr);\n  };\n}\n\nvar Utils = /*#__PURE__*/function () {\n  function Utils() {}\n\n  /* -------------------------------------------------- */\n\n  /*                    Math & Geometry                 */\n\n  /* -------------------------------------------------- */\n  Utils.filterObject = function filterObject(obj, fn) {\n    return Object.fromEntries(Object.entries(obj).filter(fn));\n  };\n\n  Utils.deepMerge = function deepMerge(a, b) {\n    return deepmerge(a, b, {\n      arrayMerge: function arrayMerge(_a, b) {\n        return b;\n      }\n    });\n  }\n  /**\r\n   * Linear interpolation betwen two numbers.\r\n   * @param y1\r\n   * @param y2\r\n   * @param mu\r\n   */\n  ;\n\n  Utils.lerp = function lerp(y1, y2, mu) {\n    mu = Utils.clamp(mu, 0, 1);\n    return y1 * (1 - mu) + y2 * mu;\n  }\n  /**\r\n   * Linear interpolation between two colors.\r\n   *\r\n   * ### Example\r\n   *\r\n   *```ts\r\n   * lerpColor(\"#000000\", \"#0099FF\", .25)\r\n   *```\r\n   */\n  ;\n\n  Utils.lerpColor = function lerpColor(color1, color2, factor) {\n    if (factor === void 0) {\n      factor = 0.5;\n    }\n\n    function h2r(hex) {\n      var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n      return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : null;\n    }\n\n    function r2h(rgb) {\n      return '#' + ((1 << 24) + (rgb[0] << 16) + (rgb[1] << 8) + rgb[2]).toString(16).slice(1);\n    }\n\n    var c1 = h2r(color1);\n    var c2 = h2r(color2);\n    if (!(c1 && c2)) return;\n    var result = c1.slice();\n\n    for (var i = 0; i < 3; i++) {\n      result[i] = Math.round(result[i] + factor * (c2[i] - c1[i]));\n    }\n\n    return r2h(result);\n  }\n  /**\r\n   * Modulate a value between two ranges.\r\n   * @param value\r\n   * @param rangeA from [low, high]\r\n   * @param rangeB to [low, high]\r\n   * @param clamp\r\n   */\n  ;\n\n  Utils.modulate = function modulate(value, rangeA, rangeB, clamp) {\n    if (clamp === void 0) {\n      clamp = false;\n    }\n\n    var fromLow = rangeA[0],\n        fromHigh = rangeA[1];\n    var v0 = rangeB[0],\n        v1 = rangeB[1];\n    var result = v0 + (value - fromLow) / (fromHigh - fromLow) * (v1 - v0);\n    return clamp ? v0 < v1 ? Math.max(Math.min(result, v1), v0) : Math.max(Math.min(result, v0), v1) : result;\n  };\n\n  Utils.clamp = function clamp(n, min, max) {\n    return Math.max(min, typeof max !== 'undefined' ? Math.min(n, max) : n);\n  } // TODO: replace with a string compression algorithm\n  ;\n\n  Utils.compress = function compress(s) {\n    return s;\n  } // TODO: replace with a string decompression algorithm\n  ;\n\n  Utils.decompress = function decompress(s) {\n    return s;\n  }\n  /**\r\n   * Recursively clone an object or array.\r\n   * @param obj\r\n   */\n  ;\n\n  Utils.deepClone = function deepClone(obj) {\n    if (obj === null) return obj;\n\n    if (Array.isArray(obj)) {\n      return [].concat(obj);\n    }\n\n    if (typeof obj === 'object') {\n      var clone = _extends({}, obj);\n\n      Object.keys(clone).forEach(function (key) {\n        return clone[key] = typeof obj[key] === 'object' ? Utils.deepClone(obj[key]) : obj[key];\n      });\n      return clone;\n    }\n\n    return obj;\n  }\n  /**\r\n   * Seeded random number generator, using [xorshift](https://en.wikipedia.org/wiki/Xorshift).\r\n   * The result will always be betweeen -1 and 1.\r\n   *\r\n   * Adapted from [seedrandom](https://github.com/davidbau/seedrandom).\r\n   */\n  ;\n\n  Utils.rng = function rng(seed) {\n    if (seed === void 0) {\n      seed = '';\n    }\n\n    var x = 0;\n    var y = 0;\n    var z = 0;\n    var w = 0;\n\n    function next() {\n      var t = x ^ x << 11;\n      x = y;\n      y = z;\n      z = w;\n      w ^= (w >>> 19 ^ t ^ t >>> 8) >>> 0;\n      return w / 0x100000000;\n    }\n\n    for (var k = 0; k < seed.length + 64; k++) {\n      x ^= seed.charCodeAt(k) | 0;\n      next();\n    }\n\n    return next;\n  }\n  /* ---------------------- Boxes --------------------- */\n  ;\n\n  Utils.getRectangleSides = function getRectangleSides(point, size) {\n    var tl = point;\n    var tr = Vec.add(point, [size[0], 0]);\n    var br = Vec.add(point, size);\n    var bl = Vec.add(point, [0, size[1]]);\n    return [['top', [tl, tr]], ['right', [tr, br]], ['bottom', [br, bl]], ['left', [bl, tl]]];\n  };\n\n  Utils.getBoundsSides = function getBoundsSides(bounds) {\n    return this.getRectangleSides([bounds.minX, bounds.minY], [bounds.width, bounds.height]);\n  };\n\n  Utils.shallowEqual = function shallowEqual(objA, objB) {\n    if (objA === objB) return true;\n    if (!objA || !objB) return false;\n    var aKeys = Object.keys(objA);\n    var bKeys = Object.keys(objB);\n    var len = aKeys.length;\n    if (bKeys.length !== len) return false;\n\n    for (var i = 0; i < len; i++) {\n      var key = aKeys[i];\n\n      if (objA[key] !== objB[key] || !Object.prototype.hasOwnProperty.call(objB, key)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /* --------------- Circles and Angles --------------- */\n\n  /**\r\n   * Get the outer of between a circle and a point.\r\n   * @param C The circle's center.\r\n   * @param r The circle's radius.\r\n   * @param P The point.\r\n   * @param side\r\n   */\n  ;\n\n  Utils.getCircleTangentToPoint = function getCircleTangentToPoint(C, r, P, side) {\n    var B = Vec.lrp(C, P, 0.5);\n    var r1 = Vec.dist(C, B);\n    var delta = Vec.sub(B, C);\n    var d = Vec.len(delta);\n\n    if (!(d <= r + r1 && d >= Math.abs(r - r1))) {\n      return null;\n    }\n\n    var a = (r * r - r1 * r1 + d * d) / (2.0 * d);\n    var n = 1 / d;\n    var p = Vec.add(C, Vec.mul(delta, a * n));\n    var h = Math.sqrt(r * r - a * a);\n    var k = Vec.mul(Vec.per(delta), h * n);\n    return side === 0 ? Vec.add(p, k) : Vec.sub(p, k);\n  }\n  /**\r\n   * Get outer tangents of two circles.\r\n   * @param x0\r\n   * @param y0\r\n   * @param r0\r\n   * @param x1\r\n   * @param y1\r\n   * @param r1\r\n   * @returns [lx0, ly0, lx1, ly1, rx0, ry0, rx1, ry1]\r\n   */\n  ;\n\n  Utils.getOuterTangentsOfCircles = function getOuterTangentsOfCircles(C0, r0, C1, r1) {\n    var a0 = Vec.angle(C0, C1);\n    var d = Vec.dist(C0, C1); // Circles are overlapping, no tangents\n\n    if (d < Math.abs(r1 - r0)) {\n      return null;\n    }\n\n    var a1 = Math.acos((r0 - r1) / d);\n    var t0 = a0 + a1;\n    var t1 = a0 - a1;\n    return [[C0[0] + r0 * Math.cos(t1), C0[1] + r0 * Math.sin(t1)], [C1[0] + r1 * Math.cos(t1), C1[1] + r1 * Math.sin(t1)], [C0[0] + r0 * Math.cos(t0), C0[1] + r0 * Math.sin(t0)], [C1[0] + r1 * Math.cos(t0), C1[1] + r1 * Math.sin(t0)]];\n  }\n  /**\r\n   * Get the closest point on the perimeter of a circle to a given point.\r\n   * @param C The circle's center.\r\n   * @param r The circle's radius.\r\n   * @param P The point.\r\n   */\n  ;\n\n  Utils.getClosestPointOnCircle = function getClosestPointOnCircle(C, r, P) {\n    var v = Vec.sub(C, P);\n    return Vec.sub(C, Vec.mul(Vec.div(v, Vec.len(v)), r));\n  }\n  /**\r\n   * Get a circle from three points.\r\n   * @param A\r\n   * @param B\r\n   * @param C\r\n   * @returns [x, y, r]\r\n   */\n  ;\n\n  Utils.circleFromThreePoints = function circleFromThreePoints(A, B, C) {\n    var x1 = A[0],\n        y1 = A[1];\n    var x2 = B[0],\n        y2 = B[1];\n    var x3 = C[0],\n        y3 = C[1];\n    var a = x1 * (y2 - y3) - y1 * (x2 - x3) + x2 * y3 - x3 * y2;\n    var b = (x1 * x1 + y1 * y1) * (y3 - y2) + (x2 * x2 + y2 * y2) * (y1 - y3) + (x3 * x3 + y3 * y3) * (y2 - y1);\n    var c = (x1 * x1 + y1 * y1) * (x2 - x3) + (x2 * x2 + y2 * y2) * (x3 - x1) + (x3 * x3 + y3 * y3) * (x1 - x2);\n    var x = -b / (2 * a);\n    var y = -c / (2 * a);\n    return [x, y, Math.hypot(x - x1, y - y1)];\n  }\n  /**\r\n   * Find the approximate perimeter of an ellipse.\r\n   * @param rx\r\n   * @param ry\r\n   */\n  ;\n\n  Utils.perimeterOfEllipse = function perimeterOfEllipse(rx, ry) {\n    var h = Math.pow(rx - ry, 2) / Math.pow(rx + ry, 2);\n    var p = Math.PI * (rx + ry) * (1 + 3 * h / (10 + Math.sqrt(4 - 3 * h)));\n    return p;\n  }\n  /**\r\n   * Get the short angle distance between two angles.\r\n   * @param a0\r\n   * @param a1\r\n   */\n  ;\n\n  Utils.shortAngleDist = function shortAngleDist(a0, a1) {\n    var max = Math.PI * 2;\n    var da = (a1 - a0) % max;\n    return 2 * da % max - da;\n  }\n  /**\r\n   * Get the long angle distance between two angles.\r\n   * @param a0\r\n   * @param a1\r\n   */\n  ;\n\n  Utils.longAngleDist = function longAngleDist(a0, a1) {\n    return Math.PI * 2 - Utils.shortAngleDist(a0, a1);\n  }\n  /**\r\n   * Interpolate an angle between two angles.\r\n   * @param a0\r\n   * @param a1\r\n   * @param t\r\n   */\n  ;\n\n  Utils.lerpAngles = function lerpAngles(a0, a1, t) {\n    return a0 + Utils.shortAngleDist(a0, a1) * t;\n  }\n  /**\r\n   * Get the short distance between two angles.\r\n   * @param a0\r\n   * @param a1\r\n   */\n  ;\n\n  Utils.angleDelta = function angleDelta(a0, a1) {\n    return Utils.shortAngleDist(a0, a1);\n  }\n  /**\r\n   * Get the \"sweep\" or short distance between two points on a circle's perimeter.\r\n   * @param C\r\n   * @param A\r\n   * @param B\r\n   */\n  ;\n\n  Utils.getSweep = function getSweep(C, A, B) {\n    return Utils.angleDelta(Vec.angle(C, A), Vec.angle(C, B));\n  }\n  /**\r\n   * Rotate a point around a center.\r\n   * @param x The x-axis coordinate of the point.\r\n   * @param y The y-axis coordinate of the point.\r\n   * @param cx The x-axis coordinate of the point to rotate round.\r\n   * @param cy The y-axis coordinate of the point to rotate round.\r\n   * @param angle The distance (in radians) to rotate.\r\n   */\n  ;\n\n  Utils.rotatePoint = function rotatePoint(A, B, angle) {\n    var s = Math.sin(angle);\n    var c = Math.cos(angle);\n    var px = A[0] - B[0];\n    var py = A[1] - B[1];\n    var nx = px * c - py * s;\n    var ny = px * s + py * c;\n    return [nx + B[0], ny + B[1]];\n  }\n  /**\r\n   * Clamp radians within 0 and 2PI\r\n   * @param r\r\n   */\n  ;\n\n  Utils.clampRadians = function clampRadians(r) {\n    return (Math.PI * 2 + r) % (Math.PI * 2);\n  }\n  /**\r\n   * Clamp rotation to even segments.\r\n   * @param r\r\n   * @param segments\r\n   */\n  ;\n\n  Utils.clampToRotationToSegments = function clampToRotationToSegments(r, segments) {\n    var seg = Math.PI * 2 / segments;\n    return Math.floor((Utils.clampRadians(r) + seg / 2) / seg) * seg;\n  }\n  /**\r\n   * Is angle c between angles a and b?\r\n   * @param a\r\n   * @param b\r\n   * @param c\r\n   */\n  ;\n\n  Utils.isAngleBetween = function isAngleBetween(a, b, c) {\n    if (c === a || c === b) return true;\n    var PI2 = Math.PI * 2;\n    var AB = (b - a + PI2) % PI2;\n    var AC = (c - a + PI2) % PI2;\n    return AB <= Math.PI !== AC > AB;\n  }\n  /**\r\n   * Convert degrees to radians.\r\n   * @param d\r\n   */\n  ;\n\n  Utils.degreesToRadians = function degreesToRadians(d) {\n    return d * Math.PI / 180;\n  }\n  /**\r\n   * Convert radians to degrees.\r\n   * @param r\r\n   */\n  ;\n\n  Utils.radiansToDegrees = function radiansToDegrees(r) {\n    return r * 180 / Math.PI;\n  }\n  /**\r\n   * Get the length of an arc between two points on a circle's perimeter.\r\n   * @param C\r\n   * @param r\r\n   * @param A\r\n   * @param B\r\n   */\n  ;\n\n  Utils.getArcLength = function getArcLength(C, r, A, B) {\n    var sweep = Utils.getSweep(C, A, B);\n    return r * (2 * Math.PI) * (sweep / (2 * Math.PI));\n  }\n  /**\r\n   * Get a dash offset for an arc, based on its length.\r\n   * @param C\r\n   * @param r\r\n   * @param A\r\n   * @param B\r\n   * @param step\r\n   */\n  ;\n\n  Utils.getArcDashOffset = function getArcDashOffset(C, r, A, B, step) {\n    var del0 = Utils.getSweep(C, A, B);\n    var len0 = Utils.getArcLength(C, r, A, B);\n    var off0 = del0 < 0 ? len0 : 2 * Math.PI * C[2] - len0;\n    return -off0 / 2 + step;\n  }\n  /**\r\n   * Get a dash offset for an ellipse, based on its length.\r\n   * @param A\r\n   * @param step\r\n   */\n  ;\n\n  Utils.getEllipseDashOffset = function getEllipseDashOffset(A, step) {\n    var c = 2 * Math.PI * A[2];\n    return -c / 2 + -step;\n  }\n  /* --------------- Curves and Splines --------------- */\n\n  /**\r\n   * Get bezier curve segments that pass through an array of points.\r\n   * @param points\r\n   * @param tension\r\n   */\n  ;\n\n  Utils.getTLBezierCurveSegments = function getTLBezierCurveSegments(points, tension) {\n    if (tension === void 0) {\n      tension = 0.4;\n    }\n\n    var len = points.length;\n    var cpoints = [].concat(points);\n\n    if (len < 2) {\n      throw Error('Curve must have at least two points.');\n    }\n\n    for (var i = 1; i < len - 1; i++) {\n      var p0 = points[i - 1];\n      var p1 = points[i];\n      var p2 = points[i + 1];\n      var pdx = p2[0] - p0[0];\n      var pdy = p2[1] - p0[1];\n      var pd = Math.hypot(pdx, pdy);\n      var nx = pdx / pd; // normalized x\n\n      var ny = pdy / pd; // normalized y\n\n      var dp = Math.hypot(p1[0] - p0[0], p1[1] - p0[1]); // Distance to previous\n\n      var dn = Math.hypot(p1[0] - p2[0], p1[1] - p2[1]); // Distance to next\n\n      cpoints[i] = [// tangent start\n      p1[0] - nx * dp * tension, p1[1] - ny * dp * tension, // tangent end\n      p1[0] + nx * dn * tension, p1[1] + ny * dn * tension, // normal\n      nx, ny];\n    } // TODO: Reflect the nearest control points, not average them\n\n\n    var d0 = Math.hypot(points[0][0] + cpoints[1][0]);\n    cpoints[0][2] = (points[0][0] + cpoints[1][0]) / 2;\n    cpoints[0][3] = (points[0][1] + cpoints[1][1]) / 2;\n    cpoints[0][4] = (cpoints[1][0] - points[0][0]) / d0;\n    cpoints[0][5] = (cpoints[1][1] - points[0][1]) / d0;\n    var d1 = Math.hypot(points[len - 1][1] + cpoints[len - 1][1]);\n    cpoints[len - 1][0] = (points[len - 1][0] + cpoints[len - 2][2]) / 2;\n    cpoints[len - 1][1] = (points[len - 1][1] + cpoints[len - 2][3]) / 2;\n    cpoints[len - 1][4] = (cpoints[len - 2][2] - points[len - 1][0]) / -d1;\n    cpoints[len - 1][5] = (cpoints[len - 2][3] - points[len - 1][1]) / -d1;\n    var results = [];\n\n    for (var _i = 1; _i < cpoints.length; _i++) {\n      results.push({\n        start: points[_i - 1].slice(0, 2),\n        tangentStart: cpoints[_i - 1].slice(2, 4),\n        normalStart: cpoints[_i - 1].slice(4, 6),\n        pressureStart: 2 + ((_i - 1) % 2 === 0 ? 1.5 : 0),\n        end: points[_i].slice(0, 2),\n        tangentEnd: cpoints[_i].slice(0, 2),\n        normalEnd: cpoints[_i].slice(4, 6),\n        pressureEnd: 2 + (_i % 2 === 0 ? 1.5 : 0)\n      });\n    }\n\n    return results;\n  }\n  /**\r\n   * Find a point along a curve segment, via pomax.\r\n   * @param t\r\n   * @param points [cpx1, cpy1, cpx2, cpy2, px, py][]\r\n   */\n  ;\n\n  Utils.computePointOnCurve = function computePointOnCurve(t, points) {\n    // shortcuts\n    if (t === 0) {\n      return points[0];\n    }\n\n    var order = points.length - 1;\n\n    if (t === 1) {\n      return points[order];\n    }\n\n    var mt = 1 - t;\n    var p = points; // constant?\n\n    if (order === 0) {\n      return points[0];\n    } // linear?\n\n\n    if (order === 1) {\n      return [mt * p[0][0] + t * p[1][0], mt * p[0][1] + t * p[1][1]];\n    } // quadratic/cubic curve?\n    // if (order < 4) {\n\n\n    var mt2 = mt * mt;\n    var t2 = t * t;\n    var a;\n    var b;\n    var c;\n    var d = 0;\n\n    if (order === 2) {\n      p = [p[0], p[1], p[2], [0, 0]];\n      a = mt2;\n      b = mt * t * 2;\n      c = t2; // } else if (order === 3) {\n    } else {\n      a = mt2 * mt;\n      b = mt2 * t * 3;\n      c = mt * t2 * 3;\n      d = t * t2;\n    }\n\n    return [a * p[0][0] + b * p[1][0] + c * p[2][0] + d * p[3][0], a * p[0][1] + b * p[1][1] + c * p[2][1] + d * p[3][1]]; // } // higher order curves: use de Casteljau's computation\n  }\n  /**\r\n   * Evaluate a 2d cubic bezier at a point t on the x axis.\r\n   * @param tx\r\n   * @param x1\r\n   * @param y1\r\n   * @param x2\r\n   * @param y2\r\n   */\n  ;\n\n  Utils.cubicBezier = function cubicBezier(tx, x1, y1, x2, y2) {\n    // Inspired by Don Lancaster's two articles\n    // http://www.tinaja.com/glib/cubemath.pdf\n    // http://www.tinaja.com/text/bezmath.html\n    // Set start and end point\n    var x0 = 0;\n    var y0 = 0;\n    var x3 = 1;\n    var y3 = 1; // Convert the coordinates to equation space\n\n    var A = x3 - 3 * x2 + 3 * x1 - x0;\n    var B = 3 * x2 - 6 * x1 + 3 * x0;\n    var C = 3 * x1 - 3 * x0;\n    var D = x0;\n    var E = y3 - 3 * y2 + 3 * y1 - y0;\n    var F = 3 * y2 - 6 * y1 + 3 * y0;\n    var G = 3 * y1 - 3 * y0;\n    var H = y0; // Variables for the loop below\n\n    var iterations = 5;\n    var i;\n    var slope;\n    var x;\n    var t = tx; // Loop through a few times to get a more accurate time value, according to the Newton-Raphson method\n    // http://en.wikipedia.org/wiki/Newton's_method\n\n    for (i = 0; i < iterations; i++) {\n      // The curve's x equation for the current time value\n      x = A * t * t * t + B * t * t + C * t + D; // The slope we want is the inverse of the derivate of x\n\n      slope = 1 / (3 * A * t * t + 2 * B * t + C); // Get the next estimated time value, which will be more accurate than the one before\n\n      t -= (x - tx) * slope;\n      t = t > 1 ? 1 : t < 0 ? 0 : t;\n    } // Find the y value through the curve's y equation, with the now more accurate time value\n\n\n    return Math.abs(E * t * t * t + F * t * t + G * t * H);\n  }\n  /**\r\n   * Get a bezier curve data for a spline that fits an array of points.\r\n   * @param points An array of points formatted as [x, y]\r\n   * @param k Tension\r\n   */\n  ;\n\n  Utils.getSpline = function getSpline(pts, k) {\n    if (k === void 0) {\n      k = 0.5;\n    }\n\n    var p0;\n    var p1 = pts[0],\n        p2 = pts[1],\n        p3 = pts[2];\n    var results = [];\n\n    for (var i = 1, len = pts.length; i < len; i++) {\n      p0 = p1;\n      p1 = p2;\n      p2 = p3;\n      p3 = pts[i + 2] ? pts[i + 2] : p2;\n      results.push({\n        cp1x: p1[0] + (p2[0] - p0[0]) / 6 * k,\n        cp1y: p1[1] + (p2[1] - p0[1]) / 6 * k,\n        cp2x: p2[0] - (p3[0] - p1[0]) / 6 * k,\n        cp2y: p2[1] - (p3[1] - p1[1]) / 6 * k,\n        px: pts[i][0],\n        py: pts[i][1]\n      });\n    }\n\n    return results;\n  }\n  /**\r\n   * Get a bezier curve data for a spline that fits an array of points.\r\n   * @param pts\r\n   * @param tension\r\n   * @param isClosed\r\n   * @param numOfSegments\r\n   */\n  ;\n\n  Utils.getCurvePoints = function getCurvePoints(pts, tension, isClosed, numOfSegments) {\n    if (tension === void 0) {\n      tension = 0.5;\n    }\n\n    if (isClosed === void 0) {\n      isClosed = false;\n    }\n\n    if (numOfSegments === void 0) {\n      numOfSegments = 3;\n    }\n\n    var _pts = [].concat(pts);\n\n    var len = pts.length;\n    var res = []; // results\n\n    var t1x, // tension vectors\n    t2x, t1y, t2y, c1, // cardinal points\n    c2, c3, c4, st, st2, st3; // The algorithm require a previous and next point to the actual point array.\n    // Check if we will draw closed or open curve.\n    // If closed, copy end points to beginning and first points to end\n    // If open, duplicate first points to befinning, end points to end\n\n    if (isClosed) {\n      _pts.unshift(_pts[len - 1]);\n\n      _pts.push(_pts[0]);\n    } else {\n      // copy 1. point and insert at beginning\n      _pts.unshift(_pts[0]);\n\n      _pts.push(_pts[len - 1]); // _pts.push(_pts[len - 1])\n\n    } // For each point, calculate a segment\n\n\n    for (var i = 1; i < _pts.length - 2; i++) {\n      // Calculate points along segment and add to results\n      for (var t = 0; t <= numOfSegments; t++) {\n        // Step\n        st = t / numOfSegments;\n        st2 = Math.pow(st, 2);\n        st3 = Math.pow(st, 3); // Cardinals\n\n        c1 = 2 * st3 - 3 * st2 + 1;\n        c2 = -(2 * st3) + 3 * st2;\n        c3 = st3 - 2 * st2 + st;\n        c4 = st3 - st2; // Tension\n\n        t1x = (_pts[i + 1][0] - _pts[i - 1][0]) * tension;\n        t2x = (_pts[i + 2][0] - _pts[i][0]) * tension;\n        t1y = (_pts[i + 1][1] - _pts[i - 1][1]) * tension;\n        t2y = (_pts[i + 2][1] - _pts[i][1]) * tension; // Control points\n\n        res.push([c1 * _pts[i][0] + c2 * _pts[i + 1][0] + c3 * t1x + c4 * t2x, c1 * _pts[i][1] + c2 * _pts[i + 1][1] + c3 * t1y + c4 * t2y]);\n      }\n    }\n\n    res.push(pts[pts.length - 1]);\n    return res;\n  }\n  /**\r\n   * Simplify a line (using Ramer-Douglas-Peucker algorithm).\r\n   * @param points An array of points as [x, y, ...][]\r\n   * @param tolerance The minimum line distance (also called epsilon).\r\n   * @returns Simplified array as [x, y, ...][]\r\n   */\n  ;\n\n  Utils.simplify = function simplify(points, tolerance) {\n    if (tolerance === void 0) {\n      tolerance = 1;\n    }\n\n    var len = points.length;\n    var a = points[0];\n    var b = points[len - 1];\n    var x1 = a[0],\n        y1 = a[1];\n    var x2 = b[0],\n        y2 = b[1];\n\n    if (len > 2) {\n      var distance = 0;\n      var index = 0;\n      var max = Math.hypot(y2 - y1, x2 - x1);\n\n      for (var i = 1; i < len - 1; i++) {\n        var _points$i = points[i],\n            x0 = _points$i[0],\n            y0 = _points$i[1];\n        var d = Math.abs((y2 - y1) * x0 - (x2 - x1) * y0 + x2 * y1 - y2 * x1) / max;\n        if (distance > d) continue;\n        distance = d;\n        index = i;\n      }\n\n      if (distance > tolerance) {\n        var l0 = Utils.simplify(points.slice(0, index + 1), tolerance);\n        var l1 = Utils.simplify(points.slice(index + 1), tolerance);\n        return l0.concat(l1.slice(1));\n      }\n    }\n\n    return [a, b];\n  }\n  /**\r\n   * Get whether a point is inside of a circle.\r\n   * @param A\r\n   * @param b\r\n   * @returns\r\n   */\n  ;\n\n  Utils.pointInCircle = function pointInCircle(A, C, r) {\n    return Vec.dist(A, C) <= r;\n  }\n  /**\r\n   * Get whether a point is inside of an ellipse.\r\n   * @param point\r\n   * @param center\r\n   * @param rx\r\n   * @param ry\r\n   * @param rotation\r\n   * @returns\r\n   */\n  ;\n\n  Utils.pointInEllipse = function pointInEllipse(A, C, rx, ry, rotation) {\n    if (rotation === void 0) {\n      rotation = 0;\n    }\n\n    rotation = rotation || 0;\n    var cos = Math.cos(rotation);\n    var sin = Math.sin(rotation);\n    var delta = Vec.sub(A, C);\n    var tdx = cos * delta[0] + sin * delta[1];\n    var tdy = sin * delta[0] - cos * delta[1];\n    return tdx * tdx / (rx * rx) + tdy * tdy / (ry * ry) <= 1;\n  }\n  /**\r\n   * Get whether a point is inside of a rectangle.\r\n   * @param point\r\n   * @param size\r\n   */\n  ;\n\n  Utils.pointInRect = function pointInRect(point, size) {\n    return !(point[0] < size[0] || point[0] > point[0] + size[0] || point[1] < size[1] || point[1] > point[1] + size[1]);\n  }\n  /* --------------------- Bounds --------------------- */\n\n  /**\r\n   * Expand a bounding box by a delta.\r\n   *\r\n   * ### Example\r\n   *\r\n   *```ts\r\n   * expandBounds(myBounds, [100, 100])\r\n   *```\r\n   */\n  ;\n\n  Utils.expandBounds = function expandBounds(bounds, delta) {\n    return {\n      minX: bounds.minX - delta,\n      minY: bounds.minY - delta,\n      maxX: bounds.maxX + delta,\n      maxY: bounds.maxY + delta,\n      width: bounds.width + delta * 2,\n      height: bounds.height + delta * 2\n    };\n  }\n  /**\r\n   * Get whether a point is inside of a bounds.\r\n   * @param A\r\n   * @param b\r\n   * @returns\r\n   */\n  ;\n\n  Utils.pointInBounds = function pointInBounds(A, b) {\n    return !(A[0] < b.minX || A[0] > b.maxX || A[1] < b.minY || A[1] > b.maxY);\n  }\n  /**\r\n   * Get whether two bounds collide.\r\n   * @param a Bounds\r\n   * @param b Bounds\r\n   * @returns\r\n   */\n  ;\n\n  Utils.boundsCollide = function boundsCollide(a, b) {\n    return !(a.maxX < b.minX || a.minX > b.maxX || a.maxY < b.minY || a.minY > b.maxY);\n  }\n  /**\r\n   * Get whether the bounds of A contain the bounds of B. A perfect match will return true.\r\n   * @param a Bounds\r\n   * @param b Bounds\r\n   * @returns\r\n   */\n  ;\n\n  Utils.boundsContain = function boundsContain(a, b) {\n    return a.minX < b.minX && a.minY < b.minY && a.maxY > b.maxY && a.maxX > b.maxX;\n  }\n  /**\r\n   * Get whether the bounds of A are contained by the bounds of B.\r\n   * @param a Bounds\r\n   * @param b Bounds\r\n   * @returns\r\n   */\n  ;\n\n  Utils.boundsContained = function boundsContained(a, b) {\n    return Utils.boundsContain(b, a);\n  }\n  /**\r\n   * Get whether two bounds are identical.\r\n   * @param a Bounds\r\n   * @param b Bounds\r\n   * @returns\r\n   */\n  ;\n\n  Utils.boundsAreEqual = function boundsAreEqual(a, b) {\n    return !(b.maxX !== a.maxX || b.minX !== a.minX || b.maxY !== a.maxY || b.minY !== a.minY);\n  }\n  /**\r\n   * Find a bounding box from an array of points.\r\n   * @param points\r\n   * @param rotation (optional) The bounding box's rotation.\r\n   */\n  ;\n\n  Utils.getBoundsFromPoints = function getBoundsFromPoints(points, rotation) {\n    if (rotation === void 0) {\n      rotation = 0;\n    }\n\n    var minX = Infinity;\n    var minY = Infinity;\n    var maxX = -Infinity;\n    var maxY = -Infinity;\n\n    if (points.length < 2) {\n      minX = 0;\n      minY = 0;\n      maxX = 1;\n      maxY = 1;\n    } else {\n      for (var _iterator = _createForOfIteratorHelperLoose(points), _step; !(_step = _iterator()).done;) {\n        var _step$value = _step.value,\n            x = _step$value[0],\n            y = _step$value[1];\n        minX = Math.min(x, minX);\n        minY = Math.min(y, minY);\n        maxX = Math.max(x, maxX);\n        maxY = Math.max(y, maxY);\n      }\n    }\n\n    if (rotation !== 0) {\n      return Utils.getBoundsFromPoints(points.map(function (pt) {\n        return Vec.rotWith(pt, [(minX + maxX) / 2, (minY + maxY) / 2], rotation);\n      }));\n    }\n\n    return {\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY,\n      width: Math.max(1, maxX - minX),\n      height: Math.max(1, maxY - minY)\n    };\n  }\n  /**\r\n   * Move a bounding box without recalculating it.\r\n   * @param bounds\r\n   * @param delta\r\n   * @returns\r\n   */\n  ;\n\n  Utils.translateBounds = function translateBounds(bounds, delta) {\n    return {\n      minX: bounds.minX + delta[0],\n      minY: bounds.minY + delta[1],\n      maxX: bounds.maxX + delta[0],\n      maxY: bounds.maxY + delta[1],\n      width: bounds.width,\n      height: bounds.height\n    };\n  }\n  /**\r\n   * Rotate a bounding box.\r\n   * @param bounds\r\n   * @param center\r\n   * @param rotation\r\n   */\n  ;\n\n  Utils.rotateBounds = function rotateBounds(bounds, center, rotation) {\n    var _vec$rotWith = Vec.rotWith([bounds.minX, bounds.minY], center, rotation),\n        minX = _vec$rotWith[0],\n        minY = _vec$rotWith[1];\n\n    var _vec$rotWith2 = Vec.rotWith([bounds.maxX, bounds.maxY], center, rotation),\n        maxX = _vec$rotWith2[0],\n        maxY = _vec$rotWith2[1];\n\n    return {\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY,\n      width: bounds.width,\n      height: bounds.height\n    };\n  }\n  /**\r\n   * Get the rotated bounds of an ellipse.\r\n   * @param x\r\n   * @param y\r\n   * @param rx\r\n   * @param ry\r\n   * @param rotation\r\n   */\n  ;\n\n  Utils.getRotatedEllipseBounds = function getRotatedEllipseBounds(x, y, rx, ry, rotation) {\n    var c = Math.cos(rotation);\n    var s = Math.sin(rotation);\n    var w = Math.hypot(rx * c, ry * s);\n    var h = Math.hypot(rx * s, ry * c);\n    return {\n      minX: x + rx - w,\n      minY: y + ry - h,\n      maxX: x + rx + w,\n      maxY: y + ry + h,\n      width: w * 2,\n      height: h * 2\n    };\n  }\n  /**\r\n   * Get a bounding box that includes two bounding boxes.\r\n   * @param a Bounding box\r\n   * @param b Bounding box\r\n   * @returns\r\n   */\n  ;\n\n  Utils.getExpandedBounds = function getExpandedBounds(a, b) {\n    var minX = Math.min(a.minX, b.minX);\n    var minY = Math.min(a.minY, b.minY);\n    var maxX = Math.max(a.maxX, b.maxX);\n    var maxY = Math.max(a.maxY, b.maxY);\n    var width = Math.abs(maxX - minX);\n    var height = Math.abs(maxY - minY);\n    return {\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY,\n      width: width,\n      height: height\n    };\n  }\n  /**\r\n   * Get the common bounds of a group of bounds.\r\n   * @returns\r\n   */\n  ;\n\n  Utils.getCommonBounds = function getCommonBounds(bounds) {\n    if (bounds.length < 2) return bounds[0];\n    var result = bounds[0];\n\n    for (var i = 1; i < bounds.length; i++) {\n      result = Utils.getExpandedBounds(result, bounds[i]);\n    }\n\n    return result;\n  };\n\n  Utils.getRotatedCorners = function getRotatedCorners(b, rotation) {\n    if (rotation === void 0) {\n      rotation = 0;\n    }\n\n    var center = [b.minX + b.width / 2, b.minY + b.height / 2];\n    return [[b.minX, b.minY], [b.maxX, b.minY], [b.maxX, b.maxY], [b.minX, b.maxY]].map(function (point) {\n      return Vec.rotWith(point, center, rotation);\n    });\n  };\n\n  Utils.getTransformedBoundingBox = function getTransformedBoundingBox(bounds, handle, delta, rotation, isAspectRatioLocked) {\n    if (rotation === void 0) {\n      rotation = 0;\n    }\n\n    if (isAspectRatioLocked === void 0) {\n      isAspectRatioLocked = false;\n    }\n\n    // Create top left and bottom right corners.\n    var _ref = [bounds.minX, bounds.minY],\n        ax0 = _ref[0],\n        ay0 = _ref[1];\n    var _ref2 = [bounds.maxX, bounds.maxY],\n        ax1 = _ref2[0],\n        ay1 = _ref2[1]; // Create a second set of corners for the new box.\n\n    var _ref3 = [bounds.minX, bounds.minY],\n        bx0 = _ref3[0],\n        by0 = _ref3[1];\n    var _ref4 = [bounds.maxX, bounds.maxY],\n        bx1 = _ref4[0],\n        by1 = _ref4[1]; // If the drag is on the center, just translate the bounds.\n\n    if (handle === 'center') {\n      return {\n        minX: bx0 + delta[0],\n        minY: by0 + delta[1],\n        maxX: bx1 + delta[0],\n        maxY: by1 + delta[1],\n        width: bx1 - bx0,\n        height: by1 - by0,\n        scaleX: 1,\n        scaleY: 1\n      };\n    } // Counter rotate the delta. This lets us make changes as if\n    // the (possibly rotated) boxes were axis aligned.\n\n\n    var _vec$rot = Vec.rot(delta, -rotation),\n        dx = _vec$rot[0],\n        dy = _vec$rot[1];\n    /*\r\n    1. Delta\r\n     Use the delta to adjust the new box by changing its corners.\r\n    The dragging handle (corner or edge) will determine which\r\n    corners should change.\r\n    */\n\n\n    switch (handle) {\n      case exports.TLBoundsEdge.Top:\n      case exports.TLBoundsCorner.TopLeft:\n      case exports.TLBoundsCorner.TopRight:\n        {\n          by0 += dy;\n          break;\n        }\n\n      case exports.TLBoundsEdge.Bottom:\n      case exports.TLBoundsCorner.BottomLeft:\n      case exports.TLBoundsCorner.BottomRight:\n        {\n          by1 += dy;\n          break;\n        }\n    }\n\n    switch (handle) {\n      case exports.TLBoundsEdge.Left:\n      case exports.TLBoundsCorner.TopLeft:\n      case exports.TLBoundsCorner.BottomLeft:\n        {\n          bx0 += dx;\n          break;\n        }\n\n      case exports.TLBoundsEdge.Right:\n      case exports.TLBoundsCorner.TopRight:\n      case exports.TLBoundsCorner.BottomRight:\n        {\n          bx1 += dx;\n          break;\n        }\n    }\n\n    var aw = ax1 - ax0;\n    var ah = ay1 - ay0;\n    var scaleX = (bx1 - bx0) / aw;\n    var scaleY = (by1 - by0) / ah;\n    var flipX = scaleX < 0;\n    var flipY = scaleY < 0;\n    var bw = Math.abs(bx1 - bx0);\n    var bh = Math.abs(by1 - by0);\n    /*\r\n    2. Aspect ratio\r\n     If the aspect ratio is locked, adjust the corners so that the\r\n    new box's aspect ratio matches the original aspect ratio.\r\n    */\n\n    if (isAspectRatioLocked) {\n      var ar = aw / ah;\n      var isTall = ar < bw / bh;\n      var tw = bw * (scaleY < 0 ? 1 : -1) * (1 / ar);\n      var th = bh * (scaleX < 0 ? 1 : -1) * ar;\n\n      switch (handle) {\n        case exports.TLBoundsCorner.TopLeft:\n          {\n            if (isTall) by0 = by1 + tw;else bx0 = bx1 + th;\n            break;\n          }\n\n        case exports.TLBoundsCorner.TopRight:\n          {\n            if (isTall) by0 = by1 + tw;else bx1 = bx0 - th;\n            break;\n          }\n\n        case exports.TLBoundsCorner.BottomRight:\n          {\n            if (isTall) by1 = by0 - tw;else bx1 = bx0 - th;\n            break;\n          }\n\n        case exports.TLBoundsCorner.BottomLeft:\n          {\n            if (isTall) by1 = by0 - tw;else bx0 = bx1 + th;\n            break;\n          }\n\n        case exports.TLBoundsEdge.Bottom:\n        case exports.TLBoundsEdge.Top:\n          {\n            var m = (bx0 + bx1) / 2;\n            var w = bh * ar;\n            bx0 = m - w / 2;\n            bx1 = m + w / 2;\n            break;\n          }\n\n        case exports.TLBoundsEdge.Left:\n        case exports.TLBoundsEdge.Right:\n          {\n            var _m = (by0 + by1) / 2;\n\n            var h = bw / ar;\n            by0 = _m - h / 2;\n            by1 = _m + h / 2;\n            break;\n          }\n      }\n    }\n    /*\r\n    3. Rotation\r\n     If the bounds are rotated, get a vector from the rotated anchor\r\n    corner in the inital bounds to the rotated anchor corner in the\r\n    result's bounds. Subtract this vector from the result's corners,\r\n    so that the two anchor points (initial and result) will be equal.\r\n    */\n\n\n    if (rotation % (Math.PI * 2) !== 0) {\n      var cv = [0, 0];\n      var c0 = Vec.med([ax0, ay0], [ax1, ay1]);\n      var c1 = Vec.med([bx0, by0], [bx1, by1]);\n\n      switch (handle) {\n        case exports.TLBoundsCorner.TopLeft:\n          {\n            cv = Vec.sub(Vec.rotWith([bx1, by1], c1, rotation), Vec.rotWith([ax1, ay1], c0, rotation));\n            break;\n          }\n\n        case exports.TLBoundsCorner.TopRight:\n          {\n            cv = Vec.sub(Vec.rotWith([bx0, by1], c1, rotation), Vec.rotWith([ax0, ay1], c0, rotation));\n            break;\n          }\n\n        case exports.TLBoundsCorner.BottomRight:\n          {\n            cv = Vec.sub(Vec.rotWith([bx0, by0], c1, rotation), Vec.rotWith([ax0, ay0], c0, rotation));\n            break;\n          }\n\n        case exports.TLBoundsCorner.BottomLeft:\n          {\n            cv = Vec.sub(Vec.rotWith([bx1, by0], c1, rotation), Vec.rotWith([ax1, ay0], c0, rotation));\n            break;\n          }\n\n        case exports.TLBoundsEdge.Top:\n          {\n            cv = Vec.sub(Vec.rotWith(Vec.med([bx0, by1], [bx1, by1]), c1, rotation), Vec.rotWith(Vec.med([ax0, ay1], [ax1, ay1]), c0, rotation));\n            break;\n          }\n\n        case exports.TLBoundsEdge.Left:\n          {\n            cv = Vec.sub(Vec.rotWith(Vec.med([bx1, by0], [bx1, by1]), c1, rotation), Vec.rotWith(Vec.med([ax1, ay0], [ax1, ay1]), c0, rotation));\n            break;\n          }\n\n        case exports.TLBoundsEdge.Bottom:\n          {\n            cv = Vec.sub(Vec.rotWith(Vec.med([bx0, by0], [bx1, by0]), c1, rotation), Vec.rotWith(Vec.med([ax0, ay0], [ax1, ay0]), c0, rotation));\n            break;\n          }\n\n        case exports.TLBoundsEdge.Right:\n          {\n            cv = Vec.sub(Vec.rotWith(Vec.med([bx0, by0], [bx0, by1]), c1, rotation), Vec.rotWith(Vec.med([ax0, ay0], [ax0, ay1]), c0, rotation));\n            break;\n          }\n      }\n\n      var _vec$sub = Vec.sub([bx0, by0], cv);\n\n      bx0 = _vec$sub[0];\n      by0 = _vec$sub[1];\n\n      var _vec$sub2 = Vec.sub([bx1, by1], cv);\n\n      bx1 = _vec$sub2[0];\n      by1 = _vec$sub2[1];\n    }\n    /*\r\n    4. Flips\r\n     If the axes are flipped (e.g. if the right edge has been dragged\r\n    left past the initial left edge) then swap points on that axis.\r\n    */\n\n\n    if (bx1 < bx0) {\n      var _ref5 = [bx0, bx1];\n      bx1 = _ref5[0];\n      bx0 = _ref5[1];\n    }\n\n    if (by1 < by0) {\n      var _ref6 = [by0, by1];\n      by1 = _ref6[0];\n      by0 = _ref6[1];\n    }\n\n    return {\n      minX: bx0,\n      minY: by0,\n      maxX: bx1,\n      maxY: by1,\n      width: bx1 - bx0,\n      height: by1 - by0,\n      scaleX: (bx1 - bx0) / (ax1 - ax0 || 1) * (flipX ? -1 : 1),\n      scaleY: (by1 - by0) / (ay1 - ay0 || 1) * (flipY ? -1 : 1)\n    };\n  };\n\n  Utils.getTransformAnchor = function getTransformAnchor(type, isFlippedX, isFlippedY) {\n    var anchor = type; // Change corner anchors if flipped\n\n    switch (type) {\n      case exports.TLBoundsCorner.TopLeft:\n        {\n          if (isFlippedX && isFlippedY) {\n            anchor = exports.TLBoundsCorner.BottomRight;\n          } else if (isFlippedX) {\n            anchor = exports.TLBoundsCorner.TopRight;\n          } else if (isFlippedY) {\n            anchor = exports.TLBoundsCorner.BottomLeft;\n          } else {\n            anchor = exports.TLBoundsCorner.BottomRight;\n          }\n\n          break;\n        }\n\n      case exports.TLBoundsCorner.TopRight:\n        {\n          if (isFlippedX && isFlippedY) {\n            anchor = exports.TLBoundsCorner.BottomLeft;\n          } else if (isFlippedX) {\n            anchor = exports.TLBoundsCorner.TopLeft;\n          } else if (isFlippedY) {\n            anchor = exports.TLBoundsCorner.BottomRight;\n          } else {\n            anchor = exports.TLBoundsCorner.BottomLeft;\n          }\n\n          break;\n        }\n\n      case exports.TLBoundsCorner.BottomRight:\n        {\n          if (isFlippedX && isFlippedY) {\n            anchor = exports.TLBoundsCorner.TopLeft;\n          } else if (isFlippedX) {\n            anchor = exports.TLBoundsCorner.BottomLeft;\n          } else if (isFlippedY) {\n            anchor = exports.TLBoundsCorner.TopRight;\n          } else {\n            anchor = exports.TLBoundsCorner.TopLeft;\n          }\n\n          break;\n        }\n\n      case exports.TLBoundsCorner.BottomLeft:\n        {\n          if (isFlippedX && isFlippedY) {\n            anchor = exports.TLBoundsCorner.TopRight;\n          } else if (isFlippedX) {\n            anchor = exports.TLBoundsCorner.BottomRight;\n          } else if (isFlippedY) {\n            anchor = exports.TLBoundsCorner.TopLeft;\n          } else {\n            anchor = exports.TLBoundsCorner.TopRight;\n          }\n\n          break;\n        }\n    }\n\n    return anchor;\n  }\n  /**\r\n   * Get the relative bounds (usually a child) within a transformed bounding box.\r\n   * @param bounds\r\n   * @param initialBounds\r\n   * @param initialShapeBounds\r\n   * @param isFlippedX\r\n   * @param isFlippedY\r\n   */\n  ;\n\n  Utils.getRelativeTransformedBoundingBox = function getRelativeTransformedBoundingBox(bounds, initialBounds, initialShapeBounds, isFlippedX, isFlippedY) {\n    var nx = (isFlippedX ? initialBounds.maxX - initialShapeBounds.maxX : initialShapeBounds.minX - initialBounds.minX) / initialBounds.width;\n    var ny = (isFlippedY ? initialBounds.maxY - initialShapeBounds.maxY : initialShapeBounds.minY - initialBounds.minY) / initialBounds.height;\n    var nw = initialShapeBounds.width / initialBounds.width;\n    var nh = initialShapeBounds.height / initialBounds.height;\n    var minX = bounds.minX + bounds.width * nx;\n    var minY = bounds.minY + bounds.height * ny;\n    var width = bounds.width * nw;\n    var height = bounds.height * nh;\n    return {\n      minX: minX,\n      minY: minY,\n      maxX: minX + width,\n      maxY: minY + height,\n      width: width,\n      height: height\n    };\n  }\n  /**\r\n   * Get the size of a rotated box.\r\n   * @param size : ;\r\n   * @param rotation\r\n   */\n  ;\n\n  Utils.getRotatedSize = function getRotatedSize(size, rotation) {\n    var center = Vec.div(size, 2);\n    var points = [[0, 0], [size[0], 0], size, [0, size[1]]].map(function (point) {\n      return Vec.rotWith(point, center, rotation);\n    });\n    var bounds = Utils.getBoundsFromPoints(points);\n    return [bounds.width, bounds.height];\n  }\n  /**\r\n   * Get the center of a bounding box.\r\n   * @param bounds\r\n   */\n  ;\n\n  Utils.getBoundsCenter = function getBoundsCenter(bounds) {\n    return [bounds.minX + bounds.width / 2, bounds.minY + bounds.height / 2];\n  }\n  /* -------------------------------------------------- */\n\n  /*                Lists and Collections               */\n\n  /* -------------------------------------------------- */\n\n  /**\r\n   *\r\n   *\r\n   * ### Example\r\n   *\r\n   *```ts\r\n   * example\r\n   *```\r\n   */\n  ;\n\n  Utils.removeDuplicatePoints = function removeDuplicatePoints(points) {\n    return points.reduce(function (acc, pt, i) {\n      if (i === 0 || !Vec.isEqual(pt, acc[i - 1])) {\n        acc.push(pt);\n      }\n\n      return acc;\n    }, []);\n  }\n  /**\r\n  // points =\r\n   \n  /**\r\n  * Get a value from a cache (a WeakMap), filling the value if it is not present.\r\n  *\r\n  * ### Example\r\n  *\r\n  *```ts\r\n  * getFromCache(boundsCache, shape, (cache) => cache.set(shape, \"value\"))\r\n  *```\r\n  */\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  ;\n\n  Utils.getFromCache = function getFromCache(cache, item, getNext) {\n    var value = cache.get(item);\n\n    if (value === undefined) {\n      cache.set(item, getNext());\n      value = cache.get(item);\n\n      if (value === undefined) {\n        throw Error('Cache did not include item!');\n      }\n    }\n\n    return value;\n  }\n  /**\r\n   * Get a unique string id.\r\n   */\n  ;\n\n  Utils.uniqueId = function uniqueId(a) {\n    if (a === void 0) {\n      a = '';\n    }\n\n    return a ?\n    /* eslint-disable no-bitwise */\n    ((Number(a) ^ Math.random() * 16) >> Number(a) / 4).toString(16) : (1e7 + \"-\" + 1e3 + \"-\" + 4e3 + \"-\" + 8e3 + \"-\" + 1e11).replace(/[018]/g, Utils.uniqueId);\n  }\n  /**\r\n   * Shuffle the contents of an array.\r\n   * @param arr\r\n   * @param offset\r\n   */\n  ;\n\n  Utils.shuffleArr = function shuffleArr(arr, offset) {\n    return arr.map(function (_, i) {\n      return arr[(i + offset) % arr.length];\n    });\n  }\n  /**\r\n   * Deep compare two arrays.\r\n   * @param a\r\n   * @param b\r\n   */\n  ;\n\n  Utils.deepCompareArrays = function deepCompareArrays(a, b) {\n    if ((a == null ? void 0 : a.length) !== (b == null ? void 0 : b.length)) return false;\n    return Utils.deepCompare(a, b);\n  }\n  /**\r\n   * Deep compare any values.\r\n   * @param a\r\n   * @param b\r\n   */\n  ;\n\n  Utils.deepCompare = function deepCompare(a, b) {\n    return a === b || JSON.stringify(a) === JSON.stringify(b);\n  };\n\n  Utils.arrsIntersect = function arrsIntersect(a, b, fn) {\n    return a.some(function (item) {\n      return b.includes(fn ? fn(item) : item);\n    });\n  }\n  /**\r\n   * Get the unique values from an array of strings or numbers.\r\n   * @param items\r\n   */\n  ;\n\n  Utils.uniqueArray = function uniqueArray() {\n    for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {\n      items[_key] = arguments[_key];\n    }\n\n    return Array.from(new Set(items).values());\n  }\n  /**\r\n   * Convert a set to an array.\r\n   * @param set\r\n   */\n  ;\n\n  Utils.setToArray = function setToArray(set) {\n    return Array.from(set.values());\n  }\n  /**\r\n   * Debounce a function.\r\n   */\n  ;\n\n  Utils.debounce = function debounce(fn, ms) {\n    if (ms === void 0) {\n      ms = 0;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    var timeoutId;\n    return function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(function () {\n        return fn.apply(args);\n      }, ms);\n    };\n  }\n  /**\r\n   * Turn an array of points into a path of quadradic curves.\r\n   * @param stroke ;\r\n   */\n  ;\n\n  Utils.getSvgPathFromStroke = function getSvgPathFromStroke(stroke) {\n    if (!stroke.length) return '';\n    var d = stroke.reduce(function (acc, _ref7, i, arr) {\n      var x0 = _ref7[0],\n          y0 = _ref7[1];\n      var _arr = arr[(i + 1) % arr.length],\n          x1 = _arr[0],\n          y1 = _arr[1];\n      acc.push(\" \" + x0 + \",\" + y0 + \" \" + (x0 + x1) / 2 + \",\" + (y0 + y1) / 2);\n      return acc;\n    }, ['M ', stroke[0][0] + \",\" + stroke[0][1], ' Q']);\n    d.push(' Z');\n    return d.join('').replaceAll(/(\\s?[A-Z]?,?-?[0-9]*\\.[0-9]{0,2})(([0-9]|e|-)*)/g, '$1');\n  }\n  /* -------------------------------------------------- */\n\n  /*                   Browser and DOM                  */\n\n  /* -------------------------------------------------- */\n\n  /**\r\n   * Find whether the current display is a touch display.\r\n   */\n  ;\n\n  Utils.isTouchDisplay = function isTouchDisplay() {\n    return 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;\n  }\n  /**\r\n   * Find whether the current device is a Mac / iOS / iPadOS.\r\n   */\n  ;\n\n  Utils.isDarwin = function isDarwin() {\n    return /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);\n  }\n  /**\r\n   * Get whether the current device is a mobile device.\r\n   */\n  ;\n\n  Utils.isMobile = function isMobile() {\n    return false; // _isMobile().any\n  }\n  /**\r\n   * Get whether an event is command (mac) or control (pc).\r\n   * @param e\r\n   */\n  ;\n\n  Utils.metaKey = function metaKey(e) {\n    return Utils.isDarwin() ? e.metaKey : e.ctrlKey;\n  }\n  /**\r\n   * Find the closest point on a SVG path to an off-path point.\r\n   * @param pathNode\r\n   * @param point\r\n   * @returns\r\n   */\n  ;\n\n  Utils.getClosestPointOnSVGPath = function getClosestPointOnSVGPath(pathNode, point) {\n    function distance2(p, point) {\n      var dx = p.x - point[0];\n      var dy = p.y - point[1];\n      return dx * dx + dy * dy;\n    }\n\n    var pathLen = pathNode.getTotalLength();\n    var p = 8;\n    var best = {};\n    var bestLen = Infinity;\n    var bestDist = Infinity;\n    var bl = 0;\n    var al = 0; // linear scan for coarse approximation\n\n    for (var scan, scanLen = 0, scanDist; scanLen <= pathLen; scanLen += p) {\n      if ((scanDist = distance2(scan = pathNode.getPointAtLength(scanLen), point)) < bestDist) {\n        best = scan;\n        bestLen = scanLen;\n        bestDist = scanDist;\n      }\n    } // binary search for precise estimate\n\n\n    p /= 2;\n\n    while (p > 0.5) {\n      var before = void 0,\n          after = void 0,\n          bd = void 0,\n          ad = void 0;\n\n      if ((bl = bestLen - p) >= 0 && (bd = distance2(before = pathNode.getPointAtLength(bl), point)) < bestDist) {\n        best = before;\n        bestLen = bl;\n        bestDist = bd;\n      } else if ((al = bestLen + p) <= pathLen && (ad = distance2(after = pathNode.getPointAtLength(al), point)) < bestDist) {\n        best = after;\n        bestLen = al;\n        bestDist = ad;\n      } else {\n        p /= 2;\n      }\n    }\n\n    return {\n      point: [best.x, best.y],\n      distance: bestDist,\n      length: (bl + al) / 2,\n      t: (bl + al) / 2 / pathLen\n    };\n  };\n\n  return Utils;\n}();\n\n/* ----------------- Start Copy Here ---------------- */\n\nfunction getIntersection(message) {\n  for (var _len = arguments.length, points = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    points[_key - 1] = arguments[_key];\n  }\n\n  var didIntersect = points.length > 0;\n  return {\n    didIntersect: didIntersect,\n    message: message,\n    points: points\n  };\n}\n\nvar Intersect = function Intersect() {};\nIntersect.ray = {\n  // Intersect a ray with a ray.\n  ray: function ray(p0, n0, p1, n1) {\n    var dx = p1[0] - p0[0];\n    var dy = p1[1] - p0[1];\n    var det = n1[0] * n0[1] - n1[1] * n0[0];\n    var u = (dy * n1[0] - dx * n1[1]) / det;\n    var v = (dy * n0[0] - dx * n0[1]) / det;\n    if (u < 0 || v < 0) return getIntersection('miss');\n    var m0 = n0[1] / n0[0];\n    var m1 = n1[1] / n1[0];\n    var b0 = p0[1] - m0 * p0[0];\n    var b1 = p1[1] - m1 * p1[0];\n    var x = (b1 - b0) / (m0 - m1);\n    var y = m0 * x + b0;\n    return Number.isFinite(x) ? getIntersection('intersection', [x, y]) : getIntersection('parallel');\n  },\n  // Interseg a ray with a line segment.\n  lineSegment: function lineSegment(origin, direction, a1, a2) {\n    var x = origin[0],\n        y = origin[1];\n    var dx = direction[0],\n        dy = direction[1];\n    var x1 = a1[0],\n        y1 = a1[1];\n    var x2 = a2[0],\n        y2 = a2[1];\n\n    if (dy / dx !== (y2 - y1) / (x2 - x1)) {\n      var d = dx * (y2 - y1) - dy * (x2 - x1);\n\n      if (d !== 0) {\n        var r = ((y - y1) * (x2 - x1) - (x - x1) * (y2 - y1)) / d;\n        var s = ((y - y1) * dx - (x - x1) * dy) / d;\n\n        if (r >= 0 && s >= 0 && s <= 1) {\n          return getIntersection('intersection', [x + r * dx, y + r * dy]);\n        }\n      }\n    }\n\n    return getIntersection('no intersection');\n  },\n  // Intersect a ray with a rectangle.\n  rectangle: function rectangle(origin, direction, point, size) {\n    return Intersect.rectangle.ray(point, size, origin, direction);\n  },\n  // Intersect a ray with an ellipse.\n  ellipse: function ellipse(origin, direction, center, rx, ry, rotation) {\n    var a1 = origin;\n    var a2 = Vec.mul(direction, 999999999);\n    return Intersect.lineSegment.ellipse(a1, a2, center, rx, ry, rotation);\n  },\n  // Intersect a ray with a bounding box.\n  bounds: function bounds(origin, direction, _bounds) {\n    var minX = _bounds.minX,\n        minY = _bounds.minY,\n        width = _bounds.width,\n        height = _bounds.height;\n    return Intersect.ray.rectangle(origin, direction, [minX, minY], [width, height]);\n  }\n};\nIntersect.lineSegment = {\n  // Intersect a line segment with a ray.\n  ray: function ray(a1, a2, origin, direction) {\n    return Intersect.ray.lineSegment(origin, direction, a1, a2);\n  },\n  // Intersect a line segment with a line segment.\n  lineSegment: function lineSegment(a1, a2, b1, b2) {\n    var AB = Vec.sub(a1, b1);\n    var BV = Vec.sub(b2, b1);\n    var AV = Vec.sub(a2, a1);\n    var ua_t = BV[0] * AB[1] - BV[1] * AB[0];\n    var ub_t = AV[0] * AB[1] - AV[1] * AB[0];\n    var u_b = BV[1] * AV[0] - BV[0] * AV[1];\n\n    if (ua_t === 0 || ub_t === 0) {\n      return getIntersection('coincident');\n    }\n\n    if (u_b === 0) {\n      return getIntersection('parallel');\n    }\n\n    if (u_b !== 0) {\n      var ua = ua_t / u_b;\n      var ub = ub_t / u_b;\n\n      if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {\n        return getIntersection('intersection', Vec.add(a1, Vec.mul(AV, ua)));\n      }\n    }\n\n    return getIntersection('no intersection');\n  },\n  // Intersect a line segment with a rectangle\n  rectangle: function rectangle(a1, a2, point, size) {\n    return Intersect.rectangle.lineSegment(point, size, a1, a2);\n  },\n  // Intersect a line segment with an arc.\n  arc: function arc(a1, a2, center, radius, start, end) {\n    var sa = Vec.angle(center, start);\n    var ea = Vec.angle(center, end);\n    var ellipseTest = Intersect.ellipse.lineSegment(center, radius, radius, 0, a1, a2);\n    if (!ellipseTest.didIntersect) return getIntersection('No intersection');\n    var points = ellipseTest.points.filter(function (point) {\n      return Utils.isAngleBetween(sa, ea, Vec.angle(center, point));\n    });\n\n    if (points.length === 0) {\n      return getIntersection('No intersection');\n    }\n\n    return getIntersection.apply(void 0, ['intersection'].concat(points));\n  },\n  // Intersect a line segment with a circle.\n  circle: function circle(a1, a2, c, r) {\n    var a = (a2[0] - a1[0]) * (a2[0] - a1[0]) + (a2[1] - a1[1]) * (a2[1] - a1[1]);\n    var b = 2 * ((a2[0] - a1[0]) * (a1[0] - c[0]) + (a2[1] - a1[1]) * (a1[1] - c[1]));\n    var cc = c[0] * c[0] + c[1] * c[1] + a1[0] * a1[0] + a1[1] * a1[1] - 2 * (c[0] * a1[0] + c[1] * a1[1]) - r * r;\n    var deter = b * b - 4 * a * cc;\n\n    if (deter < 0) {\n      return getIntersection('outside');\n    }\n\n    if (deter === 0) {\n      return getIntersection('tangent');\n    }\n\n    var e = Math.sqrt(deter);\n    var u1 = (-b + e) / (2 * a);\n    var u2 = (-b - e) / (2 * a);\n\n    if ((u1 < 0 || u1 > 1) && (u2 < 0 || u2 > 1)) {\n      if (u1 < 0 && u2 < 0 || u1 > 1 && u2 > 1) {\n        return getIntersection('outside');\n      } else {\n        return getIntersection('inside');\n      }\n    }\n\n    var results = [];\n    if (0 <= u1 && u1 <= 1) results.push(Vec.lrp(a1, a2, u1));\n    if (0 <= u2 && u2 <= 1) results.push(Vec.lrp(a1, a2, u2));\n    return getIntersection.apply(void 0, ['intersection'].concat(results));\n  },\n  // Intersect a line segment with an ellipse.\n  ellipse: function ellipse(a1, a2, center, rx, ry, rotation) {\n    if (rotation === void 0) {\n      rotation = 0;\n    }\n\n    // If the ellipse or line segment are empty, return no tValues.\n    if (rx === 0 || ry === 0 || Vec.isEqual(a1, a2)) {\n      return getIntersection('No intersection');\n    } // Get the semimajor and semiminor axes.\n\n\n    rx = rx < 0 ? rx : -rx;\n    ry = ry < 0 ? ry : -ry; // Rotate points and translate so the ellipse is centered at the origin.\n\n    a1 = Vec.sub(Vec.rotWith(a1, center, -rotation), center);\n    a2 = Vec.sub(Vec.rotWith(a2, center, -rotation), center); // Calculate the quadratic parameters.\n\n    var diff = Vec.sub(a2, a1);\n    var A = diff[0] * diff[0] / rx / rx + diff[1] * diff[1] / ry / ry;\n    var B = 2 * a1[0] * diff[0] / rx / rx + 2 * a1[1] * diff[1] / ry / ry;\n    var C = a1[0] * a1[0] / rx / rx + a1[1] * a1[1] / ry / ry - 1; // Make a list of t values (normalized points on the line where intersections occur).\n\n    var tValues = []; // Calculate the discriminant.\n\n    var discriminant = B * B - 4 * A * C;\n\n    if (discriminant === 0) {\n      // One real solution.\n      tValues.push(-B / 2 / A);\n    } else if (discriminant > 0) {\n      var root = Math.sqrt(discriminant); // Two real solutions.\n\n      tValues.push((-B + root) / 2 / A);\n      tValues.push((-B - root) / 2 / A);\n    } // Filter to only points that are on the segment.\n    // Solve for points, then counter-rotate points.\n\n\n    var points = tValues.filter(function (t) {\n      return t >= 0 && t <= 1;\n    }).map(function (t) {\n      return Vec.add(center, Vec.add(a1, Vec.mul(Vec.sub(a2, a1), t)));\n    }).map(function (p) {\n      return Vec.rotWith(p, center, rotation);\n    });\n    return getIntersection.apply(void 0, ['intersection'].concat(points));\n  },\n  // Intersect a line segment with a bounding box.\n  bounds: function bounds(a1, a2, _bounds2) {\n    return Intersect.bounds.lineSegment(_bounds2, a1, a2);\n  },\n  // Intersect a line segment with a polyline\n  polyline: function polyline(a1, a2, points) {\n    var intersections = [];\n\n    for (var i = 1; i < points.length + 1; i++) {\n      var _int = Intersect.lineSegment.lineSegment(a1, a2, points[i - 1], points[i % points.length]);\n\n      if (_int) {\n        intersections.push(_int);\n      }\n    }\n\n    return intersections;\n  }\n};\nIntersect.rectangle = {\n  // Intersect a rectangle with a ray.\n  ray: function ray(point, size, origin, direction) {\n    var sideIntersections = Utils.getRectangleSides(point, size).reduce(function (acc, _ref) {\n      var message = _ref[0],\n          _ref$ = _ref[1],\n          a1 = _ref$[0],\n          a2 = _ref$[1];\n      var intersection = Intersect.ray.lineSegment(origin, direction, a1, a2);\n\n      if (intersection) {\n        acc.push(getIntersection.apply(void 0, [message].concat(intersection.points)));\n      }\n\n      return acc;\n    }, []);\n    return sideIntersections.filter(function (_int2) {\n      return _int2.didIntersect;\n    });\n  },\n  // Intersect a rectangle with a line segment.\n  lineSegment: function lineSegment(point, size, a1, a2) {\n    var sideIntersections = Utils.getRectangleSides(point, size).reduce(function (acc, _ref2) {\n      var message = _ref2[0],\n          _ref2$ = _ref2[1],\n          b1 = _ref2$[0],\n          b2 = _ref2$[1];\n      var intersection = Intersect.lineSegment.lineSegment(a1, a2, b1, b2);\n\n      if (intersection) {\n        acc.push(getIntersection.apply(void 0, [message].concat(intersection.points)));\n      }\n\n      return acc;\n    }, []);\n    return sideIntersections.filter(function (_int3) {\n      return _int3.didIntersect;\n    });\n  },\n  // Intersect a rectangle with a rectangle.\n  rectangle: function rectangle(point1, size1, point2, size2) {\n    var sideIntersections = Utils.getRectangleSides(point1, size1).reduce(function (acc, _ref3) {\n      var message = _ref3[0],\n          _ref3$ = _ref3[1],\n          a1 = _ref3$[0],\n          a2 = _ref3$[1];\n      var intersections = Intersect.rectangle.lineSegment(point2, size2, a1, a2);\n      acc.push.apply(acc, intersections.map(function (_int4) {\n        return getIntersection.apply(void 0, [message + \" \" + _int4.message].concat(_int4.points));\n      }));\n      return acc;\n    }, []);\n    return sideIntersections.filter(function (_int5) {\n      return _int5.didIntersect;\n    });\n  },\n  // Intersect a rectangle with an arc.\n  arc: function arc(point, size, center, radius, start, end) {\n    var sideIntersections = Utils.getRectangleSides(point, size).reduce(function (acc, _ref4) {\n      var message = _ref4[0],\n          _ref4$ = _ref4[1],\n          a1 = _ref4$[0],\n          a2 = _ref4$[1];\n      var intersection = Intersect.arc.lineSegment(center, radius, start, end, a1, a2);\n\n      if (intersection) {\n        acc.push(_extends({}, intersection, {\n          message: message\n        }));\n      }\n\n      return acc;\n    }, []);\n    return sideIntersections.filter(function (_int6) {\n      return _int6.didIntersect;\n    });\n  },\n  // Intersect a rectangle with a circle.\n  circle: function circle(point, size, c, r) {\n    var sideIntersections = Utils.getRectangleSides(point, size).reduce(function (acc, _ref5) {\n      var message = _ref5[0],\n          _ref5$ = _ref5[1],\n          a1 = _ref5$[0],\n          a2 = _ref5$[1];\n      var intersection = Intersect.lineSegment.circle(a1, a2, c, r);\n\n      if (intersection) {\n        acc.push(_extends({}, intersection, {\n          message: message\n        }));\n      }\n\n      return acc;\n    }, []);\n    return sideIntersections.filter(function (_int7) {\n      return _int7.didIntersect;\n    });\n  },\n  // Intersect a rectangle with an ellipse.\n  ellipse: function ellipse(point, size, c, rx, ry, rotation) {\n    if (rotation === void 0) {\n      rotation = 0;\n    }\n\n    var sideIntersections = Utils.getRectangleSides(point, size).reduce(function (acc, _ref6) {\n      var message = _ref6[0],\n          _ref6$ = _ref6[1],\n          a1 = _ref6$[0],\n          a2 = _ref6$[1];\n      var intersection = Intersect.lineSegment.ellipse(a1, a2, c, rx, ry, rotation);\n\n      if (intersection) {\n        acc.push(_extends({}, intersection, {\n          message: message\n        }));\n      }\n\n      return acc;\n    }, []);\n    return sideIntersections.filter(function (_int8) {\n      return _int8.didIntersect;\n    });\n  },\n  // Intersect a rectangle with a bounding box.\n  bounds: function bounds(point, size, _bounds3) {\n    var minX = _bounds3.minX,\n        minY = _bounds3.minY,\n        width = _bounds3.width,\n        height = _bounds3.height;\n    return Intersect.rectangle.rectangle(point, size, [minX, minY], [width, height]);\n  },\n  // Intersect a rectangle with a polyline\n  polyline: function polyline(point, size, points) {\n    var sideIntersections = Utils.getRectangleSides(point, size).reduce(function (acc, _ref7) {\n      var message = _ref7[0],\n          _ref7$ = _ref7[1],\n          a1 = _ref7$[0],\n          a2 = _ref7$[1];\n      var intersections = Intersect.lineSegment.polyline(a1, a2, points);\n\n      if (intersections.length > 0) {\n        acc.push(getIntersection.apply(void 0, [message].concat(intersections.flatMap(function (i) {\n          return i.points;\n        }))));\n      }\n\n      return acc;\n    }, []);\n    return sideIntersections.filter(function (_int9) {\n      return _int9.didIntersect;\n    });\n  }\n};\nIntersect.arc = {\n  // Intersect an arc with a line segment.\n  lineSegment: function lineSegment(center, radius, start, end, a1, a2) {\n    return Intersect.lineSegment.arc(a1, a2, center, radius, start, end);\n  },\n  // Intersect an arc with a rectangle.\n  rectangle: function rectangle(center, radius, start, end, point, size) {\n    return Intersect.rectangle.arc(point, size, center, radius, start, end);\n  },\n  // Intersect an arc with a bounding box.\n  bounds: function bounds(center, radius, start, end, _bounds4) {\n    var minX = _bounds4.minX,\n        minY = _bounds4.minY,\n        width = _bounds4.width,\n        height = _bounds4.height;\n    return Intersect.arc.rectangle(center, radius, start, end, [minX, minY], [width, height]);\n  }\n};\nIntersect.circle = {\n  // Intersect a circle with a line segment.\n  lineSegment: function lineSegment(c, r, a1, a2) {\n    return Intersect.lineSegment.circle(a1, a2, c, r);\n  },\n  // Intersect a circle with a circle.\n  circle: function circle(c1, r1, c2, r2) {\n    var dx = c2[0] - c1[0],\n        dy = c2[1] - c1[1];\n    var d = Math.sqrt(dx * dx + dy * dy),\n        x = (d * d - r2 * r2 + r1 * r1) / (2 * d),\n        y = Math.sqrt(r1 * r1 - x * x);\n    dx /= d;\n    dy /= d;\n    return getIntersection('intersection', [c1[0] + dx * x - dy * y, c1[1] + dy * x + dx * y], [c1[0] + dx * x + dy * y, c1[1] + dy * x - dx * y]);\n  },\n  // Intersect a circle with a rectangle.\n  rectangle: function rectangle(c, r, point, size) {\n    return Intersect.rectangle.circle(point, size, c, r);\n  },\n  // Intersect a circle with a bounding box.\n  bounds: function bounds(c, r, _bounds5) {\n    var minX = _bounds5.minX,\n        minY = _bounds5.minY,\n        width = _bounds5.width,\n        height = _bounds5.height;\n    return Intersect.circle.rectangle(c, r, [minX, minY], [width, height]);\n  }\n};\nIntersect.ellipse = {\n  // Intersect an ellipse with a ray.\n  ray: function ray(center, rx, ry, rotation, point, direction) {\n    return Intersect.ray.ellipse(point, direction, center, rx, ry, rotation);\n  },\n  // Intersect an ellipse with a line segment.\n  lineSegment: function lineSegment(center, rx, ry, rotation, a1, a2) {\n    if (rotation === void 0) {\n      rotation = 0;\n    }\n\n    if (rx === ry) {\n      return Intersect.lineSegment.circle(a1, a2, center, rx);\n    }\n\n    return Intersect.lineSegment.ellipse(a1, a2, center, rx, ry, rotation);\n  },\n  // Intersect an ellipse with a rectangle.\n  rectangle: function rectangle(center, rx, ry, rotation, point, size) {\n    if (rotation === void 0) {\n      rotation = 0;\n    }\n\n    if (rx === ry) {\n      return Intersect.rectangle.circle(point, size, center, rx);\n    }\n\n    return Intersect.rectangle.ellipse(point, size, center, rx, ry, rotation);\n  },\n  // Get an intersection between an ellipse and a second ellipse.\n  // Adapted from https://gist.github.com/drawable/92792f59b6ff8869d8b1\n  ellipse: function ellipse(_c1, _rx1, _ry1, _r1, _c2, _rx2, _ry2, _r2) {\n    // TODO\n    return getIntersection('no intersection');\n  },\n  circle: function circle(c, rx, ry, rotation, c2, r2) {\n    return Intersect.ellipse.ellipse(c, rx, ry, rotation, c2, r2, r2, 0);\n  },\n  // Intersect an ellipse with a bounding box.\n  bounds: function bounds(c, rx, ry, rotation, _bounds6) {\n    var minX = _bounds6.minX,\n        minY = _bounds6.minY,\n        width = _bounds6.width,\n        height = _bounds6.height;\n    return Intersect.ellipse.rectangle(c, rx, ry, rotation, [minX, minY], [width, height]);\n  }\n};\nIntersect.bounds = {\n  ray: function ray(bounds, origin, direction) {\n    var minX = bounds.minX,\n        minY = bounds.minY,\n        width = bounds.width,\n        height = bounds.height;\n    return Intersect.ray.rectangle(origin, direction, [minX, minY], [width, height]);\n  },\n  lineSegment: function lineSegment(bounds, a1, a2) {\n    var minX = bounds.minX,\n        minY = bounds.minY,\n        width = bounds.width,\n        height = bounds.height;\n    return Intersect.lineSegment.rectangle(a1, a2, [minX, minY], [width, height]);\n  },\n  rectangle: function rectangle(bounds, point, size) {\n    var minX = bounds.minX,\n        minY = bounds.minY,\n        width = bounds.width,\n        height = bounds.height;\n    return Intersect.rectangle.rectangle(point, size, [minX, minY], [width, height]);\n  },\n  bounds: function bounds(bounds1, bounds2) {\n    return Intersect.rectangle.rectangle([bounds1.minX, bounds1.minY], [bounds1.width, bounds1.height], [bounds2.minX, bounds2.minY], [bounds2.width, bounds2.height]);\n  },\n  arc: function arc(bounds, center, radius, start, end) {\n    var minX = bounds.minX,\n        minY = bounds.minY,\n        width = bounds.width,\n        height = bounds.height;\n    return Intersect.arc.rectangle(center, radius, start, end, [minX, minY], [width, height]);\n  },\n  circle: function circle(bounds, c, r) {\n    var minX = bounds.minX,\n        minY = bounds.minY,\n        width = bounds.width,\n        height = bounds.height;\n    return Intersect.circle.rectangle(c, r, [minX, minY], [width, height]);\n  },\n  ellipse: function ellipse(bounds, c, rx, ry, rotation) {\n    if (rotation === void 0) {\n      rotation = 0;\n    }\n\n    var minX = bounds.minX,\n        minY = bounds.minY,\n        width = bounds.width,\n        height = bounds.height;\n    return Intersect.ellipse.rectangle(c, rx, ry, rotation, [minX, minY], [width, height]);\n  },\n  polyline: function polyline(bounds, points) {\n    return Intersect.polyline.bounds(points, bounds);\n  }\n};\nIntersect.polyline = {\n  // Intersect a polyline with a line segment.\n  lineSegment: function lineSegment(points, a1, a2) {\n    return Intersect.lineSegment.polyline(a1, a2, points);\n  },\n  // Interesct a polyline with a rectangle.\n  rectangle: function rectangle(points, point, size) {\n    return Intersect.rectangle.polyline(point, size, points);\n  },\n  // Intersect a polyline with a bounding box.\n  bounds: function bounds(points, _bounds7) {\n    return Intersect.rectangle.polyline([_bounds7.minX, _bounds7.minY], [_bounds7.width, _bounds7.height], points);\n  }\n};\n\nvar Svg = function Svg() {};\n\nSvg.ellipse = function (A, r) {\n  return \"M \" + (A[0] - r) + \",\" + A[1] + \"\\n      a \" + r + \",\" + r + \" 0 1,0 \" + r * 2 + \",0\\n      a \" + r + \",\" + r + \" 0 1,0 -\" + r * 2 + \",0 \";\n};\n\nSvg.moveTo = function (v) {\n  return \"M \" + v[0] + \",\" + v[1] + \" \";\n};\n\nSvg.lineTo = function (v) {\n  return \"L \" + v[0] + \",\" + v[1] + \" \";\n};\n\nSvg.line = function (a) {\n  for (var _len = arguments.length, pts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    pts[_key - 1] = arguments[_key];\n  }\n\n  return Svg.moveTo(a) + pts.map(function (p) {\n    return Svg.lineTo(p);\n  }).join();\n};\n\nSvg.hLineTo = function (v) {\n  return \"H \" + v[0] + \",\" + v[1] + \" \";\n};\n\nSvg.vLineTo = function (v) {\n  return \"V \" + v[0] + \",\" + v[1] + \" \";\n};\n\nSvg.bezierTo = function (A, B, C) {\n  return \"C \" + A[0] + \",\" + A[1] + \" \" + B[0] + \",\" + B[1] + \" \" + C[0] + \",\" + C[1] + \" \";\n};\n\nSvg.arcTo = function (C, r, A, B) {\n  return [Svg.moveTo(A), 'A', r, r, 0, Utils.getSweep(C, A, B) > 0 ? '1' : '0', 0, B[0], B[1]].join(' ');\n};\n\nSvg.closePath = function () {\n  return 'Z';\n};\n\nSvg.rectTo = function (A) {\n  return ['R', A[0], A[1]].join(' ');\n};\n\nSvg.getPointAtLength = function (path, length) {\n  var point = path.getPointAtLength(length);\n  return [point.x, point.y];\n};\n\nvar DOUBLE_CLICK_DURATION = 250;\n\nvar Inputs = /*#__PURE__*/function () {\n  function Inputs() {\n    var _this = this;\n\n    this.pointer = void 0;\n    this.keyboard = void 0;\n    this.keys = {};\n    this.pointerUpTime = 0;\n\n    this.panStart = function (e) {\n      var _this$pointer, _this$pointer2;\n\n      var shiftKey = e.shiftKey,\n          ctrlKey = e.ctrlKey,\n          metaKey = e.metaKey,\n          altKey = e.altKey;\n      var info = {\n        target: 'wheel',\n        pointerId: ((_this$pointer = _this.pointer) == null ? void 0 : _this$pointer.pointerId) || 0,\n        origin: ((_this$pointer2 = _this.pointer) == null ? void 0 : _this$pointer2.origin) || [0, 0],\n        delta: [0, 0],\n        pressure: 0.5,\n        point: Inputs.getPoint(e),\n        shiftKey: shiftKey,\n        ctrlKey: ctrlKey,\n        metaKey: metaKey,\n        altKey: altKey\n      };\n      _this.pointer = info;\n      return info;\n    };\n\n    this.pan = function (delta, e) {\n      if (!_this.pointer || _this.pointer.target !== 'wheel') {\n        return _this.panStart(e);\n      }\n\n      var shiftKey = e.shiftKey,\n          ctrlKey = e.ctrlKey,\n          metaKey = e.metaKey,\n          altKey = e.altKey;\n      var prev = _this.pointer;\n      var point = Inputs.getPoint(e);\n\n      var info = _extends({}, prev, {\n        target: 'wheel',\n        delta: delta,\n        point: Vec.sub(point, delta),\n        shiftKey: shiftKey,\n        ctrlKey: ctrlKey,\n        metaKey: metaKey,\n        altKey: altKey\n      });\n\n      _this.pointer = info;\n      return info;\n    };\n\n    this.canAccept = function (_pointerId) {\n      return true; //   return (\n      //     this.activePointerId === undefined || this.activePointerId === pointerId\n      //   )\n    };\n\n    this.keydown = function (e) {\n      var _this$pointer3, _this$pointer4;\n\n      var shiftKey = e.shiftKey,\n          ctrlKey = e.ctrlKey,\n          metaKey = e.metaKey,\n          altKey = e.altKey;\n      _this.keys[e.key] = true;\n      return {\n        point: ((_this$pointer3 = _this.pointer) == null ? void 0 : _this$pointer3.point) || [0, 0],\n        origin: ((_this$pointer4 = _this.pointer) == null ? void 0 : _this$pointer4.origin) || [0, 0],\n        key: e.key,\n        keys: Object.keys(_this.keys),\n        shiftKey: shiftKey,\n        ctrlKey: ctrlKey,\n        metaKey: Utils.isDarwin() ? metaKey : ctrlKey,\n        altKey: altKey\n      };\n    };\n\n    this.keyup = function (e) {\n      var _this$pointer5, _this$pointer6;\n\n      var shiftKey = e.shiftKey,\n          ctrlKey = e.ctrlKey,\n          metaKey = e.metaKey,\n          altKey = e.altKey;\n      delete _this.keys[e.key];\n      return {\n        point: ((_this$pointer5 = _this.pointer) == null ? void 0 : _this$pointer5.point) || [0, 0],\n        origin: ((_this$pointer6 = _this.pointer) == null ? void 0 : _this$pointer6.origin) || [0, 0],\n        key: e.key,\n        keys: Object.keys(_this.keys),\n        shiftKey: shiftKey,\n        ctrlKey: ctrlKey,\n        metaKey: Utils.isDarwin() ? metaKey : ctrlKey,\n        altKey: altKey\n      };\n    };\n  }\n\n  var _proto = Inputs.prototype;\n\n  _proto.touchStart = function touchStart(e, target) {\n    var shiftKey = e.shiftKey,\n        ctrlKey = e.ctrlKey,\n        metaKey = e.metaKey,\n        altKey = e.altKey;\n    e.preventDefault();\n    var touch = e.changedTouches[0];\n    var info = {\n      target: target,\n      pointerId: touch.identifier,\n      origin: Inputs.getPoint(touch),\n      delta: [0, 0],\n      point: Inputs.getPoint(touch),\n      pressure: Inputs.getPressure(touch),\n      shiftKey: shiftKey,\n      ctrlKey: ctrlKey,\n      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,\n      altKey: altKey\n    };\n    this.pointer = info;\n    return info;\n  };\n\n  _proto.touchMove = function touchMove(e, target) {\n    var shiftKey = e.shiftKey,\n        ctrlKey = e.ctrlKey,\n        metaKey = e.metaKey,\n        altKey = e.altKey;\n    e.preventDefault();\n    var touch = e.changedTouches[0];\n    var prev = this.pointer;\n    var point = Inputs.getPoint(touch);\n    var delta = prev != null && prev.point ? Vec.sub(point, prev.point) : [0, 0];\n\n    var info = _extends({\n      origin: point\n    }, prev, {\n      target: target,\n      pointerId: touch.identifier,\n      point: point,\n      delta: delta,\n      pressure: Inputs.getPressure(touch),\n      shiftKey: shiftKey,\n      ctrlKey: ctrlKey,\n      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,\n      altKey: altKey\n    });\n\n    this.pointer = info;\n    return info;\n  };\n\n  _proto.pointerDown = function pointerDown(e, target) {\n    var shiftKey = e.shiftKey,\n        ctrlKey = e.ctrlKey,\n        metaKey = e.metaKey,\n        altKey = e.altKey;\n    var point = Inputs.getPoint(e);\n    var info = {\n      target: target,\n      pointerId: e.pointerId,\n      origin: point,\n      point: point,\n      delta: [0, 0],\n      pressure: Inputs.getPressure(e),\n      shiftKey: shiftKey,\n      ctrlKey: ctrlKey,\n      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,\n      altKey: altKey\n    };\n    this.pointer = info;\n    return info;\n  };\n\n  _proto.pointerEnter = function pointerEnter(e, target) {\n    var shiftKey = e.shiftKey,\n        ctrlKey = e.ctrlKey,\n        metaKey = e.metaKey,\n        altKey = e.altKey;\n    var point = Inputs.getPoint(e);\n    var info = {\n      target: target,\n      pointerId: e.pointerId,\n      origin: point,\n      delta: [0, 0],\n      point: point,\n      pressure: Inputs.getPressure(e),\n      shiftKey: shiftKey,\n      ctrlKey: ctrlKey,\n      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,\n      altKey: altKey\n    };\n    this.pointer = info;\n    return info;\n  };\n\n  _proto.pointerMove = function pointerMove(e, target) {\n    var shiftKey = e.shiftKey,\n        ctrlKey = e.ctrlKey,\n        metaKey = e.metaKey,\n        altKey = e.altKey;\n    var prev = this.pointer;\n    var point = Inputs.getPoint(e);\n    var delta = prev != null && prev.point ? Vec.sub(point, prev.point) : [0, 0];\n\n    var info = _extends({\n      origin: point\n    }, prev, {\n      target: target,\n      pointerId: e.pointerId,\n      point: point,\n      delta: delta,\n      pressure: Inputs.getPressure(e),\n      shiftKey: shiftKey,\n      ctrlKey: ctrlKey,\n      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,\n      altKey: altKey\n    });\n\n    this.pointer = info;\n    return info;\n  };\n\n  _proto.pointerUp = function pointerUp(e, target) {\n    var shiftKey = e.shiftKey,\n        ctrlKey = e.ctrlKey,\n        metaKey = e.metaKey,\n        altKey = e.altKey;\n    var prev = this.pointer;\n    var point = Inputs.getPoint(e);\n    var delta = prev != null && prev.point ? Vec.sub(point, prev.point) : [0, 0];\n\n    var info = _extends({\n      origin: point\n    }, prev, {\n      target: target,\n      pointerId: e.pointerId,\n      point: point,\n      delta: delta,\n      pressure: Inputs.getPressure(e),\n      shiftKey: shiftKey,\n      ctrlKey: ctrlKey,\n      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,\n      altKey: altKey\n    });\n\n    this.pointer = info;\n    this.pointerUpTime = Date.now();\n    return info;\n  };\n\n  _proto.isDoubleClick = function isDoubleClick() {\n    if (!this.pointer) return;\n    var _this$pointer7 = this.pointer,\n        origin = _this$pointer7.origin,\n        point = _this$pointer7.point;\n    return Date.now() - this.pointerUpTime < DOUBLE_CLICK_DURATION && Vec.dist(origin, point) < 4;\n  };\n\n  _proto.clear = function clear() {\n    this.pointer = undefined;\n  };\n\n  _proto.resetDoubleClick = function resetDoubleClick() {\n    this.pointerUpTime = 0;\n  };\n\n  _proto.pinch = function pinch(point, origin) {\n    var _this$keys = this.keys,\n        shiftKey = _this$keys.shiftKey,\n        ctrlKey = _this$keys.ctrlKey,\n        metaKey = _this$keys.metaKey,\n        altKey = _this$keys.altKey;\n    var prev = this.pointer;\n    var delta = Vec.sub(origin, point);\n    var info = {\n      pointerId: 0,\n      target: 'pinch',\n      origin: (prev == null ? void 0 : prev.origin) || Vec.round(point),\n      delta: delta,\n      point: Vec.round(point),\n      pressure: 0.5,\n      shiftKey: shiftKey,\n      ctrlKey: ctrlKey,\n      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,\n      altKey: altKey\n    };\n    this.pointer = info;\n    return info;\n  };\n\n  _proto.reset = function reset() {\n    this.pointerUpTime = 0;\n    this.pointer = undefined;\n    this.keyboard = undefined;\n    this.keys = {};\n  };\n\n  Inputs.getPoint = function getPoint(e) {\n    return [Number(e.clientX.toPrecision(5)), Number(e.clientY.toPrecision(5))];\n  };\n\n  Inputs.getPressure = function getPressure(e) {\n    return 'pressure' in e ? Number(e.pressure.toPrecision(5)) || 0.5 : 0.5;\n  };\n\n  Inputs.commandKey = function commandKey() {\n    return Utils.isDarwin() ? '' : 'Ctrl';\n  };\n\n  return Inputs;\n}();\n\nvar inputs = /*#__PURE__*/new Inputs();\n\nfunction useZoomEvents() {\n  var rPinchDa = React.useRef(undefined);\n  var rPinchPoint = React.useRef(undefined);\n\n  var _useTLContext = useTLContext(),\n      callbacks = _useTLContext.callbacks;\n\n  reactUseGesture.useGesture({\n    onWheel: function onWheel(_ref) {\n      var e = _ref.event,\n          delta = _ref.delta;\n      var info = inputs.pan(delta, e);\n\n      if (e.ctrlKey) {\n        callbacks.onZoom == null ? void 0 : callbacks.onZoom(info, e);\n        return;\n      } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n      callbacks.onPan == null ? void 0 : callbacks.onPan(info, e);\n    },\n    onPinch: function onPinch(_ref2) {\n      var pinching = _ref2.pinching,\n          da = _ref2.da,\n          origin = _ref2.origin,\n          e = _ref2.event;\n\n      if (!pinching) {\n        var _info = inputs.pinch(origin, origin);\n\n        callbacks.onPinchEnd == null ? void 0 : callbacks.onPinchEnd(_info, e);\n        rPinchDa.current = undefined;\n        rPinchPoint.current = undefined;\n        return;\n      }\n\n      if (rPinchPoint.current === undefined) {\n        var _info2 = inputs.pinch(origin, origin);\n\n        callbacks.onPinchStart == null ? void 0 : callbacks.onPinchStart(_info2, e);\n        rPinchDa.current = da;\n        rPinchPoint.current = origin;\n      } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n      var _Vec$sub = Vec.sub(rPinchDa.current, da),\n          distanceDelta = _Vec$sub[0];\n\n      var info = inputs.pinch(rPinchPoint.current, origin); // Naming things is hard\n\n      callbacks.onPinch == null ? void 0 : callbacks.onPinch(_extends({}, info, {\n        point: origin,\n        origin: rPinchPoint.current,\n        delta: [].concat(info.delta, [distanceDelta])\n      }), e);\n      rPinchDa.current = da;\n      rPinchPoint.current = origin;\n    }\n  }, {\n    domTarget: typeof document === 'undefined' ? undefined : document.body,\n    eventOptions: {\n      passive: false\n    }\n  });\n}\n\nfunction useSafariFocusOutFix() {\n  var _useTLContext = useTLContext(),\n      callbacks = _useTLContext.callbacks;\n\n  React.useEffect(function () {\n    function handleFocusOut() {\n      callbacks.onBlurEditingShape == null ? void 0 : callbacks.onBlurEditingShape();\n    }\n\n    if (!Utils.isMobile()) return;\n    document.addEventListener('focusout', handleFocusOut);\n    return function () {\n      return document.removeEventListener('focusout', handleFocusOut);\n    };\n  }, [callbacks]);\n}\n\nfunction useCanvasEvents() {\n  var _useTLContext = useTLContext(),\n      callbacks = _useTLContext.callbacks;\n\n  var onPointerDown = React.useCallback(function (e) {\n    e.currentTarget.setPointerCapture(e.pointerId);\n\n    if (e.button === 0) {\n      var info = inputs.pointerDown(e, 'canvas');\n      callbacks.onPointCanvas == null ? void 0 : callbacks.onPointCanvas(info, e);\n      callbacks.onPointerDown == null ? void 0 : callbacks.onPointerDown(info, e);\n    }\n  }, [callbacks]);\n  var onPointerMove = React.useCallback(function (e) {\n    e.stopPropagation();\n\n    if (e.currentTarget.hasPointerCapture(e.pointerId)) {\n      var _info = inputs.pointerMove(e, 'canvas');\n\n      callbacks.onDragCanvas == null ? void 0 : callbacks.onDragCanvas(_info, e);\n    }\n\n    var info = inputs.pointerMove(e, 'canvas');\n    callbacks.onPointerMove == null ? void 0 : callbacks.onPointerMove(info, e);\n  }, [callbacks]);\n  var onPointerUp = React.useCallback(function (e) {\n    e.stopPropagation();\n    var isDoubleClick = inputs.isDoubleClick();\n    var info = inputs.pointerUp(e, 'canvas');\n\n    if (e.currentTarget.hasPointerCapture(e.pointerId)) {\n      var _e$currentTarget;\n\n      (_e$currentTarget = e.currentTarget) == null ? void 0 : _e$currentTarget.releasePointerCapture(e.pointerId);\n    }\n\n    if (isDoubleClick && !(info.altKey || info.metaKey)) {\n      callbacks.onDoubleClickCanvas == null ? void 0 : callbacks.onDoubleClickCanvas(info, e);\n    }\n\n    callbacks.onReleaseCanvas == null ? void 0 : callbacks.onReleaseCanvas(info, e);\n    callbacks.onPointerUp == null ? void 0 : callbacks.onPointerUp(info, e);\n  }, [callbacks]);\n  return {\n    onPointerDown: onPointerDown,\n    onPointerMove: onPointerMove,\n    onPointerUp: onPointerUp\n  };\n}\n\nfunction useShapeEvents(id, disable) {\n  if (disable === void 0) {\n    disable = false;\n  }\n\n  var _useTLContext = useTLContext(),\n      callbacks = _useTLContext.callbacks;\n\n  var onPointerDown = React.useCallback(function (e) {\n    var _e$currentTarget;\n\n    if (disable) return;\n    e.stopPropagation();\n    (_e$currentTarget = e.currentTarget) == null ? void 0 : _e$currentTarget.setPointerCapture(e.pointerId);\n    var info = inputs.pointerDown(e, id);\n    callbacks.onPointShape == null ? void 0 : callbacks.onPointShape(info, e);\n    callbacks.onPointerDown == null ? void 0 : callbacks.onPointerDown(info, e);\n  }, [callbacks, id, disable]);\n  var onPointerUp = React.useCallback(function (e) {\n    if (disable) return;\n    e.stopPropagation();\n    var isDoubleClick = inputs.isDoubleClick();\n    var info = inputs.pointerUp(e, id);\n\n    if (e.currentTarget.hasPointerCapture(e.pointerId)) {\n      var _e$currentTarget2;\n\n      (_e$currentTarget2 = e.currentTarget) == null ? void 0 : _e$currentTarget2.releasePointerCapture(e.pointerId);\n    }\n\n    if (isDoubleClick && !(info.altKey || info.metaKey)) {\n      callbacks.onDoubleClickShape == null ? void 0 : callbacks.onDoubleClickShape(info, e);\n    }\n\n    callbacks.onReleaseShape == null ? void 0 : callbacks.onReleaseShape(info, e);\n    callbacks.onPointerUp == null ? void 0 : callbacks.onPointerUp(info, e);\n  }, [callbacks, id, disable]);\n  var onPointerMove = React.useCallback(function (e) {\n    if (disable) return;\n    e.stopPropagation();\n    if (inputs.pointer && e.pointerId !== inputs.pointer.pointerId) return;\n    var info = inputs.pointerMove(e, id);\n\n    if (e.currentTarget.hasPointerCapture(e.pointerId)) {\n      callbacks.onDragShape == null ? void 0 : callbacks.onDragShape(info, e);\n    }\n\n    callbacks.onPointerMove == null ? void 0 : callbacks.onPointerMove(info, e);\n  }, [callbacks, id, disable]);\n  var onPointerEnter = React.useCallback(function (e) {\n    if (disable) return;\n    var info = inputs.pointerEnter(e, id);\n    callbacks.onHoverShape == null ? void 0 : callbacks.onHoverShape(info, e);\n  }, [callbacks, id, disable]);\n  var onPointerLeave = React.useCallback(function (e) {\n    if (disable) return;\n    var info = inputs.pointerEnter(e, id);\n    callbacks.onUnhoverShape == null ? void 0 : callbacks.onUnhoverShape(info, e);\n  }, [callbacks, id, disable]);\n  var onTouchStart = React.useCallback(function (e) {\n    e.preventDefault();\n  }, []);\n  var onTouchEnd = React.useCallback(function (e) {\n    e.preventDefault();\n  }, []);\n  return {\n    onPointerDown: onPointerDown,\n    onPointerUp: onPointerUp,\n    onPointerEnter: onPointerEnter,\n    onPointerMove: onPointerMove,\n    onPointerLeave: onPointerLeave,\n    onTouchStart: onTouchStart,\n    onTouchEnd: onTouchEnd\n  };\n}\n\nfunction addToShapeTree(shape, branch, shapes, selectedIds, info) {\n  var node = {\n    shape: shape,\n    isHovered: info.hoveredId === shape.id,\n    isCurrentParent: info.currentParentId === shape.id,\n    isEditing: info.editingId === shape.id,\n    isBinding: info.bindingId === shape.id,\n    isDarkMode: info.isDarkMode || false,\n    isSelected: selectedIds.includes(shape.id)\n  };\n  branch.push(node);\n\n  if (shape.children) {\n    node.children = [];\n    shape.children.map(function (id) {\n      return shapes[id];\n    }).sort(function (a, b) {\n      return a.childIndex - b.childIndex;\n    }).forEach(function (childShape) {\n      return (// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        addToShapeTree(childShape, node.children, shapes, selectedIds, info)\n      );\n    });\n  }\n}\n\nfunction useShapeTree(page, pageState, shapeUtils, info, onChange) {\n  if (info === void 0) {\n    info = {};\n  }\n\n  var rPreviousCount = React.useRef(0);\n  if (typeof window === 'undefined') return [];\n  var selectedIds = pageState.selectedIds,\n      camera = pageState.camera; // Find viewport\n\n  var _Vec$sub = Vec.sub(Vec.div([0, 0], camera.zoom), camera.point),\n      minX = _Vec$sub[0],\n      minY = _Vec$sub[1];\n\n  var _Vec$sub2 = Vec.sub(Vec.div([window.innerWidth, window.innerHeight], camera.zoom), camera.point),\n      maxX = _Vec$sub2[0],\n      maxY = _Vec$sub2[1];\n\n  var viewport = {\n    minX: minX,\n    minY: minY,\n    maxX: maxX,\n    maxY: maxY,\n    height: maxX - minX,\n    width: maxY - minY\n  }; // Filter shapes that are in view\n\n  var shapesToRender = Object.values(page.shapes).filter(function (shape) {\n    if (shape.parentId !== page.id) return false; // Don't hide selected shapes (this breaks certain drag interactions)\n\n    if (pageState.selectedIds.includes(shape.id)) return true;\n    var shapeBounds = shapeUtils[shape.type].getBounds(shape);\n    return (// TODO: Some shapes should always render (lines, rays)\n      Utils.boundsContain(viewport, shapeBounds) || Utils.boundsCollide(viewport, shapeBounds)\n    );\n  }); // Call onChange callback when number of rendering shapes changes\n\n  if (shapesToRender.length !== rPreviousCount.current) {\n    setTimeout(function () {\n      return onChange == null ? void 0 : onChange(shapesToRender.map(function (shape) {\n        return shape.id;\n      }));\n    }, 0);\n    rPreviousCount.current = shapesToRender.length;\n  } // Populate the shape tree\n\n\n  var tree = [];\n  shapesToRender.sort(function (a, b) {\n    return a.childIndex - b.childIndex;\n  }).forEach(function (shape) {\n    return addToShapeTree(shape, tree, page.shapes, selectedIds, info);\n  });\n  return tree;\n}\n\nvar _templateObject;\nvar styles = /*#__PURE__*/new Map();\n\nfunction makeCssTheme(prefix, theme) {\n  return Object.keys(theme).reduce(function (acc, key) {\n    var value = theme[key];\n\n    if (value) {\n      return acc + (\"--\" + prefix + \"-\" + key + \": \" + value + \";\\n\");\n    }\n\n    return acc;\n  }, '');\n}\n\nfunction useTheme(prefix, theme, selector) {\n  if (selector === void 0) {\n    selector = ':root';\n  }\n\n  React.useLayoutEffect(function () {\n    var style = document.createElement('style');\n    var cssTheme = makeCssTheme(prefix, theme);\n    style.setAttribute('id', prefix + \"-theme\");\n    style.setAttribute('data-selector', selector);\n    style.innerHTML = \"\\n        \" + selector + \" {\\n          \" + cssTheme + \"\\n        }\\n      \";\n    document.head.appendChild(style);\n    return function () {\n      if (style && document.head.contains(style)) {\n        document.head.removeChild(style);\n      }\n    };\n  }, [prefix, theme, selector]);\n}\n\nfunction useStyle(uid, rules) {\n  React.useLayoutEffect(function () {\n    if (styles.get(uid)) {\n      return;\n    }\n\n    var style = document.createElement('style');\n    style.innerHTML = rules;\n    style.setAttribute('id', uid);\n    document.head.appendChild(style);\n    styles.set(uid, style);\n    return function () {\n      if (style && document.head.contains(style)) {\n        document.head.removeChild(style);\n        styles[\"delete\"](uid);\n      }\n    };\n  }, [uid, rules]);\n}\n\nvar css = function css(strings) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return strings.reduce(function (acc, string, index) {\n    return acc + string + (index < args.length ? args[index] : '');\n  }, '');\n};\n\nvar defaultTheme = {\n  brushFill: 'rgba(0,0,0,.05)',\n  brushStroke: 'rgba(0,0,0,.25)',\n  selectStroke: 'rgb(66, 133, 244)',\n  selectFill: 'rgba(65, 132, 244, 0.05)',\n  background: 'rgb(248, 249, 250)',\n  foreground: 'rgb(51, 51, 51)'\n};\nvar tlcss = /*#__PURE__*/css(_templateObject || (_templateObject = /*#__PURE__*/_taggedTemplateLiteralLoose([\"\\n  :root {\\n    --tl-zoom: 1;\\n    --tl-scale: calc(1 / var(--tl-zoom));\\n  }\\n\\n  .tl-counter-scaled {\\n    transform: scale(var(--tl-scale));\\n  }\\n\\n  .tl-dashed {\\n    stroke-dasharray: calc(2px * var(--tl-scale)), calc(2px * var(--tl-scale));\\n  }\\n\\n  .tl-transparent {\\n    fill: transparent;\\n    stroke: transparent;\\n  }\\n\\n  .tl-cursor-ns {\\n    cursor: ns-resize;\\n  }\\n\\n  .tl-cursor-ew {\\n    cursor: ew-resize;\\n  }\\n\\n  .tl-cursor-nesw {\\n    cursor: nesw-resize;\\n  }\\n\\n  .tl-cursor-nwse {\\n    cursor: nwse-resize;\\n  }\\n\\n  .tl-corner-handle {\\n    stroke: var(--tl-selectStroke);\\n    fill: var(--tl-background);\\n    stroke-width: calc(1.5px * var(--tl-scale));\\n  }\\n\\n  .tl-rotate-handle {\\n    stroke: var(--tl-selectStroke);\\n    fill: var(--tl-background);\\n    stroke-width: calc(1.5px * var(--tl-scale));\\n    cursor: grab;\\n  }\\n\\n  .tl-handle {\\n    transform: scale(var(--tl-scale));\\n    fill: var(--tl-background);\\n    stroke: var(--tl-stroke);\\n    stroke-width: calc(2px * var(--tl-scale));\\n    pointer-events: all;\\n  }\\n\\n  .tl-binding {\\n    fill: var(--tl-selectFill);\\n    stroke: var(--tl-selectStroke);\\n    stroke-width: calc(1px * var(--tl-scale));\\n    pointer-events: none;\\n  }\\n\\n  .tl-bounds-center {\\n    fill: transparent;\\n    stroke: var(--tl-selectStroke);\\n    stroke-width: calc(1.5px * var(--tl-scale));\\n  }\\n\\n  .tl-bounds-bg {\\n    stroke: none;\\n    fill: var(--tl-selectFill);\\n    pointer-events: all;\\n  }\\n\\n  .tl-brush {\\n    fill: var(--tl-brushFill);\\n    stroke: var(--tl-brushStroke);\\n    stroke-width: calc(1px * var(--tl-scale));\\n    pointer-events: none;\\n  }\\n\\n  .tl-canvas {\\n    position: fixed;\\n    overflow: hidden;\\n    top: 0px;\\n    left: 0px;\\n    width: 100%;\\n    height: 100%;\\n    touch-action: none;\\n    z-index: 100;\\n    pointer-events: all;\\n  }\\n\\n  .tl-container {\\n    position: relative;\\n    box-sizing: border-box;\\n    width: 100%;\\n    height: 100%;\\n    padding: 0px;\\n    margin: 0px;\\n    overscroll-behavior: none;\\n    overscroll-behavior-x: none;\\n    background-color: var(--tl-background);\\n  }\\n\\n  .tl-container * {\\n    user-select: none;\\n  }\\n\\n  .tl-dot {\\n    fill: var(--tl-background);\\n    stroke: var(--tl-foreground);\\n    stroke-width: 2px;\\n  }\\n\\n  .tl-handle {\\n    fill: var(--tl-background);\\n    stroke: var(--tl-selectStroke);\\n    stroke-width: calc(1.5px * var(--tl-scale));\\n  }\\n\\n  .tl-handle-bg {\\n    fill: transparent;\\n    stroke: none;\\n    opacity: 0.2;\\n    pointer-events: all;\\n  }\\n\\n  .tl-handle-bg:hover {\\n    fill: var(--tl-selected-fill);\\n  }\\n\\n  .tl-handle-bg:hover > * {\\n    stroke: var(--tl-selected-fill);\\n  }\\n\\n  .tl-handle-bg:active {\\n    fill: var(--tl-selected-fill);\\n    stroke: var(--tl-selected-fill);\\n  }\\n\\n  .tl-binding-indicator {\\n    stroke-width: calc(3px * var(--tl-scale));\\n    fill: none;\\n    stroke: var(--tl-selected);\\n  }\\n\\n  .tl-shape-group {\\n    outline: none;\\n  }\\n\\n  .tl-shape-group > *[data-shy='true'] {\\n    opacity: 0;\\n  }\\n\\n  .tl-shape-group:hover > *[data-shy='true'] {\\n    opacity: 1;\\n  }\\n\\n  .tl-current-parent > *[data-shy='true'] {\\n    opacity: 1;\\n  }\\n\"])));\nfunction useTLTheme(theme) {\n  var _React$useState = React.useState(function () {\n    return _extends({}, defaultTheme, theme);\n  }),\n      tltheme = _React$useState[0];\n\n  useTheme('tl', tltheme);\n  useStyle('tl-canvas', tlcss);\n}\n\nfunction useBoundsHandleEvents(id) {\n  var _useTLContext = useTLContext(),\n      callbacks = _useTLContext.callbacks;\n\n  var onPointerDown = React.useCallback(function (e) {\n    var _e$currentTarget;\n\n    e.stopPropagation();\n    (_e$currentTarget = e.currentTarget) == null ? void 0 : _e$currentTarget.setPointerCapture(e.pointerId);\n    var info = inputs.pointerDown(e, id);\n    callbacks.onPointBoundsHandle == null ? void 0 : callbacks.onPointBoundsHandle(info, e);\n    callbacks.onPointerDown == null ? void 0 : callbacks.onPointerDown(info, e);\n  }, [callbacks, id]);\n  var onPointerUp = React.useCallback(function (e) {\n    e.stopPropagation();\n    var isDoubleClick = inputs.isDoubleClick();\n    var info = inputs.pointerUp(e, id);\n\n    if (e.currentTarget.hasPointerCapture(e.pointerId)) {\n      var _e$currentTarget2;\n\n      (_e$currentTarget2 = e.currentTarget) == null ? void 0 : _e$currentTarget2.releasePointerCapture(e.pointerId);\n    }\n\n    if (isDoubleClick && !(info.altKey || info.metaKey)) {\n      callbacks.onDoubleClickBoundsHandle == null ? void 0 : callbacks.onDoubleClickBoundsHandle(info, e);\n    }\n\n    callbacks.onReleaseBoundsHandle == null ? void 0 : callbacks.onReleaseBoundsHandle(info, e);\n    callbacks.onPointerUp == null ? void 0 : callbacks.onPointerUp(info, e);\n  }, [callbacks, id]);\n  var onPointerMove = React.useCallback(function (e) {\n    // e.stopPropagation()\n    if (e.currentTarget.hasPointerCapture(e.pointerId)) {\n      callbacks.onDragBoundsHandle == null ? void 0 : callbacks.onDragBoundsHandle(inputs.pointerMove(e, id), e);\n    }\n\n    var info = inputs.pointerMove(e, id);\n    callbacks.onPointerMove == null ? void 0 : callbacks.onPointerMove(info, e);\n    e.stopPropagation();\n  }, [callbacks, id]);\n  var onPointerEnter = React.useCallback(function (e) {\n    callbacks.onHoverBoundsHandle == null ? void 0 : callbacks.onHoverBoundsHandle(inputs.pointerEnter(e, id), e);\n  }, [callbacks, id]);\n  var onPointerLeave = React.useCallback(function (e) {\n    callbacks.onUnhoverBoundsHandle == null ? void 0 : callbacks.onUnhoverBoundsHandle(inputs.pointerEnter(e, id), e);\n  }, [callbacks, id]);\n  var onTouchStart = React.useCallback(function (e) {\n    e.preventDefault();\n  }, []);\n  var onTouchEnd = React.useCallback(function (e) {\n    e.preventDefault();\n  }, []);\n  return {\n    onPointerDown: onPointerDown,\n    onPointerUp: onPointerUp,\n    onPointerEnter: onPointerEnter,\n    onPointerMove: onPointerMove,\n    onPointerLeave: onPointerLeave,\n    onTouchStart: onTouchStart,\n    onTouchEnd: onTouchEnd\n  };\n}\n\nfunction useCameraCss(pageState) {\n  var rGroup = React.useRef(null); // Update the tl-zoom CSS variable when the zoom changes\n\n  React.useEffect(function () {\n    document.documentElement.style.setProperty('--tl-zoom', pageState.camera.zoom.toString());\n  }, [pageState.camera.zoom]); // Update the group's position when the camera moves or zooms\n\n  React.useEffect(function () {\n    var _rGroup$current;\n\n    var _pageState$camera = pageState.camera,\n        zoom = _pageState$camera.zoom,\n        point = _pageState$camera.point;\n    (_rGroup$current = rGroup.current) == null ? void 0 : _rGroup$current.setAttribute('transform', \"scale(\" + zoom + \") translate(\" + point[0] + \" \" + point[1] + \")\");\n  }, [pageState.camera]);\n  return rGroup;\n}\n\nfunction useRenderOnResize() {\n  var forceUpdate = React.useReducer(function (x) {\n    return x + 1;\n  }, 0)[1];\n  React.useEffect(function () {\n    var debouncedUpdate = Utils.debounce(forceUpdate, 96);\n    window.addEventListener('resize', debouncedUpdate);\n    return function () {\n      window.removeEventListener('resize', debouncedUpdate);\n    };\n  }, [forceUpdate]);\n}\n\nfunction useSelection(page, pageState, shapeUtils) {\n  var selectedIds = pageState.selectedIds;\n  var bounds = undefined;\n  var rotation = 0;\n  var isLocked = false;\n\n  if (selectedIds.length === 1) {\n    var id = selectedIds[0];\n    var shape = page.shapes[id];\n    rotation = shape.rotation || 0;\n    isLocked = shape.isLocked || false;\n    bounds = shapeUtils[shape.type].getBounds(shape);\n  } else if (selectedIds.length > 1) {\n    var selectedShapes = selectedIds.map(function (id) {\n      return page.shapes[id];\n    });\n    rotation = 0;\n    isLocked = selectedShapes.every(function (shape) {\n      return shape.isLocked;\n    });\n    bounds = selectedShapes.reduce(function (acc, shape, i) {\n      if (i === 0) {\n        return shapeUtils[shape.type].getRotatedBounds(shape);\n      }\n\n      return Utils.getExpandedBounds(acc, shapeUtils[shape.type].getRotatedBounds(shape));\n    }, {});\n  }\n\n  return {\n    bounds: bounds,\n    rotation: rotation,\n    isLocked: isLocked\n  };\n}\n\nfunction useHandleEvents(id) {\n  var _useTLContext = useTLContext(),\n      callbacks = _useTLContext.callbacks;\n\n  var onPointerDown = React.useCallback(function (e) {\n    var _e$currentTarget;\n\n    e.stopPropagation();\n    (_e$currentTarget = e.currentTarget) == null ? void 0 : _e$currentTarget.setPointerCapture(e.pointerId);\n    var info = inputs.pointerDown(e, id);\n    callbacks.onPointHandle == null ? void 0 : callbacks.onPointHandle(info, e);\n    callbacks.onPointerDown == null ? void 0 : callbacks.onPointerDown(info, e);\n  }, [callbacks, id]);\n  var onPointerUp = React.useCallback(function (e) {\n    e.stopPropagation();\n    var isDoubleClick = inputs.isDoubleClick();\n    var info = inputs.pointerUp(e, 'bounds');\n\n    if (e.currentTarget.hasPointerCapture(e.pointerId)) {\n      var _e$currentTarget2;\n\n      (_e$currentTarget2 = e.currentTarget) == null ? void 0 : _e$currentTarget2.releasePointerCapture(e.pointerId);\n\n      if (isDoubleClick && !(info.altKey || info.metaKey)) {\n        callbacks.onDoubleClickHandle == null ? void 0 : callbacks.onDoubleClickHandle(info, e);\n      }\n\n      callbacks.onReleaseHandle == null ? void 0 : callbacks.onReleaseHandle(info, e);\n    }\n\n    callbacks.onPointerUp == null ? void 0 : callbacks.onPointerUp(info, e);\n  }, [callbacks]);\n  var onPointerMove = React.useCallback(function (e) {\n    // e.stopPropagation()\n    if (e.currentTarget.hasPointerCapture(e.pointerId)) {\n      var _info = inputs.pointerMove(e, id);\n\n      callbacks.onDragHandle == null ? void 0 : callbacks.onDragHandle(_info, e);\n    }\n\n    var info = inputs.pointerMove(e, id);\n    callbacks.onPointerMove == null ? void 0 : callbacks.onPointerMove(info, e);\n    e.stopPropagation();\n  }, [callbacks, id]);\n  var onPointerEnter = React.useCallback(function (e) {\n    var info = inputs.pointerEnter(e, id);\n    callbacks.onHoverHandle == null ? void 0 : callbacks.onHoverHandle(info, e);\n  }, [callbacks, id]);\n  var onPointerLeave = React.useCallback(function (e) {\n    var info = inputs.pointerEnter(e, id);\n    callbacks.onUnhoverHandle == null ? void 0 : callbacks.onUnhoverHandle(info, e);\n  }, [callbacks, id]);\n  var onTouchStart = React.useCallback(function (e) {\n    e.preventDefault();\n  }, []);\n  var onTouchEnd = React.useCallback(function (e) {\n    e.preventDefault();\n  }, []);\n  return {\n    onPointerDown: onPointerDown,\n    onPointerUp: onPointerUp,\n    onPointerEnter: onPointerEnter,\n    onPointerMove: onPointerMove,\n    onPointerLeave: onPointerLeave,\n    onTouchStart: onTouchStart,\n    onTouchEnd: onTouchEnd\n  };\n}\n\nfunction useHandles(page, pageState) {\n  var selectedIds = pageState.selectedIds;\n  var shapeWithHandles = undefined;\n\n  if (selectedIds.length === 1) {\n    var id = selectedIds[0];\n    var shape = page.shapes[id];\n\n    if (shape.handles !== undefined) {\n      shapeWithHandles = shape;\n    }\n  }\n\n  return {\n    shapeWithHandles: shapeWithHandles\n  };\n}\n\nvar ErrorFallback = /*#__PURE__*/React.memo(function (_ref) {\n  var error = _ref.error,\n      resetErrorBoundary = _ref.resetErrorBoundary;\n\n  var _useTLContext = useTLContext(),\n      callbacks = _useTLContext.callbacks;\n\n  React.useEffect(function () {\n    callbacks.onError == null ? void 0 : callbacks.onError(error);\n    console.error(error);\n  }, [error, resetErrorBoundary, callbacks]);\n  return null;\n});\n\nvar BrushUpdater = /*#__PURE__*/function () {\n  function BrushUpdater() {\n    this.ref = React.createRef();\n    this.isControlled = false;\n  }\n\n  var _proto = BrushUpdater.prototype;\n\n  _proto.set = function set(bounds) {\n    var _this$ref;\n\n    if (!this.isControlled) this.isControlled = true;\n\n    if (!bounds) {\n      this.clear();\n      return;\n    }\n\n    var elm = (_this$ref = this.ref) == null ? void 0 : _this$ref.current;\n    if (!elm) return;\n    elm.setAttribute('opacity', '1');\n    elm.setAttribute('x', bounds.minX.toString());\n    elm.setAttribute('y', bounds.minY.toString());\n    elm.setAttribute('width', bounds.width.toString());\n    elm.setAttribute('height', bounds.height.toString());\n  };\n\n  _proto.clear = function clear() {\n    var _this$ref2;\n\n    var elm = (_this$ref2 = this.ref) == null ? void 0 : _this$ref2.current;\n    if (!elm) return;\n    elm.setAttribute('opacity', '0');\n    elm.setAttribute('width', '0');\n    elm.setAttribute('height', '0');\n  };\n\n  return BrushUpdater;\n}();\n\nvar brushUpdater = /*#__PURE__*/new BrushUpdater();\nvar Brush = /*#__PURE__*/React.memo(function (_ref) {\n  return React.createElement(\"rect\", {\n    ref: brushUpdater.ref,\n    className: \"tl-brush\",\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  });\n}, // Once the brush is controlled, never update again from props\nfunction (prev, next) {\n  return true;\n});\n\nfunction Defs(_ref) {\n  var zoom = _ref.zoom;\n  return React.createElement(\"defs\", null, React.createElement(\"circle\", {\n    id: \"dot\",\n    className: \"tl-counter-scaled tl-dot\",\n    r: 4\n  }), React.createElement(\"circle\", {\n    id: \"handle\",\n    className: \"tl-counter-scaled tl-handle\",\n    r: 4\n  }), React.createElement(\"g\", {\n    id: \"cross\",\n    className: \"tl-binding-indicator\"\n  }, React.createElement(\"line\", {\n    x1: -6,\n    y1: -6,\n    x2: 6,\n    y2: 6\n  }), React.createElement(\"line\", {\n    x1: 6,\n    y1: -6,\n    x2: -6,\n    y2: 6\n  })), React.createElement(\"filter\", {\n    id: \"expand\"\n  }, React.createElement(\"feMorphology\", {\n    operator: \"dilate\",\n    radius: 0.5 / zoom\n  })));\n}\n\nvar RenderedShape = /*#__PURE__*/React.memo(function RenderedShape(_ref) {\n  var shape = _ref.shape,\n      utils = _ref.utils,\n      isEditing = _ref.isEditing,\n      isHovered = _ref.isHovered,\n      isBinding = _ref.isBinding,\n      isSelected = _ref.isSelected,\n      isDarkMode = _ref.isDarkMode,\n      isCurrentParent = _ref.isCurrentParent;\n  return utils.render(shape, {\n    isEditing: isEditing,\n    isHovered: isHovered,\n    isSelected: isSelected,\n    isBinding: isBinding,\n    isDarkMode: isDarkMode,\n    isCurrentParent: isCurrentParent\n  });\n}, function (prev, next) {\n  if (prev.isEditing !== next.isEditing || prev.isHovered !== next.isHovered || prev.isSelected !== next.isSelected || prev.isDarkMode !== next.isDarkMode || prev.isBinding !== next.isBinding || prev.isCurrentParent !== next.isCurrentParent) {\n    return false;\n  }\n\n  if (next.shape !== prev.shape) {\n    return !next.utils.shouldRender(next.shape, prev.shape);\n  }\n\n  return true;\n});\n\nfunction EditingTextShape(_ref) {\n  var shape = _ref.shape,\n      utils = _ref.utils,\n      isEditing = _ref.isEditing,\n      isHovered = _ref.isHovered,\n      isBinding = _ref.isBinding,\n      isSelected = _ref.isSelected,\n      isDarkMode = _ref.isDarkMode,\n      isCurrentParent = _ref.isCurrentParent;\n  var ref = React.useRef(null);\n  return utils.render(shape, {\n    ref: ref,\n    isEditing: isEditing,\n    isHovered: isHovered,\n    isSelected: isSelected,\n    isCurrentParent: isCurrentParent,\n    isBinding: isBinding,\n    isDarkMode: isDarkMode\n  });\n}\n\nvar Shape = /*#__PURE__*/React.memo(function (_ref) {\n  var shape = _ref.shape,\n      isEditing = _ref.isEditing,\n      isHovered = _ref.isHovered,\n      isSelected = _ref.isSelected,\n      isBinding = _ref.isBinding,\n      isDarkMode = _ref.isDarkMode,\n      isCurrentParent = _ref.isCurrentParent;\n\n  var _useTLContext = useTLContext(),\n      shapeUtils = _useTLContext.shapeUtils;\n\n  var events = useShapeEvents(shape.id, isCurrentParent);\n  var utils = shapeUtils[shape.type];\n  var center = utils.getCenter(shape);\n  var rotation = (shape.rotation || 0) * (180 / Math.PI);\n  var transform = \"rotate(\" + rotation + \", \" + center + \") translate(\" + shape.point + \")\";\n  return React.createElement(\"g\", _extends({\n    className: isCurrentParent ? 'tl-shape-group tl-current-parent' : 'tl-shape-group',\n    id: shape.id,\n    transform: transform,\n    filter: isHovered ? 'url(#expand)' : 'none'\n  }, events), isEditing && utils.isEditableText ? React.createElement(EditingTextShape, {\n    shape: shape,\n    isBinding: false,\n    isCurrentParent: false,\n    isDarkMode: isDarkMode,\n    isEditing: true,\n    isHovered: false,\n    isSelected: false,\n    utils: utils\n  }) : React.createElement(RenderedShape, {\n    shape: shape,\n    utils: utils,\n    isBinding: isBinding,\n    isCurrentParent: isCurrentParent,\n    isDarkMode: isDarkMode,\n    isEditing: isEditing,\n    isHovered: isHovered,\n    isSelected: isSelected\n  }));\n});\n\nvar CenterHandle = /*#__PURE__*/React.memo(function (_ref) {\n  var bounds = _ref.bounds,\n      isLocked = _ref.isLocked;\n  return React.createElement(\"rect\", {\n    className: isLocked ? 'tl-bounds-center tl-dashed' : 'tl-bounds-center',\n    x: -1,\n    y: -1,\n    width: bounds.width + 2,\n    height: bounds.height + 2,\n    pointerEvents: \"none\"\n  });\n});\n\nvar RotateHandle = /*#__PURE__*/React.memo(function (_ref) {\n  var bounds = _ref.bounds,\n      size = _ref.size;\n  var events = useBoundsHandleEvents('rotate');\n  return React.createElement(\"g\", {\n    cursor: \"grab\"\n  }, React.createElement(\"circle\", _extends({\n    cx: bounds.width / 2,\n    cy: size * -2,\n    r: size * 2,\n    fill: \"transparent\",\n    stroke: \"none\",\n    pointerEvents: \"all\"\n  }, events)), React.createElement(\"circle\", {\n    className: \"tl-rotate-handle\",\n    cx: bounds.width / 2,\n    cy: size * -2,\n    r: size / 2,\n    pointerEvents: \"none\"\n  }));\n});\n\nvar _cornerBgClassnames;\nvar cornerBgClassnames = (_cornerBgClassnames = {}, _cornerBgClassnames[exports.TLBoundsCorner.TopLeft] = 'tl-transparent tl-cursor-nwse', _cornerBgClassnames[exports.TLBoundsCorner.TopRight] = 'tl-transparent tl-cursor-nesw', _cornerBgClassnames[exports.TLBoundsCorner.BottomRight] = 'tl-transparent tl-cursor-nwse', _cornerBgClassnames[exports.TLBoundsCorner.BottomLeft] = 'tl-transparent tl-cursor-nesw', _cornerBgClassnames);\nvar CornerHandle = /*#__PURE__*/React.memo(function (_ref) {\n  var size = _ref.size,\n      corner = _ref.corner,\n      bounds = _ref.bounds;\n  var events = useBoundsHandleEvents(corner);\n  var isTop = corner === exports.TLBoundsCorner.TopLeft || corner === exports.TLBoundsCorner.TopRight;\n  var isLeft = corner === exports.TLBoundsCorner.TopLeft || corner === exports.TLBoundsCorner.BottomLeft;\n  return React.createElement(\"g\", null, React.createElement(\"rect\", _extends({\n    className: cornerBgClassnames[corner],\n    x: (isLeft ? -1 : bounds.width + 1) - size,\n    y: (isTop ? -1 : bounds.height + 1) - size,\n    width: size * 2,\n    height: size * 2,\n    pointerEvents: \"all\"\n  }, events)), React.createElement(\"rect\", {\n    className: \"tl-corner-handle\",\n    x: (isLeft ? -1 : bounds.width + 1) - size / 2,\n    y: (isTop ? -1 : bounds.height + 1) - size / 2,\n    width: size,\n    height: size,\n    pointerEvents: \"none\"\n  }));\n});\n\nvar _edgeClassnames;\nvar edgeClassnames = (_edgeClassnames = {}, _edgeClassnames[exports.TLBoundsEdge.Top] = 'tl-transparent tl-cursor-ns', _edgeClassnames[exports.TLBoundsEdge.Right] = 'tl-transparent tl-cursor-ew', _edgeClassnames[exports.TLBoundsEdge.Bottom] = 'tl-transparent tl-cursor-ns', _edgeClassnames[exports.TLBoundsEdge.Left] = 'tl-transparent tl-cursor-ew', _edgeClassnames);\nvar EdgeHandle = /*#__PURE__*/React.memo(function (_ref) {\n  var size = _ref.size,\n      bounds = _ref.bounds,\n      edge = _ref.edge;\n  var events = useBoundsHandleEvents(edge);\n  var isHorizontal = edge === exports.TLBoundsEdge.Top || edge === exports.TLBoundsEdge.Bottom;\n  var isFarEdge = edge === exports.TLBoundsEdge.Right || edge === exports.TLBoundsEdge.Bottom;\n  var height = bounds.height,\n      width = bounds.width;\n  return React.createElement(\"rect\", _extends({\n    className: edgeClassnames[edge],\n    x: isHorizontal ? size / 2 : (isFarEdge ? width + 1 : -1) - size / 2,\n    y: isHorizontal ? (isFarEdge ? height + 1 : -1) - size / 2 : size / 2,\n    width: isHorizontal ? Math.max(0, width + 1 - size) : size,\n    height: isHorizontal ? size : Math.max(0, height + 1 - size)\n  }, events));\n});\n\nfunction Bounds(_ref) {\n  var zoom = _ref.zoom,\n      bounds = _ref.bounds,\n      rotation = _ref.rotation,\n      isLocked = _ref.isLocked;\n  var size = (Utils.isMobile() ? 10 : 8) / zoom; // Touch target size\n\n  var center = Utils.getBoundsCenter(bounds);\n  return React.createElement(\"g\", {\n    pointerEvents: \"all\",\n    transform: \"\\n        rotate(\" + rotation * (180 / Math.PI) + \",\" + center + \")\\n        translate(\" + bounds.minX + \",\" + bounds.minY + \")\\n        rotate(\" + (bounds.rotation || 0) * (180 / Math.PI) + \", 0, 0)\"\n  }, React.createElement(CenterHandle, {\n    bounds: bounds,\n    isLocked: isLocked\n  }), !isLocked && React.createElement(React.Fragment, null, React.createElement(EdgeHandle, {\n    size: size,\n    bounds: bounds,\n    edge: exports.TLBoundsEdge.Top\n  }), React.createElement(EdgeHandle, {\n    size: size,\n    bounds: bounds,\n    edge: exports.TLBoundsEdge.Right\n  }), React.createElement(EdgeHandle, {\n    size: size,\n    bounds: bounds,\n    edge: exports.TLBoundsEdge.Bottom\n  }), React.createElement(EdgeHandle, {\n    size: size,\n    bounds: bounds,\n    edge: exports.TLBoundsEdge.Left\n  }), React.createElement(CornerHandle, {\n    size: size,\n    bounds: bounds,\n    corner: exports.TLBoundsCorner.TopLeft\n  }), React.createElement(CornerHandle, {\n    size: size,\n    bounds: bounds,\n    corner: exports.TLBoundsCorner.TopRight\n  }), React.createElement(CornerHandle, {\n    size: size,\n    bounds: bounds,\n    corner: exports.TLBoundsCorner.BottomRight\n  }), React.createElement(CornerHandle, {\n    size: size,\n    bounds: bounds,\n    corner: exports.TLBoundsCorner.BottomLeft\n  }), React.createElement(RotateHandle, {\n    size: size,\n    bounds: bounds\n  })));\n}\n\nfunction useBoundsEvents() {\n  var _useTLContext = useTLContext(),\n      callbacks = _useTLContext.callbacks;\n\n  var onPointerDown = React.useCallback(function (e) {\n    var _e$currentTarget;\n\n    e.stopPropagation();\n    (_e$currentTarget = e.currentTarget) == null ? void 0 : _e$currentTarget.setPointerCapture(e.pointerId);\n    var info = inputs.pointerDown(e, 'bounds');\n    callbacks.onPointBounds == null ? void 0 : callbacks.onPointBounds(info, e);\n    callbacks.onPointerDown == null ? void 0 : callbacks.onPointerDown(info, e);\n  }, [callbacks]);\n  var onPointerUp = React.useCallback(function (e) {\n    e.stopPropagation();\n    var isDoubleClick = inputs.isDoubleClick();\n    var info = inputs.pointerUp(e, 'bounds');\n\n    if (e.currentTarget.hasPointerCapture(e.pointerId)) {\n      var _e$currentTarget2;\n\n      (_e$currentTarget2 = e.currentTarget) == null ? void 0 : _e$currentTarget2.releasePointerCapture(e.pointerId);\n    }\n\n    if (isDoubleClick && !(info.altKey || info.metaKey)) {\n      callbacks.onDoubleClickBounds == null ? void 0 : callbacks.onDoubleClickBounds(info, e);\n    }\n\n    callbacks.onReleaseBounds == null ? void 0 : callbacks.onReleaseBounds(info, e);\n    callbacks.onPointerUp == null ? void 0 : callbacks.onPointerUp(info, e);\n  }, [callbacks]);\n  var onPointerMove = React.useCallback(function (e) {\n    e.stopPropagation();\n    if (inputs.pointer && e.pointerId !== inputs.pointer.pointerId) return;\n\n    if (e.currentTarget.hasPointerCapture(e.pointerId)) {\n      callbacks.onDragBounds == null ? void 0 : callbacks.onDragBounds(inputs.pointerMove(e, 'bounds'), e);\n    }\n\n    var info = inputs.pointerMove(e, 'bounds');\n    callbacks.onPointerMove == null ? void 0 : callbacks.onPointerMove(info, e);\n  }, [callbacks]);\n  var onPointerEnter = React.useCallback(function (e) {\n    callbacks.onHoverBounds == null ? void 0 : callbacks.onHoverBounds(inputs.pointerEnter(e, 'bounds'), e);\n  }, [callbacks]);\n  var onPointerLeave = React.useCallback(function (e) {\n    callbacks.onUnhoverBounds == null ? void 0 : callbacks.onUnhoverBounds(inputs.pointerEnter(e, 'bounds'), e);\n  }, [callbacks]);\n  var onTouchStart = React.useCallback(function (e) {\n    e.preventDefault();\n  }, []);\n  var onTouchEnd = React.useCallback(function (e) {\n    e.preventDefault();\n  }, []);\n  return {\n    onPointerDown: onPointerDown,\n    onPointerUp: onPointerUp,\n    onPointerEnter: onPointerEnter,\n    onPointerMove: onPointerMove,\n    onPointerLeave: onPointerLeave,\n    onTouchStart: onTouchStart,\n    onTouchEnd: onTouchEnd\n  };\n}\n\nfunction BoundsBg(_ref) {\n  var bounds = _ref.bounds,\n      rotation = _ref.rotation;\n  var events = useBoundsEvents();\n  var width = bounds.width,\n      height = bounds.height;\n  var center = Utils.getBoundsCenter(bounds);\n  return React.createElement(\"rect\", _extends({\n    className: \"tl-bounds-bg\",\n    width: Math.max(1, width),\n    height: Math.max(1, height),\n    transform: \"\\n        rotate(\" + rotation * (180 / Math.PI) + \",\" + center + \")\\n        translate(\" + bounds.minX + \",\" + bounds.minY + \")\\n        rotate(\" + (bounds.rotation || 0) * (180 / Math.PI) + \", 0, 0)\"\n  }, events));\n}\n\nvar Handle = /*#__PURE__*/React.memo(function (_ref) {\n  var id = _ref.id,\n      point = _ref.point;\n  var events = useHandleEvents(id);\n  return React.createElement(\"g\", _extends({\n    key: id,\n    className: \"handles\",\n    pointerEvents: \"all\",\n    transform: \"translate(\" + point + \")\"\n  }, events), React.createElement(\"circle\", {\n    className: \"tl-handle-bg\",\n    r: 12\n  }), React.createElement(\"use\", {\n    href: \"#handle\",\n    pointerEvents: \"none\"\n  }));\n});\n\nvar toAngle = 180 / Math.PI;\nvar Handles = /*#__PURE__*/React.memo(function (_ref) {\n  var shape = _ref.shape;\n\n  var _useTLContext = useTLContext(),\n      shapeUtils = _useTLContext.shapeUtils;\n\n  var center = shapeUtils[shape.type].getCenter(shape);\n\n  if (shape.handles === undefined) {\n    return null;\n  }\n\n  return React.createElement(\"g\", {\n    transform: \"rotate(\" + (shape.rotation || 0) * toAngle + \",\" + center + \")\"\n  }, Object.values(shape.handles).map(function (handle) {\n    return React.createElement(Handle, {\n      key: handle.id,\n      id: handle.id,\n      point: Vec.add(handle.point, shape.point)\n    });\n  }));\n});\n\nfunction Page(_ref) {\n  var page = _ref.page,\n      pageState = _ref.pageState,\n      hideBounds = _ref.hideBounds;\n\n  var _useTLContext = useTLContext(),\n      callbacks = _useTLContext.callbacks,\n      shapeUtils = _useTLContext.shapeUtils;\n\n  useRenderOnResize();\n  var shapeTree = useShapeTree(page, pageState, shapeUtils, pageState, callbacks.onChange);\n\n  var _useHandles = useHandles(page, pageState),\n      shapeWithHandles = _useHandles.shapeWithHandles;\n\n  var _useSelection = useSelection(page, pageState, shapeUtils),\n      bounds = _useSelection.bounds,\n      isLocked = _useSelection.isLocked,\n      rotation = _useSelection.rotation;\n\n  return React.createElement(React.Fragment, null, bounds && !hideBounds && React.createElement(BoundsBg, {\n    bounds: bounds,\n    rotation: rotation\n  }), shapeTree.map(function (node) {\n    return React.createElement(ShapeNode, _extends({\n      key: node.shape.id,\n      allowHovers: true\n    }, node));\n  }), bounds && !hideBounds && React.createElement(Bounds, {\n    zoom: pageState.camera.zoom,\n    bounds: bounds,\n    isLocked: isLocked,\n    rotation: rotation\n  }), shapeWithHandles && React.createElement(Handles, {\n    shape: shapeWithHandles\n  }));\n}\nvar ShapeNode = /*#__PURE__*/React.memo(function (_ref2) {\n  var shape = _ref2.shape,\n      children = _ref2.children,\n      isEditing = _ref2.isEditing,\n      isHovered = _ref2.isHovered,\n      isDarkMode = _ref2.isDarkMode,\n      isSelected = _ref2.isSelected,\n      isBinding = _ref2.isBinding,\n      isCurrentParent = _ref2.isCurrentParent,\n      allowHovers = _ref2.allowHovers;\n  return React.createElement(React.Fragment, null, React.createElement(Shape, {\n    shape: shape,\n    isEditing: isEditing,\n    isHovered: allowHovers && isHovered,\n    isSelected: isSelected,\n    isDarkMode: isDarkMode,\n    isBinding: isBinding,\n    isCurrentParent: isCurrentParent\n  }), children && children.map(function (childNode) {\n    return React.createElement(ShapeNode, _extends({\n      key: childNode.shape.id,\n      allowHovers: allowHovers\n    }, childNode));\n  }));\n});\n\n/* eslint-disable @typescript-eslint/ban-ts-comment */\nfunction usePreventNavigation(rCanvas) {\n  React.useEffect(function () {\n    var preventGestureNavigation = function preventGestureNavigation(event) {\n      event.preventDefault();\n    };\n\n    var preventNavigation = function preventNavigation(event) {\n      // Center point of the touch area\n      var touchXPosition = event.touches[0].pageX; // Size of the touch area\n\n      var touchXRadius = event.touches[0].radiusX || 0; // We set a threshold (10px) on both sizes of the screen,\n      // if the touch area overlaps with the screen edges\n      // it's likely to trigger the navigation. We prevent the\n      // touchstart event in that case.\n\n      if (touchXPosition - touchXRadius < 10 || touchXPosition + touchXRadius > window.innerWidth - 10) {\n        event.preventDefault();\n      }\n    };\n\n    var elm = rCanvas.current;\n    if (!elm) return;\n    elm.addEventListener('touchstart', preventGestureNavigation); // @ts-ignore\n\n    elm.addEventListener('gestureend', preventGestureNavigation); // @ts-ignore\n\n    elm.addEventListener('gesturechange', preventGestureNavigation); // @ts-ignore\n\n    elm.addEventListener('gesturestart', preventGestureNavigation); // @ts-ignore\n\n    elm.addEventListener('touchstart', preventNavigation);\n    return function () {\n      if (elm) {\n        elm.removeEventListener('touchstart', preventGestureNavigation); // @ts-ignore\n\n        elm.removeEventListener('gestureend', preventGestureNavigation); // @ts-ignore\n\n        elm.removeEventListener('gesturechange', preventGestureNavigation); // @ts-ignore\n\n        elm.removeEventListener('gesturestart', preventGestureNavigation); // @ts-ignore\n\n        elm.removeEventListener('touchstart', preventNavigation);\n      }\n    };\n  }, [rCanvas]);\n}\n\nfunction resetError() {\n}\n\nvar Canvas = /*#__PURE__*/React.memo(function Canvas(_ref) {\n  var page = _ref.page,\n      pageState = _ref.pageState,\n      _ref$hideBounds = _ref.hideBounds,\n      hideBounds = _ref$hideBounds === void 0 ? false : _ref$hideBounds;\n  var rCanvas = React.useRef(null);\n  var rGroup = useCameraCss(pageState);\n  useZoomEvents();\n  useSafariFocusOutFix();\n  usePreventNavigation(rCanvas);\n  var events = useCanvasEvents();\n  return React.createElement(\"div\", {\n    className: \"tl-container\"\n  }, React.createElement(\"svg\", _extends({\n    id: \"canvas\",\n    className: \"tl-canvas\",\n    ref: rCanvas\n  }, events), React.createElement(reactErrorBoundary.ErrorBoundary, {\n    FallbackComponent: ErrorFallback,\n    onReset: resetError\n  }, React.createElement(Defs, {\n    zoom: pageState.camera.zoom\n  }), React.createElement(\"g\", {\n    ref: rGroup,\n    id: \"tl-shapes\"\n  }, React.createElement(Page, {\n    page: page,\n    pageState: pageState,\n    hideBounds: hideBounds\n  }), React.createElement(Brush, null)))));\n});\n\nvar _excluded = [\"shapeUtils\", \"page\", \"pageState\", \"theme\", \"hideBounds\", \"isDarkMode\", \"isDebugMode\", \"isPenMode\"];\nfunction Renderer(_ref) {\n  var shapeUtils = _ref.shapeUtils,\n      page = _ref.page,\n      pageState = _ref.pageState,\n      theme = _ref.theme,\n      _ref$hideBounds = _ref.hideBounds,\n      hideBounds = _ref$hideBounds === void 0 ? false : _ref$hideBounds,\n      rest = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n  useTLTheme(theme);\n\n  var _React$useState = React.useState(function () {\n    return {\n      callbacks: rest,\n      shapeUtils: shapeUtils\n    };\n  }),\n      context = _React$useState[0];\n\n  return React.createElement(TLContext.Provider, {\n    value: context\n  }, React.createElement(Canvas, {\n    page: page,\n    pageState: pageState,\n    hideBounds: hideBounds\n  }));\n}\n\nexports.Intersect = Intersect;\nexports.Renderer = Renderer;\nexports.Svg = Svg;\nexports.TLShapeUtil = TLShapeUtil;\nexports.Utils = Utils;\nexports.Vec = Vec;\nexports.brushUpdater = brushUpdater;\nexports.inputs = inputs;\n//# sourceMappingURL=core.cjs.development.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdGxkcmF3L3d3dy8uLi9wYWNrYWdlcy9jb3JlL2Rpc3QvY29yZS5janMuZGV2ZWxvcG1lbnQuanM/OGEwMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsQ0FBQyxjQUFjLEVBQUM7O0FBRTdELCtCQUErQixpRkFBaUY7O0FBRWhILFlBQVksbUJBQU8sQ0FBQyxvQkFBTztBQUMzQix5QkFBeUIsbUJBQU8sQ0FBQyxrREFBc0I7QUFDdkQsZ0NBQWdDLG1CQUFPLENBQUMsNEJBQVc7QUFDbkQsc0JBQXNCLG1CQUFPLENBQUMsNENBQW1COztBQUVqRDtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxTQUFTOztBQUVqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkIsb0JBQW9CLEtBQUs7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDZCQUE2QixzQkFBc0IsS0FBSztBQUN6RDs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFNBQVM7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCLHdCQUF3Qjs7QUFFeEIsd0RBQXdEOztBQUV4RCx3REFBd0Q7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBIQUEwSCxLQUFLO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBLGdEQUFnRDs7QUFFaEQsa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLCtCQUErQjs7QUFFL0IsS0FBSzs7O0FBR0wsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMEVBQTBFLDZCQUE2QjtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLGVBQWU7QUFDM0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4REFBOEQsSUFBSTtBQUNsRTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZix5Q0FBeUMsb0JBQW9CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0EsMEZBQTBGLGFBQWE7QUFDdkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0EsNkRBQTZEOztBQUU3RDtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7O0FBRWxFLHFCQUFxQjs7QUFFckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLG1CQUFtQix1QkFBdUI7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUZBQXVGLGFBQWE7QUFDcEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTs7QUFFQSwyREFBMkQ7O0FBRTNELHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRTs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlFQUFpRTtBQUNqRTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHVDQUF1QztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0Esd0ZBQXdGLGFBQWE7QUFDckc7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5SEFBeUgsbUJBQW1CLDJDQUEyQyxLQUFLLDBCQUEwQix3Q0FBd0MsS0FBSyxrQkFBa0IsaUZBQWlGLEtBQUssdUJBQXVCLHdCQUF3QiwwQkFBMEIsS0FBSyxxQkFBcUIsd0JBQXdCLEtBQUsscUJBQXFCLHdCQUF3QixLQUFLLHVCQUF1QiwwQkFBMEIsS0FBSyx1QkFBdUIsMEJBQTBCLEtBQUsseUJBQXlCLHFDQUFxQyxpQ0FBaUMsa0RBQWtELEtBQUsseUJBQXlCLHFDQUFxQyxpQ0FBaUMsa0RBQWtELG1CQUFtQixLQUFLLGtCQUFrQix3Q0FBd0MsaUNBQWlDLCtCQUErQixnREFBZ0QsMEJBQTBCLEtBQUssbUJBQW1CLGlDQUFpQyxxQ0FBcUMsZ0RBQWdELDJCQUEyQixLQUFLLHlCQUF5Qix3QkFBd0IscUNBQXFDLGtEQUFrRCxLQUFLLHFCQUFxQixtQkFBbUIsaUNBQWlDLDBCQUEwQixLQUFLLGlCQUFpQixnQ0FBZ0Msb0NBQW9DLGdEQUFnRCwyQkFBMkIsS0FBSyxrQkFBa0Isc0JBQXNCLHVCQUF1QixlQUFlLGdCQUFnQixrQkFBa0IsbUJBQW1CLHlCQUF5QixtQkFBbUIsMEJBQTBCLEtBQUsscUJBQXFCLHlCQUF5Qiw2QkFBNkIsa0JBQWtCLG1CQUFtQixtQkFBbUIsa0JBQWtCLGdDQUFnQyxrQ0FBa0MsNkNBQTZDLEtBQUssdUJBQXVCLHdCQUF3QixLQUFLLGVBQWUsaUNBQWlDLG1DQUFtQyx3QkFBd0IsS0FBSyxrQkFBa0IsaUNBQWlDLHFDQUFxQyxrREFBa0QsS0FBSyxxQkFBcUIsd0JBQXdCLG1CQUFtQixtQkFBbUIsMEJBQTBCLEtBQUssMkJBQTJCLG9DQUFvQyxLQUFLLCtCQUErQixzQ0FBc0MsS0FBSyw0QkFBNEIsb0NBQW9DLHNDQUFzQyxLQUFLLDZCQUE2QixnREFBZ0QsaUJBQWlCLGlDQUFpQyxLQUFLLHVCQUF1QixvQkFBb0IsS0FBSyw0Q0FBNEMsaUJBQWlCLEtBQUssa0RBQWtELGlCQUFpQixLQUFLLCtDQUErQyxpQkFBaUIsS0FBSztBQUM1c0c7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQSxHQUFHLDJCQUEyQjs7QUFFOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLLElBQUk7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEQUFrRDs7QUFFbEQsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUVBQWlFOztBQUVqRSxpRUFBaUU7O0FBRWpFLG9FQUFvRTs7QUFFcEUsbUVBQW1FOztBQUVuRTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7O0FBRXhFLHdFQUF3RTs7QUFFeEUsMkVBQTJFOztBQUUzRSwwRUFBMEU7O0FBRTFFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQixXQUFXO0FBQ1gsbUJBQW1CO0FBQ25CLGFBQWE7QUFDYixXQUFXO0FBQ1gsb0JBQW9CO0FBQ3BCLGNBQWM7QUFDZCIsImZpbGUiOiIuLi9wYWNrYWdlcy9jb3JlL2Rpc3QvY29yZS5janMuZGV2ZWxvcG1lbnQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZXgpIHsgcmV0dXJuIChleCAmJiAodHlwZW9mIGV4ID09PSAnb2JqZWN0JykgJiYgJ2RlZmF1bHQnIGluIGV4KSA/IGV4WydkZWZhdWx0J10gOiBleDsgfVxuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIHJlYWN0RXJyb3JCb3VuZGFyeSA9IHJlcXVpcmUoJ3JlYWN0LWVycm9yLWJvdW5kYXJ5Jyk7XG52YXIgZGVlcG1lcmdlID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ2RlZXBtZXJnZScpKTtcbnZhciByZWFjdFVzZUdlc3R1cmUgPSByZXF1aXJlKCdyZWFjdC11c2UtZ2VzdHVyZScpO1xuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlKHN0cmluZ3MsIHJhdykge1xuICBpZiAoIXJhdykge1xuICAgIHJhdyA9IHN0cmluZ3Muc2xpY2UoMCk7XG4gIH1cblxuICBzdHJpbmdzLnJhdyA9IHJhdztcbiAgcmV0dXJuIHN0cmluZ3M7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKG8sIGFsbG93QXJyYXlMaWtlKSB7XG4gIHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdO1xuICBpZiAoaXQpIHJldHVybiAoaXQgPSBpdC5jYWxsKG8pKS5uZXh0LmJpbmQoaXQpO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICBpZiAoaXQpIG8gPSBpdDtcbiAgICB2YXIgaSA9IDA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4ge1xuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBvW2krK11cbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxudmFyIFRMQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHt9KTtcbmZ1bmN0aW9uIHVzZVRMQ29udGV4dCgpIHtcbiAgdmFyIGNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KFRMQ29udGV4dCk7XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG4oZnVuY3Rpb24gKFRMQm91bmRzRWRnZSkge1xuICBUTEJvdW5kc0VkZ2VbXCJUb3BcIl0gPSBcInRvcF9lZGdlXCI7XG4gIFRMQm91bmRzRWRnZVtcIlJpZ2h0XCJdID0gXCJyaWdodF9lZGdlXCI7XG4gIFRMQm91bmRzRWRnZVtcIkJvdHRvbVwiXSA9IFwiYm90dG9tX2VkZ2VcIjtcbiAgVExCb3VuZHNFZGdlW1wiTGVmdFwiXSA9IFwibGVmdF9lZGdlXCI7XG59KShleHBvcnRzLlRMQm91bmRzRWRnZSB8fCAoZXhwb3J0cy5UTEJvdW5kc0VkZ2UgPSB7fSkpO1xuXG4oZnVuY3Rpb24gKFRMQm91bmRzQ29ybmVyKSB7XG4gIFRMQm91bmRzQ29ybmVyW1wiVG9wTGVmdFwiXSA9IFwidG9wX2xlZnRfY29ybmVyXCI7XG4gIFRMQm91bmRzQ29ybmVyW1wiVG9wUmlnaHRcIl0gPSBcInRvcF9yaWdodF9jb3JuZXJcIjtcbiAgVExCb3VuZHNDb3JuZXJbXCJCb3R0b21SaWdodFwiXSA9IFwiYm90dG9tX3JpZ2h0X2Nvcm5lclwiO1xuICBUTEJvdW5kc0Nvcm5lcltcIkJvdHRvbUxlZnRcIl0gPSBcImJvdHRvbV9sZWZ0X2Nvcm5lclwiO1xufSkoZXhwb3J0cy5UTEJvdW5kc0Nvcm5lciB8fCAoZXhwb3J0cy5UTEJvdW5kc0Nvcm5lciA9IHt9KSk7XG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4vKiAgICAgICAgICAgICAgICAgICBTaGFwZSBVdGlsaXR5ICAgICAgICAgICAgICAgICAgICAqL1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cbnZhciBUTFNoYXBlVXRpbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRMU2hhcGVVdGlsKCkge1xuICAgIHRoaXMuYm91bmRzQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuICAgIHRoaXMuaXNFZGl0YWJsZVRleHQgPSBmYWxzZTtcbiAgICB0aGlzLmlzQXNwZWN0UmF0aW9Mb2NrZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhbkVkaXQgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBUTFNoYXBlVXRpbC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnNob3VsZFJlbmRlciA9IGZ1bmN0aW9uIHNob3VsZFJlbmRlcihfcHJldiwgX25leHQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBfcHJvdG8uc2hvdWxkRGVsZXRlID0gZnVuY3Rpb24gc2hvdWxkRGVsZXRlKF9zaGFwZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0Q2VudGVyID0gZnVuY3Rpb24gZ2V0Q2VudGVyKHNoYXBlKSB7XG4gICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKHNoYXBlKTtcbiAgICByZXR1cm4gW2JvdW5kcy53aWR0aCAvIDIsIGJvdW5kcy5oZWlnaHQgLyAyXTtcbiAgfTtcblxuICBfcHJvdG8uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BzKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCB0aGlzLmRlZmF1bHRQcm9wcywgcHJvcHMpO1xuICB9O1xuXG4gIF9wcm90by5tdXRhdGUgPSBmdW5jdGlvbiBtdXRhdGUoc2hhcGUsIHByb3BzKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzaGFwZSwgcHJvcHMpO1xuICB9O1xuXG4gIF9wcm90by51cGRhdGVDaGlsZHJlbiA9IGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuKF9zaGFwZSwgX2NoaWxkcmVuKSB7XG4gICAgcmV0dXJuO1xuICB9O1xuXG4gIF9wcm90by5vbkNoaWxkcmVuQ2hhbmdlID0gZnVuY3Rpb24gb25DaGlsZHJlbkNoYW5nZShfc2hhcGUsIF9jaGlsZHJlbikge1xuICAgIHJldHVybjtcbiAgfTtcblxuICBfcHJvdG8ub25CaW5kaW5nQ2hhbmdlID0gZnVuY3Rpb24gb25CaW5kaW5nQ2hhbmdlKF9zaGFwZSwgX2JpbmRpbmcsIF90YXJnZXQsIF90YXJnZXRCb3VuZHMpIHtcbiAgICByZXR1cm47XG4gIH07XG5cbiAgX3Byb3RvLm9uSGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gb25IYW5kbGVDaGFuZ2UoX3NoYXBlLCBfaGFuZGxlLCBfaW5mbykge1xuICAgIHJldHVybjtcbiAgfTtcblxuICBfcHJvdG8ub25SaWdodFBvaW50SGFuZGxlID0gZnVuY3Rpb24gb25SaWdodFBvaW50SGFuZGxlKF9zaGFwZSwgX2hhbmRsZSwgX2luZm8pIHtcbiAgICByZXR1cm47XG4gIH07XG5cbiAgX3Byb3RvLm9uRG91YmxlQ2xpY2tIYW5kbGUgPSBmdW5jdGlvbiBvbkRvdWJsZUNsaWNrSGFuZGxlKF9zaGFwZSwgX2hhbmRsZSwgX2luZm8pIHtcbiAgICByZXR1cm47XG4gIH07XG5cbiAgX3Byb3RvLm9uU2Vzc2lvbkNvbXBsZXRlID0gZnVuY3Rpb24gb25TZXNzaW9uQ29tcGxldGUoX3NoYXBlKSB7XG4gICAgcmV0dXJuO1xuICB9O1xuXG4gIF9wcm90by5vbkJvdW5kc1Jlc2V0ID0gZnVuY3Rpb24gb25Cb3VuZHNSZXNldChfc2hhcGUpIHtcbiAgICByZXR1cm47XG4gIH07XG5cbiAgcmV0dXJuIFRMU2hhcGVVdGlsO1xufSgpO1xuXG4vLyBBIGJpZyBjb2xsZWN0aW9uIG9mIHZlY3RvciB1dGlsaXRpZXMuIENvbGxlY3RlZCBpbnRvIGEgY2xhc3MgdG8gaW1wcm92ZSBsb2dnaW5nIC8gcGFja2FnaW5nLlxuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLSBTdGFydCBDb3B5IEhlcmUgLS0tLS0tLS0tLS0tLS0tLSAqL1xudmFyIFZlYyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFZlYygpIHt9XG5cbiAgVmVjLmNsYW1wID0gZnVuY3Rpb24gY2xhbXAobiwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgobWluLCB0eXBlb2YgbWF4ICE9PSAndW5kZWZpbmVkJyA/IE1hdGgubWluKG4sIG1heCkgOiBuKTtcbiAgfVxuICAvKipcclxuICAgKiBOZWdhdGUgYSB2ZWN0b3IuXHJcbiAgICogQHBhcmFtIEFcclxuICAgKi9cbiAgO1xuXG4gIHJldHVybiBWZWM7XG59KCk7XG5cblZlYy5uZWcgPSBmdW5jdGlvbiAoQSkge1xuICByZXR1cm4gWy1BWzBdLCAtQVsxXV07XG59O1xuXG5WZWMuYWRkID0gZnVuY3Rpb24gKEEsIEIpIHtcbiAgcmV0dXJuIFtBWzBdICsgQlswXSwgQVsxXSArIEJbMV1dO1xufTtcblxuVmVjLmFkZFNjYWxhciA9IGZ1bmN0aW9uIChBLCBuKSB7XG4gIHJldHVybiBbQVswXSArIG4sIEFbMV0gKyBuXTtcbn07XG5cblZlYy5zdWIgPSBmdW5jdGlvbiAoQSwgQikge1xuICByZXR1cm4gW0FbMF0gLSBCWzBdLCBBWzFdIC0gQlsxXV07XG59O1xuXG5WZWMuc3ViU2NhbGFyID0gZnVuY3Rpb24gKEEsIG4pIHtcbiAgcmV0dXJuIFtBWzBdIC0gbiwgQVsxXSAtIG5dO1xufTtcblxuVmVjLnZlYyA9IGZ1bmN0aW9uIChBLCBCKSB7XG4gIC8vIEEsIEIgYXMgdmVjdG9ycyBnZXQgdGhlIHZlY3RvciBmcm9tIEEgdG8gQlxuICByZXR1cm4gW0JbMF0gLSBBWzBdLCBCWzFdIC0gQVsxXV07XG59O1xuXG5WZWMubXVsID0gZnVuY3Rpb24gKEEsIG4pIHtcbiAgcmV0dXJuIFtBWzBdICogbiwgQVsxXSAqIG5dO1xufTtcblxuVmVjLm11bFYgPSBmdW5jdGlvbiAoQSwgQikge1xuICByZXR1cm4gW0FbMF0gKiBCWzBdLCBBWzFdICogQlsxXV07XG59O1xuXG5WZWMuZGl2ID0gZnVuY3Rpb24gKEEsIG4pIHtcbiAgcmV0dXJuIFtBWzBdIC8gbiwgQVsxXSAvIG5dO1xufTtcblxuVmVjLmRpdlYgPSBmdW5jdGlvbiAoQSwgQikge1xuICByZXR1cm4gW0FbMF0gLyBCWzBdLCBBWzFdIC8gQlsxXV07XG59O1xuXG5WZWMucGVyID0gZnVuY3Rpb24gKEEpIHtcbiAgcmV0dXJuIFtBWzFdLCAtQVswXV07XG59O1xuXG5WZWMuZHByID0gZnVuY3Rpb24gKEEsIEIpIHtcbiAgcmV0dXJuIEFbMF0gKiBCWzBdICsgQVsxXSAqIEJbMV07XG59O1xuXG5WZWMuY3ByID0gZnVuY3Rpb24gKEEsIEIpIHtcbiAgcmV0dXJuIEFbMF0gKiBCWzFdIC0gQlswXSAqIEFbMV07XG59O1xuXG5WZWMubGVuMiA9IGZ1bmN0aW9uIChBKSB7XG4gIHJldHVybiBBWzBdICogQVswXSArIEFbMV0gKiBBWzFdO1xufTtcblxuVmVjLmxlbiA9IGZ1bmN0aW9uIChBKSB7XG4gIHJldHVybiBNYXRoLmh5cG90KEFbMF0sIEFbMV0pO1xufTtcblxuVmVjLnByeSA9IGZ1bmN0aW9uIChBLCBCKSB7XG4gIHJldHVybiBWZWMuZHByKEEsIEIpIC8gVmVjLmxlbihCKTtcbn07XG5cblZlYy51bmkgPSBmdW5jdGlvbiAoQSkge1xuICByZXR1cm4gVmVjLmRpdihBLCBWZWMubGVuKEEpKTtcbn07XG5cblZlYy5ub3JtYWxpemUgPSBmdW5jdGlvbiAoQSkge1xuICByZXR1cm4gVmVjLnVuaShBKTtcbn07XG5cblZlYy50YW5nZW50ID0gZnVuY3Rpb24gKEEsIEIpIHtcbiAgcmV0dXJuIFZlYy5ub3JtYWxpemUoVmVjLnN1YihBLCBCKSk7XG59O1xuXG5WZWMuZGlzdDIgPSBmdW5jdGlvbiAoQSwgQikge1xuICByZXR1cm4gVmVjLmxlbjIoVmVjLnN1YihBLCBCKSk7XG59O1xuXG5WZWMuZGlzdCA9IGZ1bmN0aW9uIChBLCBCKSB7XG4gIHJldHVybiBNYXRoLmh5cG90KEFbMV0gLSBCWzFdLCBBWzBdIC0gQlswXSk7XG59O1xuXG5WZWMuZmFzdERpc3QgPSBmdW5jdGlvbiAoQSwgQikge1xuICB2YXIgViA9IFtCWzBdIC0gQVswXSwgQlsxXSAtIEFbMV1dO1xuICB2YXIgYVYgPSBbTWF0aC5hYnMoVlswXSksIE1hdGguYWJzKFZbMV0pXTtcbiAgdmFyIHIgPSAxIC8gTWF0aC5tYXgoYVZbMF0sIGFWWzFdKTtcbiAgciA9IHIgKiAoMS4yOTI4OSAtIChhVlswXSArIGFWWzFdKSAqIHIgKiAwLjI5Mjg5KTtcbiAgcmV0dXJuIFtWWzBdICogciwgVlsxXSAqIHJdO1xufTtcblxuVmVjLmFuZyA9IGZ1bmN0aW9uIChBLCBCKSB7XG4gIHJldHVybiBNYXRoLmF0YW4yKFZlYy5jcHIoQSwgQiksIFZlYy5kcHIoQSwgQikpO1xufTtcblxuVmVjLmFuZ2xlID0gZnVuY3Rpb24gKEEsIEIpIHtcbiAgcmV0dXJuIE1hdGguYXRhbjIoQlsxXSAtIEFbMV0sIEJbMF0gLSBBWzBdKTtcbn07XG5cblZlYy5tZWQgPSBmdW5jdGlvbiAoQSwgQikge1xuICByZXR1cm4gVmVjLm11bChWZWMuYWRkKEEsIEIpLCAwLjUpO1xufTtcblxuVmVjLnJvdCA9IGZ1bmN0aW9uIChBLCByKSB7XG4gIHJldHVybiBbQVswXSAqIE1hdGguY29zKHIpIC0gQVsxXSAqIE1hdGguc2luKHIpLCBBWzBdICogTWF0aC5zaW4ocikgKyBBWzFdICogTWF0aC5jb3MocildO1xufTtcblxuVmVjLnJvdFdpdGggPSBmdW5jdGlvbiAoQSwgQywgcikge1xuICBpZiAociA9PT0gMCkgcmV0dXJuIEE7XG4gIHZhciBzID0gTWF0aC5zaW4ocik7XG4gIHZhciBjID0gTWF0aC5jb3Mocik7XG4gIHZhciBweCA9IEFbMF0gLSBDWzBdO1xuICB2YXIgcHkgPSBBWzFdIC0gQ1sxXTtcbiAgdmFyIG54ID0gcHggKiBjIC0gcHkgKiBzO1xuICB2YXIgbnkgPSBweCAqIHMgKyBweSAqIGM7XG4gIHJldHVybiBbbnggKyBDWzBdLCBueSArIENbMV1dO1xufTtcblxuVmVjLmlzRXF1YWwgPSBmdW5jdGlvbiAoQSwgQikge1xuICByZXR1cm4gQVswXSA9PT0gQlswXSAmJiBBWzFdID09PSBCWzFdO1xufTtcblxuVmVjLmxycCA9IGZ1bmN0aW9uIChBLCBCLCB0KSB7XG4gIHJldHVybiBWZWMuYWRkKEEsIFZlYy5tdWwoVmVjLnZlYyhBLCBCKSwgdCkpO1xufTtcblxuVmVjW1wiaW50XCJdID0gZnVuY3Rpb24gKEEsIEIsIGZyb20sIHRvLCBzKSB7XG4gIGlmIChzID09PSB2b2lkIDApIHtcbiAgICBzID0gMTtcbiAgfVxuXG4gIHZhciB0ID0gKFZlYy5jbGFtcChmcm9tLCB0bykgLSBmcm9tKSAvICh0byAtIGZyb20pO1xuICByZXR1cm4gVmVjLmFkZChWZWMubXVsKEEsIDEgLSB0KSwgVmVjLm11bChCLCBzKSk7XG59O1xuXG5WZWMuYW5nMyA9IGZ1bmN0aW9uIChwMSwgcGMsIHAyKSB7XG4gIC8vIHRoaXMsXG4gIHZhciB2MSA9IFZlYy52ZWMocGMsIHAxKTtcbiAgdmFyIHYyID0gVmVjLnZlYyhwYywgcDIpO1xuICByZXR1cm4gVmVjLmFuZyh2MSwgdjIpO1xufTtcblxuVmVjLmFicyA9IGZ1bmN0aW9uIChBKSB7XG4gIHJldHVybiBbTWF0aC5hYnMoQVswXSksIE1hdGguYWJzKEFbMV0pXTtcbn07XG5cblZlYy5yZXNjYWxlID0gZnVuY3Rpb24gKGEsIG4pIHtcbiAgdmFyIGwgPSBWZWMubGVuKGEpO1xuICByZXR1cm4gW24gKiBhWzBdIC8gbCwgbiAqIGFbMV0gLyBsXTtcbn07XG5cblZlYy5pc0xlZnQgPSBmdW5jdGlvbiAocDEsIHBjLCBwMikge1xuICAvLyAgaXNMZWZ0OiA+MCBmb3IgY291bnRlcmNsb2Nrd2lzZVxuICAvLyAgICAgICAgICA9MCBmb3Igbm9uZSAoZGVnZW5lcmF0ZSlcbiAgLy8gICAgICAgICAgPDAgZm9yIGNsb2Nrd2lzZVxuICByZXR1cm4gKHBjWzBdIC0gcDFbMF0pICogKHAyWzFdIC0gcDFbMV0pIC0gKHAyWzBdIC0gcDFbMF0pICogKHBjWzFdIC0gcDFbMV0pO1xufTtcblxuVmVjLmNsb2Nrd2lzZSA9IGZ1bmN0aW9uIChwMSwgcGMsIHAyKSB7XG4gIHJldHVybiBWZWMuaXNMZWZ0KHAxLCBwYywgcDIpID4gMDtcbn07XG5cblZlYy5yb3VuZCA9IGZ1bmN0aW9uIChhLCBkKSB7XG4gIGlmIChkID09PSB2b2lkIDApIHtcbiAgICBkID0gNTtcbiAgfVxuXG4gIHJldHVybiBhLm1hcChmdW5jdGlvbiAodikge1xuICAgIHJldHVybiArdi50b1ByZWNpc2lvbihkKTtcbiAgfSk7XG59O1xuXG5WZWMubmVhcmVzdFBvaW50T25MaW5lVGhyb3VnaFBvaW50ID0gZnVuY3Rpb24gKEEsIHUsIFApIHtcbiAgcmV0dXJuIFZlYy5hZGQoQSwgVmVjLm11bCh1LCBWZWMucHJ5KFZlYy5zdWIoUCwgQSksIHUpKSk7XG59O1xuXG5WZWMuZGlzdGFuY2VUb0xpbmVUaHJvdWdoUG9pbnQgPSBmdW5jdGlvbiAoQSwgdSwgUCkge1xuICByZXR1cm4gVmVjLmRpc3QoUCwgVmVjLm5lYXJlc3RQb2ludE9uTGluZVRocm91Z2hQb2ludChBLCB1LCBQKSk7XG59O1xuXG5WZWMubmVhcmVzdFBvaW50T25MaW5lU2VnbWVudCA9IGZ1bmN0aW9uIChBLCBCLCBQLCBjbGFtcCkge1xuICBpZiAoY2xhbXAgPT09IHZvaWQgMCkge1xuICAgIGNsYW1wID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBkZWx0YSA9IFZlYy5zdWIoQiwgQSk7XG4gIHZhciBsZW5ndGggPSBWZWMubGVuKGRlbHRhKTtcbiAgdmFyIHUgPSBWZWMuZGl2KGRlbHRhLCBsZW5ndGgpO1xuICB2YXIgcHQgPSBWZWMuYWRkKEEsIFZlYy5tdWwodSwgVmVjLnByeShWZWMuc3ViKFAsIEEpLCB1KSkpO1xuXG4gIGlmIChjbGFtcCkge1xuICAgIHZhciBkYSA9IFZlYy5kaXN0KEEsIHB0KTtcbiAgICB2YXIgZGIgPSBWZWMuZGlzdChCLCBwdCk7XG4gICAgaWYgKGRiIDwgZGEgJiYgZGEgPiBsZW5ndGgpIHJldHVybiBCO1xuICAgIGlmIChkYSA8IGRiICYmIGRiID4gbGVuZ3RoKSByZXR1cm4gQTtcbiAgfVxuXG4gIHJldHVybiBwdDtcbn07XG5cblZlYy5kaXN0YW5jZVRvTGluZVNlZ21lbnQgPSBmdW5jdGlvbiAoQSwgQiwgUCwgY2xhbXApIHtcbiAgaWYgKGNsYW1wID09PSB2b2lkIDApIHtcbiAgICBjbGFtcCA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gVmVjLmRpc3QoUCwgVmVjLm5lYXJlc3RQb2ludE9uTGluZVNlZ21lbnQoQSwgQiwgUCwgY2xhbXApKTtcbn07XG5cblZlYy5udWRnZSA9IGZ1bmN0aW9uIChBLCBCLCBkKSB7XG4gIHJldHVybiBWZWMuYWRkKEEsIFZlYy5tdWwoVmVjLnVuaShWZWMudmVjKEEsIEIpKSwgZCkpO1xufTtcblxuVmVjLm51ZGdlQXRBbmdsZSA9IGZ1bmN0aW9uIChBLCBhLCBkKSB7XG4gIHJldHVybiBbTWF0aC5jb3MoYSkgKiBkICsgQVswXSwgTWF0aC5zaW4oYSkgKiBkICsgQVsxXV07XG59O1xuXG5WZWMudG9QcmVjaXNpb24gPSBmdW5jdGlvbiAoYSwgbikge1xuICBpZiAobiA9PT0gdm9pZCAwKSB7XG4gICAgbiA9IDQ7XG4gIH1cblxuICByZXR1cm4gWythWzBdLnRvUHJlY2lzaW9uKG4pLCArYVsxXS50b1ByZWNpc2lvbihuKV07XG59O1xuXG5WZWMucG9pbnRzQmV0d2VlbiA9IGZ1bmN0aW9uIChhLCBiLCBzdGVwcykge1xuICBpZiAoc3RlcHMgPT09IHZvaWQgMCkge1xuICAgIHN0ZXBzID0gNjtcbiAgfVxuXG4gIHJldHVybiBBcnJheS5mcm9tKEFycmF5KHN0ZXBzKSkubWFwKGZ1bmN0aW9uIChfLCBpKSB7XG4gICAgdmFyIHQgPSBpIC8gc3RlcHM7XG4gICAgcmV0dXJuIHQgKiB0ICogdDtcbiAgfSkubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIFZlYy5yb3VuZChbXS5jb25jYXQoVmVjLmxycChhLCBiLCB0KSwgWygxIC0gdCkgLyAyXSkpO1xuICB9KTtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudCAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1leHRlbmQtbmF0aXZlICovXG5cbi8qKlxyXG4gKiBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2VBbGwoKSBwb2x5ZmlsbFxyXG4gKiBodHRwczovL2dvbWFrZXRoaW5ncy5jb20vaG93LXRvLXJlcGxhY2UtYS1zZWN0aW9uLW9mLWEtc3RyaW5nLXdpdGgtYW5vdGhlci1vbmUtd2l0aC12YW5pbGxhLWpzL1xyXG4gKiBAYXV0aG9yIENocmlzIEZlcmRpbmFuZGlcclxuICogQGxpY2Vuc2UgTUlUXHJcbiAqL1xuaWYgKCFTdHJpbmcucHJvdG90eXBlLnJlcGxhY2VBbGwpIHtcbiAgLy8gQHRzLWlnbm9yZVxuICBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2VBbGwgPSBmdW5jdGlvbiAoc3RyLCBuZXdTdHIpIHtcbiAgICAvLyBJZiBhIHJlZ2V4IHBhdHRlcm5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN0cikudG9Mb3dlckNhc2UoKSA9PT0gJ1tvYmplY3QgcmVnZXhwXScpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcGxhY2Uoc3RyLCBuZXdTdHIpO1xuICAgIH0gLy8gSWYgYSBzdHJpbmdcblxuXG4gICAgcmV0dXJuIHRoaXMucmVwbGFjZShuZXcgUmVnRXhwKHN0ciwgJ2cnKSwgbmV3U3RyKTtcbiAgfTtcbn1cblxudmFyIFV0aWxzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVXRpbHMoKSB7fVxuXG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgLyogICAgICAgICAgICAgICAgICAgIE1hdGggJiBHZW9tZXRyeSAgICAgICAgICAgICAgICAgKi9cblxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuICBVdGlscy5maWx0ZXJPYmplY3QgPSBmdW5jdGlvbiBmaWx0ZXJPYmplY3Qob2JqLCBmbikge1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMob2JqKS5maWx0ZXIoZm4pKTtcbiAgfTtcblxuICBVdGlscy5kZWVwTWVyZ2UgPSBmdW5jdGlvbiBkZWVwTWVyZ2UoYSwgYikge1xuICAgIHJldHVybiBkZWVwbWVyZ2UoYSwgYiwge1xuICAgICAgYXJyYXlNZXJnZTogZnVuY3Rpb24gYXJyYXlNZXJnZShfYSwgYikge1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBMaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZW4gdHdvIG51bWJlcnMuXHJcbiAgICogQHBhcmFtIHkxXHJcbiAgICogQHBhcmFtIHkyXHJcbiAgICogQHBhcmFtIG11XHJcbiAgICovXG4gIDtcblxuICBVdGlscy5sZXJwID0gZnVuY3Rpb24gbGVycCh5MSwgeTIsIG11KSB7XG4gICAgbXUgPSBVdGlscy5jbGFtcChtdSwgMCwgMSk7XG4gICAgcmV0dXJuIHkxICogKDEgLSBtdSkgKyB5MiAqIG11O1xuICB9XG4gIC8qKlxyXG4gICAqIExpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIGNvbG9ycy5cclxuICAgKlxyXG4gICAqICMjIyBFeGFtcGxlXHJcbiAgICpcclxuICAgKmBgYHRzXHJcbiAgICogbGVycENvbG9yKFwiIzAwMDAwMFwiLCBcIiMwMDk5RkZcIiwgLjI1KVxyXG4gICAqYGBgXHJcbiAgICovXG4gIDtcblxuICBVdGlscy5sZXJwQ29sb3IgPSBmdW5jdGlvbiBsZXJwQ29sb3IoY29sb3IxLCBjb2xvcjIsIGZhY3Rvcikge1xuICAgIGlmIChmYWN0b3IgPT09IHZvaWQgMCkge1xuICAgICAgZmFjdG9yID0gMC41O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGgycihoZXgpIHtcbiAgICAgIHZhciByZXN1bHQgPSAvXiM/KFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pJC9pLmV4ZWMoaGV4KTtcbiAgICAgIHJldHVybiByZXN1bHQgPyBbcGFyc2VJbnQocmVzdWx0WzFdLCAxNiksIHBhcnNlSW50KHJlc3VsdFsyXSwgMTYpLCBwYXJzZUludChyZXN1bHRbM10sIDE2KV0gOiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHIyaChyZ2IpIHtcbiAgICAgIHJldHVybiAnIycgKyAoKDEgPDwgMjQpICsgKHJnYlswXSA8PCAxNikgKyAocmdiWzFdIDw8IDgpICsgcmdiWzJdKS50b1N0cmluZygxNikuc2xpY2UoMSk7XG4gICAgfVxuXG4gICAgdmFyIGMxID0gaDJyKGNvbG9yMSk7XG4gICAgdmFyIGMyID0gaDJyKGNvbG9yMik7XG4gICAgaWYgKCEoYzEgJiYgYzIpKSByZXR1cm47XG4gICAgdmFyIHJlc3VsdCA9IGMxLnNsaWNlKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gTWF0aC5yb3VuZChyZXN1bHRbaV0gKyBmYWN0b3IgKiAoYzJbaV0gLSBjMVtpXSkpO1xuICAgIH1cblxuICAgIHJldHVybiByMmgocmVzdWx0KTtcbiAgfVxuICAvKipcclxuICAgKiBNb2R1bGF0ZSBhIHZhbHVlIGJldHdlZW4gdHdvIHJhbmdlcy5cclxuICAgKiBAcGFyYW0gdmFsdWVcclxuICAgKiBAcGFyYW0gcmFuZ2VBIGZyb20gW2xvdywgaGlnaF1cclxuICAgKiBAcGFyYW0gcmFuZ2VCIHRvIFtsb3csIGhpZ2hdXHJcbiAgICogQHBhcmFtIGNsYW1wXHJcbiAgICovXG4gIDtcblxuICBVdGlscy5tb2R1bGF0ZSA9IGZ1bmN0aW9uIG1vZHVsYXRlKHZhbHVlLCByYW5nZUEsIHJhbmdlQiwgY2xhbXApIHtcbiAgICBpZiAoY2xhbXAgPT09IHZvaWQgMCkge1xuICAgICAgY2xhbXAgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZnJvbUxvdyA9IHJhbmdlQVswXSxcbiAgICAgICAgZnJvbUhpZ2ggPSByYW5nZUFbMV07XG4gICAgdmFyIHYwID0gcmFuZ2VCWzBdLFxuICAgICAgICB2MSA9IHJhbmdlQlsxXTtcbiAgICB2YXIgcmVzdWx0ID0gdjAgKyAodmFsdWUgLSBmcm9tTG93KSAvIChmcm9tSGlnaCAtIGZyb21Mb3cpICogKHYxIC0gdjApO1xuICAgIHJldHVybiBjbGFtcCA/IHYwIDwgdjEgPyBNYXRoLm1heChNYXRoLm1pbihyZXN1bHQsIHYxKSwgdjApIDogTWF0aC5tYXgoTWF0aC5taW4ocmVzdWx0LCB2MCksIHYxKSA6IHJlc3VsdDtcbiAgfTtcblxuICBVdGlscy5jbGFtcCA9IGZ1bmN0aW9uIGNsYW1wKG4sIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KG1pbiwgdHlwZW9mIG1heCAhPT0gJ3VuZGVmaW5lZCcgPyBNYXRoLm1pbihuLCBtYXgpIDogbik7XG4gIH0gLy8gVE9ETzogcmVwbGFjZSB3aXRoIGEgc3RyaW5nIGNvbXByZXNzaW9uIGFsZ29yaXRobVxuICA7XG5cbiAgVXRpbHMuY29tcHJlc3MgPSBmdW5jdGlvbiBjb21wcmVzcyhzKSB7XG4gICAgcmV0dXJuIHM7XG4gIH0gLy8gVE9ETzogcmVwbGFjZSB3aXRoIGEgc3RyaW5nIGRlY29tcHJlc3Npb24gYWxnb3JpdGhtXG4gIDtcblxuICBVdGlscy5kZWNvbXByZXNzID0gZnVuY3Rpb24gZGVjb21wcmVzcyhzKSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVjdXJzaXZlbHkgY2xvbmUgYW4gb2JqZWN0IG9yIGFycmF5LlxyXG4gICAqIEBwYXJhbSBvYmpcclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLmRlZXBDbG9uZSA9IGZ1bmN0aW9uIGRlZXBDbG9uZShvYmopIHtcbiAgICBpZiAob2JqID09PSBudWxsKSByZXR1cm4gb2JqO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgcmV0dXJuIFtdLmNvbmNhdChvYmopO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGNsb25lID0gX2V4dGVuZHMoe30sIG9iaik7XG5cbiAgICAgIE9iamVjdC5rZXlzKGNsb25lKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGNsb25lW2tleV0gPSB0eXBlb2Ygb2JqW2tleV0gPT09ICdvYmplY3QnID8gVXRpbHMuZGVlcENsb25lKG9ialtrZXldKSA6IG9ialtrZXldO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICAvKipcclxuICAgKiBTZWVkZWQgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IsIHVzaW5nIFt4b3JzaGlmdF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvWG9yc2hpZnQpLlxyXG4gICAqIFRoZSByZXN1bHQgd2lsbCBhbHdheXMgYmUgYmV0d2VlZW4gLTEgYW5kIDEuXHJcbiAgICpcclxuICAgKiBBZGFwdGVkIGZyb20gW3NlZWRyYW5kb21dKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXZpZGJhdS9zZWVkcmFuZG9tKS5cclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLnJuZyA9IGZ1bmN0aW9uIHJuZyhzZWVkKSB7XG4gICAgaWYgKHNlZWQgPT09IHZvaWQgMCkge1xuICAgICAgc2VlZCA9ICcnO1xuICAgIH1cblxuICAgIHZhciB4ID0gMDtcbiAgICB2YXIgeSA9IDA7XG4gICAgdmFyIHogPSAwO1xuICAgIHZhciB3ID0gMDtcblxuICAgIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB2YXIgdCA9IHggXiB4IDw8IDExO1xuICAgICAgeCA9IHk7XG4gICAgICB5ID0gejtcbiAgICAgIHogPSB3O1xuICAgICAgdyBePSAodyA+Pj4gMTkgXiB0IF4gdCA+Pj4gOCkgPj4+IDA7XG4gICAgICByZXR1cm4gdyAvIDB4MTAwMDAwMDAwO1xuICAgIH1cblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc2VlZC5sZW5ndGggKyA2NDsgaysrKSB7XG4gICAgICB4IF49IHNlZWQuY2hhckNvZGVBdChrKSB8IDA7XG4gICAgICBuZXh0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBCb3hlcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgO1xuXG4gIFV0aWxzLmdldFJlY3RhbmdsZVNpZGVzID0gZnVuY3Rpb24gZ2V0UmVjdGFuZ2xlU2lkZXMocG9pbnQsIHNpemUpIHtcbiAgICB2YXIgdGwgPSBwb2ludDtcbiAgICB2YXIgdHIgPSBWZWMuYWRkKHBvaW50LCBbc2l6ZVswXSwgMF0pO1xuICAgIHZhciBiciA9IFZlYy5hZGQocG9pbnQsIHNpemUpO1xuICAgIHZhciBibCA9IFZlYy5hZGQocG9pbnQsIFswLCBzaXplWzFdXSk7XG4gICAgcmV0dXJuIFtbJ3RvcCcsIFt0bCwgdHJdXSwgWydyaWdodCcsIFt0ciwgYnJdXSwgWydib3R0b20nLCBbYnIsIGJsXV0sIFsnbGVmdCcsIFtibCwgdGxdXV07XG4gIH07XG5cbiAgVXRpbHMuZ2V0Qm91bmRzU2lkZXMgPSBmdW5jdGlvbiBnZXRCb3VuZHNTaWRlcyhib3VuZHMpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSZWN0YW5nbGVTaWRlcyhbYm91bmRzLm1pblgsIGJvdW5kcy5taW5ZXSwgW2JvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodF0pO1xuICB9O1xuXG4gIFV0aWxzLnNoYWxsb3dFcXVhbCA9IGZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gICAgaWYgKG9iakEgPT09IG9iakIpIHJldHVybiB0cnVlO1xuICAgIGlmICghb2JqQSB8fCAhb2JqQikgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBhS2V5cyA9IE9iamVjdC5rZXlzKG9iakEpO1xuICAgIHZhciBiS2V5cyA9IE9iamVjdC5rZXlzKG9iakIpO1xuICAgIHZhciBsZW4gPSBhS2V5cy5sZW5ndGg7XG4gICAgaWYgKGJLZXlzLmxlbmd0aCAhPT0gbGVuKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gYUtleXNbaV07XG5cbiAgICAgIGlmIChvYmpBW2tleV0gIT09IG9iakJba2V5XSB8fCAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qIC0tLS0tLS0tLS0tLS0tLSBDaXJjbGVzIGFuZCBBbmdsZXMgLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBvdXRlciBvZiBiZXR3ZWVuIGEgY2lyY2xlIGFuZCBhIHBvaW50LlxyXG4gICAqIEBwYXJhbSBDIFRoZSBjaXJjbGUncyBjZW50ZXIuXHJcbiAgICogQHBhcmFtIHIgVGhlIGNpcmNsZSdzIHJhZGl1cy5cclxuICAgKiBAcGFyYW0gUCBUaGUgcG9pbnQuXHJcbiAgICogQHBhcmFtIHNpZGVcclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLmdldENpcmNsZVRhbmdlbnRUb1BvaW50ID0gZnVuY3Rpb24gZ2V0Q2lyY2xlVGFuZ2VudFRvUG9pbnQoQywgciwgUCwgc2lkZSkge1xuICAgIHZhciBCID0gVmVjLmxycChDLCBQLCAwLjUpO1xuICAgIHZhciByMSA9IFZlYy5kaXN0KEMsIEIpO1xuICAgIHZhciBkZWx0YSA9IFZlYy5zdWIoQiwgQyk7XG4gICAgdmFyIGQgPSBWZWMubGVuKGRlbHRhKTtcblxuICAgIGlmICghKGQgPD0gciArIHIxICYmIGQgPj0gTWF0aC5hYnMociAtIHIxKSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBhID0gKHIgKiByIC0gcjEgKiByMSArIGQgKiBkKSAvICgyLjAgKiBkKTtcbiAgICB2YXIgbiA9IDEgLyBkO1xuICAgIHZhciBwID0gVmVjLmFkZChDLCBWZWMubXVsKGRlbHRhLCBhICogbikpO1xuICAgIHZhciBoID0gTWF0aC5zcXJ0KHIgKiByIC0gYSAqIGEpO1xuICAgIHZhciBrID0gVmVjLm11bChWZWMucGVyKGRlbHRhKSwgaCAqIG4pO1xuICAgIHJldHVybiBzaWRlID09PSAwID8gVmVjLmFkZChwLCBrKSA6IFZlYy5zdWIocCwgayk7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IG91dGVyIHRhbmdlbnRzIG9mIHR3byBjaXJjbGVzLlxyXG4gICAqIEBwYXJhbSB4MFxyXG4gICAqIEBwYXJhbSB5MFxyXG4gICAqIEBwYXJhbSByMFxyXG4gICAqIEBwYXJhbSB4MVxyXG4gICAqIEBwYXJhbSB5MVxyXG4gICAqIEBwYXJhbSByMVxyXG4gICAqIEByZXR1cm5zIFtseDAsIGx5MCwgbHgxLCBseTEsIHJ4MCwgcnkwLCByeDEsIHJ5MV1cclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLmdldE91dGVyVGFuZ2VudHNPZkNpcmNsZXMgPSBmdW5jdGlvbiBnZXRPdXRlclRhbmdlbnRzT2ZDaXJjbGVzKEMwLCByMCwgQzEsIHIxKSB7XG4gICAgdmFyIGEwID0gVmVjLmFuZ2xlKEMwLCBDMSk7XG4gICAgdmFyIGQgPSBWZWMuZGlzdChDMCwgQzEpOyAvLyBDaXJjbGVzIGFyZSBvdmVybGFwcGluZywgbm8gdGFuZ2VudHNcblxuICAgIGlmIChkIDwgTWF0aC5hYnMocjEgLSByMCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBhMSA9IE1hdGguYWNvcygocjAgLSByMSkgLyBkKTtcbiAgICB2YXIgdDAgPSBhMCArIGExO1xuICAgIHZhciB0MSA9IGEwIC0gYTE7XG4gICAgcmV0dXJuIFtbQzBbMF0gKyByMCAqIE1hdGguY29zKHQxKSwgQzBbMV0gKyByMCAqIE1hdGguc2luKHQxKV0sIFtDMVswXSArIHIxICogTWF0aC5jb3ModDEpLCBDMVsxXSArIHIxICogTWF0aC5zaW4odDEpXSwgW0MwWzBdICsgcjAgKiBNYXRoLmNvcyh0MCksIEMwWzFdICsgcjAgKiBNYXRoLnNpbih0MCldLCBbQzFbMF0gKyByMSAqIE1hdGguY29zKHQwKSwgQzFbMV0gKyByMSAqIE1hdGguc2luKHQwKV1dO1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCB0aGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgcGVyaW1ldGVyIG9mIGEgY2lyY2xlIHRvIGEgZ2l2ZW4gcG9pbnQuXHJcbiAgICogQHBhcmFtIEMgVGhlIGNpcmNsZSdzIGNlbnRlci5cclxuICAgKiBAcGFyYW0gciBUaGUgY2lyY2xlJ3MgcmFkaXVzLlxyXG4gICAqIEBwYXJhbSBQIFRoZSBwb2ludC5cclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLmdldENsb3Nlc3RQb2ludE9uQ2lyY2xlID0gZnVuY3Rpb24gZ2V0Q2xvc2VzdFBvaW50T25DaXJjbGUoQywgciwgUCkge1xuICAgIHZhciB2ID0gVmVjLnN1YihDLCBQKTtcbiAgICByZXR1cm4gVmVjLnN1YihDLCBWZWMubXVsKFZlYy5kaXYodiwgVmVjLmxlbih2KSksIHIpKTtcbiAgfVxuICAvKipcclxuICAgKiBHZXQgYSBjaXJjbGUgZnJvbSB0aHJlZSBwb2ludHMuXHJcbiAgICogQHBhcmFtIEFcclxuICAgKiBAcGFyYW0gQlxyXG4gICAqIEBwYXJhbSBDXHJcbiAgICogQHJldHVybnMgW3gsIHksIHJdXHJcbiAgICovXG4gIDtcblxuICBVdGlscy5jaXJjbGVGcm9tVGhyZWVQb2ludHMgPSBmdW5jdGlvbiBjaXJjbGVGcm9tVGhyZWVQb2ludHMoQSwgQiwgQykge1xuICAgIHZhciB4MSA9IEFbMF0sXG4gICAgICAgIHkxID0gQVsxXTtcbiAgICB2YXIgeDIgPSBCWzBdLFxuICAgICAgICB5MiA9IEJbMV07XG4gICAgdmFyIHgzID0gQ1swXSxcbiAgICAgICAgeTMgPSBDWzFdO1xuICAgIHZhciBhID0geDEgKiAoeTIgLSB5MykgLSB5MSAqICh4MiAtIHgzKSArIHgyICogeTMgLSB4MyAqIHkyO1xuICAgIHZhciBiID0gKHgxICogeDEgKyB5MSAqIHkxKSAqICh5MyAtIHkyKSArICh4MiAqIHgyICsgeTIgKiB5MikgKiAoeTEgLSB5MykgKyAoeDMgKiB4MyArIHkzICogeTMpICogKHkyIC0geTEpO1xuICAgIHZhciBjID0gKHgxICogeDEgKyB5MSAqIHkxKSAqICh4MiAtIHgzKSArICh4MiAqIHgyICsgeTIgKiB5MikgKiAoeDMgLSB4MSkgKyAoeDMgKiB4MyArIHkzICogeTMpICogKHgxIC0geDIpO1xuICAgIHZhciB4ID0gLWIgLyAoMiAqIGEpO1xuICAgIHZhciB5ID0gLWMgLyAoMiAqIGEpO1xuICAgIHJldHVybiBbeCwgeSwgTWF0aC5oeXBvdCh4IC0geDEsIHkgLSB5MSldO1xuICB9XG4gIC8qKlxyXG4gICAqIEZpbmQgdGhlIGFwcHJveGltYXRlIHBlcmltZXRlciBvZiBhbiBlbGxpcHNlLlxyXG4gICAqIEBwYXJhbSByeFxyXG4gICAqIEBwYXJhbSByeVxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMucGVyaW1ldGVyT2ZFbGxpcHNlID0gZnVuY3Rpb24gcGVyaW1ldGVyT2ZFbGxpcHNlKHJ4LCByeSkge1xuICAgIHZhciBoID0gTWF0aC5wb3cocnggLSByeSwgMikgLyBNYXRoLnBvdyhyeCArIHJ5LCAyKTtcbiAgICB2YXIgcCA9IE1hdGguUEkgKiAocnggKyByeSkgKiAoMSArIDMgKiBoIC8gKDEwICsgTWF0aC5zcXJ0KDQgLSAzICogaCkpKTtcbiAgICByZXR1cm4gcDtcbiAgfVxuICAvKipcclxuICAgKiBHZXQgdGhlIHNob3J0IGFuZ2xlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGFuZ2xlcy5cclxuICAgKiBAcGFyYW0gYTBcclxuICAgKiBAcGFyYW0gYTFcclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLnNob3J0QW5nbGVEaXN0ID0gZnVuY3Rpb24gc2hvcnRBbmdsZURpc3QoYTAsIGExKSB7XG4gICAgdmFyIG1heCA9IE1hdGguUEkgKiAyO1xuICAgIHZhciBkYSA9IChhMSAtIGEwKSAlIG1heDtcbiAgICByZXR1cm4gMiAqIGRhICUgbWF4IC0gZGE7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBsb25nIGFuZ2xlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGFuZ2xlcy5cclxuICAgKiBAcGFyYW0gYTBcclxuICAgKiBAcGFyYW0gYTFcclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLmxvbmdBbmdsZURpc3QgPSBmdW5jdGlvbiBsb25nQW5nbGVEaXN0KGEwLCBhMSkge1xuICAgIHJldHVybiBNYXRoLlBJICogMiAtIFV0aWxzLnNob3J0QW5nbGVEaXN0KGEwLCBhMSk7XG4gIH1cbiAgLyoqXHJcbiAgICogSW50ZXJwb2xhdGUgYW4gYW5nbGUgYmV0d2VlbiB0d28gYW5nbGVzLlxyXG4gICAqIEBwYXJhbSBhMFxyXG4gICAqIEBwYXJhbSBhMVxyXG4gICAqIEBwYXJhbSB0XHJcbiAgICovXG4gIDtcblxuICBVdGlscy5sZXJwQW5nbGVzID0gZnVuY3Rpb24gbGVycEFuZ2xlcyhhMCwgYTEsIHQpIHtcbiAgICByZXR1cm4gYTAgKyBVdGlscy5zaG9ydEFuZ2xlRGlzdChhMCwgYTEpICogdDtcbiAgfVxuICAvKipcclxuICAgKiBHZXQgdGhlIHNob3J0IGRpc3RhbmNlIGJldHdlZW4gdHdvIGFuZ2xlcy5cclxuICAgKiBAcGFyYW0gYTBcclxuICAgKiBAcGFyYW0gYTFcclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLmFuZ2xlRGVsdGEgPSBmdW5jdGlvbiBhbmdsZURlbHRhKGEwLCBhMSkge1xuICAgIHJldHVybiBVdGlscy5zaG9ydEFuZ2xlRGlzdChhMCwgYTEpO1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCB0aGUgXCJzd2VlcFwiIG9yIHNob3J0IGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cyBvbiBhIGNpcmNsZSdzIHBlcmltZXRlci5cclxuICAgKiBAcGFyYW0gQ1xyXG4gICAqIEBwYXJhbSBBXHJcbiAgICogQHBhcmFtIEJcclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLmdldFN3ZWVwID0gZnVuY3Rpb24gZ2V0U3dlZXAoQywgQSwgQikge1xuICAgIHJldHVybiBVdGlscy5hbmdsZURlbHRhKFZlYy5hbmdsZShDLCBBKSwgVmVjLmFuZ2xlKEMsIEIpKTtcbiAgfVxuICAvKipcclxuICAgKiBSb3RhdGUgYSBwb2ludCBhcm91bmQgYSBjZW50ZXIuXHJcbiAgICogQHBhcmFtIHggVGhlIHgtYXhpcyBjb29yZGluYXRlIG9mIHRoZSBwb2ludC5cclxuICAgKiBAcGFyYW0geSBUaGUgeS1heGlzIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LlxyXG4gICAqIEBwYXJhbSBjeCBUaGUgeC1heGlzIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHJvdGF0ZSByb3VuZC5cclxuICAgKiBAcGFyYW0gY3kgVGhlIHktYXhpcyBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byByb3RhdGUgcm91bmQuXHJcbiAgICogQHBhcmFtIGFuZ2xlIFRoZSBkaXN0YW5jZSAoaW4gcmFkaWFucykgdG8gcm90YXRlLlxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMucm90YXRlUG9pbnQgPSBmdW5jdGlvbiByb3RhdGVQb2ludChBLCBCLCBhbmdsZSkge1xuICAgIHZhciBzID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgIHZhciBjID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgIHZhciBweCA9IEFbMF0gLSBCWzBdO1xuICAgIHZhciBweSA9IEFbMV0gLSBCWzFdO1xuICAgIHZhciBueCA9IHB4ICogYyAtIHB5ICogcztcbiAgICB2YXIgbnkgPSBweCAqIHMgKyBweSAqIGM7XG4gICAgcmV0dXJuIFtueCArIEJbMF0sIG55ICsgQlsxXV07XG4gIH1cbiAgLyoqXHJcbiAgICogQ2xhbXAgcmFkaWFucyB3aXRoaW4gMCBhbmQgMlBJXHJcbiAgICogQHBhcmFtIHJcclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLmNsYW1wUmFkaWFucyA9IGZ1bmN0aW9uIGNsYW1wUmFkaWFucyhyKSB7XG4gICAgcmV0dXJuIChNYXRoLlBJICogMiArIHIpICUgKE1hdGguUEkgKiAyKTtcbiAgfVxuICAvKipcclxuICAgKiBDbGFtcCByb3RhdGlvbiB0byBldmVuIHNlZ21lbnRzLlxyXG4gICAqIEBwYXJhbSByXHJcbiAgICogQHBhcmFtIHNlZ21lbnRzXHJcbiAgICovXG4gIDtcblxuICBVdGlscy5jbGFtcFRvUm90YXRpb25Ub1NlZ21lbnRzID0gZnVuY3Rpb24gY2xhbXBUb1JvdGF0aW9uVG9TZWdtZW50cyhyLCBzZWdtZW50cykge1xuICAgIHZhciBzZWcgPSBNYXRoLlBJICogMiAvIHNlZ21lbnRzO1xuICAgIHJldHVybiBNYXRoLmZsb29yKChVdGlscy5jbGFtcFJhZGlhbnMocikgKyBzZWcgLyAyKSAvIHNlZykgKiBzZWc7XG4gIH1cbiAgLyoqXHJcbiAgICogSXMgYW5nbGUgYyBiZXR3ZWVuIGFuZ2xlcyBhIGFuZCBiP1xyXG4gICAqIEBwYXJhbSBhXHJcbiAgICogQHBhcmFtIGJcclxuICAgKiBAcGFyYW0gY1xyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuaXNBbmdsZUJldHdlZW4gPSBmdW5jdGlvbiBpc0FuZ2xlQmV0d2VlbihhLCBiLCBjKSB7XG4gICAgaWYgKGMgPT09IGEgfHwgYyA9PT0gYikgcmV0dXJuIHRydWU7XG4gICAgdmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuICAgIHZhciBBQiA9IChiIC0gYSArIFBJMikgJSBQSTI7XG4gICAgdmFyIEFDID0gKGMgLSBhICsgUEkyKSAlIFBJMjtcbiAgICByZXR1cm4gQUIgPD0gTWF0aC5QSSAhPT0gQUMgPiBBQjtcbiAgfVxuICAvKipcclxuICAgKiBDb252ZXJ0IGRlZ3JlZXMgdG8gcmFkaWFucy5cclxuICAgKiBAcGFyYW0gZFxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuZGVncmVlc1RvUmFkaWFucyA9IGZ1bmN0aW9uIGRlZ3JlZXNUb1JhZGlhbnMoZCkge1xuICAgIHJldHVybiBkICogTWF0aC5QSSAvIDE4MDtcbiAgfVxuICAvKipcclxuICAgKiBDb252ZXJ0IHJhZGlhbnMgdG8gZGVncmVlcy5cclxuICAgKiBAcGFyYW0gclxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMucmFkaWFuc1RvRGVncmVlcyA9IGZ1bmN0aW9uIHJhZGlhbnNUb0RlZ3JlZXMocikge1xuICAgIHJldHVybiByICogMTgwIC8gTWF0aC5QSTtcbiAgfVxuICAvKipcclxuICAgKiBHZXQgdGhlIGxlbmd0aCBvZiBhbiBhcmMgYmV0d2VlbiB0d28gcG9pbnRzIG9uIGEgY2lyY2xlJ3MgcGVyaW1ldGVyLlxyXG4gICAqIEBwYXJhbSBDXHJcbiAgICogQHBhcmFtIHJcclxuICAgKiBAcGFyYW0gQVxyXG4gICAqIEBwYXJhbSBCXHJcbiAgICovXG4gIDtcblxuICBVdGlscy5nZXRBcmNMZW5ndGggPSBmdW5jdGlvbiBnZXRBcmNMZW5ndGgoQywgciwgQSwgQikge1xuICAgIHZhciBzd2VlcCA9IFV0aWxzLmdldFN3ZWVwKEMsIEEsIEIpO1xuICAgIHJldHVybiByICogKDIgKiBNYXRoLlBJKSAqIChzd2VlcCAvICgyICogTWF0aC5QSSkpO1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCBhIGRhc2ggb2Zmc2V0IGZvciBhbiBhcmMsIGJhc2VkIG9uIGl0cyBsZW5ndGguXHJcbiAgICogQHBhcmFtIENcclxuICAgKiBAcGFyYW0gclxyXG4gICAqIEBwYXJhbSBBXHJcbiAgICogQHBhcmFtIEJcclxuICAgKiBAcGFyYW0gc3RlcFxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuZ2V0QXJjRGFzaE9mZnNldCA9IGZ1bmN0aW9uIGdldEFyY0Rhc2hPZmZzZXQoQywgciwgQSwgQiwgc3RlcCkge1xuICAgIHZhciBkZWwwID0gVXRpbHMuZ2V0U3dlZXAoQywgQSwgQik7XG4gICAgdmFyIGxlbjAgPSBVdGlscy5nZXRBcmNMZW5ndGgoQywgciwgQSwgQik7XG4gICAgdmFyIG9mZjAgPSBkZWwwIDwgMCA/IGxlbjAgOiAyICogTWF0aC5QSSAqIENbMl0gLSBsZW4wO1xuICAgIHJldHVybiAtb2ZmMCAvIDIgKyBzdGVwO1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCBhIGRhc2ggb2Zmc2V0IGZvciBhbiBlbGxpcHNlLCBiYXNlZCBvbiBpdHMgbGVuZ3RoLlxyXG4gICAqIEBwYXJhbSBBXHJcbiAgICogQHBhcmFtIHN0ZXBcclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLmdldEVsbGlwc2VEYXNoT2Zmc2V0ID0gZnVuY3Rpb24gZ2V0RWxsaXBzZURhc2hPZmZzZXQoQSwgc3RlcCkge1xuICAgIHZhciBjID0gMiAqIE1hdGguUEkgKiBBWzJdO1xuICAgIHJldHVybiAtYyAvIDIgKyAtc3RlcDtcbiAgfVxuICAvKiAtLS0tLS0tLS0tLS0tLS0gQ3VydmVzIGFuZCBTcGxpbmVzIC0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gIC8qKlxyXG4gICAqIEdldCBiZXppZXIgY3VydmUgc2VnbWVudHMgdGhhdCBwYXNzIHRocm91Z2ggYW4gYXJyYXkgb2YgcG9pbnRzLlxyXG4gICAqIEBwYXJhbSBwb2ludHNcclxuICAgKiBAcGFyYW0gdGVuc2lvblxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuZ2V0VExCZXppZXJDdXJ2ZVNlZ21lbnRzID0gZnVuY3Rpb24gZ2V0VExCZXppZXJDdXJ2ZVNlZ21lbnRzKHBvaW50cywgdGVuc2lvbikge1xuICAgIGlmICh0ZW5zaW9uID09PSB2b2lkIDApIHtcbiAgICAgIHRlbnNpb24gPSAwLjQ7XG4gICAgfVxuXG4gICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgdmFyIGNwb2ludHMgPSBbXS5jb25jYXQocG9pbnRzKTtcblxuICAgIGlmIChsZW4gPCAyKSB7XG4gICAgICB0aHJvdyBFcnJvcignQ3VydmUgbXVzdCBoYXZlIGF0IGxlYXN0IHR3byBwb2ludHMuJyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgICAgIHZhciBwMCA9IHBvaW50c1tpIC0gMV07XG4gICAgICB2YXIgcDEgPSBwb2ludHNbaV07XG4gICAgICB2YXIgcDIgPSBwb2ludHNbaSArIDFdO1xuICAgICAgdmFyIHBkeCA9IHAyWzBdIC0gcDBbMF07XG4gICAgICB2YXIgcGR5ID0gcDJbMV0gLSBwMFsxXTtcbiAgICAgIHZhciBwZCA9IE1hdGguaHlwb3QocGR4LCBwZHkpO1xuICAgICAgdmFyIG54ID0gcGR4IC8gcGQ7IC8vIG5vcm1hbGl6ZWQgeFxuXG4gICAgICB2YXIgbnkgPSBwZHkgLyBwZDsgLy8gbm9ybWFsaXplZCB5XG5cbiAgICAgIHZhciBkcCA9IE1hdGguaHlwb3QocDFbMF0gLSBwMFswXSwgcDFbMV0gLSBwMFsxXSk7IC8vIERpc3RhbmNlIHRvIHByZXZpb3VzXG5cbiAgICAgIHZhciBkbiA9IE1hdGguaHlwb3QocDFbMF0gLSBwMlswXSwgcDFbMV0gLSBwMlsxXSk7IC8vIERpc3RhbmNlIHRvIG5leHRcblxuICAgICAgY3BvaW50c1tpXSA9IFsvLyB0YW5nZW50IHN0YXJ0XG4gICAgICBwMVswXSAtIG54ICogZHAgKiB0ZW5zaW9uLCBwMVsxXSAtIG55ICogZHAgKiB0ZW5zaW9uLCAvLyB0YW5nZW50IGVuZFxuICAgICAgcDFbMF0gKyBueCAqIGRuICogdGVuc2lvbiwgcDFbMV0gKyBueSAqIGRuICogdGVuc2lvbiwgLy8gbm9ybWFsXG4gICAgICBueCwgbnldO1xuICAgIH0gLy8gVE9ETzogUmVmbGVjdCB0aGUgbmVhcmVzdCBjb250cm9sIHBvaW50cywgbm90IGF2ZXJhZ2UgdGhlbVxuXG5cbiAgICB2YXIgZDAgPSBNYXRoLmh5cG90KHBvaW50c1swXVswXSArIGNwb2ludHNbMV1bMF0pO1xuICAgIGNwb2ludHNbMF1bMl0gPSAocG9pbnRzWzBdWzBdICsgY3BvaW50c1sxXVswXSkgLyAyO1xuICAgIGNwb2ludHNbMF1bM10gPSAocG9pbnRzWzBdWzFdICsgY3BvaW50c1sxXVsxXSkgLyAyO1xuICAgIGNwb2ludHNbMF1bNF0gPSAoY3BvaW50c1sxXVswXSAtIHBvaW50c1swXVswXSkgLyBkMDtcbiAgICBjcG9pbnRzWzBdWzVdID0gKGNwb2ludHNbMV1bMV0gLSBwb2ludHNbMF1bMV0pIC8gZDA7XG4gICAgdmFyIGQxID0gTWF0aC5oeXBvdChwb2ludHNbbGVuIC0gMV1bMV0gKyBjcG9pbnRzW2xlbiAtIDFdWzFdKTtcbiAgICBjcG9pbnRzW2xlbiAtIDFdWzBdID0gKHBvaW50c1tsZW4gLSAxXVswXSArIGNwb2ludHNbbGVuIC0gMl1bMl0pIC8gMjtcbiAgICBjcG9pbnRzW2xlbiAtIDFdWzFdID0gKHBvaW50c1tsZW4gLSAxXVsxXSArIGNwb2ludHNbbGVuIC0gMl1bM10pIC8gMjtcbiAgICBjcG9pbnRzW2xlbiAtIDFdWzRdID0gKGNwb2ludHNbbGVuIC0gMl1bMl0gLSBwb2ludHNbbGVuIC0gMV1bMF0pIC8gLWQxO1xuICAgIGNwb2ludHNbbGVuIC0gMV1bNV0gPSAoY3BvaW50c1tsZW4gLSAyXVszXSAtIHBvaW50c1tsZW4gLSAxXVsxXSkgLyAtZDE7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBjcG9pbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgc3RhcnQ6IHBvaW50c1tfaSAtIDFdLnNsaWNlKDAsIDIpLFxuICAgICAgICB0YW5nZW50U3RhcnQ6IGNwb2ludHNbX2kgLSAxXS5zbGljZSgyLCA0KSxcbiAgICAgICAgbm9ybWFsU3RhcnQ6IGNwb2ludHNbX2kgLSAxXS5zbGljZSg0LCA2KSxcbiAgICAgICAgcHJlc3N1cmVTdGFydDogMiArICgoX2kgLSAxKSAlIDIgPT09IDAgPyAxLjUgOiAwKSxcbiAgICAgICAgZW5kOiBwb2ludHNbX2ldLnNsaWNlKDAsIDIpLFxuICAgICAgICB0YW5nZW50RW5kOiBjcG9pbnRzW19pXS5zbGljZSgwLCAyKSxcbiAgICAgICAgbm9ybWFsRW5kOiBjcG9pbnRzW19pXS5zbGljZSg0LCA2KSxcbiAgICAgICAgcHJlc3N1cmVFbmQ6IDIgKyAoX2kgJSAyID09PSAwID8gMS41IDogMClcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG4gIC8qKlxyXG4gICAqIEZpbmQgYSBwb2ludCBhbG9uZyBhIGN1cnZlIHNlZ21lbnQsIHZpYSBwb21heC5cclxuICAgKiBAcGFyYW0gdFxyXG4gICAqIEBwYXJhbSBwb2ludHMgW2NweDEsIGNweTEsIGNweDIsIGNweTIsIHB4LCBweV1bXVxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuY29tcHV0ZVBvaW50T25DdXJ2ZSA9IGZ1bmN0aW9uIGNvbXB1dGVQb2ludE9uQ3VydmUodCwgcG9pbnRzKSB7XG4gICAgLy8gc2hvcnRjdXRzXG4gICAgaWYgKHQgPT09IDApIHtcbiAgICAgIHJldHVybiBwb2ludHNbMF07XG4gICAgfVxuXG4gICAgdmFyIG9yZGVyID0gcG9pbnRzLmxlbmd0aCAtIDE7XG5cbiAgICBpZiAodCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHBvaW50c1tvcmRlcl07XG4gICAgfVxuXG4gICAgdmFyIG10ID0gMSAtIHQ7XG4gICAgdmFyIHAgPSBwb2ludHM7IC8vIGNvbnN0YW50P1xuXG4gICAgaWYgKG9yZGVyID09PSAwKSB7XG4gICAgICByZXR1cm4gcG9pbnRzWzBdO1xuICAgIH0gLy8gbGluZWFyP1xuXG5cbiAgICBpZiAob3JkZXIgPT09IDEpIHtcbiAgICAgIHJldHVybiBbbXQgKiBwWzBdWzBdICsgdCAqIHBbMV1bMF0sIG10ICogcFswXVsxXSArIHQgKiBwWzFdWzFdXTtcbiAgICB9IC8vIHF1YWRyYXRpYy9jdWJpYyBjdXJ2ZT9cbiAgICAvLyBpZiAob3JkZXIgPCA0KSB7XG5cblxuICAgIHZhciBtdDIgPSBtdCAqIG10O1xuICAgIHZhciB0MiA9IHQgKiB0O1xuICAgIHZhciBhO1xuICAgIHZhciBiO1xuICAgIHZhciBjO1xuICAgIHZhciBkID0gMDtcblxuICAgIGlmIChvcmRlciA9PT0gMikge1xuICAgICAgcCA9IFtwWzBdLCBwWzFdLCBwWzJdLCBbMCwgMF1dO1xuICAgICAgYSA9IG10MjtcbiAgICAgIGIgPSBtdCAqIHQgKiAyO1xuICAgICAgYyA9IHQyOyAvLyB9IGVsc2UgaWYgKG9yZGVyID09PSAzKSB7XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBtdDIgKiBtdDtcbiAgICAgIGIgPSBtdDIgKiB0ICogMztcbiAgICAgIGMgPSBtdCAqIHQyICogMztcbiAgICAgIGQgPSB0ICogdDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIFthICogcFswXVswXSArIGIgKiBwWzFdWzBdICsgYyAqIHBbMl1bMF0gKyBkICogcFszXVswXSwgYSAqIHBbMF1bMV0gKyBiICogcFsxXVsxXSArIGMgKiBwWzJdWzFdICsgZCAqIHBbM11bMV1dOyAvLyB9IC8vIGhpZ2hlciBvcmRlciBjdXJ2ZXM6IHVzZSBkZSBDYXN0ZWxqYXUncyBjb21wdXRhdGlvblxuICB9XG4gIC8qKlxyXG4gICAqIEV2YWx1YXRlIGEgMmQgY3ViaWMgYmV6aWVyIGF0IGEgcG9pbnQgdCBvbiB0aGUgeCBheGlzLlxyXG4gICAqIEBwYXJhbSB0eFxyXG4gICAqIEBwYXJhbSB4MVxyXG4gICAqIEBwYXJhbSB5MVxyXG4gICAqIEBwYXJhbSB4MlxyXG4gICAqIEBwYXJhbSB5MlxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuY3ViaWNCZXppZXIgPSBmdW5jdGlvbiBjdWJpY0Jlemllcih0eCwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAvLyBJbnNwaXJlZCBieSBEb24gTGFuY2FzdGVyJ3MgdHdvIGFydGljbGVzXG4gICAgLy8gaHR0cDovL3d3dy50aW5hamEuY29tL2dsaWIvY3ViZW1hdGgucGRmXG4gICAgLy8gaHR0cDovL3d3dy50aW5hamEuY29tL3RleHQvYmV6bWF0aC5odG1sXG4gICAgLy8gU2V0IHN0YXJ0IGFuZCBlbmQgcG9pbnRcbiAgICB2YXIgeDAgPSAwO1xuICAgIHZhciB5MCA9IDA7XG4gICAgdmFyIHgzID0gMTtcbiAgICB2YXIgeTMgPSAxOyAvLyBDb252ZXJ0IHRoZSBjb29yZGluYXRlcyB0byBlcXVhdGlvbiBzcGFjZVxuXG4gICAgdmFyIEEgPSB4MyAtIDMgKiB4MiArIDMgKiB4MSAtIHgwO1xuICAgIHZhciBCID0gMyAqIHgyIC0gNiAqIHgxICsgMyAqIHgwO1xuICAgIHZhciBDID0gMyAqIHgxIC0gMyAqIHgwO1xuICAgIHZhciBEID0geDA7XG4gICAgdmFyIEUgPSB5MyAtIDMgKiB5MiArIDMgKiB5MSAtIHkwO1xuICAgIHZhciBGID0gMyAqIHkyIC0gNiAqIHkxICsgMyAqIHkwO1xuICAgIHZhciBHID0gMyAqIHkxIC0gMyAqIHkwO1xuICAgIHZhciBIID0geTA7IC8vIFZhcmlhYmxlcyBmb3IgdGhlIGxvb3AgYmVsb3dcblxuICAgIHZhciBpdGVyYXRpb25zID0gNTtcbiAgICB2YXIgaTtcbiAgICB2YXIgc2xvcGU7XG4gICAgdmFyIHg7XG4gICAgdmFyIHQgPSB0eDsgLy8gTG9vcCB0aHJvdWdoIGEgZmV3IHRpbWVzIHRvIGdldCBhIG1vcmUgYWNjdXJhdGUgdGltZSB2YWx1ZSwgYWNjb3JkaW5nIHRvIHRoZSBOZXd0b24tUmFwaHNvbiBtZXRob2RcbiAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL05ld3RvbidzX21ldGhvZFxuXG4gICAgZm9yIChpID0gMDsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgLy8gVGhlIGN1cnZlJ3MgeCBlcXVhdGlvbiBmb3IgdGhlIGN1cnJlbnQgdGltZSB2YWx1ZVxuICAgICAgeCA9IEEgKiB0ICogdCAqIHQgKyBCICogdCAqIHQgKyBDICogdCArIEQ7IC8vIFRoZSBzbG9wZSB3ZSB3YW50IGlzIHRoZSBpbnZlcnNlIG9mIHRoZSBkZXJpdmF0ZSBvZiB4XG5cbiAgICAgIHNsb3BlID0gMSAvICgzICogQSAqIHQgKiB0ICsgMiAqIEIgKiB0ICsgQyk7IC8vIEdldCB0aGUgbmV4dCBlc3RpbWF0ZWQgdGltZSB2YWx1ZSwgd2hpY2ggd2lsbCBiZSBtb3JlIGFjY3VyYXRlIHRoYW4gdGhlIG9uZSBiZWZvcmVcblxuICAgICAgdCAtPSAoeCAtIHR4KSAqIHNsb3BlO1xuICAgICAgdCA9IHQgPiAxID8gMSA6IHQgPCAwID8gMCA6IHQ7XG4gICAgfSAvLyBGaW5kIHRoZSB5IHZhbHVlIHRocm91Z2ggdGhlIGN1cnZlJ3MgeSBlcXVhdGlvbiwgd2l0aCB0aGUgbm93IG1vcmUgYWNjdXJhdGUgdGltZSB2YWx1ZVxuXG5cbiAgICByZXR1cm4gTWF0aC5hYnMoRSAqIHQgKiB0ICogdCArIEYgKiB0ICogdCArIEcgKiB0ICogSCk7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IGEgYmV6aWVyIGN1cnZlIGRhdGEgZm9yIGEgc3BsaW5lIHRoYXQgZml0cyBhbiBhcnJheSBvZiBwb2ludHMuXHJcbiAgICogQHBhcmFtIHBvaW50cyBBbiBhcnJheSBvZiBwb2ludHMgZm9ybWF0dGVkIGFzIFt4LCB5XVxyXG4gICAqIEBwYXJhbSBrIFRlbnNpb25cclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLmdldFNwbGluZSA9IGZ1bmN0aW9uIGdldFNwbGluZShwdHMsIGspIHtcbiAgICBpZiAoayA9PT0gdm9pZCAwKSB7XG4gICAgICBrID0gMC41O1xuICAgIH1cblxuICAgIHZhciBwMDtcbiAgICB2YXIgcDEgPSBwdHNbMF0sXG4gICAgICAgIHAyID0gcHRzWzFdLFxuICAgICAgICBwMyA9IHB0c1syXTtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IHB0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcDAgPSBwMTtcbiAgICAgIHAxID0gcDI7XG4gICAgICBwMiA9IHAzO1xuICAgICAgcDMgPSBwdHNbaSArIDJdID8gcHRzW2kgKyAyXSA6IHAyO1xuICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgY3AxeDogcDFbMF0gKyAocDJbMF0gLSBwMFswXSkgLyA2ICogayxcbiAgICAgICAgY3AxeTogcDFbMV0gKyAocDJbMV0gLSBwMFsxXSkgLyA2ICogayxcbiAgICAgICAgY3AyeDogcDJbMF0gLSAocDNbMF0gLSBwMVswXSkgLyA2ICogayxcbiAgICAgICAgY3AyeTogcDJbMV0gLSAocDNbMV0gLSBwMVsxXSkgLyA2ICogayxcbiAgICAgICAgcHg6IHB0c1tpXVswXSxcbiAgICAgICAgcHk6IHB0c1tpXVsxXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IGEgYmV6aWVyIGN1cnZlIGRhdGEgZm9yIGEgc3BsaW5lIHRoYXQgZml0cyBhbiBhcnJheSBvZiBwb2ludHMuXHJcbiAgICogQHBhcmFtIHB0c1xyXG4gICAqIEBwYXJhbSB0ZW5zaW9uXHJcbiAgICogQHBhcmFtIGlzQ2xvc2VkXHJcbiAgICogQHBhcmFtIG51bU9mU2VnbWVudHNcclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLmdldEN1cnZlUG9pbnRzID0gZnVuY3Rpb24gZ2V0Q3VydmVQb2ludHMocHRzLCB0ZW5zaW9uLCBpc0Nsb3NlZCwgbnVtT2ZTZWdtZW50cykge1xuICAgIGlmICh0ZW5zaW9uID09PSB2b2lkIDApIHtcbiAgICAgIHRlbnNpb24gPSAwLjU7XG4gICAgfVxuXG4gICAgaWYgKGlzQ2xvc2VkID09PSB2b2lkIDApIHtcbiAgICAgIGlzQ2xvc2VkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG51bU9mU2VnbWVudHMgPT09IHZvaWQgMCkge1xuICAgICAgbnVtT2ZTZWdtZW50cyA9IDM7XG4gICAgfVxuXG4gICAgdmFyIF9wdHMgPSBbXS5jb25jYXQocHRzKTtcblxuICAgIHZhciBsZW4gPSBwdHMubGVuZ3RoO1xuICAgIHZhciByZXMgPSBbXTsgLy8gcmVzdWx0c1xuXG4gICAgdmFyIHQxeCwgLy8gdGVuc2lvbiB2ZWN0b3JzXG4gICAgdDJ4LCB0MXksIHQyeSwgYzEsIC8vIGNhcmRpbmFsIHBvaW50c1xuICAgIGMyLCBjMywgYzQsIHN0LCBzdDIsIHN0MzsgLy8gVGhlIGFsZ29yaXRobSByZXF1aXJlIGEgcHJldmlvdXMgYW5kIG5leHQgcG9pbnQgdG8gdGhlIGFjdHVhbCBwb2ludCBhcnJheS5cbiAgICAvLyBDaGVjayBpZiB3ZSB3aWxsIGRyYXcgY2xvc2VkIG9yIG9wZW4gY3VydmUuXG4gICAgLy8gSWYgY2xvc2VkLCBjb3B5IGVuZCBwb2ludHMgdG8gYmVnaW5uaW5nIGFuZCBmaXJzdCBwb2ludHMgdG8gZW5kXG4gICAgLy8gSWYgb3BlbiwgZHVwbGljYXRlIGZpcnN0IHBvaW50cyB0byBiZWZpbm5pbmcsIGVuZCBwb2ludHMgdG8gZW5kXG5cbiAgICBpZiAoaXNDbG9zZWQpIHtcbiAgICAgIF9wdHMudW5zaGlmdChfcHRzW2xlbiAtIDFdKTtcblxuICAgICAgX3B0cy5wdXNoKF9wdHNbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb3B5IDEuIHBvaW50IGFuZCBpbnNlcnQgYXQgYmVnaW5uaW5nXG4gICAgICBfcHRzLnVuc2hpZnQoX3B0c1swXSk7XG5cbiAgICAgIF9wdHMucHVzaChfcHRzW2xlbiAtIDFdKTsgLy8gX3B0cy5wdXNoKF9wdHNbbGVuIC0gMV0pXG5cbiAgICB9IC8vIEZvciBlYWNoIHBvaW50LCBjYWxjdWxhdGUgYSBzZWdtZW50XG5cblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgX3B0cy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgIC8vIENhbGN1bGF0ZSBwb2ludHMgYWxvbmcgc2VnbWVudCBhbmQgYWRkIHRvIHJlc3VsdHNcbiAgICAgIGZvciAodmFyIHQgPSAwOyB0IDw9IG51bU9mU2VnbWVudHM7IHQrKykge1xuICAgICAgICAvLyBTdGVwXG4gICAgICAgIHN0ID0gdCAvIG51bU9mU2VnbWVudHM7XG4gICAgICAgIHN0MiA9IE1hdGgucG93KHN0LCAyKTtcbiAgICAgICAgc3QzID0gTWF0aC5wb3coc3QsIDMpOyAvLyBDYXJkaW5hbHNcblxuICAgICAgICBjMSA9IDIgKiBzdDMgLSAzICogc3QyICsgMTtcbiAgICAgICAgYzIgPSAtKDIgKiBzdDMpICsgMyAqIHN0MjtcbiAgICAgICAgYzMgPSBzdDMgLSAyICogc3QyICsgc3Q7XG4gICAgICAgIGM0ID0gc3QzIC0gc3QyOyAvLyBUZW5zaW9uXG5cbiAgICAgICAgdDF4ID0gKF9wdHNbaSArIDFdWzBdIC0gX3B0c1tpIC0gMV1bMF0pICogdGVuc2lvbjtcbiAgICAgICAgdDJ4ID0gKF9wdHNbaSArIDJdWzBdIC0gX3B0c1tpXVswXSkgKiB0ZW5zaW9uO1xuICAgICAgICB0MXkgPSAoX3B0c1tpICsgMV1bMV0gLSBfcHRzW2kgLSAxXVsxXSkgKiB0ZW5zaW9uO1xuICAgICAgICB0MnkgPSAoX3B0c1tpICsgMl1bMV0gLSBfcHRzW2ldWzFdKSAqIHRlbnNpb247IC8vIENvbnRyb2wgcG9pbnRzXG5cbiAgICAgICAgcmVzLnB1c2goW2MxICogX3B0c1tpXVswXSArIGMyICogX3B0c1tpICsgMV1bMF0gKyBjMyAqIHQxeCArIGM0ICogdDJ4LCBjMSAqIF9wdHNbaV1bMV0gKyBjMiAqIF9wdHNbaSArIDFdWzFdICsgYzMgKiB0MXkgKyBjNCAqIHQyeV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlcy5wdXNoKHB0c1twdHMubGVuZ3RoIC0gMV0pO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgLyoqXHJcbiAgICogU2ltcGxpZnkgYSBsaW5lICh1c2luZyBSYW1lci1Eb3VnbGFzLVBldWNrZXIgYWxnb3JpdGhtKS5cclxuICAgKiBAcGFyYW0gcG9pbnRzIEFuIGFycmF5IG9mIHBvaW50cyBhcyBbeCwgeSwgLi4uXVtdXHJcbiAgICogQHBhcmFtIHRvbGVyYW5jZSBUaGUgbWluaW11bSBsaW5lIGRpc3RhbmNlIChhbHNvIGNhbGxlZCBlcHNpbG9uKS5cclxuICAgKiBAcmV0dXJucyBTaW1wbGlmaWVkIGFycmF5IGFzIFt4LCB5LCAuLi5dW11cclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLnNpbXBsaWZ5ID0gZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzLCB0b2xlcmFuY2UpIHtcbiAgICBpZiAodG9sZXJhbmNlID09PSB2b2lkIDApIHtcbiAgICAgIHRvbGVyYW5jZSA9IDE7XG4gICAgfVxuXG4gICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgdmFyIGEgPSBwb2ludHNbMF07XG4gICAgdmFyIGIgPSBwb2ludHNbbGVuIC0gMV07XG4gICAgdmFyIHgxID0gYVswXSxcbiAgICAgICAgeTEgPSBhWzFdO1xuICAgIHZhciB4MiA9IGJbMF0sXG4gICAgICAgIHkyID0gYlsxXTtcblxuICAgIGlmIChsZW4gPiAyKSB7XG4gICAgICB2YXIgZGlzdGFuY2UgPSAwO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciBtYXggPSBNYXRoLmh5cG90KHkyIC0geTEsIHgyIC0geDEpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbiAtIDE7IGkrKykge1xuICAgICAgICB2YXIgX3BvaW50cyRpID0gcG9pbnRzW2ldLFxuICAgICAgICAgICAgeDAgPSBfcG9pbnRzJGlbMF0sXG4gICAgICAgICAgICB5MCA9IF9wb2ludHMkaVsxXTtcbiAgICAgICAgdmFyIGQgPSBNYXRoLmFicygoeTIgLSB5MSkgKiB4MCAtICh4MiAtIHgxKSAqIHkwICsgeDIgKiB5MSAtIHkyICogeDEpIC8gbWF4O1xuICAgICAgICBpZiAoZGlzdGFuY2UgPiBkKSBjb250aW51ZTtcbiAgICAgICAgZGlzdGFuY2UgPSBkO1xuICAgICAgICBpbmRleCA9IGk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXN0YW5jZSA+IHRvbGVyYW5jZSkge1xuICAgICAgICB2YXIgbDAgPSBVdGlscy5zaW1wbGlmeShwb2ludHMuc2xpY2UoMCwgaW5kZXggKyAxKSwgdG9sZXJhbmNlKTtcbiAgICAgICAgdmFyIGwxID0gVXRpbHMuc2ltcGxpZnkocG9pbnRzLnNsaWNlKGluZGV4ICsgMSksIHRvbGVyYW5jZSk7XG4gICAgICAgIHJldHVybiBsMC5jb25jYXQobDEuc2xpY2UoMSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbYSwgYl07XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IHdoZXRoZXIgYSBwb2ludCBpcyBpbnNpZGUgb2YgYSBjaXJjbGUuXHJcbiAgICogQHBhcmFtIEFcclxuICAgKiBAcGFyYW0gYlxyXG4gICAqIEByZXR1cm5zXHJcbiAgICovXG4gIDtcblxuICBVdGlscy5wb2ludEluQ2lyY2xlID0gZnVuY3Rpb24gcG9pbnRJbkNpcmNsZShBLCBDLCByKSB7XG4gICAgcmV0dXJuIFZlYy5kaXN0KEEsIEMpIDw9IHI7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IHdoZXRoZXIgYSBwb2ludCBpcyBpbnNpZGUgb2YgYW4gZWxsaXBzZS5cclxuICAgKiBAcGFyYW0gcG9pbnRcclxuICAgKiBAcGFyYW0gY2VudGVyXHJcbiAgICogQHBhcmFtIHJ4XHJcbiAgICogQHBhcmFtIHJ5XHJcbiAgICogQHBhcmFtIHJvdGF0aW9uXHJcbiAgICogQHJldHVybnNcclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLnBvaW50SW5FbGxpcHNlID0gZnVuY3Rpb24gcG9pbnRJbkVsbGlwc2UoQSwgQywgcngsIHJ5LCByb3RhdGlvbikge1xuICAgIGlmIChyb3RhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICByb3RhdGlvbiA9IDA7XG4gICAgfVxuXG4gICAgcm90YXRpb24gPSByb3RhdGlvbiB8fCAwO1xuICAgIHZhciBjb3MgPSBNYXRoLmNvcyhyb3RhdGlvbik7XG4gICAgdmFyIHNpbiA9IE1hdGguc2luKHJvdGF0aW9uKTtcbiAgICB2YXIgZGVsdGEgPSBWZWMuc3ViKEEsIEMpO1xuICAgIHZhciB0ZHggPSBjb3MgKiBkZWx0YVswXSArIHNpbiAqIGRlbHRhWzFdO1xuICAgIHZhciB0ZHkgPSBzaW4gKiBkZWx0YVswXSAtIGNvcyAqIGRlbHRhWzFdO1xuICAgIHJldHVybiB0ZHggKiB0ZHggLyAocnggKiByeCkgKyB0ZHkgKiB0ZHkgLyAocnkgKiByeSkgPD0gMTtcbiAgfVxuICAvKipcclxuICAgKiBHZXQgd2hldGhlciBhIHBvaW50IGlzIGluc2lkZSBvZiBhIHJlY3RhbmdsZS5cclxuICAgKiBAcGFyYW0gcG9pbnRcclxuICAgKiBAcGFyYW0gc2l6ZVxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMucG9pbnRJblJlY3QgPSBmdW5jdGlvbiBwb2ludEluUmVjdChwb2ludCwgc2l6ZSkge1xuICAgIHJldHVybiAhKHBvaW50WzBdIDwgc2l6ZVswXSB8fCBwb2ludFswXSA+IHBvaW50WzBdICsgc2l6ZVswXSB8fCBwb2ludFsxXSA8IHNpemVbMV0gfHwgcG9pbnRbMV0gPiBwb2ludFsxXSArIHNpemVbMV0pO1xuICB9XG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLSBCb3VuZHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgLyoqXHJcbiAgICogRXhwYW5kIGEgYm91bmRpbmcgYm94IGJ5IGEgZGVsdGEuXHJcbiAgICpcclxuICAgKiAjIyMgRXhhbXBsZVxyXG4gICAqXHJcbiAgICpgYGB0c1xyXG4gICAqIGV4cGFuZEJvdW5kcyhteUJvdW5kcywgWzEwMCwgMTAwXSlcclxuICAgKmBgYFxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuZXhwYW5kQm91bmRzID0gZnVuY3Rpb24gZXhwYW5kQm91bmRzKGJvdW5kcywgZGVsdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWluWDogYm91bmRzLm1pblggLSBkZWx0YSxcbiAgICAgIG1pblk6IGJvdW5kcy5taW5ZIC0gZGVsdGEsXG4gICAgICBtYXhYOiBib3VuZHMubWF4WCArIGRlbHRhLFxuICAgICAgbWF4WTogYm91bmRzLm1heFkgKyBkZWx0YSxcbiAgICAgIHdpZHRoOiBib3VuZHMud2lkdGggKyBkZWx0YSAqIDIsXG4gICAgICBoZWlnaHQ6IGJvdW5kcy5oZWlnaHQgKyBkZWx0YSAqIDJcbiAgICB9O1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCB3aGV0aGVyIGEgcG9pbnQgaXMgaW5zaWRlIG9mIGEgYm91bmRzLlxyXG4gICAqIEBwYXJhbSBBXHJcbiAgICogQHBhcmFtIGJcclxuICAgKiBAcmV0dXJuc1xyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMucG9pbnRJbkJvdW5kcyA9IGZ1bmN0aW9uIHBvaW50SW5Cb3VuZHMoQSwgYikge1xuICAgIHJldHVybiAhKEFbMF0gPCBiLm1pblggfHwgQVswXSA+IGIubWF4WCB8fCBBWzFdIDwgYi5taW5ZIHx8IEFbMV0gPiBiLm1heFkpO1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCB3aGV0aGVyIHR3byBib3VuZHMgY29sbGlkZS5cclxuICAgKiBAcGFyYW0gYSBCb3VuZHNcclxuICAgKiBAcGFyYW0gYiBCb3VuZHNcclxuICAgKiBAcmV0dXJuc1xyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuYm91bmRzQ29sbGlkZSA9IGZ1bmN0aW9uIGJvdW5kc0NvbGxpZGUoYSwgYikge1xuICAgIHJldHVybiAhKGEubWF4WCA8IGIubWluWCB8fCBhLm1pblggPiBiLm1heFggfHwgYS5tYXhZIDwgYi5taW5ZIHx8IGEubWluWSA+IGIubWF4WSk7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IHdoZXRoZXIgdGhlIGJvdW5kcyBvZiBBIGNvbnRhaW4gdGhlIGJvdW5kcyBvZiBCLiBBIHBlcmZlY3QgbWF0Y2ggd2lsbCByZXR1cm4gdHJ1ZS5cclxuICAgKiBAcGFyYW0gYSBCb3VuZHNcclxuICAgKiBAcGFyYW0gYiBCb3VuZHNcclxuICAgKiBAcmV0dXJuc1xyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuYm91bmRzQ29udGFpbiA9IGZ1bmN0aW9uIGJvdW5kc0NvbnRhaW4oYSwgYikge1xuICAgIHJldHVybiBhLm1pblggPCBiLm1pblggJiYgYS5taW5ZIDwgYi5taW5ZICYmIGEubWF4WSA+IGIubWF4WSAmJiBhLm1heFggPiBiLm1heFg7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IHdoZXRoZXIgdGhlIGJvdW5kcyBvZiBBIGFyZSBjb250YWluZWQgYnkgdGhlIGJvdW5kcyBvZiBCLlxyXG4gICAqIEBwYXJhbSBhIEJvdW5kc1xyXG4gICAqIEBwYXJhbSBiIEJvdW5kc1xyXG4gICAqIEByZXR1cm5zXHJcbiAgICovXG4gIDtcblxuICBVdGlscy5ib3VuZHNDb250YWluZWQgPSBmdW5jdGlvbiBib3VuZHNDb250YWluZWQoYSwgYikge1xuICAgIHJldHVybiBVdGlscy5ib3VuZHNDb250YWluKGIsIGEpO1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCB3aGV0aGVyIHR3byBib3VuZHMgYXJlIGlkZW50aWNhbC5cclxuICAgKiBAcGFyYW0gYSBCb3VuZHNcclxuICAgKiBAcGFyYW0gYiBCb3VuZHNcclxuICAgKiBAcmV0dXJuc1xyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuYm91bmRzQXJlRXF1YWwgPSBmdW5jdGlvbiBib3VuZHNBcmVFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuICEoYi5tYXhYICE9PSBhLm1heFggfHwgYi5taW5YICE9PSBhLm1pblggfHwgYi5tYXhZICE9PSBhLm1heFkgfHwgYi5taW5ZICE9PSBhLm1pblkpO1xuICB9XG4gIC8qKlxyXG4gICAqIEZpbmQgYSBib3VuZGluZyBib3ggZnJvbSBhbiBhcnJheSBvZiBwb2ludHMuXHJcbiAgICogQHBhcmFtIHBvaW50c1xyXG4gICAqIEBwYXJhbSByb3RhdGlvbiAob3B0aW9uYWwpIFRoZSBib3VuZGluZyBib3gncyByb3RhdGlvbi5cclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLmdldEJvdW5kc0Zyb21Qb2ludHMgPSBmdW5jdGlvbiBnZXRCb3VuZHNGcm9tUG9pbnRzKHBvaW50cywgcm90YXRpb24pIHtcbiAgICBpZiAocm90YXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgcm90YXRpb24gPSAwO1xuICAgIH1cblxuICAgIHZhciBtaW5YID0gSW5maW5pdHk7XG4gICAgdmFyIG1pblkgPSBJbmZpbml0eTtcbiAgICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcbiAgICB2YXIgbWF4WSA9IC1JbmZpbml0eTtcblxuICAgIGlmIChwb2ludHMubGVuZ3RoIDwgMikge1xuICAgICAgbWluWCA9IDA7XG4gICAgICBtaW5ZID0gMDtcbiAgICAgIG1heFggPSAxO1xuICAgICAgbWF4WSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UocG9pbnRzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIF9zdGVwJHZhbHVlID0gX3N0ZXAudmFsdWUsXG4gICAgICAgICAgICB4ID0gX3N0ZXAkdmFsdWVbMF0sXG4gICAgICAgICAgICB5ID0gX3N0ZXAkdmFsdWVbMV07XG4gICAgICAgIG1pblggPSBNYXRoLm1pbih4LCBtaW5YKTtcbiAgICAgICAgbWluWSA9IE1hdGgubWluKHksIG1pblkpO1xuICAgICAgICBtYXhYID0gTWF0aC5tYXgoeCwgbWF4WCk7XG4gICAgICAgIG1heFkgPSBNYXRoLm1heCh5LCBtYXhZKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocm90YXRpb24gIT09IDApIHtcbiAgICAgIHJldHVybiBVdGlscy5nZXRCb3VuZHNGcm9tUG9pbnRzKHBvaW50cy5tYXAoZnVuY3Rpb24gKHB0KSB7XG4gICAgICAgIHJldHVybiBWZWMucm90V2l0aChwdCwgWyhtaW5YICsgbWF4WCkgLyAyLCAobWluWSArIG1heFkpIC8gMl0sIHJvdGF0aW9uKTtcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWluWDogbWluWCxcbiAgICAgIG1pblk6IG1pblksXG4gICAgICBtYXhYOiBtYXhYLFxuICAgICAgbWF4WTogbWF4WSxcbiAgICAgIHdpZHRoOiBNYXRoLm1heCgxLCBtYXhYIC0gbWluWCksXG4gICAgICBoZWlnaHQ6IE1hdGgubWF4KDEsIG1heFkgLSBtaW5ZKVxuICAgIH07XG4gIH1cbiAgLyoqXHJcbiAgICogTW92ZSBhIGJvdW5kaW5nIGJveCB3aXRob3V0IHJlY2FsY3VsYXRpbmcgaXQuXHJcbiAgICogQHBhcmFtIGJvdW5kc1xyXG4gICAqIEBwYXJhbSBkZWx0YVxyXG4gICAqIEByZXR1cm5zXHJcbiAgICovXG4gIDtcblxuICBVdGlscy50cmFuc2xhdGVCb3VuZHMgPSBmdW5jdGlvbiB0cmFuc2xhdGVCb3VuZHMoYm91bmRzLCBkZWx0YSkge1xuICAgIHJldHVybiB7XG4gICAgICBtaW5YOiBib3VuZHMubWluWCArIGRlbHRhWzBdLFxuICAgICAgbWluWTogYm91bmRzLm1pblkgKyBkZWx0YVsxXSxcbiAgICAgIG1heFg6IGJvdW5kcy5tYXhYICsgZGVsdGFbMF0sXG4gICAgICBtYXhZOiBib3VuZHMubWF4WSArIGRlbHRhWzFdLFxuICAgICAgd2lkdGg6IGJvdW5kcy53aWR0aCxcbiAgICAgIGhlaWdodDogYm91bmRzLmhlaWdodFxuICAgIH07XG4gIH1cbiAgLyoqXHJcbiAgICogUm90YXRlIGEgYm91bmRpbmcgYm94LlxyXG4gICAqIEBwYXJhbSBib3VuZHNcclxuICAgKiBAcGFyYW0gY2VudGVyXHJcbiAgICogQHBhcmFtIHJvdGF0aW9uXHJcbiAgICovXG4gIDtcblxuICBVdGlscy5yb3RhdGVCb3VuZHMgPSBmdW5jdGlvbiByb3RhdGVCb3VuZHMoYm91bmRzLCBjZW50ZXIsIHJvdGF0aW9uKSB7XG4gICAgdmFyIF92ZWMkcm90V2l0aCA9IFZlYy5yb3RXaXRoKFtib3VuZHMubWluWCwgYm91bmRzLm1pblldLCBjZW50ZXIsIHJvdGF0aW9uKSxcbiAgICAgICAgbWluWCA9IF92ZWMkcm90V2l0aFswXSxcbiAgICAgICAgbWluWSA9IF92ZWMkcm90V2l0aFsxXTtcblxuICAgIHZhciBfdmVjJHJvdFdpdGgyID0gVmVjLnJvdFdpdGgoW2JvdW5kcy5tYXhYLCBib3VuZHMubWF4WV0sIGNlbnRlciwgcm90YXRpb24pLFxuICAgICAgICBtYXhYID0gX3ZlYyRyb3RXaXRoMlswXSxcbiAgICAgICAgbWF4WSA9IF92ZWMkcm90V2l0aDJbMV07XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWluWDogbWluWCxcbiAgICAgIG1pblk6IG1pblksXG4gICAgICBtYXhYOiBtYXhYLFxuICAgICAgbWF4WTogbWF4WSxcbiAgICAgIHdpZHRoOiBib3VuZHMud2lkdGgsXG4gICAgICBoZWlnaHQ6IGJvdW5kcy5oZWlnaHRcbiAgICB9O1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCB0aGUgcm90YXRlZCBib3VuZHMgb2YgYW4gZWxsaXBzZS5cclxuICAgKiBAcGFyYW0geFxyXG4gICAqIEBwYXJhbSB5XHJcbiAgICogQHBhcmFtIHJ4XHJcbiAgICogQHBhcmFtIHJ5XHJcbiAgICogQHBhcmFtIHJvdGF0aW9uXHJcbiAgICovXG4gIDtcblxuICBVdGlscy5nZXRSb3RhdGVkRWxsaXBzZUJvdW5kcyA9IGZ1bmN0aW9uIGdldFJvdGF0ZWRFbGxpcHNlQm91bmRzKHgsIHksIHJ4LCByeSwgcm90YXRpb24pIHtcbiAgICB2YXIgYyA9IE1hdGguY29zKHJvdGF0aW9uKTtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJvdGF0aW9uKTtcbiAgICB2YXIgdyA9IE1hdGguaHlwb3QocnggKiBjLCByeSAqIHMpO1xuICAgIHZhciBoID0gTWF0aC5oeXBvdChyeCAqIHMsIHJ5ICogYyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pblg6IHggKyByeCAtIHcsXG4gICAgICBtaW5ZOiB5ICsgcnkgLSBoLFxuICAgICAgbWF4WDogeCArIHJ4ICsgdyxcbiAgICAgIG1heFk6IHkgKyByeSArIGgsXG4gICAgICB3aWR0aDogdyAqIDIsXG4gICAgICBoZWlnaHQ6IGggKiAyXG4gICAgfTtcbiAgfVxuICAvKipcclxuICAgKiBHZXQgYSBib3VuZGluZyBib3ggdGhhdCBpbmNsdWRlcyB0d28gYm91bmRpbmcgYm94ZXMuXHJcbiAgICogQHBhcmFtIGEgQm91bmRpbmcgYm94XHJcbiAgICogQHBhcmFtIGIgQm91bmRpbmcgYm94XHJcbiAgICogQHJldHVybnNcclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLmdldEV4cGFuZGVkQm91bmRzID0gZnVuY3Rpb24gZ2V0RXhwYW5kZWRCb3VuZHMoYSwgYikge1xuICAgIHZhciBtaW5YID0gTWF0aC5taW4oYS5taW5YLCBiLm1pblgpO1xuICAgIHZhciBtaW5ZID0gTWF0aC5taW4oYS5taW5ZLCBiLm1pblkpO1xuICAgIHZhciBtYXhYID0gTWF0aC5tYXgoYS5tYXhYLCBiLm1heFgpO1xuICAgIHZhciBtYXhZID0gTWF0aC5tYXgoYS5tYXhZLCBiLm1heFkpO1xuICAgIHZhciB3aWR0aCA9IE1hdGguYWJzKG1heFggLSBtaW5YKTtcbiAgICB2YXIgaGVpZ2h0ID0gTWF0aC5hYnMobWF4WSAtIG1pblkpO1xuICAgIHJldHVybiB7XG4gICAgICBtaW5YOiBtaW5YLFxuICAgICAgbWluWTogbWluWSxcbiAgICAgIG1heFg6IG1heFgsXG4gICAgICBtYXhZOiBtYXhZLFxuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9O1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCB0aGUgY29tbW9uIGJvdW5kcyBvZiBhIGdyb3VwIG9mIGJvdW5kcy5cclxuICAgKiBAcmV0dXJuc1xyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuZ2V0Q29tbW9uQm91bmRzID0gZnVuY3Rpb24gZ2V0Q29tbW9uQm91bmRzKGJvdW5kcykge1xuICAgIGlmIChib3VuZHMubGVuZ3RoIDwgMikgcmV0dXJuIGJvdW5kc1swXTtcbiAgICB2YXIgcmVzdWx0ID0gYm91bmRzWzBdO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBib3VuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdCA9IFV0aWxzLmdldEV4cGFuZGVkQm91bmRzKHJlc3VsdCwgYm91bmRzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIFV0aWxzLmdldFJvdGF0ZWRDb3JuZXJzID0gZnVuY3Rpb24gZ2V0Um90YXRlZENvcm5lcnMoYiwgcm90YXRpb24pIHtcbiAgICBpZiAocm90YXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgcm90YXRpb24gPSAwO1xuICAgIH1cblxuICAgIHZhciBjZW50ZXIgPSBbYi5taW5YICsgYi53aWR0aCAvIDIsIGIubWluWSArIGIuaGVpZ2h0IC8gMl07XG4gICAgcmV0dXJuIFtbYi5taW5YLCBiLm1pblldLCBbYi5tYXhYLCBiLm1pblldLCBbYi5tYXhYLCBiLm1heFldLCBbYi5taW5YLCBiLm1heFldXS5tYXAoZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICByZXR1cm4gVmVjLnJvdFdpdGgocG9pbnQsIGNlbnRlciwgcm90YXRpb24pO1xuICAgIH0pO1xuICB9O1xuXG4gIFV0aWxzLmdldFRyYW5zZm9ybWVkQm91bmRpbmdCb3ggPSBmdW5jdGlvbiBnZXRUcmFuc2Zvcm1lZEJvdW5kaW5nQm94KGJvdW5kcywgaGFuZGxlLCBkZWx0YSwgcm90YXRpb24sIGlzQXNwZWN0UmF0aW9Mb2NrZWQpIHtcbiAgICBpZiAocm90YXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgcm90YXRpb24gPSAwO1xuICAgIH1cblxuICAgIGlmIChpc0FzcGVjdFJhdGlvTG9ja2VkID09PSB2b2lkIDApIHtcbiAgICAgIGlzQXNwZWN0UmF0aW9Mb2NrZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgdG9wIGxlZnQgYW5kIGJvdHRvbSByaWdodCBjb3JuZXJzLlxuICAgIHZhciBfcmVmID0gW2JvdW5kcy5taW5YLCBib3VuZHMubWluWV0sXG4gICAgICAgIGF4MCA9IF9yZWZbMF0sXG4gICAgICAgIGF5MCA9IF9yZWZbMV07XG4gICAgdmFyIF9yZWYyID0gW2JvdW5kcy5tYXhYLCBib3VuZHMubWF4WV0sXG4gICAgICAgIGF4MSA9IF9yZWYyWzBdLFxuICAgICAgICBheTEgPSBfcmVmMlsxXTsgLy8gQ3JlYXRlIGEgc2Vjb25kIHNldCBvZiBjb3JuZXJzIGZvciB0aGUgbmV3IGJveC5cblxuICAgIHZhciBfcmVmMyA9IFtib3VuZHMubWluWCwgYm91bmRzLm1pblldLFxuICAgICAgICBieDAgPSBfcmVmM1swXSxcbiAgICAgICAgYnkwID0gX3JlZjNbMV07XG4gICAgdmFyIF9yZWY0ID0gW2JvdW5kcy5tYXhYLCBib3VuZHMubWF4WV0sXG4gICAgICAgIGJ4MSA9IF9yZWY0WzBdLFxuICAgICAgICBieTEgPSBfcmVmNFsxXTsgLy8gSWYgdGhlIGRyYWcgaXMgb24gdGhlIGNlbnRlciwganVzdCB0cmFuc2xhdGUgdGhlIGJvdW5kcy5cblxuICAgIGlmIChoYW5kbGUgPT09ICdjZW50ZXInKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW5YOiBieDAgKyBkZWx0YVswXSxcbiAgICAgICAgbWluWTogYnkwICsgZGVsdGFbMV0sXG4gICAgICAgIG1heFg6IGJ4MSArIGRlbHRhWzBdLFxuICAgICAgICBtYXhZOiBieTEgKyBkZWx0YVsxXSxcbiAgICAgICAgd2lkdGg6IGJ4MSAtIGJ4MCxcbiAgICAgICAgaGVpZ2h0OiBieTEgLSBieTAsXG4gICAgICAgIHNjYWxlWDogMSxcbiAgICAgICAgc2NhbGVZOiAxXG4gICAgICB9O1xuICAgIH0gLy8gQ291bnRlciByb3RhdGUgdGhlIGRlbHRhLiBUaGlzIGxldHMgdXMgbWFrZSBjaGFuZ2VzIGFzIGlmXG4gICAgLy8gdGhlIChwb3NzaWJseSByb3RhdGVkKSBib3hlcyB3ZXJlIGF4aXMgYWxpZ25lZC5cblxuXG4gICAgdmFyIF92ZWMkcm90ID0gVmVjLnJvdChkZWx0YSwgLXJvdGF0aW9uKSxcbiAgICAgICAgZHggPSBfdmVjJHJvdFswXSxcbiAgICAgICAgZHkgPSBfdmVjJHJvdFsxXTtcbiAgICAvKlxyXG4gICAgMS4gRGVsdGFcclxuICAgICBVc2UgdGhlIGRlbHRhIHRvIGFkanVzdCB0aGUgbmV3IGJveCBieSBjaGFuZ2luZyBpdHMgY29ybmVycy5cclxuICAgIFRoZSBkcmFnZ2luZyBoYW5kbGUgKGNvcm5lciBvciBlZGdlKSB3aWxsIGRldGVybWluZSB3aGljaFxyXG4gICAgY29ybmVycyBzaG91bGQgY2hhbmdlLlxyXG4gICAgKi9cblxuXG4gICAgc3dpdGNoIChoYW5kbGUpIHtcbiAgICAgIGNhc2UgZXhwb3J0cy5UTEJvdW5kc0VkZ2UuVG9wOlxuICAgICAgY2FzZSBleHBvcnRzLlRMQm91bmRzQ29ybmVyLlRvcExlZnQ6XG4gICAgICBjYXNlIGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuVG9wUmlnaHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBieTAgKz0gZHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBleHBvcnRzLlRMQm91bmRzRWRnZS5Cb3R0b206XG4gICAgICBjYXNlIGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuQm90dG9tTGVmdDpcbiAgICAgIGNhc2UgZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Cb3R0b21SaWdodDpcbiAgICAgICAge1xuICAgICAgICAgIGJ5MSArPSBkeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAoaGFuZGxlKSB7XG4gICAgICBjYXNlIGV4cG9ydHMuVExCb3VuZHNFZGdlLkxlZnQ6XG4gICAgICBjYXNlIGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuVG9wTGVmdDpcbiAgICAgIGNhc2UgZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Cb3R0b21MZWZ0OlxuICAgICAgICB7XG4gICAgICAgICAgYngwICs9IGR4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgZXhwb3J0cy5UTEJvdW5kc0VkZ2UuUmlnaHQ6XG4gICAgICBjYXNlIGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuVG9wUmlnaHQ6XG4gICAgICBjYXNlIGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuQm90dG9tUmlnaHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBieDEgKz0gZHg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYXcgPSBheDEgLSBheDA7XG4gICAgdmFyIGFoID0gYXkxIC0gYXkwO1xuICAgIHZhciBzY2FsZVggPSAoYngxIC0gYngwKSAvIGF3O1xuICAgIHZhciBzY2FsZVkgPSAoYnkxIC0gYnkwKSAvIGFoO1xuICAgIHZhciBmbGlwWCA9IHNjYWxlWCA8IDA7XG4gICAgdmFyIGZsaXBZID0gc2NhbGVZIDwgMDtcbiAgICB2YXIgYncgPSBNYXRoLmFicyhieDEgLSBieDApO1xuICAgIHZhciBiaCA9IE1hdGguYWJzKGJ5MSAtIGJ5MCk7XG4gICAgLypcclxuICAgIDIuIEFzcGVjdCByYXRpb1xyXG4gICAgIElmIHRoZSBhc3BlY3QgcmF0aW8gaXMgbG9ja2VkLCBhZGp1c3QgdGhlIGNvcm5lcnMgc28gdGhhdCB0aGVcclxuICAgIG5ldyBib3gncyBhc3BlY3QgcmF0aW8gbWF0Y2hlcyB0aGUgb3JpZ2luYWwgYXNwZWN0IHJhdGlvLlxyXG4gICAgKi9cblxuICAgIGlmIChpc0FzcGVjdFJhdGlvTG9ja2VkKSB7XG4gICAgICB2YXIgYXIgPSBhdyAvIGFoO1xuICAgICAgdmFyIGlzVGFsbCA9IGFyIDwgYncgLyBiaDtcbiAgICAgIHZhciB0dyA9IGJ3ICogKHNjYWxlWSA8IDAgPyAxIDogLTEpICogKDEgLyBhcik7XG4gICAgICB2YXIgdGggPSBiaCAqIChzY2FsZVggPCAwID8gMSA6IC0xKSAqIGFyO1xuXG4gICAgICBzd2l0Y2ggKGhhbmRsZSkge1xuICAgICAgICBjYXNlIGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuVG9wTGVmdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoaXNUYWxsKSBieTAgPSBieTEgKyB0dztlbHNlIGJ4MCA9IGJ4MSArIHRoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Ub3BSaWdodDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoaXNUYWxsKSBieTAgPSBieTEgKyB0dztlbHNlIGJ4MSA9IGJ4MCAtIHRoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Cb3R0b21SaWdodDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoaXNUYWxsKSBieTEgPSBieTAgLSB0dztlbHNlIGJ4MSA9IGJ4MCAtIHRoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Cb3R0b21MZWZ0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChpc1RhbGwpIGJ5MSA9IGJ5MCAtIHR3O2Vsc2UgYngwID0gYngxICsgdGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBleHBvcnRzLlRMQm91bmRzRWRnZS5Cb3R0b206XG4gICAgICAgIGNhc2UgZXhwb3J0cy5UTEJvdW5kc0VkZ2UuVG9wOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBtID0gKGJ4MCArIGJ4MSkgLyAyO1xuICAgICAgICAgICAgdmFyIHcgPSBiaCAqIGFyO1xuICAgICAgICAgICAgYngwID0gbSAtIHcgLyAyO1xuICAgICAgICAgICAgYngxID0gbSArIHcgLyAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgZXhwb3J0cy5UTEJvdW5kc0VkZ2UuTGVmdDpcbiAgICAgICAgY2FzZSBleHBvcnRzLlRMQm91bmRzRWRnZS5SaWdodDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX20gPSAoYnkwICsgYnkxKSAvIDI7XG5cbiAgICAgICAgICAgIHZhciBoID0gYncgLyBhcjtcbiAgICAgICAgICAgIGJ5MCA9IF9tIC0gaCAvIDI7XG4gICAgICAgICAgICBieTEgPSBfbSArIGggLyAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKlxyXG4gICAgMy4gUm90YXRpb25cclxuICAgICBJZiB0aGUgYm91bmRzIGFyZSByb3RhdGVkLCBnZXQgYSB2ZWN0b3IgZnJvbSB0aGUgcm90YXRlZCBhbmNob3JcclxuICAgIGNvcm5lciBpbiB0aGUgaW5pdGFsIGJvdW5kcyB0byB0aGUgcm90YXRlZCBhbmNob3IgY29ybmVyIGluIHRoZVxyXG4gICAgcmVzdWx0J3MgYm91bmRzLiBTdWJ0cmFjdCB0aGlzIHZlY3RvciBmcm9tIHRoZSByZXN1bHQncyBjb3JuZXJzLFxyXG4gICAgc28gdGhhdCB0aGUgdHdvIGFuY2hvciBwb2ludHMgKGluaXRpYWwgYW5kIHJlc3VsdCkgd2lsbCBiZSBlcXVhbC5cclxuICAgICovXG5cblxuICAgIGlmIChyb3RhdGlvbiAlIChNYXRoLlBJICogMikgIT09IDApIHtcbiAgICAgIHZhciBjdiA9IFswLCAwXTtcbiAgICAgIHZhciBjMCA9IFZlYy5tZWQoW2F4MCwgYXkwXSwgW2F4MSwgYXkxXSk7XG4gICAgICB2YXIgYzEgPSBWZWMubWVkKFtieDAsIGJ5MF0sIFtieDEsIGJ5MV0pO1xuXG4gICAgICBzd2l0Y2ggKGhhbmRsZSkge1xuICAgICAgICBjYXNlIGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuVG9wTGVmdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjdiA9IFZlYy5zdWIoVmVjLnJvdFdpdGgoW2J4MSwgYnkxXSwgYzEsIHJvdGF0aW9uKSwgVmVjLnJvdFdpdGgoW2F4MSwgYXkxXSwgYzAsIHJvdGF0aW9uKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBleHBvcnRzLlRMQm91bmRzQ29ybmVyLlRvcFJpZ2h0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGN2ID0gVmVjLnN1YihWZWMucm90V2l0aChbYngwLCBieTFdLCBjMSwgcm90YXRpb24pLCBWZWMucm90V2l0aChbYXgwLCBheTFdLCBjMCwgcm90YXRpb24pKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuQm90dG9tUmlnaHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY3YgPSBWZWMuc3ViKFZlYy5yb3RXaXRoKFtieDAsIGJ5MF0sIGMxLCByb3RhdGlvbiksIFZlYy5yb3RXaXRoKFtheDAsIGF5MF0sIGMwLCByb3RhdGlvbikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Cb3R0b21MZWZ0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGN2ID0gVmVjLnN1YihWZWMucm90V2l0aChbYngxLCBieTBdLCBjMSwgcm90YXRpb24pLCBWZWMucm90V2l0aChbYXgxLCBheTBdLCBjMCwgcm90YXRpb24pKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIGV4cG9ydHMuVExCb3VuZHNFZGdlLlRvcDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjdiA9IFZlYy5zdWIoVmVjLnJvdFdpdGgoVmVjLm1lZChbYngwLCBieTFdLCBbYngxLCBieTFdKSwgYzEsIHJvdGF0aW9uKSwgVmVjLnJvdFdpdGgoVmVjLm1lZChbYXgwLCBheTFdLCBbYXgxLCBheTFdKSwgYzAsIHJvdGF0aW9uKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBleHBvcnRzLlRMQm91bmRzRWRnZS5MZWZ0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGN2ID0gVmVjLnN1YihWZWMucm90V2l0aChWZWMubWVkKFtieDEsIGJ5MF0sIFtieDEsIGJ5MV0pLCBjMSwgcm90YXRpb24pLCBWZWMucm90V2l0aChWZWMubWVkKFtheDEsIGF5MF0sIFtheDEsIGF5MV0pLCBjMCwgcm90YXRpb24pKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIGV4cG9ydHMuVExCb3VuZHNFZGdlLkJvdHRvbTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjdiA9IFZlYy5zdWIoVmVjLnJvdFdpdGgoVmVjLm1lZChbYngwLCBieTBdLCBbYngxLCBieTBdKSwgYzEsIHJvdGF0aW9uKSwgVmVjLnJvdFdpdGgoVmVjLm1lZChbYXgwLCBheTBdLCBbYXgxLCBheTBdKSwgYzAsIHJvdGF0aW9uKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBleHBvcnRzLlRMQm91bmRzRWRnZS5SaWdodDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjdiA9IFZlYy5zdWIoVmVjLnJvdFdpdGgoVmVjLm1lZChbYngwLCBieTBdLCBbYngwLCBieTFdKSwgYzEsIHJvdGF0aW9uKSwgVmVjLnJvdFdpdGgoVmVjLm1lZChbYXgwLCBheTBdLCBbYXgwLCBheTFdKSwgYzAsIHJvdGF0aW9uKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBfdmVjJHN1YiA9IFZlYy5zdWIoW2J4MCwgYnkwXSwgY3YpO1xuXG4gICAgICBieDAgPSBfdmVjJHN1YlswXTtcbiAgICAgIGJ5MCA9IF92ZWMkc3ViWzFdO1xuXG4gICAgICB2YXIgX3ZlYyRzdWIyID0gVmVjLnN1YihbYngxLCBieTFdLCBjdik7XG5cbiAgICAgIGJ4MSA9IF92ZWMkc3ViMlswXTtcbiAgICAgIGJ5MSA9IF92ZWMkc3ViMlsxXTtcbiAgICB9XG4gICAgLypcclxuICAgIDQuIEZsaXBzXHJcbiAgICAgSWYgdGhlIGF4ZXMgYXJlIGZsaXBwZWQgKGUuZy4gaWYgdGhlIHJpZ2h0IGVkZ2UgaGFzIGJlZW4gZHJhZ2dlZFxyXG4gICAgbGVmdCBwYXN0IHRoZSBpbml0aWFsIGxlZnQgZWRnZSkgdGhlbiBzd2FwIHBvaW50cyBvbiB0aGF0IGF4aXMuXHJcbiAgICAqL1xuXG5cbiAgICBpZiAoYngxIDwgYngwKSB7XG4gICAgICB2YXIgX3JlZjUgPSBbYngwLCBieDFdO1xuICAgICAgYngxID0gX3JlZjVbMF07XG4gICAgICBieDAgPSBfcmVmNVsxXTtcbiAgICB9XG5cbiAgICBpZiAoYnkxIDwgYnkwKSB7XG4gICAgICB2YXIgX3JlZjYgPSBbYnkwLCBieTFdO1xuICAgICAgYnkxID0gX3JlZjZbMF07XG4gICAgICBieTAgPSBfcmVmNlsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWluWDogYngwLFxuICAgICAgbWluWTogYnkwLFxuICAgICAgbWF4WDogYngxLFxuICAgICAgbWF4WTogYnkxLFxuICAgICAgd2lkdGg6IGJ4MSAtIGJ4MCxcbiAgICAgIGhlaWdodDogYnkxIC0gYnkwLFxuICAgICAgc2NhbGVYOiAoYngxIC0gYngwKSAvIChheDEgLSBheDAgfHwgMSkgKiAoZmxpcFggPyAtMSA6IDEpLFxuICAgICAgc2NhbGVZOiAoYnkxIC0gYnkwKSAvIChheTEgLSBheTAgfHwgMSkgKiAoZmxpcFkgPyAtMSA6IDEpXG4gICAgfTtcbiAgfTtcblxuICBVdGlscy5nZXRUcmFuc2Zvcm1BbmNob3IgPSBmdW5jdGlvbiBnZXRUcmFuc2Zvcm1BbmNob3IodHlwZSwgaXNGbGlwcGVkWCwgaXNGbGlwcGVkWSkge1xuICAgIHZhciBhbmNob3IgPSB0eXBlOyAvLyBDaGFuZ2UgY29ybmVyIGFuY2hvcnMgaWYgZmxpcHBlZFxuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuVG9wTGVmdDpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChpc0ZsaXBwZWRYICYmIGlzRmxpcHBlZFkpIHtcbiAgICAgICAgICAgIGFuY2hvciA9IGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuQm90dG9tUmlnaHQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0ZsaXBwZWRYKSB7XG4gICAgICAgICAgICBhbmNob3IgPSBleHBvcnRzLlRMQm91bmRzQ29ybmVyLlRvcFJpZ2h0O1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNGbGlwcGVkWSkge1xuICAgICAgICAgICAgYW5jaG9yID0gZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Cb3R0b21MZWZ0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbmNob3IgPSBleHBvcnRzLlRMQm91bmRzQ29ybmVyLkJvdHRvbVJpZ2h0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Ub3BSaWdodDpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChpc0ZsaXBwZWRYICYmIGlzRmxpcHBlZFkpIHtcbiAgICAgICAgICAgIGFuY2hvciA9IGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuQm90dG9tTGVmdDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRmxpcHBlZFgpIHtcbiAgICAgICAgICAgIGFuY2hvciA9IGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuVG9wTGVmdDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRmxpcHBlZFkpIHtcbiAgICAgICAgICAgIGFuY2hvciA9IGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuQm90dG9tUmlnaHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuY2hvciA9IGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuQm90dG9tTGVmdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuQm90dG9tUmlnaHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoaXNGbGlwcGVkWCAmJiBpc0ZsaXBwZWRZKSB7XG4gICAgICAgICAgICBhbmNob3IgPSBleHBvcnRzLlRMQm91bmRzQ29ybmVyLlRvcExlZnQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0ZsaXBwZWRYKSB7XG4gICAgICAgICAgICBhbmNob3IgPSBleHBvcnRzLlRMQm91bmRzQ29ybmVyLkJvdHRvbUxlZnQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0ZsaXBwZWRZKSB7XG4gICAgICAgICAgICBhbmNob3IgPSBleHBvcnRzLlRMQm91bmRzQ29ybmVyLlRvcFJpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbmNob3IgPSBleHBvcnRzLlRMQm91bmRzQ29ybmVyLlRvcExlZnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBleHBvcnRzLlRMQm91bmRzQ29ybmVyLkJvdHRvbUxlZnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoaXNGbGlwcGVkWCAmJiBpc0ZsaXBwZWRZKSB7XG4gICAgICAgICAgICBhbmNob3IgPSBleHBvcnRzLlRMQm91bmRzQ29ybmVyLlRvcFJpZ2h0O1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNGbGlwcGVkWCkge1xuICAgICAgICAgICAgYW5jaG9yID0gZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Cb3R0b21SaWdodDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRmxpcHBlZFkpIHtcbiAgICAgICAgICAgIGFuY2hvciA9IGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuVG9wTGVmdDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5jaG9yID0gZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Ub3BSaWdodDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhbmNob3I7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IHRoZSByZWxhdGl2ZSBib3VuZHMgKHVzdWFsbHkgYSBjaGlsZCkgd2l0aGluIGEgdHJhbnNmb3JtZWQgYm91bmRpbmcgYm94LlxyXG4gICAqIEBwYXJhbSBib3VuZHNcclxuICAgKiBAcGFyYW0gaW5pdGlhbEJvdW5kc1xyXG4gICAqIEBwYXJhbSBpbml0aWFsU2hhcGVCb3VuZHNcclxuICAgKiBAcGFyYW0gaXNGbGlwcGVkWFxyXG4gICAqIEBwYXJhbSBpc0ZsaXBwZWRZXHJcbiAgICovXG4gIDtcblxuICBVdGlscy5nZXRSZWxhdGl2ZVRyYW5zZm9ybWVkQm91bmRpbmdCb3ggPSBmdW5jdGlvbiBnZXRSZWxhdGl2ZVRyYW5zZm9ybWVkQm91bmRpbmdCb3goYm91bmRzLCBpbml0aWFsQm91bmRzLCBpbml0aWFsU2hhcGVCb3VuZHMsIGlzRmxpcHBlZFgsIGlzRmxpcHBlZFkpIHtcbiAgICB2YXIgbnggPSAoaXNGbGlwcGVkWCA/IGluaXRpYWxCb3VuZHMubWF4WCAtIGluaXRpYWxTaGFwZUJvdW5kcy5tYXhYIDogaW5pdGlhbFNoYXBlQm91bmRzLm1pblggLSBpbml0aWFsQm91bmRzLm1pblgpIC8gaW5pdGlhbEJvdW5kcy53aWR0aDtcbiAgICB2YXIgbnkgPSAoaXNGbGlwcGVkWSA/IGluaXRpYWxCb3VuZHMubWF4WSAtIGluaXRpYWxTaGFwZUJvdW5kcy5tYXhZIDogaW5pdGlhbFNoYXBlQm91bmRzLm1pblkgLSBpbml0aWFsQm91bmRzLm1pblkpIC8gaW5pdGlhbEJvdW5kcy5oZWlnaHQ7XG4gICAgdmFyIG53ID0gaW5pdGlhbFNoYXBlQm91bmRzLndpZHRoIC8gaW5pdGlhbEJvdW5kcy53aWR0aDtcbiAgICB2YXIgbmggPSBpbml0aWFsU2hhcGVCb3VuZHMuaGVpZ2h0IC8gaW5pdGlhbEJvdW5kcy5oZWlnaHQ7XG4gICAgdmFyIG1pblggPSBib3VuZHMubWluWCArIGJvdW5kcy53aWR0aCAqIG54O1xuICAgIHZhciBtaW5ZID0gYm91bmRzLm1pblkgKyBib3VuZHMuaGVpZ2h0ICogbnk7XG4gICAgdmFyIHdpZHRoID0gYm91bmRzLndpZHRoICogbnc7XG4gICAgdmFyIGhlaWdodCA9IGJvdW5kcy5oZWlnaHQgKiBuaDtcbiAgICByZXR1cm4ge1xuICAgICAgbWluWDogbWluWCxcbiAgICAgIG1pblk6IG1pblksXG4gICAgICBtYXhYOiBtaW5YICsgd2lkdGgsXG4gICAgICBtYXhZOiBtaW5ZICsgaGVpZ2h0LFxuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9O1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc2l6ZSBvZiBhIHJvdGF0ZWQgYm94LlxyXG4gICAqIEBwYXJhbSBzaXplIDogO1xyXG4gICAqIEBwYXJhbSByb3RhdGlvblxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuZ2V0Um90YXRlZFNpemUgPSBmdW5jdGlvbiBnZXRSb3RhdGVkU2l6ZShzaXplLCByb3RhdGlvbikge1xuICAgIHZhciBjZW50ZXIgPSBWZWMuZGl2KHNpemUsIDIpO1xuICAgIHZhciBwb2ludHMgPSBbWzAsIDBdLCBbc2l6ZVswXSwgMF0sIHNpemUsIFswLCBzaXplWzFdXV0ubWFwKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgcmV0dXJuIFZlYy5yb3RXaXRoKHBvaW50LCBjZW50ZXIsIHJvdGF0aW9uKTtcbiAgICB9KTtcbiAgICB2YXIgYm91bmRzID0gVXRpbHMuZ2V0Qm91bmRzRnJvbVBvaW50cyhwb2ludHMpO1xuICAgIHJldHVybiBbYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0XTtcbiAgfVxuICAvKipcclxuICAgKiBHZXQgdGhlIGNlbnRlciBvZiBhIGJvdW5kaW5nIGJveC5cclxuICAgKiBAcGFyYW0gYm91bmRzXHJcbiAgICovXG4gIDtcblxuICBVdGlscy5nZXRCb3VuZHNDZW50ZXIgPSBmdW5jdGlvbiBnZXRCb3VuZHNDZW50ZXIoYm91bmRzKSB7XG4gICAgcmV0dXJuIFtib3VuZHMubWluWCArIGJvdW5kcy53aWR0aCAvIDIsIGJvdW5kcy5taW5ZICsgYm91bmRzLmhlaWdodCAvIDJdO1xuICB9XG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgLyogICAgICAgICAgICAgICAgTGlzdHMgYW5kIENvbGxlY3Rpb25zICAgICAgICAgICAgICAgKi9cblxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gIC8qKlxyXG4gICAqXHJcbiAgICpcclxuICAgKiAjIyMgRXhhbXBsZVxyXG4gICAqXHJcbiAgICpgYGB0c1xyXG4gICAqIGV4YW1wbGVcclxuICAgKmBgYFxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMucmVtb3ZlRHVwbGljYXRlUG9pbnRzID0gZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlUG9pbnRzKHBvaW50cykge1xuICAgIHJldHVybiBwb2ludHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHB0LCBpKSB7XG4gICAgICBpZiAoaSA9PT0gMCB8fCAhVmVjLmlzRXF1YWwocHQsIGFjY1tpIC0gMV0pKSB7XG4gICAgICAgIGFjYy5wdXNoKHB0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSk7XG4gIH1cbiAgLyoqXHJcbiAgLy8gcG9pbnRzID1cclxuICAgXG4gIC8qKlxyXG4gICogR2V0IGEgdmFsdWUgZnJvbSBhIGNhY2hlIChhIFdlYWtNYXApLCBmaWxsaW5nIHRoZSB2YWx1ZSBpZiBpdCBpcyBub3QgcHJlc2VudC5cclxuICAqXHJcbiAgKiAjIyMgRXhhbXBsZVxyXG4gICpcclxuICAqYGBgdHNcclxuICAqIGdldEZyb21DYWNoZShib3VuZHNDYWNoZSwgc2hhcGUsIChjYWNoZSkgPT4gY2FjaGUuc2V0KHNoYXBlLCBcInZhbHVlXCIpKVxyXG4gICpgYGBcclxuICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuICA7XG5cbiAgVXRpbHMuZ2V0RnJvbUNhY2hlID0gZnVuY3Rpb24gZ2V0RnJvbUNhY2hlKGNhY2hlLCBpdGVtLCBnZXROZXh0KSB7XG4gICAgdmFyIHZhbHVlID0gY2FjaGUuZ2V0KGl0ZW0pO1xuXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNhY2hlLnNldChpdGVtLCBnZXROZXh0KCkpO1xuICAgICAgdmFsdWUgPSBjYWNoZS5nZXQoaXRlbSk7XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdDYWNoZSBkaWQgbm90IGluY2x1ZGUgaXRlbSEnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IGEgdW5pcXVlIHN0cmluZyBpZC5cclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLnVuaXF1ZUlkID0gZnVuY3Rpb24gdW5pcXVlSWQoYSkge1xuICAgIGlmIChhID09PSB2b2lkIDApIHtcbiAgICAgIGEgPSAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gYSA/XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuICAgICgoTnVtYmVyKGEpIF4gTWF0aC5yYW5kb20oKSAqIDE2KSA+PiBOdW1iZXIoYSkgLyA0KS50b1N0cmluZygxNikgOiAoMWU3ICsgXCItXCIgKyAxZTMgKyBcIi1cIiArIDRlMyArIFwiLVwiICsgOGUzICsgXCItXCIgKyAxZTExKS5yZXBsYWNlKC9bMDE4XS9nLCBVdGlscy51bmlxdWVJZCk7XG4gIH1cbiAgLyoqXHJcbiAgICogU2h1ZmZsZSB0aGUgY29udGVudHMgb2YgYW4gYXJyYXkuXHJcbiAgICogQHBhcmFtIGFyclxyXG4gICAqIEBwYXJhbSBvZmZzZXRcclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLnNodWZmbGVBcnIgPSBmdW5jdGlvbiBzaHVmZmxlQXJyKGFyciwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGFyci5tYXAoZnVuY3Rpb24gKF8sIGkpIHtcbiAgICAgIHJldHVybiBhcnJbKGkgKyBvZmZzZXQpICUgYXJyLmxlbmd0aF07XG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogRGVlcCBjb21wYXJlIHR3byBhcnJheXMuXHJcbiAgICogQHBhcmFtIGFcclxuICAgKiBAcGFyYW0gYlxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuZGVlcENvbXBhcmVBcnJheXMgPSBmdW5jdGlvbiBkZWVwQ29tcGFyZUFycmF5cyhhLCBiKSB7XG4gICAgaWYgKChhID09IG51bGwgPyB2b2lkIDAgOiBhLmxlbmd0aCkgIT09IChiID09IG51bGwgPyB2b2lkIDAgOiBiLmxlbmd0aCkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gVXRpbHMuZGVlcENvbXBhcmUoYSwgYik7XG4gIH1cbiAgLyoqXHJcbiAgICogRGVlcCBjb21wYXJlIGFueSB2YWx1ZXMuXHJcbiAgICogQHBhcmFtIGFcclxuICAgKiBAcGFyYW0gYlxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuZGVlcENvbXBhcmUgPSBmdW5jdGlvbiBkZWVwQ29tcGFyZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT09IGIgfHwgSlNPTi5zdHJpbmdpZnkoYSkgPT09IEpTT04uc3RyaW5naWZ5KGIpO1xuICB9O1xuXG4gIFV0aWxzLmFycnNJbnRlcnNlY3QgPSBmdW5jdGlvbiBhcnJzSW50ZXJzZWN0KGEsIGIsIGZuKSB7XG4gICAgcmV0dXJuIGEuc29tZShmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGIuaW5jbHVkZXMoZm4gPyBmbihpdGVtKSA6IGl0ZW0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCB0aGUgdW5pcXVlIHZhbHVlcyBmcm9tIGFuIGFycmF5IG9mIHN0cmluZ3Mgb3IgbnVtYmVycy5cclxuICAgKiBAcGFyYW0gaXRlbXNcclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLnVuaXF1ZUFycmF5ID0gZnVuY3Rpb24gdW5pcXVlQXJyYXkoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGl0ZW1zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgaXRlbXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChpdGVtcykudmFsdWVzKCkpO1xuICB9XG4gIC8qKlxyXG4gICAqIENvbnZlcnQgYSBzZXQgdG8gYW4gYXJyYXkuXHJcbiAgICogQHBhcmFtIHNldFxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuc2V0VG9BcnJheSA9IGZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oc2V0LnZhbHVlcygpKTtcbiAgfVxuICAvKipcclxuICAgKiBEZWJvdW5jZSBhIGZ1bmN0aW9uLlxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuZGVib3VuY2UgPSBmdW5jdGlvbiBkZWJvdW5jZShmbiwgbXMpIHtcbiAgICBpZiAobXMgPT09IHZvaWQgMCkge1xuICAgICAgbXMgPSAwO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgdmFyIHRpbWVvdXRJZDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGFyZ3MpO1xuICAgICAgfSwgbXMpO1xuICAgIH07XG4gIH1cbiAgLyoqXHJcbiAgICogVHVybiBhbiBhcnJheSBvZiBwb2ludHMgaW50byBhIHBhdGggb2YgcXVhZHJhZGljIGN1cnZlcy5cclxuICAgKiBAcGFyYW0gc3Ryb2tlIDtcclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLmdldFN2Z1BhdGhGcm9tU3Ryb2tlID0gZnVuY3Rpb24gZ2V0U3ZnUGF0aEZyb21TdHJva2Uoc3Ryb2tlKSB7XG4gICAgaWYgKCFzdHJva2UubGVuZ3RoKSByZXR1cm4gJyc7XG4gICAgdmFyIGQgPSBzdHJva2UucmVkdWNlKGZ1bmN0aW9uIChhY2MsIF9yZWY3LCBpLCBhcnIpIHtcbiAgICAgIHZhciB4MCA9IF9yZWY3WzBdLFxuICAgICAgICAgIHkwID0gX3JlZjdbMV07XG4gICAgICB2YXIgX2FyciA9IGFyclsoaSArIDEpICUgYXJyLmxlbmd0aF0sXG4gICAgICAgICAgeDEgPSBfYXJyWzBdLFxuICAgICAgICAgIHkxID0gX2FyclsxXTtcbiAgICAgIGFjYy5wdXNoKFwiIFwiICsgeDAgKyBcIixcIiArIHkwICsgXCIgXCIgKyAoeDAgKyB4MSkgLyAyICsgXCIsXCIgKyAoeTAgKyB5MSkgLyAyKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgWydNICcsIHN0cm9rZVswXVswXSArIFwiLFwiICsgc3Ryb2tlWzBdWzFdLCAnIFEnXSk7XG4gICAgZC5wdXNoKCcgWicpO1xuICAgIHJldHVybiBkLmpvaW4oJycpLnJlcGxhY2VBbGwoLyhcXHM/W0EtWl0/LD8tP1swLTldKlxcLlswLTldezAsMn0pKChbMC05XXxlfC0pKikvZywgJyQxJyk7XG4gIH1cbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAvKiAgICAgICAgICAgICAgICAgICBCcm93c2VyIGFuZCBET00gICAgICAgICAgICAgICAgICAqL1xuXG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgLyoqXHJcbiAgICogRmluZCB3aGV0aGVyIHRoZSBjdXJyZW50IGRpc3BsYXkgaXMgYSB0b3VjaCBkaXNwbGF5LlxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuaXNUb3VjaERpc3BsYXkgPSBmdW5jdGlvbiBpc1RvdWNoRGlzcGxheSgpIHtcbiAgICByZXR1cm4gJ29udG91Y2hzdGFydCcgaW4gd2luZG93IHx8IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDAgfHwgbmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMgPiAwO1xuICB9XG4gIC8qKlxyXG4gICAqIEZpbmQgd2hldGhlciB0aGUgY3VycmVudCBkZXZpY2UgaXMgYSBNYWMgLyBpT1MgLyBpUGFkT1MuXHJcbiAgICovXG4gIDtcblxuICBVdGlscy5pc0RhcndpbiA9IGZ1bmN0aW9uIGlzRGFyd2luKCkge1xuICAgIHJldHVybiAvTWFjfGlQb2R8aVBob25lfGlQYWQvLnRlc3Qod2luZG93Lm5hdmlnYXRvci5wbGF0Zm9ybSk7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IHdoZXRoZXIgdGhlIGN1cnJlbnQgZGV2aWNlIGlzIGEgbW9iaWxlIGRldmljZS5cclxuICAgKi9cbiAgO1xuXG4gIFV0aWxzLmlzTW9iaWxlID0gZnVuY3Rpb24gaXNNb2JpbGUoKSB7XG4gICAgcmV0dXJuIGZhbHNlOyAvLyBfaXNNb2JpbGUoKS5hbnlcbiAgfVxuICAvKipcclxuICAgKiBHZXQgd2hldGhlciBhbiBldmVudCBpcyBjb21tYW5kIChtYWMpIG9yIGNvbnRyb2wgKHBjKS5cclxuICAgKiBAcGFyYW0gZVxyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMubWV0YUtleSA9IGZ1bmN0aW9uIG1ldGFLZXkoZSkge1xuICAgIHJldHVybiBVdGlscy5pc0RhcndpbigpID8gZS5tZXRhS2V5IDogZS5jdHJsS2V5O1xuICB9XG4gIC8qKlxyXG4gICAqIEZpbmQgdGhlIGNsb3Nlc3QgcG9pbnQgb24gYSBTVkcgcGF0aCB0byBhbiBvZmYtcGF0aCBwb2ludC5cclxuICAgKiBAcGFyYW0gcGF0aE5vZGVcclxuICAgKiBAcGFyYW0gcG9pbnRcclxuICAgKiBAcmV0dXJuc1xyXG4gICAqL1xuICA7XG5cbiAgVXRpbHMuZ2V0Q2xvc2VzdFBvaW50T25TVkdQYXRoID0gZnVuY3Rpb24gZ2V0Q2xvc2VzdFBvaW50T25TVkdQYXRoKHBhdGhOb2RlLCBwb2ludCkge1xuICAgIGZ1bmN0aW9uIGRpc3RhbmNlMihwLCBwb2ludCkge1xuICAgICAgdmFyIGR4ID0gcC54IC0gcG9pbnRbMF07XG4gICAgICB2YXIgZHkgPSBwLnkgLSBwb2ludFsxXTtcbiAgICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICB9XG5cbiAgICB2YXIgcGF0aExlbiA9IHBhdGhOb2RlLmdldFRvdGFsTGVuZ3RoKCk7XG4gICAgdmFyIHAgPSA4O1xuICAgIHZhciBiZXN0ID0ge307XG4gICAgdmFyIGJlc3RMZW4gPSBJbmZpbml0eTtcbiAgICB2YXIgYmVzdERpc3QgPSBJbmZpbml0eTtcbiAgICB2YXIgYmwgPSAwO1xuICAgIHZhciBhbCA9IDA7IC8vIGxpbmVhciBzY2FuIGZvciBjb2Fyc2UgYXBwcm94aW1hdGlvblxuXG4gICAgZm9yICh2YXIgc2Nhbiwgc2NhbkxlbiA9IDAsIHNjYW5EaXN0OyBzY2FuTGVuIDw9IHBhdGhMZW47IHNjYW5MZW4gKz0gcCkge1xuICAgICAgaWYgKChzY2FuRGlzdCA9IGRpc3RhbmNlMihzY2FuID0gcGF0aE5vZGUuZ2V0UG9pbnRBdExlbmd0aChzY2FuTGVuKSwgcG9pbnQpKSA8IGJlc3REaXN0KSB7XG4gICAgICAgIGJlc3QgPSBzY2FuO1xuICAgICAgICBiZXN0TGVuID0gc2NhbkxlbjtcbiAgICAgICAgYmVzdERpc3QgPSBzY2FuRGlzdDtcbiAgICAgIH1cbiAgICB9IC8vIGJpbmFyeSBzZWFyY2ggZm9yIHByZWNpc2UgZXN0aW1hdGVcblxuXG4gICAgcCAvPSAyO1xuXG4gICAgd2hpbGUgKHAgPiAwLjUpIHtcbiAgICAgIHZhciBiZWZvcmUgPSB2b2lkIDAsXG4gICAgICAgICAgYWZ0ZXIgPSB2b2lkIDAsXG4gICAgICAgICAgYmQgPSB2b2lkIDAsXG4gICAgICAgICAgYWQgPSB2b2lkIDA7XG5cbiAgICAgIGlmICgoYmwgPSBiZXN0TGVuIC0gcCkgPj0gMCAmJiAoYmQgPSBkaXN0YW5jZTIoYmVmb3JlID0gcGF0aE5vZGUuZ2V0UG9pbnRBdExlbmd0aChibCksIHBvaW50KSkgPCBiZXN0RGlzdCkge1xuICAgICAgICBiZXN0ID0gYmVmb3JlO1xuICAgICAgICBiZXN0TGVuID0gYmw7XG4gICAgICAgIGJlc3REaXN0ID0gYmQ7XG4gICAgICB9IGVsc2UgaWYgKChhbCA9IGJlc3RMZW4gKyBwKSA8PSBwYXRoTGVuICYmIChhZCA9IGRpc3RhbmNlMihhZnRlciA9IHBhdGhOb2RlLmdldFBvaW50QXRMZW5ndGgoYWwpLCBwb2ludCkpIDwgYmVzdERpc3QpIHtcbiAgICAgICAgYmVzdCA9IGFmdGVyO1xuICAgICAgICBiZXN0TGVuID0gYWw7XG4gICAgICAgIGJlc3REaXN0ID0gYWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwIC89IDI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBvaW50OiBbYmVzdC54LCBiZXN0LnldLFxuICAgICAgZGlzdGFuY2U6IGJlc3REaXN0LFxuICAgICAgbGVuZ3RoOiAoYmwgKyBhbCkgLyAyLFxuICAgICAgdDogKGJsICsgYWwpIC8gMiAvIHBhdGhMZW5cbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBVdGlscztcbn0oKTtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0gU3RhcnQgQ29weSBIZXJlIC0tLS0tLS0tLS0tLS0tLS0gKi9cblxuZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uKG1lc3NhZ2UpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBvaW50cyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgcG9pbnRzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHZhciBkaWRJbnRlcnNlY3QgPSBwb2ludHMubGVuZ3RoID4gMDtcbiAgcmV0dXJuIHtcbiAgICBkaWRJbnRlcnNlY3Q6IGRpZEludGVyc2VjdCxcbiAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgIHBvaW50czogcG9pbnRzXG4gIH07XG59XG5cbnZhciBJbnRlcnNlY3QgPSBmdW5jdGlvbiBJbnRlcnNlY3QoKSB7fTtcbkludGVyc2VjdC5yYXkgPSB7XG4gIC8vIEludGVyc2VjdCBhIHJheSB3aXRoIGEgcmF5LlxuICByYXk6IGZ1bmN0aW9uIHJheShwMCwgbjAsIHAxLCBuMSkge1xuICAgIHZhciBkeCA9IHAxWzBdIC0gcDBbMF07XG4gICAgdmFyIGR5ID0gcDFbMV0gLSBwMFsxXTtcbiAgICB2YXIgZGV0ID0gbjFbMF0gKiBuMFsxXSAtIG4xWzFdICogbjBbMF07XG4gICAgdmFyIHUgPSAoZHkgKiBuMVswXSAtIGR4ICogbjFbMV0pIC8gZGV0O1xuICAgIHZhciB2ID0gKGR5ICogbjBbMF0gLSBkeCAqIG4wWzFdKSAvIGRldDtcbiAgICBpZiAodSA8IDAgfHwgdiA8IDApIHJldHVybiBnZXRJbnRlcnNlY3Rpb24oJ21pc3MnKTtcbiAgICB2YXIgbTAgPSBuMFsxXSAvIG4wWzBdO1xuICAgIHZhciBtMSA9IG4xWzFdIC8gbjFbMF07XG4gICAgdmFyIGIwID0gcDBbMV0gLSBtMCAqIHAwWzBdO1xuICAgIHZhciBiMSA9IHAxWzFdIC0gbTEgKiBwMVswXTtcbiAgICB2YXIgeCA9IChiMSAtIGIwKSAvIChtMCAtIG0xKTtcbiAgICB2YXIgeSA9IG0wICogeCArIGIwO1xuICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUoeCkgPyBnZXRJbnRlcnNlY3Rpb24oJ2ludGVyc2VjdGlvbicsIFt4LCB5XSkgOiBnZXRJbnRlcnNlY3Rpb24oJ3BhcmFsbGVsJyk7XG4gIH0sXG4gIC8vIEludGVyc2VnIGEgcmF5IHdpdGggYSBsaW5lIHNlZ21lbnQuXG4gIGxpbmVTZWdtZW50OiBmdW5jdGlvbiBsaW5lU2VnbWVudChvcmlnaW4sIGRpcmVjdGlvbiwgYTEsIGEyKSB7XG4gICAgdmFyIHggPSBvcmlnaW5bMF0sXG4gICAgICAgIHkgPSBvcmlnaW5bMV07XG4gICAgdmFyIGR4ID0gZGlyZWN0aW9uWzBdLFxuICAgICAgICBkeSA9IGRpcmVjdGlvblsxXTtcbiAgICB2YXIgeDEgPSBhMVswXSxcbiAgICAgICAgeTEgPSBhMVsxXTtcbiAgICB2YXIgeDIgPSBhMlswXSxcbiAgICAgICAgeTIgPSBhMlsxXTtcblxuICAgIGlmIChkeSAvIGR4ICE9PSAoeTIgLSB5MSkgLyAoeDIgLSB4MSkpIHtcbiAgICAgIHZhciBkID0gZHggKiAoeTIgLSB5MSkgLSBkeSAqICh4MiAtIHgxKTtcblxuICAgICAgaWYgKGQgIT09IDApIHtcbiAgICAgICAgdmFyIHIgPSAoKHkgLSB5MSkgKiAoeDIgLSB4MSkgLSAoeCAtIHgxKSAqICh5MiAtIHkxKSkgLyBkO1xuICAgICAgICB2YXIgcyA9ICgoeSAtIHkxKSAqIGR4IC0gKHggLSB4MSkgKiBkeSkgLyBkO1xuXG4gICAgICAgIGlmIChyID49IDAgJiYgcyA+PSAwICYmIHMgPD0gMSkge1xuICAgICAgICAgIHJldHVybiBnZXRJbnRlcnNlY3Rpb24oJ2ludGVyc2VjdGlvbicsIFt4ICsgciAqIGR4LCB5ICsgciAqIGR5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0SW50ZXJzZWN0aW9uKCdubyBpbnRlcnNlY3Rpb24nKTtcbiAgfSxcbiAgLy8gSW50ZXJzZWN0IGEgcmF5IHdpdGggYSByZWN0YW5nbGUuXG4gIHJlY3RhbmdsZTogZnVuY3Rpb24gcmVjdGFuZ2xlKG9yaWdpbiwgZGlyZWN0aW9uLCBwb2ludCwgc2l6ZSkge1xuICAgIHJldHVybiBJbnRlcnNlY3QucmVjdGFuZ2xlLnJheShwb2ludCwgc2l6ZSwgb3JpZ2luLCBkaXJlY3Rpb24pO1xuICB9LFxuICAvLyBJbnRlcnNlY3QgYSByYXkgd2l0aCBhbiBlbGxpcHNlLlxuICBlbGxpcHNlOiBmdW5jdGlvbiBlbGxpcHNlKG9yaWdpbiwgZGlyZWN0aW9uLCBjZW50ZXIsIHJ4LCByeSwgcm90YXRpb24pIHtcbiAgICB2YXIgYTEgPSBvcmlnaW47XG4gICAgdmFyIGEyID0gVmVjLm11bChkaXJlY3Rpb24sIDk5OTk5OTk5OSk7XG4gICAgcmV0dXJuIEludGVyc2VjdC5saW5lU2VnbWVudC5lbGxpcHNlKGExLCBhMiwgY2VudGVyLCByeCwgcnksIHJvdGF0aW9uKTtcbiAgfSxcbiAgLy8gSW50ZXJzZWN0IGEgcmF5IHdpdGggYSBib3VuZGluZyBib3guXG4gIGJvdW5kczogZnVuY3Rpb24gYm91bmRzKG9yaWdpbiwgZGlyZWN0aW9uLCBfYm91bmRzKSB7XG4gICAgdmFyIG1pblggPSBfYm91bmRzLm1pblgsXG4gICAgICAgIG1pblkgPSBfYm91bmRzLm1pblksXG4gICAgICAgIHdpZHRoID0gX2JvdW5kcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX2JvdW5kcy5oZWlnaHQ7XG4gICAgcmV0dXJuIEludGVyc2VjdC5yYXkucmVjdGFuZ2xlKG9yaWdpbiwgZGlyZWN0aW9uLCBbbWluWCwgbWluWV0sIFt3aWR0aCwgaGVpZ2h0XSk7XG4gIH1cbn07XG5JbnRlcnNlY3QubGluZVNlZ21lbnQgPSB7XG4gIC8vIEludGVyc2VjdCBhIGxpbmUgc2VnbWVudCB3aXRoIGEgcmF5LlxuICByYXk6IGZ1bmN0aW9uIHJheShhMSwgYTIsIG9yaWdpbiwgZGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIEludGVyc2VjdC5yYXkubGluZVNlZ21lbnQob3JpZ2luLCBkaXJlY3Rpb24sIGExLCBhMik7XG4gIH0sXG4gIC8vIEludGVyc2VjdCBhIGxpbmUgc2VnbWVudCB3aXRoIGEgbGluZSBzZWdtZW50LlxuICBsaW5lU2VnbWVudDogZnVuY3Rpb24gbGluZVNlZ21lbnQoYTEsIGEyLCBiMSwgYjIpIHtcbiAgICB2YXIgQUIgPSBWZWMuc3ViKGExLCBiMSk7XG4gICAgdmFyIEJWID0gVmVjLnN1YihiMiwgYjEpO1xuICAgIHZhciBBViA9IFZlYy5zdWIoYTIsIGExKTtcbiAgICB2YXIgdWFfdCA9IEJWWzBdICogQUJbMV0gLSBCVlsxXSAqIEFCWzBdO1xuICAgIHZhciB1Yl90ID0gQVZbMF0gKiBBQlsxXSAtIEFWWzFdICogQUJbMF07XG4gICAgdmFyIHVfYiA9IEJWWzFdICogQVZbMF0gLSBCVlswXSAqIEFWWzFdO1xuXG4gICAgaWYgKHVhX3QgPT09IDAgfHwgdWJfdCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGdldEludGVyc2VjdGlvbignY29pbmNpZGVudCcpO1xuICAgIH1cblxuICAgIGlmICh1X2IgPT09IDApIHtcbiAgICAgIHJldHVybiBnZXRJbnRlcnNlY3Rpb24oJ3BhcmFsbGVsJyk7XG4gICAgfVxuXG4gICAgaWYgKHVfYiAhPT0gMCkge1xuICAgICAgdmFyIHVhID0gdWFfdCAvIHVfYjtcbiAgICAgIHZhciB1YiA9IHViX3QgLyB1X2I7XG5cbiAgICAgIGlmICgwIDw9IHVhICYmIHVhIDw9IDEgJiYgMCA8PSB1YiAmJiB1YiA8PSAxKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnRlcnNlY3Rpb24oJ2ludGVyc2VjdGlvbicsIFZlYy5hZGQoYTEsIFZlYy5tdWwoQVYsIHVhKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBnZXRJbnRlcnNlY3Rpb24oJ25vIGludGVyc2VjdGlvbicpO1xuICB9LFxuICAvLyBJbnRlcnNlY3QgYSBsaW5lIHNlZ21lbnQgd2l0aCBhIHJlY3RhbmdsZVxuICByZWN0YW5nbGU6IGZ1bmN0aW9uIHJlY3RhbmdsZShhMSwgYTIsIHBvaW50LCBzaXplKSB7XG4gICAgcmV0dXJuIEludGVyc2VjdC5yZWN0YW5nbGUubGluZVNlZ21lbnQocG9pbnQsIHNpemUsIGExLCBhMik7XG4gIH0sXG4gIC8vIEludGVyc2VjdCBhIGxpbmUgc2VnbWVudCB3aXRoIGFuIGFyYy5cbiAgYXJjOiBmdW5jdGlvbiBhcmMoYTEsIGEyLCBjZW50ZXIsIHJhZGl1cywgc3RhcnQsIGVuZCkge1xuICAgIHZhciBzYSA9IFZlYy5hbmdsZShjZW50ZXIsIHN0YXJ0KTtcbiAgICB2YXIgZWEgPSBWZWMuYW5nbGUoY2VudGVyLCBlbmQpO1xuICAgIHZhciBlbGxpcHNlVGVzdCA9IEludGVyc2VjdC5lbGxpcHNlLmxpbmVTZWdtZW50KGNlbnRlciwgcmFkaXVzLCByYWRpdXMsIDAsIGExLCBhMik7XG4gICAgaWYgKCFlbGxpcHNlVGVzdC5kaWRJbnRlcnNlY3QpIHJldHVybiBnZXRJbnRlcnNlY3Rpb24oJ05vIGludGVyc2VjdGlvbicpO1xuICAgIHZhciBwb2ludHMgPSBlbGxpcHNlVGVzdC5wb2ludHMuZmlsdGVyKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgcmV0dXJuIFV0aWxzLmlzQW5nbGVCZXR3ZWVuKHNhLCBlYSwgVmVjLmFuZ2xlKGNlbnRlciwgcG9pbnQpKTtcbiAgICB9KTtcblxuICAgIGlmIChwb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZ2V0SW50ZXJzZWN0aW9uKCdObyBpbnRlcnNlY3Rpb24nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0SW50ZXJzZWN0aW9uLmFwcGx5KHZvaWQgMCwgWydpbnRlcnNlY3Rpb24nXS5jb25jYXQocG9pbnRzKSk7XG4gIH0sXG4gIC8vIEludGVyc2VjdCBhIGxpbmUgc2VnbWVudCB3aXRoIGEgY2lyY2xlLlxuICBjaXJjbGU6IGZ1bmN0aW9uIGNpcmNsZShhMSwgYTIsIGMsIHIpIHtcbiAgICB2YXIgYSA9IChhMlswXSAtIGExWzBdKSAqIChhMlswXSAtIGExWzBdKSArIChhMlsxXSAtIGExWzFdKSAqIChhMlsxXSAtIGExWzFdKTtcbiAgICB2YXIgYiA9IDIgKiAoKGEyWzBdIC0gYTFbMF0pICogKGExWzBdIC0gY1swXSkgKyAoYTJbMV0gLSBhMVsxXSkgKiAoYTFbMV0gLSBjWzFdKSk7XG4gICAgdmFyIGNjID0gY1swXSAqIGNbMF0gKyBjWzFdICogY1sxXSArIGExWzBdICogYTFbMF0gKyBhMVsxXSAqIGExWzFdIC0gMiAqIChjWzBdICogYTFbMF0gKyBjWzFdICogYTFbMV0pIC0gciAqIHI7XG4gICAgdmFyIGRldGVyID0gYiAqIGIgLSA0ICogYSAqIGNjO1xuXG4gICAgaWYgKGRldGVyIDwgMCkge1xuICAgICAgcmV0dXJuIGdldEludGVyc2VjdGlvbignb3V0c2lkZScpO1xuICAgIH1cblxuICAgIGlmIChkZXRlciA9PT0gMCkge1xuICAgICAgcmV0dXJuIGdldEludGVyc2VjdGlvbigndGFuZ2VudCcpO1xuICAgIH1cblxuICAgIHZhciBlID0gTWF0aC5zcXJ0KGRldGVyKTtcbiAgICB2YXIgdTEgPSAoLWIgKyBlKSAvICgyICogYSk7XG4gICAgdmFyIHUyID0gKC1iIC0gZSkgLyAoMiAqIGEpO1xuXG4gICAgaWYgKCh1MSA8IDAgfHwgdTEgPiAxKSAmJiAodTIgPCAwIHx8IHUyID4gMSkpIHtcbiAgICAgIGlmICh1MSA8IDAgJiYgdTIgPCAwIHx8IHUxID4gMSAmJiB1MiA+IDEpIHtcbiAgICAgICAgcmV0dXJuIGdldEludGVyc2VjdGlvbignb3V0c2lkZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdldEludGVyc2VjdGlvbignaW5zaWRlJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBpZiAoMCA8PSB1MSAmJiB1MSA8PSAxKSByZXN1bHRzLnB1c2goVmVjLmxycChhMSwgYTIsIHUxKSk7XG4gICAgaWYgKDAgPD0gdTIgJiYgdTIgPD0gMSkgcmVzdWx0cy5wdXNoKFZlYy5scnAoYTEsIGEyLCB1MikpO1xuICAgIHJldHVybiBnZXRJbnRlcnNlY3Rpb24uYXBwbHkodm9pZCAwLCBbJ2ludGVyc2VjdGlvbiddLmNvbmNhdChyZXN1bHRzKSk7XG4gIH0sXG4gIC8vIEludGVyc2VjdCBhIGxpbmUgc2VnbWVudCB3aXRoIGFuIGVsbGlwc2UuXG4gIGVsbGlwc2U6IGZ1bmN0aW9uIGVsbGlwc2UoYTEsIGEyLCBjZW50ZXIsIHJ4LCByeSwgcm90YXRpb24pIHtcbiAgICBpZiAocm90YXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgcm90YXRpb24gPSAwO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBlbGxpcHNlIG9yIGxpbmUgc2VnbWVudCBhcmUgZW1wdHksIHJldHVybiBubyB0VmFsdWVzLlxuICAgIGlmIChyeCA9PT0gMCB8fCByeSA9PT0gMCB8fCBWZWMuaXNFcXVhbChhMSwgYTIpKSB7XG4gICAgICByZXR1cm4gZ2V0SW50ZXJzZWN0aW9uKCdObyBpbnRlcnNlY3Rpb24nKTtcbiAgICB9IC8vIEdldCB0aGUgc2VtaW1ham9yIGFuZCBzZW1pbWlub3IgYXhlcy5cblxuXG4gICAgcnggPSByeCA8IDAgPyByeCA6IC1yeDtcbiAgICByeSA9IHJ5IDwgMCA/IHJ5IDogLXJ5OyAvLyBSb3RhdGUgcG9pbnRzIGFuZCB0cmFuc2xhdGUgc28gdGhlIGVsbGlwc2UgaXMgY2VudGVyZWQgYXQgdGhlIG9yaWdpbi5cblxuICAgIGExID0gVmVjLnN1YihWZWMucm90V2l0aChhMSwgY2VudGVyLCAtcm90YXRpb24pLCBjZW50ZXIpO1xuICAgIGEyID0gVmVjLnN1YihWZWMucm90V2l0aChhMiwgY2VudGVyLCAtcm90YXRpb24pLCBjZW50ZXIpOyAvLyBDYWxjdWxhdGUgdGhlIHF1YWRyYXRpYyBwYXJhbWV0ZXJzLlxuXG4gICAgdmFyIGRpZmYgPSBWZWMuc3ViKGEyLCBhMSk7XG4gICAgdmFyIEEgPSBkaWZmWzBdICogZGlmZlswXSAvIHJ4IC8gcnggKyBkaWZmWzFdICogZGlmZlsxXSAvIHJ5IC8gcnk7XG4gICAgdmFyIEIgPSAyICogYTFbMF0gKiBkaWZmWzBdIC8gcnggLyByeCArIDIgKiBhMVsxXSAqIGRpZmZbMV0gLyByeSAvIHJ5O1xuICAgIHZhciBDID0gYTFbMF0gKiBhMVswXSAvIHJ4IC8gcnggKyBhMVsxXSAqIGExWzFdIC8gcnkgLyByeSAtIDE7IC8vIE1ha2UgYSBsaXN0IG9mIHQgdmFsdWVzIChub3JtYWxpemVkIHBvaW50cyBvbiB0aGUgbGluZSB3aGVyZSBpbnRlcnNlY3Rpb25zIG9jY3VyKS5cblxuICAgIHZhciB0VmFsdWVzID0gW107IC8vIENhbGN1bGF0ZSB0aGUgZGlzY3JpbWluYW50LlxuXG4gICAgdmFyIGRpc2NyaW1pbmFudCA9IEIgKiBCIC0gNCAqIEEgKiBDO1xuXG4gICAgaWYgKGRpc2NyaW1pbmFudCA9PT0gMCkge1xuICAgICAgLy8gT25lIHJlYWwgc29sdXRpb24uXG4gICAgICB0VmFsdWVzLnB1c2goLUIgLyAyIC8gQSk7XG4gICAgfSBlbHNlIGlmIChkaXNjcmltaW5hbnQgPiAwKSB7XG4gICAgICB2YXIgcm9vdCA9IE1hdGguc3FydChkaXNjcmltaW5hbnQpOyAvLyBUd28gcmVhbCBzb2x1dGlvbnMuXG5cbiAgICAgIHRWYWx1ZXMucHVzaCgoLUIgKyByb290KSAvIDIgLyBBKTtcbiAgICAgIHRWYWx1ZXMucHVzaCgoLUIgLSByb290KSAvIDIgLyBBKTtcbiAgICB9IC8vIEZpbHRlciB0byBvbmx5IHBvaW50cyB0aGF0IGFyZSBvbiB0aGUgc2VnbWVudC5cbiAgICAvLyBTb2x2ZSBmb3IgcG9pbnRzLCB0aGVuIGNvdW50ZXItcm90YXRlIHBvaW50cy5cblxuXG4gICAgdmFyIHBvaW50cyA9IHRWYWx1ZXMuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdCA+PSAwICYmIHQgPD0gMTtcbiAgICB9KS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiBWZWMuYWRkKGNlbnRlciwgVmVjLmFkZChhMSwgVmVjLm11bChWZWMuc3ViKGEyLCBhMSksIHQpKSk7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gVmVjLnJvdFdpdGgocCwgY2VudGVyLCByb3RhdGlvbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGdldEludGVyc2VjdGlvbi5hcHBseSh2b2lkIDAsIFsnaW50ZXJzZWN0aW9uJ10uY29uY2F0KHBvaW50cykpO1xuICB9LFxuICAvLyBJbnRlcnNlY3QgYSBsaW5lIHNlZ21lbnQgd2l0aCBhIGJvdW5kaW5nIGJveC5cbiAgYm91bmRzOiBmdW5jdGlvbiBib3VuZHMoYTEsIGEyLCBfYm91bmRzMikge1xuICAgIHJldHVybiBJbnRlcnNlY3QuYm91bmRzLmxpbmVTZWdtZW50KF9ib3VuZHMyLCBhMSwgYTIpO1xuICB9LFxuICAvLyBJbnRlcnNlY3QgYSBsaW5lIHNlZ21lbnQgd2l0aCBhIHBvbHlsaW5lXG4gIHBvbHlsaW5lOiBmdW5jdGlvbiBwb2x5bGluZShhMSwgYTIsIHBvaW50cykge1xuICAgIHZhciBpbnRlcnNlY3Rpb25zID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGggKyAxOyBpKyspIHtcbiAgICAgIHZhciBfaW50ID0gSW50ZXJzZWN0LmxpbmVTZWdtZW50LmxpbmVTZWdtZW50KGExLCBhMiwgcG9pbnRzW2kgLSAxXSwgcG9pbnRzW2kgJSBwb2ludHMubGVuZ3RoXSk7XG5cbiAgICAgIGlmIChfaW50KSB7XG4gICAgICAgIGludGVyc2VjdGlvbnMucHVzaChfaW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbiAgfVxufTtcbkludGVyc2VjdC5yZWN0YW5nbGUgPSB7XG4gIC8vIEludGVyc2VjdCBhIHJlY3RhbmdsZSB3aXRoIGEgcmF5LlxuICByYXk6IGZ1bmN0aW9uIHJheShwb2ludCwgc2l6ZSwgb3JpZ2luLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgc2lkZUludGVyc2VjdGlvbnMgPSBVdGlscy5nZXRSZWN0YW5nbGVTaWRlcyhwb2ludCwgc2l6ZSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIF9yZWYpIHtcbiAgICAgIHZhciBtZXNzYWdlID0gX3JlZlswXSxcbiAgICAgICAgICBfcmVmJCA9IF9yZWZbMV0sXG4gICAgICAgICAgYTEgPSBfcmVmJFswXSxcbiAgICAgICAgICBhMiA9IF9yZWYkWzFdO1xuICAgICAgdmFyIGludGVyc2VjdGlvbiA9IEludGVyc2VjdC5yYXkubGluZVNlZ21lbnQob3JpZ2luLCBkaXJlY3Rpb24sIGExLCBhMik7XG5cbiAgICAgIGlmIChpbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgYWNjLnB1c2goZ2V0SW50ZXJzZWN0aW9uLmFwcGx5KHZvaWQgMCwgW21lc3NhZ2VdLmNvbmNhdChpbnRlcnNlY3Rpb24ucG9pbnRzKSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gc2lkZUludGVyc2VjdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChfaW50Mikge1xuICAgICAgcmV0dXJuIF9pbnQyLmRpZEludGVyc2VjdDtcbiAgICB9KTtcbiAgfSxcbiAgLy8gSW50ZXJzZWN0IGEgcmVjdGFuZ2xlIHdpdGggYSBsaW5lIHNlZ21lbnQuXG4gIGxpbmVTZWdtZW50OiBmdW5jdGlvbiBsaW5lU2VnbWVudChwb2ludCwgc2l6ZSwgYTEsIGEyKSB7XG4gICAgdmFyIHNpZGVJbnRlcnNlY3Rpb25zID0gVXRpbHMuZ2V0UmVjdGFuZ2xlU2lkZXMocG9pbnQsIHNpemUpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBfcmVmMikge1xuICAgICAgdmFyIG1lc3NhZ2UgPSBfcmVmMlswXSxcbiAgICAgICAgICBfcmVmMiQgPSBfcmVmMlsxXSxcbiAgICAgICAgICBiMSA9IF9yZWYyJFswXSxcbiAgICAgICAgICBiMiA9IF9yZWYyJFsxXTtcbiAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBJbnRlcnNlY3QubGluZVNlZ21lbnQubGluZVNlZ21lbnQoYTEsIGEyLCBiMSwgYjIpO1xuXG4gICAgICBpZiAoaW50ZXJzZWN0aW9uKSB7XG4gICAgICAgIGFjYy5wdXNoKGdldEludGVyc2VjdGlvbi5hcHBseSh2b2lkIDAsIFttZXNzYWdlXS5jb25jYXQoaW50ZXJzZWN0aW9uLnBvaW50cykpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHNpZGVJbnRlcnNlY3Rpb25zLmZpbHRlcihmdW5jdGlvbiAoX2ludDMpIHtcbiAgICAgIHJldHVybiBfaW50My5kaWRJbnRlcnNlY3Q7XG4gICAgfSk7XG4gIH0sXG4gIC8vIEludGVyc2VjdCBhIHJlY3RhbmdsZSB3aXRoIGEgcmVjdGFuZ2xlLlxuICByZWN0YW5nbGU6IGZ1bmN0aW9uIHJlY3RhbmdsZShwb2ludDEsIHNpemUxLCBwb2ludDIsIHNpemUyKSB7XG4gICAgdmFyIHNpZGVJbnRlcnNlY3Rpb25zID0gVXRpbHMuZ2V0UmVjdGFuZ2xlU2lkZXMocG9pbnQxLCBzaXplMSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIF9yZWYzKSB7XG4gICAgICB2YXIgbWVzc2FnZSA9IF9yZWYzWzBdLFxuICAgICAgICAgIF9yZWYzJCA9IF9yZWYzWzFdLFxuICAgICAgICAgIGExID0gX3JlZjMkWzBdLFxuICAgICAgICAgIGEyID0gX3JlZjMkWzFdO1xuICAgICAgdmFyIGludGVyc2VjdGlvbnMgPSBJbnRlcnNlY3QucmVjdGFuZ2xlLmxpbmVTZWdtZW50KHBvaW50Miwgc2l6ZTIsIGExLCBhMik7XG4gICAgICBhY2MucHVzaC5hcHBseShhY2MsIGludGVyc2VjdGlvbnMubWFwKGZ1bmN0aW9uIChfaW50NCkge1xuICAgICAgICByZXR1cm4gZ2V0SW50ZXJzZWN0aW9uLmFwcGx5KHZvaWQgMCwgW21lc3NhZ2UgKyBcIiBcIiArIF9pbnQ0Lm1lc3NhZ2VdLmNvbmNhdChfaW50NC5wb2ludHMpKTtcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBzaWRlSW50ZXJzZWN0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKF9pbnQ1KSB7XG4gICAgICByZXR1cm4gX2ludDUuZGlkSW50ZXJzZWN0O1xuICAgIH0pO1xuICB9LFxuICAvLyBJbnRlcnNlY3QgYSByZWN0YW5nbGUgd2l0aCBhbiBhcmMuXG4gIGFyYzogZnVuY3Rpb24gYXJjKHBvaW50LCBzaXplLCBjZW50ZXIsIHJhZGl1cywgc3RhcnQsIGVuZCkge1xuICAgIHZhciBzaWRlSW50ZXJzZWN0aW9ucyA9IFV0aWxzLmdldFJlY3RhbmdsZVNpZGVzKHBvaW50LCBzaXplKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgX3JlZjQpIHtcbiAgICAgIHZhciBtZXNzYWdlID0gX3JlZjRbMF0sXG4gICAgICAgICAgX3JlZjQkID0gX3JlZjRbMV0sXG4gICAgICAgICAgYTEgPSBfcmVmNCRbMF0sXG4gICAgICAgICAgYTIgPSBfcmVmNCRbMV07XG4gICAgICB2YXIgaW50ZXJzZWN0aW9uID0gSW50ZXJzZWN0LmFyYy5saW5lU2VnbWVudChjZW50ZXIsIHJhZGl1cywgc3RhcnQsIGVuZCwgYTEsIGEyKTtcblxuICAgICAgaWYgKGludGVyc2VjdGlvbikge1xuICAgICAgICBhY2MucHVzaChfZXh0ZW5kcyh7fSwgaW50ZXJzZWN0aW9uLCB7XG4gICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBzaWRlSW50ZXJzZWN0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKF9pbnQ2KSB7XG4gICAgICByZXR1cm4gX2ludDYuZGlkSW50ZXJzZWN0O1xuICAgIH0pO1xuICB9LFxuICAvLyBJbnRlcnNlY3QgYSByZWN0YW5nbGUgd2l0aCBhIGNpcmNsZS5cbiAgY2lyY2xlOiBmdW5jdGlvbiBjaXJjbGUocG9pbnQsIHNpemUsIGMsIHIpIHtcbiAgICB2YXIgc2lkZUludGVyc2VjdGlvbnMgPSBVdGlscy5nZXRSZWN0YW5nbGVTaWRlcyhwb2ludCwgc2l6ZSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIF9yZWY1KSB7XG4gICAgICB2YXIgbWVzc2FnZSA9IF9yZWY1WzBdLFxuICAgICAgICAgIF9yZWY1JCA9IF9yZWY1WzFdLFxuICAgICAgICAgIGExID0gX3JlZjUkWzBdLFxuICAgICAgICAgIGEyID0gX3JlZjUkWzFdO1xuICAgICAgdmFyIGludGVyc2VjdGlvbiA9IEludGVyc2VjdC5saW5lU2VnbWVudC5jaXJjbGUoYTEsIGEyLCBjLCByKTtcblxuICAgICAgaWYgKGludGVyc2VjdGlvbikge1xuICAgICAgICBhY2MucHVzaChfZXh0ZW5kcyh7fSwgaW50ZXJzZWN0aW9uLCB7XG4gICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBzaWRlSW50ZXJzZWN0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKF9pbnQ3KSB7XG4gICAgICByZXR1cm4gX2ludDcuZGlkSW50ZXJzZWN0O1xuICAgIH0pO1xuICB9LFxuICAvLyBJbnRlcnNlY3QgYSByZWN0YW5nbGUgd2l0aCBhbiBlbGxpcHNlLlxuICBlbGxpcHNlOiBmdW5jdGlvbiBlbGxpcHNlKHBvaW50LCBzaXplLCBjLCByeCwgcnksIHJvdGF0aW9uKSB7XG4gICAgaWYgKHJvdGF0aW9uID09PSB2b2lkIDApIHtcbiAgICAgIHJvdGF0aW9uID0gMDtcbiAgICB9XG5cbiAgICB2YXIgc2lkZUludGVyc2VjdGlvbnMgPSBVdGlscy5nZXRSZWN0YW5nbGVTaWRlcyhwb2ludCwgc2l6ZSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIF9yZWY2KSB7XG4gICAgICB2YXIgbWVzc2FnZSA9IF9yZWY2WzBdLFxuICAgICAgICAgIF9yZWY2JCA9IF9yZWY2WzFdLFxuICAgICAgICAgIGExID0gX3JlZjYkWzBdLFxuICAgICAgICAgIGEyID0gX3JlZjYkWzFdO1xuICAgICAgdmFyIGludGVyc2VjdGlvbiA9IEludGVyc2VjdC5saW5lU2VnbWVudC5lbGxpcHNlKGExLCBhMiwgYywgcngsIHJ5LCByb3RhdGlvbik7XG5cbiAgICAgIGlmIChpbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgYWNjLnB1c2goX2V4dGVuZHMoe30sIGludGVyc2VjdGlvbiwge1xuICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gc2lkZUludGVyc2VjdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChfaW50OCkge1xuICAgICAgcmV0dXJuIF9pbnQ4LmRpZEludGVyc2VjdDtcbiAgICB9KTtcbiAgfSxcbiAgLy8gSW50ZXJzZWN0IGEgcmVjdGFuZ2xlIHdpdGggYSBib3VuZGluZyBib3guXG4gIGJvdW5kczogZnVuY3Rpb24gYm91bmRzKHBvaW50LCBzaXplLCBfYm91bmRzMykge1xuICAgIHZhciBtaW5YID0gX2JvdW5kczMubWluWCxcbiAgICAgICAgbWluWSA9IF9ib3VuZHMzLm1pblksXG4gICAgICAgIHdpZHRoID0gX2JvdW5kczMud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9ib3VuZHMzLmhlaWdodDtcbiAgICByZXR1cm4gSW50ZXJzZWN0LnJlY3RhbmdsZS5yZWN0YW5nbGUocG9pbnQsIHNpemUsIFttaW5YLCBtaW5ZXSwgW3dpZHRoLCBoZWlnaHRdKTtcbiAgfSxcbiAgLy8gSW50ZXJzZWN0IGEgcmVjdGFuZ2xlIHdpdGggYSBwb2x5bGluZVxuICBwb2x5bGluZTogZnVuY3Rpb24gcG9seWxpbmUocG9pbnQsIHNpemUsIHBvaW50cykge1xuICAgIHZhciBzaWRlSW50ZXJzZWN0aW9ucyA9IFV0aWxzLmdldFJlY3RhbmdsZVNpZGVzKHBvaW50LCBzaXplKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgX3JlZjcpIHtcbiAgICAgIHZhciBtZXNzYWdlID0gX3JlZjdbMF0sXG4gICAgICAgICAgX3JlZjckID0gX3JlZjdbMV0sXG4gICAgICAgICAgYTEgPSBfcmVmNyRbMF0sXG4gICAgICAgICAgYTIgPSBfcmVmNyRbMV07XG4gICAgICB2YXIgaW50ZXJzZWN0aW9ucyA9IEludGVyc2VjdC5saW5lU2VnbWVudC5wb2x5bGluZShhMSwgYTIsIHBvaW50cyk7XG5cbiAgICAgIGlmIChpbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYWNjLnB1c2goZ2V0SW50ZXJzZWN0aW9uLmFwcGx5KHZvaWQgMCwgW21lc3NhZ2VdLmNvbmNhdChpbnRlcnNlY3Rpb25zLmZsYXRNYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICByZXR1cm4gaS5wb2ludHM7XG4gICAgICAgIH0pKSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gc2lkZUludGVyc2VjdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChfaW50OSkge1xuICAgICAgcmV0dXJuIF9pbnQ5LmRpZEludGVyc2VjdDtcbiAgICB9KTtcbiAgfVxufTtcbkludGVyc2VjdC5hcmMgPSB7XG4gIC8vIEludGVyc2VjdCBhbiBhcmMgd2l0aCBhIGxpbmUgc2VnbWVudC5cbiAgbGluZVNlZ21lbnQ6IGZ1bmN0aW9uIGxpbmVTZWdtZW50KGNlbnRlciwgcmFkaXVzLCBzdGFydCwgZW5kLCBhMSwgYTIpIHtcbiAgICByZXR1cm4gSW50ZXJzZWN0LmxpbmVTZWdtZW50LmFyYyhhMSwgYTIsIGNlbnRlciwgcmFkaXVzLCBzdGFydCwgZW5kKTtcbiAgfSxcbiAgLy8gSW50ZXJzZWN0IGFuIGFyYyB3aXRoIGEgcmVjdGFuZ2xlLlxuICByZWN0YW5nbGU6IGZ1bmN0aW9uIHJlY3RhbmdsZShjZW50ZXIsIHJhZGl1cywgc3RhcnQsIGVuZCwgcG9pbnQsIHNpemUpIHtcbiAgICByZXR1cm4gSW50ZXJzZWN0LnJlY3RhbmdsZS5hcmMocG9pbnQsIHNpemUsIGNlbnRlciwgcmFkaXVzLCBzdGFydCwgZW5kKTtcbiAgfSxcbiAgLy8gSW50ZXJzZWN0IGFuIGFyYyB3aXRoIGEgYm91bmRpbmcgYm94LlxuICBib3VuZHM6IGZ1bmN0aW9uIGJvdW5kcyhjZW50ZXIsIHJhZGl1cywgc3RhcnQsIGVuZCwgX2JvdW5kczQpIHtcbiAgICB2YXIgbWluWCA9IF9ib3VuZHM0Lm1pblgsXG4gICAgICAgIG1pblkgPSBfYm91bmRzNC5taW5ZLFxuICAgICAgICB3aWR0aCA9IF9ib3VuZHM0LndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfYm91bmRzNC5oZWlnaHQ7XG4gICAgcmV0dXJuIEludGVyc2VjdC5hcmMucmVjdGFuZ2xlKGNlbnRlciwgcmFkaXVzLCBzdGFydCwgZW5kLCBbbWluWCwgbWluWV0sIFt3aWR0aCwgaGVpZ2h0XSk7XG4gIH1cbn07XG5JbnRlcnNlY3QuY2lyY2xlID0ge1xuICAvLyBJbnRlcnNlY3QgYSBjaXJjbGUgd2l0aCBhIGxpbmUgc2VnbWVudC5cbiAgbGluZVNlZ21lbnQ6IGZ1bmN0aW9uIGxpbmVTZWdtZW50KGMsIHIsIGExLCBhMikge1xuICAgIHJldHVybiBJbnRlcnNlY3QubGluZVNlZ21lbnQuY2lyY2xlKGExLCBhMiwgYywgcik7XG4gIH0sXG4gIC8vIEludGVyc2VjdCBhIGNpcmNsZSB3aXRoIGEgY2lyY2xlLlxuICBjaXJjbGU6IGZ1bmN0aW9uIGNpcmNsZShjMSwgcjEsIGMyLCByMikge1xuICAgIHZhciBkeCA9IGMyWzBdIC0gYzFbMF0sXG4gICAgICAgIGR5ID0gYzJbMV0gLSBjMVsxXTtcbiAgICB2YXIgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSksXG4gICAgICAgIHggPSAoZCAqIGQgLSByMiAqIHIyICsgcjEgKiByMSkgLyAoMiAqIGQpLFxuICAgICAgICB5ID0gTWF0aC5zcXJ0KHIxICogcjEgLSB4ICogeCk7XG4gICAgZHggLz0gZDtcbiAgICBkeSAvPSBkO1xuICAgIHJldHVybiBnZXRJbnRlcnNlY3Rpb24oJ2ludGVyc2VjdGlvbicsIFtjMVswXSArIGR4ICogeCAtIGR5ICogeSwgYzFbMV0gKyBkeSAqIHggKyBkeCAqIHldLCBbYzFbMF0gKyBkeCAqIHggKyBkeSAqIHksIGMxWzFdICsgZHkgKiB4IC0gZHggKiB5XSk7XG4gIH0sXG4gIC8vIEludGVyc2VjdCBhIGNpcmNsZSB3aXRoIGEgcmVjdGFuZ2xlLlxuICByZWN0YW5nbGU6IGZ1bmN0aW9uIHJlY3RhbmdsZShjLCByLCBwb2ludCwgc2l6ZSkge1xuICAgIHJldHVybiBJbnRlcnNlY3QucmVjdGFuZ2xlLmNpcmNsZShwb2ludCwgc2l6ZSwgYywgcik7XG4gIH0sXG4gIC8vIEludGVyc2VjdCBhIGNpcmNsZSB3aXRoIGEgYm91bmRpbmcgYm94LlxuICBib3VuZHM6IGZ1bmN0aW9uIGJvdW5kcyhjLCByLCBfYm91bmRzNSkge1xuICAgIHZhciBtaW5YID0gX2JvdW5kczUubWluWCxcbiAgICAgICAgbWluWSA9IF9ib3VuZHM1Lm1pblksXG4gICAgICAgIHdpZHRoID0gX2JvdW5kczUud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9ib3VuZHM1LmhlaWdodDtcbiAgICByZXR1cm4gSW50ZXJzZWN0LmNpcmNsZS5yZWN0YW5nbGUoYywgciwgW21pblgsIG1pblldLCBbd2lkdGgsIGhlaWdodF0pO1xuICB9XG59O1xuSW50ZXJzZWN0LmVsbGlwc2UgPSB7XG4gIC8vIEludGVyc2VjdCBhbiBlbGxpcHNlIHdpdGggYSByYXkuXG4gIHJheTogZnVuY3Rpb24gcmF5KGNlbnRlciwgcngsIHJ5LCByb3RhdGlvbiwgcG9pbnQsIGRpcmVjdGlvbikge1xuICAgIHJldHVybiBJbnRlcnNlY3QucmF5LmVsbGlwc2UocG9pbnQsIGRpcmVjdGlvbiwgY2VudGVyLCByeCwgcnksIHJvdGF0aW9uKTtcbiAgfSxcbiAgLy8gSW50ZXJzZWN0IGFuIGVsbGlwc2Ugd2l0aCBhIGxpbmUgc2VnbWVudC5cbiAgbGluZVNlZ21lbnQ6IGZ1bmN0aW9uIGxpbmVTZWdtZW50KGNlbnRlciwgcngsIHJ5LCByb3RhdGlvbiwgYTEsIGEyKSB7XG4gICAgaWYgKHJvdGF0aW9uID09PSB2b2lkIDApIHtcbiAgICAgIHJvdGF0aW9uID0gMDtcbiAgICB9XG5cbiAgICBpZiAocnggPT09IHJ5KSB7XG4gICAgICByZXR1cm4gSW50ZXJzZWN0LmxpbmVTZWdtZW50LmNpcmNsZShhMSwgYTIsIGNlbnRlciwgcngpO1xuICAgIH1cblxuICAgIHJldHVybiBJbnRlcnNlY3QubGluZVNlZ21lbnQuZWxsaXBzZShhMSwgYTIsIGNlbnRlciwgcngsIHJ5LCByb3RhdGlvbik7XG4gIH0sXG4gIC8vIEludGVyc2VjdCBhbiBlbGxpcHNlIHdpdGggYSByZWN0YW5nbGUuXG4gIHJlY3RhbmdsZTogZnVuY3Rpb24gcmVjdGFuZ2xlKGNlbnRlciwgcngsIHJ5LCByb3RhdGlvbiwgcG9pbnQsIHNpemUpIHtcbiAgICBpZiAocm90YXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgcm90YXRpb24gPSAwO1xuICAgIH1cblxuICAgIGlmIChyeCA9PT0gcnkpIHtcbiAgICAgIHJldHVybiBJbnRlcnNlY3QucmVjdGFuZ2xlLmNpcmNsZShwb2ludCwgc2l6ZSwgY2VudGVyLCByeCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEludGVyc2VjdC5yZWN0YW5nbGUuZWxsaXBzZShwb2ludCwgc2l6ZSwgY2VudGVyLCByeCwgcnksIHJvdGF0aW9uKTtcbiAgfSxcbiAgLy8gR2V0IGFuIGludGVyc2VjdGlvbiBiZXR3ZWVuIGFuIGVsbGlwc2UgYW5kIGEgc2Vjb25kIGVsbGlwc2UuXG4gIC8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9kcmF3YWJsZS85Mjc5MmY1OWI2ZmY4ODY5ZDhiMVxuICBlbGxpcHNlOiBmdW5jdGlvbiBlbGxpcHNlKF9jMSwgX3J4MSwgX3J5MSwgX3IxLCBfYzIsIF9yeDIsIF9yeTIsIF9yMikge1xuICAgIC8vIFRPRE9cbiAgICByZXR1cm4gZ2V0SW50ZXJzZWN0aW9uKCdubyBpbnRlcnNlY3Rpb24nKTtcbiAgfSxcbiAgY2lyY2xlOiBmdW5jdGlvbiBjaXJjbGUoYywgcngsIHJ5LCByb3RhdGlvbiwgYzIsIHIyKSB7XG4gICAgcmV0dXJuIEludGVyc2VjdC5lbGxpcHNlLmVsbGlwc2UoYywgcngsIHJ5LCByb3RhdGlvbiwgYzIsIHIyLCByMiwgMCk7XG4gIH0sXG4gIC8vIEludGVyc2VjdCBhbiBlbGxpcHNlIHdpdGggYSBib3VuZGluZyBib3guXG4gIGJvdW5kczogZnVuY3Rpb24gYm91bmRzKGMsIHJ4LCByeSwgcm90YXRpb24sIF9ib3VuZHM2KSB7XG4gICAgdmFyIG1pblggPSBfYm91bmRzNi5taW5YLFxuICAgICAgICBtaW5ZID0gX2JvdW5kczYubWluWSxcbiAgICAgICAgd2lkdGggPSBfYm91bmRzNi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX2JvdW5kczYuaGVpZ2h0O1xuICAgIHJldHVybiBJbnRlcnNlY3QuZWxsaXBzZS5yZWN0YW5nbGUoYywgcngsIHJ5LCByb3RhdGlvbiwgW21pblgsIG1pblldLCBbd2lkdGgsIGhlaWdodF0pO1xuICB9XG59O1xuSW50ZXJzZWN0LmJvdW5kcyA9IHtcbiAgcmF5OiBmdW5jdGlvbiByYXkoYm91bmRzLCBvcmlnaW4sIGRpcmVjdGlvbikge1xuICAgIHZhciBtaW5YID0gYm91bmRzLm1pblgsXG4gICAgICAgIG1pblkgPSBib3VuZHMubWluWSxcbiAgICAgICAgd2lkdGggPSBib3VuZHMud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IGJvdW5kcy5oZWlnaHQ7XG4gICAgcmV0dXJuIEludGVyc2VjdC5yYXkucmVjdGFuZ2xlKG9yaWdpbiwgZGlyZWN0aW9uLCBbbWluWCwgbWluWV0sIFt3aWR0aCwgaGVpZ2h0XSk7XG4gIH0sXG4gIGxpbmVTZWdtZW50OiBmdW5jdGlvbiBsaW5lU2VnbWVudChib3VuZHMsIGExLCBhMikge1xuICAgIHZhciBtaW5YID0gYm91bmRzLm1pblgsXG4gICAgICAgIG1pblkgPSBib3VuZHMubWluWSxcbiAgICAgICAgd2lkdGggPSBib3VuZHMud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IGJvdW5kcy5oZWlnaHQ7XG4gICAgcmV0dXJuIEludGVyc2VjdC5saW5lU2VnbWVudC5yZWN0YW5nbGUoYTEsIGEyLCBbbWluWCwgbWluWV0sIFt3aWR0aCwgaGVpZ2h0XSk7XG4gIH0sXG4gIHJlY3RhbmdsZTogZnVuY3Rpb24gcmVjdGFuZ2xlKGJvdW5kcywgcG9pbnQsIHNpemUpIHtcbiAgICB2YXIgbWluWCA9IGJvdW5kcy5taW5YLFxuICAgICAgICBtaW5ZID0gYm91bmRzLm1pblksXG4gICAgICAgIHdpZHRoID0gYm91bmRzLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBib3VuZHMuaGVpZ2h0O1xuICAgIHJldHVybiBJbnRlcnNlY3QucmVjdGFuZ2xlLnJlY3RhbmdsZShwb2ludCwgc2l6ZSwgW21pblgsIG1pblldLCBbd2lkdGgsIGhlaWdodF0pO1xuICB9LFxuICBib3VuZHM6IGZ1bmN0aW9uIGJvdW5kcyhib3VuZHMxLCBib3VuZHMyKSB7XG4gICAgcmV0dXJuIEludGVyc2VjdC5yZWN0YW5nbGUucmVjdGFuZ2xlKFtib3VuZHMxLm1pblgsIGJvdW5kczEubWluWV0sIFtib3VuZHMxLndpZHRoLCBib3VuZHMxLmhlaWdodF0sIFtib3VuZHMyLm1pblgsIGJvdW5kczIubWluWV0sIFtib3VuZHMyLndpZHRoLCBib3VuZHMyLmhlaWdodF0pO1xuICB9LFxuICBhcmM6IGZ1bmN0aW9uIGFyYyhib3VuZHMsIGNlbnRlciwgcmFkaXVzLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIG1pblggPSBib3VuZHMubWluWCxcbiAgICAgICAgbWluWSA9IGJvdW5kcy5taW5ZLFxuICAgICAgICB3aWR0aCA9IGJvdW5kcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gYm91bmRzLmhlaWdodDtcbiAgICByZXR1cm4gSW50ZXJzZWN0LmFyYy5yZWN0YW5nbGUoY2VudGVyLCByYWRpdXMsIHN0YXJ0LCBlbmQsIFttaW5YLCBtaW5ZXSwgW3dpZHRoLCBoZWlnaHRdKTtcbiAgfSxcbiAgY2lyY2xlOiBmdW5jdGlvbiBjaXJjbGUoYm91bmRzLCBjLCByKSB7XG4gICAgdmFyIG1pblggPSBib3VuZHMubWluWCxcbiAgICAgICAgbWluWSA9IGJvdW5kcy5taW5ZLFxuICAgICAgICB3aWR0aCA9IGJvdW5kcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gYm91bmRzLmhlaWdodDtcbiAgICByZXR1cm4gSW50ZXJzZWN0LmNpcmNsZS5yZWN0YW5nbGUoYywgciwgW21pblgsIG1pblldLCBbd2lkdGgsIGhlaWdodF0pO1xuICB9LFxuICBlbGxpcHNlOiBmdW5jdGlvbiBlbGxpcHNlKGJvdW5kcywgYywgcngsIHJ5LCByb3RhdGlvbikge1xuICAgIGlmIChyb3RhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICByb3RhdGlvbiA9IDA7XG4gICAgfVxuXG4gICAgdmFyIG1pblggPSBib3VuZHMubWluWCxcbiAgICAgICAgbWluWSA9IGJvdW5kcy5taW5ZLFxuICAgICAgICB3aWR0aCA9IGJvdW5kcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gYm91bmRzLmhlaWdodDtcbiAgICByZXR1cm4gSW50ZXJzZWN0LmVsbGlwc2UucmVjdGFuZ2xlKGMsIHJ4LCByeSwgcm90YXRpb24sIFttaW5YLCBtaW5ZXSwgW3dpZHRoLCBoZWlnaHRdKTtcbiAgfSxcbiAgcG9seWxpbmU6IGZ1bmN0aW9uIHBvbHlsaW5lKGJvdW5kcywgcG9pbnRzKSB7XG4gICAgcmV0dXJuIEludGVyc2VjdC5wb2x5bGluZS5ib3VuZHMocG9pbnRzLCBib3VuZHMpO1xuICB9XG59O1xuSW50ZXJzZWN0LnBvbHlsaW5lID0ge1xuICAvLyBJbnRlcnNlY3QgYSBwb2x5bGluZSB3aXRoIGEgbGluZSBzZWdtZW50LlxuICBsaW5lU2VnbWVudDogZnVuY3Rpb24gbGluZVNlZ21lbnQocG9pbnRzLCBhMSwgYTIpIHtcbiAgICByZXR1cm4gSW50ZXJzZWN0LmxpbmVTZWdtZW50LnBvbHlsaW5lKGExLCBhMiwgcG9pbnRzKTtcbiAgfSxcbiAgLy8gSW50ZXJlc2N0IGEgcG9seWxpbmUgd2l0aCBhIHJlY3RhbmdsZS5cbiAgcmVjdGFuZ2xlOiBmdW5jdGlvbiByZWN0YW5nbGUocG9pbnRzLCBwb2ludCwgc2l6ZSkge1xuICAgIHJldHVybiBJbnRlcnNlY3QucmVjdGFuZ2xlLnBvbHlsaW5lKHBvaW50LCBzaXplLCBwb2ludHMpO1xuICB9LFxuICAvLyBJbnRlcnNlY3QgYSBwb2x5bGluZSB3aXRoIGEgYm91bmRpbmcgYm94LlxuICBib3VuZHM6IGZ1bmN0aW9uIGJvdW5kcyhwb2ludHMsIF9ib3VuZHM3KSB7XG4gICAgcmV0dXJuIEludGVyc2VjdC5yZWN0YW5nbGUucG9seWxpbmUoW19ib3VuZHM3Lm1pblgsIF9ib3VuZHM3Lm1pblldLCBbX2JvdW5kczcud2lkdGgsIF9ib3VuZHM3LmhlaWdodF0sIHBvaW50cyk7XG4gIH1cbn07XG5cbnZhciBTdmcgPSBmdW5jdGlvbiBTdmcoKSB7fTtcblxuU3ZnLmVsbGlwc2UgPSBmdW5jdGlvbiAoQSwgcikge1xuICByZXR1cm4gXCJNIFwiICsgKEFbMF0gLSByKSArIFwiLFwiICsgQVsxXSArIFwiXFxuICAgICAgYSBcIiArIHIgKyBcIixcIiArIHIgKyBcIiAwIDEsMCBcIiArIHIgKiAyICsgXCIsMFxcbiAgICAgIGEgXCIgKyByICsgXCIsXCIgKyByICsgXCIgMCAxLDAgLVwiICsgciAqIDIgKyBcIiwwIFwiO1xufTtcblxuU3ZnLm1vdmVUbyA9IGZ1bmN0aW9uICh2KSB7XG4gIHJldHVybiBcIk0gXCIgKyB2WzBdICsgXCIsXCIgKyB2WzFdICsgXCIgXCI7XG59O1xuXG5TdmcubGluZVRvID0gZnVuY3Rpb24gKHYpIHtcbiAgcmV0dXJuIFwiTCBcIiArIHZbMF0gKyBcIixcIiArIHZbMV0gKyBcIiBcIjtcbn07XG5cblN2Zy5saW5lID0gZnVuY3Rpb24gKGEpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHB0cyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgcHRzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBTdmcubW92ZVRvKGEpICsgcHRzLm1hcChmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBTdmcubGluZVRvKHApO1xuICB9KS5qb2luKCk7XG59O1xuXG5TdmcuaExpbmVUbyA9IGZ1bmN0aW9uICh2KSB7XG4gIHJldHVybiBcIkggXCIgKyB2WzBdICsgXCIsXCIgKyB2WzFdICsgXCIgXCI7XG59O1xuXG5TdmcudkxpbmVUbyA9IGZ1bmN0aW9uICh2KSB7XG4gIHJldHVybiBcIlYgXCIgKyB2WzBdICsgXCIsXCIgKyB2WzFdICsgXCIgXCI7XG59O1xuXG5TdmcuYmV6aWVyVG8gPSBmdW5jdGlvbiAoQSwgQiwgQykge1xuICByZXR1cm4gXCJDIFwiICsgQVswXSArIFwiLFwiICsgQVsxXSArIFwiIFwiICsgQlswXSArIFwiLFwiICsgQlsxXSArIFwiIFwiICsgQ1swXSArIFwiLFwiICsgQ1sxXSArIFwiIFwiO1xufTtcblxuU3ZnLmFyY1RvID0gZnVuY3Rpb24gKEMsIHIsIEEsIEIpIHtcbiAgcmV0dXJuIFtTdmcubW92ZVRvKEEpLCAnQScsIHIsIHIsIDAsIFV0aWxzLmdldFN3ZWVwKEMsIEEsIEIpID4gMCA/ICcxJyA6ICcwJywgMCwgQlswXSwgQlsxXV0uam9pbignICcpO1xufTtcblxuU3ZnLmNsb3NlUGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICdaJztcbn07XG5cblN2Zy5yZWN0VG8gPSBmdW5jdGlvbiAoQSkge1xuICByZXR1cm4gWydSJywgQVswXSwgQVsxXV0uam9pbignICcpO1xufTtcblxuU3ZnLmdldFBvaW50QXRMZW5ndGggPSBmdW5jdGlvbiAocGF0aCwgbGVuZ3RoKSB7XG4gIHZhciBwb2ludCA9IHBhdGguZ2V0UG9pbnRBdExlbmd0aChsZW5ndGgpO1xuICByZXR1cm4gW3BvaW50LngsIHBvaW50LnldO1xufTtcblxudmFyIERPVUJMRV9DTElDS19EVVJBVElPTiA9IDI1MDtcblxudmFyIElucHV0cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIElucHV0cygpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5wb2ludGVyID0gdm9pZCAwO1xuICAgIHRoaXMua2V5Ym9hcmQgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXlzID0ge307XG4gICAgdGhpcy5wb2ludGVyVXBUaW1lID0gMDtcblxuICAgIHRoaXMucGFuU3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIF90aGlzJHBvaW50ZXIsIF90aGlzJHBvaW50ZXIyO1xuXG4gICAgICB2YXIgc2hpZnRLZXkgPSBlLnNoaWZ0S2V5LFxuICAgICAgICAgIGN0cmxLZXkgPSBlLmN0cmxLZXksXG4gICAgICAgICAgbWV0YUtleSA9IGUubWV0YUtleSxcbiAgICAgICAgICBhbHRLZXkgPSBlLmFsdEtleTtcbiAgICAgIHZhciBpbmZvID0ge1xuICAgICAgICB0YXJnZXQ6ICd3aGVlbCcsXG4gICAgICAgIHBvaW50ZXJJZDogKChfdGhpcyRwb2ludGVyID0gX3RoaXMucG9pbnRlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHBvaW50ZXIucG9pbnRlcklkKSB8fCAwLFxuICAgICAgICBvcmlnaW46ICgoX3RoaXMkcG9pbnRlcjIgPSBfdGhpcy5wb2ludGVyKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcG9pbnRlcjIub3JpZ2luKSB8fCBbMCwgMF0sXG4gICAgICAgIGRlbHRhOiBbMCwgMF0sXG4gICAgICAgIHByZXNzdXJlOiAwLjUsXG4gICAgICAgIHBvaW50OiBJbnB1dHMuZ2V0UG9pbnQoZSksXG4gICAgICAgIHNoaWZ0S2V5OiBzaGlmdEtleSxcbiAgICAgICAgY3RybEtleTogY3RybEtleSxcbiAgICAgICAgbWV0YUtleTogbWV0YUtleSxcbiAgICAgICAgYWx0S2V5OiBhbHRLZXlcbiAgICAgIH07XG4gICAgICBfdGhpcy5wb2ludGVyID0gaW5mbztcbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH07XG5cbiAgICB0aGlzLnBhbiA9IGZ1bmN0aW9uIChkZWx0YSwgZSkge1xuICAgICAgaWYgKCFfdGhpcy5wb2ludGVyIHx8IF90aGlzLnBvaW50ZXIudGFyZ2V0ICE9PSAnd2hlZWwnKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5wYW5TdGFydChlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNoaWZ0S2V5ID0gZS5zaGlmdEtleSxcbiAgICAgICAgICBjdHJsS2V5ID0gZS5jdHJsS2V5LFxuICAgICAgICAgIG1ldGFLZXkgPSBlLm1ldGFLZXksXG4gICAgICAgICAgYWx0S2V5ID0gZS5hbHRLZXk7XG4gICAgICB2YXIgcHJldiA9IF90aGlzLnBvaW50ZXI7XG4gICAgICB2YXIgcG9pbnQgPSBJbnB1dHMuZ2V0UG9pbnQoZSk7XG5cbiAgICAgIHZhciBpbmZvID0gX2V4dGVuZHMoe30sIHByZXYsIHtcbiAgICAgICAgdGFyZ2V0OiAnd2hlZWwnLFxuICAgICAgICBkZWx0YTogZGVsdGEsXG4gICAgICAgIHBvaW50OiBWZWMuc3ViKHBvaW50LCBkZWx0YSksXG4gICAgICAgIHNoaWZ0S2V5OiBzaGlmdEtleSxcbiAgICAgICAgY3RybEtleTogY3RybEtleSxcbiAgICAgICAgbWV0YUtleTogbWV0YUtleSxcbiAgICAgICAgYWx0S2V5OiBhbHRLZXlcbiAgICAgIH0pO1xuXG4gICAgICBfdGhpcy5wb2ludGVyID0gaW5mbztcbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH07XG5cbiAgICB0aGlzLmNhbkFjY2VwdCA9IGZ1bmN0aW9uIChfcG9pbnRlcklkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gICByZXR1cm4gKFxuICAgICAgLy8gICAgIHRoaXMuYWN0aXZlUG9pbnRlcklkID09PSB1bmRlZmluZWQgfHwgdGhpcy5hY3RpdmVQb2ludGVySWQgPT09IHBvaW50ZXJJZFxuICAgICAgLy8gICApXG4gICAgfTtcblxuICAgIHRoaXMua2V5ZG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgX3RoaXMkcG9pbnRlcjMsIF90aGlzJHBvaW50ZXI0O1xuXG4gICAgICB2YXIgc2hpZnRLZXkgPSBlLnNoaWZ0S2V5LFxuICAgICAgICAgIGN0cmxLZXkgPSBlLmN0cmxLZXksXG4gICAgICAgICAgbWV0YUtleSA9IGUubWV0YUtleSxcbiAgICAgICAgICBhbHRLZXkgPSBlLmFsdEtleTtcbiAgICAgIF90aGlzLmtleXNbZS5rZXldID0gdHJ1ZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvaW50OiAoKF90aGlzJHBvaW50ZXIzID0gX3RoaXMucG9pbnRlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHBvaW50ZXIzLnBvaW50KSB8fCBbMCwgMF0sXG4gICAgICAgIG9yaWdpbjogKChfdGhpcyRwb2ludGVyNCA9IF90aGlzLnBvaW50ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRwb2ludGVyNC5vcmlnaW4pIHx8IFswLCAwXSxcbiAgICAgICAga2V5OiBlLmtleSxcbiAgICAgICAga2V5czogT2JqZWN0LmtleXMoX3RoaXMua2V5cyksXG4gICAgICAgIHNoaWZ0S2V5OiBzaGlmdEtleSxcbiAgICAgICAgY3RybEtleTogY3RybEtleSxcbiAgICAgICAgbWV0YUtleTogVXRpbHMuaXNEYXJ3aW4oKSA/IG1ldGFLZXkgOiBjdHJsS2V5LFxuICAgICAgICBhbHRLZXk6IGFsdEtleVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdGhpcy5rZXl1cCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgX3RoaXMkcG9pbnRlcjUsIF90aGlzJHBvaW50ZXI2O1xuXG4gICAgICB2YXIgc2hpZnRLZXkgPSBlLnNoaWZ0S2V5LFxuICAgICAgICAgIGN0cmxLZXkgPSBlLmN0cmxLZXksXG4gICAgICAgICAgbWV0YUtleSA9IGUubWV0YUtleSxcbiAgICAgICAgICBhbHRLZXkgPSBlLmFsdEtleTtcbiAgICAgIGRlbGV0ZSBfdGhpcy5rZXlzW2Uua2V5XTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvaW50OiAoKF90aGlzJHBvaW50ZXI1ID0gX3RoaXMucG9pbnRlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHBvaW50ZXI1LnBvaW50KSB8fCBbMCwgMF0sXG4gICAgICAgIG9yaWdpbjogKChfdGhpcyRwb2ludGVyNiA9IF90aGlzLnBvaW50ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRwb2ludGVyNi5vcmlnaW4pIHx8IFswLCAwXSxcbiAgICAgICAga2V5OiBlLmtleSxcbiAgICAgICAga2V5czogT2JqZWN0LmtleXMoX3RoaXMua2V5cyksXG4gICAgICAgIHNoaWZ0S2V5OiBzaGlmdEtleSxcbiAgICAgICAgY3RybEtleTogY3RybEtleSxcbiAgICAgICAgbWV0YUtleTogVXRpbHMuaXNEYXJ3aW4oKSA/IG1ldGFLZXkgOiBjdHJsS2V5LFxuICAgICAgICBhbHRLZXk6IGFsdEtleVxuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIF9wcm90byA9IElucHV0cy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnRvdWNoU3RhcnQgPSBmdW5jdGlvbiB0b3VjaFN0YXJ0KGUsIHRhcmdldCkge1xuICAgIHZhciBzaGlmdEtleSA9IGUuc2hpZnRLZXksXG4gICAgICAgIGN0cmxLZXkgPSBlLmN0cmxLZXksXG4gICAgICAgIG1ldGFLZXkgPSBlLm1ldGFLZXksXG4gICAgICAgIGFsdEtleSA9IGUuYWx0S2V5O1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgdG91Y2ggPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgIHZhciBpbmZvID0ge1xuICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICBwb2ludGVySWQ6IHRvdWNoLmlkZW50aWZpZXIsXG4gICAgICBvcmlnaW46IElucHV0cy5nZXRQb2ludCh0b3VjaCksXG4gICAgICBkZWx0YTogWzAsIDBdLFxuICAgICAgcG9pbnQ6IElucHV0cy5nZXRQb2ludCh0b3VjaCksXG4gICAgICBwcmVzc3VyZTogSW5wdXRzLmdldFByZXNzdXJlKHRvdWNoKSxcbiAgICAgIHNoaWZ0S2V5OiBzaGlmdEtleSxcbiAgICAgIGN0cmxLZXk6IGN0cmxLZXksXG4gICAgICBtZXRhS2V5OiBVdGlscy5pc0RhcndpbigpID8gbWV0YUtleSA6IGN0cmxLZXksXG4gICAgICBhbHRLZXk6IGFsdEtleVxuICAgIH07XG4gICAgdGhpcy5wb2ludGVyID0gaW5mbztcbiAgICByZXR1cm4gaW5mbztcbiAgfTtcblxuICBfcHJvdG8udG91Y2hNb3ZlID0gZnVuY3Rpb24gdG91Y2hNb3ZlKGUsIHRhcmdldCkge1xuICAgIHZhciBzaGlmdEtleSA9IGUuc2hpZnRLZXksXG4gICAgICAgIGN0cmxLZXkgPSBlLmN0cmxLZXksXG4gICAgICAgIG1ldGFLZXkgPSBlLm1ldGFLZXksXG4gICAgICAgIGFsdEtleSA9IGUuYWx0S2V5O1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgdG91Y2ggPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgIHZhciBwcmV2ID0gdGhpcy5wb2ludGVyO1xuICAgIHZhciBwb2ludCA9IElucHV0cy5nZXRQb2ludCh0b3VjaCk7XG4gICAgdmFyIGRlbHRhID0gcHJldiAhPSBudWxsICYmIHByZXYucG9pbnQgPyBWZWMuc3ViKHBvaW50LCBwcmV2LnBvaW50KSA6IFswLCAwXTtcblxuICAgIHZhciBpbmZvID0gX2V4dGVuZHMoe1xuICAgICAgb3JpZ2luOiBwb2ludFxuICAgIH0sIHByZXYsIHtcbiAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgcG9pbnRlcklkOiB0b3VjaC5pZGVudGlmaWVyLFxuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgZGVsdGE6IGRlbHRhLFxuICAgICAgcHJlc3N1cmU6IElucHV0cy5nZXRQcmVzc3VyZSh0b3VjaCksXG4gICAgICBzaGlmdEtleTogc2hpZnRLZXksXG4gICAgICBjdHJsS2V5OiBjdHJsS2V5LFxuICAgICAgbWV0YUtleTogVXRpbHMuaXNEYXJ3aW4oKSA/IG1ldGFLZXkgOiBjdHJsS2V5LFxuICAgICAgYWx0S2V5OiBhbHRLZXlcbiAgICB9KTtcblxuICAgIHRoaXMucG9pbnRlciA9IGluZm87XG4gICAgcmV0dXJuIGluZm87XG4gIH07XG5cbiAgX3Byb3RvLnBvaW50ZXJEb3duID0gZnVuY3Rpb24gcG9pbnRlckRvd24oZSwgdGFyZ2V0KSB7XG4gICAgdmFyIHNoaWZ0S2V5ID0gZS5zaGlmdEtleSxcbiAgICAgICAgY3RybEtleSA9IGUuY3RybEtleSxcbiAgICAgICAgbWV0YUtleSA9IGUubWV0YUtleSxcbiAgICAgICAgYWx0S2V5ID0gZS5hbHRLZXk7XG4gICAgdmFyIHBvaW50ID0gSW5wdXRzLmdldFBvaW50KGUpO1xuICAgIHZhciBpbmZvID0ge1xuICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICBwb2ludGVySWQ6IGUucG9pbnRlcklkLFxuICAgICAgb3JpZ2luOiBwb2ludCxcbiAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgIGRlbHRhOiBbMCwgMF0sXG4gICAgICBwcmVzc3VyZTogSW5wdXRzLmdldFByZXNzdXJlKGUpLFxuICAgICAgc2hpZnRLZXk6IHNoaWZ0S2V5LFxuICAgICAgY3RybEtleTogY3RybEtleSxcbiAgICAgIG1ldGFLZXk6IFV0aWxzLmlzRGFyd2luKCkgPyBtZXRhS2V5IDogY3RybEtleSxcbiAgICAgIGFsdEtleTogYWx0S2V5XG4gICAgfTtcbiAgICB0aGlzLnBvaW50ZXIgPSBpbmZvO1xuICAgIHJldHVybiBpbmZvO1xuICB9O1xuXG4gIF9wcm90by5wb2ludGVyRW50ZXIgPSBmdW5jdGlvbiBwb2ludGVyRW50ZXIoZSwgdGFyZ2V0KSB7XG4gICAgdmFyIHNoaWZ0S2V5ID0gZS5zaGlmdEtleSxcbiAgICAgICAgY3RybEtleSA9IGUuY3RybEtleSxcbiAgICAgICAgbWV0YUtleSA9IGUubWV0YUtleSxcbiAgICAgICAgYWx0S2V5ID0gZS5hbHRLZXk7XG4gICAgdmFyIHBvaW50ID0gSW5wdXRzLmdldFBvaW50KGUpO1xuICAgIHZhciBpbmZvID0ge1xuICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICBwb2ludGVySWQ6IGUucG9pbnRlcklkLFxuICAgICAgb3JpZ2luOiBwb2ludCxcbiAgICAgIGRlbHRhOiBbMCwgMF0sXG4gICAgICBwb2ludDogcG9pbnQsXG4gICAgICBwcmVzc3VyZTogSW5wdXRzLmdldFByZXNzdXJlKGUpLFxuICAgICAgc2hpZnRLZXk6IHNoaWZ0S2V5LFxuICAgICAgY3RybEtleTogY3RybEtleSxcbiAgICAgIG1ldGFLZXk6IFV0aWxzLmlzRGFyd2luKCkgPyBtZXRhS2V5IDogY3RybEtleSxcbiAgICAgIGFsdEtleTogYWx0S2V5XG4gICAgfTtcbiAgICB0aGlzLnBvaW50ZXIgPSBpbmZvO1xuICAgIHJldHVybiBpbmZvO1xuICB9O1xuXG4gIF9wcm90by5wb2ludGVyTW92ZSA9IGZ1bmN0aW9uIHBvaW50ZXJNb3ZlKGUsIHRhcmdldCkge1xuICAgIHZhciBzaGlmdEtleSA9IGUuc2hpZnRLZXksXG4gICAgICAgIGN0cmxLZXkgPSBlLmN0cmxLZXksXG4gICAgICAgIG1ldGFLZXkgPSBlLm1ldGFLZXksXG4gICAgICAgIGFsdEtleSA9IGUuYWx0S2V5O1xuICAgIHZhciBwcmV2ID0gdGhpcy5wb2ludGVyO1xuICAgIHZhciBwb2ludCA9IElucHV0cy5nZXRQb2ludChlKTtcbiAgICB2YXIgZGVsdGEgPSBwcmV2ICE9IG51bGwgJiYgcHJldi5wb2ludCA/IFZlYy5zdWIocG9pbnQsIHByZXYucG9pbnQpIDogWzAsIDBdO1xuXG4gICAgdmFyIGluZm8gPSBfZXh0ZW5kcyh7XG4gICAgICBvcmlnaW46IHBvaW50XG4gICAgfSwgcHJldiwge1xuICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICBwb2ludGVySWQ6IGUucG9pbnRlcklkLFxuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgZGVsdGE6IGRlbHRhLFxuICAgICAgcHJlc3N1cmU6IElucHV0cy5nZXRQcmVzc3VyZShlKSxcbiAgICAgIHNoaWZ0S2V5OiBzaGlmdEtleSxcbiAgICAgIGN0cmxLZXk6IGN0cmxLZXksXG4gICAgICBtZXRhS2V5OiBVdGlscy5pc0RhcndpbigpID8gbWV0YUtleSA6IGN0cmxLZXksXG4gICAgICBhbHRLZXk6IGFsdEtleVxuICAgIH0pO1xuXG4gICAgdGhpcy5wb2ludGVyID0gaW5mbztcbiAgICByZXR1cm4gaW5mbztcbiAgfTtcblxuICBfcHJvdG8ucG9pbnRlclVwID0gZnVuY3Rpb24gcG9pbnRlclVwKGUsIHRhcmdldCkge1xuICAgIHZhciBzaGlmdEtleSA9IGUuc2hpZnRLZXksXG4gICAgICAgIGN0cmxLZXkgPSBlLmN0cmxLZXksXG4gICAgICAgIG1ldGFLZXkgPSBlLm1ldGFLZXksXG4gICAgICAgIGFsdEtleSA9IGUuYWx0S2V5O1xuICAgIHZhciBwcmV2ID0gdGhpcy5wb2ludGVyO1xuICAgIHZhciBwb2ludCA9IElucHV0cy5nZXRQb2ludChlKTtcbiAgICB2YXIgZGVsdGEgPSBwcmV2ICE9IG51bGwgJiYgcHJldi5wb2ludCA/IFZlYy5zdWIocG9pbnQsIHByZXYucG9pbnQpIDogWzAsIDBdO1xuXG4gICAgdmFyIGluZm8gPSBfZXh0ZW5kcyh7XG4gICAgICBvcmlnaW46IHBvaW50XG4gICAgfSwgcHJldiwge1xuICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICBwb2ludGVySWQ6IGUucG9pbnRlcklkLFxuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgZGVsdGE6IGRlbHRhLFxuICAgICAgcHJlc3N1cmU6IElucHV0cy5nZXRQcmVzc3VyZShlKSxcbiAgICAgIHNoaWZ0S2V5OiBzaGlmdEtleSxcbiAgICAgIGN0cmxLZXk6IGN0cmxLZXksXG4gICAgICBtZXRhS2V5OiBVdGlscy5pc0RhcndpbigpID8gbWV0YUtleSA6IGN0cmxLZXksXG4gICAgICBhbHRLZXk6IGFsdEtleVxuICAgIH0pO1xuXG4gICAgdGhpcy5wb2ludGVyID0gaW5mbztcbiAgICB0aGlzLnBvaW50ZXJVcFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHJldHVybiBpbmZvO1xuICB9O1xuXG4gIF9wcm90by5pc0RvdWJsZUNsaWNrID0gZnVuY3Rpb24gaXNEb3VibGVDbGljaygpIHtcbiAgICBpZiAoIXRoaXMucG9pbnRlcikgcmV0dXJuO1xuICAgIHZhciBfdGhpcyRwb2ludGVyNyA9IHRoaXMucG9pbnRlcixcbiAgICAgICAgb3JpZ2luID0gX3RoaXMkcG9pbnRlcjcub3JpZ2luLFxuICAgICAgICBwb2ludCA9IF90aGlzJHBvaW50ZXI3LnBvaW50O1xuICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGhpcy5wb2ludGVyVXBUaW1lIDwgRE9VQkxFX0NMSUNLX0RVUkFUSU9OICYmIFZlYy5kaXN0KG9yaWdpbiwgcG9pbnQpIDwgNDtcbiAgfTtcblxuICBfcHJvdG8uY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLnBvaW50ZXIgPSB1bmRlZmluZWQ7XG4gIH07XG5cbiAgX3Byb3RvLnJlc2V0RG91YmxlQ2xpY2sgPSBmdW5jdGlvbiByZXNldERvdWJsZUNsaWNrKCkge1xuICAgIHRoaXMucG9pbnRlclVwVGltZSA9IDA7XG4gIH07XG5cbiAgX3Byb3RvLnBpbmNoID0gZnVuY3Rpb24gcGluY2gocG9pbnQsIG9yaWdpbikge1xuICAgIHZhciBfdGhpcyRrZXlzID0gdGhpcy5rZXlzLFxuICAgICAgICBzaGlmdEtleSA9IF90aGlzJGtleXMuc2hpZnRLZXksXG4gICAgICAgIGN0cmxLZXkgPSBfdGhpcyRrZXlzLmN0cmxLZXksXG4gICAgICAgIG1ldGFLZXkgPSBfdGhpcyRrZXlzLm1ldGFLZXksXG4gICAgICAgIGFsdEtleSA9IF90aGlzJGtleXMuYWx0S2V5O1xuICAgIHZhciBwcmV2ID0gdGhpcy5wb2ludGVyO1xuICAgIHZhciBkZWx0YSA9IFZlYy5zdWIob3JpZ2luLCBwb2ludCk7XG4gICAgdmFyIGluZm8gPSB7XG4gICAgICBwb2ludGVySWQ6IDAsXG4gICAgICB0YXJnZXQ6ICdwaW5jaCcsXG4gICAgICBvcmlnaW46IChwcmV2ID09IG51bGwgPyB2b2lkIDAgOiBwcmV2Lm9yaWdpbikgfHwgVmVjLnJvdW5kKHBvaW50KSxcbiAgICAgIGRlbHRhOiBkZWx0YSxcbiAgICAgIHBvaW50OiBWZWMucm91bmQocG9pbnQpLFxuICAgICAgcHJlc3N1cmU6IDAuNSxcbiAgICAgIHNoaWZ0S2V5OiBzaGlmdEtleSxcbiAgICAgIGN0cmxLZXk6IGN0cmxLZXksXG4gICAgICBtZXRhS2V5OiBVdGlscy5pc0RhcndpbigpID8gbWV0YUtleSA6IGN0cmxLZXksXG4gICAgICBhbHRLZXk6IGFsdEtleVxuICAgIH07XG4gICAgdGhpcy5wb2ludGVyID0gaW5mbztcbiAgICByZXR1cm4gaW5mbztcbiAgfTtcblxuICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB0aGlzLnBvaW50ZXJVcFRpbWUgPSAwO1xuICAgIHRoaXMucG9pbnRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmtleWJvYXJkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMua2V5cyA9IHt9O1xuICB9O1xuXG4gIElucHV0cy5nZXRQb2ludCA9IGZ1bmN0aW9uIGdldFBvaW50KGUpIHtcbiAgICByZXR1cm4gW051bWJlcihlLmNsaWVudFgudG9QcmVjaXNpb24oNSkpLCBOdW1iZXIoZS5jbGllbnRZLnRvUHJlY2lzaW9uKDUpKV07XG4gIH07XG5cbiAgSW5wdXRzLmdldFByZXNzdXJlID0gZnVuY3Rpb24gZ2V0UHJlc3N1cmUoZSkge1xuICAgIHJldHVybiAncHJlc3N1cmUnIGluIGUgPyBOdW1iZXIoZS5wcmVzc3VyZS50b1ByZWNpc2lvbig1KSkgfHwgMC41IDogMC41O1xuICB9O1xuXG4gIElucHV0cy5jb21tYW5kS2V5ID0gZnVuY3Rpb24gY29tbWFuZEtleSgpIHtcbiAgICByZXR1cm4gVXRpbHMuaXNEYXJ3aW4oKSA/ICfijJgnIDogJ0N0cmwnO1xuICB9O1xuXG4gIHJldHVybiBJbnB1dHM7XG59KCk7XG5cbnZhciBpbnB1dHMgPSAvKiNfX1BVUkVfXyovbmV3IElucHV0cygpO1xuXG5mdW5jdGlvbiB1c2Vab29tRXZlbnRzKCkge1xuICB2YXIgclBpbmNoRGEgPSBSZWFjdC51c2VSZWYodW5kZWZpbmVkKTtcbiAgdmFyIHJQaW5jaFBvaW50ID0gUmVhY3QudXNlUmVmKHVuZGVmaW5lZCk7XG5cbiAgdmFyIF91c2VUTENvbnRleHQgPSB1c2VUTENvbnRleHQoKSxcbiAgICAgIGNhbGxiYWNrcyA9IF91c2VUTENvbnRleHQuY2FsbGJhY2tzO1xuXG4gIHJlYWN0VXNlR2VzdHVyZS51c2VHZXN0dXJlKHtcbiAgICBvbldoZWVsOiBmdW5jdGlvbiBvbldoZWVsKF9yZWYpIHtcbiAgICAgIHZhciBlID0gX3JlZi5ldmVudCxcbiAgICAgICAgICBkZWx0YSA9IF9yZWYuZGVsdGE7XG4gICAgICB2YXIgaW5mbyA9IGlucHV0cy5wYW4oZGVsdGEsIGUpO1xuXG4gICAgICBpZiAoZS5jdHJsS2V5KSB7XG4gICAgICAgIGNhbGxiYWNrcy5vblpvb20gPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vblpvb20oaW5mbywgZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cblxuXG4gICAgICBjYWxsYmFja3Mub25QYW4gPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vblBhbihpbmZvLCBlKTtcbiAgICB9LFxuICAgIG9uUGluY2g6IGZ1bmN0aW9uIG9uUGluY2goX3JlZjIpIHtcbiAgICAgIHZhciBwaW5jaGluZyA9IF9yZWYyLnBpbmNoaW5nLFxuICAgICAgICAgIGRhID0gX3JlZjIuZGEsXG4gICAgICAgICAgb3JpZ2luID0gX3JlZjIub3JpZ2luLFxuICAgICAgICAgIGUgPSBfcmVmMi5ldmVudDtcblxuICAgICAgaWYgKCFwaW5jaGluZykge1xuICAgICAgICB2YXIgX2luZm8gPSBpbnB1dHMucGluY2gob3JpZ2luLCBvcmlnaW4pO1xuXG4gICAgICAgIGNhbGxiYWNrcy5vblBpbmNoRW5kID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25QaW5jaEVuZChfaW5mbywgZSk7XG4gICAgICAgIHJQaW5jaERhLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJQaW5jaFBvaW50LmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHJQaW5jaFBvaW50LmN1cnJlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgX2luZm8yID0gaW5wdXRzLnBpbmNoKG9yaWdpbiwgb3JpZ2luKTtcblxuICAgICAgICBjYWxsYmFja3Mub25QaW5jaFN0YXJ0ID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25QaW5jaFN0YXJ0KF9pbmZvMiwgZSk7XG4gICAgICAgIHJQaW5jaERhLmN1cnJlbnQgPSBkYTtcbiAgICAgICAgclBpbmNoUG9pbnQuY3VycmVudCA9IG9yaWdpbjtcbiAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cblxuXG4gICAgICB2YXIgX1ZlYyRzdWIgPSBWZWMuc3ViKHJQaW5jaERhLmN1cnJlbnQsIGRhKSxcbiAgICAgICAgICBkaXN0YW5jZURlbHRhID0gX1ZlYyRzdWJbMF07XG5cbiAgICAgIHZhciBpbmZvID0gaW5wdXRzLnBpbmNoKHJQaW5jaFBvaW50LmN1cnJlbnQsIG9yaWdpbik7IC8vIE5hbWluZyB0aGluZ3MgaXMgaGFyZFxuXG4gICAgICBjYWxsYmFja3Mub25QaW5jaCA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uUGluY2goX2V4dGVuZHMoe30sIGluZm8sIHtcbiAgICAgICAgcG9pbnQ6IG9yaWdpbixcbiAgICAgICAgb3JpZ2luOiByUGluY2hQb2ludC5jdXJyZW50LFxuICAgICAgICBkZWx0YTogW10uY29uY2F0KGluZm8uZGVsdGEsIFtkaXN0YW5jZURlbHRhXSlcbiAgICAgIH0pLCBlKTtcbiAgICAgIHJQaW5jaERhLmN1cnJlbnQgPSBkYTtcbiAgICAgIHJQaW5jaFBvaW50LmN1cnJlbnQgPSBvcmlnaW47XG4gICAgfVxuICB9LCB7XG4gICAgZG9tVGFyZ2V0OiB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogZG9jdW1lbnQuYm9keSxcbiAgICBldmVudE9wdGlvbnM6IHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlU2FmYXJpRm9jdXNPdXRGaXgoKSB7XG4gIHZhciBfdXNlVExDb250ZXh0ID0gdXNlVExDb250ZXh0KCksXG4gICAgICBjYWxsYmFja3MgPSBfdXNlVExDb250ZXh0LmNhbGxiYWNrcztcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGhhbmRsZUZvY3VzT3V0KCkge1xuICAgICAgY2FsbGJhY2tzLm9uQmx1ckVkaXRpbmdTaGFwZSA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uQmx1ckVkaXRpbmdTaGFwZSgpO1xuICAgIH1cblxuICAgIGlmICghVXRpbHMuaXNNb2JpbGUoKSkgcmV0dXJuO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgaGFuZGxlRm9jdXNPdXQpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBoYW5kbGVGb2N1c091dCk7XG4gICAgfTtcbiAgfSwgW2NhbGxiYWNrc10pO1xufVxuXG5mdW5jdGlvbiB1c2VDYW52YXNFdmVudHMoKSB7XG4gIHZhciBfdXNlVExDb250ZXh0ID0gdXNlVExDb250ZXh0KCksXG4gICAgICBjYWxsYmFja3MgPSBfdXNlVExDb250ZXh0LmNhbGxiYWNrcztcblxuICB2YXIgb25Qb2ludGVyRG93biA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgZS5jdXJyZW50VGFyZ2V0LnNldFBvaW50ZXJDYXB0dXJlKGUucG9pbnRlcklkKTtcblxuICAgIGlmIChlLmJ1dHRvbiA9PT0gMCkge1xuICAgICAgdmFyIGluZm8gPSBpbnB1dHMucG9pbnRlckRvd24oZSwgJ2NhbnZhcycpO1xuICAgICAgY2FsbGJhY2tzLm9uUG9pbnRDYW52YXMgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vblBvaW50Q2FudmFzKGluZm8sIGUpO1xuICAgICAgY2FsbGJhY2tzLm9uUG9pbnRlckRvd24gPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vblBvaW50ZXJEb3duKGluZm8sIGUpO1xuICAgIH1cbiAgfSwgW2NhbGxiYWNrc10pO1xuICB2YXIgb25Qb2ludGVyTW92ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIGlmIChlLmN1cnJlbnRUYXJnZXQuaGFzUG9pbnRlckNhcHR1cmUoZS5wb2ludGVySWQpKSB7XG4gICAgICB2YXIgX2luZm8gPSBpbnB1dHMucG9pbnRlck1vdmUoZSwgJ2NhbnZhcycpO1xuXG4gICAgICBjYWxsYmFja3Mub25EcmFnQ2FudmFzID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25EcmFnQ2FudmFzKF9pbmZvLCBlKTtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IGlucHV0cy5wb2ludGVyTW92ZShlLCAnY2FudmFzJyk7XG4gICAgY2FsbGJhY2tzLm9uUG9pbnRlck1vdmUgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vblBvaW50ZXJNb3ZlKGluZm8sIGUpO1xuICB9LCBbY2FsbGJhY2tzXSk7XG4gIHZhciBvblBvaW50ZXJVcCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB2YXIgaXNEb3VibGVDbGljayA9IGlucHV0cy5pc0RvdWJsZUNsaWNrKCk7XG4gICAgdmFyIGluZm8gPSBpbnB1dHMucG9pbnRlclVwKGUsICdjYW52YXMnKTtcblxuICAgIGlmIChlLmN1cnJlbnRUYXJnZXQuaGFzUG9pbnRlckNhcHR1cmUoZS5wb2ludGVySWQpKSB7XG4gICAgICB2YXIgX2UkY3VycmVudFRhcmdldDtcblxuICAgICAgKF9lJGN1cnJlbnRUYXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQpID09IG51bGwgPyB2b2lkIDAgOiBfZSRjdXJyZW50VGFyZ2V0LnJlbGVhc2VQb2ludGVyQ2FwdHVyZShlLnBvaW50ZXJJZCk7XG4gICAgfVxuXG4gICAgaWYgKGlzRG91YmxlQ2xpY2sgJiYgIShpbmZvLmFsdEtleSB8fCBpbmZvLm1ldGFLZXkpKSB7XG4gICAgICBjYWxsYmFja3Mub25Eb3VibGVDbGlja0NhbnZhcyA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uRG91YmxlQ2xpY2tDYW52YXMoaW5mbywgZSk7XG4gICAgfVxuXG4gICAgY2FsbGJhY2tzLm9uUmVsZWFzZUNhbnZhcyA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uUmVsZWFzZUNhbnZhcyhpbmZvLCBlKTtcbiAgICBjYWxsYmFja3Mub25Qb2ludGVyVXAgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vblBvaW50ZXJVcChpbmZvLCBlKTtcbiAgfSwgW2NhbGxiYWNrc10pO1xuICByZXR1cm4ge1xuICAgIG9uUG9pbnRlckRvd246IG9uUG9pbnRlckRvd24sXG4gICAgb25Qb2ludGVyTW92ZTogb25Qb2ludGVyTW92ZSxcbiAgICBvblBvaW50ZXJVcDogb25Qb2ludGVyVXBcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlU2hhcGVFdmVudHMoaWQsIGRpc2FibGUpIHtcbiAgaWYgKGRpc2FibGUgPT09IHZvaWQgMCkge1xuICAgIGRpc2FibGUgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBfdXNlVExDb250ZXh0ID0gdXNlVExDb250ZXh0KCksXG4gICAgICBjYWxsYmFja3MgPSBfdXNlVExDb250ZXh0LmNhbGxiYWNrcztcblxuICB2YXIgb25Qb2ludGVyRG93biA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIF9lJGN1cnJlbnRUYXJnZXQ7XG5cbiAgICBpZiAoZGlzYWJsZSkgcmV0dXJuO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgKF9lJGN1cnJlbnRUYXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQpID09IG51bGwgPyB2b2lkIDAgOiBfZSRjdXJyZW50VGFyZ2V0LnNldFBvaW50ZXJDYXB0dXJlKGUucG9pbnRlcklkKTtcbiAgICB2YXIgaW5mbyA9IGlucHV0cy5wb2ludGVyRG93bihlLCBpZCk7XG4gICAgY2FsbGJhY2tzLm9uUG9pbnRTaGFwZSA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uUG9pbnRTaGFwZShpbmZvLCBlKTtcbiAgICBjYWxsYmFja3Mub25Qb2ludGVyRG93biA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uUG9pbnRlckRvd24oaW5mbywgZSk7XG4gIH0sIFtjYWxsYmFja3MsIGlkLCBkaXNhYmxlXSk7XG4gIHZhciBvblBvaW50ZXJVcCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGRpc2FibGUpIHJldHVybjtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHZhciBpc0RvdWJsZUNsaWNrID0gaW5wdXRzLmlzRG91YmxlQ2xpY2soKTtcbiAgICB2YXIgaW5mbyA9IGlucHV0cy5wb2ludGVyVXAoZSwgaWQpO1xuXG4gICAgaWYgKGUuY3VycmVudFRhcmdldC5oYXNQb2ludGVyQ2FwdHVyZShlLnBvaW50ZXJJZCkpIHtcbiAgICAgIHZhciBfZSRjdXJyZW50VGFyZ2V0MjtcblxuICAgICAgKF9lJGN1cnJlbnRUYXJnZXQyID0gZS5jdXJyZW50VGFyZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX2UkY3VycmVudFRhcmdldDIucmVsZWFzZVBvaW50ZXJDYXB0dXJlKGUucG9pbnRlcklkKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEb3VibGVDbGljayAmJiAhKGluZm8uYWx0S2V5IHx8IGluZm8ubWV0YUtleSkpIHtcbiAgICAgIGNhbGxiYWNrcy5vbkRvdWJsZUNsaWNrU2hhcGUgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vbkRvdWJsZUNsaWNrU2hhcGUoaW5mbywgZSk7XG4gICAgfVxuXG4gICAgY2FsbGJhY2tzLm9uUmVsZWFzZVNoYXBlID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25SZWxlYXNlU2hhcGUoaW5mbywgZSk7XG4gICAgY2FsbGJhY2tzLm9uUG9pbnRlclVwID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25Qb2ludGVyVXAoaW5mbywgZSk7XG4gIH0sIFtjYWxsYmFja3MsIGlkLCBkaXNhYmxlXSk7XG4gIHZhciBvblBvaW50ZXJNb3ZlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZGlzYWJsZSkgcmV0dXJuO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgaWYgKGlucHV0cy5wb2ludGVyICYmIGUucG9pbnRlcklkICE9PSBpbnB1dHMucG9pbnRlci5wb2ludGVySWQpIHJldHVybjtcbiAgICB2YXIgaW5mbyA9IGlucHV0cy5wb2ludGVyTW92ZShlLCBpZCk7XG5cbiAgICBpZiAoZS5jdXJyZW50VGFyZ2V0Lmhhc1BvaW50ZXJDYXB0dXJlKGUucG9pbnRlcklkKSkge1xuICAgICAgY2FsbGJhY2tzLm9uRHJhZ1NoYXBlID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25EcmFnU2hhcGUoaW5mbywgZSk7XG4gICAgfVxuXG4gICAgY2FsbGJhY2tzLm9uUG9pbnRlck1vdmUgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vblBvaW50ZXJNb3ZlKGluZm8sIGUpO1xuICB9LCBbY2FsbGJhY2tzLCBpZCwgZGlzYWJsZV0pO1xuICB2YXIgb25Qb2ludGVyRW50ZXIgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xuICAgIGlmIChkaXNhYmxlKSByZXR1cm47XG4gICAgdmFyIGluZm8gPSBpbnB1dHMucG9pbnRlckVudGVyKGUsIGlkKTtcbiAgICBjYWxsYmFja3Mub25Ib3ZlclNoYXBlID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25Ib3ZlclNoYXBlKGluZm8sIGUpO1xuICB9LCBbY2FsbGJhY2tzLCBpZCwgZGlzYWJsZV0pO1xuICB2YXIgb25Qb2ludGVyTGVhdmUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xuICAgIGlmIChkaXNhYmxlKSByZXR1cm47XG4gICAgdmFyIGluZm8gPSBpbnB1dHMucG9pbnRlckVudGVyKGUsIGlkKTtcbiAgICBjYWxsYmFja3Mub25VbmhvdmVyU2hhcGUgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vblVuaG92ZXJTaGFwZShpbmZvLCBlKTtcbiAgfSwgW2NhbGxiYWNrcywgaWQsIGRpc2FibGVdKTtcbiAgdmFyIG9uVG91Y2hTdGFydCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9LCBbXSk7XG4gIHZhciBvblRvdWNoRW5kID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHtcbiAgICBvblBvaW50ZXJEb3duOiBvblBvaW50ZXJEb3duLFxuICAgIG9uUG9pbnRlclVwOiBvblBvaW50ZXJVcCxcbiAgICBvblBvaW50ZXJFbnRlcjogb25Qb2ludGVyRW50ZXIsXG4gICAgb25Qb2ludGVyTW92ZTogb25Qb2ludGVyTW92ZSxcbiAgICBvblBvaW50ZXJMZWF2ZTogb25Qb2ludGVyTGVhdmUsXG4gICAgb25Ub3VjaFN0YXJ0OiBvblRvdWNoU3RhcnQsXG4gICAgb25Ub3VjaEVuZDogb25Ub3VjaEVuZFxuICB9O1xufVxuXG5mdW5jdGlvbiBhZGRUb1NoYXBlVHJlZShzaGFwZSwgYnJhbmNoLCBzaGFwZXMsIHNlbGVjdGVkSWRzLCBpbmZvKSB7XG4gIHZhciBub2RlID0ge1xuICAgIHNoYXBlOiBzaGFwZSxcbiAgICBpc0hvdmVyZWQ6IGluZm8uaG92ZXJlZElkID09PSBzaGFwZS5pZCxcbiAgICBpc0N1cnJlbnRQYXJlbnQ6IGluZm8uY3VycmVudFBhcmVudElkID09PSBzaGFwZS5pZCxcbiAgICBpc0VkaXRpbmc6IGluZm8uZWRpdGluZ0lkID09PSBzaGFwZS5pZCxcbiAgICBpc0JpbmRpbmc6IGluZm8uYmluZGluZ0lkID09PSBzaGFwZS5pZCxcbiAgICBpc0RhcmtNb2RlOiBpbmZvLmlzRGFya01vZGUgfHwgZmFsc2UsXG4gICAgaXNTZWxlY3RlZDogc2VsZWN0ZWRJZHMuaW5jbHVkZXMoc2hhcGUuaWQpXG4gIH07XG4gIGJyYW5jaC5wdXNoKG5vZGUpO1xuXG4gIGlmIChzaGFwZS5jaGlsZHJlbikge1xuICAgIG5vZGUuY2hpbGRyZW4gPSBbXTtcbiAgICBzaGFwZS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgICByZXR1cm4gc2hhcGVzW2lkXTtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5jaGlsZEluZGV4IC0gYi5jaGlsZEluZGV4O1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkU2hhcGUpIHtcbiAgICAgIHJldHVybiAoLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgYWRkVG9TaGFwZVRyZWUoY2hpbGRTaGFwZSwgbm9kZS5jaGlsZHJlbiwgc2hhcGVzLCBzZWxlY3RlZElkcywgaW5mbylcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlU2hhcGVUcmVlKHBhZ2UsIHBhZ2VTdGF0ZSwgc2hhcGVVdGlscywgaW5mbywgb25DaGFuZ2UpIHtcbiAgaWYgKGluZm8gPT09IHZvaWQgMCkge1xuICAgIGluZm8gPSB7fTtcbiAgfVxuXG4gIHZhciByUHJldmlvdXNDb3VudCA9IFJlYWN0LnVzZVJlZigwKTtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gW107XG4gIHZhciBzZWxlY3RlZElkcyA9IHBhZ2VTdGF0ZS5zZWxlY3RlZElkcyxcbiAgICAgIGNhbWVyYSA9IHBhZ2VTdGF0ZS5jYW1lcmE7IC8vIEZpbmQgdmlld3BvcnRcblxuICB2YXIgX1ZlYyRzdWIgPSBWZWMuc3ViKFZlYy5kaXYoWzAsIDBdLCBjYW1lcmEuem9vbSksIGNhbWVyYS5wb2ludCksXG4gICAgICBtaW5YID0gX1ZlYyRzdWJbMF0sXG4gICAgICBtaW5ZID0gX1ZlYyRzdWJbMV07XG5cbiAgdmFyIF9WZWMkc3ViMiA9IFZlYy5zdWIoVmVjLmRpdihbd2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodF0sIGNhbWVyYS56b29tKSwgY2FtZXJhLnBvaW50KSxcbiAgICAgIG1heFggPSBfVmVjJHN1YjJbMF0sXG4gICAgICBtYXhZID0gX1ZlYyRzdWIyWzFdO1xuXG4gIHZhciB2aWV3cG9ydCA9IHtcbiAgICBtaW5YOiBtaW5YLFxuICAgIG1pblk6IG1pblksXG4gICAgbWF4WDogbWF4WCxcbiAgICBtYXhZOiBtYXhZLFxuICAgIGhlaWdodDogbWF4WCAtIG1pblgsXG4gICAgd2lkdGg6IG1heFkgLSBtaW5ZXG4gIH07IC8vIEZpbHRlciBzaGFwZXMgdGhhdCBhcmUgaW4gdmlld1xuXG4gIHZhciBzaGFwZXNUb1JlbmRlciA9IE9iamVjdC52YWx1ZXMocGFnZS5zaGFwZXMpLmZpbHRlcihmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICBpZiAoc2hhcGUucGFyZW50SWQgIT09IHBhZ2UuaWQpIHJldHVybiBmYWxzZTsgLy8gRG9uJ3QgaGlkZSBzZWxlY3RlZCBzaGFwZXMgKHRoaXMgYnJlYWtzIGNlcnRhaW4gZHJhZyBpbnRlcmFjdGlvbnMpXG5cbiAgICBpZiAocGFnZVN0YXRlLnNlbGVjdGVkSWRzLmluY2x1ZGVzKHNoYXBlLmlkKSkgcmV0dXJuIHRydWU7XG4gICAgdmFyIHNoYXBlQm91bmRzID0gc2hhcGVVdGlsc1tzaGFwZS50eXBlXS5nZXRCb3VuZHMoc2hhcGUpO1xuICAgIHJldHVybiAoLy8gVE9ETzogU29tZSBzaGFwZXMgc2hvdWxkIGFsd2F5cyByZW5kZXIgKGxpbmVzLCByYXlzKVxuICAgICAgVXRpbHMuYm91bmRzQ29udGFpbih2aWV3cG9ydCwgc2hhcGVCb3VuZHMpIHx8IFV0aWxzLmJvdW5kc0NvbGxpZGUodmlld3BvcnQsIHNoYXBlQm91bmRzKVxuICAgICk7XG4gIH0pOyAvLyBDYWxsIG9uQ2hhbmdlIGNhbGxiYWNrIHdoZW4gbnVtYmVyIG9mIHJlbmRlcmluZyBzaGFwZXMgY2hhbmdlc1xuXG4gIGlmIChzaGFwZXNUb1JlbmRlci5sZW5ndGggIT09IHJQcmV2aW91c0NvdW50LmN1cnJlbnQpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBvbkNoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogb25DaGFuZ2Uoc2hhcGVzVG9SZW5kZXIubWFwKGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgICByZXR1cm4gc2hhcGUuaWQ7XG4gICAgICB9KSk7XG4gICAgfSwgMCk7XG4gICAgclByZXZpb3VzQ291bnQuY3VycmVudCA9IHNoYXBlc1RvUmVuZGVyLmxlbmd0aDtcbiAgfSAvLyBQb3B1bGF0ZSB0aGUgc2hhcGUgdHJlZVxuXG5cbiAgdmFyIHRyZWUgPSBbXTtcbiAgc2hhcGVzVG9SZW5kZXIuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhLmNoaWxkSW5kZXggLSBiLmNoaWxkSW5kZXg7XG4gIH0pLmZvckVhY2goZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgcmV0dXJuIGFkZFRvU2hhcGVUcmVlKHNoYXBlLCB0cmVlLCBwYWdlLnNoYXBlcywgc2VsZWN0ZWRJZHMsIGluZm8pO1xuICB9KTtcbiAgcmV0dXJuIHRyZWU7XG59XG5cbnZhciBfdGVtcGxhdGVPYmplY3Q7XG52YXIgc3R5bGVzID0gLyojX19QVVJFX18qL25ldyBNYXAoKTtcblxuZnVuY3Rpb24gbWFrZUNzc1RoZW1lKHByZWZpeCwgdGhlbWUpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHRoZW1lKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgdmFyIHZhbHVlID0gdGhlbWVba2V5XTtcblxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGFjYyArIChcIi0tXCIgKyBwcmVmaXggKyBcIi1cIiArIGtleSArIFwiOiBcIiArIHZhbHVlICsgXCI7XFxuXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sICcnKTtcbn1cblxuZnVuY3Rpb24gdXNlVGhlbWUocHJlZml4LCB0aGVtZSwgc2VsZWN0b3IpIHtcbiAgaWYgKHNlbGVjdG9yID09PSB2b2lkIDApIHtcbiAgICBzZWxlY3RvciA9ICc6cm9vdCc7XG4gIH1cblxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgdmFyIGNzc1RoZW1lID0gbWFrZUNzc1RoZW1lKHByZWZpeCwgdGhlbWUpO1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnaWQnLCBwcmVmaXggKyBcIi10aGVtZVwiKTtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtc2VsZWN0b3InLCBzZWxlY3Rvcik7XG4gICAgc3R5bGUuaW5uZXJIVE1MID0gXCJcXG4gICAgICAgIFwiICsgc2VsZWN0b3IgKyBcIiB7XFxuICAgICAgICAgIFwiICsgY3NzVGhlbWUgKyBcIlxcbiAgICAgICAgfVxcbiAgICAgIFwiO1xuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc3R5bGUgJiYgZG9jdW1lbnQuaGVhZC5jb250YWlucyhzdHlsZSkpIHtcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZChzdHlsZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW3ByZWZpeCwgdGhlbWUsIHNlbGVjdG9yXSk7XG59XG5cbmZ1bmN0aW9uIHVzZVN0eWxlKHVpZCwgcnVsZXMpIHtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc3R5bGVzLmdldCh1aWQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBzdHlsZS5pbm5lckhUTUwgPSBydWxlcztcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ2lkJywgdWlkKTtcbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICBzdHlsZXMuc2V0KHVpZCwgc3R5bGUpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc3R5bGUgJiYgZG9jdW1lbnQuaGVhZC5jb250YWlucyhzdHlsZSkpIHtcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZChzdHlsZSk7XG4gICAgICAgIHN0eWxlc1tcImRlbGV0ZVwiXSh1aWQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFt1aWQsIHJ1bGVzXSk7XG59XG5cbnZhciBjc3MgPSBmdW5jdGlvbiBjc3Moc3RyaW5ncykge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gc3RyaW5ncy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgc3RyaW5nLCBpbmRleCkge1xuICAgIHJldHVybiBhY2MgKyBzdHJpbmcgKyAoaW5kZXggPCBhcmdzLmxlbmd0aCA/IGFyZ3NbaW5kZXhdIDogJycpO1xuICB9LCAnJyk7XG59O1xuXG52YXIgZGVmYXVsdFRoZW1lID0ge1xuICBicnVzaEZpbGw6ICdyZ2JhKDAsMCwwLC4wNSknLFxuICBicnVzaFN0cm9rZTogJ3JnYmEoMCwwLDAsLjI1KScsXG4gIHNlbGVjdFN0cm9rZTogJ3JnYig2NiwgMTMzLCAyNDQpJyxcbiAgc2VsZWN0RmlsbDogJ3JnYmEoNjUsIDEzMiwgMjQ0LCAwLjA1KScsXG4gIGJhY2tncm91bmQ6ICdyZ2IoMjQ4LCAyNDksIDI1MCknLFxuICBmb3JlZ3JvdW5kOiAncmdiKDUxLCA1MSwgNTEpJ1xufTtcbnZhciB0bGNzcyA9IC8qI19fUFVSRV9fKi9jc3MoX3RlbXBsYXRlT2JqZWN0IHx8IChfdGVtcGxhdGVPYmplY3QgPSAvKiNfX1BVUkVfXyovX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlKFtcIlxcbiAgOnJvb3Qge1xcbiAgICAtLXRsLXpvb206IDE7XFxuICAgIC0tdGwtc2NhbGU6IGNhbGMoMSAvIHZhcigtLXRsLXpvb20pKTtcXG4gIH1cXG5cXG4gIC50bC1jb3VudGVyLXNjYWxlZCB7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUodmFyKC0tdGwtc2NhbGUpKTtcXG4gIH1cXG5cXG4gIC50bC1kYXNoZWQge1xcbiAgICBzdHJva2UtZGFzaGFycmF5OiBjYWxjKDJweCAqIHZhcigtLXRsLXNjYWxlKSksIGNhbGMoMnB4ICogdmFyKC0tdGwtc2NhbGUpKTtcXG4gIH1cXG5cXG4gIC50bC10cmFuc3BhcmVudCB7XFxuICAgIGZpbGw6IHRyYW5zcGFyZW50O1xcbiAgICBzdHJva2U6IHRyYW5zcGFyZW50O1xcbiAgfVxcblxcbiAgLnRsLWN1cnNvci1ucyB7XFxuICAgIGN1cnNvcjogbnMtcmVzaXplO1xcbiAgfVxcblxcbiAgLnRsLWN1cnNvci1ldyB7XFxuICAgIGN1cnNvcjogZXctcmVzaXplO1xcbiAgfVxcblxcbiAgLnRsLWN1cnNvci1uZXN3IHtcXG4gICAgY3Vyc29yOiBuZXN3LXJlc2l6ZTtcXG4gIH1cXG5cXG4gIC50bC1jdXJzb3ItbndzZSB7XFxuICAgIGN1cnNvcjogbndzZS1yZXNpemU7XFxuICB9XFxuXFxuICAudGwtY29ybmVyLWhhbmRsZSB7XFxuICAgIHN0cm9rZTogdmFyKC0tdGwtc2VsZWN0U3Ryb2tlKTtcXG4gICAgZmlsbDogdmFyKC0tdGwtYmFja2dyb3VuZCk7XFxuICAgIHN0cm9rZS13aWR0aDogY2FsYygxLjVweCAqIHZhcigtLXRsLXNjYWxlKSk7XFxuICB9XFxuXFxuICAudGwtcm90YXRlLWhhbmRsZSB7XFxuICAgIHN0cm9rZTogdmFyKC0tdGwtc2VsZWN0U3Ryb2tlKTtcXG4gICAgZmlsbDogdmFyKC0tdGwtYmFja2dyb3VuZCk7XFxuICAgIHN0cm9rZS13aWR0aDogY2FsYygxLjVweCAqIHZhcigtLXRsLXNjYWxlKSk7XFxuICAgIGN1cnNvcjogZ3JhYjtcXG4gIH1cXG5cXG4gIC50bC1oYW5kbGUge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKHZhcigtLXRsLXNjYWxlKSk7XFxuICAgIGZpbGw6IHZhcigtLXRsLWJhY2tncm91bmQpO1xcbiAgICBzdHJva2U6IHZhcigtLXRsLXN0cm9rZSk7XFxuICAgIHN0cm9rZS13aWR0aDogY2FsYygycHggKiB2YXIoLS10bC1zY2FsZSkpO1xcbiAgICBwb2ludGVyLWV2ZW50czogYWxsO1xcbiAgfVxcblxcbiAgLnRsLWJpbmRpbmcge1xcbiAgICBmaWxsOiB2YXIoLS10bC1zZWxlY3RGaWxsKTtcXG4gICAgc3Ryb2tlOiB2YXIoLS10bC1zZWxlY3RTdHJva2UpO1xcbiAgICBzdHJva2Utd2lkdGg6IGNhbGMoMXB4ICogdmFyKC0tdGwtc2NhbGUpKTtcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICB9XFxuXFxuICAudGwtYm91bmRzLWNlbnRlciB7XFxuICAgIGZpbGw6IHRyYW5zcGFyZW50O1xcbiAgICBzdHJva2U6IHZhcigtLXRsLXNlbGVjdFN0cm9rZSk7XFxuICAgIHN0cm9rZS13aWR0aDogY2FsYygxLjVweCAqIHZhcigtLXRsLXNjYWxlKSk7XFxuICB9XFxuXFxuICAudGwtYm91bmRzLWJnIHtcXG4gICAgc3Ryb2tlOiBub25lO1xcbiAgICBmaWxsOiB2YXIoLS10bC1zZWxlY3RGaWxsKTtcXG4gICAgcG9pbnRlci1ldmVudHM6IGFsbDtcXG4gIH1cXG5cXG4gIC50bC1icnVzaCB7XFxuICAgIGZpbGw6IHZhcigtLXRsLWJydXNoRmlsbCk7XFxuICAgIHN0cm9rZTogdmFyKC0tdGwtYnJ1c2hTdHJva2UpO1xcbiAgICBzdHJva2Utd2lkdGg6IGNhbGMoMXB4ICogdmFyKC0tdGwtc2NhbGUpKTtcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICB9XFxuXFxuICAudGwtY2FudmFzIHtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICB0b3A6IDBweDtcXG4gICAgbGVmdDogMHB4O1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICB0b3VjaC1hY3Rpb246IG5vbmU7XFxuICAgIHotaW5kZXg6IDEwMDtcXG4gICAgcG9pbnRlci1ldmVudHM6IGFsbDtcXG4gIH1cXG5cXG4gIC50bC1jb250YWluZXIge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHBhZGRpbmc6IDBweDtcXG4gICAgbWFyZ2luOiAwcHg7XFxuICAgIG92ZXJzY3JvbGwtYmVoYXZpb3I6IG5vbmU7XFxuICAgIG92ZXJzY3JvbGwtYmVoYXZpb3IteDogbm9uZTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tdGwtYmFja2dyb3VuZCk7XFxuICB9XFxuXFxuICAudGwtY29udGFpbmVyICoge1xcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gIH1cXG5cXG4gIC50bC1kb3Qge1xcbiAgICBmaWxsOiB2YXIoLS10bC1iYWNrZ3JvdW5kKTtcXG4gICAgc3Ryb2tlOiB2YXIoLS10bC1mb3JlZ3JvdW5kKTtcXG4gICAgc3Ryb2tlLXdpZHRoOiAycHg7XFxuICB9XFxuXFxuICAudGwtaGFuZGxlIHtcXG4gICAgZmlsbDogdmFyKC0tdGwtYmFja2dyb3VuZCk7XFxuICAgIHN0cm9rZTogdmFyKC0tdGwtc2VsZWN0U3Ryb2tlKTtcXG4gICAgc3Ryb2tlLXdpZHRoOiBjYWxjKDEuNXB4ICogdmFyKC0tdGwtc2NhbGUpKTtcXG4gIH1cXG5cXG4gIC50bC1oYW5kbGUtYmcge1xcbiAgICBmaWxsOiB0cmFuc3BhcmVudDtcXG4gICAgc3Ryb2tlOiBub25lO1xcbiAgICBvcGFjaXR5OiAwLjI7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XFxuICB9XFxuXFxuICAudGwtaGFuZGxlLWJnOmhvdmVyIHtcXG4gICAgZmlsbDogdmFyKC0tdGwtc2VsZWN0ZWQtZmlsbCk7XFxuICB9XFxuXFxuICAudGwtaGFuZGxlLWJnOmhvdmVyID4gKiB7XFxuICAgIHN0cm9rZTogdmFyKC0tdGwtc2VsZWN0ZWQtZmlsbCk7XFxuICB9XFxuXFxuICAudGwtaGFuZGxlLWJnOmFjdGl2ZSB7XFxuICAgIGZpbGw6IHZhcigtLXRsLXNlbGVjdGVkLWZpbGwpO1xcbiAgICBzdHJva2U6IHZhcigtLXRsLXNlbGVjdGVkLWZpbGwpO1xcbiAgfVxcblxcbiAgLnRsLWJpbmRpbmctaW5kaWNhdG9yIHtcXG4gICAgc3Ryb2tlLXdpZHRoOiBjYWxjKDNweCAqIHZhcigtLXRsLXNjYWxlKSk7XFxuICAgIGZpbGw6IG5vbmU7XFxuICAgIHN0cm9rZTogdmFyKC0tdGwtc2VsZWN0ZWQpO1xcbiAgfVxcblxcbiAgLnRsLXNoYXBlLWdyb3VwIHtcXG4gICAgb3V0bGluZTogbm9uZTtcXG4gIH1cXG5cXG4gIC50bC1zaGFwZS1ncm91cCA+ICpbZGF0YS1zaHk9J3RydWUnXSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICB9XFxuXFxuICAudGwtc2hhcGUtZ3JvdXA6aG92ZXIgPiAqW2RhdGEtc2h5PSd0cnVlJ10ge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgfVxcblxcbiAgLnRsLWN1cnJlbnQtcGFyZW50ID4gKltkYXRhLXNoeT0ndHJ1ZSddIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gIH1cXG5cIl0pKSk7XG5mdW5jdGlvbiB1c2VUTFRoZW1lKHRoZW1lKSB7XG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBkZWZhdWx0VGhlbWUsIHRoZW1lKTtcbiAgfSksXG4gICAgICB0bHRoZW1lID0gX1JlYWN0JHVzZVN0YXRlWzBdO1xuXG4gIHVzZVRoZW1lKCd0bCcsIHRsdGhlbWUpO1xuICB1c2VTdHlsZSgndGwtY2FudmFzJywgdGxjc3MpO1xufVxuXG5mdW5jdGlvbiB1c2VCb3VuZHNIYW5kbGVFdmVudHMoaWQpIHtcbiAgdmFyIF91c2VUTENvbnRleHQgPSB1c2VUTENvbnRleHQoKSxcbiAgICAgIGNhbGxiYWNrcyA9IF91c2VUTENvbnRleHQuY2FsbGJhY2tzO1xuXG4gIHZhciBvblBvaW50ZXJEb3duID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgX2UkY3VycmVudFRhcmdldDtcblxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgKF9lJGN1cnJlbnRUYXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQpID09IG51bGwgPyB2b2lkIDAgOiBfZSRjdXJyZW50VGFyZ2V0LnNldFBvaW50ZXJDYXB0dXJlKGUucG9pbnRlcklkKTtcbiAgICB2YXIgaW5mbyA9IGlucHV0cy5wb2ludGVyRG93bihlLCBpZCk7XG4gICAgY2FsbGJhY2tzLm9uUG9pbnRCb3VuZHNIYW5kbGUgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vblBvaW50Qm91bmRzSGFuZGxlKGluZm8sIGUpO1xuICAgIGNhbGxiYWNrcy5vblBvaW50ZXJEb3duID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25Qb2ludGVyRG93bihpbmZvLCBlKTtcbiAgfSwgW2NhbGxiYWNrcywgaWRdKTtcbiAgdmFyIG9uUG9pbnRlclVwID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHZhciBpc0RvdWJsZUNsaWNrID0gaW5wdXRzLmlzRG91YmxlQ2xpY2soKTtcbiAgICB2YXIgaW5mbyA9IGlucHV0cy5wb2ludGVyVXAoZSwgaWQpO1xuXG4gICAgaWYgKGUuY3VycmVudFRhcmdldC5oYXNQb2ludGVyQ2FwdHVyZShlLnBvaW50ZXJJZCkpIHtcbiAgICAgIHZhciBfZSRjdXJyZW50VGFyZ2V0MjtcblxuICAgICAgKF9lJGN1cnJlbnRUYXJnZXQyID0gZS5jdXJyZW50VGFyZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX2UkY3VycmVudFRhcmdldDIucmVsZWFzZVBvaW50ZXJDYXB0dXJlKGUucG9pbnRlcklkKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEb3VibGVDbGljayAmJiAhKGluZm8uYWx0S2V5IHx8IGluZm8ubWV0YUtleSkpIHtcbiAgICAgIGNhbGxiYWNrcy5vbkRvdWJsZUNsaWNrQm91bmRzSGFuZGxlID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25Eb3VibGVDbGlja0JvdW5kc0hhbmRsZShpbmZvLCBlKTtcbiAgICB9XG5cbiAgICBjYWxsYmFja3Mub25SZWxlYXNlQm91bmRzSGFuZGxlID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25SZWxlYXNlQm91bmRzSGFuZGxlKGluZm8sIGUpO1xuICAgIGNhbGxiYWNrcy5vblBvaW50ZXJVcCA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uUG9pbnRlclVwKGluZm8sIGUpO1xuICB9LCBbY2FsbGJhY2tzLCBpZF0pO1xuICB2YXIgb25Qb2ludGVyTW92ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgLy8gZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgIGlmIChlLmN1cnJlbnRUYXJnZXQuaGFzUG9pbnRlckNhcHR1cmUoZS5wb2ludGVySWQpKSB7XG4gICAgICBjYWxsYmFja3Mub25EcmFnQm91bmRzSGFuZGxlID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25EcmFnQm91bmRzSGFuZGxlKGlucHV0cy5wb2ludGVyTW92ZShlLCBpZCksIGUpO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gaW5wdXRzLnBvaW50ZXJNb3ZlKGUsIGlkKTtcbiAgICBjYWxsYmFja3Mub25Qb2ludGVyTW92ZSA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uUG9pbnRlck1vdmUoaW5mbywgZSk7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSwgW2NhbGxiYWNrcywgaWRdKTtcbiAgdmFyIG9uUG9pbnRlckVudGVyID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGUpIHtcbiAgICBjYWxsYmFja3Mub25Ib3ZlckJvdW5kc0hhbmRsZSA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uSG92ZXJCb3VuZHNIYW5kbGUoaW5wdXRzLnBvaW50ZXJFbnRlcihlLCBpZCksIGUpO1xuICB9LCBbY2FsbGJhY2tzLCBpZF0pO1xuICB2YXIgb25Qb2ludGVyTGVhdmUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xuICAgIGNhbGxiYWNrcy5vblVuaG92ZXJCb3VuZHNIYW5kbGUgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vblVuaG92ZXJCb3VuZHNIYW5kbGUoaW5wdXRzLnBvaW50ZXJFbnRlcihlLCBpZCksIGUpO1xuICB9LCBbY2FsbGJhY2tzLCBpZF0pO1xuICB2YXIgb25Ub3VjaFN0YXJ0ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0sIFtdKTtcbiAgdmFyIG9uVG91Y2hFbmQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSwgW10pO1xuICByZXR1cm4ge1xuICAgIG9uUG9pbnRlckRvd246IG9uUG9pbnRlckRvd24sXG4gICAgb25Qb2ludGVyVXA6IG9uUG9pbnRlclVwLFxuICAgIG9uUG9pbnRlckVudGVyOiBvblBvaW50ZXJFbnRlcixcbiAgICBvblBvaW50ZXJNb3ZlOiBvblBvaW50ZXJNb3ZlLFxuICAgIG9uUG9pbnRlckxlYXZlOiBvblBvaW50ZXJMZWF2ZSxcbiAgICBvblRvdWNoU3RhcnQ6IG9uVG91Y2hTdGFydCxcbiAgICBvblRvdWNoRW5kOiBvblRvdWNoRW5kXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZUNhbWVyYUNzcyhwYWdlU3RhdGUpIHtcbiAgdmFyIHJHcm91cCA9IFJlYWN0LnVzZVJlZihudWxsKTsgLy8gVXBkYXRlIHRoZSB0bC16b29tIENTUyB2YXJpYWJsZSB3aGVuIHRoZSB6b29tIGNoYW5nZXNcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS10bC16b29tJywgcGFnZVN0YXRlLmNhbWVyYS56b29tLnRvU3RyaW5nKCkpO1xuICB9LCBbcGFnZVN0YXRlLmNhbWVyYS56b29tXSk7IC8vIFVwZGF0ZSB0aGUgZ3JvdXAncyBwb3NpdGlvbiB3aGVuIHRoZSBjYW1lcmEgbW92ZXMgb3Igem9vbXNcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBfckdyb3VwJGN1cnJlbnQ7XG5cbiAgICB2YXIgX3BhZ2VTdGF0ZSRjYW1lcmEgPSBwYWdlU3RhdGUuY2FtZXJhLFxuICAgICAgICB6b29tID0gX3BhZ2VTdGF0ZSRjYW1lcmEuem9vbSxcbiAgICAgICAgcG9pbnQgPSBfcGFnZVN0YXRlJGNhbWVyYS5wb2ludDtcbiAgICAoX3JHcm91cCRjdXJyZW50ID0gckdyb3VwLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfckdyb3VwJGN1cnJlbnQuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBcInNjYWxlKFwiICsgem9vbSArIFwiKSB0cmFuc2xhdGUoXCIgKyBwb2ludFswXSArIFwiIFwiICsgcG9pbnRbMV0gKyBcIilcIik7XG4gIH0sIFtwYWdlU3RhdGUuY2FtZXJhXSk7XG4gIHJldHVybiByR3JvdXA7XG59XG5cbmZ1bmN0aW9uIHVzZVJlbmRlck9uUmVzaXplKCkge1xuICB2YXIgZm9yY2VVcGRhdGUgPSBSZWFjdC51c2VSZWR1Y2VyKGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHggKyAxO1xuICB9LCAwKVsxXTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGVib3VuY2VkVXBkYXRlID0gVXRpbHMuZGVib3VuY2UoZm9yY2VVcGRhdGUsIDk2KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZGVib3VuY2VkVXBkYXRlKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGRlYm91bmNlZFVwZGF0ZSk7XG4gICAgfTtcbiAgfSwgW2ZvcmNlVXBkYXRlXSk7XG59XG5cbmZ1bmN0aW9uIHVzZVNlbGVjdGlvbihwYWdlLCBwYWdlU3RhdGUsIHNoYXBlVXRpbHMpIHtcbiAgdmFyIHNlbGVjdGVkSWRzID0gcGFnZVN0YXRlLnNlbGVjdGVkSWRzO1xuICB2YXIgYm91bmRzID0gdW5kZWZpbmVkO1xuICB2YXIgcm90YXRpb24gPSAwO1xuICB2YXIgaXNMb2NrZWQgPSBmYWxzZTtcblxuICBpZiAoc2VsZWN0ZWRJZHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGlkID0gc2VsZWN0ZWRJZHNbMF07XG4gICAgdmFyIHNoYXBlID0gcGFnZS5zaGFwZXNbaWRdO1xuICAgIHJvdGF0aW9uID0gc2hhcGUucm90YXRpb24gfHwgMDtcbiAgICBpc0xvY2tlZCA9IHNoYXBlLmlzTG9ja2VkIHx8IGZhbHNlO1xuICAgIGJvdW5kcyA9IHNoYXBlVXRpbHNbc2hhcGUudHlwZV0uZ2V0Qm91bmRzKHNoYXBlKTtcbiAgfSBlbHNlIGlmIChzZWxlY3RlZElkcy5sZW5ndGggPiAxKSB7XG4gICAgdmFyIHNlbGVjdGVkU2hhcGVzID0gc2VsZWN0ZWRJZHMubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuIHBhZ2Uuc2hhcGVzW2lkXTtcbiAgICB9KTtcbiAgICByb3RhdGlvbiA9IDA7XG4gICAgaXNMb2NrZWQgPSBzZWxlY3RlZFNoYXBlcy5ldmVyeShmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgIHJldHVybiBzaGFwZS5pc0xvY2tlZDtcbiAgICB9KTtcbiAgICBib3VuZHMgPSBzZWxlY3RlZFNoYXBlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgc2hhcGUsIGkpIHtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzaGFwZVV0aWxzW3NoYXBlLnR5cGVdLmdldFJvdGF0ZWRCb3VuZHMoc2hhcGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gVXRpbHMuZ2V0RXhwYW5kZWRCb3VuZHMoYWNjLCBzaGFwZVV0aWxzW3NoYXBlLnR5cGVdLmdldFJvdGF0ZWRCb3VuZHMoc2hhcGUpKTtcbiAgICB9LCB7fSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJvdW5kczogYm91bmRzLFxuICAgIHJvdGF0aW9uOiByb3RhdGlvbixcbiAgICBpc0xvY2tlZDogaXNMb2NrZWRcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlSGFuZGxlRXZlbnRzKGlkKSB7XG4gIHZhciBfdXNlVExDb250ZXh0ID0gdXNlVExDb250ZXh0KCksXG4gICAgICBjYWxsYmFja3MgPSBfdXNlVExDb250ZXh0LmNhbGxiYWNrcztcblxuICB2YXIgb25Qb2ludGVyRG93biA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIF9lJGN1cnJlbnRUYXJnZXQ7XG5cbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIChfZSRjdXJyZW50VGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX2UkY3VycmVudFRhcmdldC5zZXRQb2ludGVyQ2FwdHVyZShlLnBvaW50ZXJJZCk7XG4gICAgdmFyIGluZm8gPSBpbnB1dHMucG9pbnRlckRvd24oZSwgaWQpO1xuICAgIGNhbGxiYWNrcy5vblBvaW50SGFuZGxlID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25Qb2ludEhhbmRsZShpbmZvLCBlKTtcbiAgICBjYWxsYmFja3Mub25Qb2ludGVyRG93biA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uUG9pbnRlckRvd24oaW5mbywgZSk7XG4gIH0sIFtjYWxsYmFja3MsIGlkXSk7XG4gIHZhciBvblBvaW50ZXJVcCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB2YXIgaXNEb3VibGVDbGljayA9IGlucHV0cy5pc0RvdWJsZUNsaWNrKCk7XG4gICAgdmFyIGluZm8gPSBpbnB1dHMucG9pbnRlclVwKGUsICdib3VuZHMnKTtcblxuICAgIGlmIChlLmN1cnJlbnRUYXJnZXQuaGFzUG9pbnRlckNhcHR1cmUoZS5wb2ludGVySWQpKSB7XG4gICAgICB2YXIgX2UkY3VycmVudFRhcmdldDI7XG5cbiAgICAgIChfZSRjdXJyZW50VGFyZ2V0MiA9IGUuY3VycmVudFRhcmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lJGN1cnJlbnRUYXJnZXQyLnJlbGVhc2VQb2ludGVyQ2FwdHVyZShlLnBvaW50ZXJJZCk7XG5cbiAgICAgIGlmIChpc0RvdWJsZUNsaWNrICYmICEoaW5mby5hbHRLZXkgfHwgaW5mby5tZXRhS2V5KSkge1xuICAgICAgICBjYWxsYmFja3Mub25Eb3VibGVDbGlja0hhbmRsZSA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uRG91YmxlQ2xpY2tIYW5kbGUoaW5mbywgZSk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrcy5vblJlbGVhc2VIYW5kbGUgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vblJlbGVhc2VIYW5kbGUoaW5mbywgZSk7XG4gICAgfVxuXG4gICAgY2FsbGJhY2tzLm9uUG9pbnRlclVwID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25Qb2ludGVyVXAoaW5mbywgZSk7XG4gIH0sIFtjYWxsYmFja3NdKTtcbiAgdmFyIG9uUG9pbnRlck1vdmUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xuICAgIC8vIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICBpZiAoZS5jdXJyZW50VGFyZ2V0Lmhhc1BvaW50ZXJDYXB0dXJlKGUucG9pbnRlcklkKSkge1xuICAgICAgdmFyIF9pbmZvID0gaW5wdXRzLnBvaW50ZXJNb3ZlKGUsIGlkKTtcblxuICAgICAgY2FsbGJhY2tzLm9uRHJhZ0hhbmRsZSA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uRHJhZ0hhbmRsZShfaW5mbywgZSk7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSBpbnB1dHMucG9pbnRlck1vdmUoZSwgaWQpO1xuICAgIGNhbGxiYWNrcy5vblBvaW50ZXJNb3ZlID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25Qb2ludGVyTW92ZShpbmZvLCBlKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9LCBbY2FsbGJhY2tzLCBpZF0pO1xuICB2YXIgb25Qb2ludGVyRW50ZXIgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xuICAgIHZhciBpbmZvID0gaW5wdXRzLnBvaW50ZXJFbnRlcihlLCBpZCk7XG4gICAgY2FsbGJhY2tzLm9uSG92ZXJIYW5kbGUgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vbkhvdmVySGFuZGxlKGluZm8sIGUpO1xuICB9LCBbY2FsbGJhY2tzLCBpZF0pO1xuICB2YXIgb25Qb2ludGVyTGVhdmUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xuICAgIHZhciBpbmZvID0gaW5wdXRzLnBvaW50ZXJFbnRlcihlLCBpZCk7XG4gICAgY2FsbGJhY2tzLm9uVW5ob3ZlckhhbmRsZSA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uVW5ob3ZlckhhbmRsZShpbmZvLCBlKTtcbiAgfSwgW2NhbGxiYWNrcywgaWRdKTtcbiAgdmFyIG9uVG91Y2hTdGFydCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9LCBbXSk7XG4gIHZhciBvblRvdWNoRW5kID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHtcbiAgICBvblBvaW50ZXJEb3duOiBvblBvaW50ZXJEb3duLFxuICAgIG9uUG9pbnRlclVwOiBvblBvaW50ZXJVcCxcbiAgICBvblBvaW50ZXJFbnRlcjogb25Qb2ludGVyRW50ZXIsXG4gICAgb25Qb2ludGVyTW92ZTogb25Qb2ludGVyTW92ZSxcbiAgICBvblBvaW50ZXJMZWF2ZTogb25Qb2ludGVyTGVhdmUsXG4gICAgb25Ub3VjaFN0YXJ0OiBvblRvdWNoU3RhcnQsXG4gICAgb25Ub3VjaEVuZDogb25Ub3VjaEVuZFxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VIYW5kbGVzKHBhZ2UsIHBhZ2VTdGF0ZSkge1xuICB2YXIgc2VsZWN0ZWRJZHMgPSBwYWdlU3RhdGUuc2VsZWN0ZWRJZHM7XG4gIHZhciBzaGFwZVdpdGhIYW5kbGVzID0gdW5kZWZpbmVkO1xuXG4gIGlmIChzZWxlY3RlZElkcy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgaWQgPSBzZWxlY3RlZElkc1swXTtcbiAgICB2YXIgc2hhcGUgPSBwYWdlLnNoYXBlc1tpZF07XG5cbiAgICBpZiAoc2hhcGUuaGFuZGxlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzaGFwZVdpdGhIYW5kbGVzID0gc2hhcGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzaGFwZVdpdGhIYW5kbGVzOiBzaGFwZVdpdGhIYW5kbGVzXG4gIH07XG59XG5cbnZhciBFcnJvckZhbGxiYWNrID0gLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGVycm9yID0gX3JlZi5lcnJvcixcbiAgICAgIHJlc2V0RXJyb3JCb3VuZGFyeSA9IF9yZWYucmVzZXRFcnJvckJvdW5kYXJ5O1xuXG4gIHZhciBfdXNlVExDb250ZXh0ID0gdXNlVExDb250ZXh0KCksXG4gICAgICBjYWxsYmFja3MgPSBfdXNlVExDb250ZXh0LmNhbGxiYWNrcztcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGNhbGxiYWNrcy5vbkVycm9yID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25FcnJvcihlcnJvcik7XG4gICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gIH0sIFtlcnJvciwgcmVzZXRFcnJvckJvdW5kYXJ5LCBjYWxsYmFja3NdKTtcbiAgcmV0dXJuIG51bGw7XG59KTtcblxudmFyIEJydXNoVXBkYXRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJydXNoVXBkYXRlcigpIHtcbiAgICB0aGlzLnJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgIHRoaXMuaXNDb250cm9sbGVkID0gZmFsc2U7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQnJ1c2hVcGRhdGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KGJvdW5kcykge1xuICAgIHZhciBfdGhpcyRyZWY7XG5cbiAgICBpZiAoIXRoaXMuaXNDb250cm9sbGVkKSB0aGlzLmlzQ29udHJvbGxlZCA9IHRydWU7XG5cbiAgICBpZiAoIWJvdW5kcykge1xuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlbG0gPSAoX3RoaXMkcmVmID0gdGhpcy5yZWYpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRyZWYuY3VycmVudDtcbiAgICBpZiAoIWVsbSkgcmV0dXJuO1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ29wYWNpdHknLCAnMScpO1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ3gnLCBib3VuZHMubWluWC50b1N0cmluZygpKTtcbiAgICBlbG0uc2V0QXR0cmlidXRlKCd5JywgYm91bmRzLm1pblkudG9TdHJpbmcoKSk7XG4gICAgZWxtLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBib3VuZHMud2lkdGgudG9TdHJpbmcoKSk7XG4gICAgZWxtLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgYm91bmRzLmhlaWdodC50b1N0cmluZygpKTtcbiAgfTtcblxuICBfcHJvdG8uY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB2YXIgX3RoaXMkcmVmMjtcblxuICAgIHZhciBlbG0gPSAoX3RoaXMkcmVmMiA9IHRoaXMucmVmKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcmVmMi5jdXJyZW50O1xuICAgIGlmICghZWxtKSByZXR1cm47XG4gICAgZWxtLnNldEF0dHJpYnV0ZSgnb3BhY2l0eScsICcwJyk7XG4gICAgZWxtLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMCcpO1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcwJyk7XG4gIH07XG5cbiAgcmV0dXJuIEJydXNoVXBkYXRlcjtcbn0oKTtcblxudmFyIGJydXNoVXBkYXRlciA9IC8qI19fUFVSRV9fKi9uZXcgQnJ1c2hVcGRhdGVyKCk7XG52YXIgQnJ1c2ggPSAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyhmdW5jdGlvbiAoX3JlZikge1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xuICAgIHJlZjogYnJ1c2hVcGRhdGVyLnJlZixcbiAgICBjbGFzc05hbWU6IFwidGwtYnJ1c2hcIixcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH0pO1xufSwgLy8gT25jZSB0aGUgYnJ1c2ggaXMgY29udHJvbGxlZCwgbmV2ZXIgdXBkYXRlIGFnYWluIGZyb20gcHJvcHNcbmZ1bmN0aW9uIChwcmV2LCBuZXh0KSB7XG4gIHJldHVybiB0cnVlO1xufSk7XG5cbmZ1bmN0aW9uIERlZnMoX3JlZikge1xuICB2YXIgem9vbSA9IF9yZWYuem9vbTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkZWZzXCIsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIiwge1xuICAgIGlkOiBcImRvdFwiLFxuICAgIGNsYXNzTmFtZTogXCJ0bC1jb3VudGVyLXNjYWxlZCB0bC1kb3RcIixcbiAgICByOiA0XG4gIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIsIHtcbiAgICBpZDogXCJoYW5kbGVcIixcbiAgICBjbGFzc05hbWU6IFwidGwtY291bnRlci1zY2FsZWQgdGwtaGFuZGxlXCIsXG4gICAgcjogNFxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIiwge1xuICAgIGlkOiBcImNyb3NzXCIsXG4gICAgY2xhc3NOYW1lOiBcInRsLWJpbmRpbmctaW5kaWNhdG9yXCJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmVcIiwge1xuICAgIHgxOiAtNixcbiAgICB5MTogLTYsXG4gICAgeDI6IDYsXG4gICAgeTI6IDZcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIsIHtcbiAgICB4MTogNixcbiAgICB5MTogLTYsXG4gICAgeDI6IC02LFxuICAgIHkyOiA2XG4gIH0pKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImZpbHRlclwiLCB7XG4gICAgaWQ6IFwiZXhwYW5kXCJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImZlTW9ycGhvbG9neVwiLCB7XG4gICAgb3BlcmF0b3I6IFwiZGlsYXRlXCIsXG4gICAgcmFkaXVzOiAwLjUgLyB6b29tXG4gIH0pKSk7XG59XG5cbnZhciBSZW5kZXJlZFNoYXBlID0gLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oZnVuY3Rpb24gUmVuZGVyZWRTaGFwZShfcmVmKSB7XG4gIHZhciBzaGFwZSA9IF9yZWYuc2hhcGUsXG4gICAgICB1dGlscyA9IF9yZWYudXRpbHMsXG4gICAgICBpc0VkaXRpbmcgPSBfcmVmLmlzRWRpdGluZyxcbiAgICAgIGlzSG92ZXJlZCA9IF9yZWYuaXNIb3ZlcmVkLFxuICAgICAgaXNCaW5kaW5nID0gX3JlZi5pc0JpbmRpbmcsXG4gICAgICBpc1NlbGVjdGVkID0gX3JlZi5pc1NlbGVjdGVkLFxuICAgICAgaXNEYXJrTW9kZSA9IF9yZWYuaXNEYXJrTW9kZSxcbiAgICAgIGlzQ3VycmVudFBhcmVudCA9IF9yZWYuaXNDdXJyZW50UGFyZW50O1xuICByZXR1cm4gdXRpbHMucmVuZGVyKHNoYXBlLCB7XG4gICAgaXNFZGl0aW5nOiBpc0VkaXRpbmcsXG4gICAgaXNIb3ZlcmVkOiBpc0hvdmVyZWQsXG4gICAgaXNTZWxlY3RlZDogaXNTZWxlY3RlZCxcbiAgICBpc0JpbmRpbmc6IGlzQmluZGluZyxcbiAgICBpc0RhcmtNb2RlOiBpc0RhcmtNb2RlLFxuICAgIGlzQ3VycmVudFBhcmVudDogaXNDdXJyZW50UGFyZW50XG4gIH0pO1xufSwgZnVuY3Rpb24gKHByZXYsIG5leHQpIHtcbiAgaWYgKHByZXYuaXNFZGl0aW5nICE9PSBuZXh0LmlzRWRpdGluZyB8fCBwcmV2LmlzSG92ZXJlZCAhPT0gbmV4dC5pc0hvdmVyZWQgfHwgcHJldi5pc1NlbGVjdGVkICE9PSBuZXh0LmlzU2VsZWN0ZWQgfHwgcHJldi5pc0RhcmtNb2RlICE9PSBuZXh0LmlzRGFya01vZGUgfHwgcHJldi5pc0JpbmRpbmcgIT09IG5leHQuaXNCaW5kaW5nIHx8IHByZXYuaXNDdXJyZW50UGFyZW50ICE9PSBuZXh0LmlzQ3VycmVudFBhcmVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChuZXh0LnNoYXBlICE9PSBwcmV2LnNoYXBlKSB7XG4gICAgcmV0dXJuICFuZXh0LnV0aWxzLnNob3VsZFJlbmRlcihuZXh0LnNoYXBlLCBwcmV2LnNoYXBlKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufSk7XG5cbmZ1bmN0aW9uIEVkaXRpbmdUZXh0U2hhcGUoX3JlZikge1xuICB2YXIgc2hhcGUgPSBfcmVmLnNoYXBlLFxuICAgICAgdXRpbHMgPSBfcmVmLnV0aWxzLFxuICAgICAgaXNFZGl0aW5nID0gX3JlZi5pc0VkaXRpbmcsXG4gICAgICBpc0hvdmVyZWQgPSBfcmVmLmlzSG92ZXJlZCxcbiAgICAgIGlzQmluZGluZyA9IF9yZWYuaXNCaW5kaW5nLFxuICAgICAgaXNTZWxlY3RlZCA9IF9yZWYuaXNTZWxlY3RlZCxcbiAgICAgIGlzRGFya01vZGUgPSBfcmVmLmlzRGFya01vZGUsXG4gICAgICBpc0N1cnJlbnRQYXJlbnQgPSBfcmVmLmlzQ3VycmVudFBhcmVudDtcbiAgdmFyIHJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgcmV0dXJuIHV0aWxzLnJlbmRlcihzaGFwZSwge1xuICAgIHJlZjogcmVmLFxuICAgIGlzRWRpdGluZzogaXNFZGl0aW5nLFxuICAgIGlzSG92ZXJlZDogaXNIb3ZlcmVkLFxuICAgIGlzU2VsZWN0ZWQ6IGlzU2VsZWN0ZWQsXG4gICAgaXNDdXJyZW50UGFyZW50OiBpc0N1cnJlbnRQYXJlbnQsXG4gICAgaXNCaW5kaW5nOiBpc0JpbmRpbmcsXG4gICAgaXNEYXJrTW9kZTogaXNEYXJrTW9kZVxuICB9KTtcbn1cblxudmFyIFNoYXBlID0gLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHNoYXBlID0gX3JlZi5zaGFwZSxcbiAgICAgIGlzRWRpdGluZyA9IF9yZWYuaXNFZGl0aW5nLFxuICAgICAgaXNIb3ZlcmVkID0gX3JlZi5pc0hvdmVyZWQsXG4gICAgICBpc1NlbGVjdGVkID0gX3JlZi5pc1NlbGVjdGVkLFxuICAgICAgaXNCaW5kaW5nID0gX3JlZi5pc0JpbmRpbmcsXG4gICAgICBpc0RhcmtNb2RlID0gX3JlZi5pc0RhcmtNb2RlLFxuICAgICAgaXNDdXJyZW50UGFyZW50ID0gX3JlZi5pc0N1cnJlbnRQYXJlbnQ7XG5cbiAgdmFyIF91c2VUTENvbnRleHQgPSB1c2VUTENvbnRleHQoKSxcbiAgICAgIHNoYXBlVXRpbHMgPSBfdXNlVExDb250ZXh0LnNoYXBlVXRpbHM7XG5cbiAgdmFyIGV2ZW50cyA9IHVzZVNoYXBlRXZlbnRzKHNoYXBlLmlkLCBpc0N1cnJlbnRQYXJlbnQpO1xuICB2YXIgdXRpbHMgPSBzaGFwZVV0aWxzW3NoYXBlLnR5cGVdO1xuICB2YXIgY2VudGVyID0gdXRpbHMuZ2V0Q2VudGVyKHNoYXBlKTtcbiAgdmFyIHJvdGF0aW9uID0gKHNoYXBlLnJvdGF0aW9uIHx8IDApICogKDE4MCAvIE1hdGguUEkpO1xuICB2YXIgdHJhbnNmb3JtID0gXCJyb3RhdGUoXCIgKyByb3RhdGlvbiArIFwiLCBcIiArIGNlbnRlciArIFwiKSB0cmFuc2xhdGUoXCIgKyBzaGFwZS5wb2ludCArIFwiKVwiO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIiwgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogaXNDdXJyZW50UGFyZW50ID8gJ3RsLXNoYXBlLWdyb3VwIHRsLWN1cnJlbnQtcGFyZW50JyA6ICd0bC1zaGFwZS1ncm91cCcsXG4gICAgaWQ6IHNoYXBlLmlkLFxuICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgIGZpbHRlcjogaXNIb3ZlcmVkID8gJ3VybCgjZXhwYW5kKScgOiAnbm9uZSdcbiAgfSwgZXZlbnRzKSwgaXNFZGl0aW5nICYmIHV0aWxzLmlzRWRpdGFibGVUZXh0ID8gUmVhY3QuY3JlYXRlRWxlbWVudChFZGl0aW5nVGV4dFNoYXBlLCB7XG4gICAgc2hhcGU6IHNoYXBlLFxuICAgIGlzQmluZGluZzogZmFsc2UsXG4gICAgaXNDdXJyZW50UGFyZW50OiBmYWxzZSxcbiAgICBpc0RhcmtNb2RlOiBpc0RhcmtNb2RlLFxuICAgIGlzRWRpdGluZzogdHJ1ZSxcbiAgICBpc0hvdmVyZWQ6IGZhbHNlLFxuICAgIGlzU2VsZWN0ZWQ6IGZhbHNlLFxuICAgIHV0aWxzOiB1dGlsc1xuICB9KSA6IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVuZGVyZWRTaGFwZSwge1xuICAgIHNoYXBlOiBzaGFwZSxcbiAgICB1dGlsczogdXRpbHMsXG4gICAgaXNCaW5kaW5nOiBpc0JpbmRpbmcsXG4gICAgaXNDdXJyZW50UGFyZW50OiBpc0N1cnJlbnRQYXJlbnQsXG4gICAgaXNEYXJrTW9kZTogaXNEYXJrTW9kZSxcbiAgICBpc0VkaXRpbmc6IGlzRWRpdGluZyxcbiAgICBpc0hvdmVyZWQ6IGlzSG92ZXJlZCxcbiAgICBpc1NlbGVjdGVkOiBpc1NlbGVjdGVkXG4gIH0pKTtcbn0pO1xuXG52YXIgQ2VudGVySGFuZGxlID0gLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGJvdW5kcyA9IF9yZWYuYm91bmRzLFxuICAgICAgaXNMb2NrZWQgPSBfcmVmLmlzTG9ja2VkO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xuICAgIGNsYXNzTmFtZTogaXNMb2NrZWQgPyAndGwtYm91bmRzLWNlbnRlciB0bC1kYXNoZWQnIDogJ3RsLWJvdW5kcy1jZW50ZXInLFxuICAgIHg6IC0xLFxuICAgIHk6IC0xLFxuICAgIHdpZHRoOiBib3VuZHMud2lkdGggKyAyLFxuICAgIGhlaWdodDogYm91bmRzLmhlaWdodCArIDIsXG4gICAgcG9pbnRlckV2ZW50czogXCJub25lXCJcbiAgfSk7XG59KTtcblxudmFyIFJvdGF0ZUhhbmRsZSA9IC8qI19fUFVSRV9fKi9SZWFjdC5tZW1vKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBib3VuZHMgPSBfcmVmLmJvdW5kcyxcbiAgICAgIHNpemUgPSBfcmVmLnNpemU7XG4gIHZhciBldmVudHMgPSB1c2VCb3VuZHNIYW5kbGVFdmVudHMoJ3JvdGF0ZScpO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIiwge1xuICAgIGN1cnNvcjogXCJncmFiXCJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImNpcmNsZVwiLCBfZXh0ZW5kcyh7XG4gICAgY3g6IGJvdW5kcy53aWR0aCAvIDIsXG4gICAgY3k6IHNpemUgKiAtMixcbiAgICByOiBzaXplICogMixcbiAgICBmaWxsOiBcInRyYW5zcGFyZW50XCIsXG4gICAgc3Ryb2tlOiBcIm5vbmVcIixcbiAgICBwb2ludGVyRXZlbnRzOiBcImFsbFwiXG4gIH0sIGV2ZW50cykpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIsIHtcbiAgICBjbGFzc05hbWU6IFwidGwtcm90YXRlLWhhbmRsZVwiLFxuICAgIGN4OiBib3VuZHMud2lkdGggLyAyLFxuICAgIGN5OiBzaXplICogLTIsXG4gICAgcjogc2l6ZSAvIDIsXG4gICAgcG9pbnRlckV2ZW50czogXCJub25lXCJcbiAgfSkpO1xufSk7XG5cbnZhciBfY29ybmVyQmdDbGFzc25hbWVzO1xudmFyIGNvcm5lckJnQ2xhc3NuYW1lcyA9IChfY29ybmVyQmdDbGFzc25hbWVzID0ge30sIF9jb3JuZXJCZ0NsYXNzbmFtZXNbZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Ub3BMZWZ0XSA9ICd0bC10cmFuc3BhcmVudCB0bC1jdXJzb3ItbndzZScsIF9jb3JuZXJCZ0NsYXNzbmFtZXNbZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Ub3BSaWdodF0gPSAndGwtdHJhbnNwYXJlbnQgdGwtY3Vyc29yLW5lc3cnLCBfY29ybmVyQmdDbGFzc25hbWVzW2V4cG9ydHMuVExCb3VuZHNDb3JuZXIuQm90dG9tUmlnaHRdID0gJ3RsLXRyYW5zcGFyZW50IHRsLWN1cnNvci1ud3NlJywgX2Nvcm5lckJnQ2xhc3NuYW1lc1tleHBvcnRzLlRMQm91bmRzQ29ybmVyLkJvdHRvbUxlZnRdID0gJ3RsLXRyYW5zcGFyZW50IHRsLWN1cnNvci1uZXN3JywgX2Nvcm5lckJnQ2xhc3NuYW1lcyk7XG52YXIgQ29ybmVySGFuZGxlID0gLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHNpemUgPSBfcmVmLnNpemUsXG4gICAgICBjb3JuZXIgPSBfcmVmLmNvcm5lcixcbiAgICAgIGJvdW5kcyA9IF9yZWYuYm91bmRzO1xuICB2YXIgZXZlbnRzID0gdXNlQm91bmRzSGFuZGxlRXZlbnRzKGNvcm5lcik7XG4gIHZhciBpc1RvcCA9IGNvcm5lciA9PT0gZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Ub3BMZWZ0IHx8IGNvcm5lciA9PT0gZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Ub3BSaWdodDtcbiAgdmFyIGlzTGVmdCA9IGNvcm5lciA9PT0gZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Ub3BMZWZ0IHx8IGNvcm5lciA9PT0gZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Cb3R0b21MZWZ0O1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIiwgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChcInJlY3RcIiwgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogY29ybmVyQmdDbGFzc25hbWVzW2Nvcm5lcl0sXG4gICAgeDogKGlzTGVmdCA/IC0xIDogYm91bmRzLndpZHRoICsgMSkgLSBzaXplLFxuICAgIHk6IChpc1RvcCA/IC0xIDogYm91bmRzLmhlaWdodCArIDEpIC0gc2l6ZSxcbiAgICB3aWR0aDogc2l6ZSAqIDIsXG4gICAgaGVpZ2h0OiBzaXplICogMixcbiAgICBwb2ludGVyRXZlbnRzOiBcImFsbFwiXG4gIH0sIGV2ZW50cykpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7XG4gICAgY2xhc3NOYW1lOiBcInRsLWNvcm5lci1oYW5kbGVcIixcbiAgICB4OiAoaXNMZWZ0ID8gLTEgOiBib3VuZHMud2lkdGggKyAxKSAtIHNpemUgLyAyLFxuICAgIHk6IChpc1RvcCA/IC0xIDogYm91bmRzLmhlaWdodCArIDEpIC0gc2l6ZSAvIDIsXG4gICAgd2lkdGg6IHNpemUsXG4gICAgaGVpZ2h0OiBzaXplLFxuICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiXG4gIH0pKTtcbn0pO1xuXG52YXIgX2VkZ2VDbGFzc25hbWVzO1xudmFyIGVkZ2VDbGFzc25hbWVzID0gKF9lZGdlQ2xhc3NuYW1lcyA9IHt9LCBfZWRnZUNsYXNzbmFtZXNbZXhwb3J0cy5UTEJvdW5kc0VkZ2UuVG9wXSA9ICd0bC10cmFuc3BhcmVudCB0bC1jdXJzb3ItbnMnLCBfZWRnZUNsYXNzbmFtZXNbZXhwb3J0cy5UTEJvdW5kc0VkZ2UuUmlnaHRdID0gJ3RsLXRyYW5zcGFyZW50IHRsLWN1cnNvci1ldycsIF9lZGdlQ2xhc3NuYW1lc1tleHBvcnRzLlRMQm91bmRzRWRnZS5Cb3R0b21dID0gJ3RsLXRyYW5zcGFyZW50IHRsLWN1cnNvci1ucycsIF9lZGdlQ2xhc3NuYW1lc1tleHBvcnRzLlRMQm91bmRzRWRnZS5MZWZ0XSA9ICd0bC10cmFuc3BhcmVudCB0bC1jdXJzb3ItZXcnLCBfZWRnZUNsYXNzbmFtZXMpO1xudmFyIEVkZ2VIYW5kbGUgPSAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyhmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgc2l6ZSA9IF9yZWYuc2l6ZSxcbiAgICAgIGJvdW5kcyA9IF9yZWYuYm91bmRzLFxuICAgICAgZWRnZSA9IF9yZWYuZWRnZTtcbiAgdmFyIGV2ZW50cyA9IHVzZUJvdW5kc0hhbmRsZUV2ZW50cyhlZGdlKTtcbiAgdmFyIGlzSG9yaXpvbnRhbCA9IGVkZ2UgPT09IGV4cG9ydHMuVExCb3VuZHNFZGdlLlRvcCB8fCBlZGdlID09PSBleHBvcnRzLlRMQm91bmRzRWRnZS5Cb3R0b207XG4gIHZhciBpc0ZhckVkZ2UgPSBlZGdlID09PSBleHBvcnRzLlRMQm91bmRzRWRnZS5SaWdodCB8fCBlZGdlID09PSBleHBvcnRzLlRMQm91bmRzRWRnZS5Cb3R0b207XG4gIHZhciBoZWlnaHQgPSBib3VuZHMuaGVpZ2h0LFxuICAgICAgd2lkdGggPSBib3VuZHMud2lkdGg7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCBfZXh0ZW5kcyh7XG4gICAgY2xhc3NOYW1lOiBlZGdlQ2xhc3NuYW1lc1tlZGdlXSxcbiAgICB4OiBpc0hvcml6b250YWwgPyBzaXplIC8gMiA6IChpc0ZhckVkZ2UgPyB3aWR0aCArIDEgOiAtMSkgLSBzaXplIC8gMixcbiAgICB5OiBpc0hvcml6b250YWwgPyAoaXNGYXJFZGdlID8gaGVpZ2h0ICsgMSA6IC0xKSAtIHNpemUgLyAyIDogc2l6ZSAvIDIsXG4gICAgd2lkdGg6IGlzSG9yaXpvbnRhbCA/IE1hdGgubWF4KDAsIHdpZHRoICsgMSAtIHNpemUpIDogc2l6ZSxcbiAgICBoZWlnaHQ6IGlzSG9yaXpvbnRhbCA/IHNpemUgOiBNYXRoLm1heCgwLCBoZWlnaHQgKyAxIC0gc2l6ZSlcbiAgfSwgZXZlbnRzKSk7XG59KTtcblxuZnVuY3Rpb24gQm91bmRzKF9yZWYpIHtcbiAgdmFyIHpvb20gPSBfcmVmLnpvb20sXG4gICAgICBib3VuZHMgPSBfcmVmLmJvdW5kcyxcbiAgICAgIHJvdGF0aW9uID0gX3JlZi5yb3RhdGlvbixcbiAgICAgIGlzTG9ja2VkID0gX3JlZi5pc0xvY2tlZDtcbiAgdmFyIHNpemUgPSAoVXRpbHMuaXNNb2JpbGUoKSA/IDEwIDogOCkgLyB6b29tOyAvLyBUb3VjaCB0YXJnZXQgc2l6ZVxuXG4gIHZhciBjZW50ZXIgPSBVdGlscy5nZXRCb3VuZHNDZW50ZXIoYm91bmRzKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHtcbiAgICBwb2ludGVyRXZlbnRzOiBcImFsbFwiLFxuICAgIHRyYW5zZm9ybTogXCJcXG4gICAgICAgIHJvdGF0ZShcIiArIHJvdGF0aW9uICogKDE4MCAvIE1hdGguUEkpICsgXCIsXCIgKyBjZW50ZXIgKyBcIilcXG4gICAgICAgIHRyYW5zbGF0ZShcIiArIGJvdW5kcy5taW5YICsgXCIsXCIgKyBib3VuZHMubWluWSArIFwiKVxcbiAgICAgICAgcm90YXRlKFwiICsgKGJvdW5kcy5yb3RhdGlvbiB8fCAwKSAqICgxODAgLyBNYXRoLlBJKSArIFwiLCAwLCAwKVwiXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2VudGVySGFuZGxlLCB7XG4gICAgYm91bmRzOiBib3VuZHMsXG4gICAgaXNMb2NrZWQ6IGlzTG9ja2VkXG4gIH0pLCAhaXNMb2NrZWQgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChFZGdlSGFuZGxlLCB7XG4gICAgc2l6ZTogc2l6ZSxcbiAgICBib3VuZHM6IGJvdW5kcyxcbiAgICBlZGdlOiBleHBvcnRzLlRMQm91bmRzRWRnZS5Ub3BcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRWRnZUhhbmRsZSwge1xuICAgIHNpemU6IHNpemUsXG4gICAgYm91bmRzOiBib3VuZHMsXG4gICAgZWRnZTogZXhwb3J0cy5UTEJvdW5kc0VkZ2UuUmlnaHRcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRWRnZUhhbmRsZSwge1xuICAgIHNpemU6IHNpemUsXG4gICAgYm91bmRzOiBib3VuZHMsXG4gICAgZWRnZTogZXhwb3J0cy5UTEJvdW5kc0VkZ2UuQm90dG9tXG4gIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KEVkZ2VIYW5kbGUsIHtcbiAgICBzaXplOiBzaXplLFxuICAgIGJvdW5kczogYm91bmRzLFxuICAgIGVkZ2U6IGV4cG9ydHMuVExCb3VuZHNFZGdlLkxlZnRcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29ybmVySGFuZGxlLCB7XG4gICAgc2l6ZTogc2l6ZSxcbiAgICBib3VuZHM6IGJvdW5kcyxcbiAgICBjb3JuZXI6IGV4cG9ydHMuVExCb3VuZHNDb3JuZXIuVG9wTGVmdFxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChDb3JuZXJIYW5kbGUsIHtcbiAgICBzaXplOiBzaXplLFxuICAgIGJvdW5kczogYm91bmRzLFxuICAgIGNvcm5lcjogZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Ub3BSaWdodFxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChDb3JuZXJIYW5kbGUsIHtcbiAgICBzaXplOiBzaXplLFxuICAgIGJvdW5kczogYm91bmRzLFxuICAgIGNvcm5lcjogZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Cb3R0b21SaWdodFxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChDb3JuZXJIYW5kbGUsIHtcbiAgICBzaXplOiBzaXplLFxuICAgIGJvdW5kczogYm91bmRzLFxuICAgIGNvcm5lcjogZXhwb3J0cy5UTEJvdW5kc0Nvcm5lci5Cb3R0b21MZWZ0XG4gIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdGF0ZUhhbmRsZSwge1xuICAgIHNpemU6IHNpemUsXG4gICAgYm91bmRzOiBib3VuZHNcbiAgfSkpKTtcbn1cblxuZnVuY3Rpb24gdXNlQm91bmRzRXZlbnRzKCkge1xuICB2YXIgX3VzZVRMQ29udGV4dCA9IHVzZVRMQ29udGV4dCgpLFxuICAgICAgY2FsbGJhY2tzID0gX3VzZVRMQ29udGV4dC5jYWxsYmFja3M7XG5cbiAgdmFyIG9uUG9pbnRlckRvd24gPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xuICAgIHZhciBfZSRjdXJyZW50VGFyZ2V0O1xuXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAoX2UkY3VycmVudFRhcmdldCA9IGUuY3VycmVudFRhcmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lJGN1cnJlbnRUYXJnZXQuc2V0UG9pbnRlckNhcHR1cmUoZS5wb2ludGVySWQpO1xuICAgIHZhciBpbmZvID0gaW5wdXRzLnBvaW50ZXJEb3duKGUsICdib3VuZHMnKTtcbiAgICBjYWxsYmFja3Mub25Qb2ludEJvdW5kcyA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uUG9pbnRCb3VuZHMoaW5mbywgZSk7XG4gICAgY2FsbGJhY2tzLm9uUG9pbnRlckRvd24gPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vblBvaW50ZXJEb3duKGluZm8sIGUpO1xuICB9LCBbY2FsbGJhY2tzXSk7XG4gIHZhciBvblBvaW50ZXJVcCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB2YXIgaXNEb3VibGVDbGljayA9IGlucHV0cy5pc0RvdWJsZUNsaWNrKCk7XG4gICAgdmFyIGluZm8gPSBpbnB1dHMucG9pbnRlclVwKGUsICdib3VuZHMnKTtcblxuICAgIGlmIChlLmN1cnJlbnRUYXJnZXQuaGFzUG9pbnRlckNhcHR1cmUoZS5wb2ludGVySWQpKSB7XG4gICAgICB2YXIgX2UkY3VycmVudFRhcmdldDI7XG5cbiAgICAgIChfZSRjdXJyZW50VGFyZ2V0MiA9IGUuY3VycmVudFRhcmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lJGN1cnJlbnRUYXJnZXQyLnJlbGVhc2VQb2ludGVyQ2FwdHVyZShlLnBvaW50ZXJJZCk7XG4gICAgfVxuXG4gICAgaWYgKGlzRG91YmxlQ2xpY2sgJiYgIShpbmZvLmFsdEtleSB8fCBpbmZvLm1ldGFLZXkpKSB7XG4gICAgICBjYWxsYmFja3Mub25Eb3VibGVDbGlja0JvdW5kcyA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uRG91YmxlQ2xpY2tCb3VuZHMoaW5mbywgZSk7XG4gICAgfVxuXG4gICAgY2FsbGJhY2tzLm9uUmVsZWFzZUJvdW5kcyA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uUmVsZWFzZUJvdW5kcyhpbmZvLCBlKTtcbiAgICBjYWxsYmFja3Mub25Qb2ludGVyVXAgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vblBvaW50ZXJVcChpbmZvLCBlKTtcbiAgfSwgW2NhbGxiYWNrc10pO1xuICB2YXIgb25Qb2ludGVyTW92ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBpZiAoaW5wdXRzLnBvaW50ZXIgJiYgZS5wb2ludGVySWQgIT09IGlucHV0cy5wb2ludGVyLnBvaW50ZXJJZCkgcmV0dXJuO1xuXG4gICAgaWYgKGUuY3VycmVudFRhcmdldC5oYXNQb2ludGVyQ2FwdHVyZShlLnBvaW50ZXJJZCkpIHtcbiAgICAgIGNhbGxiYWNrcy5vbkRyYWdCb3VuZHMgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vbkRyYWdCb3VuZHMoaW5wdXRzLnBvaW50ZXJNb3ZlKGUsICdib3VuZHMnKSwgZSk7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSBpbnB1dHMucG9pbnRlck1vdmUoZSwgJ2JvdW5kcycpO1xuICAgIGNhbGxiYWNrcy5vblBvaW50ZXJNb3ZlID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25Qb2ludGVyTW92ZShpbmZvLCBlKTtcbiAgfSwgW2NhbGxiYWNrc10pO1xuICB2YXIgb25Qb2ludGVyRW50ZXIgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xuICAgIGNhbGxiYWNrcy5vbkhvdmVyQm91bmRzID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25Ib3ZlckJvdW5kcyhpbnB1dHMucG9pbnRlckVudGVyKGUsICdib3VuZHMnKSwgZSk7XG4gIH0sIFtjYWxsYmFja3NdKTtcbiAgdmFyIG9uUG9pbnRlckxlYXZlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGUpIHtcbiAgICBjYWxsYmFja3Mub25VbmhvdmVyQm91bmRzID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25VbmhvdmVyQm91bmRzKGlucHV0cy5wb2ludGVyRW50ZXIoZSwgJ2JvdW5kcycpLCBlKTtcbiAgfSwgW2NhbGxiYWNrc10pO1xuICB2YXIgb25Ub3VjaFN0YXJ0ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0sIFtdKTtcbiAgdmFyIG9uVG91Y2hFbmQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSwgW10pO1xuICByZXR1cm4ge1xuICAgIG9uUG9pbnRlckRvd246IG9uUG9pbnRlckRvd24sXG4gICAgb25Qb2ludGVyVXA6IG9uUG9pbnRlclVwLFxuICAgIG9uUG9pbnRlckVudGVyOiBvblBvaW50ZXJFbnRlcixcbiAgICBvblBvaW50ZXJNb3ZlOiBvblBvaW50ZXJNb3ZlLFxuICAgIG9uUG9pbnRlckxlYXZlOiBvblBvaW50ZXJMZWF2ZSxcbiAgICBvblRvdWNoU3RhcnQ6IG9uVG91Y2hTdGFydCxcbiAgICBvblRvdWNoRW5kOiBvblRvdWNoRW5kXG4gIH07XG59XG5cbmZ1bmN0aW9uIEJvdW5kc0JnKF9yZWYpIHtcbiAgdmFyIGJvdW5kcyA9IF9yZWYuYm91bmRzLFxuICAgICAgcm90YXRpb24gPSBfcmVmLnJvdGF0aW9uO1xuICB2YXIgZXZlbnRzID0gdXNlQm91bmRzRXZlbnRzKCk7XG4gIHZhciB3aWR0aCA9IGJvdW5kcy53aWR0aCxcbiAgICAgIGhlaWdodCA9IGJvdW5kcy5oZWlnaHQ7XG4gIHZhciBjZW50ZXIgPSBVdGlscy5nZXRCb3VuZHNDZW50ZXIoYm91bmRzKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIsIF9leHRlbmRzKHtcbiAgICBjbGFzc05hbWU6IFwidGwtYm91bmRzLWJnXCIsXG4gICAgd2lkdGg6IE1hdGgubWF4KDEsIHdpZHRoKSxcbiAgICBoZWlnaHQ6IE1hdGgubWF4KDEsIGhlaWdodCksXG4gICAgdHJhbnNmb3JtOiBcIlxcbiAgICAgICAgcm90YXRlKFwiICsgcm90YXRpb24gKiAoMTgwIC8gTWF0aC5QSSkgKyBcIixcIiArIGNlbnRlciArIFwiKVxcbiAgICAgICAgdHJhbnNsYXRlKFwiICsgYm91bmRzLm1pblggKyBcIixcIiArIGJvdW5kcy5taW5ZICsgXCIpXFxuICAgICAgICByb3RhdGUoXCIgKyAoYm91bmRzLnJvdGF0aW9uIHx8IDApICogKDE4MCAvIE1hdGguUEkpICsgXCIsIDAsIDApXCJcbiAgfSwgZXZlbnRzKSk7XG59XG5cbnZhciBIYW5kbGUgPSAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyhmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgaWQgPSBfcmVmLmlkLFxuICAgICAgcG9pbnQgPSBfcmVmLnBvaW50O1xuICB2YXIgZXZlbnRzID0gdXNlSGFuZGxlRXZlbnRzKGlkKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJnXCIsIF9leHRlbmRzKHtcbiAgICBrZXk6IGlkLFxuICAgIGNsYXNzTmFtZTogXCJoYW5kbGVzXCIsXG4gICAgcG9pbnRlckV2ZW50czogXCJhbGxcIixcbiAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiICsgcG9pbnQgKyBcIilcIlxuICB9LCBldmVudHMpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIsIHtcbiAgICBjbGFzc05hbWU6IFwidGwtaGFuZGxlLWJnXCIsXG4gICAgcjogMTJcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ1c2VcIiwge1xuICAgIGhyZWY6IFwiI2hhbmRsZVwiLFxuICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiXG4gIH0pKTtcbn0pO1xuXG52YXIgdG9BbmdsZSA9IDE4MCAvIE1hdGguUEk7XG52YXIgSGFuZGxlcyA9IC8qI19fUFVSRV9fKi9SZWFjdC5tZW1vKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBzaGFwZSA9IF9yZWYuc2hhcGU7XG5cbiAgdmFyIF91c2VUTENvbnRleHQgPSB1c2VUTENvbnRleHQoKSxcbiAgICAgIHNoYXBlVXRpbHMgPSBfdXNlVExDb250ZXh0LnNoYXBlVXRpbHM7XG5cbiAgdmFyIGNlbnRlciA9IHNoYXBlVXRpbHNbc2hhcGUudHlwZV0uZ2V0Q2VudGVyKHNoYXBlKTtcblxuICBpZiAoc2hhcGUuaGFuZGxlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIiwge1xuICAgIHRyYW5zZm9ybTogXCJyb3RhdGUoXCIgKyAoc2hhcGUucm90YXRpb24gfHwgMCkgKiB0b0FuZ2xlICsgXCIsXCIgKyBjZW50ZXIgKyBcIilcIlxuICB9LCBPYmplY3QudmFsdWVzKHNoYXBlLmhhbmRsZXMpLm1hcChmdW5jdGlvbiAoaGFuZGxlKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSGFuZGxlLCB7XG4gICAgICBrZXk6IGhhbmRsZS5pZCxcbiAgICAgIGlkOiBoYW5kbGUuaWQsXG4gICAgICBwb2ludDogVmVjLmFkZChoYW5kbGUucG9pbnQsIHNoYXBlLnBvaW50KVxuICAgIH0pO1xuICB9KSk7XG59KTtcblxuZnVuY3Rpb24gUGFnZShfcmVmKSB7XG4gIHZhciBwYWdlID0gX3JlZi5wYWdlLFxuICAgICAgcGFnZVN0YXRlID0gX3JlZi5wYWdlU3RhdGUsXG4gICAgICBoaWRlQm91bmRzID0gX3JlZi5oaWRlQm91bmRzO1xuXG4gIHZhciBfdXNlVExDb250ZXh0ID0gdXNlVExDb250ZXh0KCksXG4gICAgICBjYWxsYmFja3MgPSBfdXNlVExDb250ZXh0LmNhbGxiYWNrcyxcbiAgICAgIHNoYXBlVXRpbHMgPSBfdXNlVExDb250ZXh0LnNoYXBlVXRpbHM7XG5cbiAgdXNlUmVuZGVyT25SZXNpemUoKTtcbiAgdmFyIHNoYXBlVHJlZSA9IHVzZVNoYXBlVHJlZShwYWdlLCBwYWdlU3RhdGUsIHNoYXBlVXRpbHMsIHBhZ2VTdGF0ZSwgY2FsbGJhY2tzLm9uQ2hhbmdlKTtcblxuICB2YXIgX3VzZUhhbmRsZXMgPSB1c2VIYW5kbGVzKHBhZ2UsIHBhZ2VTdGF0ZSksXG4gICAgICBzaGFwZVdpdGhIYW5kbGVzID0gX3VzZUhhbmRsZXMuc2hhcGVXaXRoSGFuZGxlcztcblxuICB2YXIgX3VzZVNlbGVjdGlvbiA9IHVzZVNlbGVjdGlvbihwYWdlLCBwYWdlU3RhdGUsIHNoYXBlVXRpbHMpLFxuICAgICAgYm91bmRzID0gX3VzZVNlbGVjdGlvbi5ib3VuZHMsXG4gICAgICBpc0xvY2tlZCA9IF91c2VTZWxlY3Rpb24uaXNMb2NrZWQsXG4gICAgICByb3RhdGlvbiA9IF91c2VTZWxlY3Rpb24ucm90YXRpb247XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGJvdW5kcyAmJiAhaGlkZUJvdW5kcyAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KEJvdW5kc0JnLCB7XG4gICAgYm91bmRzOiBib3VuZHMsXG4gICAgcm90YXRpb246IHJvdGF0aW9uXG4gIH0pLCBzaGFwZVRyZWUubWFwKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2hhcGVOb2RlLCBfZXh0ZW5kcyh7XG4gICAgICBrZXk6IG5vZGUuc2hhcGUuaWQsXG4gICAgICBhbGxvd0hvdmVyczogdHJ1ZVxuICAgIH0sIG5vZGUpKTtcbiAgfSksIGJvdW5kcyAmJiAhaGlkZUJvdW5kcyAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KEJvdW5kcywge1xuICAgIHpvb206IHBhZ2VTdGF0ZS5jYW1lcmEuem9vbSxcbiAgICBib3VuZHM6IGJvdW5kcyxcbiAgICBpc0xvY2tlZDogaXNMb2NrZWQsXG4gICAgcm90YXRpb246IHJvdGF0aW9uXG4gIH0pLCBzaGFwZVdpdGhIYW5kbGVzICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSGFuZGxlcywge1xuICAgIHNoYXBlOiBzaGFwZVdpdGhIYW5kbGVzXG4gIH0pKTtcbn1cbnZhciBTaGFwZU5vZGUgPSAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyhmdW5jdGlvbiAoX3JlZjIpIHtcbiAgdmFyIHNoYXBlID0gX3JlZjIuc2hhcGUsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYyLmNoaWxkcmVuLFxuICAgICAgaXNFZGl0aW5nID0gX3JlZjIuaXNFZGl0aW5nLFxuICAgICAgaXNIb3ZlcmVkID0gX3JlZjIuaXNIb3ZlcmVkLFxuICAgICAgaXNEYXJrTW9kZSA9IF9yZWYyLmlzRGFya01vZGUsXG4gICAgICBpc1NlbGVjdGVkID0gX3JlZjIuaXNTZWxlY3RlZCxcbiAgICAgIGlzQmluZGluZyA9IF9yZWYyLmlzQmluZGluZyxcbiAgICAgIGlzQ3VycmVudFBhcmVudCA9IF9yZWYyLmlzQ3VycmVudFBhcmVudCxcbiAgICAgIGFsbG93SG92ZXJzID0gX3JlZjIuYWxsb3dIb3ZlcnM7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBSZWFjdC5jcmVhdGVFbGVtZW50KFNoYXBlLCB7XG4gICAgc2hhcGU6IHNoYXBlLFxuICAgIGlzRWRpdGluZzogaXNFZGl0aW5nLFxuICAgIGlzSG92ZXJlZDogYWxsb3dIb3ZlcnMgJiYgaXNIb3ZlcmVkLFxuICAgIGlzU2VsZWN0ZWQ6IGlzU2VsZWN0ZWQsXG4gICAgaXNEYXJrTW9kZTogaXNEYXJrTW9kZSxcbiAgICBpc0JpbmRpbmc6IGlzQmluZGluZyxcbiAgICBpc0N1cnJlbnRQYXJlbnQ6IGlzQ3VycmVudFBhcmVudFxuICB9KSwgY2hpbGRyZW4gJiYgY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZE5vZGUpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChTaGFwZU5vZGUsIF9leHRlbmRzKHtcbiAgICAgIGtleTogY2hpbGROb2RlLnNoYXBlLmlkLFxuICAgICAgYWxsb3dIb3ZlcnM6IGFsbG93SG92ZXJzXG4gICAgfSwgY2hpbGROb2RlKSk7XG4gIH0pKTtcbn0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnQgKi9cbmZ1bmN0aW9uIHVzZVByZXZlbnROYXZpZ2F0aW9uKHJDYW52YXMpIHtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJldmVudEdlc3R1cmVOYXZpZ2F0aW9uID0gZnVuY3Rpb24gcHJldmVudEdlc3R1cmVOYXZpZ2F0aW9uKGV2ZW50KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG5cbiAgICB2YXIgcHJldmVudE5hdmlnYXRpb24gPSBmdW5jdGlvbiBwcmV2ZW50TmF2aWdhdGlvbihldmVudCkge1xuICAgICAgLy8gQ2VudGVyIHBvaW50IG9mIHRoZSB0b3VjaCBhcmVhXG4gICAgICB2YXIgdG91Y2hYUG9zaXRpb24gPSBldmVudC50b3VjaGVzWzBdLnBhZ2VYOyAvLyBTaXplIG9mIHRoZSB0b3VjaCBhcmVhXG5cbiAgICAgIHZhciB0b3VjaFhSYWRpdXMgPSBldmVudC50b3VjaGVzWzBdLnJhZGl1c1ggfHwgMDsgLy8gV2Ugc2V0IGEgdGhyZXNob2xkICgxMHB4KSBvbiBib3RoIHNpemVzIG9mIHRoZSBzY3JlZW4sXG4gICAgICAvLyBpZiB0aGUgdG91Y2ggYXJlYSBvdmVybGFwcyB3aXRoIHRoZSBzY3JlZW4gZWRnZXNcbiAgICAgIC8vIGl0J3MgbGlrZWx5IHRvIHRyaWdnZXIgdGhlIG5hdmlnYXRpb24uIFdlIHByZXZlbnQgdGhlXG4gICAgICAvLyB0b3VjaHN0YXJ0IGV2ZW50IGluIHRoYXQgY2FzZS5cblxuICAgICAgaWYgKHRvdWNoWFBvc2l0aW9uIC0gdG91Y2hYUmFkaXVzIDwgMTAgfHwgdG91Y2hYUG9zaXRpb24gKyB0b3VjaFhSYWRpdXMgPiB3aW5kb3cuaW5uZXJXaWR0aCAtIDEwKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBlbG0gPSByQ2FudmFzLmN1cnJlbnQ7XG4gICAgaWYgKCFlbG0pIHJldHVybjtcbiAgICBlbG0uYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHByZXZlbnRHZXN0dXJlTmF2aWdhdGlvbik7IC8vIEB0cy1pZ25vcmVcblxuICAgIGVsbS5hZGRFdmVudExpc3RlbmVyKCdnZXN0dXJlZW5kJywgcHJldmVudEdlc3R1cmVOYXZpZ2F0aW9uKTsgLy8gQHRzLWlnbm9yZVxuXG4gICAgZWxtLmFkZEV2ZW50TGlzdGVuZXIoJ2dlc3R1cmVjaGFuZ2UnLCBwcmV2ZW50R2VzdHVyZU5hdmlnYXRpb24pOyAvLyBAdHMtaWdub3JlXG5cbiAgICBlbG0uYWRkRXZlbnRMaXN0ZW5lcignZ2VzdHVyZXN0YXJ0JywgcHJldmVudEdlc3R1cmVOYXZpZ2F0aW9uKTsgLy8gQHRzLWlnbm9yZVxuXG4gICAgZWxtLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBwcmV2ZW50TmF2aWdhdGlvbik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChlbG0pIHtcbiAgICAgICAgZWxtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBwcmV2ZW50R2VzdHVyZU5hdmlnYXRpb24pOyAvLyBAdHMtaWdub3JlXG5cbiAgICAgICAgZWxtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2dlc3R1cmVlbmQnLCBwcmV2ZW50R2VzdHVyZU5hdmlnYXRpb24pOyAvLyBAdHMtaWdub3JlXG5cbiAgICAgICAgZWxtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2dlc3R1cmVjaGFuZ2UnLCBwcmV2ZW50R2VzdHVyZU5hdmlnYXRpb24pOyAvLyBAdHMtaWdub3JlXG5cbiAgICAgICAgZWxtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2dlc3R1cmVzdGFydCcsIHByZXZlbnRHZXN0dXJlTmF2aWdhdGlvbik7IC8vIEB0cy1pZ25vcmVcblxuICAgICAgICBlbG0ucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHByZXZlbnROYXZpZ2F0aW9uKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbckNhbnZhc10pO1xufVxuXG5mdW5jdGlvbiByZXNldEVycm9yKCkge1xufVxuXG52YXIgQ2FudmFzID0gLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oZnVuY3Rpb24gQ2FudmFzKF9yZWYpIHtcbiAgdmFyIHBhZ2UgPSBfcmVmLnBhZ2UsXG4gICAgICBwYWdlU3RhdGUgPSBfcmVmLnBhZ2VTdGF0ZSxcbiAgICAgIF9yZWYkaGlkZUJvdW5kcyA9IF9yZWYuaGlkZUJvdW5kcyxcbiAgICAgIGhpZGVCb3VuZHMgPSBfcmVmJGhpZGVCb3VuZHMgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRoaWRlQm91bmRzO1xuICB2YXIgckNhbnZhcyA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdmFyIHJHcm91cCA9IHVzZUNhbWVyYUNzcyhwYWdlU3RhdGUpO1xuICB1c2Vab29tRXZlbnRzKCk7XG4gIHVzZVNhZmFyaUZvY3VzT3V0Rml4KCk7XG4gIHVzZVByZXZlbnROYXZpZ2F0aW9uKHJDYW52YXMpO1xuICB2YXIgZXZlbnRzID0gdXNlQ2FudmFzRXZlbnRzKCk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IFwidGwtY29udGFpbmVyXCJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCBfZXh0ZW5kcyh7XG4gICAgaWQ6IFwiY2FudmFzXCIsXG4gICAgY2xhc3NOYW1lOiBcInRsLWNhbnZhc1wiLFxuICAgIHJlZjogckNhbnZhc1xuICB9LCBldmVudHMpLCBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0RXJyb3JCb3VuZGFyeS5FcnJvckJvdW5kYXJ5LCB7XG4gICAgRmFsbGJhY2tDb21wb25lbnQ6IEVycm9yRmFsbGJhY2ssXG4gICAgb25SZXNldDogcmVzZXRFcnJvclxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KERlZnMsIHtcbiAgICB6b29tOiBwYWdlU3RhdGUuY2FtZXJhLnpvb21cbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHtcbiAgICByZWY6IHJHcm91cCxcbiAgICBpZDogXCJ0bC1zaGFwZXNcIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFBhZ2UsIHtcbiAgICBwYWdlOiBwYWdlLFxuICAgIHBhZ2VTdGF0ZTogcGFnZVN0YXRlLFxuICAgIGhpZGVCb3VuZHM6IGhpZGVCb3VuZHNcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQnJ1c2gsIG51bGwpKSkpKTtcbn0pO1xuXG52YXIgX2V4Y2x1ZGVkID0gW1wic2hhcGVVdGlsc1wiLCBcInBhZ2VcIiwgXCJwYWdlU3RhdGVcIiwgXCJ0aGVtZVwiLCBcImhpZGVCb3VuZHNcIiwgXCJpc0RhcmtNb2RlXCIsIFwiaXNEZWJ1Z01vZGVcIiwgXCJpc1Blbk1vZGVcIl07XG5mdW5jdGlvbiBSZW5kZXJlcihfcmVmKSB7XG4gIHZhciBzaGFwZVV0aWxzID0gX3JlZi5zaGFwZVV0aWxzLFxuICAgICAgcGFnZSA9IF9yZWYucGFnZSxcbiAgICAgIHBhZ2VTdGF0ZSA9IF9yZWYucGFnZVN0YXRlLFxuICAgICAgdGhlbWUgPSBfcmVmLnRoZW1lLFxuICAgICAgX3JlZiRoaWRlQm91bmRzID0gX3JlZi5oaWRlQm91bmRzLFxuICAgICAgaGlkZUJvdW5kcyA9IF9yZWYkaGlkZUJvdW5kcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJGhpZGVCb3VuZHMsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgX2V4Y2x1ZGVkKTtcblxuICB1c2VUTFRoZW1lKHRoZW1lKTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjYWxsYmFja3M6IHJlc3QsXG4gICAgICBzaGFwZVV0aWxzOiBzaGFwZVV0aWxzXG4gICAgfTtcbiAgfSksXG4gICAgICBjb250ZXh0ID0gX1JlYWN0JHVzZVN0YXRlWzBdO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFRMQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FudmFzLCB7XG4gICAgcGFnZTogcGFnZSxcbiAgICBwYWdlU3RhdGU6IHBhZ2VTdGF0ZSxcbiAgICBoaWRlQm91bmRzOiBoaWRlQm91bmRzXG4gIH0pKTtcbn1cblxuZXhwb3J0cy5JbnRlcnNlY3QgPSBJbnRlcnNlY3Q7XG5leHBvcnRzLlJlbmRlcmVyID0gUmVuZGVyZXI7XG5leHBvcnRzLlN2ZyA9IFN2ZztcbmV4cG9ydHMuVExTaGFwZVV0aWwgPSBUTFNoYXBlVXRpbDtcbmV4cG9ydHMuVXRpbHMgPSBVdGlscztcbmV4cG9ydHMuVmVjID0gVmVjO1xuZXhwb3J0cy5icnVzaFVwZGF0ZXIgPSBicnVzaFVwZGF0ZXI7XG5leHBvcnRzLmlucHV0cyA9IGlucHV0cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmUuY2pzLmRldmVsb3BtZW50LmpzLm1hcFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../packages/core/dist/core.cjs.development.js\n");

/***/ }),

/***/ "../packages/core/dist/index.js":
/*!**************************************!*\
  !*** ../packages/core/dist/index.js ***!
  \**************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./core.cjs.development.js */ \"../packages/core/dist/core.cjs.development.js\")\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdGxkcmF3L3d3dy8uLi9wYWNrYWdlcy9jb3JlL2Rpc3QvaW5kZXguanM/MWQyZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ1k7O0FBRVosSUFBSSxLQUFxQyxFQUFFLEVBRTFDO0FBQ0QsRUFBRSxzSEFBcUQ7QUFDdkQiLCJmaWxlIjoiLi4vcGFja2FnZXMvY29yZS9kaXN0L2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4ndXNlIHN0cmljdCdcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvcmUuY2pzLnByb2R1Y3Rpb24ubWluLmpzJylcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb3JlLmNqcy5kZXZlbG9wbWVudC5qcycpXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../packages/core/dist/index.js\n");

/***/ }),

/***/ "../packages/tldraw/dist/index.js":
/*!****************************************!*\
  !*** ../packages/tldraw/dist/index.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./tldraw.cjs.development.js */ \"../packages/tldraw/dist/tldraw.cjs.development.js\")\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdGxkcmF3L3d3dy8uLi9wYWNrYWdlcy90bGRyYXcvZGlzdC9pbmRleC5qcz8wZDU3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDWTs7QUFFWixJQUFJLEtBQXFDLEVBQUUsRUFFMUM7QUFDRCxFQUFFLDRIQUF1RDtBQUN6RCIsImZpbGUiOiIuLi9wYWNrYWdlcy90bGRyYXcvZGlzdC9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuJ3VzZSBzdHJpY3QnXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi90bGRyYXcuY2pzLnByb2R1Y3Rpb24ubWluLmpzJylcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi90bGRyYXcuY2pzLmRldmVsb3BtZW50LmpzJylcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../packages/tldraw/dist/index.js\n");

/***/ }),

/***/ "../packages/tldraw/dist/tldraw.cjs.development.js":
/*!*********************************************************!*\
  !*** ../packages/tldraw/dist/tldraw.cjs.development.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar React = __webpack_require__(/*! react */ \"react\");\nvar React__default = _interopDefault(React);\nvar reactId = __webpack_require__(/*! @radix-ui/react-id */ \"@radix-ui/react-id\");\nvar core = __webpack_require__(/*! @tldraw/core */ \"../packages/core/dist/index.js\");\nvar getStroke = __webpack_require__(/*! perfect-freehand */ \"perfect-freehand\");\nvar getStroke__default = _interopDefault(getStroke);\nvar reactHotkeysHook = __webpack_require__(/*! react-hotkeys-hook */ \"react-hotkeys-hook\");\nvar react = __webpack_require__(/*! @stitches/react */ \"@stitches/react\");\nvar ContextMenu$1 = __webpack_require__(/*! @radix-ui/react-context-menu */ \"@radix-ui/react-context-menu\");\nvar RadixTooltip = __webpack_require__(/*! @radix-ui/react-tooltip */ \"@radix-ui/react-tooltip\");\nvar DropdownMenu = __webpack_require__(/*! @radix-ui/react-dropdown-menu */ \"@radix-ui/react-dropdown-menu\");\n__webpack_require__(/*! @radix-ui/react-radio-group */ \"@radix-ui/react-radio-group\");\nvar reactIcons = __webpack_require__(/*! @radix-ui/react-icons */ \"@radix-ui/react-icons\");\nvar Checkbox = __webpack_require__(/*! @radix-ui/react-checkbox */ \"@radix-ui/react-checkbox\");\nvar createReact = _interopDefault(__webpack_require__(/*! zustand */ \"zustand\"));\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\n(function (TLDrawToolType) {\n  TLDrawToolType[\"Draw\"] = \"draw\";\n  TLDrawToolType[\"Bounds\"] = \"bounds\";\n  TLDrawToolType[\"Point\"] = \"point\";\n  TLDrawToolType[\"Points\"] = \"points\";\n})(exports.TLDrawToolType || (exports.TLDrawToolType = {}));\n\n(function (TLDrawShapeType) {\n  TLDrawShapeType[\"Ellipse\"] = \"ellipse\";\n  TLDrawShapeType[\"Rectangle\"] = \"rectangle\";\n  TLDrawShapeType[\"Draw\"] = \"draw\";\n})(exports.TLDrawShapeType || (exports.TLDrawShapeType = {}));\n\nvar TLDrawShapeUtil = /*#__PURE__*/function (_TLShapeUtil) {\n  _inheritsLoose(TLDrawShapeUtil, _TLShapeUtil);\n\n  function TLDrawShapeUtil() {\n    return _TLShapeUtil.apply(this, arguments) || this;\n  }\n\n  return TLDrawShapeUtil;\n}(core.TLShapeUtil);\n\n(function (ColorStyle) {\n  ColorStyle[\"White\"] = \"White\";\n  ColorStyle[\"LightGray\"] = \"LightGray\";\n  ColorStyle[\"Gray\"] = \"Gray\";\n  ColorStyle[\"Black\"] = \"Black\";\n  ColorStyle[\"Green\"] = \"Green\";\n  ColorStyle[\"Cyan\"] = \"Cyan\";\n  ColorStyle[\"Blue\"] = \"Blue\";\n  ColorStyle[\"Indigo\"] = \"Indigo\";\n  ColorStyle[\"Violet\"] = \"Violet\";\n  ColorStyle[\"Red\"] = \"Red\";\n  ColorStyle[\"Orange\"] = \"Orange\";\n  ColorStyle[\"Yellow\"] = \"Yellow\";\n})(exports.ColorStyle || (exports.ColorStyle = {}));\n\n(function (SizeStyle) {\n  SizeStyle[\"Small\"] = \"Small\";\n  SizeStyle[\"Medium\"] = \"Medium\";\n  SizeStyle[\"Large\"] = \"Large\";\n})(exports.SizeStyle || (exports.SizeStyle = {}));\n\n(function (DashStyle) {\n  DashStyle[\"Draw\"] = \"Draw\";\n  DashStyle[\"Solid\"] = \"Solid\";\n  DashStyle[\"Dashed\"] = \"Dashed\";\n  DashStyle[\"Dotted\"] = \"Dotted\";\n})(exports.DashStyle || (exports.DashStyle = {}));\n\n(function (FontSize) {\n  FontSize[\"Small\"] = \"Small\";\n  FontSize[\"Medium\"] = \"Medium\";\n  FontSize[\"Large\"] = \"Large\";\n  FontSize[\"ExtraLarge\"] = \"ExtraLarge\";\n})(exports.FontSize || (exports.FontSize = {}));\n\nvar _colors, _extends2, _extends3, _strokeWidths, _fontSizes;\nvar canvasLight = '#fafafa';\nvar canvasDark = '#343d45';\nvar colors = (_colors = {}, _colors[exports.ColorStyle.Black] = '#212528', _colors[exports.ColorStyle.White] = '#f0f1f3', _colors[exports.ColorStyle.LightGray] = '#c6cbd1', _colors[exports.ColorStyle.Gray] = '#788492', _colors[exports.ColorStyle.Green] = '#36b24d', _colors[exports.ColorStyle.Cyan] = '#0e98ad', _colors[exports.ColorStyle.Blue] = '#1c7ed6', _colors[exports.ColorStyle.Indigo] = '#4263eb', _colors[exports.ColorStyle.Violet] = '#7746f1', _colors[exports.ColorStyle.Red] = '#ff2133', _colors[exports.ColorStyle.Orange] = '#ff9433', _colors[exports.ColorStyle.Yellow] = '#ffc936', _colors);\nvar strokes = {\n  light: colors,\n  dark: /*#__PURE__*/_extends({}, /*#__PURE__*/Object.fromEntries( /*#__PURE__*/Object.entries(colors).map(function (_ref) {\n    var k = _ref[0],\n        v = _ref[1];\n    return [k, core.Utils.lerpColor(v, canvasDark, 0.1)];\n  })), (_extends2 = {}, _extends2[exports.ColorStyle.White] = '#ffffff', _extends2[exports.ColorStyle.Black] = '#000', _extends2))\n};\nvar fills = {\n  light: /*#__PURE__*/_extends({}, /*#__PURE__*/Object.fromEntries( /*#__PURE__*/Object.entries(colors).map(function (_ref2) {\n    var k = _ref2[0],\n        v = _ref2[1];\n    return [k, core.Utils.lerpColor(v, canvasLight, 0.82)];\n  })), (_extends3 = {}, _extends3[exports.ColorStyle.White] = '#ffffff', _extends3[exports.ColorStyle.Black] = '#ffffff', _extends3)),\n  dark: /*#__PURE__*/Object.fromEntries( /*#__PURE__*/Object.entries(colors).map(function (_ref3) {\n    var k = _ref3[0],\n        v = _ref3[1];\n    return [k, core.Utils.lerpColor(v, canvasDark, 0.618)];\n  }))\n};\nvar strokeWidths = (_strokeWidths = {}, _strokeWidths[exports.SizeStyle.Small] = 2, _strokeWidths[exports.SizeStyle.Medium] = 4, _strokeWidths[exports.SizeStyle.Large] = 8, _strokeWidths);\nvar fontSizes = (_fontSizes = {}, _fontSizes[exports.SizeStyle.Small] = 24, _fontSizes[exports.SizeStyle.Medium] = 48, _fontSizes[exports.SizeStyle.Large] = 72, _fontSizes.auto = 'auto', _fontSizes);\nfunction getStrokeWidth(size) {\n  return strokeWidths[size];\n}\nfunction getFontSize(size) {\n  return fontSizes[size];\n}\nfunction getFontStyle(scale, style) {\n  var fontSize = getFontSize(style.size);\n  return fontSize * scale + \"px/1.4 Verveine Regular\";\n}\nfunction getShapeStyle(style, isDarkMode) {\n  if (isDarkMode === void 0) {\n    isDarkMode = false;\n  }\n\n  var color = style.color,\n      size = style.size,\n      isFilled = style.isFilled;\n  var strokeWidth = getStrokeWidth(size);\n  var theme = isDarkMode ? 'dark' : 'light';\n  return {\n    stroke: strokes[theme][color],\n    fill: isFilled ? fills[theme][color] : 'none',\n    strokeWidth: strokeWidth\n  };\n}\nvar defaultStyle = {\n  color: exports.ColorStyle.Black,\n  size: exports.SizeStyle.Medium,\n  isFilled: false,\n  dash: exports.DashStyle.Draw\n};\n/**\r\n * Get balanced dash-strokearray and dash-strokeoffset properties for a path of a given length.\r\n * @param length The length of the path.\r\n * @param strokeWidth The shape's stroke-width property.\r\n * @param style The stroke's style: \"dashed\" or \"dotted\" (default \"dashed\").\r\n * @param snap An interval for dashes (e.g. 4 will produce arrays with 4, 8, 16, etc dashes).\r\n */\n\nfunction getPerfectDashProps(length, strokeWidth, style, snap) {\n  if (snap === void 0) {\n    snap = 1;\n  }\n\n  var dashLength;\n  var strokeDashoffset;\n  var ratio;\n\n  if (style === exports.DashStyle.Solid || style === exports.DashStyle.Draw) {\n    return {\n      strokeDasharray: 'none',\n      strokeDashoffset: 'none'\n    };\n  } else if (style === exports.DashStyle.Dashed) {\n    dashLength = strokeWidth * 2;\n    ratio = 1;\n    strokeDashoffset = (dashLength / 2).toString();\n  } else {\n    dashLength = strokeWidth / 100;\n    ratio = 100;\n    strokeDashoffset = '0';\n  }\n\n  var dashes = Math.floor(length / dashLength / (2 * ratio));\n  dashes -= dashes % snap;\n  if (dashes === 0) dashes = 1;\n  var gapLength = (length - dashes * dashLength) / dashes;\n  return {\n    strokeDasharray: [dashLength, gapLength].join(' '),\n    strokeDashoffset: strokeDashoffset\n  };\n}\n\nvar Rectangle = /*#__PURE__*/function (_TLDrawShapeUtil) {\n  _inheritsLoose(Rectangle, _TLDrawShapeUtil);\n\n  function Rectangle() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _TLDrawShapeUtil.call.apply(_TLDrawShapeUtil, [this].concat(args)) || this;\n    _this.type = exports.TLDrawShapeType.Rectangle;\n    _this.toolType = exports.TLDrawToolType.Bounds;\n    _this.pathCache = new WeakMap([]);\n    _this.defaultProps = {\n      id: 'id',\n      type: exports.TLDrawShapeType.Rectangle,\n      name: 'Rectangle',\n      parentId: 'page',\n      childIndex: 1,\n      point: [0, 0],\n      size: [1, 1],\n      rotation: 0,\n      radius: 0,\n      style: defaultStyle\n    };\n    return _this;\n  }\n\n  var _proto = Rectangle.prototype;\n\n  _proto.render = function render(shape, _ref) {\n    var isBinding = _ref.isBinding,\n        isHovered = _ref.isHovered,\n        isDarkMode = _ref.isDarkMode;\n    var id = shape.id,\n        size = shape.size,\n        style = shape.style;\n    var styles = getShapeStyle(style, isDarkMode);\n    var strokeWidth = +styles.strokeWidth;\n\n    if (style.dash === exports.DashStyle.Draw) {\n      var pathData = core.Utils.getFromCache(this.pathCache, shape.size, function () {\n        return renderPath(shape);\n      });\n      return React.createElement(React.Fragment, null, isBinding && React.createElement(\"rect\", {\n        className: \"tl-binding-indicator\",\n        x: strokeWidth / 2 - 32,\n        y: strokeWidth / 2 - 32,\n        width: Math.max(0, size[0] - strokeWidth / 2) + 64,\n        height: Math.max(0, size[1] - strokeWidth / 2) + 64\n      }), React.createElement(\"rect\", {\n        x: +styles.strokeWidth / 2,\n        y: +styles.strokeWidth / 2,\n        width: Math.max(0, size[0] - strokeWidth),\n        height: Math.max(0, size[1] - strokeWidth),\n        fill: style.isFilled ? styles.fill : 'transparent',\n        stroke: \"none\",\n        pointerEvents: \"all\"\n      }), React.createElement(\"path\", {\n        d: pathData,\n        fill: styles.stroke,\n        stroke: styles.stroke,\n        strokeWidth: styles.strokeWidth,\n        filter: isHovered ? 'url(#expand)' : 'none',\n        pointerEvents: \"all\"\n      }));\n    }\n\n    var sw = strokeWidth * 1.618;\n    var w = Math.max(0, size[0] - sw / 2);\n    var h = Math.max(0, size[1] - sw / 2);\n    var strokes = [[[sw / 2, sw / 2], [w, sw / 2], w - sw / 2], [[w, sw / 2], [w, h], h - sw / 2], [[w, h], [sw / 2, h], w - sw / 2], [[sw / 2, h], [sw / 2, sw / 2], h - sw / 2]];\n    var paths = strokes.map(function (_ref2, i) {\n      var start = _ref2[0],\n          end = _ref2[1],\n          length = _ref2[2];\n\n      var _getPerfectDashProps = getPerfectDashProps(length, sw, shape.style.dash),\n          strokeDasharray = _getPerfectDashProps.strokeDasharray,\n          strokeDashoffset = _getPerfectDashProps.strokeDashoffset;\n\n      return React.createElement(\"line\", {\n        key: id + '_' + i,\n        x1: start[0],\n        y1: start[1],\n        x2: end[0],\n        y2: end[1],\n        stroke: styles.stroke,\n        strokeWidth: sw,\n        strokeLinecap: \"round\",\n        strokeDasharray: strokeDasharray,\n        strokeDashoffset: strokeDashoffset\n      });\n    });\n    return React.createElement(React.Fragment, null, isBinding && React.createElement(\"rect\", {\n      className: \"tl-binding-indicator\",\n      x: sw / 2 - 32,\n      y: sw / 2 - 32,\n      width: w + 64,\n      height: h + 64\n    }), React.createElement(\"rect\", {\n      x: sw / 2,\n      y: sw / 2,\n      width: w,\n      height: h,\n      fill: styles.fill,\n      stroke: \"transparent\",\n      strokeWidth: sw,\n      pointerEvents: \"all\"\n    }), React.createElement(\"g\", {\n      filter: isHovered ? 'url(#expand)' : 'none',\n      pointerEvents: \"stroke\"\n    }, paths));\n  };\n\n  _proto.getBounds = function getBounds(shape) {\n    var bounds = core.Utils.getFromCache(this.boundsCache, shape, function () {\n      var _shape$size = shape.size,\n          width = _shape$size[0],\n          height = _shape$size[1];\n      return {\n        minX: 0,\n        maxX: width,\n        minY: 0,\n        maxY: height,\n        width: width,\n        height: height\n      };\n    });\n    return core.Utils.translateBounds(bounds, shape.point);\n  };\n\n  _proto.getRotatedBounds = function getRotatedBounds(shape) {\n    return core.Utils.getBoundsFromPoints(core.Utils.getRotatedCorners(this.getBounds(shape), shape.rotation));\n  };\n\n  _proto.getCenter = function getCenter(shape) {\n    return core.Utils.getBoundsCenter(this.getBounds(shape));\n  };\n\n  _proto.hitTest = function hitTest(shape, point) {\n    return core.Utils.pointInBounds(point, this.getBounds(shape));\n  };\n\n  _proto.hitTestBounds = function hitTestBounds(shape, bounds) {\n    var rotatedCorners = core.Utils.getRotatedCorners(this.getBounds(shape), shape.rotation);\n    return rotatedCorners.every(function (point) {\n      return core.Utils.pointInBounds(point, bounds);\n    }) || core.Intersect.polyline.bounds(rotatedCorners, bounds).length > 0;\n  };\n\n  _proto.transform = function transform(shape, bounds, _ref3) {\n    var initialShape = _ref3.initialShape,\n        transformOrigin = _ref3.transformOrigin,\n        scaleX = _ref3.scaleX,\n        scaleY = _ref3.scaleY;\n\n    if (!shape.rotation && !shape.isAspectRatioLocked) {\n      return {\n        point: core.Vec.round([bounds.minX, bounds.minY]),\n        size: core.Vec.round([bounds.width, bounds.height])\n      };\n    } else {\n      var size = core.Vec.round(core.Vec.mul(initialShape.size, Math.min(Math.abs(scaleX), Math.abs(scaleY))));\n      var point = core.Vec.round([bounds.minX + (bounds.width - shape.size[0]) * (scaleX < 0 ? 1 - transformOrigin[0] : transformOrigin[0]), bounds.minY + (bounds.height - shape.size[1]) * (scaleY < 0 ? 1 - transformOrigin[1] : transformOrigin[1])]);\n      var rotation = scaleX < 0 && scaleY >= 0 || scaleY < 0 && scaleX >= 0 ? initialShape.rotation ? -initialShape.rotation : 0 : initialShape.rotation;\n      return {\n        size: size,\n        point: point,\n        rotation: rotation\n      };\n    }\n  };\n\n  _proto.transformSingle = function transformSingle(shape, bounds, info) {\n    return {\n      size: core.Vec.round([bounds.width, bounds.height]),\n      point: core.Vec.round([bounds.minX, bounds.minY])\n    };\n  };\n\n  return Rectangle;\n}(TLDrawShapeUtil);\nvar rectangle = /*#__PURE__*/new Rectangle();\n\nfunction renderPath(shape) {\n  var styles = getShapeStyle(shape.style);\n  var getRandom = core.Utils.rng(shape.id);\n  var strokeWidth = +styles.strokeWidth;\n  var baseOffset = strokeWidth / 2;\n  var offsets = Array.from(Array(4)).map(function () {\n    return [getRandom() * baseOffset, getRandom() * baseOffset];\n  });\n  var sw = strokeWidth;\n  var w = Math.max(0, shape.size[0] - sw / 2);\n  var h = Math.max(0, shape.size[1] - sw / 2);\n  var tl = core.Vec.add([sw / 2, sw / 2], offsets[0]);\n  var tr = core.Vec.add([w, sw / 2], offsets[1]);\n  var br = core.Vec.add([w, h], offsets[2]);\n  var bl = core.Vec.add([sw / 2, h], offsets[3]);\n  var lines = core.Utils.shuffleArr([core.Vec.pointsBetween(tr, br), core.Vec.pointsBetween(br, bl), core.Vec.pointsBetween(bl, tl), core.Vec.pointsBetween(tl, tr)], Math.floor(5 + getRandom() * 4));\n  var stroke = getStroke__default([].concat(lines.flat().slice(2), lines[0], lines[0].slice(4)), {\n    size: 1 + +styles.strokeWidth,\n    thinning: 0.6,\n    easing: function easing(t) {\n      return t * t * t * t;\n    },\n    end: {\n      taper: +styles.strokeWidth * 20\n    },\n    start: {\n      taper: +styles.strokeWidth * 20\n    },\n    simulatePressure: false\n  });\n  return core.Utils.getSvgPathFromStroke(stroke);\n}\n\nvar Ellipse = /*#__PURE__*/function (_TLDrawShapeUtil) {\n  _inheritsLoose(Ellipse, _TLDrawShapeUtil);\n\n  function Ellipse() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _TLDrawShapeUtil.call.apply(_TLDrawShapeUtil, [this].concat(args)) || this;\n    _this.type = exports.TLDrawShapeType.Ellipse;\n    _this.toolType = exports.TLDrawToolType.Bounds;\n    _this.pathCache = new WeakMap([]);\n    _this.defaultProps = {\n      id: 'id',\n      type: exports.TLDrawShapeType.Ellipse,\n      name: 'Ellipse',\n      parentId: 'page',\n      childIndex: 1,\n      point: [0, 0],\n      radius: [1, 1],\n      rotation: 0,\n      style: defaultStyle\n    };\n    return _this;\n  }\n\n  var _proto = Ellipse.prototype;\n\n  _proto.render = function render(shape, _ref) {\n    var _this2 = this;\n\n    var isDarkMode = _ref.isDarkMode,\n        isBinding = _ref.isBinding;\n    var _shape$radius = shape.radius,\n        radiusX = _shape$radius[0],\n        radiusY = _shape$radius[1],\n        style = shape.style;\n    var styles = getShapeStyle(style, isDarkMode);\n    var strokeWidth = +styles.strokeWidth;\n    var rx = Math.max(0, radiusX - strokeWidth / 2);\n    var ry = Math.max(0, radiusY - strokeWidth / 2);\n\n    if (style.dash === exports.DashStyle.Draw) {\n      var path = core.Utils.getFromCache(this.pathCache, shape, function () {\n        return renderPath$1(shape, _this2.getCenter(shape));\n      });\n      return React.createElement(React.Fragment, null, isBinding && React.createElement(\"ellipse\", {\n        className: \"tl-binding-indicator\",\n        cx: radiusX,\n        cy: radiusY,\n        rx: rx + 2,\n        ry: ry + 2\n      }), React.createElement(\"ellipse\", {\n        cx: radiusX,\n        cy: radiusY,\n        rx: rx,\n        ry: ry,\n        stroke: \"none\",\n        fill: style.isFilled ? styles.fill : 'transparent',\n        pointerEvents: \"all\"\n      }), React.createElement(\"path\", {\n        d: path,\n        fill: styles.stroke,\n        stroke: styles.stroke,\n        strokeWidth: strokeWidth,\n        pointerEvents: \"all\",\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\"\n      }));\n    }\n\n    var h = Math.pow(rx - ry, 2) / Math.pow(rx + ry, 2);\n    var perimeter = Math.PI * (rx + ry) * (1 + 3 * h / (10 + Math.sqrt(4 - 3 * h)));\n\n    var _getPerfectDashProps = getPerfectDashProps(perimeter, strokeWidth * 1.618, shape.style.dash, 4),\n        strokeDasharray = _getPerfectDashProps.strokeDasharray,\n        strokeDashoffset = _getPerfectDashProps.strokeDashoffset;\n\n    var sw = strokeWidth * 1.618;\n    return React.createElement(React.Fragment, null, isBinding && React.createElement(\"ellipse\", {\n      className: \"tl-binding-indicator\",\n      cx: radiusX,\n      cy: radiusY,\n      rx: rx + 32,\n      ry: ry + 32\n    }), React.createElement(\"ellipse\", {\n      cx: radiusX,\n      cy: radiusY,\n      rx: rx,\n      ry: ry,\n      fill: styles.fill,\n      stroke: styles.stroke,\n      strokeWidth: sw,\n      strokeDasharray: strokeDasharray,\n      strokeDashoffset: strokeDashoffset,\n      pointerEvents: \"all\",\n      strokeLinecap: \"round\",\n      strokeLinejoin: \"round\"\n    }));\n  };\n\n  _proto.getBounds = function getBounds(shape) {\n    return core.Utils.getFromCache(this.boundsCache, shape, function () {\n      return core.Utils.getRotatedEllipseBounds(shape.point[0], shape.point[1], shape.radius[0], shape.radius[1], shape.rotation || 0);\n    });\n  };\n\n  _proto.getRotatedBounds = function getRotatedBounds(shape) {\n    return core.Utils.getBoundsFromPoints(core.Utils.getRotatedCorners(this.getBounds(shape), shape.rotation));\n  };\n\n  _proto.getCenter = function getCenter(shape) {\n    return core.Utils.getBoundsCenter(this.getBounds(shape));\n  };\n\n  _proto.hitTest = function hitTest(shape, point) {\n    return core.Utils.pointInBounds(point, this.getBounds(shape));\n  };\n\n  _proto.hitTestBounds = function hitTestBounds(shape, bounds) {\n    var rotatedCorners = core.Utils.getRotatedCorners(this.getBounds(shape), shape.rotation);\n    return rotatedCorners.every(function (point) {\n      return core.Utils.pointInBounds(point, bounds);\n    }) || core.Intersect.polyline.bounds(rotatedCorners, bounds).length > 0;\n  };\n\n  _proto.transform = function transform(shape, bounds, _ref2) {\n    var scaleX = _ref2.scaleX,\n        scaleY = _ref2.scaleY,\n        initialShape = _ref2.initialShape;\n    var _initialShape$rotatio = initialShape.rotation,\n        rotation = _initialShape$rotatio === void 0 ? 0 : _initialShape$rotatio;\n    return {\n      point: [bounds.minX, bounds.minY],\n      radius: [bounds.width / 2, bounds.height / 2],\n      rotation: scaleX < 0 && scaleY >= 0 || scaleY < 0 && scaleX >= 0 ? -(rotation || 0) : rotation || 0\n    };\n  };\n\n  _proto.transformSingle = function transformSingle(shape, bounds) {\n    return {\n      point: core.Vec.round([bounds.minX, bounds.minY]),\n      radius: core.Vec.div([bounds.width, bounds.height], 2)\n    };\n  };\n\n  return Ellipse;\n}(TLDrawShapeUtil);\nvar ellipse = /*#__PURE__*/new Ellipse();\n\nfunction renderPath$1(shape, boundsCenter) {\n  var style = shape.style,\n      id = shape.id,\n      _shape$radius2 = shape.radius,\n      radiusX = _shape$radius2[0],\n      radiusY = _shape$radius2[1],\n      point = shape.point;\n  var getRandom = core.Utils.rng(id);\n  var center = core.Vec.sub(boundsCenter, point);\n  var strokeWidth = +getShapeStyle(style).strokeWidth;\n  var rx = radiusX + getRandom() * strokeWidth - strokeWidth / 2;\n  var ry = radiusY + getRandom() * strokeWidth - strokeWidth / 2;\n  var points = [];\n  var start = Math.PI + Math.PI * getRandom();\n  var overlap = Math.PI / 12;\n\n  for (var i = 2; i < 8; i++) {\n    var rads = start + overlap * 2 * (i / 8);\n    var x = rx * Math.cos(rads) + center[0];\n    var y = ry * Math.sin(rads) + center[1];\n    points.push([x, y]);\n  }\n\n  for (var _i = 5; _i < 32; _i++) {\n    var t = _i / 35;\n\n    var _rads = start + overlap * 2 + Math.PI * 2.5 * (t * t * t);\n\n    var _x = rx * Math.cos(_rads) + center[0];\n\n    var _y = ry * Math.sin(_rads) + center[1];\n\n    points.push([_x, _y]);\n  }\n\n  for (var _i2 = 0; _i2 < 8; _i2++) {\n    var _rads2 = start + overlap * 2 * (_i2 / 4);\n\n    var _x2 = rx * Math.cos(_rads2) + center[0];\n\n    var _y2 = ry * Math.sin(_rads2) + center[1];\n\n    points.push([_x2, _y2]);\n  }\n\n  var stroke = getStroke__default(points, {\n    size: 1 + strokeWidth,\n    thinning: 0.6,\n    easing: function easing(t) {\n      return t * t * t * t;\n    },\n    end: {\n      taper: strokeWidth * 20\n    },\n    start: {\n      taper: strokeWidth * 20\n    },\n    simulatePressure: false\n  });\n  return core.Utils.getSvgPathFromStroke(stroke);\n}\n\nvar Draw = /*#__PURE__*/function (_TLDrawShapeUtil) {\n  _inheritsLoose(Draw, _TLDrawShapeUtil);\n\n  function Draw() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _TLDrawShapeUtil.call.apply(_TLDrawShapeUtil, [this].concat(args)) || this;\n    _this.type = exports.TLDrawShapeType.Draw;\n    _this.toolType = exports.TLDrawToolType.Draw;\n    _this.pointsBoundsCache = new WeakMap([]);\n    _this.rotatedCache = new WeakMap([]);\n    _this.drawPathCache = new WeakMap([]);\n    _this.simplePathCache = new WeakMap([]);\n    _this.polygonCache = new WeakMap([]);\n    _this.defaultProps = {\n      id: 'id',\n      type: exports.TLDrawShapeType.Draw,\n      name: 'Draw',\n      parentId: 'page',\n      childIndex: 1,\n      point: [0, 0],\n      points: [[0, 0, 0.5]],\n      rotation: 0,\n      radius: 0,\n      style: defaultStyle\n    };\n    return _this;\n  }\n\n  var _proto = Draw.prototype;\n\n  _proto.render = function render(shape, _ref) {\n    var _DashStyle$Draw$DashS, _DashStyle$Draw$DashS2;\n\n    var isHovered = _ref.isHovered,\n        isDarkMode = _ref.isDarkMode;\n    var points = shape.points,\n        style = shape.style;\n    var styles = getShapeStyle(style, isDarkMode);\n    var strokeWidth = +styles.strokeWidth;\n    var shouldFill = style.isFilled && points.length > 3 && core.Vec.dist(points[0], points[points.length - 1]) < +styles.strokeWidth * 2; // For very short lines, draw a point instead of a line\n\n    if (points.length > 0 && points.length < 3) {\n      var _sw = strokeWidth * 0.618;\n\n      return React.createElement(\"circle\", {\n        r: strokeWidth * 0.618,\n        fill: styles.stroke,\n        stroke: styles.stroke,\n        strokeWidth: _sw,\n        pointerEvents: \"all\",\n        filter: isHovered ? 'url(#expand)' : 'none'\n      });\n    } // For drawn lines, draw a line from the path cache\n\n\n    if (shape.style.dash === exports.DashStyle.Draw) {\n      var polygonPathData = core.Utils.getFromCache(this.polygonCache, points, function () {\n        return getFillPath(shape);\n      });\n      var drawPathData = core.Utils.getFromCache(this.drawPathCache, points, function () {\n        return getDrawStrokePath(shape);\n      });\n      return React.createElement(React.Fragment, null, shouldFill && React.createElement(\"path\", {\n        d: polygonPathData,\n        stroke: \"none\",\n        fill: styles.fill,\n        strokeLinejoin: \"round\",\n        strokeLinecap: \"round\",\n        pointerEvents: \"fill\"\n      }), React.createElement(\"path\", {\n        d: drawPathData,\n        fill: styles.stroke,\n        stroke: styles.stroke,\n        strokeWidth: strokeWidth,\n        strokeLinejoin: \"round\",\n        strokeLinecap: \"round\",\n        pointerEvents: \"all\",\n        filter: isHovered ? 'url(#expand)' : 'none'\n      }));\n    } // For solid, dash and dotted lines, draw a regular stroke path\n\n\n    var strokeDasharray = (_DashStyle$Draw$DashS = {}, _DashStyle$Draw$DashS[exports.DashStyle.Draw] = 'none', _DashStyle$Draw$DashS[exports.DashStyle.Solid] = \"none\", _DashStyle$Draw$DashS[exports.DashStyle.Dotted] = strokeWidth / 10 + \" \" + strokeWidth * 3, _DashStyle$Draw$DashS[exports.DashStyle.Dashed] = strokeWidth * 3 + \" \" + strokeWidth * 3, _DashStyle$Draw$DashS)[style.dash];\n    var strokeDashoffset = (_DashStyle$Draw$DashS2 = {}, _DashStyle$Draw$DashS2[exports.DashStyle.Draw] = 'none', _DashStyle$Draw$DashS2[exports.DashStyle.Solid] = \"none\", _DashStyle$Draw$DashS2[exports.DashStyle.Dotted] = \"-\" + strokeWidth / 20, _DashStyle$Draw$DashS2[exports.DashStyle.Dashed] = \"-\" + strokeWidth, _DashStyle$Draw$DashS2)[style.dash];\n    var path = core.Utils.getFromCache(this.simplePathCache, points, function () {\n      return getSolidStrokePath(shape);\n    });\n    var sw = strokeWidth * 1.618;\n    return React.createElement(React.Fragment, null, React.createElement(\"path\", {\n      d: path,\n      fill: shouldFill ? styles.fill : 'none',\n      stroke: \"transparent\",\n      strokeWidth: Math.min(4, strokeWidth * 2),\n      strokeLinejoin: \"round\",\n      strokeLinecap: \"round\",\n      pointerEvents: shouldFill ? 'all' : 'stroke'\n    }), React.createElement(\"path\", {\n      d: path,\n      fill: \"transparent\",\n      stroke: styles.stroke,\n      strokeWidth: sw,\n      strokeDasharray: strokeDasharray,\n      strokeDashoffset: strokeDashoffset,\n      strokeLinejoin: \"round\",\n      strokeLinecap: \"round\",\n      pointerEvents: \"stroke\",\n      filter: isHovered ? 'url(#expand)' : 'none'\n    }));\n  };\n\n  _proto.getBounds = function getBounds(shape) {\n    return core.Utils.translateBounds(core.Utils.getFromCache(this.pointsBoundsCache, shape.points, function () {\n      return core.Utils.getBoundsFromPoints(shape.points);\n    }), shape.point);\n  };\n\n  _proto.getRotatedBounds = function getRotatedBounds(shape) {\n    return core.Utils.translateBounds(core.Utils.getBoundsFromPoints(shape.points, shape.rotation), shape.point);\n  };\n\n  _proto.getCenter = function getCenter(shape) {\n    return core.Utils.getBoundsCenter(this.getBounds(shape));\n  };\n\n  _proto.hitTest = function hitTest(shape, point) {\n    return true;\n  };\n\n  _proto.hitTestBounds = function hitTestBounds(shape, brushBounds) {\n    // Test axis-aligned shape\n    if (!shape.rotation) {\n      var bounds = this.getBounds(shape);\n      return core.Utils.boundsContain(brushBounds, bounds) || (core.Utils.boundsContain(bounds, brushBounds) || core.Intersect.bounds.bounds(bounds, brushBounds).length > 0) && core.Intersect.polyline.bounds(shape.points, core.Utils.translateBounds(brushBounds, core.Vec.neg(shape.point))).length > 0;\n    } // Test rotated shape\n\n\n    var rBounds = this.getRotatedBounds(shape);\n    var rotatedBounds = core.Utils.getFromCache(this.rotatedCache, shape, function () {\n      var c = core.Utils.getBoundsCenter(core.Utils.getBoundsFromPoints(shape.points));\n      return shape.points.map(function (pt) {\n        return core.Vec.rotWith(pt, c, shape.rotation || 0);\n      });\n    });\n    return core.Utils.boundsContain(brushBounds, rBounds) || core.Intersect.bounds.polyline(core.Utils.translateBounds(brushBounds, core.Vec.neg(shape.point)), rotatedBounds).length > 0;\n  };\n\n  _proto.transform = function transform(shape, bounds, _ref2) {\n    var initialShape = _ref2.initialShape,\n        scaleX = _ref2.scaleX,\n        scaleY = _ref2.scaleY;\n    var initialShapeBounds = core.Utils.getFromCache(this.boundsCache, initialShape, function () {\n      return core.Utils.getBoundsFromPoints(initialShape.points);\n    });\n    var points = initialShape.points.map(function (_ref3) {\n      var x = _ref3[0],\n          y = _ref3[1],\n          r = _ref3[2];\n      return [bounds.width * (scaleX < 0 // * sin?\n      ? 1 - x / initialShapeBounds.width : x / initialShapeBounds.width), bounds.height * (scaleY < 0 // * cos?\n      ? 1 - y / initialShapeBounds.height : y / initialShapeBounds.height), r];\n    });\n    var newBounds = core.Utils.getBoundsFromPoints(shape.points);\n    var point = core.Vec.sub([bounds.minX, bounds.minY], [newBounds.minX, newBounds.minY]);\n    return {\n      points: points,\n      point: point\n    };\n  };\n\n  _proto.transformSingle = function transformSingle(shape, bounds, info) {\n    return this.transform(shape, bounds, info);\n  };\n\n  _proto.onSessionComplete = function onSessionComplete(shape) {\n    var bounds = this.getBounds(shape);\n\n    var _Vec$sub = core.Vec.sub([bounds.minX, bounds.minY], shape.point),\n        x1 = _Vec$sub[0],\n        y1 = _Vec$sub[1];\n\n    return {\n      points: shape.points.map(function (_ref4) {\n        var x0 = _ref4[0],\n            y0 = _ref4[1],\n            p = _ref4[2];\n        return [x0 - x1, y0 - y1, p];\n      }),\n      point: core.Vec.add(shape.point, [x1, y1])\n    };\n  };\n\n  return Draw;\n}(TLDrawShapeUtil);\nvar draw = /*#__PURE__*/new Draw();\nvar simulatePressureSettings = {\n  simulatePressure: true\n};\nvar realPressureSettings = {\n  easing: function easing(t) {\n    return t * t;\n  },\n  simulatePressure: false,\n  start: {\n    taper: 1\n  },\n  end: {\n    taper: 1\n  }\n};\n\nfunction getFillPath(shape) {\n  var styles = getShapeStyle(shape.style);\n\n  if (shape.points.length < 2) {\n    return '';\n  }\n\n  return core.Utils.getSvgPathFromStroke(getStroke.getStrokePoints(shape.points, {\n    size: 1 + +styles.strokeWidth * 2,\n    thinning: 0.85,\n    end: {\n      taper: +styles.strokeWidth * 20\n    },\n    start: {\n      taper: +styles.strokeWidth * 20\n    }\n  }).map(function (pt) {\n    return pt.point;\n  }));\n}\n\nfunction getDrawStrokePath(shape) {\n  var styles = getShapeStyle(shape.style);\n\n  if (shape.points.length < 2) {\n    return '';\n  }\n\n  var options = shape.points[1][2] === 0.5 ? simulatePressureSettings : realPressureSettings;\n  var stroke = getStroke__default(shape.points, _extends({\n    size: 1 + +styles.strokeWidth * 2,\n    thinning: 0.85,\n    end: {\n      taper: +styles.strokeWidth * 10\n    },\n    start: {\n      taper: +styles.strokeWidth * 10\n    }\n  }, options));\n  return core.Utils.getSvgPathFromStroke(stroke);\n}\n\nfunction getSolidStrokePath(shape) {\n  var points = shape.points;\n  var len = points.length;\n  if (len === 0) return 'M 0 0 L 0 0';\n  if (len < 3) return \"M \" + points[0][0] + \" \" + points[0][1];\n  points = getStroke.getStrokePoints(points).map(function (pt) {\n    return pt.point;\n  });\n  len = points.length;\n  var d = points.reduce(function (acc, _ref5, i, arr) {\n    var x0 = _ref5[0],\n        y0 = _ref5[1];\n\n    if (i === len - 1) {\n      acc.push('L', x0, y0);\n      return acc;\n    }\n\n    var _arr = arr[i + 1],\n        x1 = _arr[0],\n        y1 = _arr[1];\n    acc.push(x0.toFixed(2), y0.toFixed(2), ((x0 + x1) / 2).toFixed(2), ((y0 + y1) / 2).toFixed(2));\n    return acc;\n  }, ['M', points[0][0], points[0][1], 'Q']);\n  var path = d.join(' ').replaceAll(/(\\s[0-9]*\\.[0-9]{2})([0-9]*)\\b/g, '$1');\n  return path;\n}\n\nvar tldrawShapeUtils = {\n  rectangle: rectangle,\n  ellipse: ellipse,\n  draw: draw\n};\nfunction getShapeUtils(shape) {\n  return tldrawShapeUtils[shape.type];\n}\nfunction createShape(type, props) {\n  return tldrawShapeUtils[type].create(props);\n}\n\nfunction useKeyboardShortcuts(tlstate) {\n  React__default.useEffect(function () {\n    var handleKeyDown = function handleKeyDown(e) {\n      var info = core.inputs.keydown(e);\n      tlstate.onKeyDown(e.key, info);\n    };\n\n    var handleKeyUp = function handleKeyUp(e) {\n      var info = core.inputs.keyup(e);\n      tlstate.onKeyUp(e.key, info);\n    };\n\n    window.addEventListener('keydown', handleKeyDown);\n    window.addEventListener('keyup', handleKeyUp);\n    return function () {\n      window.removeEventListener('keydown', handleKeyDown);\n      window.removeEventListener('keyup', handleKeyUp);\n    };\n  }, [tlstate]);\n  reactHotkeysHook.useHotkeys('command+z', function (e) {\n    tlstate.undo();\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('ctrl+shift-z,command+shift+z', function (e) {\n    tlstate.redo();\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('ctrl+d,command+d', function (e) {\n    tlstate.duplicate();\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('ctrl+s,command+s', function (e) {\n    tlstate.save();\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('ctrl+=,command+=', function (e) {\n    tlstate.zoomIn();\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('ctrl+-,command+-', function (e) {\n    tlstate.zoomOut();\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('shift+1', function (e) {\n    tlstate.zoomToFit();\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('shift+2', function (e) {\n    tlstate.zoomToSelection();\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('shift+0', function (e) {\n    tlstate.zoomToActual();\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('escape', function (e) {\n    tlstate.cancel();\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('backspace', function (e) {\n    tlstate[\"delete\"]();\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('command+a,ctrl+a', function (e) {\n    tlstate.selectAll();\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('up', function (e) {\n    tlstate.nudge([0, -1], false);\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('right', function (e) {\n    tlstate.nudge([1, 0], false);\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('down', function (e) {\n    tlstate.nudge([0, 1], false);\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('left', function (e) {\n    tlstate.nudge([-1, 0], false);\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('shift+up', function (e) {\n    tlstate.nudge([0, -1], true);\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('shift+right', function (e) {\n    tlstate.nudge([1, 0], true);\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('shift+down', function (e) {\n    tlstate.nudge([0, 1], true);\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('shift+left', function (e) {\n    tlstate.nudge([-1, 0], true);\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('[', function (e) {\n    tlstate.moveBackward();\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys(']', function (e) {\n    tlstate.moveForward();\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('shift+[', function (e) {\n    tlstate.moveToBack();\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('shift+]', function (e) {\n    tlstate.moveToFront();\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('v,1', function (e) {\n    tlstate.selectTool('select');\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('d,2', function (e) {\n    tlstate.selectTool(exports.TLDrawShapeType.Draw);\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('r,3', function (e) {\n    tlstate.selectTool(exports.TLDrawShapeType.Rectangle);\n    e.preventDefault();\n  });\n  reactHotkeysHook.useHotkeys('e,4', function (e) {\n    tlstate.selectTool(exports.TLDrawShapeType.Ellipse);\n    e.preventDefault();\n  });\n}\n\nvar TLDrawContext = /*#__PURE__*/React.createContext({});\nfunction useTLDrawContext() {\n  var context = React.useContext(TLDrawContext);\n  return context;\n}\n\nfunction useTheme() {\n  return {\n    theme: 'light',\n    toggle: function toggle() {\n      return null;\n    }\n  };\n}\n\nvar _createCss = /*#__PURE__*/react.createCss({\n  themeMap: /*#__PURE__*/_extends({}, react.defaultThemeMap),\n  theme: {\n    colors: {\n      codeHl: 'rgba(144, 144, 144, .15)',\n      brushFill: 'rgba(0,0,0,.05)',\n      brushStroke: 'rgba(0,0,0,.25)',\n      hint: 'rgba(216, 226, 249, 1.000)',\n      selected: 'rgba(66, 133, 244, 1.000)',\n      bounds: 'rgba(65, 132, 244, 1.000)',\n      boundsBg: 'rgba(65, 132, 244, 0.05)',\n      highlight: 'rgba(65, 132, 244, 0.15)',\n      overlay: 'rgba(0, 0, 0, 0.15)',\n      overlayContrast: 'rgba(255, 255, 255, 0.15)',\n      border: '#aaaaaa',\n      canvas: '#f8f9fa',\n      panel: '#fefefe',\n      inactive: '#cccccf',\n      hover: '#efefef',\n      text: '#333333',\n      tooltipBg: '#1d1d1d',\n      tooltipText: '#ffffff',\n      muted: '#777777',\n      input: '#f3f3f3',\n      inputBorder: '#dddddd',\n      warn: 'rgba(255, 100, 100, 1)',\n      lineError: 'rgba(255, 0, 0, .1)'\n    },\n    shadows: {\n      2: '0px 1px 1px rgba(0, 0, 0, 0.14)',\n      3: '0px 2px 3px rgba(0, 0, 0, 0.14)',\n      4: '0px 4px 5px -1px rgba(0, 0, 0, 0.14)',\n      8: '0px 12px 17px rgba(0, 0, 0, 0.14)',\n      12: '0px 12px 17px rgba(0, 0, 0, 0.14)',\n      24: '0px 24px 38px rgba(0, 0, 0, 0.14)',\n      key: '1px 1px rgba(0,0,0,1)'\n    },\n    space: {\n      0: '2px',\n      1: '3px',\n      2: '4px',\n      3: '8px',\n      4: '12px',\n      5: '16px'\n    },\n    fontSizes: {\n      0: '10px',\n      1: '12px',\n      2: '13px',\n      3: '16px',\n      4: '18px'\n    },\n    fonts: {\n      ui: '\"Recursive\", system-ui, sans-serif',\n      body: '\"Recursive\", system-ui, sans-serif',\n      mono: '\"Recursive Mono\", monospace'\n    },\n    fontWeights: {},\n    lineHeights: {},\n    letterSpacings: {},\n    sizes: {},\n    borderWidths: {\n      0: '$1'\n    },\n    borderStyles: {},\n    radii: {\n      0: '2px',\n      1: '4px',\n      2: '8px'\n    },\n    zIndices: {},\n    transitions: {}\n  },\n  media: {\n    sm: '(min-width: 640px)',\n    md: '(min-width: 768px)'\n  },\n  utils: {\n    zDash: function zDash() {\n      return function (value) {\n        return {\n          strokeDasharray: \"calc(\" + value + \"px / var(--camera-zoom)) calc(\" + value + \"px / var(--camera-zoom))\"\n        };\n      };\n    },\n    zStrokeWidth: function zStrokeWidth() {\n      return function (value) {\n        if (Array.isArray(value)) {\n          return {\n            strokeWidth: \"calc(\" + value[0] + \"px / var(--camera-zoom))\"\n          };\n        }\n\n        return {\n          strokeWidth: \"calc(\" + value + \"px / var(--camera-zoom))\"\n        };\n      };\n    }\n  }\n}),\n    styled = _createCss.styled;\n\nfunction commandKey() {\n  return core.Utils.isDarwin() ? '' : 'Ctrl';\n}\nfunction Kbd(_ref) {\n  var variant = _ref.variant,\n      children = _ref.children;\n  if (core.Utils.isMobile()) return null;\n  return React.createElement(StyledKbd, {\n    variant: variant\n  }, children.replaceAll('#', commandKey()).split('').map(function (k, i) {\n    return React.createElement(\"span\", {\n      key: i\n    }, k);\n  }));\n}\nvar StyledKbd = /*#__PURE__*/styled('kbd', {\n  marginLeft: '$3',\n  textShadow: '$2',\n  textAlign: 'center',\n  fontSize: '$0',\n  fontFamily: '$ui',\n  fontWeight: 400,\n  gap: '$1',\n  display: 'flex',\n  alignItems: 'center',\n  '& > span': {\n    padding: '$0',\n    borderRadius: '$0',\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'center'\n  },\n  variants: {\n    variant: {\n      tooltip: {\n        '& > span': {\n          background: '$overlayContrast',\n          boxShadow: '$key',\n          width: '20px',\n          height: '20px'\n        }\n      },\n      menu: {}\n    }\n  }\n});\n\nfunction Tooltip(_ref) {\n  var children = _ref.children,\n      label = _ref.label,\n      kbd = _ref.kbd,\n      _ref$side = _ref.side,\n      side = _ref$side === void 0 ? 'top' : _ref$side;\n  return React__default.createElement(RadixTooltip.Root, null, React__default.createElement(RadixTooltip.Trigger, {\n    as: \"span\"\n  }, children), React__default.createElement(StyledContent, {\n    side: side,\n    sideOffset: 8\n  }, label, kbd ? React__default.createElement(Kbd, {\n    variant: \"tooltip\"\n  }, kbd) : null, React__default.createElement(StyledArrow, null)));\n}\nvar StyledContent = /*#__PURE__*/styled(RadixTooltip.Content, {\n  borderRadius: 3,\n  padding: '$3 $3 $3 $3',\n  fontSize: '$1',\n  backgroundColor: '$tooltipBg',\n  color: '$tooltipText',\n  boxShadow: '$3',\n  display: 'flex',\n  alignItems: 'center',\n  fontFamily: '$ui'\n});\nvar StyledArrow = /*#__PURE__*/styled(RadixTooltip.Arrow, {\n  fill: '$tooltipBg',\n  margin: '0 8px'\n});\n\nvar _excluded = [\"size\"];\n\nvar _pageButton;\nvar breakpoints = {\n  '@initial': 'mobile',\n  '@sm': 'small'\n};\nvar IconButton = /*#__PURE__*/styled('button', {\n  position: 'relative',\n  height: '32px',\n  width: '32px',\n  backgroundColor: '$panel',\n  borderRadius: '4px',\n  padding: '0',\n  margin: '0',\n  display: 'grid',\n  alignItems: 'center',\n  justifyContent: 'center',\n  outline: 'none',\n  border: 'none',\n  pointerEvents: 'all',\n  fontSize: '$0',\n  color: '$text',\n  cursor: 'pointer',\n  '& > *': {\n    gridRow: 1,\n    gridColumn: 1\n  },\n  '&:disabled': {\n    opacity: '0.5'\n  },\n  '& > span': {\n    width: '100%',\n    height: '100%',\n    display: 'flex',\n    alignItems: 'center'\n  },\n  variants: {\n    bp: {\n      mobile: {\n        backgroundColor: 'transparent'\n      },\n      small: {\n        '&:hover:not(:disabled)': {\n          backgroundColor: '$hover'\n        }\n      }\n    },\n    size: {\n      small: {\n        height: 32,\n        width: 32,\n        '& svg:nth-of-type(1)': {\n          height: '16px',\n          width: '16px'\n        }\n      },\n      medium: {\n        height: 44,\n        width: 44,\n        '& svg:nth-of-type(1)': {\n          height: '18px',\n          width: '18px'\n        }\n      },\n      large: {\n        height: 44,\n        width: 44,\n        '& svg:nth-of-type(1)': {\n          height: '20px',\n          width: '20px'\n        }\n      }\n    },\n    isActive: {\n      \"true\": {\n        color: '$selected'\n      }\n    }\n  }\n});\nvar RowButton = /*#__PURE__*/styled('button', {\n  position: 'relative',\n  display: 'flex',\n  width: '100%',\n  background: 'none',\n  height: '32px',\n  border: 'none',\n  cursor: 'pointer',\n  color: '$text',\n  outline: 'none',\n  alignItems: 'center',\n  fontFamily: '$ui',\n  fontWeight: 400,\n  fontSize: '$1',\n  justifyContent: 'space-between',\n  padding: '4px 8px 4px 12px',\n  borderRadius: 4,\n  userSelect: 'none',\n  '& label': {\n    fontWeight: '$1',\n    margin: 0,\n    padding: 0\n  },\n  '& svg': {\n    position: 'relative',\n    stroke: '$overlay',\n    strokeWidth: 1,\n    zIndex: 1\n  },\n  '&[data-disabled]': {\n    opacity: 0.3\n  },\n  '&:disabled': {\n    opacity: 0.3\n  },\n  variants: {\n    bp: {\n      mobile: {},\n      small: {\n        '& *[data-shy=\"true\"]': {\n          opacity: 0\n        },\n        '&:hover:not(:disabled)': {\n          backgroundColor: '$hover',\n          '& *[data-shy=\"true\"]': {\n            opacity: 1\n          }\n        }\n      }\n    },\n    size: {\n      icon: {\n        padding: '4px ',\n        width: 'auto'\n      }\n    },\n    variant: {\n      noIcon: {\n        padding: '4px 12px'\n      },\n      pageButton: (_pageButton = {\n        display: 'grid',\n        gridTemplateColumns: '24px auto',\n        width: '100%',\n        paddingLeft: '$1',\n        gap: '$3',\n        justifyContent: 'flex-start'\n      }, _pageButton[\"& > *[data-state=\\\"checked\\\"]\"] = {\n        gridRow: 1,\n        gridColumn: 1\n      }, _pageButton['& > span'] = {\n        gridRow: 1,\n        gridColumn: 2,\n        width: '100%'\n      }, _pageButton)\n    },\n    warn: {\n      \"true\": {\n        color: '$warn'\n      }\n    },\n    isActive: {\n      \"true\": {\n        backgroundColor: '$hover'\n      }\n    }\n  }\n});\nvar IconWrapper = /*#__PURE__*/styled('div', {\n  height: '100%',\n  borderRadius: '4px',\n  marginRight: '1px',\n  display: 'grid',\n  alignItems: 'center',\n  justifyContent: 'center',\n  outline: 'none',\n  border: 'none',\n  pointerEvents: 'all',\n  cursor: 'pointer',\n  color: '$text',\n  '& svg': {\n    height: 22,\n    width: 22,\n    strokeWidth: 1\n  },\n  '& > *': {\n    gridRow: 1,\n    gridColumn: 1\n  },\n  variants: {\n    size: {\n      small: {\n        '& svg': {\n          height: '16px',\n          width: '16px'\n        }\n      },\n      medium: {\n        '& svg': {\n          height: '22px',\n          width: '22px'\n        }\n      }\n    }\n  }\n});\nvar ButtonsRow = /*#__PURE__*/styled('div', {\n  position: 'relative',\n  display: 'flex',\n  width: '100%',\n  background: 'none',\n  border: 'none',\n  cursor: 'pointer',\n  outline: 'none',\n  alignItems: 'center',\n  justifyContent: 'flex-start',\n  padding: 0\n});\nvar FloatingContainer = /*#__PURE__*/styled('div', {\n  backgroundColor: '$panel',\n  border: '1px solid $panel',\n  borderRadius: '4px',\n  boxShadow: '$4',\n  display: 'flex',\n  height: 'fit-content',\n  padding: '$0',\n  pointerEvents: 'all',\n  position: 'relative',\n  userSelect: 'none',\n  zIndex: 200,\n  variants: {\n    direction: {\n      row: {\n        flexDirection: 'row'\n      },\n      column: {\n        flexDirection: 'column'\n      }\n    },\n    elevation: {\n      0: {\n        boxShadow: 'none'\n      },\n      2: {\n        boxShadow: '$2'\n      },\n      3: {\n        boxShadow: '$3'\n      },\n      4: {\n        boxShadow: '$4'\n      }\n    }\n  }\n});\n/* -------------------------------------------------- */\n\n/*                        Menus                       */\n\n/* -------------------------------------------------- */\n\nvar MenuContent = /*#__PURE__*/styled('div', {\n  position: 'relative',\n  overflow: 'hidden',\n  userSelect: 'none',\n  zIndex: 180,\n  minWidth: 180,\n  pointerEvents: 'all',\n  backgroundColor: '$panel',\n  border: '1px solid $panel',\n  padding: '$0',\n  boxShadow: '$4',\n  borderRadius: '4px',\n  font: '$ui'\n});\nvar Divider = /*#__PURE__*/styled('div', {\n  backgroundColor: '$hover',\n  height: 1,\n  marginTop: '$2',\n  marginRight: '-$2',\n  marginBottom: '$2',\n  marginLeft: '-$2'\n});\nfunction DropdownMenuIconTriggerButton(_ref6) {\n  var label = _ref6.label,\n      kbd = _ref6.kbd,\n      children = _ref6.children,\n      _ref6$disabled = _ref6.disabled,\n      disabled = _ref6$disabled === void 0 ? false : _ref6$disabled;\n  return React__default.createElement(DropdownMenu.Trigger, {\n    as: IconButton,\n    bp: breakpoints,\n    disabled: disabled\n  }, React__default.createElement(Tooltip, {\n    label: label,\n    kbd: kbd\n  }, children));\n}\n/* -------------------------------------------------- */\n\n/*                    Context Menu                   */\n\n/* -------------------------------------------------- */\n\nfunction ContextMenuRoot(_ref8) {\n  var onOpenChange = _ref8.onOpenChange,\n      children = _ref8.children;\n  return React__default.createElement(ContextMenu$1.Root, {\n    dir: \"ltr\",\n    onOpenChange: onOpenChange\n  }, children);\n}\nfunction ContextMenuSubMenu(_ref9) {\n  var children = _ref9.children,\n      label = _ref9.label;\n  return React__default.createElement(ContextMenu$1.Root, {\n    dir: \"ltr\"\n  }, React__default.createElement(ContextMenu$1.TriggerItem, {\n    as: RowButton,\n    bp: breakpoints\n  }, React__default.createElement(\"span\", null, label), React__default.createElement(IconWrapper, {\n    size: \"small\"\n  }, React__default.createElement(reactIcons.ChevronRightIcon, null))), React__default.createElement(ContextMenu$1.Content, {\n    as: MenuContent,\n    sideOffset: 2,\n    alignOffset: -2\n  }, children, React__default.createElement(ContextMenuArrow, {\n    offset: 13\n  })));\n}\nvar ContextMenuDivider = /*#__PURE__*/styled(ContextMenu$1.Separator, {\n  backgroundColor: '$hover',\n  height: 1,\n  margin: '$2 -$2'\n});\nvar ContextMenuArrow = /*#__PURE__*/styled(ContextMenu$1.Arrow, {\n  fill: '$panel'\n});\nfunction ContextMenuButton(_ref10) {\n  var onSelect = _ref10.onSelect,\n      children = _ref10.children,\n      _ref10$disabled = _ref10.disabled,\n      disabled = _ref10$disabled === void 0 ? false : _ref10$disabled;\n  return React__default.createElement(RowButton, {\n    as: ContextMenu$1.Item,\n    bp: breakpoints,\n    disabled: disabled,\n    onSelect: onSelect\n  }, children);\n}\nfunction ContextMenuIconButton(_ref11) {\n  var onSelect = _ref11.onSelect,\n      children = _ref11.children,\n      _ref11$disabled = _ref11.disabled,\n      disabled = _ref11$disabled === void 0 ? false : _ref11$disabled;\n  return React__default.createElement(ContextMenu$1.Item, {\n    as: IconButton,\n    bp: breakpoints,\n    disabled: disabled,\n    onSelect: onSelect\n  }, children);\n}\nfunction CircleIcon(props) {\n  var _props$size = props.size,\n      size = _props$size === void 0 ? 16 : _props$size,\n      rest = _objectWithoutPropertiesLoose(props, _excluded);\n\n  return React__default.createElement(\"svg\", _extends({\n    width: 24,\n    height: 24\n  }, rest), React__default.createElement(\"circle\", {\n    cx: 12,\n    cy: 12,\n    r: size / 2\n  }));\n}\n\n(function (MoveType) {\n  MoveType[\"Backward\"] = \"backward\";\n  MoveType[\"Forward\"] = \"forward\";\n  MoveType[\"ToFront\"] = \"toFront\";\n  MoveType[\"ToBack\"] = \"toBack\";\n})(exports.MoveType || (exports.MoveType = {}));\n\n(function (AlignType) {\n  AlignType[\"Top\"] = \"top\";\n  AlignType[\"CenterVertical\"] = \"centerVertical\";\n  AlignType[\"Bottom\"] = \"bottom\";\n  AlignType[\"Left\"] = \"left\";\n  AlignType[\"CenterHorizontal\"] = \"centerHorizontal\";\n  AlignType[\"Right\"] = \"right\";\n})(exports.AlignType || (exports.AlignType = {}));\n\n(function (StretchType) {\n  StretchType[\"Horizontal\"] = \"horizontal\";\n  StretchType[\"Vertical\"] = \"vertical\";\n})(exports.StretchType || (exports.StretchType = {}));\n\n(function (DistributeType) {\n  DistributeType[\"Horizontal\"] = \"horizontal\";\n  DistributeType[\"Vertical\"] = \"vertical\";\n})(exports.DistributeType || (exports.DistributeType = {}));\n\nvar has1SelectedIdsSelector = function has1SelectedIdsSelector(s) {\n  return s.pageState.selectedIds.length > 0;\n};\n\nvar has2SelectedIdsSelector = function has2SelectedIdsSelector(s) {\n  return s.pageState.selectedIds.length > 1;\n};\n\nvar has3SelectedIdsSelector = function has3SelectedIdsSelector(s) {\n  return s.pageState.selectedIds.length > 2;\n};\n\nvar isDebugModeSelector = function isDebugModeSelector(s) {\n  return s.settings.isDebugMode;\n};\n\nvar hasGroupSelectedSelector = function hasGroupSelectedSelector(s) {\n  return s.pageState.selectedIds.some(function (id) {\n    return s.page.shapes[id].children !== undefined;\n  });\n};\n\nvar ContextMenu = /*#__PURE__*/React.memo(function (_ref) {\n  var children = _ref.children;\n\n  var _useTLDrawContext = useTLDrawContext(),\n      tlstate = _useTLDrawContext.tlstate,\n      useAppState = _useTLDrawContext.useAppState;\n\n  var hasSelection = useAppState(has1SelectedIdsSelector);\n  var hasTwoOrMore = useAppState(has2SelectedIdsSelector);\n  var hasThreeOrMore = useAppState(has3SelectedIdsSelector);\n  var isDebugMode = useAppState(isDebugModeSelector);\n  var hasGroupSelected = useAppState(hasGroupSelectedSelector);\n  var rContent = React.useRef(null);\n  var handleDuplicate = React.useCallback(function () {\n    tlstate.duplicate();\n  }, [tlstate]);\n  var handleGroup = React.useCallback(function () {\n    tlstate.group();\n  }, [tlstate]);\n  var handleMoveToBack = React.useCallback(function () {\n    tlstate.moveToBack();\n  }, [tlstate]);\n  var handleMoveBackward = React.useCallback(function () {\n    tlstate.moveBackward();\n  }, [tlstate]);\n  var handleMoveForward = React.useCallback(function () {\n    tlstate.moveForward();\n  }, [tlstate]);\n  var handleMoveToFront = React.useCallback(function () {\n    tlstate.moveToFront();\n  }, [tlstate]);\n  var handleDelete = React.useCallback(function () {\n    tlstate[\"delete\"]();\n  }, [tlstate]);\n  var handleCopyAsJson = React.useCallback(function () {\n    tlstate.copyAsJson();\n  }, [tlstate]);\n  var handleCopyAsSvg = React.useCallback(function () {\n    tlstate.copyAsSvg();\n  }, [tlstate]);\n  var handleUndo = React.useCallback(function () {\n    tlstate.undo();\n  }, [tlstate]);\n  var handleRedo = React.useCallback(function () {\n    tlstate.redo();\n  }, [tlstate]);\n  return React.createElement(ContextMenuRoot, null, React.createElement(ContextMenu$1.Trigger, null, children), React.createElement(MenuContent, {\n    as: ContextMenu$1.Content,\n    ref: rContent\n  }, hasSelection ? React.createElement(React.Fragment, null, React.createElement(ContextMenuButton, {\n    onSelect: handleDuplicate\n  }, React.createElement(\"span\", null, \"Duplicate\"), React.createElement(Kbd, {\n    variant: \"menu\"\n  }, \"#D\")), React.createElement(ContextMenuDivider, null), hasGroupSelected || hasTwoOrMore && React.createElement(React.Fragment, null, hasGroupSelected && React.createElement(ContextMenuButton, {\n    onSelect: handleGroup\n  }, React.createElement(\"span\", null, \"Ungroup\"), React.createElement(Kbd, {\n    variant: \"menu\"\n  }, \"#\\u21E7G\")), hasTwoOrMore && React.createElement(ContextMenuButton, {\n    onSelect: handleGroup\n  }, React.createElement(\"span\", null, \"Group\"), React.createElement(Kbd, {\n    variant: \"menu\"\n  }, \"#G\"))), React.createElement(ContextMenuSubMenu, {\n    label: \"Move\"\n  }, React.createElement(ContextMenuButton, {\n    onSelect: handleMoveToFront\n  }, React.createElement(\"span\", null, \"To Front\"), React.createElement(Kbd, {\n    variant: \"menu\"\n  }, \"# \\u21E7 ]\")), React.createElement(ContextMenuButton, {\n    onSelect: handleMoveForward\n  }, React.createElement(\"span\", null, \"Forward\"), React.createElement(Kbd, {\n    variant: \"menu\"\n  }, \"# ]\")), React.createElement(ContextMenuButton, {\n    onSelect: handleMoveBackward\n  }, React.createElement(\"span\", null, \"Backward\"), React.createElement(Kbd, {\n    variant: \"menu\"\n  }, \"# [\")), React.createElement(ContextMenuButton, {\n    onSelect: handleMoveToBack\n  }, React.createElement(\"span\", null, \"To Back\"), React.createElement(Kbd, {\n    variant: \"menu\"\n  }, \"# \\u21E7 [\"))), hasTwoOrMore && React.createElement(AlignDistributeSubMenu, {\n    hasTwoOrMore: hasTwoOrMore,\n    hasThreeOrMore: hasThreeOrMore\n  }), isDebugMode && React.createElement(ContextMenuButton, {\n    onSelect: handleCopyAsJson\n  }, React.createElement(\"span\", null, \"Copy Data\"), React.createElement(Kbd, {\n    variant: \"menu\"\n  }, \"# \\u21E7 C\")), React.createElement(ContextMenuButton, {\n    onSelect: handleCopyAsSvg\n  }, React.createElement(\"span\", null, \"Copy to SVG\"), React.createElement(Kbd, {\n    variant: \"menu\"\n  }, \"# \\u21E7 C\")), React.createElement(ContextMenuDivider, null), React.createElement(ContextMenuButton, {\n    onSelect: handleDelete\n  }, React.createElement(\"span\", null, \"Delete\"), React.createElement(Kbd, {\n    variant: \"menu\"\n  }, \"\\u232B\"))) : React.createElement(React.Fragment, null, React.createElement(ContextMenuButton, {\n    onSelect: handleUndo\n  }, React.createElement(\"span\", null, \"Undo\"), React.createElement(Kbd, {\n    variant: \"menu\"\n  }, \"# Z\")), React.createElement(ContextMenuButton, {\n    onSelect: handleRedo\n  }, React.createElement(\"span\", null, \"Redo\"), React.createElement(Kbd, {\n    variant: \"menu\"\n  }, \"# \\u21E7 Z\")))));\n});\n\nfunction AlignDistributeSubMenu(_ref2) {\n  var hasThreeOrMore = _ref2.hasThreeOrMore;\n\n  var _useTLDrawContext2 = useTLDrawContext(),\n      tlstate = _useTLDrawContext2.tlstate;\n\n  var alignTop = React.useCallback(function () {\n    tlstate.align(exports.AlignType.Top);\n  }, [tlstate]);\n  var alignCenterVertical = React.useCallback(function () {\n    tlstate.align(exports.AlignType.CenterVertical);\n  }, [tlstate]);\n  var alignBottom = React.useCallback(function () {\n    tlstate.align(exports.AlignType.Bottom);\n  }, [tlstate]);\n  var stretchVertically = React.useCallback(function () {\n    tlstate.stretch(exports.StretchType.Vertical);\n  }, [tlstate]);\n  var distributeVertically = React.useCallback(function () {\n    tlstate.distribute(exports.DistributeType.Vertical);\n  }, [tlstate]);\n  var alignLeft = React.useCallback(function () {\n    tlstate.align(exports.AlignType.Left);\n  }, [tlstate]);\n  var alignCenterHorizontal = React.useCallback(function () {\n    tlstate.align(exports.AlignType.CenterHorizontal);\n  }, [tlstate]);\n  var alignRight = React.useCallback(function () {\n    tlstate.align(exports.AlignType.Right);\n  }, [tlstate]);\n  var stretchHorizontally = React.useCallback(function () {\n    tlstate.stretch(exports.StretchType.Horizontal);\n  }, [tlstate]);\n  var distributeHorizontally = React.useCallback(function () {\n    tlstate.distribute(exports.DistributeType.Horizontal);\n  }, [tlstate]);\n  return React.createElement(ContextMenuRoot, null, React.createElement(ContextMenu$1.TriggerItem, {\n    as: RowButton,\n    bp: breakpoints\n  }, React.createElement(\"span\", null, \"Align / Distribute\"), React.createElement(IconWrapper, {\n    size: \"small\"\n  }, React.createElement(reactIcons.ChevronRightIcon, null))), React.createElement(StyledGrid, {\n    as: ContextMenu$1.Content,\n    sideOffset: 2,\n    alignOffset: -2,\n    selectedStyle: hasThreeOrMore ? 'threeOrMore' : 'twoOrMore'\n  }, React.createElement(ContextMenuIconButton, {\n    onSelect: alignLeft\n  }, React.createElement(reactIcons.AlignLeftIcon, null)), React.createElement(ContextMenuIconButton, {\n    onSelect: alignCenterHorizontal\n  }, React.createElement(reactIcons.AlignCenterHorizontallyIcon, null)), React.createElement(ContextMenuIconButton, {\n    onSelect: alignRight\n  }, React.createElement(reactIcons.AlignRightIcon, null)), React.createElement(ContextMenuIconButton, {\n    onSelect: stretchHorizontally\n  }, React.createElement(reactIcons.StretchHorizontallyIcon, null)), hasThreeOrMore && React.createElement(ContextMenuIconButton, {\n    onSelect: distributeHorizontally\n  }, React.createElement(reactIcons.SpaceEvenlyHorizontallyIcon, null)), React.createElement(ContextMenuIconButton, {\n    onSelect: alignTop\n  }, React.createElement(reactIcons.AlignTopIcon, null)), React.createElement(ContextMenuIconButton, {\n    onSelect: alignCenterVertical\n  }, React.createElement(reactIcons.AlignCenterVerticallyIcon, null)), React.createElement(ContextMenuIconButton, {\n    onSelect: alignBottom\n  }, React.createElement(reactIcons.AlignBottomIcon, null)), React.createElement(ContextMenuIconButton, {\n    onSelect: stretchVertically\n  }, React.createElement(reactIcons.StretchVerticallyIcon, null)), hasThreeOrMore && React.createElement(ContextMenuIconButton, {\n    onSelect: distributeVertically\n  }, React.createElement(reactIcons.SpaceEvenlyVerticallyIcon, null)), React.createElement(ContextMenuArrow, {\n    offset: 13\n  })));\n}\n\nvar StyledGrid = /*#__PURE__*/styled(MenuContent, {\n  display: 'grid',\n  variants: {\n    selectedStyle: {\n      threeOrMore: {\n        gridTemplateColumns: 'repeat(5, auto)'\n      },\n      twoOrMore: {\n        gridTemplateColumns: 'repeat(4, auto)'\n      }\n    }\n  }\n}); // function MoveToPageMenu() {\n//   const documentPages = useSelector((s) => s.data.document.pages)\n//   const currentPageId = useSelector((s) => s.data.currentPageId)\n//   if (!documentPages[currentPageId]) return null\n//   const sorted = Object.values(documentPages)\n//     .sort((a, b) => a.childIndex - b.childIndex)\n//     .filter((a) => a.id !== currentPageId)\n//   if (sorted.length === 0) return null\n//   return (\n//     <ContextMenuRoot>\n//       <ContextMenuButton>\n//         <span>Move To Page</span>\n//         <IconWrapper size=\"small\">\n//           <ChevronRightIcon />\n//         </IconWrapper>\n//       </ContextMenuButton>\n//       <MenuContent as={RadixContextMenu.Content} sideOffset={2} alignOffset={-2}>\n//         {sorted.map(({ id, name }) => (\n//           <ContextMenuButton\n//             key={id}\n//             disabled={id === currentPageId}\n//             onSelect={() => state.send('MOVED_TO_PAGE', { id })}\n//           >\n//             <span>{name}</span>\n//           </ContextMenuButton>\n//         ))}\n//         <ContextMenuArrow offset={13} />\n//       </MenuContent>\n//     </ContextMenuRoot>\n//   )\n// }\n\nfunction SvgRedo(props) {\n  return React.createElement(\"svg\", _extends({\n    viewBox: \"0 0 15 15\",\n    fill: \"currentColor\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props), React.createElement(\"path\", {\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\",\n    d: \"M12.5 2.495a.5.5 0 00-.5.5v2.5H9.5a.5.5 0 100 1h3a.5.5 0 00.5-.5v-3a.5.5 0 00-.5-.5z\"\n  }), React.createElement(\"path\", {\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\",\n    d: \"M7.697 2.049a5 5 0 104.02 6.613.5.5 0 10-.944-.332 4 4 0 11-.946-4.16l.01.01 2.32 2.18a.5.5 0 00.685-.729l-2.314-2.175A5 5 0 007.697 2.05z\"\n  }));\n}\n\nfunction SvgTrash(props) {\n  return React.createElement(\"svg\", _extends({\n    viewBox: \"0 0 15 15\",\n    fill: \"currentColor\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props), React.createElement(\"path\", {\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\",\n    d: \"M2 4.656a.5.5 0 01.5-.5h9.7a.5.5 0 010 1H2.5a.5.5 0 01-.5-.5z\"\n  }), React.createElement(\"path\", {\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\",\n    d: \"M6.272 3a.578.578 0 00-.578.578v.578h3.311v-.578A.578.578 0 008.428 3H6.272zm3.733 1.156v-.578A1.578 1.578 0 008.428 2H6.272a1.578 1.578 0 00-1.578 1.578v.578H3.578a.5.5 0 00-.5.5V12.2a1.578 1.578 0 001.577 1.578h5.39a1.578 1.578 0 001.577-1.578V4.656a.5.5 0 00-.5-.5h-1.117zm-5.927 1V12.2a.578.578 0 00.577.578h5.39a.578.578 0 00.577-.578V5.156H4.078z\"\n  }), React.createElement(\"path\", {\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\",\n    d: \"M6.272 6.85a.5.5 0 01.5.5v3.233a.5.5 0 11-1 0V7.35a.5.5 0 01.5-.5zM8.428 6.85a.5.5 0 01.5.5v3.233a.5.5 0 11-1 0V7.35a.5.5 0 01.5-.5z\"\n  }));\n}\n\nfunction SvgUndo(props) {\n  return React.createElement(\"svg\", _extends({\n    viewBox: \"0 0 15 15\",\n    fill: \"currentColor\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, props), React.createElement(\"path\", {\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\",\n    d: \"M2.5 2.495a.5.5 0 01.5.5v2.5h2.5a.5.5 0 110 1h-3a.5.5 0 01-.5-.5v-3a.5.5 0 01.5-.5z\"\n  }), React.createElement(\"path\", {\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\",\n    d: \"M7.303 2.049a5 5 0 11-4.02 6.613.5.5 0 01.944-.332 4 4 0 10.946-4.16l-.01.01-2.32 2.18a.5.5 0 01-.685-.729l2.314-2.175A5 5 0 017.303 2.05z\"\n  }));\n}\n\nvar isAllLockedSelector = function isAllLockedSelector(s) {\n  var selectedIds = s.pageState.selectedIds;\n  return selectedIds.every(function (id) {\n    return s.page.shapes[id].isLocked;\n  });\n};\n\nvar isAllAspectLockedSelector = function isAllAspectLockedSelector(s) {\n  var selectedIds = s.pageState.selectedIds;\n  return selectedIds.every(function (id) {\n    return s.page.shapes[id].isAspectRatioLocked;\n  });\n};\n\nvar isAllGroupedSelector = function isAllGroupedSelector(s) {\n  var selectedShapes = s.pageState.selectedIds.map(function (id) {\n    return s.page.shapes[id];\n  });\n  return selectedShapes.every(function (shape) {\n    return shape.children !== undefined || shape.parentId === selectedShapes[0].parentId && selectedShapes[0].parentId !== s.appState.currentPageId;\n  });\n};\n\nvar hasSelectionSelector = function hasSelectionSelector(s) {\n  return s.pageState.selectedIds.length > 0;\n};\n\nvar hasMultipleSelectionSelector = function hasMultipleSelectionSelector(s) {\n  return s.pageState.selectedIds.length > 1;\n};\n\nvar ShapesFunctions = /*#__PURE__*/React.memo(function () {\n  var _useTLDrawContext = useTLDrawContext(),\n      tlstate = _useTLDrawContext.tlstate,\n      useAppState = _useTLDrawContext.useAppState;\n\n  var isAllLocked = useAppState(isAllLockedSelector);\n  var isAllAspectLocked = useAppState(isAllAspectLockedSelector);\n  var isAllGrouped = useAppState(isAllGroupedSelector);\n  var hasSelection = useAppState(hasSelectionSelector);\n  var hasMultipleSelection = useAppState(hasMultipleSelectionSelector);\n  var handleRotate = React.useCallback(function () {\n    tlstate.rotate();\n  }, [tlstate]);\n  var handleDuplicate = React.useCallback(function () {\n    tlstate.duplicate();\n  }, [tlstate]);\n  var handleToggleLocked = React.useCallback(function () {\n    tlstate.toggleLocked();\n  }, [tlstate]);\n  var handleToggleAspectRatio = React.useCallback(function () {\n    tlstate.toggleAspectRatioLocked();\n  }, [tlstate]);\n  var handleGroup = React.useCallback(function () {\n    tlstate.group();\n  }, [tlstate]);\n  var handleMoveToBack = React.useCallback(function () {\n    tlstate.moveToBack();\n  }, [tlstate]);\n  var handleMoveBackward = React.useCallback(function () {\n    tlstate.moveBackward();\n  }, [tlstate]);\n  var handleMoveForward = React.useCallback(function () {\n    tlstate.moveForward();\n  }, [tlstate]);\n  var handleMoveToFront = React.useCallback(function () {\n    tlstate.moveToFront();\n  }, [tlstate]);\n  var handleDelete = React.useCallback(function () {\n    tlstate[\"delete\"]();\n  }, [tlstate]);\n  return React.createElement(React.Fragment, null, React.createElement(ButtonsRow, null, React.createElement(IconButton, {\n    bp: breakpoints,\n    disabled: !hasSelection,\n    size: \"small\",\n    onClick: handleDuplicate\n  }, React.createElement(Tooltip, {\n    label: \"Duplicate\",\n    kbd: \"#D\"\n  }, React.createElement(reactIcons.CopyIcon, null))), React.createElement(IconButton, {\n    disabled: !hasSelection,\n    size: \"small\",\n    onClick: handleRotate\n  }, React.createElement(Tooltip, {\n    label: \"Rotate\"\n  }, React.createElement(reactIcons.RotateCounterClockwiseIcon, null))), React.createElement(IconButton, {\n    bp: breakpoints,\n    disabled: !hasSelection,\n    size: \"small\",\n    onClick: handleToggleLocked\n  }, React.createElement(Tooltip, {\n    label: \"Toogle Locked\",\n    kbd: \"#L\"\n  }, isAllLocked ? React.createElement(reactIcons.LockClosedIcon, null) : React.createElement(reactIcons.LockOpen1Icon, {\n    opacity: 0.4\n  }))), React.createElement(IconButton, {\n    bp: breakpoints,\n    disabled: !hasSelection,\n    size: \"small\",\n    onClick: handleToggleAspectRatio\n  }, React.createElement(Tooltip, {\n    label: \"Toogle Aspect Ratio Lock\"\n  }, React.createElement(reactIcons.AspectRatioIcon, {\n    opacity: isAllAspectLocked ? 1 : 0.4\n  }))), React.createElement(IconButton, {\n    bp: breakpoints,\n    disabled: !isAllGrouped && !hasMultipleSelection,\n    size: \"small\",\n    onClick: handleGroup\n  }, React.createElement(Tooltip, {\n    label: \"Group\",\n    kbd: \"#G\"\n  }, React.createElement(reactIcons.GroupIcon, {\n    opacity: isAllGrouped ? 1 : 0.4\n  })))), React.createElement(ButtonsRow, null, React.createElement(IconButton, {\n    bp: breakpoints,\n    disabled: !hasSelection,\n    size: \"small\",\n    onClick: handleMoveToBack\n  }, React.createElement(Tooltip, {\n    label: \"Move to Back\",\n    kbd: \"#\\u21E7[\"\n  }, React.createElement(reactIcons.PinBottomIcon, null))), React.createElement(IconButton, {\n    bp: breakpoints,\n    disabled: !hasSelection,\n    size: \"small\",\n    onClick: handleMoveBackward\n  }, React.createElement(Tooltip, {\n    label: \"Move Backward\",\n    kbd: \"#[\"\n  }, React.createElement(reactIcons.ArrowDownIcon, null))), React.createElement(IconButton, {\n    bp: breakpoints,\n    disabled: !hasSelection,\n    size: \"small\",\n    onClick: handleMoveForward\n  }, React.createElement(Tooltip, {\n    label: \"Move Forward\",\n    kbd: \"#]\"\n  }, React.createElement(reactIcons.ArrowUpIcon, null))), React.createElement(IconButton, {\n    bp: breakpoints,\n    disabled: !hasSelection,\n    size: \"small\",\n    onClick: handleMoveToFront\n  }, React.createElement(Tooltip, {\n    label: \"More to Front\",\n    kbd: \"#\\u21E7]\"\n  }, React.createElement(reactIcons.PinTopIcon, null))), React.createElement(IconButton, {\n    bp: breakpoints,\n    disabled: !hasSelection,\n    size: \"small\",\n    onClick: handleDelete\n  }, React.createElement(Tooltip, {\n    label: \"Delete\",\n    kbd: \"\\u232B\"\n  }, React.createElement(SvgTrash, null)))));\n});\n\nvar AlignDistribute = /*#__PURE__*/React.memo(function (_ref) {\n  var hasTwoOrMore = _ref.hasTwoOrMore,\n      hasThreeOrMore = _ref.hasThreeOrMore;\n\n  var _useTLDrawContext = useTLDrawContext(),\n      tlstate = _useTLDrawContext.tlstate;\n\n  var alignTop = React.useCallback(function () {\n    tlstate.align(exports.AlignType.Top);\n  }, [tlstate]);\n  var alignCenterVertical = React.useCallback(function () {\n    tlstate.align(exports.AlignType.CenterVertical);\n  }, [tlstate]);\n  var alignBottom = React.useCallback(function () {\n    tlstate.align(exports.AlignType.Bottom);\n  }, [tlstate]);\n  var stretchVertically = React.useCallback(function () {\n    tlstate.stretch(exports.StretchType.Vertical);\n  }, [tlstate]);\n  var distributeVertically = React.useCallback(function () {\n    tlstate.distribute(exports.DistributeType.Vertical);\n  }, [tlstate]);\n  var alignLeft = React.useCallback(function () {\n    tlstate.align(exports.AlignType.Left);\n  }, [tlstate]);\n  var alignCenterHorizontal = React.useCallback(function () {\n    tlstate.align(exports.AlignType.CenterHorizontal);\n  }, [tlstate]);\n  var alignRight = React.useCallback(function () {\n    tlstate.align(exports.AlignType.Right);\n  }, [tlstate]);\n  var stretchHorizontally = React.useCallback(function () {\n    tlstate.stretch(exports.StretchType.Horizontal);\n  }, [tlstate]);\n  var distributeHorizontally = React.useCallback(function () {\n    tlstate.distribute(exports.DistributeType.Horizontal);\n  }, [tlstate]);\n  return React.createElement(React.Fragment, null, React.createElement(ButtonsRow, null, React.createElement(IconButton, {\n    bp: breakpoints,\n    size: \"small\",\n    disabled: !hasTwoOrMore,\n    onClick: alignLeft\n  }, React.createElement(reactIcons.AlignLeftIcon, null)), React.createElement(IconButton, {\n    bp: breakpoints,\n    size: \"small\",\n    disabled: !hasTwoOrMore,\n    onClick: alignCenterHorizontal\n  }, React.createElement(reactIcons.AlignCenterHorizontallyIcon, null)), React.createElement(IconButton, {\n    bp: breakpoints,\n    size: \"small\",\n    disabled: !hasTwoOrMore,\n    onClick: alignRight\n  }, React.createElement(reactIcons.AlignRightIcon, null)), React.createElement(IconButton, {\n    bp: breakpoints,\n    size: \"small\",\n    disabled: !hasTwoOrMore,\n    onClick: stretchHorizontally\n  }, React.createElement(reactIcons.StretchHorizontallyIcon, null)), React.createElement(IconButton, {\n    bp: breakpoints,\n    size: \"small\",\n    disabled: !hasThreeOrMore,\n    onClick: distributeHorizontally\n  }, React.createElement(reactIcons.SpaceEvenlyHorizontallyIcon, null))), React.createElement(ButtonsRow, null, React.createElement(IconButton, {\n    bp: breakpoints,\n    size: \"small\",\n    disabled: !hasTwoOrMore,\n    onClick: alignTop\n  }, React.createElement(reactIcons.AlignTopIcon, null)), React.createElement(IconButton, {\n    bp: breakpoints,\n    size: \"small\",\n    disabled: !hasTwoOrMore,\n    onClick: alignCenterVertical\n  }, React.createElement(reactIcons.AlignCenterVerticallyIcon, null)), React.createElement(IconButton, {\n    bp: breakpoints,\n    size: \"small\",\n    disabled: !hasTwoOrMore,\n    onClick: alignBottom\n  }, React.createElement(reactIcons.AlignBottomIcon, null)), React.createElement(IconButton, {\n    bp: breakpoints,\n    size: \"small\",\n    disabled: !hasTwoOrMore,\n    onClick: stretchVertically\n  }, React.createElement(reactIcons.StretchVerticallyIcon, null)), React.createElement(IconButton, {\n    bp: breakpoints,\n    size: \"small\",\n    disabled: !hasThreeOrMore,\n    onClick: distributeVertically\n  }, React.createElement(reactIcons.SpaceEvenlyVerticallyIcon, null))));\n});\n\nvar StyleDropdownContent = /*#__PURE__*/styled('div', {\n  display: 'grid',\n  padding: 4,\n  gridTemplateColumns: 'repeat(4, 1fr)',\n  backgroundColor: '$panel',\n  borderRadius: 4,\n  border: '1px solid $panel',\n  boxShadow: '$4',\n  variants: {\n    direction: {\n      vertical: {\n        gridTemplateColumns: '1fr'\n      }\n    }\n  }\n});\nvar StyleDropdownItem = /*#__PURE__*/styled('button', {\n  height: '32px',\n  width: '32px',\n  backgroundColor: '$panel',\n  borderRadius: '4px',\n  padding: '0',\n  margin: '0',\n  display: 'flex',\n  alignItems: 'center',\n  justifyContent: 'center',\n  outline: 'none',\n  border: 'none',\n  pointerEvents: 'all',\n  cursor: 'pointer',\n  '&:focus': {\n    backgroundColor: '$hover'\n  },\n  '&:hover:not(:disabled)': {\n    backgroundColor: '$hover'\n  },\n  '&:disabled': {\n    opacity: '0.5'\n  },\n  variants: {\n    isActive: {\n      \"true\": {\n        '& svg': {\n          fill: '$text',\n          stroke: '$text'\n        }\n      },\n      \"false\": {\n        '& svg': {\n          fill: '$inactive',\n          stroke: '$inactive'\n        }\n      }\n    }\n  }\n});\nfunction BoxIcon(_ref) {\n  var _ref$fill = _ref.fill,\n      fill = _ref$fill === void 0 ? 'none' : _ref$fill,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === void 0 ? 'currentColor' : _ref$stroke;\n  return React.createElement(\"svg\", {\n    width: \"24\",\n    height: \"24\",\n    viewBox: \"0 0 24 24\",\n    stroke: stroke,\n    fill: fill,\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, React.createElement(\"rect\", {\n    x: \"4\",\n    y: \"4\",\n    width: \"16\",\n    height: \"16\",\n    rx: \"2\",\n    strokeWidth: \"2\"\n  }));\n}\nfunction DashSolidIcon() {\n  return React.createElement(\"svg\", {\n    width: \"24\",\n    height: \"24\",\n    stroke: \"currentColor\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, React.createElement(\"circle\", {\n    cx: 12,\n    cy: 12,\n    r: 8,\n    fill: \"none\",\n    strokeWidth: 2,\n    strokeLinecap: \"round\"\n  }));\n}\nfunction DashDashedIcon() {\n  return React.createElement(\"svg\", {\n    width: \"24\",\n    height: \"24\",\n    stroke: \"currentColor\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, React.createElement(\"circle\", {\n    cx: 12,\n    cy: 12,\n    r: 8,\n    fill: \"none\",\n    strokeWidth: 2.5,\n    strokeLinecap: \"round\",\n    strokeDasharray: 50.26548 * 0.1\n  }));\n}\nvar dottedDasharray = 50.26548 * 0.025 + \" \" + 50.26548 * 0.1;\nfunction DashDottedIcon() {\n  return React.createElement(\"svg\", {\n    width: \"24\",\n    height: \"24\",\n    stroke: \"currentColor\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, React.createElement(\"circle\", {\n    cx: 12,\n    cy: 12,\n    r: 8,\n    fill: \"none\",\n    strokeWidth: 2.5,\n    strokeLinecap: \"round\",\n    strokeDasharray: dottedDasharray\n  }));\n}\nfunction DashDrawIcon() {\n  return React.createElement(\"svg\", {\n    width: \"24\",\n    height: \"24\",\n    viewBox: \"1 1.5 21 22\",\n    fill: \"currentColor\",\n    stroke: \"currentColor\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, React.createElement(\"path\", {\n    d: \"M10.0162 19.2768C10.0162 19.2768 9.90679 19.2517 9.6879 19.2017C9.46275 19.1454 9.12816 19.0422 8.68413 18.8921C8.23384 18.7358 7.81482 18.545 7.42707 18.3199C7.03307 18.101 6.62343 17.7883 6.19816 17.3818C5.77289 16.9753 5.33511 16.3718 4.88482 15.5713C4.43453 14.7645 4.1531 13.8545 4.04053 12.8414C3.92795 11.822 4.04991 10.8464 4.40639 9.91451C4.76286 8.98266 5.39452 8.10084 6.30135 7.26906C7.21444 6.44353 8.29325 5.83377 9.5378 5.43976C10.7823 5.05202 11.833 4.92068 12.6898 5.04576C13.5466 5.16459 14.3878 5.43664 15.2133 5.86191C16.0388 6.28718 16.7768 6.8688 17.4272 7.60678C18.0714 8.34475 18.5404 9.21406 18.8344 10.2147C19.1283 11.2153 19.1721 12.2598 18.9657 13.348C18.7593 14.4299 18.2872 15.4337 17.5492 16.3593C16.8112 17.2849 15.9263 18.0072 14.8944 18.5263C13.8624 19.0391 12.9056 19.3174 12.0238 19.3612C11.142 19.405 10.2101 19.2705 9.22823 18.9578C8.24635 18.6451 7.35828 18.151 6.56402 17.4756C5.77601 16.8002 6.08871 16.8658 7.50212 17.6726C8.90927 18.4731 10.1444 18.8484 11.2076 18.7983C12.2645 18.7545 13.2965 18.4825 14.3034 17.9822C15.3102 17.4819 16.1264 16.8221 16.7518 16.0028C17.3772 15.1835 17.7681 14.3111 17.9244 13.3855C18.0808 12.4599 18.0401 11.5781 17.8025 10.74C17.5586 9.902 17.1739 9.15464 16.6486 8.49797C16.1233 7.8413 15.2289 7.27844 13.9656 6.80939C12.7086 6.34034 11.4203 6.20901 10.1007 6.41539C8.78732 6.61552 7.69599 7.06893 6.82669 7.77564C5.96363 8.48859 5.34761 9.26409 4.97863 10.1021C4.60964 10.9402 4.45329 11.8376 4.50958 12.7945C4.56586 13.7513 4.79101 14.6238 5.18501 15.4118C5.57276 16.1998 5.96363 16.8002 6.35764 17.2129C6.75164 17.6257 7.13313 17.9509 7.50212 18.1886C7.87736 18.4325 8.28074 18.642 8.71227 18.8171C9.15005 18.9922 9.47839 19.111 9.69728 19.1736C9.91617 19.2361 10.0256 19.2705 10.0256 19.2768H10.0162Z\",\n    strokeWidth: \"2\"\n  }));\n}\nfunction IsFilledFillIcon() {\n  return React.createElement(\"svg\", {\n    width: \"24\",\n    height: \"24\",\n    viewBox: \"0 0 24 24\",\n    fill: \"currentColor\",\n    stroke: \"currentColor\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, React.createElement(\"path\", {\n    d: \"M2.6168 11.1303C2.6168 11.1303 2.7023 11.0131 2.8733 10.7788C3.0443 10.5444 3.1298 10.4272 3.1298 10.4272C3.1298 10.4272 3.23333 10.2823 3.4404 9.99236C3.64746 9.70246 3.85889 9.40341 4.0747 9.09521C4.2905 8.78701 4.50606 8.47574 4.72139 8.16141C4.93671 7.84708 5.14338 7.54139 5.3414 7.24432C5.53943 6.94726 5.72068 6.67162 5.88517 6.41742C6.04966 6.16321 6.2116 5.91477 6.37099 5.67211C6.53038 5.42944 6.69528 5.18806 6.86568 4.94796C7.03608 4.70786 7.21694 4.4699 7.40824 4.23409C7.59955 3.99828 7.81063 3.76287 8.0415 3.52787C8.27236 3.29286 8.71114 3.0267 9.35782 2.72937C10.0045 2.43203 10.4713 2.35281 10.7581 2.49169C11.045 2.63057 11.2637 2.84049 11.4141 3.12146C11.5645 3.40243 11.618 3.70079 11.5746 4.01653C11.5312 4.33227 11.4627 4.59891 11.3691 4.81646C11.2756 5.03401 11.0858 5.43918 10.7998 6.03199C10.5139 6.62479 10.2122 7.17617 9.89499 7.68612C9.57773 8.19607 9.25048 8.71529 8.91323 9.24379C8.57598 9.77229 8.24193 10.3038 7.91107 10.8382C7.58021 11.3726 7.2828 11.8729 7.01885 12.339C6.75489 12.8051 6.53711 13.2259 6.36552 13.6014C6.19393 13.977 6.0132 14.3951 5.82332 14.8557C5.63344 15.3163 5.43771 15.617 5.23612 15.7578C5.03453 15.8986 4.80537 15.7993 4.54865 15.4599C4.29193 15.1205 4.11244 14.8722 4.0102 14.7148C3.90796 14.5575 3.97008 14.3802 4.19657 14.183C4.42306 13.9858 4.69016 13.7584 4.99789 13.5009C5.30561 13.2434 5.64245 12.9617 6.00839 12.6559C6.37434 12.35 6.67617 12.0967 6.91389 11.8958C7.15161 11.695 7.39026 11.4926 7.62985 11.2885C7.86944 11.0844 8.15332 10.8467 8.48148 10.5754C8.80965 10.3042 9.23907 9.9577 9.76972 9.53604C10.3004 9.11439 10.867 8.66604 11.4695 8.19102C12.072 7.71599 12.6869 7.22975 13.3142 6.73229C13.9415 6.23483 14.5741 5.73378 15.2121 5.22914C15.85 4.7245 16.4168 4.26953 16.9125 3.86423C17.4081 3.45892 17.7739 3.14715 18.0099 2.92891C18.2459 2.71066 18.5969 2.50912 19.0631 2.32427C19.5292 2.13942 19.8754 2.10947 20.1017 2.23443C20.328 2.35939 20.4959 2.53892 20.6056 2.77302C20.7152 3.00712 20.7455 3.25108 20.6966 3.50489C20.6477 3.75871 20.6108 3.93537 20.5859 4.03487C20.561 4.13437 20.4998 4.32304 20.4023 4.60088C20.3047 4.87872 20.1621 5.17449 19.9745 5.4882C19.7869 5.80191 19.576 6.14669 19.3419 6.52256C19.1078 6.89842 18.9086 7.21331 18.7443 7.46722C18.58 7.72113 18.4142 7.9759 18.2469 8.23153C18.0796 8.48716 17.8836 8.77861 17.6588 9.10588C17.434 9.43316 17.1448 9.84205 16.7912 10.3326C16.4376 10.8231 16.0659 11.342 15.676 11.8893C15.2862 12.4365 14.9001 12.9968 14.5178 13.5701C14.1356 14.1435 13.7682 14.7264 13.4159 15.3191C13.0635 15.9118 12.7579 16.4671 12.4989 16.985C12.24 17.503 12.0533 17.9527 11.9389 18.3342C11.8244 18.7156 11.7224 19.1347 11.6326 19.5912C11.5429 20.0477 11.3788 20.6043 11.1402 21.2609C10.9016 21.9175 10.6425 22.299 10.3629 22.4054C10.0832 22.5118 9.79895 22.5258 9.51015 22.4475C9.22136 22.3692 8.98315 22.2135 8.79554 21.9804C8.60793 21.7473 8.53141 21.5443 8.56597 21.3714C8.60054 21.1985 8.6805 20.9055 8.80586 20.4924C8.93122 20.0794 9.10654 19.7322 9.33182 19.4511C9.55709 19.17 9.8396 18.8347 10.1793 18.4454C10.5191 18.056 10.8588 17.6756 11.1985 17.3041C11.5381 16.9326 11.8676 16.5798 12.1871 16.2457C12.5065 15.9117 12.8481 15.5592 13.2121 15.1882C13.576 14.8173 13.9567 14.4418 14.3542 14.0616C14.7517 13.6814 15.1666 13.3082 15.599 12.9418C16.0313 12.5755 16.437 12.2489 16.8159 11.962C17.1948 11.6752 17.5102 11.4423 17.762 11.2634C18.0138 11.0844 18.3084 10.8902 18.6457 10.6807C18.983 10.4711 19.3744 10.3243 19.82 10.2401C20.2656 10.1559 20.6534 10.2693 20.9834 10.5803C21.3134 10.8913 21.4496 11.2717 21.392 11.7215C21.3344 12.1713 21.1067 12.5051 20.7089 12.7229C20.3112 12.9406 19.9073 12.9526 19.4973 12.7588C19.0873 12.565 18.8402 12.2453 18.7561 11.7997C18.6719 11.3541 18.7853 10.9663 19.0963 10.6363C19.4073 10.3063 19.7877 10.1701 20.2375 10.2277C20.6873 10.2853 21.0211 10.513 21.2388 10.9108C21.4566 11.3086 21.4686 11.7124 21.2748 12.1224C21.081 12.5324 20.8095 12.8344 20.4603 13.0286C20.1111 13.2227 19.8038 13.4005 19.5384 13.5619C19.273 13.7233 18.9732 13.9304 18.6387 14.1834C18.3043 14.4364 17.9499 14.7309 17.5755 15.0671C17.201 15.4032 16.8338 15.7568 16.4739 16.1278C16.114 16.4987 15.762 16.8738 15.418 17.253C15.0741 17.6321 14.7467 17.9939 14.4358 18.3383C14.125 18.6826 13.8006 19.0346 13.4627 19.3941C13.1248 19.7537 12.7843 20.1151 12.4411 20.4784C12.0979 20.8417 11.7811 21.1784 11.4907 21.4885C11.2003 21.7987 11.0097 22.0025 10.9187 22.0998C10.8278 22.1971 10.6425 22.299 10.3629 22.4054C10.0832 22.5118 9.79895 22.5258 9.51015 22.4475C9.22136 22.3692 8.98315 22.2135 8.79554 21.9804C8.60793 21.7473 8.56361 21.2915 8.6626 20.6129C8.76158 19.9344 8.86025 19.4336 8.95861 19.1104C9.05697 18.7873 9.15977 18.4792 9.267 18.186C9.37423 17.8929 9.51059 17.5722 9.67609 17.2241C9.84159 16.8759 10.0617 16.4208 10.3365 15.8586C10.6113 15.2963 10.9173 14.6928 11.2544 14.0481C11.5915 13.4033 11.9371 12.7709 12.2911 12.1509C12.645 11.5309 12.9985 10.928 13.3515 10.3421C13.7045 9.75628 14.043 9.20593 14.3669 8.6911C14.6908 8.17628 14.9637 7.75371 15.1856 7.42339C15.4075 7.09308 15.6064 6.80362 15.7825 6.55501C15.9585 6.3064 16.1337 6.06006 16.3078 5.81598C16.482 5.5719 16.6533 5.33288 16.8217 5.09891C16.9901 4.86494 17.216 4.59736 17.4993 4.29615C17.7826 3.99495 18.1463 3.6271 18.5904 3.1926C19.0345 2.7581 19.3409 2.45855 19.5094 2.29392C19.678 2.1293 19.8754 2.10947 20.1017 2.23443C20.328 2.35939 20.4959 2.53892 20.6056 2.77302C20.7152 3.00712 20.7455 3.25108 20.6966 3.50489C20.6477 3.75871 20.3584 4.05693 19.8288 4.39957C19.2993 4.7422 18.7953 5.11711 18.3168 5.52431C17.8384 5.93151 17.3057 6.40907 16.7189 6.95701C16.1321 7.50495 15.554 8.0585 14.9846 8.61766C14.4151 9.17682 13.8571 9.72936 13.3104 10.2753C12.7637 10.8212 12.2439 11.3334 11.7509 11.8119C11.258 12.2905 10.8516 12.6747 10.5319 12.9645C10.2122 13.2543 9.93102 13.503 9.68844 13.7105C9.44586 13.918 9.20376 14.1242 8.96214 14.329C8.72051 14.5339 8.41222 14.7917 8.03728 15.1027C7.66233 15.4136 7.3052 15.7042 6.96587 15.9744C6.62655 16.2447 6.30615 16.4867 6.00468 16.7005C5.70321 16.9143 5.4028 17.1012 5.10345 17.2611C4.8041 17.421 4.46527 17.4827 4.08697 17.4462C3.70867 17.4098 3.36157 17.209 3.04566 16.8439C2.72975 16.4788 2.5775 16.0785 2.58891 15.6432C2.60033 15.2079 2.70674 14.7684 2.90815 14.3248C3.10956 13.8811 3.29546 13.4939 3.46586 13.163C3.63625 12.832 3.80799 12.5116 3.98107 12.2016C4.15415 11.8916 4.37223 11.4904 4.6353 10.9979C4.89838 10.5055 5.18148 9.97864 5.48461 9.41727C5.78773 8.8559 6.08723 8.30477 6.3831 7.7639C6.67898 7.22302 6.96213 6.69976 7.23257 6.19412C7.50301 5.68847 7.75585 5.24404 7.99109 4.86081C8.22633 4.47759 8.57505 4.04675 9.03725 3.56831C9.49946 3.08987 9.8301 2.7561 10.0292 2.56701C10.2283 2.37791 10.4713 2.35281 10.7581 2.49169C11.045 2.63057 11.2637 2.84049 11.4141 3.12146C11.5645 3.40243 11.618 3.70079 11.5746 4.01653C11.5312 4.33227 11.1439 4.77278 10.4128 5.33807C9.68173 5.90336 9.17886 6.30718 8.90421 6.54953C8.62955 6.79188 8.38273 7.01366 8.16374 7.21485C7.94475 7.41605 7.71551 7.6216 7.47603 7.83151C7.23655 8.04141 6.97229 8.26391 6.68326 8.49901C6.39423 8.7341 6.09233 8.96876 5.77756 9.20297C5.46279 9.43719 5.1469 9.6616 4.8299 9.87622C4.5129 10.0908 4.20211 10.2932 3.89753 10.4834L2.6168 11.1303Z\",\n    strokeWidth: \"0.5\",\n    strokeLinecap: \"round\"\n  }));\n}\n\nvar selectColor = function selectColor(data) {\n  return data.appState.selectedStyle.color;\n};\n\nvar QuickColorSelect = /*#__PURE__*/React.memo(function () {\n  var _useTheme = useTheme(),\n      theme = _useTheme.theme;\n\n  var _useTLDrawContext = useTLDrawContext(),\n      tlstate = _useTLDrawContext.tlstate,\n      useAppState = _useTLDrawContext.useAppState;\n\n  var color = useAppState(selectColor);\n  var handleColorChange = React.useCallback(function (color) {\n    tlstate.style({\n      color: color\n    });\n  }, [tlstate]);\n  return React.createElement(DropdownMenu.Root, {\n    dir: \"ltr\"\n  }, React.createElement(DropdownMenuIconTriggerButton, {\n    label: \"Color\"\n  }, React.createElement(BoxIcon, {\n    fill: strokes[theme][color],\n    stroke: strokes[theme][color]\n  })), React.createElement(DropdownMenu.Content, {\n    sideOffset: 8\n  }, React.createElement(DropdownMenu.DropdownMenuRadioGroup, {\n    value: color,\n    onValueChange: handleColorChange,\n    as: StyleDropdownContent\n  }, Object.keys(strokes[theme]).map(function (colorStyle) {\n    return React.createElement(DropdownMenu.DropdownMenuRadioItem, {\n      as: StyleDropdownItem,\n      key: colorStyle,\n      title: colorStyle,\n      value: colorStyle\n    }, React.createElement(BoxIcon, {\n      fill: strokes[theme][colorStyle],\n      stroke: strokes[theme][colorStyle]\n    }));\n  }))));\n});\n\nvar _sizes;\nvar sizes = (_sizes = {}, _sizes[exports.SizeStyle.Small] = 6, _sizes[exports.SizeStyle.Medium] = 12, _sizes[exports.SizeStyle.Large] = 22, _sizes);\n\nvar selectSize = function selectSize(data) {\n  return data.appState.selectedStyle.size;\n};\n\nvar QuickSizeSelect = /*#__PURE__*/React.memo(function () {\n  var _useTLDrawContext = useTLDrawContext(),\n      tlstate = _useTLDrawContext.tlstate,\n      useAppState = _useTLDrawContext.useAppState;\n\n  var size = useAppState(selectSize);\n  var changeSizeStyle = React.useCallback(function (size) {\n    tlstate.style({\n      size: size\n    });\n  }, [tlstate]);\n  return React.createElement(DropdownMenu.Root, {\n    dir: \"ltr\"\n  }, React.createElement(DropdownMenuIconTriggerButton, {\n    label: \"Size\"\n  }, React.createElement(CircleIcon, {\n    size: sizes[size],\n    stroke: \"none\",\n    fill: \"currentColor\"\n  })), React.createElement(DropdownMenu.Content, {\n    sideOffset: 8\n  }, React.createElement(DropdownMenu.DropdownMenuRadioGroup, {\n    as: StyleDropdownContent,\n    direction: \"vertical\",\n    value: size,\n    onValueChange: changeSizeStyle\n  }, Object.keys(exports.SizeStyle).map(function (sizeStyle) {\n    return React.createElement(DropdownMenu.DropdownMenuRadioItem, {\n      key: sizeStyle,\n      as: StyleDropdownItem,\n      isActive: size === sizeStyle,\n      value: sizeStyle\n    }, React.createElement(CircleIcon, {\n      size: sizes[sizeStyle]\n    }));\n  }))));\n});\n\nvar _dashes;\nvar dashes = (_dashes = {}, _dashes[exports.DashStyle.Draw] = /*#__PURE__*/React.createElement(DashDrawIcon, null), _dashes[exports.DashStyle.Solid] = /*#__PURE__*/React.createElement(DashSolidIcon, null), _dashes[exports.DashStyle.Dashed] = /*#__PURE__*/React.createElement(DashDashedIcon, null), _dashes[exports.DashStyle.Dotted] = /*#__PURE__*/React.createElement(DashDottedIcon, null), _dashes);\n\nvar selectDash = function selectDash(data) {\n  return data.appState.selectedStyle.dash;\n};\n\nvar QuickDashSelect = /*#__PURE__*/React.memo(function () {\n  var _useTLDrawContext = useTLDrawContext(),\n      tlstate = _useTLDrawContext.tlstate,\n      useAppState = _useTLDrawContext.useAppState;\n\n  var dash = useAppState(selectDash);\n  var changeDashStyle = React.useCallback(function (dash) {\n    tlstate.style({\n      dash: dash\n    });\n  }, [tlstate]);\n  return React.createElement(DropdownMenu.Root, {\n    dir: \"ltr\"\n  }, React.createElement(DropdownMenuIconTriggerButton, {\n    label: \"Dash\"\n  }, dashes[dash]), React.createElement(DropdownMenu.Content, {\n    sideOffset: 8\n  }, React.createElement(DropdownMenu.DropdownMenuRadioGroup, {\n    as: StyleDropdownContent,\n    direction: \"vertical\",\n    value: dash,\n    onValueChange: changeDashStyle\n  }, Object.keys(exports.DashStyle).map(function (dashStyle) {\n    return React.createElement(DropdownMenu.DropdownMenuRadioItem, {\n      as: StyleDropdownItem,\n      key: dashStyle,\n      isActive: dash === dashStyle,\n      value: dashStyle\n    }, dashes[dashStyle]);\n  }))));\n});\n\nvar isFilledSelector = function isFilledSelector(data) {\n  return data.appState.selectedStyle.isFilled;\n};\n\nvar QuickFillSelect = /*#__PURE__*/React.memo(function () {\n  var _useTLDrawContext = useTLDrawContext(),\n      tlstate = _useTLDrawContext.tlstate,\n      useAppState = _useTLDrawContext.useAppState;\n\n  var isFilled = useAppState(isFilledSelector);\n  var handleIsFilledChange = React.useCallback(function (isFilled) {\n    tlstate.style({\n      isFilled: isFilled\n    });\n  }, [tlstate]);\n  return React.createElement(Checkbox.Root, {\n    dir: \"ltr\",\n    as: IconButton,\n    bp: breakpoints,\n    checked: isFilled,\n    onCheckedChange: handleIsFilledChange\n  }, React.createElement(Tooltip, {\n    label: \"Fill\"\n  }, React.createElement(IconWrapper, null, React.createElement(BoxIcon, null), React.createElement(Checkbox.Indicator, null, React.createElement(IsFilledFillIcon, null)))));\n});\n\nvar isStyleOpenSelector = function isStyleOpenSelector(s) {\n  return s.appState.isStyleOpen;\n};\n\nfunction StylePanel() {\n  var _useTLDrawContext = useTLDrawContext(),\n      tlstate = _useTLDrawContext.tlstate,\n      useAppState = _useTLDrawContext.useAppState;\n\n  var isOpen = useAppState(isStyleOpenSelector);\n  return React.createElement(FloatingContainer, {\n    direction: \"column\"\n  }, React.createElement(ButtonsRow, null, React.createElement(QuickColorSelect, null), React.createElement(QuickSizeSelect, null), React.createElement(QuickDashSelect, null), React.createElement(QuickFillSelect, null), React.createElement(IconButton, {\n    bp: breakpoints,\n    title: \"Style\",\n    size: \"small\",\n    onPointerDown: tlstate.toggleStylePanel\n  }, React.createElement(Tooltip, {\n    label: isOpen ? 'Close' : 'More'\n  }, isOpen ? React.createElement(reactIcons.Cross2Icon, null) : React.createElement(reactIcons.DotsHorizontalIcon, null)))), isOpen && React.createElement(SelectedShapeContent, null));\n}\nvar showKbds = ! /*#__PURE__*/core.Utils.isMobile();\n\nvar selectedShapesCountSelector = function selectedShapesCountSelector(s) {\n  return s.pageState.selectedIds.length;\n};\n\nfunction SelectedShapeContent() {\n  var _useTLDrawContext2 = useTLDrawContext(),\n      tlstate = _useTLDrawContext2.tlstate,\n      useAppState = _useTLDrawContext2.useAppState;\n\n  var selectedShapesCount = useAppState(selectedShapesCountSelector);\n  return React.createElement(React.Fragment, null, React.createElement(Divider, null), React.createElement(ShapesFunctions, null), React.createElement(Divider, null), React.createElement(AlignDistribute, {\n    hasTwoOrMore: selectedShapesCount > 1,\n    hasThreeOrMore: selectedShapesCount > 2\n  }), React.createElement(Divider, null), React.createElement(RowButton, {\n    bp: breakpoints,\n    disabled: selectedShapesCount === 0,\n    onClick: tlstate.copy\n  }, React.createElement(\"span\", null, \"Copy\"), showKbds && React.createElement(Kbd, {\n    variant: \"menu\"\n  }, \"#C\")), React.createElement(RowButton, {\n    bp: breakpoints,\n    onClick: tlstate.paste\n  }, React.createElement(\"span\", null, \"Paste\"), showKbds && React.createElement(Kbd, {\n    variant: \"menu\"\n  }, \"#V\")), React.createElement(RowButton, {\n    bp: breakpoints,\n    onClick: tlstate.copyAsSvg\n  }, React.createElement(\"span\", null, \"Copy to SVG\"), showKbds && React.createElement(Kbd, {\n    variant: \"menu\"\n  }, \"\\u21E7#C\")));\n}\n\nvar activeToolSelector = function activeToolSelector(s) {\n  return s.appState.activeTool;\n};\n\nfunction StatusBar() {\n  var _useTLDrawContext = useTLDrawContext(),\n      useAppState = _useTLDrawContext.useAppState;\n\n  var activeTool = useAppState(activeToolSelector);\n  return React.createElement(StatusBarContainer, {\n    size: {\n      '@sm': 'small'\n    }\n  }, React.createElement(Section, null, activeTool));\n}\nvar StatusBarContainer = /*#__PURE__*/styled('div', {\n  height: 40,\n  userSelect: 'none',\n  borderTop: '1px solid $border',\n  gridArea: 'status',\n  display: 'flex',\n  color: '$text',\n  justifyContent: 'space-between',\n  alignItems: 'center',\n  backgroundColor: '$panel',\n  gap: 8,\n  fontFamily: '$ui',\n  fontSize: '$0',\n  padding: '0 16px',\n  variants: {\n    size: {\n      small: {\n        fontSize: '$1'\n      }\n    }\n  }\n});\nvar Section = /*#__PURE__*/styled('div', {\n  whiteSpace: 'nowrap',\n  overflow: 'hidden'\n});\n\nvar ToolButton = /*#__PURE__*/styled('button', {\n  position: 'relative',\n  height: '32px',\n  width: '32px',\n  color: '$text',\n  backgroundColor: '$panel',\n  borderRadius: '4px',\n  padding: '0',\n  margin: '0',\n  display: 'grid',\n  alignItems: 'center',\n  justifyContent: 'center',\n  outline: 'none',\n  border: 'none',\n  pointerEvents: 'all',\n  fontSize: '$0',\n  cursor: 'pointer',\n  '& > *': {\n    gridRow: 1,\n    gridColumn: 1\n  },\n  '&:disabled': {\n    opacity: '0.5'\n  },\n  '& > span': {\n    width: '100%',\n    height: '100%',\n    display: 'flex',\n    alignItems: 'center'\n  }\n});\nvar PrimaryToolButton = /*#__PURE__*/styled(ToolButton, {\n  variants: {\n    bp: {\n      mobile: {\n        height: 44,\n        width: 44,\n        '& svg:nth-of-type(1)': {\n          height: '20px',\n          width: '20px'\n        }\n      },\n      small: {\n        '&:hover:not(:disabled)': {\n          backgroundColor: '$hover'\n        }\n      },\n      medium: {},\n      large: {}\n    },\n    isActive: {\n      \"true\": {\n        color: '$selected'\n      }\n    }\n  }\n});\nvar SecondaryToolButton = /*#__PURE__*/styled(ToolButton, {\n  variants: {\n    bp: {\n      mobile: {\n        height: 44,\n        width: 44,\n        '& svg:nth-of-type(1)': {\n          height: '18px',\n          width: '18px'\n        }\n      },\n      small: {\n        '&:hover:not(:disabled)': {\n          backgroundColor: '$hover'\n        }\n      },\n      medium: {},\n      large: {}\n    },\n    isActive: {\n      \"true\": {\n        color: '$selected'\n      }\n    }\n  }\n});\nvar TertiaryToolButton = /*#__PURE__*/styled(ToolButton, {\n  variants: {\n    bp: {\n      mobile: {\n        height: 32,\n        width: 44,\n        '& svg:nth-of-type(1)': {\n          height: '16px',\n          width: '16px'\n        }\n      },\n      small: {\n        height: 40,\n        width: 40,\n        '& svg:nth-of-type(1)': {\n          height: '18px',\n          width: '18px'\n        },\n        '&:hover:not(:disabled)': {\n          backgroundColor: '$hover'\n        }\n      },\n      medium: {},\n      large: {}\n    }\n  }\n});\nfunction PrimaryButton(_ref) {\n  var label = _ref.label,\n      kbd = _ref.kbd,\n      onClick = _ref.onClick,\n      onDoubleClick = _ref.onDoubleClick,\n      isActive = _ref.isActive,\n      children = _ref.children;\n  return React.createElement(Tooltip, {\n    label: label[0].toUpperCase() + label.slice(1),\n    kbd: kbd\n  }, React.createElement(PrimaryToolButton, {\n    name: label,\n    bp: {\n      '@initial': 'mobile',\n      '@sm': 'small',\n      '@md': 'medium',\n      '@lg': 'large'\n    },\n    onClick: onClick,\n    onDoubleClick: onDoubleClick,\n    isActive: isActive\n  }, children));\n}\nfunction SecondaryButton(_ref2) {\n  var label = _ref2.label,\n      kbd = _ref2.kbd,\n      onClick = _ref2.onClick,\n      onDoubleClick = _ref2.onDoubleClick,\n      isActive = _ref2.isActive,\n      children = _ref2.children;\n  return React.createElement(Tooltip, {\n    label: label[0].toUpperCase() + label.slice(1),\n    kbd: kbd\n  }, React.createElement(SecondaryToolButton, {\n    name: label,\n    bp: {\n      '@initial': 'mobile',\n      '@sm': 'small',\n      '@md': 'medium',\n      '@lg': 'large'\n    },\n    onClick: onClick,\n    onDoubleClick: onDoubleClick,\n    isActive: isActive\n  }, children));\n}\nfunction TertiaryButton(_ref3) {\n  var label = _ref3.label,\n      kbd = _ref3.kbd,\n      onClick = _ref3.onClick,\n      onDoubleClick = _ref3.onDoubleClick,\n      children = _ref3.children;\n  return React.createElement(Tooltip, {\n    label: label[0].toUpperCase() + label.slice(1),\n    kbd: kbd\n  }, React.createElement(TertiaryToolButton, {\n    name: label,\n    bp: {\n      '@initial': 'mobile',\n      '@sm': 'small',\n      '@md': 'medium',\n      '@lg': 'large'\n    },\n    onClick: onClick,\n    onDoubleClick: onDoubleClick\n  }, children));\n}\nvar TertiaryButtonsContainer = /*#__PURE__*/styled(FloatingContainer, {\n  boxShadow: '$3',\n  variants: {\n    bp: {\n      mobile: {\n        alignItems: 'center',\n        flexDirection: 'column'\n      },\n      small: {\n        alignItems: 'center',\n        flexDirection: 'row'\n      }\n    }\n  }\n});\n\nvar UndoRedo = /*#__PURE__*/React.memo(function () {\n  var _useTLDrawContext = useTLDrawContext(),\n      tlstate = _useTLDrawContext.tlstate;\n\n  var handleDelete = React.useCallback(function () {\n    tlstate[\"delete\"]();\n  }, [tlstate]);\n  var handleClear = React.useCallback(function () {\n    tlstate.clear();\n  }, [tlstate]);\n  return React.createElement(TertiaryButtonsContainer, {\n    bp: {\n      '@initial': 'mobile',\n      '@sm': 'small'\n    }\n  }, React.createElement(TertiaryButton, {\n    label: \"Undo\",\n    kbd: \"#Z\",\n    onClick: tlstate.undo\n  }, React.createElement(SvgUndo, null)), React.createElement(TertiaryButton, {\n    label: \"Redo\",\n    kbd: \"#\\u21E7\",\n    onClick: tlstate.redo\n  }, React.createElement(SvgRedo, null)), React.createElement(TertiaryButton, {\n    label: \"Delete\",\n    kbd: \"\\u232B\",\n    onClick: handleDelete,\n    onDoubleClick: handleClear\n  }, React.createElement(SvgTrash, null)));\n});\n\nvar Zoom = /*#__PURE__*/React.memo(function () {\n  var _useTLDrawContext = useTLDrawContext(),\n      tlstate = _useTLDrawContext.tlstate;\n\n  return React.createElement(TertiaryButtonsContainer, {\n    bp: {\n      '@initial': 'mobile',\n      '@sm': 'small'\n    }\n  }, React.createElement(TertiaryButton, {\n    label: \"Zoom Out\",\n    kbd: \"#\\u2212\",\n    onClick: tlstate.zoomOut\n  }, React.createElement(reactIcons.ZoomOutIcon, null)), React.createElement(TertiaryButton, {\n    label: \"Zoom In\",\n    kbd: \"#+\",\n    onClick: tlstate.zoomIn\n  }, React.createElement(reactIcons.ZoomInIcon, null)), React.createElement(ZoomCounter, null));\n});\n\nvar zoomSelector = function zoomSelector(s) {\n  return s.pageState.camera.zoom;\n};\n\nfunction ZoomCounter() {\n  var _useTLDrawContext2 = useTLDrawContext(),\n      tlstate = _useTLDrawContext2.tlstate,\n      useAppState = _useTLDrawContext2.useAppState;\n\n  var zoom = useAppState(zoomSelector);\n  return React.createElement(TertiaryButton, {\n    label: \"Reset Zoom\",\n    kbd: \"\\u21E70\",\n    onClick: tlstate.zoomToActual,\n    onDoubleClick: tlstate.zoomToFit\n  }, Math.round(zoom * 100), \"%\");\n}\n\nvar isEmptyCanvasSelector = function isEmptyCanvasSelector(s) {\n  return Object.keys(s.page.shapes).length > 0 && s.appState.isEmptyCanvas;\n};\n\nvar BackToContent = /*#__PURE__*/React.memo(function () {\n  var _useTLDrawContext = useTLDrawContext(),\n      tlstate = _useTLDrawContext.tlstate,\n      useAppState = _useTLDrawContext.useAppState;\n\n  var isEmptyCanvas = useAppState(isEmptyCanvasSelector);\n  if (!isEmptyCanvas) return null;\n  return React.createElement(BackToContentButton, null, React.createElement(RowButton, {\n    onClick: tlstate.zoomToContent\n  }, \"Back to content\"));\n});\nvar BackToContentButton = /*#__PURE__*/styled(FloatingContainer, {\n  pointerEvents: 'all',\n  width: 'fit-content',\n  gridRow: 1,\n  flexGrow: 2,\n  display: 'block'\n});\n\nvar activeToolSelector$1 = function activeToolSelector(s) {\n  return s.appState.activeTool;\n};\n\nvar isToolLockedSelector = function isToolLockedSelector(s) {\n  return s.appState.isToolLocked;\n};\n\nvar isDebugModeSelector$1 = function isDebugModeSelector(s) {\n  return s.settings.isDebugMode;\n};\n\nvar ToolsPanel = /*#__PURE__*/React.memo(function () {\n  var _useTLDrawContext = useTLDrawContext(),\n      tlstate = _useTLDrawContext.tlstate,\n      useAppState = _useTLDrawContext.useAppState;\n\n  var activeTool = useAppState(activeToolSelector$1);\n  var isToolLocked = useAppState(isToolLockedSelector);\n  var isDebugMode = useAppState(isDebugModeSelector$1);\n  var selectSelectTool = React.useCallback(function () {\n    tlstate.selectTool('select');\n  }, [tlstate]);\n  var selectDrawTool = React.useCallback(function () {\n    tlstate.selectTool(exports.TLDrawShapeType.Draw);\n  }, [tlstate]);\n  var selectRectangleTool = React.useCallback(function () {\n    tlstate.selectTool(exports.TLDrawShapeType.Rectangle);\n  }, [tlstate]);\n  var selectEllipseTool = React.useCallback(function () {\n    tlstate.selectTool(exports.TLDrawShapeType.Ellipse);\n  }, [tlstate]); // const selectArrowTool = React.useCallback(() => {\n  //   tlstate.selectTool(TLDrawShapeType.Ellipse)\n  // }, [tlstate])\n  // const selectTextTool = React.useCallback(() => {\n  //   tlstate.selectTool(TLDrawShapeType.Ellipse)\n  // }, [tlstate])\n\n  return React.createElement(ToolsPanelContainer, null, React.createElement(LeftWrap, {\n    size: {\n      '@initial': 'mobile',\n      '@sm': 'small'\n    }\n  }, React.createElement(Zoom, null), React.createElement(FloatingContainer, null, React.createElement(SecondaryButton, {\n    label: 'Select',\n    kbd: '1',\n    onClick: selectSelectTool,\n    isActive: activeTool === 'select'\n  }, React.createElement(reactIcons.CursorArrowIcon, null)))), React.createElement(CenterWrap, null, React.createElement(BackToContent, null), React.createElement(FloatingContainer, null, React.createElement(PrimaryButton, {\n    kbd: '2',\n    label: exports.TLDrawShapeType.Draw,\n    onClick: selectDrawTool,\n    isActive: activeTool === exports.TLDrawShapeType.Draw\n  }, React.createElement(reactIcons.Pencil1Icon, null)), React.createElement(PrimaryButton, {\n    kbd: '3',\n    label: exports.TLDrawShapeType.Rectangle,\n    onClick: selectRectangleTool,\n    isActive: activeTool === exports.TLDrawShapeType.Rectangle\n  }, React.createElement(reactIcons.SquareIcon, null)), React.createElement(PrimaryButton, {\n    kbd: '4',\n    label: exports.TLDrawShapeType.Draw,\n    onClick: selectEllipseTool,\n    isActive: activeTool === exports.TLDrawShapeType.Ellipse\n  }, React.createElement(reactIcons.CircleIcon, null)))), React.createElement(RightWrap, {\n    size: {\n      '@initial': 'mobile',\n      '@sm': 'small'\n    }\n  }, React.createElement(FloatingContainer, null, React.createElement(SecondaryButton, {\n    kbd: '7',\n    label: 'Lock Tool',\n    onClick: tlstate.toggleToolLock,\n    isActive: isToolLocked\n  }, isToolLocked ? React.createElement(reactIcons.LockClosedIcon, null) : React.createElement(reactIcons.LockOpen1Icon, null))), React.createElement(UndoRedo, null)), React.createElement(StatusWrap, null, isDebugMode && React.createElement(StatusBar, null)));\n});\nvar ToolsPanelContainer = /*#__PURE__*/styled('div', {\n  position: 'fixed',\n  bottom: 0,\n  left: 0,\n  right: 0,\n  width: '100%',\n  minWidth: 0,\n  maxWidth: '100%',\n  display: 'grid',\n  gridTemplateColumns: '1fr auto 1fr',\n  padding: '0',\n  alignItems: 'flex-end',\n  zIndex: 200,\n  gridGap: '$4',\n  gridRowGap: '$4',\n  pointerEvents: 'none',\n  '& > div > *': {\n    pointerEvents: 'all'\n  }\n});\nvar CenterWrap = /*#__PURE__*/styled('div', {\n  gridRow: 1,\n  gridColumn: 2,\n  display: 'flex',\n  width: 'fit-content',\n  alignItems: 'center',\n  justifyContent: 'center',\n  flexDirection: 'column',\n  gap: 12\n});\nvar LeftWrap = /*#__PURE__*/styled('div', {\n  gridRow: 1,\n  gridColumn: 1,\n  display: 'flex',\n  paddingLeft: '$3',\n  variants: {\n    size: {\n      mobile: {\n        flexDirection: 'column',\n        justifyContent: 'flex-end',\n        alignItems: 'flex-start',\n        '& > *:nth-of-type(1)': {\n          marginBottom: '8px'\n        }\n      },\n      small: {\n        flexDirection: 'row',\n        alignItems: 'flex-end',\n        justifyContent: 'space-between',\n        '& > *:nth-of-type(1)': {\n          marginBottom: '0px'\n        }\n      }\n    }\n  }\n});\nvar RightWrap = /*#__PURE__*/styled('div', {\n  gridRow: 1,\n  gridColumn: 3,\n  display: 'flex',\n  paddingRight: '$3',\n  variants: {\n    size: {\n      mobile: {\n        flexDirection: 'column-reverse',\n        justifyContent: 'flex-end',\n        alignItems: 'flex-end',\n        '& > *:nth-of-type(2)': {\n          marginBottom: '8px'\n        }\n      },\n      small: {\n        flexDirection: 'row',\n        alignItems: 'flex-end',\n        justifyContent: 'space-between',\n        '& > *:nth-of-type(2)': {\n          marginBottom: '0px'\n        }\n      }\n    }\n  }\n});\nvar StatusWrap = /*#__PURE__*/styled('div', {\n  gridRow: 2,\n  gridColumn: '1 / span 3'\n});\n\nvar TLDR = /*#__PURE__*/function () {\n  function TLDR() {}\n\n  TLDR.getShapeUtils = function getShapeUtils$1(shape) {\n    return getShapeUtils(shape);\n  };\n\n  TLDR.getSelectedShapes = function getSelectedShapes(data) {\n    return data.pageState.selectedIds.map(function (id) {\n      return data.page.shapes[id];\n    });\n  };\n\n  TLDR.screenToWorld = function screenToWorld(data, point) {\n    var camera = data.pageState.camera;\n    return core.Vec.sub(core.Vec.div(point, camera.zoom), camera.point);\n  };\n\n  TLDR.getViewport = function getViewport(data) {\n    var _this$screenToWorld = this.screenToWorld(data, [0, 0]),\n        minX = _this$screenToWorld[0],\n        minY = _this$screenToWorld[1];\n\n    var _this$screenToWorld2 = this.screenToWorld(data, [window.innerWidth, window.innerHeight]),\n        maxX = _this$screenToWorld2[0],\n        maxY = _this$screenToWorld2[1];\n\n    return {\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY,\n      height: maxX - minX,\n      width: maxY - minY\n    };\n  };\n\n  TLDR.getCameraZoom = function getCameraZoom(zoom) {\n    return core.Utils.clamp(zoom, 0.1, 5);\n  };\n\n  TLDR.getCurrentCamera = function getCurrentCamera(data) {\n    return data.pageState.camera;\n  };\n\n  TLDR.getPage = function getPage(data) {\n    return data.page;\n  };\n\n  TLDR.getPageState = function getPageState(data) {\n    return data.pageState;\n  };\n\n  TLDR.getSelectedIds = function getSelectedIds(data) {\n    return data.pageState.selectedIds;\n  };\n\n  TLDR.getShapes = function getShapes(data) {\n    return Object.values(data.page.shapes);\n  };\n\n  TLDR.getCamera = function getCamera(data) {\n    return data.pageState.camera;\n  };\n\n  TLDR.getShape = function getShape(data, shapeId) {\n    return data.page.shapes[shapeId];\n  };\n\n  TLDR.getBounds = function getBounds(shape) {\n    return getShapeUtils(shape).getBounds(shape);\n  };\n\n  TLDR.getRotatedBounds = function getRotatedBounds(shape) {\n    return getShapeUtils(shape).getRotatedBounds(shape);\n  };\n\n  TLDR.getSelectedBounds = function getSelectedBounds(data) {\n    return core.Utils.getCommonBounds(this.getSelectedShapes(data).map(function (shape) {\n      return getShapeUtils(shape).getBounds(shape);\n    }));\n  };\n\n  TLDR.getParentId = function getParentId(data, id) {\n    var shape = data.page.shapes[id];\n    return shape.parentId;\n  };\n\n  TLDR.getPointedId = function getPointedId(data, id) {\n    var shape = data.page.shapes[id];\n    if (!shape) return id;\n    return shape.parentId === data.pageState.currentParentId || shape.parentId === data.page.id ? id : this.getPointedId(data, shape.parentId);\n  };\n\n  TLDR.getDrilledPointedId = function getDrilledPointedId(data, id) {\n    var shape = data.page.shapes[id];\n    var _data$pageState = data.pageState,\n        currentParentId = _data$pageState.currentParentId,\n        pointedId = _data$pageState.pointedId;\n    return shape.parentId === data.page.id || shape.parentId === pointedId || shape.parentId === currentParentId ? id : this.getDrilledPointedId(data, shape.parentId);\n  };\n\n  TLDR.getTopParentId = function getTopParentId(data, id) {\n    var shape = data.page.shapes[id];\n\n    if (shape.parentId === shape.id) {\n      throw Error(\"Shape has the same id as its parent! \" + shape.id);\n    }\n\n    return shape.parentId === data.page.id || shape.parentId === data.pageState.currentParentId ? id : this.getTopParentId(data, shape.parentId);\n  } // Get an array of a shape id and its descendant shapes' ids\n  ;\n\n  TLDR.getDocumentBranch = function getDocumentBranch(data, id) {\n    var _this = this;\n\n    var shape = data.page.shapes[id];\n    if (shape.children === undefined) return [id];\n    return [id].concat(shape.children.flatMap(function (childId) {\n      return _this.getDocumentBranch(data, childId);\n    }));\n  };\n\n  TLDR.getSelectedBranchSnapshot = function getSelectedBranchSnapshot(data, fn) {\n    var _this2 = this;\n\n    var page = this.getPage(data);\n    var copies = this.getSelectedIds(data).flatMap(function (id) {\n      return _this2.getDocumentBranch(data, id).map(function (id) {\n        return page.shapes[id];\n      });\n    }).filter(function (shape) {\n      return !shape.isLocked;\n    }).map(core.Utils.deepClone);\n\n    if (fn !== undefined) {\n      return copies.map(function (shape) {\n        return _extends({\n          id: shape.id\n        }, fn(shape));\n      });\n    }\n\n    return copies;\n  };\n\n  TLDR.getSelectedShapeSnapshot = function getSelectedShapeSnapshot(data, fn) {\n    var copies = this.getSelectedShapes(data).filter(function (shape) {\n      return !shape.isLocked;\n    }).map(core.Utils.deepClone);\n\n    if (fn !== undefined) {\n      return copies.map(function (shape) {\n        return _extends({\n          id: shape.id\n        }, fn(shape));\n      });\n    }\n\n    return copies;\n  } // For a given array of shape ids, an array of all other shapes that may be affected by a mutation to it.\n  // Use this to decide which shapes to clone as before / after for a command.\n  ;\n\n  TLDR.getAllEffectedShapeIds = function getAllEffectedShapeIds(data, ids) {\n    var visited = new Set(ids);\n    ids.forEach(function (id) {\n      var shape = data.page.shapes[id]; // Add descendant shapes\n\n      function collectDescendants(shape) {\n        if (shape.children === undefined) return;\n        shape.children.filter(function (childId) {\n          return !visited.has(childId);\n        }).forEach(function (childId) {\n          visited.add(childId);\n          collectDescendants(data.page.shapes[childId]);\n        });\n      }\n\n      collectDescendants(shape); // Add asecendant shapes\n\n      function collectAscendants(shape) {\n        var parentId = shape.parentId;\n        if (parentId === data.page.id) return;\n        if (visited.has(parentId)) return;\n        visited.add(parentId);\n        collectAscendants(data.page.shapes[parentId]);\n      }\n\n      collectAscendants(shape); // Add bindings that are to or from any of the visited shapes (this does not have to be recursive)\n\n      visited.forEach(function (id) {\n        Object.values(data.page.bindings).filter(function (binding) {\n          return binding.fromId === id || binding.toId === id;\n        }).forEach(function (binding) {\n          return visited.add(binding.fromId === id ? binding.toId : binding.fromId);\n        });\n      });\n    }); // Return the unique array of visited shapes\n\n    return Array.from(visited.values());\n  };\n\n  TLDR.recursivelyUpdateChildren = function recursivelyUpdateChildren(data, id, beforeShapes, afterShapes) {\n    var _this3 = this;\n\n    if (beforeShapes === void 0) {\n      beforeShapes = {};\n    }\n\n    if (afterShapes === void 0) {\n      afterShapes = {};\n    }\n\n    var shape = data.page.shapes[id];\n\n    if (shape.children !== undefined) {\n      var deltas = this.getShapeUtils(shape).updateChildren(shape, shape.children.map(function (childId) {\n        return data.page.shapes[childId];\n      }));\n\n      if (deltas) {\n        return deltas.reduce(function (cData, delta) {\n          var deltaShape = cData.page.shapes[delta.id];\n\n          if (!beforeShapes[deltaShape.id]) {\n            beforeShapes[deltaShape.id] = deltaShape;\n          }\n\n          cData.page.shapes[deltaShape.id] = _this3.getShapeUtils(deltaShape).mutate(deltaShape, delta);\n          afterShapes[deltaShape.id] = cData.page.shapes[deltaShape.id];\n\n          if (deltaShape.children !== undefined) {\n            _this3.recursivelyUpdateChildren(cData, deltaShape.id, beforeShapes, afterShapes);\n          }\n\n          return cData;\n        }, data);\n      }\n    }\n\n    return data;\n  };\n\n  TLDR.recursivelyUpdateParents = function recursivelyUpdateParents(data, id, beforeShapes, afterShapes) {\n    if (beforeShapes === void 0) {\n      beforeShapes = {};\n    }\n\n    if (afterShapes === void 0) {\n      afterShapes = {};\n    }\n\n    var shape = data.page.shapes[id];\n\n    if (shape.parentId !== data.page.id) {\n      var parent = data.page.shapes[shape.parentId];\n      var delta = this.getShapeUtils(shape).onChildrenChange(parent, parent.children.map(function (childId) {\n        return data.page.shapes[childId];\n      }));\n\n      if (delta) {\n        if (!beforeShapes[parent.id]) {\n          beforeShapes[parent.id] = parent;\n        }\n\n        data.page.shapes[parent.id] = this.getShapeUtils(parent).mutate(parent, delta);\n        afterShapes[parent.id] = data.page.shapes[parent.id];\n      }\n\n      if (parent.parentId !== data.page.id) {\n        return this.recursivelyUpdateParents(data, parent.parentId, beforeShapes, afterShapes);\n      }\n    }\n\n    return data;\n  };\n\n  TLDR.updateBindings = function updateBindings(data, id, beforeShapes, afterShapes) {\n    var _this4 = this;\n\n    if (beforeShapes === void 0) {\n      beforeShapes = {};\n    }\n\n    if (afterShapes === void 0) {\n      afterShapes = {};\n    }\n\n    return Object.values(data.page.bindings).filter(function (binding) {\n      return binding.fromId === id || binding.toId === id;\n    }).reduce(function (cData, binding) {\n      if (!beforeShapes[binding.id]) {\n        beforeShapes[binding.fromId] = core.Utils.deepClone(cData.page.shapes[binding.fromId]);\n      }\n\n      if (!beforeShapes[binding.toId]) {\n        beforeShapes[binding.toId] = core.Utils.deepClone(cData.page.shapes[binding.toId]);\n      }\n\n      _this4.onBindingChange(cData, cData.page.shapes[binding.fromId], binding, cData.page.shapes[binding.toId]);\n\n      afterShapes[binding.fromId] = core.Utils.deepClone(cData.page.shapes[binding.fromId]);\n      afterShapes[binding.toId] = core.Utils.deepClone(cData.page.shapes[binding.toId]);\n      return cData;\n    }, data);\n  };\n\n  TLDR.getChildIndexAbove = function getChildIndexAbove(data, id) {\n    var page = this.getPage(data);\n    var shape = page.shapes[id];\n    var siblings = Object.values(page.shapes).filter(function (_ref) {\n      var parentId = _ref.parentId;\n      return parentId === shape.parentId;\n    }).sort(function (a, b) {\n      return a.childIndex - b.childIndex;\n    });\n    var index = siblings.indexOf(shape);\n    var nextSibling = siblings[index + 1];\n    if (!nextSibling) return shape.childIndex + 1;\n    return (shape.childIndex + nextSibling.childIndex) / 2;\n  }\n  /* -------------------------------------------------- */\n\n  /*                      Mutations                     */\n\n  /* -------------------------------------------------- */\n  ;\n\n  TLDR.setSelectedIds = function setSelectedIds(data, ids) {\n    data.pageState.selectedIds = ids;\n  };\n\n  TLDR.deselectAll = function deselectAll(data) {\n    this.setSelectedIds(data, []);\n  };\n\n  TLDR.mutateShapes = function mutateShapes(data, ids, fn) {\n    var _this5 = this;\n\n    var beforeShapes = {};\n    var afterShapes = {};\n    ids.forEach(function (id, i) {\n      var shape = data.page.shapes[id];\n      var change = fn(shape, i);\n      beforeShapes[id] = Object.fromEntries(Object.keys(change).map(function (key) {\n        return [key, shape[key]];\n      }));\n      afterShapes[id] = change;\n      data.page.shapes[id] = _this5.getShapeUtils(shape).mutate(shape, change);\n    });\n    var dataWithChildrenChanges = ids.reduce(function (cData, id) {\n      return _this5.recursivelyUpdateChildren(cData, id, beforeShapes, afterShapes);\n    }, data);\n    var dataWithParentChanges = ids.reduce(function (cData, id) {\n      return _this5.recursivelyUpdateParents(cData, id, beforeShapes, afterShapes);\n    }, dataWithChildrenChanges);\n    var dataWithBindingChanges = ids.reduce(function (cData, id) {\n      return _this5.updateBindings(cData, id, beforeShapes, afterShapes);\n    }, dataWithParentChanges);\n    return {\n      before: beforeShapes,\n      after: afterShapes,\n      data: dataWithBindingChanges\n    };\n  };\n\n  TLDR.createShapes = function createShapes(data, shapes) {\n    var _this6 = this;\n\n    var page = this.getPage(data);\n    var shapeIds = shapes.map(function (shape) {\n      return shape.id;\n    }); // Update selected ids\n\n    this.setSelectedIds(data, shapeIds); // Restore deleted shapes\n\n    shapes.forEach(function (shape) {\n      var newShape = _extends({}, shape);\n\n      page.shapes[shape.id] = newShape;\n    }); // Update parents\n\n    shapes.forEach(function (shape) {\n      if (shape.parentId === data.page.id) return;\n      var parent = page.shapes[shape.parentId];\n\n      _this6.mutate(data, parent, {\n        children: parent.children.includes(shape.id) ? parent.children : [].concat(parent.children, [shape.id])\n      });\n    });\n  };\n\n  TLDR.onSessionComplete = function onSessionComplete(data, shape) {\n    var delta = getShapeUtils(shape).onSessionComplete(shape);\n\n    if (!delta) return shape;\n    return this.mutate(data, shape, delta);\n  };\n\n  TLDR.onChildrenChange = function onChildrenChange(data, shape) {\n    var delta = getShapeUtils(shape).onChildrenChange(shape, shape.children.map(function (id) {\n      return data.page.shapes[id];\n    }));\n\n    if (!delta) return shape;\n    return this.mutate(data, shape, delta);\n  };\n\n  TLDR.onBindingChange = function onBindingChange(data, shape, binding, otherShape) {\n    var delta = getShapeUtils(shape).onBindingChange(shape, binding, otherShape, getShapeUtils(otherShape).getBounds(otherShape));\n\n    if (!delta) return shape;\n    return this.mutate(data, shape, delta);\n  };\n\n  TLDR.transform = function transform(data, shape, bounds, info) {\n    return this.mutate(data, shape, getShapeUtils(shape).transform(shape, bounds, info));\n  };\n\n  TLDR.transformSingle = function transformSingle(data, shape, bounds, info) {\n    return this.mutate(data, shape, getShapeUtils(shape).transformSingle(shape, bounds, info));\n  };\n\n  TLDR.mutate = function mutate(data, shape, props) {\n    var next = getShapeUtils(shape).mutate(shape, props);\n\n    if ('children' in props) {\n      next = this.onChildrenChange(data, next);\n    }\n\n    data.page.shapes[next.id] = next;\n    return next;\n  }\n  /* -------------------------------------------------- */\n\n  /*                       Parents                      */\n\n  /* -------------------------------------------------- */\n  ;\n\n  TLDR.updateParents = function updateParents(data, changedShapeIds) {\n    if (changedShapeIds.length === 0) return;\n\n    var _this$getPage = this.getPage(data),\n        shapes = _this$getPage.shapes;\n\n    var parentToUpdateIds = Array.from(new Set(changedShapeIds.map(function (id) {\n      return shapes[id].parentId;\n    }).values())).filter(function (id) {\n      return id !== data.page.id;\n    });\n\n    for (var _iterator = _createForOfIteratorHelperLoose(parentToUpdateIds), _step; !(_step = _iterator()).done;) {\n      var parentId = _step.value;\n      var parent = shapes[parentId];\n\n      if (!parent.children) {\n        throw Error('A shape is parented to a shape without a children array.');\n      }\n\n      this.onChildrenChange(data, parent);\n    }\n\n    this.updateParents(data, parentToUpdateIds);\n  };\n\n  TLDR.getSelectedStyle = function getSelectedStyle(data) {\n    var page = data.page,\n        pageState = data.pageState,\n        currentStyle = data.appState.currentStyle;\n\n    if (pageState.selectedIds.length === 0) {\n      return currentStyle;\n    }\n\n    var shapeStyles = data.pageState.selectedIds.map(function (id) {\n      return page.shapes[id].style;\n    });\n    var commonStyle = {};\n    var overrides = new Set([]);\n\n    var _loop = function _loop() {\n      var shapeStyle = _step2.value;\n      Object.keys(currentStyle).forEach(function (key) {\n        if (overrides.has(key)) return;\n\n        if (commonStyle[key] === undefined) {\n          // @ts-ignore\n          commonStyle[key] = shapeStyle[key];\n        } else {\n          if (commonStyle[key] === shapeStyle[key]) return; // @ts-ignore\n\n          commonStyle[key] = currentStyle[key];\n          overrides.add(key);\n        }\n      });\n    };\n\n    for (var _iterator2 = _createForOfIteratorHelperLoose(shapeStyles), _step2; !(_step2 = _iterator2()).done;) {\n      _loop();\n    }\n\n    return commonStyle;\n  }\n  /* -------------------------------------------------- */\n\n  /*                      Bindings                      */\n\n  /* -------------------------------------------------- */\n  ;\n\n  TLDR.getBinding = function getBinding(data, id) {\n    return this.getPage(data).bindings[id];\n  };\n\n  TLDR.getBindings = function getBindings(data) {\n    var page = this.getPage(data);\n    return Object.values(page.bindings);\n  };\n\n  TLDR.getBindingsWithShapeIds = function getBindingsWithShapeIds(data, ids) {\n    return Array.from(new Set(this.getBindings(data).filter(function (binding) {\n      return ids.includes(binding.toId) || ids.includes(binding.fromId);\n    })).values());\n  };\n\n  TLDR.createBindings = function createBindings(data, bindings) {\n    var page = this.getPage(data);\n    bindings.forEach(function (binding) {\n      return page.bindings[binding.id] = binding;\n    });\n  };\n\n  TLDR.deleteBindings = function deleteBindings(data, ids) {\n    if (ids.length === 0) return;\n    var page = this.getPage(data);\n    ids.forEach(function (id) {\n      return delete page.bindings[id];\n    });\n  };\n\n  return TLDR;\n}();\n\nfunction align(data, ids, type) {\n  var initialShapes = ids.map(function (id) {\n    return TLDR.getShape(data, id);\n  });\n  var boundsForShapes = initialShapes.map(function (shape) {\n    return {\n      id: shape.id,\n      point: [].concat(shape.point),\n      bounds: TLDR.getShapeUtils(shape).getBounds(shape)\n    };\n  });\n  var commonBounds = core.Utils.getCommonBounds(boundsForShapes.map(function (_ref) {\n    var bounds = _ref.bounds;\n    return bounds;\n  }));\n  var midX = commonBounds.minX + commonBounds.width / 2;\n  var midY = commonBounds.minY + commonBounds.height / 2;\n  var deltaMap = Object.fromEntries(boundsForShapes.map(function (_ref2) {\n    var _AlignType$CenterVert;\n\n    var id = _ref2.id,\n        point = _ref2.point,\n        bounds = _ref2.bounds;\n    return [id, {\n      prev: point,\n      next: (_AlignType$CenterVert = {}, _AlignType$CenterVert[exports.AlignType.CenterVertical] = [point[0], midY - bounds.height / 2], _AlignType$CenterVert[exports.AlignType.CenterHorizontal] = [midX - bounds.width / 2, point[1]], _AlignType$CenterVert[exports.AlignType.Top] = [point[0], commonBounds.minY], _AlignType$CenterVert[exports.AlignType.Bottom] = [point[0], commonBounds.maxY - bounds.height], _AlignType$CenterVert[exports.AlignType.Left] = [commonBounds.minX, point[1]], _AlignType$CenterVert[exports.AlignType.Right] = [commonBounds.maxX - bounds.width, point[1]], _AlignType$CenterVert)[type]\n    }];\n  }));\n\n  var _TLDR$mutateShapes = TLDR.mutateShapes(data, ids, function (shape) {\n    if (!deltaMap[shape.id]) return shape;\n    return {\n      point: deltaMap[shape.id].next\n    };\n  }),\n      before = _TLDR$mutateShapes.before,\n      after = _TLDR$mutateShapes.after;\n\n  return {\n    id: 'align_shapes',\n    before: {\n      page: {\n        shapes: _extends({}, before)\n      }\n    },\n    after: {\n      page: {\n        shapes: _extends({}, after)\n      }\n    }\n  };\n}\n\nfunction distribute(data, ids, type) {\n  var initialShapes = ids.map(function (id) {\n    return data.page.shapes[id];\n  });\n  var deltaMap = Object.fromEntries(getDistributions(initialShapes, type).map(function (d) {\n    return [d.id, d];\n  }));\n\n  var _TLDR$mutateShapes = TLDR.mutateShapes(data, ids, function (shape) {\n    if (!deltaMap[shape.id]) return shape;\n    return {\n      point: deltaMap[shape.id].next\n    };\n  }),\n      before = _TLDR$mutateShapes.before,\n      after = _TLDR$mutateShapes.after;\n\n  return {\n    id: 'distribute_shapes',\n    before: {\n      page: {\n        shapes: _extends({}, before)\n      }\n    },\n    after: {\n      page: {\n        shapes: _extends({}, after)\n      }\n    }\n  };\n}\n\nfunction getDistributions(initialShapes, type) {\n  var entries = initialShapes.map(function (shape) {\n    var utils = TLDR.getShapeUtils(shape);\n    return {\n      id: shape.id,\n      point: [].concat(shape.point),\n      bounds: utils.getBounds(shape),\n      center: utils.getCenter(shape)\n    };\n  });\n  var len = entries.length;\n  var commonBounds = core.Utils.getCommonBounds(entries.map(function (_ref) {\n    var bounds = _ref.bounds;\n    return bounds;\n  }));\n  var results = [];\n\n  switch (type) {\n    case exports.DistributeType.Horizontal:\n      {\n        var span = entries.reduce(function (a, c) {\n          return a + c.bounds.width;\n        }, 0);\n\n        if (span > commonBounds.width) {\n          var left = entries.sort(function (a, b) {\n            return a.bounds.minX - b.bounds.minX;\n          })[0];\n          var right = entries.sort(function (a, b) {\n            return b.bounds.maxX - a.bounds.maxX;\n          })[0];\n          var entriesToMove = entries.filter(function (a) {\n            return a !== left && a !== right;\n          }).sort(function (a, b) {\n            return a.center[0] - b.center[0];\n          });\n          var step = (right.center[0] - left.center[0]) / (len - 1);\n          var x = left.center[0] + step;\n          entriesToMove.forEach(function (_ref2, i) {\n            var id = _ref2.id,\n                point = _ref2.point,\n                bounds = _ref2.bounds;\n            results.push({\n              id: id,\n              prev: point,\n              next: [x + step * i - bounds.width / 2, bounds.minY]\n            });\n          });\n        } else {\n          var _entriesToMove = entries.sort(function (a, b) {\n            return a.center[0] - b.center[0];\n          });\n\n          var _x = commonBounds.minX;\n\n          var _step = (commonBounds.width - span) / (len - 1);\n\n          _entriesToMove.forEach(function (_ref3, i) {\n            var id = _ref3.id,\n                point = _ref3.point,\n                bounds = _ref3.bounds;\n            results.push({\n              id: id,\n              prev: point,\n              next: [_x, bounds.minY]\n            });\n            _x += bounds.width + _step;\n          });\n        }\n\n        break;\n      }\n\n    case exports.DistributeType.Vertical:\n      {\n        var _span = entries.reduce(function (a, c) {\n          return a + c.bounds.height;\n        }, 0);\n\n        if (_span > commonBounds.height) {\n          var top = entries.sort(function (a, b) {\n            return a.bounds.minY - b.bounds.minY;\n          })[0];\n          var bottom = entries.sort(function (a, b) {\n            return b.bounds.maxY - a.bounds.maxY;\n          })[0];\n\n          var _entriesToMove2 = entries.filter(function (a) {\n            return a !== top && a !== bottom;\n          }).sort(function (a, b) {\n            return a.center[1] - b.center[1];\n          });\n\n          var _step2 = (bottom.center[1] - top.center[1]) / (len - 1);\n\n          var y = top.center[1] + _step2;\n\n          _entriesToMove2.forEach(function (_ref4, i) {\n            var id = _ref4.id,\n                point = _ref4.point,\n                bounds = _ref4.bounds;\n            results.push({\n              id: id,\n              prev: point,\n              next: [bounds.minX, y + _step2 * i - bounds.height / 2]\n            });\n          });\n        } else {\n          var _entriesToMove3 = entries.sort(function (a, b) {\n            return a.center[1] - b.center[1];\n          });\n\n          var _y = commonBounds.minY;\n\n          var _step3 = (commonBounds.height - _span) / (len - 1);\n\n          _entriesToMove3.forEach(function (_ref5, i) {\n            var id = _ref5.id,\n                point = _ref5.point,\n                bounds = _ref5.bounds;\n            results.push({\n              id: id,\n              prev: point,\n              next: [bounds.minX, _y]\n            });\n            _y += bounds.height + _step3;\n          });\n        }\n\n        break;\n      }\n  }\n\n  return results;\n}\n\nfunction style(data, ids, changes) {\n  var _TLDR$mutateShapes = TLDR.mutateShapes(data, ids, function (shape) {\n    return {\n      style: _extends({}, shape.style, changes)\n    };\n  }),\n      before = _TLDR$mutateShapes.before,\n      after = _TLDR$mutateShapes.after;\n\n  return {\n    id: 'style_shapes',\n    before: {\n      page: {\n        shapes: _extends({}, before)\n      },\n      appState: {\n        currentStyle: _extends({}, data.appState.currentStyle)\n      }\n    },\n    after: {\n      page: {\n        shapes: _extends({}, after)\n      },\n      appState: {\n        currentStyle: _extends({}, data.appState.currentStyle, changes)\n      }\n    }\n  };\n}\n\nfunction duplicate(data, ids) {\n  var delta = core.Vec.div([16, 16], data.pageState.camera.zoom);\n  var after = Object.fromEntries(TLDR.getSelectedIds(data).map(function (id) {\n    return data.page.shapes[id];\n  }).map(function (shape) {\n    var id = core.Utils.uniqueId();\n    return [id, _extends({}, core.Utils.deepClone(shape), {\n      id: id,\n      point: core.Vec.add(shape.point, delta)\n    })];\n  }));\n  var before = Object.fromEntries(Object.keys(after).map(function (id) {\n    return [id, undefined];\n  }));\n  return {\n    id: 'duplicate',\n    before: {\n      page: {\n        shapes: _extends({}, before)\n      },\n      pageState: _extends({}, data.pageState, {\n        selectedIds: ids\n      })\n    },\n    after: {\n      page: {\n        shapes: _extends({}, after)\n      },\n      pageState: _extends({}, data.pageState, {\n        selectedIds: Object.keys(after)\n      })\n    }\n  };\n}\n\nfunction move(data, ids, type) {\n  var _result, _result2;\n\n  // Get the unique parent ids for the selected elements\n  var parentIds = new Set(ids.map(function (id) {\n    return data.page.shapes[id].parentId;\n  }));\n  var result = {\n    before: {},\n    after: {}\n  };\n  var startIndex;\n  var startChildIndex;\n  var step; // Collect shapes with common parents into a table under their parent id\n\n  Array.from(parentIds.values()).forEach(function (parentId) {\n    var sortedChildren = parentId === data.page.id ? Object.values(data.page.shapes).sort(function (a, b) {\n      return a.childIndex - b.childIndex;\n    }) : data.page.shapes[parentId].children.map(function (childId) {\n      return data.page.shapes[childId];\n    }).sort(function (a, b) {\n      return a.childIndex - b.childIndex;\n    });\n    var sortedChildIds = sortedChildren.map(function (shape) {\n      return shape.id;\n    });\n    var sortedIndicesToMove = ids.filter(function (id) {\n      return sortedChildIds.includes(id);\n    }).map(function (id) {\n      return sortedChildIds.indexOf(id);\n    }).sort(function (a, b) {\n      return a - b;\n    });\n    if (sortedIndicesToMove.length === sortedChildIds.length) return;\n\n    switch (type) {\n      case exports.MoveType.ToBack:\n        {\n          //               a       b  c\n          // Initial   1   2    3  4  5  6  7\n          // Final   .25  .5  .75  1  3  6  7\n          //           a   b    c\n          // Find the lowest \"open\" index\n          for (var i = 0; i < sortedChildIds.length; i++) {\n            if (sortedIndicesToMove.includes(i)) continue;\n            startIndex = i;\n            break;\n          } // Find the lowest child index that isn't in sortedIndicesToMove\n\n\n          startChildIndex = sortedChildren[startIndex].childIndex; // Find the step for each additional child\n\n          step = startChildIndex / (sortedIndicesToMove.length + 1); // Get the results of moving the selected shapes below the first open index's shape\n\n          result = TLDR.mutateShapes(data, sortedIndicesToMove.map(function (i) {\n            return sortedChildren[i].id;\n          }).reverse(), function (_shape, i) {\n            return {\n              childIndex: startChildIndex - (i + 1) * step\n            };\n          });\n          break;\n        }\n\n      case exports.MoveType.ToFront:\n        {\n          //              a     b  c\n          // Initial   1  2  3  4  5  6   7\n          // Final     1  3  6  7  8  9  10\n          //                       a  b   c\n          // Find the highest \"open\" index\n          for (var _i = sortedChildIds.length - 1; _i >= 0; _i--) {\n            if (sortedIndicesToMove.includes(_i)) continue;\n            startIndex = _i;\n            break;\n          } // Find the lowest child index that isn't in sortedIndicesToMove\n\n\n          startChildIndex = sortedChildren[startIndex].childIndex; // Find the step for each additional child\n\n          step = 1; // Get the results of moving the selected shapes below the first open index's shape\n\n          result = TLDR.mutateShapes(data, sortedIndicesToMove.map(function (i) {\n            return sortedChildren[i].id;\n          }), function (_shape, i) {\n            return {\n              childIndex: startChildIndex + (i + 1)\n            };\n          });\n          break;\n        }\n\n      case exports.MoveType.Backward:\n        {\n          //               a           b  c\n          // Initial    1  2     3     4  5  6  7\n          // Final     .5  1  1.66  2.33  3  6  7\n          //           a         b     c\n          var indexMap = {}; // Starting from the top...\n\n          for (var _i2 = sortedChildIds.length - 1; _i2 >= 0; _i2--) {\n            // If we found a moving index...\n            if (sortedIndicesToMove.includes(_i2)) {\n              for (var j = _i2; j >= 0; j--) {\n                // iterate downward until we find an open spot\n                if (!sortedIndicesToMove.includes(j)) {\n                  // i = the index of the first closed spot\n                  // j = the index of the first open spot\n                  startChildIndex = j === 0 ? sortedChildren[j].childIndex / 2 : sortedChildren[j - 1].childIndex;\n\n                  var _step = (sortedChildren[j].childIndex - startChildIndex) / (_i2 - j + 1);\n\n                  for (var k = 0; k < _i2 - j; k++) {\n                    indexMap[sortedChildren[j + k + 1].id] = startChildIndex + _step * (k + 1);\n                  }\n\n                  break;\n                }\n              }\n            }\n          }\n\n          if (Object.values(indexMap).length > 0) {\n            // Get the results of moving the selected shapes below the first open index's shape\n            result = TLDR.mutateShapes(data, sortedIndicesToMove.map(function (i) {\n              return sortedChildren[i].id;\n            }), function (shape) {\n              return {\n                childIndex: indexMap[shape.id]\n              };\n            });\n          }\n\n          break;\n        }\n\n      case exports.MoveType.Forward:\n        {\n          //             a     b c\n          // Initial   1 2   3 4 5 6 7\n          // Final     1 3 3.5 6 7 8 9\n          //                 a     b c\n          var _indexMap = {}; // Starting from the top...\n\n          for (var _i3 = 0; _i3 < sortedChildIds.length; _i3++) {\n            // If we found a moving index...\n            if (sortedIndicesToMove.includes(_i3)) {\n              // Search for the first open spot above this one\n              for (var _j = _i3; _j < sortedChildIds.length; _j++) {\n                if (!sortedIndicesToMove.includes(_j)) {\n                  // i = the low index of the first closed spot\n                  // j = the high index of the first open spot\n                  startChildIndex = sortedChildren[_j].childIndex;\n\n                  var _step2 = _j === sortedChildIds.length - 1 ? 1 : (sortedChildren[_j + 1].childIndex - startChildIndex) / (_j - _i3 + 1);\n\n                  for (var _k = 0; _k < _j - _i3; _k++) {\n                    _indexMap[sortedChildren[_i3 + _k].id] = startChildIndex + _step2 * (_k + 1);\n                  }\n\n                  break;\n                }\n              }\n            }\n          }\n\n          if (Object.values(_indexMap).length > 0) {\n            // Get the results of moving the selected shapes below the first open index's shape\n            result = TLDR.mutateShapes(data, sortedIndicesToMove.map(function (i) {\n              return sortedChildren[i].id;\n            }), function (shape) {\n              return {\n                childIndex: _indexMap[shape.id]\n              };\n            });\n          }\n\n          break;\n        }\n    }\n  });\n  return {\n    id: 'move_shapes',\n    before: {\n      page: _extends({}, data.page, {\n        shapes: ((_result = result) == null ? void 0 : _result.before) || {}\n      })\n    },\n    after: {\n      page: _extends({}, data.page, {\n        shapes: ((_result2 = result) == null ? void 0 : _result2.after) || {}\n      })\n    }\n  };\n}\n\nfunction translate(data, ids, delta) {\n  var _TLDR$mutateShapes = TLDR.mutateShapes(data, ids, function (shape) {\n    return {\n      point: core.Vec.add(shape.point, delta)\n    };\n  }),\n      before = _TLDR$mutateShapes.before,\n      after = _TLDR$mutateShapes.after;\n\n  return {\n    id: 'translate_shapes',\n    before: {\n      page: _extends({}, data.page, {\n        shapes: _extends({}, before)\n      })\n    },\n    after: {\n      page: _extends({}, data.page, {\n        shapes: _extends({}, after)\n      })\n    }\n  };\n}\n\nfunction toggle(data, ids, prop) {\n  var initialShapes = ids.map(function (id) {\n    return data.page.shapes[id];\n  });\n  var isAllToggled = initialShapes.every(function (shape) {\n    return shape[prop];\n  });\n\n  var _TLDR$mutateShapes = TLDR.mutateShapes(data, TLDR.getSelectedIds(data), function () {\n    var _ref;\n\n    return _ref = {}, _ref[prop] = !isAllToggled, _ref;\n  }),\n      before = _TLDR$mutateShapes.before,\n      after = _TLDR$mutateShapes.after;\n\n  return {\n    id: 'toggle_shapes',\n    before: {\n      page: {\n        shapes: _extends({}, before)\n      }\n    },\n    after: {\n      page: {\n        shapes: _extends({}, after)\n      }\n    }\n  };\n}\n\nfunction deleteShapes(data, ids) {\n  return {\n    id: 'toggle_shapes',\n    before: {\n      page: {\n        shapes: Object.fromEntries(ids.map(function (id) {\n          return [id, data.page.shapes[id]];\n        }))\n      },\n      pageState: {\n        selectedIds: [].concat(data.pageState.selectedIds)\n      }\n    },\n    after: {\n      page: {\n        shapes: Object.fromEntries(ids.map(function (id) {\n          return [id, undefined];\n        }))\n      },\n      pageState: {\n        selectedIds: []\n      }\n    }\n  };\n}\n\nvar PI2 = Math.PI * 2;\nfunction rotate(data, ids, delta) {\n  if (delta === void 0) {\n    delta = -PI2 / 4;\n  }\n\n  var initialShapes = ids.map(function (id) {\n    return data.page.shapes[id];\n  });\n  var boundsForShapes = initialShapes.map(function (shape) {\n    var utils = TLDR.getShapeUtils(shape);\n    return {\n      id: shape.id,\n      point: [].concat(shape.point),\n      bounds: utils.getBounds(shape),\n      center: utils.getCenter(shape),\n      rotation: shape.rotation\n    };\n  });\n  var commonBounds = core.Utils.getCommonBounds(boundsForShapes.map(function (_ref) {\n    var bounds = _ref.bounds;\n    return bounds;\n  }));\n  var commonBoundsCenter = core.Utils.getBoundsCenter(commonBounds);\n  var rotations = Object.fromEntries(boundsForShapes.map(function (_ref2) {\n    var id = _ref2.id,\n        point = _ref2.point,\n        center = _ref2.center,\n        rotation = _ref2.rotation;\n    var offset = core.Vec.sub(center, point);\n    var nextPoint = core.Vec.sub(core.Vec.rotWith(center, commonBoundsCenter, -(PI2 / 4)), offset);\n    var nextRotation = (PI2 + ((rotation || 0) + delta)) % PI2;\n    return [id, {\n      point: nextPoint,\n      rotation: nextRotation\n    }];\n  }));\n  var prevBoundsRotation = data.pageState.boundsRotation;\n  var nextBoundsRotation = (PI2 + ((data.pageState.boundsRotation || 0) + delta)) % PI2;\n\n  var _TLDR$mutateShapes = TLDR.mutateShapes(data, ids, function (shape) {\n    return rotations[shape.id];\n  }),\n      before = _TLDR$mutateShapes.before,\n      after = _TLDR$mutateShapes.after;\n\n  return {\n    id: 'toggle_shapes',\n    before: {\n      page: {\n        shapes: _extends({}, before)\n      },\n      pageState: {\n        boundsRotation: prevBoundsRotation\n      }\n    },\n    after: {\n      page: {\n        shapes: _extends({}, after)\n      },\n      pageState: {\n        boundsRotation: nextBoundsRotation\n      }\n    }\n  };\n}\n\nfunction stretch(data, ids, type) {\n  var initialShapes = ids.map(function (id) {\n    return data.page.shapes[id];\n  });\n  var boundsForShapes = initialShapes.map(function (shape) {\n    return TLDR.getBounds(shape);\n  });\n  var commonBounds = core.Utils.getCommonBounds(boundsForShapes);\n\n  var _TLDR$mutateShapes = TLDR.mutateShapes(data, ids, function (shape) {\n    var bounds = TLDR.getBounds(shape);\n\n    switch (type) {\n      case exports.StretchType.Horizontal:\n        {\n          var newBounds = _extends({}, bounds, {\n            minX: commonBounds.minX,\n            maxX: commonBounds.maxX,\n            width: commonBounds.width\n          });\n\n          return TLDR.getShapeUtils(shape).transformSingle(shape, newBounds, {\n            type: core.TLBoundsCorner.TopLeft,\n            scaleX: newBounds.width / bounds.width,\n            scaleY: 1,\n            initialShape: shape,\n            transformOrigin: [0.5, 0.5]\n          });\n        }\n\n      case exports.StretchType.Vertical:\n        {\n          var _newBounds = _extends({}, bounds, {\n            minY: commonBounds.minY,\n            maxY: commonBounds.maxY,\n            height: commonBounds.height\n          });\n\n          return TLDR.getShapeUtils(shape).transformSingle(shape, _newBounds, {\n            type: core.TLBoundsCorner.TopLeft,\n            scaleX: 1,\n            scaleY: _newBounds.height / bounds.height,\n            initialShape: shape,\n            transformOrigin: [0.5, 0.5]\n          });\n        }\n    }\n  }),\n      before = _TLDR$mutateShapes.before,\n      after = _TLDR$mutateShapes.after;\n\n  return {\n    id: 'stretch_shapes',\n    before: {\n      page: {\n        shapes: _extends({}, before)\n      }\n    },\n    after: {\n      page: {\n        shapes: _extends({}, after)\n      }\n    }\n  };\n}\n\nfunction create(data, shapes) {\n  return {\n    id: 'toggle_shapes',\n    before: {\n      page: {\n        shapes: Object.fromEntries(shapes.map(function (shape) {\n          return [shape.id, undefined];\n        }))\n      }\n    },\n    after: {\n      page: {\n        shapes: Object.fromEntries(shapes.map(function (shape) {\n          return [shape.id, shape];\n        }))\n      }\n    }\n  };\n}\n\nvar BrushSession = /*#__PURE__*/function () {\n  function BrushSession(_data, _point) {\n    var _this = this;\n\n    this.id = 'brush';\n    this.origin = void 0;\n    this.snapshot = void 0;\n\n    this.start = function (data) {\n      return data;\n    };\n\n    this.update = function (data, point, containMode) {\n      if (containMode === void 0) {\n        containMode = false;\n      }\n\n      var snapshot = _this.snapshot,\n          origin = _this.origin; // Create a bounding box between the origin and the new point\n\n      var brush = core.Utils.getBoundsFromPoints([origin, point]);\n      core.brushUpdater.set(brush); // Find ids of brushed shapes\n\n      var hits = new Set();\n      var selectedIds = new Set(snapshot.selectedIds);\n      snapshot.shapesToTest.forEach(function (_ref) {\n        var id = _ref.id,\n            util = _ref.util,\n            selectId = _ref.selectId;\n        if (selectedIds.has(id)) return;\n        var shape = data.page.shapes[id];\n\n        if (!hits.has(selectId)) {\n          if (containMode ? core.Utils.boundsContain(brush, util.getBounds(shape)) : util.hitTestBounds(shape, brush)) {\n            hits.add(selectId); // When brushing a shape, select its top group parent.\n\n            if (!selectedIds.has(selectId)) {\n              selectedIds.add(selectId);\n            }\n          } else if (selectedIds.has(selectId)) {\n            selectedIds[\"delete\"](selectId);\n          }\n        }\n      });\n\n      if (selectedIds.size === data.pageState.selectedIds.length && data.pageState.selectedIds.every(function (id) {\n        return selectedIds.has(id);\n      })) {\n        return data;\n      }\n\n      return _extends({}, data, {\n        pageState: _extends({}, data.pageState, {\n          selectedIds: Array.from(selectedIds.values())\n        })\n      });\n    };\n\n    this.origin = core.Vec.round(_point);\n    this.snapshot = getBrushSnapshot(_data);\n  }\n\n  var _proto = BrushSession.prototype;\n\n  _proto.cancel = function cancel(data) {\n    return _extends({}, data, {\n      pageState: _extends({}, data.pageState, {\n        selectedIds: this.snapshot.selectedIds\n      })\n    });\n  };\n\n  _proto.complete = function complete(data) {\n    return _extends({}, data, {\n      pageState: _extends({}, data.pageState, {\n        selectedIds: [].concat(data.pageState.selectedIds)\n      })\n    });\n  };\n\n  return BrushSession;\n}();\n/**\r\n * Get a snapshot of the current selected ids, for each shape that is\r\n * not already selected, the shape's id and a test to see whether the\r\n * brush will intersect that shape. For tests, start broad -> fine.\r\n */\n\nfunction getBrushSnapshot(data) {\n  var selectedIds = [].concat(data.pageState.selectedIds);\n  var shapesToTest = TLDR.getShapes(data).filter(function (shape) {\n    return !(shape.isHidden || shape.children !== undefined || selectedIds.includes(shape.id) || selectedIds.includes(shape.parentId));\n  }).map(function (shape) {\n    return {\n      id: shape.id,\n      util: getShapeUtils(shape),\n      bounds: getShapeUtils(shape).getBounds(shape),\n      selectId: TLDR.getTopParentId(data, shape.id)\n    };\n  });\n  return {\n    selectedIds: selectedIds,\n    shapesToTest: shapesToTest\n  };\n}\n\nvar TranslateSession = /*#__PURE__*/function () {\n  function TranslateSession(_data, _point) {\n    var _this = this;\n\n    this.id = 'translate';\n    this.delta = [0, 0];\n    this.prev = [0, 0];\n    this.origin = void 0;\n    this.snapshot = void 0;\n    this.isCloning = false;\n\n    this.start = function (data) {\n      return data;\n    };\n\n    this.update = function (data, point, isAligned, isCloning) {\n      if (isAligned === void 0) {\n        isAligned = false;\n      }\n\n      if (isCloning === void 0) {\n        isCloning = false;\n      }\n\n      var _this$snapshot = _this.snapshot,\n          clones = _this$snapshot.clones,\n          initialShapes = _this$snapshot.initialShapes;\n\n      var next = _extends({}, data, {\n        page: _extends({}, data.page),\n        shapes: _extends({}, data.page.shapes),\n        pageState: _extends({}, data.pageState)\n      });\n\n      var delta = core.Vec.sub(point, _this.origin);\n\n      if (isAligned) {\n        if (Math.abs(delta[0]) < Math.abs(delta[1])) {\n          delta[0] = 0;\n        } else {\n          delta[1] = 0;\n        }\n      }\n\n      var trueDelta = core.Vec.sub(delta, _this.prev);\n      _this.delta = delta;\n      _this.prev = delta; // If cloning...\n\n      if (isCloning) {\n        // Not Cloning -> Cloning\n        if (!_this.isCloning) {\n          _this.isCloning = true; // Move original shapes back to start\n\n          next.page.shapes = _extends({}, next.page.shapes, Object.fromEntries(initialShapes.map(function (shape) {\n            return [shape.id, _extends({}, next.page.shapes[shape.id], {\n              point: shape.point\n            })];\n          })));\n          next.page.shapes = _extends({}, next.page.shapes, Object.fromEntries(clones.map(function (clone) {\n            return [clone.id, _extends({}, clone, {\n              point: core.Vec.add(clone.point, delta)\n            })];\n          })));\n          next.pageState.selectedIds = clones.map(function (c) {\n            return c.id;\n          });\n        } // Either way, move the clones\n\n\n        next.page.shapes = _extends({}, next.page.shapes, Object.fromEntries(clones.map(function (clone) {\n          return [clone.id, _extends({}, clone, {\n            point: core.Vec.add(next.page.shapes[clone.id].point, trueDelta)\n          })];\n        })));\n        return next;\n      } // If not cloning...\n      // Cloning -> Not Cloning\n\n\n      if (_this.isCloning) {\n        _this.isCloning = false; // Delete the clones\n\n        clones.forEach(function (clone) {\n          return delete next.page.shapes[clone.id];\n        }); // Move the original shapes back to the cursor position\n\n        next.page.shapes = _extends({}, next.page.shapes, Object.fromEntries(initialShapes.map(function (shape) {\n          return [shape.id, _extends({}, next.page.shapes[shape.id], {\n            point: core.Vec.add(shape.point, delta)\n          })];\n        }))); // Set selected ids\n\n        next.pageState.selectedIds = initialShapes.map(function (c) {\n          return c.id;\n        });\n      } // Move the shapes by the delta\n\n\n      next.page.shapes = _extends({}, next.page.shapes, Object.fromEntries(initialShapes.map(function (shape) {\n        return [shape.id, _extends({}, next.page.shapes[shape.id], {\n          point: core.Vec.add(next.page.shapes[shape.id].point, trueDelta)\n        })];\n      })));\n      return next;\n    };\n\n    this.cancel = function (data) {\n      return _extends({}, data, {\n        page: _extends({}, data.page, {\n          // @ts-ignore - We need to set deleted shapes to undefined in order to correctly deep merge them away.\n          shapes: _extends({}, data.page.shapes, Object.fromEntries(_this.snapshot.clones.map(function (clone) {\n            return [clone.id, undefined];\n          })), Object.fromEntries(_this.snapshot.initialShapes.map(function (shape) {\n            return [shape.id, _extends({}, data.page.shapes[shape.id], {\n              point: shape.point\n            })];\n          })))\n        }),\n        pageState: _extends({}, data.pageState, {\n          selectedIds: _this.snapshot.selectedIds\n        })\n      });\n    };\n\n    this.origin = _point;\n    this.snapshot = getTranslateSnapshot(_data);\n  }\n\n  var _proto = TranslateSession.prototype;\n\n  _proto.complete = function complete(data) {\n    return {\n      id: 'translate',\n      before: _extends({}, data, {\n        page: _extends({}, data.page, {\n          shapes: _extends({}, data.page.shapes, Object.fromEntries(this.snapshot.clones.map(function (clone) {\n            return [clone.id, undefined];\n          })), Object.fromEntries(this.snapshot.initialShapes.map(function (shape) {\n            return [shape.id, {\n              point: shape.point\n            }];\n          })))\n        }),\n        pageState: _extends({}, data.pageState, {\n          selectedIds: this.snapshot.selectedIds\n        })\n      }),\n      after: _extends({}, data, {\n        page: _extends({}, data.page, {\n          shapes: _extends({}, data.page.shapes, Object.fromEntries(this.snapshot.clones.map(function (clone) {\n            return [clone.id, data.page.shapes[clone.id]];\n          })), Object.fromEntries(this.snapshot.initialShapes.map(function (shape) {\n            return [shape.id, {\n              point: data.page.shapes[shape.id].point\n            }];\n          })))\n        }),\n        pageState: _extends({}, data.pageState, {\n          selectedIds: [].concat(data.pageState.selectedIds)\n        })\n      })\n    };\n  };\n\n  return TranslateSession;\n}(); // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n\nfunction getTranslateSnapshot(data) {\n  var selectedShapes = TLDR.getSelectedShapeSnapshot(data);\n  var hasUnlockedShapes = selectedShapes.length > 0;\n  var initialParents = Array.from(new Set(selectedShapes.map(function (s) {\n    return s.parentId;\n  })).values()).filter(function (id) {\n    return id !== data.page.id;\n  }).map(function (id) {\n    var shape = TLDR.getShape(data, id);\n    return {\n      id: id,\n      children: shape.children\n    };\n  });\n  return {\n    selectedIds: TLDR.getSelectedIds(data),\n    hasUnlockedShapes: hasUnlockedShapes,\n    initialParents: initialParents,\n    initialShapes: selectedShapes.map(function (_ref) {\n      var id = _ref.id,\n          point = _ref.point,\n          parentId = _ref.parentId;\n      return {\n        id: id,\n        point: point,\n        parentId: parentId\n      };\n    }),\n    clones: selectedShapes.filter(function (shape) {\n      return shape.children === undefined;\n    }).flatMap(function (shape) {\n      var clone = _extends({}, shape, {\n        id: core.Utils.uniqueId(),\n        parentId: shape.parentId,\n        childIndex: TLDR.getChildIndexAbove(data, shape.id)\n      });\n\n      return clone;\n    })\n  };\n}\n\nvar TransformSingleSession = /*#__PURE__*/function () {\n  function TransformSingleSession(_data, _point, _transformType, commandId) {\n    var _this = this;\n\n    if (_transformType === void 0) {\n      _transformType = core.TLBoundsCorner.BottomRight;\n    }\n\n    if (commandId === void 0) {\n      commandId = 'transform_single';\n    }\n\n    this.id = 'transform_single';\n    this.commandId = void 0;\n    this.transformType = void 0;\n    this.origin = void 0;\n    this.scaleX = 1;\n    this.scaleY = 1;\n    this.snapshot = void 0;\n\n    this.start = function (data) {\n      return data;\n    };\n\n    this.update = function (data, point, isAspectRatioLocked) {\n      var _extends2;\n\n      if (isAspectRatioLocked === void 0) {\n        isAspectRatioLocked = false;\n      }\n\n      var transformType = _this.transformType;\n      var _this$snapshot = _this.snapshot,\n          initialShapeBounds = _this$snapshot.initialShapeBounds,\n          initialShape = _this$snapshot.initialShape,\n          id = _this$snapshot.id;\n      var shape = data.page.shapes[id];\n      var utils = TLDR.getShapeUtils(shape);\n      var newBounds = core.Utils.getTransformedBoundingBox(initialShapeBounds, transformType, core.Vec.sub(point, _this.origin), shape.rotation, isAspectRatioLocked || shape.isAspectRatioLocked || utils.isAspectRatioLocked);\n      return _extends({}, data, {\n        page: _extends({}, data.page, {\n          shapes: _extends({}, data.page.shapes, (_extends2 = {}, _extends2[shape.id] = _extends({}, initialShape, TLDR.getShapeUtils(shape).transformSingle(shape, newBounds, {\n            initialShape: initialShape,\n            type: _this.transformType,\n            scaleX: newBounds.scaleX,\n            scaleY: newBounds.scaleY,\n            transformOrigin: [0.5, 0.5]\n          })), _extends2))\n        })\n      });\n    };\n\n    this.cancel = function (data) {\n      var _extends3;\n\n      var _this$snapshot2 = _this.snapshot,\n          id = _this$snapshot2.id,\n          initialShape = _this$snapshot2.initialShape;\n      data.page.shapes[id] = initialShape;\n      return _extends({}, data, {\n        page: _extends({}, data.page, {\n          shapes: _extends({}, data.page.shapes, (_extends3 = {}, _extends3[id] = initialShape, _extends3))\n        })\n      });\n    };\n\n    this.origin = _point;\n    this.transformType = _transformType;\n    this.snapshot = getTransformSingleSnapshot(_data, _transformType);\n    this.commandId = commandId;\n  }\n\n  var _proto = TransformSingleSession.prototype;\n\n  _proto.complete = function complete(data) {\n    var _shapes, _shapes2;\n\n    if (!this.snapshot.hasUnlockedShape) return data;\n    return {\n      id: this.commandId,\n      before: {\n        page: {\n          shapes: (_shapes = {}, _shapes[this.snapshot.id] = this.snapshot.initialShape, _shapes)\n        }\n      },\n      after: {\n        page: {\n          shapes: (_shapes2 = {}, _shapes2[this.snapshot.id] = data.page.shapes[this.snapshot.id], _shapes2)\n        }\n      }\n    };\n  };\n\n  return TransformSingleSession;\n}();\nfunction getTransformSingleSnapshot(data, transformType) {\n  var shape = data.page.shapes[data.pageState.selectedIds[0]];\n\n  if (!shape) {\n    throw Error('You must have one shape selected.');\n  }\n\n  var bounds = TLDR.getBounds(shape);\n  return {\n    id: shape.id,\n    hasUnlockedShape: !shape.isLocked,\n    type: transformType,\n    initialShape: core.Utils.deepClone(shape),\n    initialShapeBounds: bounds\n  };\n}\n\nvar TransformSession = /*#__PURE__*/function () {\n  function TransformSession(_data, _point, _transformType) {\n    var _this = this;\n\n    if (_transformType === void 0) {\n      _transformType = core.TLBoundsCorner.BottomRight;\n    }\n\n    this.id = 'transform';\n    this.scaleX = 1;\n    this.scaleY = 1;\n    this.transformType = void 0;\n    this.origin = void 0;\n    this.snapshot = void 0;\n\n    this.start = function (data) {\n      return data;\n    };\n\n    this.update = function (data, point, isAspectRatioLocked, _altKey) {\n      if (isAspectRatioLocked === void 0) {\n        isAspectRatioLocked = false;\n      }\n\n      var transformType = _this.transformType,\n          _this$snapshot = _this.snapshot,\n          shapeBounds = _this$snapshot.shapeBounds,\n          initialBounds = _this$snapshot.initialBounds,\n          isAllAspectRatioLocked = _this$snapshot.isAllAspectRatioLocked;\n\n      var next = _extends({}, data, {\n        page: _extends({}, data.page)\n      });\n\n      var shapes = next.page.shapes;\n      var newBoundingBox = core.Utils.getTransformedBoundingBox(initialBounds, transformType, core.Vec.vec(_this.origin, point), data.pageState.boundsRotation, isAspectRatioLocked || isAllAspectRatioLocked); // Now work backward to calculate a new bounding box for each of the shapes.\n\n      _this.scaleX = newBoundingBox.scaleX;\n      _this.scaleY = newBoundingBox.scaleY;\n      next.page.shapes = _extends({}, next.page.shapes, Object.fromEntries(Object.entries(shapeBounds).map(function (_ref) {\n        var id = _ref[0],\n            _ref$ = _ref[1],\n            initialShape = _ref$.initialShape,\n            initialShapeBounds = _ref$.initialShapeBounds,\n            transformOrigin = _ref$.transformOrigin;\n        var newShapeBounds = core.Utils.getRelativeTransformedBoundingBox(newBoundingBox, initialBounds, initialShapeBounds, _this.scaleX < 0, _this.scaleY < 0);\n        var shape = shapes[id];\n        return [id, _extends({}, initialShape, TLDR.transform(next, shape, newShapeBounds, {\n          type: _this.transformType,\n          initialShape: initialShape,\n          scaleX: _this.scaleX,\n          scaleY: _this.scaleY,\n          transformOrigin: transformOrigin\n        }))];\n      })));\n      return next;\n    };\n\n    this.cancel = function (data) {\n      var shapeBounds = _this.snapshot.shapeBounds;\n      return _extends({}, data, {\n        page: _extends({}, data.page, {\n          shapes: _extends({}, data.page.shapes, Object.fromEntries(Object.entries(shapeBounds).map(function (_ref2) {\n            var id = _ref2[0],\n                initialShape = _ref2[1].initialShape;\n            return [id, initialShape];\n          })))\n        })\n      });\n    };\n\n    this.origin = _point;\n    this.transformType = _transformType;\n    this.snapshot = getTransformSnapshot(_data, _transformType);\n  }\n\n  var _proto = TransformSession.prototype;\n\n  _proto.complete = function complete(data) {\n    var _this$snapshot2 = this.snapshot,\n        hasUnlockedShapes = _this$snapshot2.hasUnlockedShapes,\n        shapeBounds = _this$snapshot2.shapeBounds;\n    if (!hasUnlockedShapes) return data;\n    return {\n      id: 'transform',\n      before: {\n        page: {\n          shapes: Object.fromEntries(Object.entries(shapeBounds).map(function (_ref3) {\n            var id = _ref3[0],\n                initialShape = _ref3[1].initialShape;\n            return [id, initialShape];\n          }))\n        }\n      },\n      after: {\n        page: {\n          shapes: Object.fromEntries(this.snapshot.initialShapes.map(function (shape) {\n            return [shape.id, data.page.shapes[shape.id]];\n          }))\n        }\n      }\n    };\n  };\n\n  return TransformSession;\n}();\nfunction getTransformSnapshot(data, transformType) {\n  var initialShapes = TLDR.getSelectedBranchSnapshot(data);\n  var hasUnlockedShapes = initialShapes.length > 0;\n  var isAllAspectRatioLocked = initialShapes.every(function (shape) {\n    return shape.isAspectRatioLocked || TLDR.getShapeUtils(shape).isAspectRatioLocked;\n  });\n  var shapesBounds = Object.fromEntries(initialShapes.map(function (shape) {\n    return [shape.id, TLDR.getBounds(shape)];\n  }));\n  var boundsArr = Object.values(shapesBounds);\n  var commonBounds = core.Utils.getCommonBounds(boundsArr);\n  var initialInnerBounds = core.Utils.getBoundsFromPoints(boundsArr.map(core.Utils.getBoundsCenter)); // Return a mapping of shapes to bounds together with the relative\n  // positions of the shape's bounds within the common bounds shape.\n\n  return {\n    type: transformType,\n    hasUnlockedShapes: hasUnlockedShapes,\n    isAllAspectRatioLocked: isAllAspectRatioLocked,\n    initialShapes: initialShapes,\n    initialBounds: commonBounds,\n    shapeBounds: Object.fromEntries(initialShapes.map(function (shape) {\n      var initialShapeBounds = shapesBounds[shape.id];\n      var ic = core.Utils.getBoundsCenter(initialShapeBounds);\n      var ix = (ic[0] - initialInnerBounds.minX) / initialInnerBounds.width;\n      var iy = (ic[1] - initialInnerBounds.minY) / initialInnerBounds.height;\n      return [shape.id, {\n        initialShape: shape,\n        initialShapeBounds: initialShapeBounds,\n        transformOrigin: [ix, iy]\n      }];\n    }))\n  };\n}\n\nvar DrawSession = function DrawSession(_data, id, _point) {\n  var _this = this;\n\n  this.id = 'draw';\n  this.origin = void 0;\n  this.previous = void 0;\n  this.last = void 0;\n  this.points = void 0;\n  this.snapshot = void 0;\n  this.isLocked = void 0;\n  this.lockedDirection = void 0;\n\n  this.start = function (data) {\n    return data;\n  };\n\n  this.update = function (data, point, pressure, isLocked) {\n    var _extends2;\n\n    if (isLocked === void 0) {\n      isLocked = false;\n    }\n\n    var snapshot = _this.snapshot; // Drawing while holding shift will \"lock\" the pen to either the\n    // x or y axis, depending on which direction has the greater\n    // delta. Pressing shift will also add more points to \"return\"\n    // the pen to the axis.\n\n    if (isLocked) {\n      if (!_this.isLocked && _this.points.length > 1) {\n        var bounds = core.Utils.getBoundsFromPoints(_this.points);\n\n        if (bounds.width > 8 || bounds.height > 8) {\n          _this.isLocked = true;\n          var returning = [].concat(_this.previous);\n          var isVertical = bounds.height > 8;\n\n          if (isVertical) {\n            _this.lockedDirection = 'vertical';\n            returning[0] = _this.origin[0];\n          } else {\n            _this.lockedDirection = 'horizontal';\n            returning[1] = _this.origin[1];\n          }\n\n          _this.previous = returning;\n\n          _this.points.push(core.Vec.sub(returning, _this.origin));\n        }\n      }\n    } else if (_this.isLocked) {\n      _this.isLocked = false;\n    }\n\n    if (_this.isLocked) {\n      if (_this.lockedDirection === 'vertical') {\n        point[0] = _this.origin[0];\n      } else {\n        point[1] = _this.origin[1];\n      }\n    } // Low pass the current input point against the previous one\n\n\n    var nextPrev = core.Vec.med(_this.previous, point);\n    _this.previous = nextPrev; // Don't add duplicate points. It's important to test against the\n    // adjusted (low-passed) point rather than the input point.\n\n    var newPoint = core.Vec.round([].concat(core.Vec.sub(_this.previous, _this.origin), [pressure]));\n    if (core.Vec.isEqual(_this.last, newPoint)) return data;\n    _this.last = newPoint;\n\n    _this.points.push(newPoint); // We draw a dot when the number of points is 1 or 2, so this guard\n    // prevents a \"flash\" of a dot when a user begins drawing a line.\n\n\n    if (_this.points.length <= 2) return data;\n    return _extends({}, data, {\n      page: _extends({}, data.page, {\n        shapes: _extends({}, data.page.shapes, (_extends2 = {}, _extends2[snapshot.id] = _extends({}, data.page.shapes[snapshot.id], {\n          points: [].concat(_this.points)\n        }), _extends2))\n      }),\n      pageState: _extends({}, data.pageState, {\n        selectedIds: [snapshot.id]\n      })\n    });\n  };\n\n  this.cancel = function (data) {\n    var _extends3;\n\n    var snapshot = _this.snapshot;\n    return _extends({}, data, {\n      page: _extends({}, data.page, {\n        // @ts-ignore\n        shapes: _extends({}, data.page.shapes, (_extends3 = {}, _extends3[snapshot.id] = undefined, _extends3))\n      }),\n      pageState: _extends({}, data.pageState, {\n        selectedIds: []\n      })\n    });\n  };\n\n  this.complete = function (data) {\n    var _shapes, _shapes2;\n\n    var snapshot = _this.snapshot;\n    return {\n      id: 'create_draw',\n      before: {\n        page: {\n          shapes: (_shapes = {}, _shapes[snapshot.id] = undefined, _shapes)\n        },\n        pageState: {\n          selectedIds: []\n        }\n      },\n      after: {\n        page: {\n          shapes: (_shapes2 = {}, _shapes2[snapshot.id] = data.page.shapes[snapshot.id], _shapes2)\n        },\n        pageState: {\n          selectedIds: []\n        }\n      }\n    };\n  };\n\n  this.origin = _point;\n  this.previous = _point;\n  this.last = _point;\n  this.snapshot = getDrawSnapshot(_data, id); // Add a first point but don't update the shape yet. We'll update\n  // when the draw session ends; if the user hasn't added additional\n  // points, this single point will be interpreted as a \"dot\" shape.\n\n  this.points = [[0, 0, 0.5]];\n}; // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n\nfunction getDrawSnapshot(data, shapeId) {\n  var page = data.page;\n\n  var _Utils$deepClone = core.Utils.deepClone(page.shapes[shapeId]),\n      points = _Utils$deepClone.points,\n      point = _Utils$deepClone.point;\n\n  return {\n    id: shapeId,\n    point: point,\n    points: points\n  };\n}\n\nvar PI2$1 = Math.PI * 2;\nvar RotateSession = /*#__PURE__*/function () {\n  function RotateSession(_data, _point) {\n    var _this = this;\n\n    this.id = 'rotate';\n    this.delta = [0, 0];\n    this.origin = void 0;\n    this.snapshot = void 0;\n    this.prev = 0;\n\n    this.start = function (data) {\n      return data;\n    };\n\n    this.update = function (data, point, isLocked) {\n      if (isLocked === void 0) {\n        isLocked = false;\n      }\n\n      var _this$snapshot = _this.snapshot,\n          commonBoundsCenter = _this$snapshot.commonBoundsCenter,\n          initialShapes = _this$snapshot.initialShapes;\n\n      var next = _extends({}, data, {\n        page: _extends({}, data.page),\n        pageState: _extends({}, data.pageState)\n      });\n\n      var page = next.page,\n          pageState = next.pageState;\n      var a1 = core.Vec.angle(commonBoundsCenter, _this.origin);\n      var a2 = core.Vec.angle(commonBoundsCenter, point);\n      var rot = a2 - a1;\n      _this.prev = rot;\n\n      if (isLocked) {\n        rot = core.Utils.clampToRotationToSegments(rot, 24);\n      }\n\n      pageState.boundsRotation = (PI2$1 + (_this.snapshot.boundsRotation + rot)) % PI2$1;\n      next.page.shapes = _extends({}, next.page.shapes, Object.fromEntries(initialShapes.map(function (_ref) {\n        var id = _ref.id,\n            center = _ref.center,\n            offset = _ref.offset,\n            _ref$shape$rotation = _ref.shape.rotation,\n            rotation = _ref$shape$rotation === void 0 ? 0 : _ref$shape$rotation;\n        var shape = page.shapes[id];\n        var nextRotation = isLocked ? core.Utils.clampToRotationToSegments(rotation + rot, 24) : rotation + rot;\n        var nextPoint = core.Vec.sub(core.Vec.rotWith(center, commonBoundsCenter, rot), offset);\n        return [id, _extends({}, next.page.shapes[id], TLDR.mutate(data, shape, {\n          point: nextPoint,\n          rotation: (PI2$1 + nextRotation) % PI2$1\n        }))];\n      })));\n      return next;\n    };\n\n    this.cancel = function (data) {\n      var initialShapes = _this.snapshot.initialShapes;\n\n      for (var _iterator = _createForOfIteratorHelperLoose(initialShapes), _step; !(_step = _iterator()).done;) {\n        var _step$value = _step.value,\n            id = _step$value.id,\n            shape = _step$value.shape;\n        data.page.shapes[id] = _extends({}, shape);\n      }\n\n      return _extends({}, data, {\n        page: _extends({}, data.page, {\n          shapes: _extends({}, data.page.shapes, Object.fromEntries(initialShapes.map(function (_ref2) {\n            var id = _ref2.id,\n                shape = _ref2.shape;\n            return [id, shape];\n          })))\n        })\n      });\n    };\n\n    this.origin = _point;\n    this.snapshot = getRotateSnapshot(_data);\n  }\n\n  var _proto = RotateSession.prototype;\n\n  _proto.complete = function complete(data) {\n    var _this$snapshot2 = this.snapshot,\n        hasUnlockedShapes = _this$snapshot2.hasUnlockedShapes,\n        initialShapes = _this$snapshot2.initialShapes;\n    if (!hasUnlockedShapes) return data;\n    return {\n      id: 'rotate',\n      before: {\n        page: {\n          shapes: Object.fromEntries(initialShapes.map(function (_ref3) {\n            var _ref3$shape = _ref3.shape,\n                id = _ref3$shape.id,\n                point = _ref3$shape.point,\n                _ref3$shape$rotation = _ref3$shape.rotation,\n                rotation = _ref3$shape$rotation === void 0 ? undefined : _ref3$shape$rotation;\n            return [id, {\n              point: point,\n              rotation: rotation\n            }];\n          }))\n        }\n      },\n      after: {\n        page: {\n          shapes: Object.fromEntries(this.snapshot.initialShapes.map(function (_ref4) {\n            var shape = _ref4.shape;\n            var _data$page$shapes$sha = data.page.shapes[shape.id],\n                point = _data$page$shapes$sha.point,\n                rotation = _data$page$shapes$sha.rotation;\n            return [shape.id, {\n              point: point,\n              rotation: rotation\n            }];\n          }))\n        }\n      }\n    };\n  };\n\n  return RotateSession;\n}(); // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n\nfunction getRotateSnapshot(data) {\n  var initialShapes = TLDR.getSelectedBranchSnapshot(data);\n\n  if (initialShapes.length === 0) {\n    throw Error('No selected shapes!');\n  }\n\n  var hasUnlockedShapes = initialShapes.length > 0;\n  var shapesBounds = Object.fromEntries(initialShapes.map(function (shape) {\n    return [shape.id, TLDR.getBounds(shape)];\n  }));\n  var rotatedBounds = Object.fromEntries(initialShapes.map(function (shape) {\n    return [shape.id, TLDR.getRotatedBounds(shape)];\n  }));\n  var bounds = core.Utils.getCommonBounds(Object.values(shapesBounds));\n  var commonBoundsCenter = core.Utils.getBoundsCenter(bounds);\n  return {\n    hasUnlockedShapes: hasUnlockedShapes,\n    boundsRotation: data.pageState.boundsRotation || 0,\n    commonBoundsCenter: commonBoundsCenter,\n    initialShapes: initialShapes.filter(function (shape) {\n      return shape.children === undefined;\n    }).map(function (shape) {\n      var bounds = TLDR.getBounds(shape);\n      var center = core.Utils.getBoundsCenter(bounds);\n      var offset = core.Vec.sub(center, shape.point);\n      var rotationOffset = core.Vec.sub(center, core.Utils.getBoundsCenter(rotatedBounds[shape.id]));\n      return {\n        id: shape.id,\n        shape: core.Utils.deepClone(shape),\n        offset: offset,\n        rotationOffset: rotationOffset,\n        center: center\n      };\n    })\n  };\n}\n\nvar initialData = {\n  settings: {\n    isPenMode: false,\n    isDarkMode: false,\n    isDebugMode: \"development\" === 'development',\n    isReadonlyMode: false,\n    nudgeDistanceLarge: 10,\n    nudgeDistanceSmall: 1\n  },\n  appState: {\n    activeToolType: undefined,\n    activeTool: 'select',\n    hoveredId: undefined,\n    currentPageId: 'page',\n    pages: [{\n      id: 'page'\n    }],\n    currentStyle: defaultStyle,\n    selectedStyle: defaultStyle,\n    isToolLocked: false,\n    isStyleOpen: false,\n    isEmptyCanvas: false\n  },\n  page: {\n    id: 'page',\n    childIndex: 1,\n    shapes: {// rect1: {\n      //   id: 'rect1',\n      //   parentId: 'page',\n      //   name: 'Rectangle',\n      //   childIndex: 1,\n      //   type: TLDrawShapeType.Rectangle,\n      //   point: [32, 32],\n      //   size: [100, 100],\n      //   style: defaultStyle,\n      // },\n    },\n    bindings: {// TODO\n    }\n  },\n  pageState: {\n    id: 'page',\n    selectedIds: [],\n    camera: {\n      point: [0, 0],\n      zoom: 1\n    }\n  }\n};\nvar TLDrawState = /*#__PURE__*/function () {\n  function TLDrawState() {\n    var _this = this;\n\n    this.store = createReact(function () {\n      return initialData;\n    });\n    this.history = {\n      stack: [],\n      pointer: -1\n    };\n    this.session = void 0;\n    this.status = {\n      current: 'idle',\n      previous: 'idle'\n    };\n    this.pointedId = void 0;\n    this.pointedHandle = void 0;\n    this.pointedBoundsHandle = void 0;\n    this.currentDocumentId = 'doc';\n    this.currentPageId = 'page';\n    this.pages = {\n      page: initialData.page\n    };\n    this.pageStates = {\n      page: initialData.pageState\n    };\n    this._onChange = void 0;\n    this.getState = this.store.getState;\n\n    this.setState = function (data) {\n      var current = _this.getState(); // Apply incoming change\n\n\n      var result = typeof data === 'function' ? data(current) : data;\n\n      var next = _extends({}, current, result);\n\n      if ('page' in result) {\n        next.page = _extends({}, next.page, {\n          shapes: Object.fromEntries(Object.entries(next.page.shapes).filter(function (_ref) {\n            var shape = _ref[1];\n            return shape && (shape.parentId === next.page.id || next.page.shapes[shape.parentId]);\n          }))\n        });\n      } // Apply selected style change, if any\n\n\n      var newSelectedStyle = TLDR.getSelectedStyle(next);\n\n      if (newSelectedStyle) {\n        next = _extends({}, next, {\n          appState: _extends({}, current.appState, next.appState, {\n            selectedStyle: newSelectedStyle\n          })\n        });\n      }\n\n      _this.store.setState(next);\n\n      _this.pages[next.page.id] = next.page;\n      _this.pageStates[next.page.id] = next.pageState;\n      return _this;\n    };\n\n    this.getShape = function (id) {\n      return _this.getState().page.shapes[id];\n    };\n\n    this.getPage = function (id) {\n      if (id === void 0) {\n        id = _this.currentPageId;\n      }\n\n      return _this.pages[id];\n    };\n\n    this.getPageState = function (id) {\n      if (id === void 0) {\n        id = _this.currentPageId;\n      }\n\n      return _this.pageStates[id];\n    };\n\n    this.getAppState = function (id) {\n\n      return _this.getState().appState;\n    };\n\n    this.getPagePoint = function (point) {\n      var _this$getPageState = _this.getPageState(),\n          camera = _this$getPageState.camera;\n\n      return core.Vec.sub(core.Vec.div(point, camera.zoom), camera.point);\n    };\n\n    this.toggleStylePanel = function () {\n      _this.setState(function (data) {\n        return {\n          appState: _extends({}, data.appState, {\n            isStyleOpen: !data.appState.isStyleOpen\n          })\n        };\n      });\n\n      return _this;\n    };\n\n    this.copy = function () {\n      // TODO\n      return _this;\n    };\n\n    this.paste = function () {\n      // TODO\n      return _this;\n    };\n\n    this.copyAsSvg = function () {\n      // TODO\n      return '<svg/>';\n    };\n\n    this.copyAsJson = function () {\n      // TODO\n      return {};\n    };\n\n    this.togglePenMode = function () {\n      _this.setState(function (data) {\n        return {\n          settings: _extends({}, data.settings, {\n            isPenMode: !data.settings.isPenMode\n          })\n        };\n      });\n\n      return _this;\n    };\n\n    this.toggleDarkMode = function () {\n      _this.setState(function (data) {\n        return {\n          settings: _extends({}, data.settings, {\n            isDarkMode: !data.settings.isDarkMode\n          })\n        };\n      });\n\n      return _this;\n    };\n\n    this.reset = function () {\n      _this.setState(function (data) {\n        return {\n          appState: _extends({}, data.appState, initialData.appState),\n          settings: _extends({}, data.appState, initialData.settings)\n        };\n      });\n\n      _this._onChange == null ? void 0 : _this._onChange(_this, \"reset\");\n      return _this;\n    };\n\n    this.selectTool = function (tool) {\n      _this.setState(function (data) {\n        return {\n          appState: _extends({}, data.appState, {\n            activeTool: tool,\n            activeToolType: tool === 'select' ? 'select' : TLDR.getShapeUtils({\n              type: tool\n            }).toolType\n          })\n        };\n      });\n\n      return _this;\n    };\n\n    this.toggleToolLock = function () {\n      _this.setState(function (data) {\n        return {\n          appState: _extends({}, data.appState, {\n            isToolLocked: true\n          })\n        };\n      });\n\n      return _this;\n    };\n\n    this.zoomIn = function () {\n      var i = Math.round(_this.store.getState().pageState.camera.zoom * 100 / 25);\n      var nextZoom = TLDR.getCameraZoom((i + 1) * 0.25);\n\n      _this.zoomTo(nextZoom);\n\n      return _this;\n    };\n\n    this.zoomOut = function () {\n      var i = Math.round(_this.store.getState().pageState.camera.zoom * 100 / 25);\n      var nextZoom = TLDR.getCameraZoom((i - 1) * 0.25);\n\n      _this.zoomTo(nextZoom);\n\n      return _this;\n    };\n\n    this.zoomToFit = function () {\n      _this.setState(function (data) {\n        var shapes = Object.values(data.page.shapes);\n        if (shapes.length === 0) return {\n          pageState: data.pageState\n        };\n        var bounds = core.Utils.getCommonBounds(Object.values(shapes).map(TLDR.getBounds));\n        var zoom = TLDR.getCameraZoom(bounds.width > bounds.height ? (window.innerWidth - 128) / bounds.width : (window.innerHeight - 128) / bounds.height);\n        var mx = (window.innerWidth - bounds.width * zoom) / 2 / zoom;\n        var my = (window.innerHeight - bounds.height * zoom) / 2 / zoom;\n        return {\n          pageState: _extends({}, data.pageState, {\n            camera: _extends({}, data.pageState.camera, {\n              point: core.Vec.add([-bounds.minX, -bounds.minY], [mx, my]),\n              zoom: zoom\n            })\n          })\n        };\n      });\n\n      return _this;\n    };\n\n    this.zoomToSelection = function () {\n      _this.setState(function (data) {\n        if (TLDR.getSelectedIds(data).length === 0) return {\n          pageState: data.pageState\n        };\n        var bounds = TLDR.getSelectedBounds(data);\n        var zoom = TLDR.getCameraZoom(bounds.width > bounds.height ? (window.innerWidth - 128) / bounds.width : (window.innerHeight - 128) / bounds.height);\n        var mx = (window.innerWidth - bounds.width * zoom) / 2 / zoom;\n        var my = (window.innerHeight - bounds.height * zoom) / 2 / zoom;\n        return {\n          pageState: _extends({}, data.pageState, {\n            camera: _extends({}, data.pageState.camera, {\n              point: core.Vec.add([-bounds.minX, -bounds.minY], [mx, my]),\n              zoom: zoom\n            })\n          })\n        };\n      });\n\n      return _this;\n    };\n\n    this.resetCamera = function () {\n      _this.setState(function (data) {\n        return {\n          pageState: _extends({}, data.pageState, {\n            camera: {\n              zoom: 1,\n              point: [window.innerWidth / 2, window.innerHeight / 2]\n            }\n          })\n        };\n      });\n\n      return _this;\n    };\n\n    this.zoomToContent = function () {\n      _this.setState(function (data) {\n        var shapes = Object.values(data.page.shapes);\n        if (shapes.length === 0) return {\n          pageState: data.pageState\n        };\n        var bounds = core.Utils.getCommonBounds(Object.values(shapes).map(TLDR.getBounds));\n        var zoom = data.pageState.camera.zoom;\n        var mx = (window.innerWidth - bounds.width * zoom) / 2 / zoom;\n        var my = (window.innerHeight - bounds.height * zoom) / 2 / zoom;\n        return {\n          pageState: _extends({}, data.pageState, {\n            camera: _extends({}, data.pageState.camera, {\n              point: core.Vec.add([-bounds.minX, -bounds.minY], [mx, my])\n            })\n          })\n        };\n      });\n\n      return _this;\n    };\n\n    this.zoomToActual = function () {\n      _this.zoomTo(1);\n\n      return _this;\n    };\n\n    this.loadDocument = function (document, onChange) {\n      _this._onChange = onChange;\n      _this.currentDocumentId = document.id;\n      _this.pages = core.Utils.deepClone(document.pages);\n      _this.pageStates = core.Utils.deepClone(document.pageStates);\n      _this.currentPageId = Object.values(_this.pages)[0].id;\n\n      _this.setState(function (data) {\n        return {\n          page: _this.pages[_this.currentPageId],\n          pageState: _this.pageStates[_this.currentPageId],\n          appState: _extends({}, data.appState, {\n            pageIds: Object.values(_this.pages).sort(function (a, b) {\n              return (a.childIndex || 0) - (b.childIndex || 0);\n            }).map(function (page) {\n              return page.id;\n            })\n          })\n        };\n      });\n\n      return _this;\n    };\n\n    this.undo = function () {\n      var history = _this.history;\n      if (history.pointer <= -1) return _this;\n      var command = history.stack[history.pointer];\n\n      _this.setState(function (data) {\n        return core.Utils.deepMerge(data, command.before);\n      });\n\n      history.pointer--;\n      _this._onChange == null ? void 0 : _this._onChange(_this, \"undo:\" + command.id);\n      return _this;\n    };\n\n    this.redo = function () {\n      var history = _this.history;\n      if (history.pointer >= history.stack.length - 1) return _this;\n      history.pointer++;\n      var command = history.stack[history.pointer];\n\n      _this.setState(function (data) {\n        return core.Utils.deepMerge(data, command.after);\n      });\n\n      _this._onChange == null ? void 0 : _this._onChange(_this, \"redo:\" + command.id);\n      return _this;\n    };\n\n    this.select = function () {\n      for (var _len = arguments.length, ids = new Array(_len), _key = 0; _key < _len; _key++) {\n        ids[_key] = arguments[_key];\n      }\n\n      _this.setSelectedIds(ids);\n\n      return _this;\n    };\n\n    this.selectAll = function () {\n      _this.setState(function (data) {\n        return {\n          appState: _extends({}, data.appState, {\n            activeTool: 'select',\n            activeToolType: 'select'\n          }),\n          pageState: _extends({}, data.pageState, {\n            selectedIds: Object.keys(data.page.shapes)\n          })\n        };\n      });\n\n      return _this;\n    };\n\n    this.deselectAll = function () {\n      _this.setSelectedIds([]);\n\n      return _this;\n    };\n\n    this.style = function (style$1, ids) {\n      var data = _this.store.getState();\n\n      var idsToMutate = ids ? ids : data.pageState.selectedIds;\n\n      _this[\"do\"](style(data, idsToMutate, style$1));\n\n      return _this;\n    };\n\n    this.align = function (type, ids) {\n      var data = _this.store.getState();\n\n      var idsToMutate = ids ? ids : data.pageState.selectedIds;\n\n      _this[\"do\"](align(data, idsToMutate, type));\n\n      return _this;\n    };\n\n    this.distribute = function (type, ids) {\n      var data = _this.store.getState();\n\n      var idsToMutate = ids ? ids : data.pageState.selectedIds;\n\n      _this[\"do\"](distribute(data, idsToMutate, type));\n\n      return _this;\n    };\n\n    this.stretch = function (type, ids) {\n      var data = _this.store.getState();\n\n      var idsToMutate = ids ? ids : data.pageState.selectedIds;\n\n      _this[\"do\"](stretch(data, idsToMutate, type));\n\n      return _this;\n    };\n\n    this.moveToBack = function (ids) {\n      var data = _this.store.getState();\n\n      var idsToMutate = ids ? ids : data.pageState.selectedIds;\n\n      _this[\"do\"](move(data, idsToMutate, exports.MoveType.ToBack));\n\n      return _this;\n    };\n\n    this.moveBackward = function (ids) {\n      var data = _this.store.getState();\n\n      var idsToMutate = ids ? ids : data.pageState.selectedIds;\n\n      _this[\"do\"](move(data, idsToMutate, exports.MoveType.Backward));\n\n      return _this;\n    };\n\n    this.moveForward = function (ids) {\n      var data = _this.store.getState();\n\n      var idsToMutate = ids ? ids : data.pageState.selectedIds;\n\n      _this[\"do\"](move(data, idsToMutate, exports.MoveType.Forward));\n\n      return _this;\n    };\n\n    this.moveToFront = function (ids) {\n      var data = _this.store.getState();\n\n      var idsToMutate = ids ? ids : data.pageState.selectedIds;\n\n      _this[\"do\"](move(data, idsToMutate, exports.MoveType.ToFront));\n\n      return _this;\n    };\n\n    this.nudge = function (delta, isMajor, ids) {\n      if (isMajor === void 0) {\n        isMajor = false;\n      }\n\n      var data = _this.store.getState();\n\n      var idsToMutate = ids ? ids : data.pageState.selectedIds;\n\n      _this[\"do\"](translate(data, idsToMutate, core.Vec.mul(delta, isMajor ? 10 : 1)));\n\n      return _this;\n    };\n\n    this.duplicate = function (ids) {\n      var data = _this.store.getState();\n\n      var idsToMutate = ids ? ids : data.pageState.selectedIds;\n\n      _this[\"do\"](duplicate(data, idsToMutate));\n\n      return _this;\n    };\n\n    this.toggleHidden = function (ids) {\n      var data = _this.store.getState();\n\n      var idsToMutate = ids ? ids : data.pageState.selectedIds;\n\n      _this[\"do\"](toggle(data, idsToMutate, 'isHidden'));\n\n      return _this;\n    };\n\n    this.toggleLocked = function (ids) {\n      var data = _this.store.getState();\n\n      var idsToMutate = ids ? ids : data.pageState.selectedIds;\n\n      _this[\"do\"](toggle(data, idsToMutate, 'isLocked'));\n\n      return _this;\n    };\n\n    this.toggleAspectRatioLocked = function (ids) {\n      var data = _this.store.getState();\n\n      var idsToMutate = ids ? ids : data.pageState.selectedIds;\n\n      _this[\"do\"](toggle(data, idsToMutate, 'isAspectRatioLocked'));\n\n      return _this;\n    };\n\n    this.rotate = function (delta, ids) {\n      if (delta === void 0) {\n        delta = Math.PI * -0.5;\n      }\n\n      var data = _this.store.getState();\n\n      var idsToMutate = ids ? ids : data.pageState.selectedIds;\n\n      _this[\"do\"](rotate(data, idsToMutate, delta));\n\n      return _this;\n    };\n\n    this.group = function (ids) {\n      // TODO\n      // const data = this.store.getState()\n      // const idsToMutate = ids ? ids : data.pageState.selectedIds\n      // this.do(commands.toggle(data, idsToMutate, 'isAspectRatioLocked'))\n      return _this;\n    };\n\n    this.create = function () {\n      var data = _this.store.getState();\n\n      for (var _len2 = arguments.length, shapes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        shapes[_key2] = arguments[_key2];\n      }\n\n      _this[\"do\"](create(data, shapes));\n\n      return _this;\n    };\n\n    this[\"delete\"] = function (ids) {\n      var data = _this.store.getState();\n\n      var idsToMutate = ids ? ids : data.pageState.selectedIds;\n      if (idsToMutate.length === 0) return _this;\n\n      _this[\"do\"](deleteShapes(data, idsToMutate));\n\n      return _this;\n    };\n\n    this.clear = function () {\n      _this.selectAll();\n\n      _this[\"delete\"]();\n\n      return _this;\n    };\n\n    this.cancel = function () {\n      switch (_this.status.current) {\n        case 'idle':\n          {\n            _this.deselectAll();\n\n            _this.selectTool('select');\n\n            break;\n          }\n\n        case 'brushing':\n          {\n            _this.cancelSession();\n\n            core.brushUpdater.clear();\n            break;\n          }\n\n        case 'translating':\n          {\n            _this.cancelSession();\n\n            break;\n          }\n\n        case 'transforming':\n          {\n            _this.cancelSession();\n\n            break;\n          }\n\n        case 'rotating':\n          {\n            _this.cancelSession();\n\n            break;\n          }\n\n        case 'creating':\n          {\n            _this.cancelSession();\n\n            _this[\"delete\"]();\n\n            break;\n          }\n      }\n\n      return _this;\n    };\n\n    this.save = function () {\n      // TODO\n      return _this;\n    };\n\n    this.startBrushSession = function (point) {\n      _this.setStatus('brushing');\n\n      _this.startSession(new BrushSession(_this.store.getState(), point));\n\n      return _this;\n    };\n\n    this.updateBrushSession = function (point, metaKey) {\n      if (metaKey === void 0) {\n        metaKey = false;\n      }\n\n      _this.updateSession(point, metaKey);\n\n      return _this;\n    };\n\n    this.startTranslateSession = function (point) {\n      _this.setStatus('translating');\n\n      _this.startSession(new TranslateSession(_this.store.getState(), point));\n\n      return _this;\n    };\n\n    this.updateTranslateSession = function (point, shiftKey, altKey) {\n      if (shiftKey === void 0) {\n        shiftKey = false;\n      }\n\n      if (altKey === void 0) {\n        altKey = false;\n      }\n\n      _this.updateSession(point, shiftKey, altKey);\n\n      return _this;\n    };\n\n    this.startTransformSession = function (point, handle, commandId) {\n      var selectedIds = _this.selectedIds;\n      if (selectedIds.length === 0) return _this;\n\n      _this.setStatus('transforming');\n\n      _this.pointedBoundsHandle = handle;\n\n      if (_this.pointedBoundsHandle === 'rotate') {\n        _this.startSession(new RotateSession(_this.store.getState(), point));\n      } else if (_this.selectedIds.length === 1) {\n        _this.startSession(new TransformSingleSession(_this.store.getState(), point, _this.pointedBoundsHandle, commandId));\n      } else {\n        _this.startSession(new TransformSession(_this.store.getState(), point, _this.pointedBoundsHandle));\n      }\n\n      return _this;\n    };\n\n    this.updateTransformSession = function (point, shiftKey, altKey) {\n      if (shiftKey === void 0) {\n        shiftKey = false;\n      }\n\n      if (altKey === void 0) {\n        altKey = false;\n      }\n\n      _this.updateSession(point, shiftKey, altKey);\n\n      return _this;\n    };\n\n    this.startDrawSession = function (id, point) {\n      _this.setStatus('creating');\n\n      _this.startSession(new DrawSession(_this.store.getState(), id, point));\n\n      return _this;\n    };\n\n    this.updateDrawSession = function (point, pressure, shiftKey) {\n      if (shiftKey === void 0) {\n        shiftKey = false;\n      }\n\n      _this.updateSession(point, pressure, shiftKey);\n\n      return _this;\n    };\n\n    this.updateSessionsOnPointerMove = function (info) {\n      switch (_this.status.current) {\n        case 'pointingBoundsHandle':\n          {\n            if (core.Vec.dist(info.origin, info.point) > 4) {\n              _this.setStatus('transforming');\n\n              _this.startTransformSession(_this.getPagePoint(info.origin), _this.pointedBoundsHandle);\n            }\n\n            break;\n          }\n\n        case 'pointingBounds':\n          {\n            if (core.Vec.dist(info.origin, info.point) > 4) {\n              _this.setStatus('translating');\n\n              _this.startTranslateSession(_this.getPagePoint(info.origin));\n            }\n\n            break;\n          }\n\n        case 'brushing':\n          {\n            _this.updateBrushSession(_this.getPagePoint(info.point), info.metaKey);\n\n            break;\n          }\n\n        case 'translating':\n          {\n            _this.updateTranslateSession(_this.getPagePoint(info.point), info.shiftKey, info.altKey);\n\n            break;\n          }\n\n        case 'transforming':\n          {\n            _this.updateTransformSession(_this.getPagePoint(info.point), info.shiftKey, info.altKey);\n\n            break;\n          }\n\n        case 'creating':\n          {\n            switch (_this.appState.activeToolType) {\n              case 'draw':\n                {\n                  _this.updateDrawSession(_this.getPagePoint(info.point), info.pressure, info.shiftKey);\n\n                  break;\n                }\n\n              case 'bounds':\n                {\n                  _this.updateTransformSession(_this.getPagePoint(info.point), info.shiftKey);\n\n                  break;\n                }\n            }\n\n            break;\n          }\n      }\n    };\n\n    this.onKeyDown = function (key, info) {\n      if (key === 'Escape') {\n        _this.cancel();\n\n        return;\n      }\n\n      switch (_this.status.current) {\n        case 'idle':\n          {\n            break;\n          }\n\n        case 'brushing':\n          {\n            if (key === 'Meta' || key === 'Control') {\n              _this.updateBrushSession(_this.getPagePoint(info.point), info.metaKey);\n\n              return;\n            }\n\n            break;\n          }\n\n        case 'translating':\n          {\n            if (key === 'Escape') {\n              _this.cancelSession(_this.getPagePoint(info.point));\n            }\n\n            if (key === 'Shift' || key === 'Alt') {\n              _this.updateTranslateSession(_this.getPagePoint(info.point), info.shiftKey, info.altKey);\n            }\n\n            break;\n          }\n\n        case 'transforming':\n          {\n            if (key === 'Escape') {\n              _this.cancelSession(_this.getPagePoint(info.point));\n            }\n\n            if (key === 'Shift' || key === 'Alt') {\n              _this.updateTransformSession(_this.getPagePoint(info.point), info.shiftKey, info.altKey);\n            }\n\n            break;\n          }\n      }\n    };\n\n    this.onKeyUp = function (key, info) {\n      switch (_this.status.current) {\n        case 'brushing':\n          {\n            if (key === 'Meta' || key === 'Control') {\n              _this.updateBrushSession(_this.getPagePoint(info.point), info.metaKey);\n            }\n\n            break;\n          }\n\n        case 'transforming':\n          {\n            if (key === 'Shift' || key === 'Alt') {\n              _this.updateTransformSession(_this.getPagePoint(info.point), info.shiftKey, info.altKey);\n            }\n\n            break;\n          }\n\n        case 'translating':\n          {\n            if (key === 'Shift' || key === 'Alt') {\n              _this.updateTransformSession(_this.getPagePoint(info.point), info.shiftKey, info.altKey);\n            }\n\n            break;\n          }\n      }\n    };\n\n    this.onPinchStart = function (info) {\n      _this.setStatus('pinching');\n    };\n\n    this.onPinchEnd = function () {\n      _this.setStatus(_this.status.previous);\n    };\n\n    this.onPinch = function (info, e) {\n      if (_this.status.current !== 'pinching') return;\n\n      _this.pinchZoom(info.origin, info.delta, info.delta[2] / 350);\n\n      _this.updateSessionsOnPointerMove(info, e);\n    };\n\n    this.onPan = function (info, e) {\n      var delta = core.Vec.div(info.delta, _this.getPageState().camera.zoom);\n\n      var prev = _this.getPageState().camera.point;\n\n      var next = core.Vec.sub(prev, delta);\n      if (core.Vec.isEqual(next, prev)) return;\n\n      _this.pan(delta);\n\n      _this.updateSessionsOnPointerMove(info, e);\n    };\n\n    this.onZoom = function (info, e) {\n      _this.zoom(info.delta[2] / 100);\n\n      _this.updateSessionsOnPointerMove(info, e);\n    };\n\n    this.onPointerDown = function (info) {\n      switch (_this.status.current) {\n        case 'idle':\n          {\n            switch (_this.appState.activeTool) {\n              case 'draw':\n                {\n                  _this.setStatus('creating');\n\n                  _this.createActiveToolShape(info.point);\n\n                  break;\n                }\n\n              case 'rectangle':\n                {\n                  _this.setStatus('creating');\n\n                  _this.createActiveToolShape(info.point);\n\n                  break;\n                }\n\n              case 'ellipse':\n                {\n                  _this.setStatus('creating');\n\n                  _this.createActiveToolShape(info.point);\n\n                  break;\n                }\n            }\n          }\n      }\n    };\n\n    this.onPointerMove = function (info, e) {\n      _this.updateSessionsOnPointerMove(info, e);\n    };\n\n    this.onPointerUp = function (info) {\n      var data = _this.getState();\n\n      switch (_this.status.current) {\n        case 'pointingBoundsHandle':\n          {\n            _this.setStatus('idle');\n\n            _this.pointedBoundsHandle = undefined;\n            break;\n          }\n\n        case 'pointingBounds':\n          {\n            if (info.target === 'bounds') {\n              // If we just clicked the selecting bounds's background, clear the selection\n              _this.deselectAll();\n            } else if (data.pageState.selectedIds.includes(info.target)) {\n              // If we're holding shift...\n              if (info.shiftKey) {\n                // Unless we just shift-selected the shape, remove it from the selected shapes\n                if (_this.pointedId !== info.target) {\n                  _this.setSelectedIds(data.pageState.selectedIds.filter(function (id) {\n                    return id !== info.target;\n                  }));\n                }\n              }\n            }\n\n            _this.setStatus('idle');\n\n            _this.pointedId = undefined;\n            break;\n          }\n\n        case 'brushing':\n          {\n            _this.completeSession();\n\n            core.brushUpdater.clear();\n            break;\n          }\n\n        case 'translating':\n          {\n            _this.completeSession(_this.getPagePoint(info.point));\n\n            _this.pointedId = undefined;\n            break;\n          }\n\n        case 'transforming':\n          {\n            _this.completeSession(_this.getPagePoint(info.point));\n\n            _this.pointedBoundsHandle = undefined;\n            break;\n          }\n\n        case 'creating':\n          {\n            _this.completeSession(_this.getPagePoint(info.point));\n          }\n      }\n    };\n\n    this.onPointCanvas = function (info) {\n      switch (_this.status.current) {\n        case 'idle':\n          {\n            switch (_this.appState.activeTool) {\n              case 'select':\n                {\n                  // Unless the user is holding shift or meta, clear the current selection\n                  if (!(info.shiftKey || info.metaKey)) {\n                    _this.deselectAll();\n                  } // Start a brush session\n\n\n                  _this.startBrushSession(_this.getPagePoint(info.point));\n\n                  break;\n                }\n            }\n          }\n      }\n    };\n\n    this.onDoubleClickCanvas = function () {// Unused\n    };\n\n    this.onRightPointCanvas = function () {// Unused\n    };\n\n    this.onDragCanvas = function () {// Unused\n    };\n\n    this.onReleaseCanvas = function () {// Unused\n    };\n\n    this.onPointShape = function (info) {\n      var data = _this.getState();\n\n      switch (_this.status.current) {\n        case 'idle':\n          {\n            switch (_this.appState.activeTool) {\n              case 'select':\n                {\n                  if (info.metaKey) {\n                    // While holding command key, allow event to pass through to canvas\n                    return;\n                  }\n\n                  if (!data.pageState.selectedIds.includes(info.target)) {\n                    // Set the pointed ID to the shape that was clicked.\n                    _this.pointedId = info.target; // If the shape is not selected; then if the user is pressing shift,\n                    // add the shape to the current selection; otherwise, set the shape as\n                    // the only selected shape.\n\n                    _this.setSelectedIds([info.target], info.shiftKey);\n                  }\n\n                  _this.setStatus('pointingBounds');\n\n                  break;\n                }\n            }\n          }\n      }\n    };\n\n    this.onReleaseShape = function (info) {// const data = this.getState()\n      // switch (this.status.current) {\n      //   case 'pointingBounds': {\n      //     if (info.metaKey) {\n      //       // While holding command key, allow event to pass through to canvas\n      //       return\n      //     }\n      //     // If the shape is selected...\n      //     if (\n      //       data.pageState.selectedIds.includes(info.target) &&\n      //       this.pointedId !== info.target &&\n      //       info.shiftKey\n      //     ) {\n      //       // If the shape is not selected; then if the user is pressing shift,\n      //       // add the shape to the current selection; otherwise, set the shape as\n      //       // the only selected shape.\n      //       this.setSelectedIds(data.pageState.selectedIds.filter((id) => id !== info.target))\n      //     }\n      //     this.setStatus('pointingBounds')\n      //     break\n      //   }\n      // }\n    };\n\n    this.onDoubleClickShape = function (info) {\n      if (_this.selectedIds.includes(info.target)) {\n        _this.setSelectedIds([info.target]);\n      }\n    };\n\n    this.onRightPointShape = function () {// TODO\n    };\n\n    this.onDragShape = function (info) {// Unused\n    };\n\n    this.onHoverShape = function (info) {\n      _this.setState(function (data) {\n        return {\n          appState: _extends({}, data.appState, {\n            hoveredId: info.target\n          })\n        };\n      });\n    };\n\n    this.onUnhoverShape = function (info) {\n      setTimeout(function () {\n        if (_this.getState().appState.hoveredId === info.target) {\n          _this.setState(function (data) {\n            return {\n              appState: _extends({}, data.appState, {\n                hoveredId: undefined\n              })\n            };\n          });\n        }\n      }, 10);\n    };\n\n    this.onPointBounds = function (info) {\n      _this.setStatus('pointingBounds');\n    };\n\n    this.onDoubleClickBounds = function () {// TODO\n    };\n\n    this.onRightPointBounds = function () {// TODO\n    };\n\n    this.onDragBounds = function (info) {// Unused\n    };\n\n    this.onHoverBounds = function () {// TODO\n    };\n\n    this.onUnhoverBounds = function () {// TODO\n    };\n\n    this.onReleaseBounds = function (info) {\n      switch (_this.status.current) {\n        case 'translating':\n          {\n            _this.completeSession(_this.getPagePoint(info.point));\n\n            break;\n          }\n\n        case 'brushing':\n          {\n            _this.completeSession();\n\n            core.brushUpdater.clear();\n            break;\n          }\n      }\n    };\n\n    this.onPointBoundsHandle = function (info) {\n      _this.pointedBoundsHandle = info.target;\n\n      _this.setStatus('pointingBoundsHandle');\n    };\n\n    this.onDoubleClickBoundsHandle = function () {// TODO\n    };\n\n    this.onRightPointBoundsHandle = function () {// TODO\n    };\n\n    this.onDragBoundsHandle = function () {// Unused\n    };\n\n    this.onHoverBoundsHandle = function () {// TODO\n    };\n\n    this.onUnhoverBoundsHandle = function () {// TODO\n    };\n\n    this.onReleaseBoundsHandle = function () {// TODO\n    };\n\n    this.onPointHandle = function () {// TODO\n    };\n\n    this.onDoubleClickHandle = function () {// TODO\n    };\n\n    this.onRightPointHandle = function () {// TODO\n    };\n\n    this.onDragHandle = function () {// TODO\n    };\n\n    this.onHoverHandle = function () {// TODO\n    };\n\n    this.onUnhoverHandle = function () {// TODO\n    };\n\n    this.onReleaseHandle = function () {// TODO\n    };\n\n    this.onChange = function (ids) {\n      var appState = _this.getAppState();\n\n      if (appState.isEmptyCanvas && ids.length > 0) {\n        _this.setState(function (data) {\n          return {\n            appState: _extends({}, data.appState, {\n              isEmptyCanvas: false\n            })\n          };\n        });\n      } else if (!appState.isEmptyCanvas && ids.length <= 0) {\n        _this.setState(function (data) {\n          return {\n            appState: _extends({}, data.appState, {\n              isEmptyCanvas: true\n            })\n          };\n        });\n      }\n    };\n\n    this.onError = function (error) {// TODO\n    };\n\n    this.onBlurEditingShape = function () {// TODO\n    };\n  }\n\n  var _proto = TLDrawState.prototype;\n\n  /* --------------------- Status --------------------- */\n  _proto.setStatus = function setStatus(status) {\n    this.status.previous = this.status.current;\n    this.status.current = status;\n    return this; // console.log(this.status.previous, ' -> ', this.status.current)\n  }\n  /* -------------------- App State ------------------- */\n  ;\n\n  _proto.pinchZoom = function pinchZoom(point, delta, zoomDelta) {\n    this.setState(function (data) {\n      var camera = data.pageState.camera;\n      var nextPoint = core.Vec.add(camera.point, core.Vec.div(delta, camera.zoom));\n      var nextZoom = TLDR.getCameraZoom(camera.zoom - zoomDelta * camera.zoom);\n      var p0 = core.Vec.sub(core.Vec.div(point, camera.zoom), nextPoint);\n      var p1 = core.Vec.sub(core.Vec.div(point, nextZoom), nextPoint);\n      return {\n        pageState: _extends({}, data.pageState, {\n          camera: _extends({}, data.pageState.camera, {\n            point: core.Vec.add(nextPoint, core.Vec.sub(p1, p0)),\n            zoom: nextZoom\n          })\n        })\n      };\n    });\n    return this;\n  };\n\n  _proto.zoomTo = function zoomTo(next) {\n    this.setState(function (data) {\n      var _TLDR$getCurrentCamer = TLDR.getCurrentCamera(data),\n          zoom = _TLDR$getCurrentCamer.zoom,\n          point = _TLDR$getCurrentCamer.point;\n\n      var center = [window.innerWidth / 2, window.innerHeight / 2];\n      var p0 = core.Vec.sub(core.Vec.div(center, zoom), point);\n      var p1 = core.Vec.sub(core.Vec.div(center, next), point);\n      return {\n        pageState: _extends({}, data.pageState, {\n          camera: _extends({}, data.pageState.camera, {\n            point: core.Vec.add(point, core.Vec.sub(p1, p0)),\n            zoom: next\n          })\n        })\n      };\n    });\n    return this;\n  };\n\n  _proto.zoom = function zoom(delta) {\n    var zoom = this.store.getState().pageState.camera.zoom;\n    var nextZoom = TLDR.getCameraZoom(zoom - delta * zoom);\n    this.zoomTo(nextZoom);\n    return this;\n  };\n\n  _proto.pan = function pan(delta) {\n    this.setState(function (data) {\n      var _TLDR$getCurrentCamer2 = TLDR.getCurrentCamera(data),\n          point = _TLDR$getCurrentCamer2.point;\n\n      return {\n        pageState: _extends({}, data.pageState, {\n          camera: _extends({}, data.pageState.camera, {\n            point: core.Vec.sub(point, delta)\n          })\n        })\n      };\n    });\n    return this;\n  }\n  /* ---------------------- Document --------------------- */\n  ;\n\n  _proto.setCurrentPageId = function setCurrentPageId(pageId) {\n    if (pageId === this.currentPageId) return this;\n    this.currentPageId = pageId;\n    this.setState({\n      page: this.pages[pageId],\n      pageState: this.pageStates[pageId]\n    });\n    return this;\n  }\n  /* -------------------- Sessions -------------------- */\n  ;\n\n  _proto.startSession = function startSession(session) {\n    var _this$_onChange;\n\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n\n    this.session = session;\n    this.setState(function (data) {\n      return session.start.apply(session, [data].concat(args));\n    });\n    (_this$_onChange = this._onChange) == null ? void 0 : _this$_onChange.call(this, this, \"session:start_\" + session.id);\n    return this;\n  };\n\n  _proto.updateSession = function updateSession() {\n    var _this$_onChange2;\n\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    var session = this.session;\n    if (!session) return;\n    this.setState(function (data) {\n      return session.update.apply(session, [data].concat(args));\n    });\n    (_this$_onChange2 = this._onChange) == null ? void 0 : _this$_onChange2.call(this, this, \"session:update:\" + session.id);\n    return this;\n  };\n\n  _proto.cancelSession = function cancelSession() {\n    var _this$_onChange3;\n\n    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n\n    var session = this.session;\n    if (!session) return;\n    this.setState(function (data) {\n      return session.cancel.apply(session, [data].concat(args));\n    });\n    this.setStatus('idle');\n    this.session = undefined;\n    (_this$_onChange3 = this._onChange) == null ? void 0 : _this$_onChange3.call(this, this, \"session:cancel:\" + session.id);\n    return this;\n  };\n\n  _proto.completeSession = function completeSession() {\n    var session = this.session;\n    if (!session) return;\n    this.setStatus('idle');\n\n    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n\n    var result = session.complete.apply(session, [this.store.getState()].concat(args));\n\n    if ('after' in result) {\n      this[\"do\"](result);\n    } else {\n      var _this$_onChange4;\n\n      this.setState(function (data) {\n        return core.Utils.deepMerge(data, result);\n      });\n      (_this$_onChange4 = this._onChange) == null ? void 0 : _this$_onChange4.call(this, this, \"session:complete:\" + session.id);\n    }\n\n    var _this$appState = this.appState,\n        isToolLocked = _this$appState.isToolLocked,\n        activeTool = _this$appState.activeTool;\n\n    if (!isToolLocked && activeTool !== 'draw') {\n      this.selectTool('select');\n    }\n\n    this.session = undefined;\n    return this;\n  }\n  /* -------------------- Commands -------------------- */\n  ;\n\n  _proto[\"do\"] = function _do(command) {\n    var _this$_onChange5;\n\n    var history = this.history;\n\n    if (history.pointer !== history.stack.length - 1) {\n      history.stack = history.stack.slice(0, history.pointer + 1);\n    }\n\n    history.stack.push(command);\n    history.pointer = history.stack.length - 1;\n    this.setState(function (data) {\n      return core.Utils.deepMerge(data, history.stack[history.pointer].after);\n    });\n    (_this$_onChange5 = this._onChange) == null ? void 0 : _this$_onChange5.call(this, this, \"command:\" + command.id);\n    return this;\n  };\n\n  /* -------------------- Selection ------------------- */\n  _proto.setSelectedIds = function setSelectedIds(ids, push) {\n    if (push === void 0) {\n      push = false;\n    }\n\n    this.setState(function (data) {\n      return {\n        pageState: _extends({}, data.pageState, {\n          selectedIds: push ? [].concat(data.pageState.selectedIds, ids) : [].concat(ids)\n        })\n      };\n    });\n    return this;\n  };\n\n  _proto.createActiveToolShape = function createActiveToolShape(point) {\n    var id = core.Utils.uniqueId();\n    var pagePoint = core.Vec.round(this.getPagePoint(point));\n    this.setState(function (data) {\n      var _extends2;\n\n      var _data$appState = data.appState,\n          activeTool = _data$appState.activeTool,\n          activeToolType = _data$appState.activeToolType;\n      if (activeTool === 'select') return data;\n      if (!activeToolType) throw Error;\n      var utils = TLDR.getShapeUtils({\n        type: activeTool\n      });\n      var shapes = Object.values(data.page.shapes);\n      var childIndex = shapes.length === 0 ? 1 : shapes.sort(function (a, b) {\n        return b.childIndex - a.childIndex;\n      })[0].childIndex + 1;\n      return {\n        page: _extends({}, data.page, {\n          shapes: _extends({}, data.page.shapes, (_extends2 = {}, _extends2[id] = utils.create({\n            id: id,\n            parentId: data.page.id,\n            childIndex: childIndex,\n            point: pagePoint,\n            style: _extends({}, data.appState.currentStyle)\n          }), _extends2))\n        }),\n        pageState: _extends({}, data.pageState, {\n          selectedIds: [id]\n        })\n      };\n    });\n\n    var _this$getAppState = this.getAppState(),\n        activeTool = _this$getAppState.activeTool,\n        activeToolType = _this$getAppState.activeToolType;\n\n    switch (activeToolType) {\n      case 'draw':\n        {\n          this.startDrawSession(id, pagePoint);\n          break;\n        }\n\n      case 'bounds':\n        {\n          this.startTransformSession(pagePoint, core.TLBoundsCorner.BottomRight, \"create_\" + activeTool);\n          break;\n        }\n    }\n  }\n  /* --------------------- Events --------------------- */\n  ;\n\n  _createClass(TLDrawState, [{\n    key: \"document\",\n    get: function get() {\n      return {\n        id: this.currentDocumentId,\n        pages: this.pages,\n        pageStates: this.pageStates\n      };\n    }\n  }, {\n    key: \"data\",\n    get: function get() {\n      return this.getState();\n    }\n  }, {\n    key: \"selectedIds\",\n    get: function get() {\n      return this.pageState.selectedIds;\n    }\n  }, {\n    key: \"page\",\n    get: function get() {\n      return this.pages[this.currentPageId];\n    }\n  }, {\n    key: \"pageState\",\n    get: function get() {\n      return this.pageStates[this.currentPageId];\n    }\n  }, {\n    key: \"appState\",\n    get: function get() {\n      return this.data.appState;\n    }\n  }]);\n\n  return TLDrawState;\n}();\n\nvar hideBoundsSelector = function hideBoundsSelector(s) {\n  return s.appState.activeTool !== 'select';\n};\n\nvar pageSelector = function pageSelector(s) {\n  return s.page;\n};\n\nvar pageStateSelector = function pageStateSelector(s) {\n  return s.pageState;\n};\n\nfunction TLDraw(_ref) {\n  var document = _ref.document,\n      currentPageId = _ref.currentPageId,\n      onMount = _ref.onMount,\n      _onChange = _ref.onChange;\n\n  var _React$useState = React.useState(function () {\n    return new TLDrawState();\n  }),\n      tlstate = _React$useState[0];\n\n  var _React$useState2 = React.useState(function () {\n    return {\n      tlstate: tlstate,\n      useAppState: tlstate.store\n    };\n  }),\n      context = _React$useState2[0];\n\n  useKeyboardShortcuts(tlstate);\n  var hideBounds = context.useAppState(hideBoundsSelector);\n  var page = context.useAppState(pageSelector);\n  var pageState = context.useAppState(pageStateSelector);\n  React.useEffect(function () {\n    if (!document) return;\n    tlstate.loadDocument(document, _onChange);\n  }, [document, tlstate]);\n  React.useEffect(function () {\n    if (!currentPageId) return;\n    tlstate.setCurrentPageId(currentPageId);\n  }, [currentPageId, tlstate]);\n  React.useEffect(function () {\n    onMount == null ? void 0 : onMount(tlstate); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return React.createElement(TLDrawContext.Provider, {\n    value: context\n  }, React.createElement(reactId.IdProvider, null, React.createElement(Layout, null, React.createElement(ContextMenu, null, React.createElement(core.Renderer, {\n    page: page,\n    pageState: pageState,\n    shapeUtils: tldrawShapeUtils,\n    hideBounds: hideBounds,\n    onPinchStart: tlstate.onPinchStart,\n    onPinchEnd: tlstate.onPinchEnd,\n    onPinch: tlstate.onPinch,\n    onPan: tlstate.onPan,\n    onZoom: tlstate.onZoom,\n    onPointerDown: tlstate.onPointerDown,\n    onPointerMove: tlstate.onPointerMove,\n    onPointerUp: tlstate.onPointerUp,\n    onPointCanvas: tlstate.onPointCanvas,\n    onDoubleClickCanvas: tlstate.onDoubleClickCanvas,\n    onRightPointCanvas: tlstate.onRightPointCanvas,\n    onDragCanvas: tlstate.onDragCanvas,\n    onReleaseCanvas: tlstate.onReleaseCanvas,\n    onPointShape: tlstate.onPointShape,\n    onDoubleClickShape: tlstate.onDoubleClickShape,\n    onRightPointShape: tlstate.onRightPointShape,\n    onDragShape: tlstate.onDragShape,\n    onHoverShape: tlstate.onHoverShape,\n    onUnhoverShape: tlstate.onUnhoverShape,\n    onReleaseShape: tlstate.onReleaseShape,\n    onPointBounds: tlstate.onPointBounds,\n    onDoubleClickBounds: tlstate.onDoubleClickBounds,\n    onRightPointBounds: tlstate.onRightPointBounds,\n    onDragBounds: tlstate.onDragBounds,\n    onHoverBounds: tlstate.onHoverBounds,\n    onUnhoverBounds: tlstate.onUnhoverBounds,\n    onReleaseBounds: tlstate.onReleaseBounds,\n    onPointBoundsHandle: tlstate.onPointBoundsHandle,\n    onDoubleClickBoundsHandle: tlstate.onDoubleClickBoundsHandle,\n    onRightPointBoundsHandle: tlstate.onRightPointBoundsHandle,\n    onDragBoundsHandle: tlstate.onDragBoundsHandle,\n    onHoverBoundsHandle: tlstate.onHoverBoundsHandle,\n    onUnhoverBoundsHandle: tlstate.onUnhoverBoundsHandle,\n    onReleaseBoundsHandle: tlstate.onReleaseBoundsHandle,\n    onPointHandle: tlstate.onPointHandle,\n    onDoubleClickHandle: tlstate.onDoubleClickHandle,\n    onRightPointHandle: tlstate.onRightPointHandle,\n    onDragHandle: tlstate.onDragHandle,\n    onHoverHandle: tlstate.onHoverHandle,\n    onUnhoverHandle: tlstate.onUnhoverHandle,\n    onReleaseHandle: tlstate.onReleaseHandle,\n    onChange: tlstate.onChange,\n    onError: tlstate.onError,\n    onBlurEditingShape: tlstate.onBlurEditingShape\n  })), React.createElement(Spacer, null), React.createElement(StylePanel, null), React.createElement(ToolsPanel, null))));\n}\nvar Spacer = /*#__PURE__*/styled('div', {\n  flexGrow: 2\n}); // const MenuButtons = styled('div', {\n//   display: 'flex',\n//   gap: 8,\n// })\n\nvar Layout = /*#__PURE__*/styled('main', {\n  position: 'fixed',\n  overflow: 'hidden',\n  top: 0,\n  left: 0,\n  bottom: 0,\n  right: 0,\n  height: '100%',\n  width: '100%',\n  padding: '8px 8px 0 8px',\n  zIndex: 200,\n  display: 'flex',\n  alignItems: 'flex-start',\n  justifyContent: 'flex-start',\n  boxSizing: 'border-box',\n  outline: 'none',\n  pointerEvents: 'none',\n  '& > *': {\n    pointerEvents: 'all'\n  },\n  '& .tl-container': {\n    position: 'absolute',\n    top: 0,\n    left: 0\n  }\n});\n\nexports.TLDraw = TLDraw;\nexports.TLDrawShapeUtil = TLDrawShapeUtil;\nexports.TLDrawState = TLDrawState;\nexports.createShape = createShape;\nexports.defaultStyle = defaultStyle;\nexports.fills = fills;\nexports.getFontSize = getFontSize;\nexports.getFontStyle = getFontStyle;\nexports.getPerfectDashProps = getPerfectDashProps;\nexports.getShapeStyle = getShapeStyle;\nexports.getShapeUtils = getShapeUtils;\nexports.getStrokeWidth = getStrokeWidth;\nexports.strokes = strokes;\nexports.tldrawShapeUtils = tldrawShapeUtils;\n//# sourceMappingURL=tldraw.cjs.development.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdGxkcmF3L3d3dy8uLi9wYWNrYWdlcy90bGRyYXcvZGlzdC90bGRyYXcuY2pzLmRldmVsb3BtZW50LmpzPzFlNDEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDLENBQUMsY0FBYyxFQUFDOztBQUU3RCwrQkFBK0IsaUZBQWlGOztBQUVoSCxZQUFZLG1CQUFPLENBQUMsb0JBQU87QUFDM0I7QUFDQSxjQUFjLG1CQUFPLENBQUMsOENBQW9CO0FBQzFDLFdBQVcsbUJBQU8sQ0FBQyxvREFBYztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQywwQ0FBa0I7QUFDMUM7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQyw4Q0FBb0I7QUFDbkQsWUFBWSxtQkFBTyxDQUFDLHdDQUFpQjtBQUNyQyxvQkFBb0IsbUJBQU8sQ0FBQyxrRUFBOEI7QUFDMUQsbUJBQW1CLG1CQUFPLENBQUMsd0RBQXlCO0FBQ3BELG1CQUFtQixtQkFBTyxDQUFDLG9FQUErQjtBQUMxRCxtQkFBTyxDQUFDLGdFQUE2QjtBQUNyQyxpQkFBaUIsbUJBQU8sQ0FBQyxvREFBdUI7QUFDaEQsZUFBZSxtQkFBTyxDQUFDLDBEQUEwQjtBQUNqRCxrQ0FBa0MsbUJBQU8sQ0FBQyx3QkFBUzs7QUFFbkQ7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUzs7QUFFakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw2QkFBNkIsc0JBQXNCLEtBQUs7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEIsdUJBQXVCLEtBQUs7O0FBRTNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMseUJBQXlCLGtCQUFrQixLQUFLOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQixLQUFLOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0IsaUJBQWlCLEtBQUs7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVCQUF1QixnQkFBZ0IsS0FBSzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsR0FBRyxtQkFBbUI7QUFDdEI7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxHQUFHLG1CQUFtQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHNDQUFzQztBQUN0QyxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUVBQXVFLGFBQWE7QUFDcEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1RUFBdUUsYUFBYTtBQUNwRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUVBQXVFLGFBQWE7QUFDcEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBJQUEwSTs7QUFFMUk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7OztBQUdMLHFEQUFxRDtBQUNyRCx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0RBQXNELEVBQUU7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsc0JBQXNCO0FBQ3RCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQkFBZ0I7QUFDaEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVCQUF1QixnQkFBZ0IsS0FBSzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUIsS0FBSzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEIsbUJBQW1CLEtBQUs7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBLENBQUMsNkJBQTZCLHNCQUFzQixLQUFLOztBQUV6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTtBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix5QkFBeUIsYUFBYSxFQUFFLGNBQWMsR0FBRztBQUNuRixZQUFZLGFBQWEsV0FBVztBQUNwQztBQUNBLG9CQUFvQjtBQUNwQix5QkFBeUI7QUFDekIseUJBQXlCLG1DQUFtQyxLQUFLO0FBQ2pFO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTtBQUNBLHFDQUFxQyxHQUFHO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZ0JBQWdCO0FBQ2hCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxnQkFBZ0I7QUFDaEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUcsYUFBYTtBQUNoQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUssRUFBRTs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRTs7QUFFUCx3Q0FBd0M7O0FBRXhDO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBLEtBQUssRUFBRTs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSzs7QUFFTCxtRkFBbUYsNkJBQTZCO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwyREFBMkQ7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQSwrRUFBK0UsK0JBQStCO0FBQzlHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXOztBQUVYOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXOztBQUVYOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLE9BQU87QUFDUDtBQUNBLGlDQUFpQztBQUNqQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLE9BQU87QUFDUDtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLE9BQU87QUFDUCw0QkFBNEI7QUFDNUI7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsT0FBTztBQUNQLDRCQUE0QjtBQUM1QjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwyQkFBMkI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7O0FBR1gsa0VBQWtFOztBQUVsRSxvRUFBb0U7O0FBRXBFO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxXQUFXOzs7QUFHWCxrRUFBa0U7O0FBRWxFLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCLG1EQUFtRCxVQUFVO0FBQzdEO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlDQUFpQyxhQUFhO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCLDJCQUEyQiw2QkFBNkI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDRCQUE0QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQ0FBa0MsZUFBZTtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLDJCQUEyQjtBQUMzQixPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsdUJBQXVCO0FBQ3ZCLDJCQUEyQjtBQUMzQixPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQixHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEIsOEJBQThCO0FBQzlCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEIsNEJBQTRCO0FBQzVCO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0Qiw0QkFBNEI7QUFDNUI7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUIseUJBQXlCO0FBQ3pCLDJCQUEyQjtBQUMzQiw4QkFBOEI7QUFDOUIsT0FBTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakMsd0NBQXdDO0FBQ3hDLHlDQUF5QztBQUN6QztBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsd0NBQXdDO0FBQ3hDLHlDQUF5QztBQUN6QztBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTOzs7QUFHVCxzQ0FBc0M7QUFDdEMsdUNBQXVDO0FBQ3ZDO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQSxTQUFTLEVBQUU7O0FBRVgsc0NBQXNDO0FBQ3RDLHVDQUF1QztBQUN2QztBQUNBLFdBQVc7QUFDWCxTQUFTLElBQUk7O0FBRWI7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOzs7QUFHUCxvQ0FBb0M7QUFDcEMscUNBQXFDO0FBQ3JDO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6QjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLFdBQVc7QUFDWCx5Q0FBeUM7QUFDekM7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFNBQVM7QUFDVCw4QkFBOEI7QUFDOUI7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1QsOEJBQThCO0FBQzlCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCx3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1QsOEJBQThCO0FBQzlCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsQ0FBQyxHQUFHOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCLDZCQUE2QixtQ0FBbUMsbUNBQW1DO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6Qiw2QkFBNkIsbUNBQW1DO0FBQ2hFLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCLHlCQUF5QjtBQUN6QixPQUFPOztBQUVQO0FBQ0EsK01BQStNOztBQUUvTTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekIsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EscUdBQXFHO0FBQ3JHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDOzs7QUFHQTtBQUNBLHNCQUFzQjtBQUN0Qix1QkFBdUI7QUFDdkIsMkJBQTJCLG1DQUFtQyxzQ0FBc0M7QUFDcEc7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLDRCQUE0QjtBQUM1QjtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0Qix1QkFBdUI7QUFDdkI7QUFDQSwyQkFBMkIsbUNBQW1DO0FBQzlELE9BQU87QUFDUCw0QkFBNEI7QUFDNUI7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1Qix5QkFBeUI7QUFDekIsOEJBQThCO0FBQzlCLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpRkFBaUYsNkJBQTZCO0FBQzlHO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQSx3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLEdBQUc7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLEtBQUs7QUFDTCxlQUFlO0FBQ2Y7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7OztBQUdyQzs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTzs7O0FBR1A7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUIsK0JBQStCO0FBQy9CO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQjtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsK0JBQStCO0FBQy9CO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0VBQXdFLGFBQWE7QUFDckY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsV0FBVztBQUNYLGdDQUFnQztBQUNoQztBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEVBQThFLGVBQWU7QUFDN0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COzs7QUFHbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QztBQUM1Qzs7QUFFQSwyQ0FBMkM7QUFDM0M7O0FBRUEscUNBQXFDO0FBQ3JDOztBQUVBLHdDQUF3QztBQUN4Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0QsaUNBQWlDO0FBQ25GLDhEQUE4RDtBQUM5RDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDO0FBQzFDOztBQUVBLHdDQUF3QztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDO0FBQzVDOztBQUVBLDJDQUEyQztBQUMzQzs7QUFFQSx5Q0FBeUM7QUFDekM7O0FBRUEsc0NBQXNDO0FBQ3RDOztBQUVBLHdDQUF3QztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtEQUFrRDtBQUNsRDs7QUFFQSxpREFBaUQ7QUFDakQ7O0FBRUEsMkNBQTJDO0FBQzNDOztBQUVBLDRDQUE0QztBQUM1Qzs7QUFFQSw4Q0FBOEM7QUFDOUM7O0FBRUEsOENBQThDO0FBQzlDOztBQUVBLHNDQUFzQztBQUN0Qzs7QUFFQSw0Q0FBNEM7QUFDNUM7O0FBRUEsMkNBQTJDO0FBQzNDOztBQUVBLHFDQUFxQztBQUNyQzs7QUFFQSxzQ0FBc0M7QUFDdEM7O0FBRUEsd0NBQXdDO0FBQ3hDOztBQUVBLHdDQUF3QztBQUN4Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLHFDQUFxQztBQUNyQzs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0I7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhGQUE4RixlQUFlO0FBQzdHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBFQUEwRSxlQUFlO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEVBQTBFLGVBQWU7QUFDekY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBFQUEwRSxlQUFlO0FBQ3pGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHlCQUF5QjtBQUN6Qiw2QkFBNkIsbUNBQW1DO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLFdBQVc7QUFDWCxTQUFTO0FBQ1QsOEJBQThCO0FBQzlCO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxnREFBZ0Q7QUFDaEQsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTtBQUNIO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELGNBQWM7QUFDZCx1QkFBdUI7QUFDdkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEIsYUFBYTtBQUNiLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEIsMkJBQTJCO0FBQzNCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCLGVBQWU7QUFDZix3QkFBd0I7QUFDeEIiLCJmaWxlIjoiLi4vcGFja2FnZXMvdGxkcmF3L2Rpc3QvdGxkcmF3LmNqcy5kZXZlbG9wbWVudC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChleCkgeyByZXR1cm4gKGV4ICYmICh0eXBlb2YgZXggPT09ICdvYmplY3QnKSAmJiAnZGVmYXVsdCcgaW4gZXgpID8gZXhbJ2RlZmF1bHQnXSA6IGV4OyB9XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RfX2RlZmF1bHQgPSBfaW50ZXJvcERlZmF1bHQoUmVhY3QpO1xudmFyIHJlYWN0SWQgPSByZXF1aXJlKCdAcmFkaXgtdWkvcmVhY3QtaWQnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnQHRsZHJhdy9jb3JlJyk7XG52YXIgZ2V0U3Ryb2tlID0gcmVxdWlyZSgncGVyZmVjdC1mcmVlaGFuZCcpO1xudmFyIGdldFN0cm9rZV9fZGVmYXVsdCA9IF9pbnRlcm9wRGVmYXVsdChnZXRTdHJva2UpO1xudmFyIHJlYWN0SG90a2V5c0hvb2sgPSByZXF1aXJlKCdyZWFjdC1ob3RrZXlzLWhvb2snKTtcbnZhciByZWFjdCA9IHJlcXVpcmUoJ0BzdGl0Y2hlcy9yZWFjdCcpO1xudmFyIENvbnRleHRNZW51JDEgPSByZXF1aXJlKCdAcmFkaXgtdWkvcmVhY3QtY29udGV4dC1tZW51Jyk7XG52YXIgUmFkaXhUb29sdGlwID0gcmVxdWlyZSgnQHJhZGl4LXVpL3JlYWN0LXRvb2x0aXAnKTtcbnZhciBEcm9wZG93bk1lbnUgPSByZXF1aXJlKCdAcmFkaXgtdWkvcmVhY3QtZHJvcGRvd24tbWVudScpO1xucmVxdWlyZSgnQHJhZGl4LXVpL3JlYWN0LXJhZGlvLWdyb3VwJyk7XG52YXIgcmVhY3RJY29ucyA9IHJlcXVpcmUoJ0ByYWRpeC11aS9yZWFjdC1pY29ucycpO1xudmFyIENoZWNrYm94ID0gcmVxdWlyZSgnQHJhZGl4LXVpL3JlYWN0LWNoZWNrYm94Jyk7XG52YXIgY3JlYXRlUmVhY3QgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnenVzdGFuZCcpKTtcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG5cbiAgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShvLCBhbGxvd0FycmF5TGlrZSkge1xuICB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKGl0KSByZXR1cm4gKGl0ID0gaXQuY2FsbChvKSkubmV4dC5iaW5kKGl0KTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKGl0KSBvID0gaXQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogb1tpKytdXG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbihmdW5jdGlvbiAoVExEcmF3VG9vbFR5cGUpIHtcbiAgVExEcmF3VG9vbFR5cGVbXCJEcmF3XCJdID0gXCJkcmF3XCI7XG4gIFRMRHJhd1Rvb2xUeXBlW1wiQm91bmRzXCJdID0gXCJib3VuZHNcIjtcbiAgVExEcmF3VG9vbFR5cGVbXCJQb2ludFwiXSA9IFwicG9pbnRcIjtcbiAgVExEcmF3VG9vbFR5cGVbXCJQb2ludHNcIl0gPSBcInBvaW50c1wiO1xufSkoZXhwb3J0cy5UTERyYXdUb29sVHlwZSB8fCAoZXhwb3J0cy5UTERyYXdUb29sVHlwZSA9IHt9KSk7XG5cbihmdW5jdGlvbiAoVExEcmF3U2hhcGVUeXBlKSB7XG4gIFRMRHJhd1NoYXBlVHlwZVtcIkVsbGlwc2VcIl0gPSBcImVsbGlwc2VcIjtcbiAgVExEcmF3U2hhcGVUeXBlW1wiUmVjdGFuZ2xlXCJdID0gXCJyZWN0YW5nbGVcIjtcbiAgVExEcmF3U2hhcGVUeXBlW1wiRHJhd1wiXSA9IFwiZHJhd1wiO1xufSkoZXhwb3J0cy5UTERyYXdTaGFwZVR5cGUgfHwgKGV4cG9ydHMuVExEcmF3U2hhcGVUeXBlID0ge30pKTtcblxudmFyIFRMRHJhd1NoYXBlVXRpbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1RMU2hhcGVVdGlsKSB7XG4gIF9pbmhlcml0c0xvb3NlKFRMRHJhd1NoYXBlVXRpbCwgX1RMU2hhcGVVdGlsKTtcblxuICBmdW5jdGlvbiBUTERyYXdTaGFwZVV0aWwoKSB7XG4gICAgcmV0dXJuIF9UTFNoYXBlVXRpbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICByZXR1cm4gVExEcmF3U2hhcGVVdGlsO1xufShjb3JlLlRMU2hhcGVVdGlsKTtcblxuKGZ1bmN0aW9uIChDb2xvclN0eWxlKSB7XG4gIENvbG9yU3R5bGVbXCJXaGl0ZVwiXSA9IFwiV2hpdGVcIjtcbiAgQ29sb3JTdHlsZVtcIkxpZ2h0R3JheVwiXSA9IFwiTGlnaHRHcmF5XCI7XG4gIENvbG9yU3R5bGVbXCJHcmF5XCJdID0gXCJHcmF5XCI7XG4gIENvbG9yU3R5bGVbXCJCbGFja1wiXSA9IFwiQmxhY2tcIjtcbiAgQ29sb3JTdHlsZVtcIkdyZWVuXCJdID0gXCJHcmVlblwiO1xuICBDb2xvclN0eWxlW1wiQ3lhblwiXSA9IFwiQ3lhblwiO1xuICBDb2xvclN0eWxlW1wiQmx1ZVwiXSA9IFwiQmx1ZVwiO1xuICBDb2xvclN0eWxlW1wiSW5kaWdvXCJdID0gXCJJbmRpZ29cIjtcbiAgQ29sb3JTdHlsZVtcIlZpb2xldFwiXSA9IFwiVmlvbGV0XCI7XG4gIENvbG9yU3R5bGVbXCJSZWRcIl0gPSBcIlJlZFwiO1xuICBDb2xvclN0eWxlW1wiT3JhbmdlXCJdID0gXCJPcmFuZ2VcIjtcbiAgQ29sb3JTdHlsZVtcIlllbGxvd1wiXSA9IFwiWWVsbG93XCI7XG59KShleHBvcnRzLkNvbG9yU3R5bGUgfHwgKGV4cG9ydHMuQ29sb3JTdHlsZSA9IHt9KSk7XG5cbihmdW5jdGlvbiAoU2l6ZVN0eWxlKSB7XG4gIFNpemVTdHlsZVtcIlNtYWxsXCJdID0gXCJTbWFsbFwiO1xuICBTaXplU3R5bGVbXCJNZWRpdW1cIl0gPSBcIk1lZGl1bVwiO1xuICBTaXplU3R5bGVbXCJMYXJnZVwiXSA9IFwiTGFyZ2VcIjtcbn0pKGV4cG9ydHMuU2l6ZVN0eWxlIHx8IChleHBvcnRzLlNpemVTdHlsZSA9IHt9KSk7XG5cbihmdW5jdGlvbiAoRGFzaFN0eWxlKSB7XG4gIERhc2hTdHlsZVtcIkRyYXdcIl0gPSBcIkRyYXdcIjtcbiAgRGFzaFN0eWxlW1wiU29saWRcIl0gPSBcIlNvbGlkXCI7XG4gIERhc2hTdHlsZVtcIkRhc2hlZFwiXSA9IFwiRGFzaGVkXCI7XG4gIERhc2hTdHlsZVtcIkRvdHRlZFwiXSA9IFwiRG90dGVkXCI7XG59KShleHBvcnRzLkRhc2hTdHlsZSB8fCAoZXhwb3J0cy5EYXNoU3R5bGUgPSB7fSkpO1xuXG4oZnVuY3Rpb24gKEZvbnRTaXplKSB7XG4gIEZvbnRTaXplW1wiU21hbGxcIl0gPSBcIlNtYWxsXCI7XG4gIEZvbnRTaXplW1wiTWVkaXVtXCJdID0gXCJNZWRpdW1cIjtcbiAgRm9udFNpemVbXCJMYXJnZVwiXSA9IFwiTGFyZ2VcIjtcbiAgRm9udFNpemVbXCJFeHRyYUxhcmdlXCJdID0gXCJFeHRyYUxhcmdlXCI7XG59KShleHBvcnRzLkZvbnRTaXplIHx8IChleHBvcnRzLkZvbnRTaXplID0ge30pKTtcblxudmFyIF9jb2xvcnMsIF9leHRlbmRzMiwgX2V4dGVuZHMzLCBfc3Ryb2tlV2lkdGhzLCBfZm9udFNpemVzO1xudmFyIGNhbnZhc0xpZ2h0ID0gJyNmYWZhZmEnO1xudmFyIGNhbnZhc0RhcmsgPSAnIzM0M2Q0NSc7XG52YXIgY29sb3JzID0gKF9jb2xvcnMgPSB7fSwgX2NvbG9yc1tleHBvcnRzLkNvbG9yU3R5bGUuQmxhY2tdID0gJyMyMTI1MjgnLCBfY29sb3JzW2V4cG9ydHMuQ29sb3JTdHlsZS5XaGl0ZV0gPSAnI2YwZjFmMycsIF9jb2xvcnNbZXhwb3J0cy5Db2xvclN0eWxlLkxpZ2h0R3JheV0gPSAnI2M2Y2JkMScsIF9jb2xvcnNbZXhwb3J0cy5Db2xvclN0eWxlLkdyYXldID0gJyM3ODg0OTInLCBfY29sb3JzW2V4cG9ydHMuQ29sb3JTdHlsZS5HcmVlbl0gPSAnIzM2YjI0ZCcsIF9jb2xvcnNbZXhwb3J0cy5Db2xvclN0eWxlLkN5YW5dID0gJyMwZTk4YWQnLCBfY29sb3JzW2V4cG9ydHMuQ29sb3JTdHlsZS5CbHVlXSA9ICcjMWM3ZWQ2JywgX2NvbG9yc1tleHBvcnRzLkNvbG9yU3R5bGUuSW5kaWdvXSA9ICcjNDI2M2ViJywgX2NvbG9yc1tleHBvcnRzLkNvbG9yU3R5bGUuVmlvbGV0XSA9ICcjNzc0NmYxJywgX2NvbG9yc1tleHBvcnRzLkNvbG9yU3R5bGUuUmVkXSA9ICcjZmYyMTMzJywgX2NvbG9yc1tleHBvcnRzLkNvbG9yU3R5bGUuT3JhbmdlXSA9ICcjZmY5NDMzJywgX2NvbG9yc1tleHBvcnRzLkNvbG9yU3R5bGUuWWVsbG93XSA9ICcjZmZjOTM2JywgX2NvbG9ycyk7XG52YXIgc3Ryb2tlcyA9IHtcbiAgbGlnaHQ6IGNvbG9ycyxcbiAgZGFyazogLyojX19QVVJFX18qL19leHRlbmRzKHt9LCAvKiNfX1BVUkVfXyovT2JqZWN0LmZyb21FbnRyaWVzKCAvKiNfX1BVUkVfXyovT2JqZWN0LmVudHJpZXMoY29sb3JzKS5tYXAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgayA9IF9yZWZbMF0sXG4gICAgICAgIHYgPSBfcmVmWzFdO1xuICAgIHJldHVybiBbaywgY29yZS5VdGlscy5sZXJwQ29sb3IodiwgY2FudmFzRGFyaywgMC4xKV07XG4gIH0pKSwgKF9leHRlbmRzMiA9IHt9LCBfZXh0ZW5kczJbZXhwb3J0cy5Db2xvclN0eWxlLldoaXRlXSA9ICcjZmZmZmZmJywgX2V4dGVuZHMyW2V4cG9ydHMuQ29sb3JTdHlsZS5CbGFja10gPSAnIzAwMCcsIF9leHRlbmRzMikpXG59O1xudmFyIGZpbGxzID0ge1xuICBsaWdodDogLyojX19QVVJFX18qL19leHRlbmRzKHt9LCAvKiNfX1BVUkVfXyovT2JqZWN0LmZyb21FbnRyaWVzKCAvKiNfX1BVUkVfXyovT2JqZWN0LmVudHJpZXMoY29sb3JzKS5tYXAoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgdmFyIGsgPSBfcmVmMlswXSxcbiAgICAgICAgdiA9IF9yZWYyWzFdO1xuICAgIHJldHVybiBbaywgY29yZS5VdGlscy5sZXJwQ29sb3IodiwgY2FudmFzTGlnaHQsIDAuODIpXTtcbiAgfSkpLCAoX2V4dGVuZHMzID0ge30sIF9leHRlbmRzM1tleHBvcnRzLkNvbG9yU3R5bGUuV2hpdGVdID0gJyNmZmZmZmYnLCBfZXh0ZW5kczNbZXhwb3J0cy5Db2xvclN0eWxlLkJsYWNrXSA9ICcjZmZmZmZmJywgX2V4dGVuZHMzKSksXG4gIGRhcms6IC8qI19fUFVSRV9fKi9PYmplY3QuZnJvbUVudHJpZXMoIC8qI19fUFVSRV9fKi9PYmplY3QuZW50cmllcyhjb2xvcnMpLm1hcChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICB2YXIgayA9IF9yZWYzWzBdLFxuICAgICAgICB2ID0gX3JlZjNbMV07XG4gICAgcmV0dXJuIFtrLCBjb3JlLlV0aWxzLmxlcnBDb2xvcih2LCBjYW52YXNEYXJrLCAwLjYxOCldO1xuICB9KSlcbn07XG52YXIgc3Ryb2tlV2lkdGhzID0gKF9zdHJva2VXaWR0aHMgPSB7fSwgX3N0cm9rZVdpZHRoc1tleHBvcnRzLlNpemVTdHlsZS5TbWFsbF0gPSAyLCBfc3Ryb2tlV2lkdGhzW2V4cG9ydHMuU2l6ZVN0eWxlLk1lZGl1bV0gPSA0LCBfc3Ryb2tlV2lkdGhzW2V4cG9ydHMuU2l6ZVN0eWxlLkxhcmdlXSA9IDgsIF9zdHJva2VXaWR0aHMpO1xudmFyIGZvbnRTaXplcyA9IChfZm9udFNpemVzID0ge30sIF9mb250U2l6ZXNbZXhwb3J0cy5TaXplU3R5bGUuU21hbGxdID0gMjQsIF9mb250U2l6ZXNbZXhwb3J0cy5TaXplU3R5bGUuTWVkaXVtXSA9IDQ4LCBfZm9udFNpemVzW2V4cG9ydHMuU2l6ZVN0eWxlLkxhcmdlXSA9IDcyLCBfZm9udFNpemVzLmF1dG8gPSAnYXV0bycsIF9mb250U2l6ZXMpO1xuZnVuY3Rpb24gZ2V0U3Ryb2tlV2lkdGgoc2l6ZSkge1xuICByZXR1cm4gc3Ryb2tlV2lkdGhzW3NpemVdO1xufVxuZnVuY3Rpb24gZ2V0Rm9udFNpemUoc2l6ZSkge1xuICByZXR1cm4gZm9udFNpemVzW3NpemVdO1xufVxuZnVuY3Rpb24gZ2V0Rm9udFN0eWxlKHNjYWxlLCBzdHlsZSkge1xuICB2YXIgZm9udFNpemUgPSBnZXRGb250U2l6ZShzdHlsZS5zaXplKTtcbiAgcmV0dXJuIGZvbnRTaXplICogc2NhbGUgKyBcInB4LzEuNCBWZXJ2ZWluZSBSZWd1bGFyXCI7XG59XG5mdW5jdGlvbiBnZXRTaGFwZVN0eWxlKHN0eWxlLCBpc0RhcmtNb2RlKSB7XG4gIGlmIChpc0RhcmtNb2RlID09PSB2b2lkIDApIHtcbiAgICBpc0RhcmtNb2RlID0gZmFsc2U7XG4gIH1cblxuICB2YXIgY29sb3IgPSBzdHlsZS5jb2xvcixcbiAgICAgIHNpemUgPSBzdHlsZS5zaXplLFxuICAgICAgaXNGaWxsZWQgPSBzdHlsZS5pc0ZpbGxlZDtcbiAgdmFyIHN0cm9rZVdpZHRoID0gZ2V0U3Ryb2tlV2lkdGgoc2l6ZSk7XG4gIHZhciB0aGVtZSA9IGlzRGFya01vZGUgPyAnZGFyaycgOiAnbGlnaHQnO1xuICByZXR1cm4ge1xuICAgIHN0cm9rZTogc3Ryb2tlc1t0aGVtZV1bY29sb3JdLFxuICAgIGZpbGw6IGlzRmlsbGVkID8gZmlsbHNbdGhlbWVdW2NvbG9yXSA6ICdub25lJyxcbiAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGhcbiAgfTtcbn1cbnZhciBkZWZhdWx0U3R5bGUgPSB7XG4gIGNvbG9yOiBleHBvcnRzLkNvbG9yU3R5bGUuQmxhY2ssXG4gIHNpemU6IGV4cG9ydHMuU2l6ZVN0eWxlLk1lZGl1bSxcbiAgaXNGaWxsZWQ6IGZhbHNlLFxuICBkYXNoOiBleHBvcnRzLkRhc2hTdHlsZS5EcmF3XG59O1xuLyoqXHJcbiAqIEdldCBiYWxhbmNlZCBkYXNoLXN0cm9rZWFycmF5IGFuZCBkYXNoLXN0cm9rZW9mZnNldCBwcm9wZXJ0aWVzIGZvciBhIHBhdGggb2YgYSBnaXZlbiBsZW5ndGguXHJcbiAqIEBwYXJhbSBsZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgcGF0aC5cclxuICogQHBhcmFtIHN0cm9rZVdpZHRoIFRoZSBzaGFwZSdzIHN0cm9rZS13aWR0aCBwcm9wZXJ0eS5cclxuICogQHBhcmFtIHN0eWxlIFRoZSBzdHJva2UncyBzdHlsZTogXCJkYXNoZWRcIiBvciBcImRvdHRlZFwiIChkZWZhdWx0IFwiZGFzaGVkXCIpLlxyXG4gKiBAcGFyYW0gc25hcCBBbiBpbnRlcnZhbCBmb3IgZGFzaGVzIChlLmcuIDQgd2lsbCBwcm9kdWNlIGFycmF5cyB3aXRoIDQsIDgsIDE2LCBldGMgZGFzaGVzKS5cclxuICovXG5cbmZ1bmN0aW9uIGdldFBlcmZlY3REYXNoUHJvcHMobGVuZ3RoLCBzdHJva2VXaWR0aCwgc3R5bGUsIHNuYXApIHtcbiAgaWYgKHNuYXAgPT09IHZvaWQgMCkge1xuICAgIHNuYXAgPSAxO1xuICB9XG5cbiAgdmFyIGRhc2hMZW5ndGg7XG4gIHZhciBzdHJva2VEYXNob2Zmc2V0O1xuICB2YXIgcmF0aW87XG5cbiAgaWYgKHN0eWxlID09PSBleHBvcnRzLkRhc2hTdHlsZS5Tb2xpZCB8fCBzdHlsZSA9PT0gZXhwb3J0cy5EYXNoU3R5bGUuRHJhdykge1xuICAgIHJldHVybiB7XG4gICAgICBzdHJva2VEYXNoYXJyYXk6ICdub25lJyxcbiAgICAgIHN0cm9rZURhc2hvZmZzZXQ6ICdub25lJ1xuICAgIH07XG4gIH0gZWxzZSBpZiAoc3R5bGUgPT09IGV4cG9ydHMuRGFzaFN0eWxlLkRhc2hlZCkge1xuICAgIGRhc2hMZW5ndGggPSBzdHJva2VXaWR0aCAqIDI7XG4gICAgcmF0aW8gPSAxO1xuICAgIHN0cm9rZURhc2hvZmZzZXQgPSAoZGFzaExlbmd0aCAvIDIpLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgZGFzaExlbmd0aCA9IHN0cm9rZVdpZHRoIC8gMTAwO1xuICAgIHJhdGlvID0gMTAwO1xuICAgIHN0cm9rZURhc2hvZmZzZXQgPSAnMCc7XG4gIH1cblxuICB2YXIgZGFzaGVzID0gTWF0aC5mbG9vcihsZW5ndGggLyBkYXNoTGVuZ3RoIC8gKDIgKiByYXRpbykpO1xuICBkYXNoZXMgLT0gZGFzaGVzICUgc25hcDtcbiAgaWYgKGRhc2hlcyA9PT0gMCkgZGFzaGVzID0gMTtcbiAgdmFyIGdhcExlbmd0aCA9IChsZW5ndGggLSBkYXNoZXMgKiBkYXNoTGVuZ3RoKSAvIGRhc2hlcztcbiAgcmV0dXJuIHtcbiAgICBzdHJva2VEYXNoYXJyYXk6IFtkYXNoTGVuZ3RoLCBnYXBMZW5ndGhdLmpvaW4oJyAnKSxcbiAgICBzdHJva2VEYXNob2Zmc2V0OiBzdHJva2VEYXNob2Zmc2V0XG4gIH07XG59XG5cbnZhciBSZWN0YW5nbGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9UTERyYXdTaGFwZVV0aWwpIHtcbiAgX2luaGVyaXRzTG9vc2UoUmVjdGFuZ2xlLCBfVExEcmF3U2hhcGVVdGlsKTtcblxuICBmdW5jdGlvbiBSZWN0YW5nbGUoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX1RMRHJhd1NoYXBlVXRpbC5jYWxsLmFwcGx5KF9UTERyYXdTaGFwZVV0aWwsIFt0aGlzXS5jb25jYXQoYXJncykpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IGV4cG9ydHMuVExEcmF3U2hhcGVUeXBlLlJlY3RhbmdsZTtcbiAgICBfdGhpcy50b29sVHlwZSA9IGV4cG9ydHMuVExEcmF3VG9vbFR5cGUuQm91bmRzO1xuICAgIF90aGlzLnBhdGhDYWNoZSA9IG5ldyBXZWFrTWFwKFtdKTtcbiAgICBfdGhpcy5kZWZhdWx0UHJvcHMgPSB7XG4gICAgICBpZDogJ2lkJyxcbiAgICAgIHR5cGU6IGV4cG9ydHMuVExEcmF3U2hhcGVUeXBlLlJlY3RhbmdsZSxcbiAgICAgIG5hbWU6ICdSZWN0YW5nbGUnLFxuICAgICAgcGFyZW50SWQ6ICdwYWdlJyxcbiAgICAgIGNoaWxkSW5kZXg6IDEsXG4gICAgICBwb2ludDogWzAsIDBdLFxuICAgICAgc2l6ZTogWzEsIDFdLFxuICAgICAgcm90YXRpb246IDAsXG4gICAgICByYWRpdXM6IDAsXG4gICAgICBzdHlsZTogZGVmYXVsdFN0eWxlXG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUmVjdGFuZ2xlLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKHNoYXBlLCBfcmVmKSB7XG4gICAgdmFyIGlzQmluZGluZyA9IF9yZWYuaXNCaW5kaW5nLFxuICAgICAgICBpc0hvdmVyZWQgPSBfcmVmLmlzSG92ZXJlZCxcbiAgICAgICAgaXNEYXJrTW9kZSA9IF9yZWYuaXNEYXJrTW9kZTtcbiAgICB2YXIgaWQgPSBzaGFwZS5pZCxcbiAgICAgICAgc2l6ZSA9IHNoYXBlLnNpemUsXG4gICAgICAgIHN0eWxlID0gc2hhcGUuc3R5bGU7XG4gICAgdmFyIHN0eWxlcyA9IGdldFNoYXBlU3R5bGUoc3R5bGUsIGlzRGFya01vZGUpO1xuICAgIHZhciBzdHJva2VXaWR0aCA9ICtzdHlsZXMuc3Ryb2tlV2lkdGg7XG5cbiAgICBpZiAoc3R5bGUuZGFzaCA9PT0gZXhwb3J0cy5EYXNoU3R5bGUuRHJhdykge1xuICAgICAgdmFyIHBhdGhEYXRhID0gY29yZS5VdGlscy5nZXRGcm9tQ2FjaGUodGhpcy5wYXRoQ2FjaGUsIHNoYXBlLnNpemUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlclBhdGgoc2hhcGUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgaXNCaW5kaW5nICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInRsLWJpbmRpbmctaW5kaWNhdG9yXCIsXG4gICAgICAgIHg6IHN0cm9rZVdpZHRoIC8gMiAtIDMyLFxuICAgICAgICB5OiBzdHJva2VXaWR0aCAvIDIgLSAzMixcbiAgICAgICAgd2lkdGg6IE1hdGgubWF4KDAsIHNpemVbMF0gLSBzdHJva2VXaWR0aCAvIDIpICsgNjQsXG4gICAgICAgIGhlaWdodDogTWF0aC5tYXgoMCwgc2l6ZVsxXSAtIHN0cm9rZVdpZHRoIC8gMikgKyA2NFxuICAgICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIsIHtcbiAgICAgICAgeDogK3N0eWxlcy5zdHJva2VXaWR0aCAvIDIsXG4gICAgICAgIHk6ICtzdHlsZXMuc3Ryb2tlV2lkdGggLyAyLFxuICAgICAgICB3aWR0aDogTWF0aC5tYXgoMCwgc2l6ZVswXSAtIHN0cm9rZVdpZHRoKSxcbiAgICAgICAgaGVpZ2h0OiBNYXRoLm1heCgwLCBzaXplWzFdIC0gc3Ryb2tlV2lkdGgpLFxuICAgICAgICBmaWxsOiBzdHlsZS5pc0ZpbGxlZCA/IHN0eWxlcy5maWxsIDogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgc3Ryb2tlOiBcIm5vbmVcIixcbiAgICAgICAgcG9pbnRlckV2ZW50czogXCJhbGxcIlxuICAgICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICAgICAgZDogcGF0aERhdGEsXG4gICAgICAgIGZpbGw6IHN0eWxlcy5zdHJva2UsXG4gICAgICAgIHN0cm9rZTogc3R5bGVzLnN0cm9rZSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHN0eWxlcy5zdHJva2VXaWR0aCxcbiAgICAgICAgZmlsdGVyOiBpc0hvdmVyZWQgPyAndXJsKCNleHBhbmQpJyA6ICdub25lJyxcbiAgICAgICAgcG9pbnRlckV2ZW50czogXCJhbGxcIlxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHZhciBzdyA9IHN0cm9rZVdpZHRoICogMS42MTg7XG4gICAgdmFyIHcgPSBNYXRoLm1heCgwLCBzaXplWzBdIC0gc3cgLyAyKTtcbiAgICB2YXIgaCA9IE1hdGgubWF4KDAsIHNpemVbMV0gLSBzdyAvIDIpO1xuICAgIHZhciBzdHJva2VzID0gW1tbc3cgLyAyLCBzdyAvIDJdLCBbdywgc3cgLyAyXSwgdyAtIHN3IC8gMl0sIFtbdywgc3cgLyAyXSwgW3csIGhdLCBoIC0gc3cgLyAyXSwgW1t3LCBoXSwgW3N3IC8gMiwgaF0sIHcgLSBzdyAvIDJdLCBbW3N3IC8gMiwgaF0sIFtzdyAvIDIsIHN3IC8gMl0sIGggLSBzdyAvIDJdXTtcbiAgICB2YXIgcGF0aHMgPSBzdHJva2VzLm1hcChmdW5jdGlvbiAoX3JlZjIsIGkpIHtcbiAgICAgIHZhciBzdGFydCA9IF9yZWYyWzBdLFxuICAgICAgICAgIGVuZCA9IF9yZWYyWzFdLFxuICAgICAgICAgIGxlbmd0aCA9IF9yZWYyWzJdO1xuXG4gICAgICB2YXIgX2dldFBlcmZlY3REYXNoUHJvcHMgPSBnZXRQZXJmZWN0RGFzaFByb3BzKGxlbmd0aCwgc3csIHNoYXBlLnN0eWxlLmRhc2gpLFxuICAgICAgICAgIHN0cm9rZURhc2hhcnJheSA9IF9nZXRQZXJmZWN0RGFzaFByb3BzLnN0cm9rZURhc2hhcnJheSxcbiAgICAgICAgICBzdHJva2VEYXNob2Zmc2V0ID0gX2dldFBlcmZlY3REYXNoUHJvcHMuc3Ryb2tlRGFzaG9mZnNldDtcblxuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIsIHtcbiAgICAgICAga2V5OiBpZCArICdfJyArIGksXG4gICAgICAgIHgxOiBzdGFydFswXSxcbiAgICAgICAgeTE6IHN0YXJ0WzFdLFxuICAgICAgICB4MjogZW5kWzBdLFxuICAgICAgICB5MjogZW5kWzFdLFxuICAgICAgICBzdHJva2U6IHN0eWxlcy5zdHJva2UsXG4gICAgICAgIHN0cm9rZVdpZHRoOiBzdyxcbiAgICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAgICBzdHJva2VEYXNoYXJyYXk6IHN0cm9rZURhc2hhcnJheSxcbiAgICAgICAgc3Ryb2tlRGFzaG9mZnNldDogc3Ryb2tlRGFzaG9mZnNldFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGlzQmluZGluZyAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7XG4gICAgICBjbGFzc05hbWU6IFwidGwtYmluZGluZy1pbmRpY2F0b3JcIixcbiAgICAgIHg6IHN3IC8gMiAtIDMyLFxuICAgICAgeTogc3cgLyAyIC0gMzIsXG4gICAgICB3aWR0aDogdyArIDY0LFxuICAgICAgaGVpZ2h0OiBoICsgNjRcbiAgICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xuICAgICAgeDogc3cgLyAyLFxuICAgICAgeTogc3cgLyAyLFxuICAgICAgd2lkdGg6IHcsXG4gICAgICBoZWlnaHQ6IGgsXG4gICAgICBmaWxsOiBzdHlsZXMuZmlsbCxcbiAgICAgIHN0cm9rZTogXCJ0cmFuc3BhcmVudFwiLFxuICAgICAgc3Ryb2tlV2lkdGg6IHN3LFxuICAgICAgcG9pbnRlckV2ZW50czogXCJhbGxcIlxuICAgIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7XG4gICAgICBmaWx0ZXI6IGlzSG92ZXJlZCA/ICd1cmwoI2V4cGFuZCknIDogJ25vbmUnLFxuICAgICAgcG9pbnRlckV2ZW50czogXCJzdHJva2VcIlxuICAgIH0sIHBhdGhzKSk7XG4gIH07XG5cbiAgX3Byb3RvLmdldEJvdW5kcyA9IGZ1bmN0aW9uIGdldEJvdW5kcyhzaGFwZSkge1xuICAgIHZhciBib3VuZHMgPSBjb3JlLlV0aWxzLmdldEZyb21DYWNoZSh0aGlzLmJvdW5kc0NhY2hlLCBzaGFwZSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9zaGFwZSRzaXplID0gc2hhcGUuc2l6ZSxcbiAgICAgICAgICB3aWR0aCA9IF9zaGFwZSRzaXplWzBdLFxuICAgICAgICAgIGhlaWdodCA9IF9zaGFwZSRzaXplWzFdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWluWDogMCxcbiAgICAgICAgbWF4WDogd2lkdGgsXG4gICAgICAgIG1pblk6IDAsXG4gICAgICAgIG1heFk6IGhlaWdodCxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29yZS5VdGlscy50cmFuc2xhdGVCb3VuZHMoYm91bmRzLCBzaGFwZS5wb2ludCk7XG4gIH07XG5cbiAgX3Byb3RvLmdldFJvdGF0ZWRCb3VuZHMgPSBmdW5jdGlvbiBnZXRSb3RhdGVkQm91bmRzKHNoYXBlKSB7XG4gICAgcmV0dXJuIGNvcmUuVXRpbHMuZ2V0Qm91bmRzRnJvbVBvaW50cyhjb3JlLlV0aWxzLmdldFJvdGF0ZWRDb3JuZXJzKHRoaXMuZ2V0Qm91bmRzKHNoYXBlKSwgc2hhcGUucm90YXRpb24pKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0Q2VudGVyID0gZnVuY3Rpb24gZ2V0Q2VudGVyKHNoYXBlKSB7XG4gICAgcmV0dXJuIGNvcmUuVXRpbHMuZ2V0Qm91bmRzQ2VudGVyKHRoaXMuZ2V0Qm91bmRzKHNoYXBlKSk7XG4gIH07XG5cbiAgX3Byb3RvLmhpdFRlc3QgPSBmdW5jdGlvbiBoaXRUZXN0KHNoYXBlLCBwb2ludCkge1xuICAgIHJldHVybiBjb3JlLlV0aWxzLnBvaW50SW5Cb3VuZHMocG9pbnQsIHRoaXMuZ2V0Qm91bmRzKHNoYXBlKSk7XG4gIH07XG5cbiAgX3Byb3RvLmhpdFRlc3RCb3VuZHMgPSBmdW5jdGlvbiBoaXRUZXN0Qm91bmRzKHNoYXBlLCBib3VuZHMpIHtcbiAgICB2YXIgcm90YXRlZENvcm5lcnMgPSBjb3JlLlV0aWxzLmdldFJvdGF0ZWRDb3JuZXJzKHRoaXMuZ2V0Qm91bmRzKHNoYXBlKSwgc2hhcGUucm90YXRpb24pO1xuICAgIHJldHVybiByb3RhdGVkQ29ybmVycy5ldmVyeShmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIHJldHVybiBjb3JlLlV0aWxzLnBvaW50SW5Cb3VuZHMocG9pbnQsIGJvdW5kcyk7XG4gICAgfSkgfHwgY29yZS5JbnRlcnNlY3QucG9seWxpbmUuYm91bmRzKHJvdGF0ZWRDb3JuZXJzLCBib3VuZHMpLmxlbmd0aCA+IDA7XG4gIH07XG5cbiAgX3Byb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIHRyYW5zZm9ybShzaGFwZSwgYm91bmRzLCBfcmVmMykge1xuICAgIHZhciBpbml0aWFsU2hhcGUgPSBfcmVmMy5pbml0aWFsU2hhcGUsXG4gICAgICAgIHRyYW5zZm9ybU9yaWdpbiA9IF9yZWYzLnRyYW5zZm9ybU9yaWdpbixcbiAgICAgICAgc2NhbGVYID0gX3JlZjMuc2NhbGVYLFxuICAgICAgICBzY2FsZVkgPSBfcmVmMy5zY2FsZVk7XG5cbiAgICBpZiAoIXNoYXBlLnJvdGF0aW9uICYmICFzaGFwZS5pc0FzcGVjdFJhdGlvTG9ja2VkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb2ludDogY29yZS5WZWMucm91bmQoW2JvdW5kcy5taW5YLCBib3VuZHMubWluWV0pLFxuICAgICAgICBzaXplOiBjb3JlLlZlYy5yb3VuZChbYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0XSlcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzaXplID0gY29yZS5WZWMucm91bmQoY29yZS5WZWMubXVsKGluaXRpYWxTaGFwZS5zaXplLCBNYXRoLm1pbihNYXRoLmFicyhzY2FsZVgpLCBNYXRoLmFicyhzY2FsZVkpKSkpO1xuICAgICAgdmFyIHBvaW50ID0gY29yZS5WZWMucm91bmQoW2JvdW5kcy5taW5YICsgKGJvdW5kcy53aWR0aCAtIHNoYXBlLnNpemVbMF0pICogKHNjYWxlWCA8IDAgPyAxIC0gdHJhbnNmb3JtT3JpZ2luWzBdIDogdHJhbnNmb3JtT3JpZ2luWzBdKSwgYm91bmRzLm1pblkgKyAoYm91bmRzLmhlaWdodCAtIHNoYXBlLnNpemVbMV0pICogKHNjYWxlWSA8IDAgPyAxIC0gdHJhbnNmb3JtT3JpZ2luWzFdIDogdHJhbnNmb3JtT3JpZ2luWzFdKV0pO1xuICAgICAgdmFyIHJvdGF0aW9uID0gc2NhbGVYIDwgMCAmJiBzY2FsZVkgPj0gMCB8fCBzY2FsZVkgPCAwICYmIHNjYWxlWCA+PSAwID8gaW5pdGlhbFNoYXBlLnJvdGF0aW9uID8gLWluaXRpYWxTaGFwZS5yb3RhdGlvbiA6IDAgOiBpbml0aWFsU2hhcGUucm90YXRpb247XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgIHJvdGF0aW9uOiByb3RhdGlvblxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnRyYW5zZm9ybVNpbmdsZSA9IGZ1bmN0aW9uIHRyYW5zZm9ybVNpbmdsZShzaGFwZSwgYm91bmRzLCBpbmZvKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNpemU6IGNvcmUuVmVjLnJvdW5kKFtib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHRdKSxcbiAgICAgIHBvaW50OiBjb3JlLlZlYy5yb3VuZChbYm91bmRzLm1pblgsIGJvdW5kcy5taW5ZXSlcbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBSZWN0YW5nbGU7XG59KFRMRHJhd1NoYXBlVXRpbCk7XG52YXIgcmVjdGFuZ2xlID0gLyojX19QVVJFX18qL25ldyBSZWN0YW5nbGUoKTtcblxuZnVuY3Rpb24gcmVuZGVyUGF0aChzaGFwZSkge1xuICB2YXIgc3R5bGVzID0gZ2V0U2hhcGVTdHlsZShzaGFwZS5zdHlsZSk7XG4gIHZhciBnZXRSYW5kb20gPSBjb3JlLlV0aWxzLnJuZyhzaGFwZS5pZCk7XG4gIHZhciBzdHJva2VXaWR0aCA9ICtzdHlsZXMuc3Ryb2tlV2lkdGg7XG4gIHZhciBiYXNlT2Zmc2V0ID0gc3Ryb2tlV2lkdGggLyAyO1xuICB2YXIgb2Zmc2V0cyA9IEFycmF5LmZyb20oQXJyYXkoNCkpLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFtnZXRSYW5kb20oKSAqIGJhc2VPZmZzZXQsIGdldFJhbmRvbSgpICogYmFzZU9mZnNldF07XG4gIH0pO1xuICB2YXIgc3cgPSBzdHJva2VXaWR0aDtcbiAgdmFyIHcgPSBNYXRoLm1heCgwLCBzaGFwZS5zaXplWzBdIC0gc3cgLyAyKTtcbiAgdmFyIGggPSBNYXRoLm1heCgwLCBzaGFwZS5zaXplWzFdIC0gc3cgLyAyKTtcbiAgdmFyIHRsID0gY29yZS5WZWMuYWRkKFtzdyAvIDIsIHN3IC8gMl0sIG9mZnNldHNbMF0pO1xuICB2YXIgdHIgPSBjb3JlLlZlYy5hZGQoW3csIHN3IC8gMl0sIG9mZnNldHNbMV0pO1xuICB2YXIgYnIgPSBjb3JlLlZlYy5hZGQoW3csIGhdLCBvZmZzZXRzWzJdKTtcbiAgdmFyIGJsID0gY29yZS5WZWMuYWRkKFtzdyAvIDIsIGhdLCBvZmZzZXRzWzNdKTtcbiAgdmFyIGxpbmVzID0gY29yZS5VdGlscy5zaHVmZmxlQXJyKFtjb3JlLlZlYy5wb2ludHNCZXR3ZWVuKHRyLCBiciksIGNvcmUuVmVjLnBvaW50c0JldHdlZW4oYnIsIGJsKSwgY29yZS5WZWMucG9pbnRzQmV0d2VlbihibCwgdGwpLCBjb3JlLlZlYy5wb2ludHNCZXR3ZWVuKHRsLCB0cildLCBNYXRoLmZsb29yKDUgKyBnZXRSYW5kb20oKSAqIDQpKTtcbiAgdmFyIHN0cm9rZSA9IGdldFN0cm9rZV9fZGVmYXVsdChbXS5jb25jYXQobGluZXMuZmxhdCgpLnNsaWNlKDIpLCBsaW5lc1swXSwgbGluZXNbMF0uc2xpY2UoNCkpLCB7XG4gICAgc2l6ZTogMSArICtzdHlsZXMuc3Ryb2tlV2lkdGgsXG4gICAgdGhpbm5pbmc6IDAuNixcbiAgICBlYXNpbmc6IGZ1bmN0aW9uIGVhc2luZyh0KSB7XG4gICAgICByZXR1cm4gdCAqIHQgKiB0ICogdDtcbiAgICB9LFxuICAgIGVuZDoge1xuICAgICAgdGFwZXI6ICtzdHlsZXMuc3Ryb2tlV2lkdGggKiAyMFxuICAgIH0sXG4gICAgc3RhcnQ6IHtcbiAgICAgIHRhcGVyOiArc3R5bGVzLnN0cm9rZVdpZHRoICogMjBcbiAgICB9LFxuICAgIHNpbXVsYXRlUHJlc3N1cmU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gY29yZS5VdGlscy5nZXRTdmdQYXRoRnJvbVN0cm9rZShzdHJva2UpO1xufVxuXG52YXIgRWxsaXBzZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1RMRHJhd1NoYXBlVXRpbCkge1xuICBfaW5oZXJpdHNMb29zZShFbGxpcHNlLCBfVExEcmF3U2hhcGVVdGlsKTtcblxuICBmdW5jdGlvbiBFbGxpcHNlKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9UTERyYXdTaGFwZVV0aWwuY2FsbC5hcHBseShfVExEcmF3U2hhcGVVdGlsLCBbdGhpc10uY29uY2F0KGFyZ3MpKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBleHBvcnRzLlRMRHJhd1NoYXBlVHlwZS5FbGxpcHNlO1xuICAgIF90aGlzLnRvb2xUeXBlID0gZXhwb3J0cy5UTERyYXdUb29sVHlwZS5Cb3VuZHM7XG4gICAgX3RoaXMucGF0aENhY2hlID0gbmV3IFdlYWtNYXAoW10pO1xuICAgIF90aGlzLmRlZmF1bHRQcm9wcyA9IHtcbiAgICAgIGlkOiAnaWQnLFxuICAgICAgdHlwZTogZXhwb3J0cy5UTERyYXdTaGFwZVR5cGUuRWxsaXBzZSxcbiAgICAgIG5hbWU6ICdFbGxpcHNlJyxcbiAgICAgIHBhcmVudElkOiAncGFnZScsXG4gICAgICBjaGlsZEluZGV4OiAxLFxuICAgICAgcG9pbnQ6IFswLCAwXSxcbiAgICAgIHJhZGl1czogWzEsIDFdLFxuICAgICAgcm90YXRpb246IDAsXG4gICAgICBzdHlsZTogZGVmYXVsdFN0eWxlXG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRWxsaXBzZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihzaGFwZSwgX3JlZikge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIGlzRGFya01vZGUgPSBfcmVmLmlzRGFya01vZGUsXG4gICAgICAgIGlzQmluZGluZyA9IF9yZWYuaXNCaW5kaW5nO1xuICAgIHZhciBfc2hhcGUkcmFkaXVzID0gc2hhcGUucmFkaXVzLFxuICAgICAgICByYWRpdXNYID0gX3NoYXBlJHJhZGl1c1swXSxcbiAgICAgICAgcmFkaXVzWSA9IF9zaGFwZSRyYWRpdXNbMV0sXG4gICAgICAgIHN0eWxlID0gc2hhcGUuc3R5bGU7XG4gICAgdmFyIHN0eWxlcyA9IGdldFNoYXBlU3R5bGUoc3R5bGUsIGlzRGFya01vZGUpO1xuICAgIHZhciBzdHJva2VXaWR0aCA9ICtzdHlsZXMuc3Ryb2tlV2lkdGg7XG4gICAgdmFyIHJ4ID0gTWF0aC5tYXgoMCwgcmFkaXVzWCAtIHN0cm9rZVdpZHRoIC8gMik7XG4gICAgdmFyIHJ5ID0gTWF0aC5tYXgoMCwgcmFkaXVzWSAtIHN0cm9rZVdpZHRoIC8gMik7XG5cbiAgICBpZiAoc3R5bGUuZGFzaCA9PT0gZXhwb3J0cy5EYXNoU3R5bGUuRHJhdykge1xuICAgICAgdmFyIHBhdGggPSBjb3JlLlV0aWxzLmdldEZyb21DYWNoZSh0aGlzLnBhdGhDYWNoZSwgc2hhcGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlclBhdGgkMShzaGFwZSwgX3RoaXMyLmdldENlbnRlcihzaGFwZSkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgaXNCaW5kaW5nICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJlbGxpcHNlXCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInRsLWJpbmRpbmctaW5kaWNhdG9yXCIsXG4gICAgICAgIGN4OiByYWRpdXNYLFxuICAgICAgICBjeTogcmFkaXVzWSxcbiAgICAgICAgcng6IHJ4ICsgMixcbiAgICAgICAgcnk6IHJ5ICsgMlxuICAgICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJlbGxpcHNlXCIsIHtcbiAgICAgICAgY3g6IHJhZGl1c1gsXG4gICAgICAgIGN5OiByYWRpdXNZLFxuICAgICAgICByeDogcngsXG4gICAgICAgIHJ5OiByeSxcbiAgICAgICAgc3Ryb2tlOiBcIm5vbmVcIixcbiAgICAgICAgZmlsbDogc3R5bGUuaXNGaWxsZWQgPyBzdHlsZXMuZmlsbCA6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgIHBvaW50ZXJFdmVudHM6IFwiYWxsXCJcbiAgICAgIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgICAgIGQ6IHBhdGgsXG4gICAgICAgIGZpbGw6IHN0eWxlcy5zdHJva2UsXG4gICAgICAgIHN0cm9rZTogc3R5bGVzLnN0cm9rZSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiBcImFsbFwiLFxuICAgICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgICAgIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCJcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICB2YXIgaCA9IE1hdGgucG93KHJ4IC0gcnksIDIpIC8gTWF0aC5wb3cocnggKyByeSwgMik7XG4gICAgdmFyIHBlcmltZXRlciA9IE1hdGguUEkgKiAocnggKyByeSkgKiAoMSArIDMgKiBoIC8gKDEwICsgTWF0aC5zcXJ0KDQgLSAzICogaCkpKTtcblxuICAgIHZhciBfZ2V0UGVyZmVjdERhc2hQcm9wcyA9IGdldFBlcmZlY3REYXNoUHJvcHMocGVyaW1ldGVyLCBzdHJva2VXaWR0aCAqIDEuNjE4LCBzaGFwZS5zdHlsZS5kYXNoLCA0KSxcbiAgICAgICAgc3Ryb2tlRGFzaGFycmF5ID0gX2dldFBlcmZlY3REYXNoUHJvcHMuc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgICBzdHJva2VEYXNob2Zmc2V0ID0gX2dldFBlcmZlY3REYXNoUHJvcHMuc3Ryb2tlRGFzaG9mZnNldDtcblxuICAgIHZhciBzdyA9IHN0cm9rZVdpZHRoICogMS42MTg7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGlzQmluZGluZyAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZWxsaXBzZVwiLCB7XG4gICAgICBjbGFzc05hbWU6IFwidGwtYmluZGluZy1pbmRpY2F0b3JcIixcbiAgICAgIGN4OiByYWRpdXNYLFxuICAgICAgY3k6IHJhZGl1c1ksXG4gICAgICByeDogcnggKyAzMixcbiAgICAgIHJ5OiByeSArIDMyXG4gICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJlbGxpcHNlXCIsIHtcbiAgICAgIGN4OiByYWRpdXNYLFxuICAgICAgY3k6IHJhZGl1c1ksXG4gICAgICByeDogcngsXG4gICAgICByeTogcnksXG4gICAgICBmaWxsOiBzdHlsZXMuZmlsbCxcbiAgICAgIHN0cm9rZTogc3R5bGVzLnN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoOiBzdyxcbiAgICAgIHN0cm9rZURhc2hhcnJheTogc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgc3Ryb2tlRGFzaG9mZnNldDogc3Ryb2tlRGFzaG9mZnNldCxcbiAgICAgIHBvaW50ZXJFdmVudHM6IFwiYWxsXCIsXG4gICAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiXG4gICAgfSkpO1xuICB9O1xuXG4gIF9wcm90by5nZXRCb3VuZHMgPSBmdW5jdGlvbiBnZXRCb3VuZHMoc2hhcGUpIHtcbiAgICByZXR1cm4gY29yZS5VdGlscy5nZXRGcm9tQ2FjaGUodGhpcy5ib3VuZHNDYWNoZSwgc2hhcGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjb3JlLlV0aWxzLmdldFJvdGF0ZWRFbGxpcHNlQm91bmRzKHNoYXBlLnBvaW50WzBdLCBzaGFwZS5wb2ludFsxXSwgc2hhcGUucmFkaXVzWzBdLCBzaGFwZS5yYWRpdXNbMV0sIHNoYXBlLnJvdGF0aW9uIHx8IDApO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5nZXRSb3RhdGVkQm91bmRzID0gZnVuY3Rpb24gZ2V0Um90YXRlZEJvdW5kcyhzaGFwZSkge1xuICAgIHJldHVybiBjb3JlLlV0aWxzLmdldEJvdW5kc0Zyb21Qb2ludHMoY29yZS5VdGlscy5nZXRSb3RhdGVkQ29ybmVycyh0aGlzLmdldEJvdW5kcyhzaGFwZSksIHNoYXBlLnJvdGF0aW9uKSk7XG4gIH07XG5cbiAgX3Byb3RvLmdldENlbnRlciA9IGZ1bmN0aW9uIGdldENlbnRlcihzaGFwZSkge1xuICAgIHJldHVybiBjb3JlLlV0aWxzLmdldEJvdW5kc0NlbnRlcih0aGlzLmdldEJvdW5kcyhzaGFwZSkpO1xuICB9O1xuXG4gIF9wcm90by5oaXRUZXN0ID0gZnVuY3Rpb24gaGl0VGVzdChzaGFwZSwgcG9pbnQpIHtcbiAgICByZXR1cm4gY29yZS5VdGlscy5wb2ludEluQm91bmRzKHBvaW50LCB0aGlzLmdldEJvdW5kcyhzaGFwZSkpO1xuICB9O1xuXG4gIF9wcm90by5oaXRUZXN0Qm91bmRzID0gZnVuY3Rpb24gaGl0VGVzdEJvdW5kcyhzaGFwZSwgYm91bmRzKSB7XG4gICAgdmFyIHJvdGF0ZWRDb3JuZXJzID0gY29yZS5VdGlscy5nZXRSb3RhdGVkQ29ybmVycyh0aGlzLmdldEJvdW5kcyhzaGFwZSksIHNoYXBlLnJvdGF0aW9uKTtcbiAgICByZXR1cm4gcm90YXRlZENvcm5lcnMuZXZlcnkoZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICByZXR1cm4gY29yZS5VdGlscy5wb2ludEluQm91bmRzKHBvaW50LCBib3VuZHMpO1xuICAgIH0pIHx8IGNvcmUuSW50ZXJzZWN0LnBvbHlsaW5lLmJvdW5kcyhyb3RhdGVkQ29ybmVycywgYm91bmRzKS5sZW5ndGggPiAwO1xuICB9O1xuXG4gIF9wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbiB0cmFuc2Zvcm0oc2hhcGUsIGJvdW5kcywgX3JlZjIpIHtcbiAgICB2YXIgc2NhbGVYID0gX3JlZjIuc2NhbGVYLFxuICAgICAgICBzY2FsZVkgPSBfcmVmMi5zY2FsZVksXG4gICAgICAgIGluaXRpYWxTaGFwZSA9IF9yZWYyLmluaXRpYWxTaGFwZTtcbiAgICB2YXIgX2luaXRpYWxTaGFwZSRyb3RhdGlvID0gaW5pdGlhbFNoYXBlLnJvdGF0aW9uLFxuICAgICAgICByb3RhdGlvbiA9IF9pbml0aWFsU2hhcGUkcm90YXRpbyA9PT0gdm9pZCAwID8gMCA6IF9pbml0aWFsU2hhcGUkcm90YXRpbztcbiAgICByZXR1cm4ge1xuICAgICAgcG9pbnQ6IFtib3VuZHMubWluWCwgYm91bmRzLm1pblldLFxuICAgICAgcmFkaXVzOiBbYm91bmRzLndpZHRoIC8gMiwgYm91bmRzLmhlaWdodCAvIDJdLFxuICAgICAgcm90YXRpb246IHNjYWxlWCA8IDAgJiYgc2NhbGVZID49IDAgfHwgc2NhbGVZIDwgMCAmJiBzY2FsZVggPj0gMCA/IC0ocm90YXRpb24gfHwgMCkgOiByb3RhdGlvbiB8fCAwXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8udHJhbnNmb3JtU2luZ2xlID0gZnVuY3Rpb24gdHJhbnNmb3JtU2luZ2xlKHNoYXBlLCBib3VuZHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcG9pbnQ6IGNvcmUuVmVjLnJvdW5kKFtib3VuZHMubWluWCwgYm91bmRzLm1pblldKSxcbiAgICAgIHJhZGl1czogY29yZS5WZWMuZGl2KFtib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHRdLCAyKVxuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIEVsbGlwc2U7XG59KFRMRHJhd1NoYXBlVXRpbCk7XG52YXIgZWxsaXBzZSA9IC8qI19fUFVSRV9fKi9uZXcgRWxsaXBzZSgpO1xuXG5mdW5jdGlvbiByZW5kZXJQYXRoJDEoc2hhcGUsIGJvdW5kc0NlbnRlcikge1xuICB2YXIgc3R5bGUgPSBzaGFwZS5zdHlsZSxcbiAgICAgIGlkID0gc2hhcGUuaWQsXG4gICAgICBfc2hhcGUkcmFkaXVzMiA9IHNoYXBlLnJhZGl1cyxcbiAgICAgIHJhZGl1c1ggPSBfc2hhcGUkcmFkaXVzMlswXSxcbiAgICAgIHJhZGl1c1kgPSBfc2hhcGUkcmFkaXVzMlsxXSxcbiAgICAgIHBvaW50ID0gc2hhcGUucG9pbnQ7XG4gIHZhciBnZXRSYW5kb20gPSBjb3JlLlV0aWxzLnJuZyhpZCk7XG4gIHZhciBjZW50ZXIgPSBjb3JlLlZlYy5zdWIoYm91bmRzQ2VudGVyLCBwb2ludCk7XG4gIHZhciBzdHJva2VXaWR0aCA9ICtnZXRTaGFwZVN0eWxlKHN0eWxlKS5zdHJva2VXaWR0aDtcbiAgdmFyIHJ4ID0gcmFkaXVzWCArIGdldFJhbmRvbSgpICogc3Ryb2tlV2lkdGggLSBzdHJva2VXaWR0aCAvIDI7XG4gIHZhciByeSA9IHJhZGl1c1kgKyBnZXRSYW5kb20oKSAqIHN0cm9rZVdpZHRoIC0gc3Ryb2tlV2lkdGggLyAyO1xuICB2YXIgcG9pbnRzID0gW107XG4gIHZhciBzdGFydCA9IE1hdGguUEkgKyBNYXRoLlBJICogZ2V0UmFuZG9tKCk7XG4gIHZhciBvdmVybGFwID0gTWF0aC5QSSAvIDEyO1xuXG4gIGZvciAodmFyIGkgPSAyOyBpIDwgODsgaSsrKSB7XG4gICAgdmFyIHJhZHMgPSBzdGFydCArIG92ZXJsYXAgKiAyICogKGkgLyA4KTtcbiAgICB2YXIgeCA9IHJ4ICogTWF0aC5jb3MocmFkcykgKyBjZW50ZXJbMF07XG4gICAgdmFyIHkgPSByeSAqIE1hdGguc2luKHJhZHMpICsgY2VudGVyWzFdO1xuICAgIHBvaW50cy5wdXNoKFt4LCB5XSk7XG4gIH1cblxuICBmb3IgKHZhciBfaSA9IDU7IF9pIDwgMzI7IF9pKyspIHtcbiAgICB2YXIgdCA9IF9pIC8gMzU7XG5cbiAgICB2YXIgX3JhZHMgPSBzdGFydCArIG92ZXJsYXAgKiAyICsgTWF0aC5QSSAqIDIuNSAqICh0ICogdCAqIHQpO1xuXG4gICAgdmFyIF94ID0gcnggKiBNYXRoLmNvcyhfcmFkcykgKyBjZW50ZXJbMF07XG5cbiAgICB2YXIgX3kgPSByeSAqIE1hdGguc2luKF9yYWRzKSArIGNlbnRlclsxXTtcblxuICAgIHBvaW50cy5wdXNoKFtfeCwgX3ldKTtcbiAgfVxuXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IDg7IF9pMisrKSB7XG4gICAgdmFyIF9yYWRzMiA9IHN0YXJ0ICsgb3ZlcmxhcCAqIDIgKiAoX2kyIC8gNCk7XG5cbiAgICB2YXIgX3gyID0gcnggKiBNYXRoLmNvcyhfcmFkczIpICsgY2VudGVyWzBdO1xuXG4gICAgdmFyIF95MiA9IHJ5ICogTWF0aC5zaW4oX3JhZHMyKSArIGNlbnRlclsxXTtcblxuICAgIHBvaW50cy5wdXNoKFtfeDIsIF95Ml0pO1xuICB9XG5cbiAgdmFyIHN0cm9rZSA9IGdldFN0cm9rZV9fZGVmYXVsdChwb2ludHMsIHtcbiAgICBzaXplOiAxICsgc3Ryb2tlV2lkdGgsXG4gICAgdGhpbm5pbmc6IDAuNixcbiAgICBlYXNpbmc6IGZ1bmN0aW9uIGVhc2luZyh0KSB7XG4gICAgICByZXR1cm4gdCAqIHQgKiB0ICogdDtcbiAgICB9LFxuICAgIGVuZDoge1xuICAgICAgdGFwZXI6IHN0cm9rZVdpZHRoICogMjBcbiAgICB9LFxuICAgIHN0YXJ0OiB7XG4gICAgICB0YXBlcjogc3Ryb2tlV2lkdGggKiAyMFxuICAgIH0sXG4gICAgc2ltdWxhdGVQcmVzc3VyZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBjb3JlLlV0aWxzLmdldFN2Z1BhdGhGcm9tU3Ryb2tlKHN0cm9rZSk7XG59XG5cbnZhciBEcmF3ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVExEcmF3U2hhcGVVdGlsKSB7XG4gIF9pbmhlcml0c0xvb3NlKERyYXcsIF9UTERyYXdTaGFwZVV0aWwpO1xuXG4gIGZ1bmN0aW9uIERyYXcoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX1RMRHJhd1NoYXBlVXRpbC5jYWxsLmFwcGx5KF9UTERyYXdTaGFwZVV0aWwsIFt0aGlzXS5jb25jYXQoYXJncykpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IGV4cG9ydHMuVExEcmF3U2hhcGVUeXBlLkRyYXc7XG4gICAgX3RoaXMudG9vbFR5cGUgPSBleHBvcnRzLlRMRHJhd1Rvb2xUeXBlLkRyYXc7XG4gICAgX3RoaXMucG9pbnRzQm91bmRzQ2FjaGUgPSBuZXcgV2Vha01hcChbXSk7XG4gICAgX3RoaXMucm90YXRlZENhY2hlID0gbmV3IFdlYWtNYXAoW10pO1xuICAgIF90aGlzLmRyYXdQYXRoQ2FjaGUgPSBuZXcgV2Vha01hcChbXSk7XG4gICAgX3RoaXMuc2ltcGxlUGF0aENhY2hlID0gbmV3IFdlYWtNYXAoW10pO1xuICAgIF90aGlzLnBvbHlnb25DYWNoZSA9IG5ldyBXZWFrTWFwKFtdKTtcbiAgICBfdGhpcy5kZWZhdWx0UHJvcHMgPSB7XG4gICAgICBpZDogJ2lkJyxcbiAgICAgIHR5cGU6IGV4cG9ydHMuVExEcmF3U2hhcGVUeXBlLkRyYXcsXG4gICAgICBuYW1lOiAnRHJhdycsXG4gICAgICBwYXJlbnRJZDogJ3BhZ2UnLFxuICAgICAgY2hpbGRJbmRleDogMSxcbiAgICAgIHBvaW50OiBbMCwgMF0sXG4gICAgICBwb2ludHM6IFtbMCwgMCwgMC41XV0sXG4gICAgICByb3RhdGlvbjogMCxcbiAgICAgIHJhZGl1czogMCxcbiAgICAgIHN0eWxlOiBkZWZhdWx0U3R5bGVcbiAgICB9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBEcmF3LnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKHNoYXBlLCBfcmVmKSB7XG4gICAgdmFyIF9EYXNoU3R5bGUkRHJhdyREYXNoUywgX0Rhc2hTdHlsZSREcmF3JERhc2hTMjtcblxuICAgIHZhciBpc0hvdmVyZWQgPSBfcmVmLmlzSG92ZXJlZCxcbiAgICAgICAgaXNEYXJrTW9kZSA9IF9yZWYuaXNEYXJrTW9kZTtcbiAgICB2YXIgcG9pbnRzID0gc2hhcGUucG9pbnRzLFxuICAgICAgICBzdHlsZSA9IHNoYXBlLnN0eWxlO1xuICAgIHZhciBzdHlsZXMgPSBnZXRTaGFwZVN0eWxlKHN0eWxlLCBpc0RhcmtNb2RlKTtcbiAgICB2YXIgc3Ryb2tlV2lkdGggPSArc3R5bGVzLnN0cm9rZVdpZHRoO1xuICAgIHZhciBzaG91bGRGaWxsID0gc3R5bGUuaXNGaWxsZWQgJiYgcG9pbnRzLmxlbmd0aCA+IDMgJiYgY29yZS5WZWMuZGlzdChwb2ludHNbMF0sIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0pIDwgK3N0eWxlcy5zdHJva2VXaWR0aCAqIDI7IC8vIEZvciB2ZXJ5IHNob3J0IGxpbmVzLCBkcmF3IGEgcG9pbnQgaW5zdGVhZCBvZiBhIGxpbmVcblxuICAgIGlmIChwb2ludHMubGVuZ3RoID4gMCAmJiBwb2ludHMubGVuZ3RoIDwgMykge1xuICAgICAgdmFyIF9zdyA9IHN0cm9rZVdpZHRoICogMC42MTg7XG5cbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIsIHtcbiAgICAgICAgcjogc3Ryb2tlV2lkdGggKiAwLjYxOCxcbiAgICAgICAgZmlsbDogc3R5bGVzLnN0cm9rZSxcbiAgICAgICAgc3Ryb2tlOiBzdHlsZXMuc3Ryb2tlLFxuICAgICAgICBzdHJva2VXaWR0aDogX3N3LFxuICAgICAgICBwb2ludGVyRXZlbnRzOiBcImFsbFwiLFxuICAgICAgICBmaWx0ZXI6IGlzSG92ZXJlZCA/ICd1cmwoI2V4cGFuZCknIDogJ25vbmUnXG4gICAgICB9KTtcbiAgICB9IC8vIEZvciBkcmF3biBsaW5lcywgZHJhdyBhIGxpbmUgZnJvbSB0aGUgcGF0aCBjYWNoZVxuXG5cbiAgICBpZiAoc2hhcGUuc3R5bGUuZGFzaCA9PT0gZXhwb3J0cy5EYXNoU3R5bGUuRHJhdykge1xuICAgICAgdmFyIHBvbHlnb25QYXRoRGF0YSA9IGNvcmUuVXRpbHMuZ2V0RnJvbUNhY2hlKHRoaXMucG9seWdvbkNhY2hlLCBwb2ludHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGdldEZpbGxQYXRoKHNoYXBlKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGRyYXdQYXRoRGF0YSA9IGNvcmUuVXRpbHMuZ2V0RnJvbUNhY2hlKHRoaXMuZHJhd1BhdGhDYWNoZSwgcG9pbnRzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBnZXREcmF3U3Ryb2tlUGF0aChzaGFwZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBzaG91bGRGaWxsICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICAgICAgZDogcG9seWdvblBhdGhEYXRhLFxuICAgICAgICBzdHJva2U6IFwibm9uZVwiLFxuICAgICAgICBmaWxsOiBzdHlsZXMuZmlsbCxcbiAgICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIixcbiAgICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiBcImZpbGxcIlxuICAgICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICAgICAgZDogZHJhd1BhdGhEYXRhLFxuICAgICAgICBmaWxsOiBzdHlsZXMuc3Ryb2tlLFxuICAgICAgICBzdHJva2U6IHN0eWxlcy5zdHJva2UsXG4gICAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIixcbiAgICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiBcImFsbFwiLFxuICAgICAgICBmaWx0ZXI6IGlzSG92ZXJlZCA/ICd1cmwoI2V4cGFuZCknIDogJ25vbmUnXG4gICAgICB9KSk7XG4gICAgfSAvLyBGb3Igc29saWQsIGRhc2ggYW5kIGRvdHRlZCBsaW5lcywgZHJhdyBhIHJlZ3VsYXIgc3Ryb2tlIHBhdGhcblxuXG4gICAgdmFyIHN0cm9rZURhc2hhcnJheSA9IChfRGFzaFN0eWxlJERyYXckRGFzaFMgPSB7fSwgX0Rhc2hTdHlsZSREcmF3JERhc2hTW2V4cG9ydHMuRGFzaFN0eWxlLkRyYXddID0gJ25vbmUnLCBfRGFzaFN0eWxlJERyYXckRGFzaFNbZXhwb3J0cy5EYXNoU3R5bGUuU29saWRdID0gXCJub25lXCIsIF9EYXNoU3R5bGUkRHJhdyREYXNoU1tleHBvcnRzLkRhc2hTdHlsZS5Eb3R0ZWRdID0gc3Ryb2tlV2lkdGggLyAxMCArIFwiIFwiICsgc3Ryb2tlV2lkdGggKiAzLCBfRGFzaFN0eWxlJERyYXckRGFzaFNbZXhwb3J0cy5EYXNoU3R5bGUuRGFzaGVkXSA9IHN0cm9rZVdpZHRoICogMyArIFwiIFwiICsgc3Ryb2tlV2lkdGggKiAzLCBfRGFzaFN0eWxlJERyYXckRGFzaFMpW3N0eWxlLmRhc2hdO1xuICAgIHZhciBzdHJva2VEYXNob2Zmc2V0ID0gKF9EYXNoU3R5bGUkRHJhdyREYXNoUzIgPSB7fSwgX0Rhc2hTdHlsZSREcmF3JERhc2hTMltleHBvcnRzLkRhc2hTdHlsZS5EcmF3XSA9ICdub25lJywgX0Rhc2hTdHlsZSREcmF3JERhc2hTMltleHBvcnRzLkRhc2hTdHlsZS5Tb2xpZF0gPSBcIm5vbmVcIiwgX0Rhc2hTdHlsZSREcmF3JERhc2hTMltleHBvcnRzLkRhc2hTdHlsZS5Eb3R0ZWRdID0gXCItXCIgKyBzdHJva2VXaWR0aCAvIDIwLCBfRGFzaFN0eWxlJERyYXckRGFzaFMyW2V4cG9ydHMuRGFzaFN0eWxlLkRhc2hlZF0gPSBcIi1cIiArIHN0cm9rZVdpZHRoLCBfRGFzaFN0eWxlJERyYXckRGFzaFMyKVtzdHlsZS5kYXNoXTtcbiAgICB2YXIgcGF0aCA9IGNvcmUuVXRpbHMuZ2V0RnJvbUNhY2hlKHRoaXMuc2ltcGxlUGF0aENhY2hlLCBwb2ludHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBnZXRTb2xpZFN0cm9rZVBhdGgoc2hhcGUpO1xuICAgIH0pO1xuICAgIHZhciBzdyA9IHN0cm9rZVdpZHRoICogMS42MTg7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICAgIGQ6IHBhdGgsXG4gICAgICBmaWxsOiBzaG91bGRGaWxsID8gc3R5bGVzLmZpbGwgOiAnbm9uZScsXG4gICAgICBzdHJva2U6IFwidHJhbnNwYXJlbnRcIixcbiAgICAgIHN0cm9rZVdpZHRoOiBNYXRoLm1pbig0LCBzdHJva2VXaWR0aCAqIDIpLFxuICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIixcbiAgICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgICAgIHBvaW50ZXJFdmVudHM6IHNob3VsZEZpbGwgPyAnYWxsJyA6ICdzdHJva2UnXG4gICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICAgIGQ6IHBhdGgsXG4gICAgICBmaWxsOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICBzdHJva2U6IHN0eWxlcy5zdHJva2UsXG4gICAgICBzdHJva2VXaWR0aDogc3csXG4gICAgICBzdHJva2VEYXNoYXJyYXk6IHN0cm9rZURhc2hhcnJheSxcbiAgICAgIHN0cm9rZURhc2hvZmZzZXQ6IHN0cm9rZURhc2hvZmZzZXQsXG4gICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLFxuICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAgcG9pbnRlckV2ZW50czogXCJzdHJva2VcIixcbiAgICAgIGZpbHRlcjogaXNIb3ZlcmVkID8gJ3VybCgjZXhwYW5kKScgOiAnbm9uZSdcbiAgICB9KSk7XG4gIH07XG5cbiAgX3Byb3RvLmdldEJvdW5kcyA9IGZ1bmN0aW9uIGdldEJvdW5kcyhzaGFwZSkge1xuICAgIHJldHVybiBjb3JlLlV0aWxzLnRyYW5zbGF0ZUJvdW5kcyhjb3JlLlV0aWxzLmdldEZyb21DYWNoZSh0aGlzLnBvaW50c0JvdW5kc0NhY2hlLCBzaGFwZS5wb2ludHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjb3JlLlV0aWxzLmdldEJvdW5kc0Zyb21Qb2ludHMoc2hhcGUucG9pbnRzKTtcbiAgICB9KSwgc2hhcGUucG9pbnQpO1xuICB9O1xuXG4gIF9wcm90by5nZXRSb3RhdGVkQm91bmRzID0gZnVuY3Rpb24gZ2V0Um90YXRlZEJvdW5kcyhzaGFwZSkge1xuICAgIHJldHVybiBjb3JlLlV0aWxzLnRyYW5zbGF0ZUJvdW5kcyhjb3JlLlV0aWxzLmdldEJvdW5kc0Zyb21Qb2ludHMoc2hhcGUucG9pbnRzLCBzaGFwZS5yb3RhdGlvbiksIHNoYXBlLnBvaW50KTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0Q2VudGVyID0gZnVuY3Rpb24gZ2V0Q2VudGVyKHNoYXBlKSB7XG4gICAgcmV0dXJuIGNvcmUuVXRpbHMuZ2V0Qm91bmRzQ2VudGVyKHRoaXMuZ2V0Qm91bmRzKHNoYXBlKSk7XG4gIH07XG5cbiAgX3Byb3RvLmhpdFRlc3QgPSBmdW5jdGlvbiBoaXRUZXN0KHNoYXBlLCBwb2ludCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9wcm90by5oaXRUZXN0Qm91bmRzID0gZnVuY3Rpb24gaGl0VGVzdEJvdW5kcyhzaGFwZSwgYnJ1c2hCb3VuZHMpIHtcbiAgICAvLyBUZXN0IGF4aXMtYWxpZ25lZCBzaGFwZVxuICAgIGlmICghc2hhcGUucm90YXRpb24pIHtcbiAgICAgIHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kcyhzaGFwZSk7XG4gICAgICByZXR1cm4gY29yZS5VdGlscy5ib3VuZHNDb250YWluKGJydXNoQm91bmRzLCBib3VuZHMpIHx8IChjb3JlLlV0aWxzLmJvdW5kc0NvbnRhaW4oYm91bmRzLCBicnVzaEJvdW5kcykgfHwgY29yZS5JbnRlcnNlY3QuYm91bmRzLmJvdW5kcyhib3VuZHMsIGJydXNoQm91bmRzKS5sZW5ndGggPiAwKSAmJiBjb3JlLkludGVyc2VjdC5wb2x5bGluZS5ib3VuZHMoc2hhcGUucG9pbnRzLCBjb3JlLlV0aWxzLnRyYW5zbGF0ZUJvdW5kcyhicnVzaEJvdW5kcywgY29yZS5WZWMubmVnKHNoYXBlLnBvaW50KSkpLmxlbmd0aCA+IDA7XG4gICAgfSAvLyBUZXN0IHJvdGF0ZWQgc2hhcGVcblxuXG4gICAgdmFyIHJCb3VuZHMgPSB0aGlzLmdldFJvdGF0ZWRCb3VuZHMoc2hhcGUpO1xuICAgIHZhciByb3RhdGVkQm91bmRzID0gY29yZS5VdGlscy5nZXRGcm9tQ2FjaGUodGhpcy5yb3RhdGVkQ2FjaGUsIHNoYXBlLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYyA9IGNvcmUuVXRpbHMuZ2V0Qm91bmRzQ2VudGVyKGNvcmUuVXRpbHMuZ2V0Qm91bmRzRnJvbVBvaW50cyhzaGFwZS5wb2ludHMpKTtcbiAgICAgIHJldHVybiBzaGFwZS5wb2ludHMubWFwKGZ1bmN0aW9uIChwdCkge1xuICAgICAgICByZXR1cm4gY29yZS5WZWMucm90V2l0aChwdCwgYywgc2hhcGUucm90YXRpb24gfHwgMCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29yZS5VdGlscy5ib3VuZHNDb250YWluKGJydXNoQm91bmRzLCByQm91bmRzKSB8fCBjb3JlLkludGVyc2VjdC5ib3VuZHMucG9seWxpbmUoY29yZS5VdGlscy50cmFuc2xhdGVCb3VuZHMoYnJ1c2hCb3VuZHMsIGNvcmUuVmVjLm5lZyhzaGFwZS5wb2ludCkpLCByb3RhdGVkQm91bmRzKS5sZW5ndGggPiAwO1xuICB9O1xuXG4gIF9wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbiB0cmFuc2Zvcm0oc2hhcGUsIGJvdW5kcywgX3JlZjIpIHtcbiAgICB2YXIgaW5pdGlhbFNoYXBlID0gX3JlZjIuaW5pdGlhbFNoYXBlLFxuICAgICAgICBzY2FsZVggPSBfcmVmMi5zY2FsZVgsXG4gICAgICAgIHNjYWxlWSA9IF9yZWYyLnNjYWxlWTtcbiAgICB2YXIgaW5pdGlhbFNoYXBlQm91bmRzID0gY29yZS5VdGlscy5nZXRGcm9tQ2FjaGUodGhpcy5ib3VuZHNDYWNoZSwgaW5pdGlhbFNoYXBlLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gY29yZS5VdGlscy5nZXRCb3VuZHNGcm9tUG9pbnRzKGluaXRpYWxTaGFwZS5wb2ludHMpO1xuICAgIH0pO1xuICAgIHZhciBwb2ludHMgPSBpbml0aWFsU2hhcGUucG9pbnRzLm1hcChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgIHZhciB4ID0gX3JlZjNbMF0sXG4gICAgICAgICAgeSA9IF9yZWYzWzFdLFxuICAgICAgICAgIHIgPSBfcmVmM1syXTtcbiAgICAgIHJldHVybiBbYm91bmRzLndpZHRoICogKHNjYWxlWCA8IDAgLy8gKiBzaW4/XG4gICAgICA/IDEgLSB4IC8gaW5pdGlhbFNoYXBlQm91bmRzLndpZHRoIDogeCAvIGluaXRpYWxTaGFwZUJvdW5kcy53aWR0aCksIGJvdW5kcy5oZWlnaHQgKiAoc2NhbGVZIDwgMCAvLyAqIGNvcz9cbiAgICAgID8gMSAtIHkgLyBpbml0aWFsU2hhcGVCb3VuZHMuaGVpZ2h0IDogeSAvIGluaXRpYWxTaGFwZUJvdW5kcy5oZWlnaHQpLCByXTtcbiAgICB9KTtcbiAgICB2YXIgbmV3Qm91bmRzID0gY29yZS5VdGlscy5nZXRCb3VuZHNGcm9tUG9pbnRzKHNoYXBlLnBvaW50cyk7XG4gICAgdmFyIHBvaW50ID0gY29yZS5WZWMuc3ViKFtib3VuZHMubWluWCwgYm91bmRzLm1pblldLCBbbmV3Qm91bmRzLm1pblgsIG5ld0JvdW5kcy5taW5ZXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvaW50czogcG9pbnRzLFxuICAgICAgcG9pbnQ6IHBvaW50XG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8udHJhbnNmb3JtU2luZ2xlID0gZnVuY3Rpb24gdHJhbnNmb3JtU2luZ2xlKHNoYXBlLCBib3VuZHMsIGluZm8pIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oc2hhcGUsIGJvdW5kcywgaW5mbyk7XG4gIH07XG5cbiAgX3Byb3RvLm9uU2Vzc2lvbkNvbXBsZXRlID0gZnVuY3Rpb24gb25TZXNzaW9uQ29tcGxldGUoc2hhcGUpIHtcbiAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoc2hhcGUpO1xuXG4gICAgdmFyIF9WZWMkc3ViID0gY29yZS5WZWMuc3ViKFtib3VuZHMubWluWCwgYm91bmRzLm1pblldLCBzaGFwZS5wb2ludCksXG4gICAgICAgIHgxID0gX1ZlYyRzdWJbMF0sXG4gICAgICAgIHkxID0gX1ZlYyRzdWJbMV07XG5cbiAgICByZXR1cm4ge1xuICAgICAgcG9pbnRzOiBzaGFwZS5wb2ludHMubWFwKGZ1bmN0aW9uIChfcmVmNCkge1xuICAgICAgICB2YXIgeDAgPSBfcmVmNFswXSxcbiAgICAgICAgICAgIHkwID0gX3JlZjRbMV0sXG4gICAgICAgICAgICBwID0gX3JlZjRbMl07XG4gICAgICAgIHJldHVybiBbeDAgLSB4MSwgeTAgLSB5MSwgcF07XG4gICAgICB9KSxcbiAgICAgIHBvaW50OiBjb3JlLlZlYy5hZGQoc2hhcGUucG9pbnQsIFt4MSwgeTFdKVxuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIERyYXc7XG59KFRMRHJhd1NoYXBlVXRpbCk7XG52YXIgZHJhdyA9IC8qI19fUFVSRV9fKi9uZXcgRHJhdygpO1xudmFyIHNpbXVsYXRlUHJlc3N1cmVTZXR0aW5ncyA9IHtcbiAgc2ltdWxhdGVQcmVzc3VyZTogdHJ1ZVxufTtcbnZhciByZWFsUHJlc3N1cmVTZXR0aW5ncyA9IHtcbiAgZWFzaW5nOiBmdW5jdGlvbiBlYXNpbmcodCkge1xuICAgIHJldHVybiB0ICogdDtcbiAgfSxcbiAgc2ltdWxhdGVQcmVzc3VyZTogZmFsc2UsXG4gIHN0YXJ0OiB7XG4gICAgdGFwZXI6IDFcbiAgfSxcbiAgZW5kOiB7XG4gICAgdGFwZXI6IDFcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0RmlsbFBhdGgoc2hhcGUpIHtcbiAgdmFyIHN0eWxlcyA9IGdldFNoYXBlU3R5bGUoc2hhcGUuc3R5bGUpO1xuXG4gIGlmIChzaGFwZS5wb2ludHMubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHJldHVybiBjb3JlLlV0aWxzLmdldFN2Z1BhdGhGcm9tU3Ryb2tlKGdldFN0cm9rZS5nZXRTdHJva2VQb2ludHMoc2hhcGUucG9pbnRzLCB7XG4gICAgc2l6ZTogMSArICtzdHlsZXMuc3Ryb2tlV2lkdGggKiAyLFxuICAgIHRoaW5uaW5nOiAwLjg1LFxuICAgIGVuZDoge1xuICAgICAgdGFwZXI6ICtzdHlsZXMuc3Ryb2tlV2lkdGggKiAyMFxuICAgIH0sXG4gICAgc3RhcnQ6IHtcbiAgICAgIHRhcGVyOiArc3R5bGVzLnN0cm9rZVdpZHRoICogMjBcbiAgICB9XG4gIH0pLm1hcChmdW5jdGlvbiAocHQpIHtcbiAgICByZXR1cm4gcHQucG9pbnQ7XG4gIH0pKTtcbn1cblxuZnVuY3Rpb24gZ2V0RHJhd1N0cm9rZVBhdGgoc2hhcGUpIHtcbiAgdmFyIHN0eWxlcyA9IGdldFNoYXBlU3R5bGUoc2hhcGUuc3R5bGUpO1xuXG4gIGlmIChzaGFwZS5wb2ludHMubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciBvcHRpb25zID0gc2hhcGUucG9pbnRzWzFdWzJdID09PSAwLjUgPyBzaW11bGF0ZVByZXNzdXJlU2V0dGluZ3MgOiByZWFsUHJlc3N1cmVTZXR0aW5ncztcbiAgdmFyIHN0cm9rZSA9IGdldFN0cm9rZV9fZGVmYXVsdChzaGFwZS5wb2ludHMsIF9leHRlbmRzKHtcbiAgICBzaXplOiAxICsgK3N0eWxlcy5zdHJva2VXaWR0aCAqIDIsXG4gICAgdGhpbm5pbmc6IDAuODUsXG4gICAgZW5kOiB7XG4gICAgICB0YXBlcjogK3N0eWxlcy5zdHJva2VXaWR0aCAqIDEwXG4gICAgfSxcbiAgICBzdGFydDoge1xuICAgICAgdGFwZXI6ICtzdHlsZXMuc3Ryb2tlV2lkdGggKiAxMFxuICAgIH1cbiAgfSwgb3B0aW9ucykpO1xuICByZXR1cm4gY29yZS5VdGlscy5nZXRTdmdQYXRoRnJvbVN0cm9rZShzdHJva2UpO1xufVxuXG5mdW5jdGlvbiBnZXRTb2xpZFN0cm9rZVBhdGgoc2hhcGUpIHtcbiAgdmFyIHBvaW50cyA9IHNoYXBlLnBvaW50cztcbiAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XG4gIGlmIChsZW4gPT09IDApIHJldHVybiAnTSAwIDAgTCAwIDAnO1xuICBpZiAobGVuIDwgMykgcmV0dXJuIFwiTSBcIiArIHBvaW50c1swXVswXSArIFwiIFwiICsgcG9pbnRzWzBdWzFdO1xuICBwb2ludHMgPSBnZXRTdHJva2UuZ2V0U3Ryb2tlUG9pbnRzKHBvaW50cykubWFwKGZ1bmN0aW9uIChwdCkge1xuICAgIHJldHVybiBwdC5wb2ludDtcbiAgfSk7XG4gIGxlbiA9IHBvaW50cy5sZW5ndGg7XG4gIHZhciBkID0gcG9pbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBfcmVmNSwgaSwgYXJyKSB7XG4gICAgdmFyIHgwID0gX3JlZjVbMF0sXG4gICAgICAgIHkwID0gX3JlZjVbMV07XG5cbiAgICBpZiAoaSA9PT0gbGVuIC0gMSkge1xuICAgICAgYWNjLnB1c2goJ0wnLCB4MCwgeTApO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG5cbiAgICB2YXIgX2FyciA9IGFycltpICsgMV0sXG4gICAgICAgIHgxID0gX2FyclswXSxcbiAgICAgICAgeTEgPSBfYXJyWzFdO1xuICAgIGFjYy5wdXNoKHgwLnRvRml4ZWQoMiksIHkwLnRvRml4ZWQoMiksICgoeDAgKyB4MSkgLyAyKS50b0ZpeGVkKDIpLCAoKHkwICsgeTEpIC8gMikudG9GaXhlZCgyKSk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgWydNJywgcG9pbnRzWzBdWzBdLCBwb2ludHNbMF1bMV0sICdRJ10pO1xuICB2YXIgcGF0aCA9IGQuam9pbignICcpLnJlcGxhY2VBbGwoLyhcXHNbMC05XSpcXC5bMC05XXsyfSkoWzAtOV0qKVxcYi9nLCAnJDEnKTtcbiAgcmV0dXJuIHBhdGg7XG59XG5cbnZhciB0bGRyYXdTaGFwZVV0aWxzID0ge1xuICByZWN0YW5nbGU6IHJlY3RhbmdsZSxcbiAgZWxsaXBzZTogZWxsaXBzZSxcbiAgZHJhdzogZHJhd1xufTtcbmZ1bmN0aW9uIGdldFNoYXBlVXRpbHMoc2hhcGUpIHtcbiAgcmV0dXJuIHRsZHJhd1NoYXBlVXRpbHNbc2hhcGUudHlwZV07XG59XG5mdW5jdGlvbiBjcmVhdGVTaGFwZSh0eXBlLCBwcm9wcykge1xuICByZXR1cm4gdGxkcmF3U2hhcGVVdGlsc1t0eXBlXS5jcmVhdGUocHJvcHMpO1xufVxuXG5mdW5jdGlvbiB1c2VLZXlib2FyZFNob3J0Y3V0cyh0bHN0YXRlKSB7XG4gIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhbmRsZUtleURvd24gPSBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGUpIHtcbiAgICAgIHZhciBpbmZvID0gY29yZS5pbnB1dHMua2V5ZG93bihlKTtcbiAgICAgIHRsc3RhdGUub25LZXlEb3duKGUua2V5LCBpbmZvKTtcbiAgICB9O1xuXG4gICAgdmFyIGhhbmRsZUtleVVwID0gZnVuY3Rpb24gaGFuZGxlS2V5VXAoZSkge1xuICAgICAgdmFyIGluZm8gPSBjb3JlLmlucHV0cy5rZXl1cChlKTtcbiAgICAgIHRsc3RhdGUub25LZXlVcChlLmtleSwgaW5mbyk7XG4gICAgfTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlS2V5RG93bik7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgaGFuZGxlS2V5VXApO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZUtleURvd24pO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgaGFuZGxlS2V5VXApO1xuICAgIH07XG4gIH0sIFt0bHN0YXRlXSk7XG4gIHJlYWN0SG90a2V5c0hvb2sudXNlSG90a2V5cygnY29tbWFuZCt6JywgZnVuY3Rpb24gKGUpIHtcbiAgICB0bHN0YXRlLnVuZG8oKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xuICByZWFjdEhvdGtleXNIb29rLnVzZUhvdGtleXMoJ2N0cmwrc2hpZnQteixjb21tYW5kK3NoaWZ0K3onLCBmdW5jdGlvbiAoZSkge1xuICAgIHRsc3RhdGUucmVkbygpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG4gIHJlYWN0SG90a2V5c0hvb2sudXNlSG90a2V5cygnY3RybCtkLGNvbW1hbmQrZCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgdGxzdGF0ZS5kdXBsaWNhdGUoKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xuICByZWFjdEhvdGtleXNIb29rLnVzZUhvdGtleXMoJ2N0cmwrcyxjb21tYW5kK3MnLCBmdW5jdGlvbiAoZSkge1xuICAgIHRsc3RhdGUuc2F2ZSgpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG4gIHJlYWN0SG90a2V5c0hvb2sudXNlSG90a2V5cygnY3RybCs9LGNvbW1hbmQrPScsIGZ1bmN0aW9uIChlKSB7XG4gICAgdGxzdGF0ZS56b29tSW4oKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xuICByZWFjdEhvdGtleXNIb29rLnVzZUhvdGtleXMoJ2N0cmwrLSxjb21tYW5kKy0nLCBmdW5jdGlvbiAoZSkge1xuICAgIHRsc3RhdGUuem9vbU91dCgpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG4gIHJlYWN0SG90a2V5c0hvb2sudXNlSG90a2V5cygnc2hpZnQrMScsIGZ1bmN0aW9uIChlKSB7XG4gICAgdGxzdGF0ZS56b29tVG9GaXQoKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xuICByZWFjdEhvdGtleXNIb29rLnVzZUhvdGtleXMoJ3NoaWZ0KzInLCBmdW5jdGlvbiAoZSkge1xuICAgIHRsc3RhdGUuem9vbVRvU2VsZWN0aW9uKCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9KTtcbiAgcmVhY3RIb3RrZXlzSG9vay51c2VIb3RrZXlzKCdzaGlmdCswJywgZnVuY3Rpb24gKGUpIHtcbiAgICB0bHN0YXRlLnpvb21Ub0FjdHVhbCgpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG4gIHJlYWN0SG90a2V5c0hvb2sudXNlSG90a2V5cygnZXNjYXBlJywgZnVuY3Rpb24gKGUpIHtcbiAgICB0bHN0YXRlLmNhbmNlbCgpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG4gIHJlYWN0SG90a2V5c0hvb2sudXNlSG90a2V5cygnYmFja3NwYWNlJywgZnVuY3Rpb24gKGUpIHtcbiAgICB0bHN0YXRlW1wiZGVsZXRlXCJdKCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9KTtcbiAgcmVhY3RIb3RrZXlzSG9vay51c2VIb3RrZXlzKCdjb21tYW5kK2EsY3RybCthJywgZnVuY3Rpb24gKGUpIHtcbiAgICB0bHN0YXRlLnNlbGVjdEFsbCgpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG4gIHJlYWN0SG90a2V5c0hvb2sudXNlSG90a2V5cygndXAnLCBmdW5jdGlvbiAoZSkge1xuICAgIHRsc3RhdGUubnVkZ2UoWzAsIC0xXSwgZmFsc2UpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG4gIHJlYWN0SG90a2V5c0hvb2sudXNlSG90a2V5cygncmlnaHQnLCBmdW5jdGlvbiAoZSkge1xuICAgIHRsc3RhdGUubnVkZ2UoWzEsIDBdLCBmYWxzZSk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9KTtcbiAgcmVhY3RIb3RrZXlzSG9vay51c2VIb3RrZXlzKCdkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICB0bHN0YXRlLm51ZGdlKFswLCAxXSwgZmFsc2UpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG4gIHJlYWN0SG90a2V5c0hvb2sudXNlSG90a2V5cygnbGVmdCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgdGxzdGF0ZS5udWRnZShbLTEsIDBdLCBmYWxzZSk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9KTtcbiAgcmVhY3RIb3RrZXlzSG9vay51c2VIb3RrZXlzKCdzaGlmdCt1cCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgdGxzdGF0ZS5udWRnZShbMCwgLTFdLCB0cnVlKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xuICByZWFjdEhvdGtleXNIb29rLnVzZUhvdGtleXMoJ3NoaWZ0K3JpZ2h0JywgZnVuY3Rpb24gKGUpIHtcbiAgICB0bHN0YXRlLm51ZGdlKFsxLCAwXSwgdHJ1ZSk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9KTtcbiAgcmVhY3RIb3RrZXlzSG9vay51c2VIb3RrZXlzKCdzaGlmdCtkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICB0bHN0YXRlLm51ZGdlKFswLCAxXSwgdHJ1ZSk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9KTtcbiAgcmVhY3RIb3RrZXlzSG9vay51c2VIb3RrZXlzKCdzaGlmdCtsZWZ0JywgZnVuY3Rpb24gKGUpIHtcbiAgICB0bHN0YXRlLm51ZGdlKFstMSwgMF0sIHRydWUpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG4gIHJlYWN0SG90a2V5c0hvb2sudXNlSG90a2V5cygnWycsIGZ1bmN0aW9uIChlKSB7XG4gICAgdGxzdGF0ZS5tb3ZlQmFja3dhcmQoKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xuICByZWFjdEhvdGtleXNIb29rLnVzZUhvdGtleXMoJ10nLCBmdW5jdGlvbiAoZSkge1xuICAgIHRsc3RhdGUubW92ZUZvcndhcmQoKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xuICByZWFjdEhvdGtleXNIb29rLnVzZUhvdGtleXMoJ3NoaWZ0K1snLCBmdW5jdGlvbiAoZSkge1xuICAgIHRsc3RhdGUubW92ZVRvQmFjaygpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG4gIHJlYWN0SG90a2V5c0hvb2sudXNlSG90a2V5cygnc2hpZnQrXScsIGZ1bmN0aW9uIChlKSB7XG4gICAgdGxzdGF0ZS5tb3ZlVG9Gcm9udCgpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG4gIHJlYWN0SG90a2V5c0hvb2sudXNlSG90a2V5cygndiwxJywgZnVuY3Rpb24gKGUpIHtcbiAgICB0bHN0YXRlLnNlbGVjdFRvb2woJ3NlbGVjdCcpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG4gIHJlYWN0SG90a2V5c0hvb2sudXNlSG90a2V5cygnZCwyJywgZnVuY3Rpb24gKGUpIHtcbiAgICB0bHN0YXRlLnNlbGVjdFRvb2woZXhwb3J0cy5UTERyYXdTaGFwZVR5cGUuRHJhdyk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9KTtcbiAgcmVhY3RIb3RrZXlzSG9vay51c2VIb3RrZXlzKCdyLDMnLCBmdW5jdGlvbiAoZSkge1xuICAgIHRsc3RhdGUuc2VsZWN0VG9vbChleHBvcnRzLlRMRHJhd1NoYXBlVHlwZS5SZWN0YW5nbGUpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG4gIHJlYWN0SG90a2V5c0hvb2sudXNlSG90a2V5cygnZSw0JywgZnVuY3Rpb24gKGUpIHtcbiAgICB0bHN0YXRlLnNlbGVjdFRvb2woZXhwb3J0cy5UTERyYXdTaGFwZVR5cGUuRWxsaXBzZSk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9KTtcbn1cblxudmFyIFRMRHJhd0NvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh7fSk7XG5mdW5jdGlvbiB1c2VUTERyYXdDb250ZXh0KCkge1xuICB2YXIgY29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoVExEcmF3Q29udGV4dCk7XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiB1c2VUaGVtZSgpIHtcbiAgcmV0dXJuIHtcbiAgICB0aGVtZTogJ2xpZ2h0JyxcbiAgICB0b2dnbGU6IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIF9jcmVhdGVDc3MgPSAvKiNfX1BVUkVfXyovcmVhY3QuY3JlYXRlQ3NzKHtcbiAgdGhlbWVNYXA6IC8qI19fUFVSRV9fKi9fZXh0ZW5kcyh7fSwgcmVhY3QuZGVmYXVsdFRoZW1lTWFwKSxcbiAgdGhlbWU6IHtcbiAgICBjb2xvcnM6IHtcbiAgICAgIGNvZGVIbDogJ3JnYmEoMTQ0LCAxNDQsIDE0NCwgLjE1KScsXG4gICAgICBicnVzaEZpbGw6ICdyZ2JhKDAsMCwwLC4wNSknLFxuICAgICAgYnJ1c2hTdHJva2U6ICdyZ2JhKDAsMCwwLC4yNSknLFxuICAgICAgaGludDogJ3JnYmEoMjE2LCAyMjYsIDI0OSwgMS4wMDApJyxcbiAgICAgIHNlbGVjdGVkOiAncmdiYSg2NiwgMTMzLCAyNDQsIDEuMDAwKScsXG4gICAgICBib3VuZHM6ICdyZ2JhKDY1LCAxMzIsIDI0NCwgMS4wMDApJyxcbiAgICAgIGJvdW5kc0JnOiAncmdiYSg2NSwgMTMyLCAyNDQsIDAuMDUpJyxcbiAgICAgIGhpZ2hsaWdodDogJ3JnYmEoNjUsIDEzMiwgMjQ0LCAwLjE1KScsXG4gICAgICBvdmVybGF5OiAncmdiYSgwLCAwLCAwLCAwLjE1KScsXG4gICAgICBvdmVybGF5Q29udHJhc3Q6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTUpJyxcbiAgICAgIGJvcmRlcjogJyNhYWFhYWEnLFxuICAgICAgY2FudmFzOiAnI2Y4ZjlmYScsXG4gICAgICBwYW5lbDogJyNmZWZlZmUnLFxuICAgICAgaW5hY3RpdmU6ICcjY2NjY2NmJyxcbiAgICAgIGhvdmVyOiAnI2VmZWZlZicsXG4gICAgICB0ZXh0OiAnIzMzMzMzMycsXG4gICAgICB0b29sdGlwQmc6ICcjMWQxZDFkJyxcbiAgICAgIHRvb2x0aXBUZXh0OiAnI2ZmZmZmZicsXG4gICAgICBtdXRlZDogJyM3Nzc3NzcnLFxuICAgICAgaW5wdXQ6ICcjZjNmM2YzJyxcbiAgICAgIGlucHV0Qm9yZGVyOiAnI2RkZGRkZCcsXG4gICAgICB3YXJuOiAncmdiYSgyNTUsIDEwMCwgMTAwLCAxKScsXG4gICAgICBsaW5lRXJyb3I6ICdyZ2JhKDI1NSwgMCwgMCwgLjEpJ1xuICAgIH0sXG4gICAgc2hhZG93czoge1xuICAgICAgMjogJzBweCAxcHggMXB4IHJnYmEoMCwgMCwgMCwgMC4xNCknLFxuICAgICAgMzogJzBweCAycHggM3B4IHJnYmEoMCwgMCwgMCwgMC4xNCknLFxuICAgICAgNDogJzBweCA0cHggNXB4IC0xcHggcmdiYSgwLCAwLCAwLCAwLjE0KScsXG4gICAgICA4OiAnMHB4IDEycHggMTdweCByZ2JhKDAsIDAsIDAsIDAuMTQpJyxcbiAgICAgIDEyOiAnMHB4IDEycHggMTdweCByZ2JhKDAsIDAsIDAsIDAuMTQpJyxcbiAgICAgIDI0OiAnMHB4IDI0cHggMzhweCByZ2JhKDAsIDAsIDAsIDAuMTQpJyxcbiAgICAgIGtleTogJzFweCAxcHggcmdiYSgwLDAsMCwxKSdcbiAgICB9LFxuICAgIHNwYWNlOiB7XG4gICAgICAwOiAnMnB4JyxcbiAgICAgIDE6ICczcHgnLFxuICAgICAgMjogJzRweCcsXG4gICAgICAzOiAnOHB4JyxcbiAgICAgIDQ6ICcxMnB4JyxcbiAgICAgIDU6ICcxNnB4J1xuICAgIH0sXG4gICAgZm9udFNpemVzOiB7XG4gICAgICAwOiAnMTBweCcsXG4gICAgICAxOiAnMTJweCcsXG4gICAgICAyOiAnMTNweCcsXG4gICAgICAzOiAnMTZweCcsXG4gICAgICA0OiAnMThweCdcbiAgICB9LFxuICAgIGZvbnRzOiB7XG4gICAgICB1aTogJ1wiUmVjdXJzaXZlXCIsIHN5c3RlbS11aSwgc2Fucy1zZXJpZicsXG4gICAgICBib2R5OiAnXCJSZWN1cnNpdmVcIiwgc3lzdGVtLXVpLCBzYW5zLXNlcmlmJyxcbiAgICAgIG1vbm86ICdcIlJlY3Vyc2l2ZSBNb25vXCIsIG1vbm9zcGFjZSdcbiAgICB9LFxuICAgIGZvbnRXZWlnaHRzOiB7fSxcbiAgICBsaW5lSGVpZ2h0czoge30sXG4gICAgbGV0dGVyU3BhY2luZ3M6IHt9LFxuICAgIHNpemVzOiB7fSxcbiAgICBib3JkZXJXaWR0aHM6IHtcbiAgICAgIDA6ICckMSdcbiAgICB9LFxuICAgIGJvcmRlclN0eWxlczoge30sXG4gICAgcmFkaWk6IHtcbiAgICAgIDA6ICcycHgnLFxuICAgICAgMTogJzRweCcsXG4gICAgICAyOiAnOHB4J1xuICAgIH0sXG4gICAgekluZGljZXM6IHt9LFxuICAgIHRyYW5zaXRpb25zOiB7fVxuICB9LFxuICBtZWRpYToge1xuICAgIHNtOiAnKG1pbi13aWR0aDogNjQwcHgpJyxcbiAgICBtZDogJyhtaW4td2lkdGg6IDc2OHB4KSdcbiAgfSxcbiAgdXRpbHM6IHtcbiAgICB6RGFzaDogZnVuY3Rpb24gekRhc2goKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiBcImNhbGMoXCIgKyB2YWx1ZSArIFwicHggLyB2YXIoLS1jYW1lcmEtem9vbSkpIGNhbGMoXCIgKyB2YWx1ZSArIFwicHggLyB2YXIoLS1jYW1lcmEtem9vbSkpXCJcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfSxcbiAgICB6U3Ryb2tlV2lkdGg6IGZ1bmN0aW9uIHpTdHJva2VXaWR0aCgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBcImNhbGMoXCIgKyB2YWx1ZVswXSArIFwicHggLyB2YXIoLS1jYW1lcmEtem9vbSkpXCJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdHJva2VXaWR0aDogXCJjYWxjKFwiICsgdmFsdWUgKyBcInB4IC8gdmFyKC0tY2FtZXJhLXpvb20pKVwiXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH1cbiAgfVxufSksXG4gICAgc3R5bGVkID0gX2NyZWF0ZUNzcy5zdHlsZWQ7XG5cbmZ1bmN0aW9uIGNvbW1hbmRLZXkoKSB7XG4gIHJldHVybiBjb3JlLlV0aWxzLmlzRGFyd2luKCkgPyAn4oyYJyA6ICdDdHJsJztcbn1cbmZ1bmN0aW9uIEtiZChfcmVmKSB7XG4gIHZhciB2YXJpYW50ID0gX3JlZi52YXJpYW50LFxuICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuO1xuICBpZiAoY29yZS5VdGlscy5pc01vYmlsZSgpKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU3R5bGVkS2JkLCB7XG4gICAgdmFyaWFudDogdmFyaWFudFxuICB9LCBjaGlsZHJlbi5yZXBsYWNlQWxsKCcjJywgY29tbWFuZEtleSgpKS5zcGxpdCgnJykubWFwKGZ1bmN0aW9uIChrLCBpKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgIGtleTogaVxuICAgIH0sIGspO1xuICB9KSk7XG59XG52YXIgU3R5bGVkS2JkID0gLyojX19QVVJFX18qL3N0eWxlZCgna2JkJywge1xuICBtYXJnaW5MZWZ0OiAnJDMnLFxuICB0ZXh0U2hhZG93OiAnJDInLFxuICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICBmb250U2l6ZTogJyQwJyxcbiAgZm9udEZhbWlseTogJyR1aScsXG4gIGZvbnRXZWlnaHQ6IDQwMCxcbiAgZ2FwOiAnJDEnLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAnJiA+IHNwYW4nOiB7XG4gICAgcGFkZGluZzogJyQwJyxcbiAgICBib3JkZXJSYWRpdXM6ICckMCcsXG4gICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJ1xuICB9LFxuICB2YXJpYW50czoge1xuICAgIHZhcmlhbnQ6IHtcbiAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgJyYgPiBzcGFuJzoge1xuICAgICAgICAgIGJhY2tncm91bmQ6ICckb3ZlcmxheUNvbnRyYXN0JyxcbiAgICAgICAgICBib3hTaGFkb3c6ICcka2V5JyxcbiAgICAgICAgICB3aWR0aDogJzIwcHgnLFxuICAgICAgICAgIGhlaWdodDogJzIwcHgnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtZW51OiB7fVxuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIFRvb2x0aXAoX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgbGFiZWwgPSBfcmVmLmxhYmVsLFxuICAgICAga2JkID0gX3JlZi5rYmQsXG4gICAgICBfcmVmJHNpZGUgPSBfcmVmLnNpZGUsXG4gICAgICBzaWRlID0gX3JlZiRzaWRlID09PSB2b2lkIDAgPyAndG9wJyA6IF9yZWYkc2lkZTtcbiAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmFkaXhUb29sdGlwLlJvb3QsIG51bGwsIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmFkaXhUb29sdGlwLlRyaWdnZXIsIHtcbiAgICBhczogXCJzcGFuXCJcbiAgfSwgY2hpbGRyZW4pLCBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFN0eWxlZENvbnRlbnQsIHtcbiAgICBzaWRlOiBzaWRlLFxuICAgIHNpZGVPZmZzZXQ6IDhcbiAgfSwgbGFiZWwsIGtiZCA/IFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoS2JkLCB7XG4gICAgdmFyaWFudDogXCJ0b29sdGlwXCJcbiAgfSwga2JkKSA6IG51bGwsIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3R5bGVkQXJyb3csIG51bGwpKSk7XG59XG52YXIgU3R5bGVkQ29udGVudCA9IC8qI19fUFVSRV9fKi9zdHlsZWQoUmFkaXhUb29sdGlwLkNvbnRlbnQsIHtcbiAgYm9yZGVyUmFkaXVzOiAzLFxuICBwYWRkaW5nOiAnJDMgJDMgJDMgJDMnLFxuICBmb250U2l6ZTogJyQxJyxcbiAgYmFja2dyb3VuZENvbG9yOiAnJHRvb2x0aXBCZycsXG4gIGNvbG9yOiAnJHRvb2x0aXBUZXh0JyxcbiAgYm94U2hhZG93OiAnJDMnLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICBmb250RmFtaWx5OiAnJHVpJ1xufSk7XG52YXIgU3R5bGVkQXJyb3cgPSAvKiNfX1BVUkVfXyovc3R5bGVkKFJhZGl4VG9vbHRpcC5BcnJvdywge1xuICBmaWxsOiAnJHRvb2x0aXBCZycsXG4gIG1hcmdpbjogJzAgOHB4J1xufSk7XG5cbnZhciBfZXhjbHVkZWQgPSBbXCJzaXplXCJdO1xuXG52YXIgX3BhZ2VCdXR0b247XG52YXIgYnJlYWtwb2ludHMgPSB7XG4gICdAaW5pdGlhbCc6ICdtb2JpbGUnLFxuICAnQHNtJzogJ3NtYWxsJ1xufTtcbnZhciBJY29uQnV0dG9uID0gLyojX19QVVJFX18qL3N0eWxlZCgnYnV0dG9uJywge1xuICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgaGVpZ2h0OiAnMzJweCcsXG4gIHdpZHRoOiAnMzJweCcsXG4gIGJhY2tncm91bmRDb2xvcjogJyRwYW5lbCcsXG4gIGJvcmRlclJhZGl1czogJzRweCcsXG4gIHBhZGRpbmc6ICcwJyxcbiAgbWFyZ2luOiAnMCcsXG4gIGRpc3BsYXk6ICdncmlkJyxcbiAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcbiAgb3V0bGluZTogJ25vbmUnLFxuICBib3JkZXI6ICdub25lJyxcbiAgcG9pbnRlckV2ZW50czogJ2FsbCcsXG4gIGZvbnRTaXplOiAnJDAnLFxuICBjb2xvcjogJyR0ZXh0JyxcbiAgY3Vyc29yOiAncG9pbnRlcicsXG4gICcmID4gKic6IHtcbiAgICBncmlkUm93OiAxLFxuICAgIGdyaWRDb2x1bW46IDFcbiAgfSxcbiAgJyY6ZGlzYWJsZWQnOiB7XG4gICAgb3BhY2l0eTogJzAuNSdcbiAgfSxcbiAgJyYgPiBzcGFuJzoge1xuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgIGFsaWduSXRlbXM6ICdjZW50ZXInXG4gIH0sXG4gIHZhcmlhbnRzOiB7XG4gICAgYnA6IHtcbiAgICAgIG1vYmlsZToge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCdcbiAgICAgIH0sXG4gICAgICBzbWFsbDoge1xuICAgICAgICAnJjpob3Zlcjpub3QoOmRpc2FibGVkKSc6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICckaG92ZXInXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHNpemU6IHtcbiAgICAgIHNtYWxsOiB7XG4gICAgICAgIGhlaWdodDogMzIsXG4gICAgICAgIHdpZHRoOiAzMixcbiAgICAgICAgJyYgc3ZnOm50aC1vZi10eXBlKDEpJzoge1xuICAgICAgICAgIGhlaWdodDogJzE2cHgnLFxuICAgICAgICAgIHdpZHRoOiAnMTZweCdcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1lZGl1bToge1xuICAgICAgICBoZWlnaHQ6IDQ0LFxuICAgICAgICB3aWR0aDogNDQsXG4gICAgICAgICcmIHN2ZzpudGgtb2YtdHlwZSgxKSc6IHtcbiAgICAgICAgICBoZWlnaHQ6ICcxOHB4JyxcbiAgICAgICAgICB3aWR0aDogJzE4cHgnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBsYXJnZToge1xuICAgICAgICBoZWlnaHQ6IDQ0LFxuICAgICAgICB3aWR0aDogNDQsXG4gICAgICAgICcmIHN2ZzpudGgtb2YtdHlwZSgxKSc6IHtcbiAgICAgICAgICBoZWlnaHQ6ICcyMHB4JyxcbiAgICAgICAgICB3aWR0aDogJzIwcHgnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGlzQWN0aXZlOiB7XG4gICAgICBcInRydWVcIjoge1xuICAgICAgICBjb2xvcjogJyRzZWxlY3RlZCdcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xudmFyIFJvd0J1dHRvbiA9IC8qI19fUFVSRV9fKi9zdHlsZWQoJ2J1dHRvbicsIHtcbiAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gIGRpc3BsYXk6ICdmbGV4JyxcbiAgd2lkdGg6ICcxMDAlJyxcbiAgYmFja2dyb3VuZDogJ25vbmUnLFxuICBoZWlnaHQ6ICczMnB4JyxcbiAgYm9yZGVyOiAnbm9uZScsXG4gIGN1cnNvcjogJ3BvaW50ZXInLFxuICBjb2xvcjogJyR0ZXh0JyxcbiAgb3V0bGluZTogJ25vbmUnLFxuICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgZm9udEZhbWlseTogJyR1aScsXG4gIGZvbnRXZWlnaHQ6IDQwMCxcbiAgZm9udFNpemU6ICckMScsXG4gIGp1c3RpZnlDb250ZW50OiAnc3BhY2UtYmV0d2VlbicsXG4gIHBhZGRpbmc6ICc0cHggOHB4IDRweCAxMnB4JyxcbiAgYm9yZGVyUmFkaXVzOiA0LFxuICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICcmIGxhYmVsJzoge1xuICAgIGZvbnRXZWlnaHQ6ICckMScsXG4gICAgbWFyZ2luOiAwLFxuICAgIHBhZGRpbmc6IDBcbiAgfSxcbiAgJyYgc3ZnJzoge1xuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgIHN0cm9rZTogJyRvdmVybGF5JyxcbiAgICBzdHJva2VXaWR0aDogMSxcbiAgICB6SW5kZXg6IDFcbiAgfSxcbiAgJyZbZGF0YS1kaXNhYmxlZF0nOiB7XG4gICAgb3BhY2l0eTogMC4zXG4gIH0sXG4gICcmOmRpc2FibGVkJzoge1xuICAgIG9wYWNpdHk6IDAuM1xuICB9LFxuICB2YXJpYW50czoge1xuICAgIGJwOiB7XG4gICAgICBtb2JpbGU6IHt9LFxuICAgICAgc21hbGw6IHtcbiAgICAgICAgJyYgKltkYXRhLXNoeT1cInRydWVcIl0nOiB7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LFxuICAgICAgICAnJjpob3Zlcjpub3QoOmRpc2FibGVkKSc6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICckaG92ZXInLFxuICAgICAgICAgICcmICpbZGF0YS1zaHk9XCJ0cnVlXCJdJzoge1xuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgc2l6ZToge1xuICAgICAgaWNvbjoge1xuICAgICAgICBwYWRkaW5nOiAnNHB4ICcsXG4gICAgICAgIHdpZHRoOiAnYXV0bydcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhcmlhbnQ6IHtcbiAgICAgIG5vSWNvbjoge1xuICAgICAgICBwYWRkaW5nOiAnNHB4IDEycHgnXG4gICAgICB9LFxuICAgICAgcGFnZUJ1dHRvbjogKF9wYWdlQnV0dG9uID0ge1xuICAgICAgICBkaXNwbGF5OiAnZ3JpZCcsXG4gICAgICAgIGdyaWRUZW1wbGF0ZUNvbHVtbnM6ICcyNHB4IGF1dG8nLFxuICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICBwYWRkaW5nTGVmdDogJyQxJyxcbiAgICAgICAgZ2FwOiAnJDMnLFxuICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2ZsZXgtc3RhcnQnXG4gICAgICB9LCBfcGFnZUJ1dHRvbltcIiYgPiAqW2RhdGEtc3RhdGU9XFxcImNoZWNrZWRcXFwiXVwiXSA9IHtcbiAgICAgICAgZ3JpZFJvdzogMSxcbiAgICAgICAgZ3JpZENvbHVtbjogMVxuICAgICAgfSwgX3BhZ2VCdXR0b25bJyYgPiBzcGFuJ10gPSB7XG4gICAgICAgIGdyaWRSb3c6IDEsXG4gICAgICAgIGdyaWRDb2x1bW46IDIsXG4gICAgICAgIHdpZHRoOiAnMTAwJSdcbiAgICAgIH0sIF9wYWdlQnV0dG9uKVxuICAgIH0sXG4gICAgd2Fybjoge1xuICAgICAgXCJ0cnVlXCI6IHtcbiAgICAgICAgY29sb3I6ICckd2FybidcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzQWN0aXZlOiB7XG4gICAgICBcInRydWVcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICckaG92ZXInXG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbnZhciBJY29uV3JhcHBlciA9IC8qI19fUFVSRV9fKi9zdHlsZWQoJ2RpdicsIHtcbiAgaGVpZ2h0OiAnMTAwJScsXG4gIGJvcmRlclJhZGl1czogJzRweCcsXG4gIG1hcmdpblJpZ2h0OiAnMXB4JyxcbiAgZGlzcGxheTogJ2dyaWQnLFxuICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxuICBvdXRsaW5lOiAnbm9uZScsXG4gIGJvcmRlcjogJ25vbmUnLFxuICBwb2ludGVyRXZlbnRzOiAnYWxsJyxcbiAgY3Vyc29yOiAncG9pbnRlcicsXG4gIGNvbG9yOiAnJHRleHQnLFxuICAnJiBzdmcnOiB7XG4gICAgaGVpZ2h0OiAyMixcbiAgICB3aWR0aDogMjIsXG4gICAgc3Ryb2tlV2lkdGg6IDFcbiAgfSxcbiAgJyYgPiAqJzoge1xuICAgIGdyaWRSb3c6IDEsXG4gICAgZ3JpZENvbHVtbjogMVxuICB9LFxuICB2YXJpYW50czoge1xuICAgIHNpemU6IHtcbiAgICAgIHNtYWxsOiB7XG4gICAgICAgICcmIHN2Zyc6IHtcbiAgICAgICAgICBoZWlnaHQ6ICcxNnB4JyxcbiAgICAgICAgICB3aWR0aDogJzE2cHgnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtZWRpdW06IHtcbiAgICAgICAgJyYgc3ZnJzoge1xuICAgICAgICAgIGhlaWdodDogJzIycHgnLFxuICAgICAgICAgIHdpZHRoOiAnMjJweCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG52YXIgQnV0dG9uc1JvdyA9IC8qI19fUFVSRV9fKi9zdHlsZWQoJ2RpdicsIHtcbiAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gIGRpc3BsYXk6ICdmbGV4JyxcbiAgd2lkdGg6ICcxMDAlJyxcbiAgYmFja2dyb3VuZDogJ25vbmUnLFxuICBib3JkZXI6ICdub25lJyxcbiAgY3Vyc29yOiAncG9pbnRlcicsXG4gIG91dGxpbmU6ICdub25lJyxcbiAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gIGp1c3RpZnlDb250ZW50OiAnZmxleC1zdGFydCcsXG4gIHBhZGRpbmc6IDBcbn0pO1xudmFyIEZsb2F0aW5nQ29udGFpbmVyID0gLyojX19QVVJFX18qL3N0eWxlZCgnZGl2Jywge1xuICBiYWNrZ3JvdW5kQ29sb3I6ICckcGFuZWwnLFxuICBib3JkZXI6ICcxcHggc29saWQgJHBhbmVsJyxcbiAgYm9yZGVyUmFkaXVzOiAnNHB4JyxcbiAgYm94U2hhZG93OiAnJDQnLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIGhlaWdodDogJ2ZpdC1jb250ZW50JyxcbiAgcGFkZGluZzogJyQwJyxcbiAgcG9pbnRlckV2ZW50czogJ2FsbCcsXG4gIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gIHpJbmRleDogMjAwLFxuICB2YXJpYW50czoge1xuICAgIGRpcmVjdGlvbjoge1xuICAgICAgcm93OiB7XG4gICAgICAgIGZsZXhEaXJlY3Rpb246ICdyb3cnXG4gICAgICB9LFxuICAgICAgY29sdW1uOiB7XG4gICAgICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nXG4gICAgICB9XG4gICAgfSxcbiAgICBlbGV2YXRpb246IHtcbiAgICAgIDA6IHtcbiAgICAgICAgYm94U2hhZG93OiAnbm9uZSdcbiAgICAgIH0sXG4gICAgICAyOiB7XG4gICAgICAgIGJveFNoYWRvdzogJyQyJ1xuICAgICAgfSxcbiAgICAgIDM6IHtcbiAgICAgICAgYm94U2hhZG93OiAnJDMnXG4gICAgICB9LFxuICAgICAgNDoge1xuICAgICAgICBib3hTaGFkb3c6ICckNCdcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuLyogICAgICAgICAgICAgICAgICAgICAgICBNZW51cyAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxudmFyIE1lbnVDb250ZW50ID0gLyojX19QVVJFX18qL3N0eWxlZCgnZGl2Jywge1xuICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gIHpJbmRleDogMTgwLFxuICBtaW5XaWR0aDogMTgwLFxuICBwb2ludGVyRXZlbnRzOiAnYWxsJyxcbiAgYmFja2dyb3VuZENvbG9yOiAnJHBhbmVsJyxcbiAgYm9yZGVyOiAnMXB4IHNvbGlkICRwYW5lbCcsXG4gIHBhZGRpbmc6ICckMCcsXG4gIGJveFNoYWRvdzogJyQ0JyxcbiAgYm9yZGVyUmFkaXVzOiAnNHB4JyxcbiAgZm9udDogJyR1aSdcbn0pO1xudmFyIERpdmlkZXIgPSAvKiNfX1BVUkVfXyovc3R5bGVkKCdkaXYnLCB7XG4gIGJhY2tncm91bmRDb2xvcjogJyRob3ZlcicsXG4gIGhlaWdodDogMSxcbiAgbWFyZ2luVG9wOiAnJDInLFxuICBtYXJnaW5SaWdodDogJy0kMicsXG4gIG1hcmdpbkJvdHRvbTogJyQyJyxcbiAgbWFyZ2luTGVmdDogJy0kMidcbn0pO1xuZnVuY3Rpb24gRHJvcGRvd25NZW51SWNvblRyaWdnZXJCdXR0b24oX3JlZjYpIHtcbiAgdmFyIGxhYmVsID0gX3JlZjYubGFiZWwsXG4gICAgICBrYmQgPSBfcmVmNi5rYmQsXG4gICAgICBjaGlsZHJlbiA9IF9yZWY2LmNoaWxkcmVuLFxuICAgICAgX3JlZjYkZGlzYWJsZWQgPSBfcmVmNi5kaXNhYmxlZCxcbiAgICAgIGRpc2FibGVkID0gX3JlZjYkZGlzYWJsZWQgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjYkZGlzYWJsZWQ7XG4gIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KERyb3Bkb3duTWVudS5UcmlnZ2VyLCB7XG4gICAgYXM6IEljb25CdXR0b24sXG4gICAgYnA6IGJyZWFrcG9pbnRzLFxuICAgIGRpc2FibGVkOiBkaXNhYmxlZFxuICB9LCBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFRvb2x0aXAsIHtcbiAgICBsYWJlbDogbGFiZWwsXG4gICAga2JkOiBrYmRcbiAgfSwgY2hpbGRyZW4pKTtcbn1cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbi8qICAgICAgICAgICAgICAgICAgICBDb250ZXh0IE1lbnUgICAgICAgICAgICAgICAgICAgKi9cblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuZnVuY3Rpb24gQ29udGV4dE1lbnVSb290KF9yZWY4KSB7XG4gIHZhciBvbk9wZW5DaGFuZ2UgPSBfcmVmOC5vbk9wZW5DaGFuZ2UsXG4gICAgICBjaGlsZHJlbiA9IF9yZWY4LmNoaWxkcmVuO1xuICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChDb250ZXh0TWVudSQxLlJvb3QsIHtcbiAgICBkaXI6IFwibHRyXCIsXG4gICAgb25PcGVuQ2hhbmdlOiBvbk9wZW5DaGFuZ2VcbiAgfSwgY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gQ29udGV4dE1lbnVTdWJNZW51KF9yZWY5KSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWY5LmNoaWxkcmVuLFxuICAgICAgbGFiZWwgPSBfcmVmOS5sYWJlbDtcbiAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dE1lbnUkMS5Sb290LCB7XG4gICAgZGlyOiBcImx0clwiXG4gIH0sIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dE1lbnUkMS5UcmlnZ2VySXRlbSwge1xuICAgIGFzOiBSb3dCdXR0b24sXG4gICAgYnA6IGJyZWFrcG9pbnRzXG4gIH0sIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIGxhYmVsKSwgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChJY29uV3JhcHBlciwge1xuICAgIHNpemU6IFwic21hbGxcIlxuICB9LCBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KHJlYWN0SWNvbnMuQ2hldnJvblJpZ2h0SWNvbiwgbnVsbCkpKSwgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChDb250ZXh0TWVudSQxLkNvbnRlbnQsIHtcbiAgICBhczogTWVudUNvbnRlbnQsXG4gICAgc2lkZU9mZnNldDogMixcbiAgICBhbGlnbk9mZnNldDogLTJcbiAgfSwgY2hpbGRyZW4sIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dE1lbnVBcnJvdywge1xuICAgIG9mZnNldDogMTNcbiAgfSkpKTtcbn1cbnZhciBDb250ZXh0TWVudURpdmlkZXIgPSAvKiNfX1BVUkVfXyovc3R5bGVkKENvbnRleHRNZW51JDEuU2VwYXJhdG9yLCB7XG4gIGJhY2tncm91bmRDb2xvcjogJyRob3ZlcicsXG4gIGhlaWdodDogMSxcbiAgbWFyZ2luOiAnJDIgLSQyJ1xufSk7XG52YXIgQ29udGV4dE1lbnVBcnJvdyA9IC8qI19fUFVSRV9fKi9zdHlsZWQoQ29udGV4dE1lbnUkMS5BcnJvdywge1xuICBmaWxsOiAnJHBhbmVsJ1xufSk7XG5mdW5jdGlvbiBDb250ZXh0TWVudUJ1dHRvbihfcmVmMTApIHtcbiAgdmFyIG9uU2VsZWN0ID0gX3JlZjEwLm9uU2VsZWN0LFxuICAgICAgY2hpbGRyZW4gPSBfcmVmMTAuY2hpbGRyZW4sXG4gICAgICBfcmVmMTAkZGlzYWJsZWQgPSBfcmVmMTAuZGlzYWJsZWQsXG4gICAgICBkaXNhYmxlZCA9IF9yZWYxMCRkaXNhYmxlZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMTAkZGlzYWJsZWQ7XG4gIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJvd0J1dHRvbiwge1xuICAgIGFzOiBDb250ZXh0TWVudSQxLkl0ZW0sXG4gICAgYnA6IGJyZWFrcG9pbnRzLFxuICAgIGRpc2FibGVkOiBkaXNhYmxlZCxcbiAgICBvblNlbGVjdDogb25TZWxlY3RcbiAgfSwgY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gQ29udGV4dE1lbnVJY29uQnV0dG9uKF9yZWYxMSkge1xuICB2YXIgb25TZWxlY3QgPSBfcmVmMTEub25TZWxlY3QsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYxMS5jaGlsZHJlbixcbiAgICAgIF9yZWYxMSRkaXNhYmxlZCA9IF9yZWYxMS5kaXNhYmxlZCxcbiAgICAgIGRpc2FibGVkID0gX3JlZjExJGRpc2FibGVkID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYxMSRkaXNhYmxlZDtcbiAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dE1lbnUkMS5JdGVtLCB7XG4gICAgYXM6IEljb25CdXR0b24sXG4gICAgYnA6IGJyZWFrcG9pbnRzLFxuICAgIGRpc2FibGVkOiBkaXNhYmxlZCxcbiAgICBvblNlbGVjdDogb25TZWxlY3RcbiAgfSwgY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gQ2lyY2xlSWNvbihwcm9wcykge1xuICB2YXIgX3Byb3BzJHNpemUgPSBwcm9wcy5zaXplLFxuICAgICAgc2l6ZSA9IF9wcm9wcyRzaXplID09PSB2b2lkIDAgPyAxNiA6IF9wcm9wcyRzaXplLFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQpO1xuXG4gIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIF9leHRlbmRzKHtcbiAgICB3aWR0aDogMjQsXG4gICAgaGVpZ2h0OiAyNFxuICB9LCByZXN0KSwgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImNpcmNsZVwiLCB7XG4gICAgY3g6IDEyLFxuICAgIGN5OiAxMixcbiAgICByOiBzaXplIC8gMlxuICB9KSk7XG59XG5cbihmdW5jdGlvbiAoTW92ZVR5cGUpIHtcbiAgTW92ZVR5cGVbXCJCYWNrd2FyZFwiXSA9IFwiYmFja3dhcmRcIjtcbiAgTW92ZVR5cGVbXCJGb3J3YXJkXCJdID0gXCJmb3J3YXJkXCI7XG4gIE1vdmVUeXBlW1wiVG9Gcm9udFwiXSA9IFwidG9Gcm9udFwiO1xuICBNb3ZlVHlwZVtcIlRvQmFja1wiXSA9IFwidG9CYWNrXCI7XG59KShleHBvcnRzLk1vdmVUeXBlIHx8IChleHBvcnRzLk1vdmVUeXBlID0ge30pKTtcblxuKGZ1bmN0aW9uIChBbGlnblR5cGUpIHtcbiAgQWxpZ25UeXBlW1wiVG9wXCJdID0gXCJ0b3BcIjtcbiAgQWxpZ25UeXBlW1wiQ2VudGVyVmVydGljYWxcIl0gPSBcImNlbnRlclZlcnRpY2FsXCI7XG4gIEFsaWduVHlwZVtcIkJvdHRvbVwiXSA9IFwiYm90dG9tXCI7XG4gIEFsaWduVHlwZVtcIkxlZnRcIl0gPSBcImxlZnRcIjtcbiAgQWxpZ25UeXBlW1wiQ2VudGVySG9yaXpvbnRhbFwiXSA9IFwiY2VudGVySG9yaXpvbnRhbFwiO1xuICBBbGlnblR5cGVbXCJSaWdodFwiXSA9IFwicmlnaHRcIjtcbn0pKGV4cG9ydHMuQWxpZ25UeXBlIHx8IChleHBvcnRzLkFsaWduVHlwZSA9IHt9KSk7XG5cbihmdW5jdGlvbiAoU3RyZXRjaFR5cGUpIHtcbiAgU3RyZXRjaFR5cGVbXCJIb3Jpem9udGFsXCJdID0gXCJob3Jpem9udGFsXCI7XG4gIFN0cmV0Y2hUeXBlW1wiVmVydGljYWxcIl0gPSBcInZlcnRpY2FsXCI7XG59KShleHBvcnRzLlN0cmV0Y2hUeXBlIHx8IChleHBvcnRzLlN0cmV0Y2hUeXBlID0ge30pKTtcblxuKGZ1bmN0aW9uIChEaXN0cmlidXRlVHlwZSkge1xuICBEaXN0cmlidXRlVHlwZVtcIkhvcml6b250YWxcIl0gPSBcImhvcml6b250YWxcIjtcbiAgRGlzdHJpYnV0ZVR5cGVbXCJWZXJ0aWNhbFwiXSA9IFwidmVydGljYWxcIjtcbn0pKGV4cG9ydHMuRGlzdHJpYnV0ZVR5cGUgfHwgKGV4cG9ydHMuRGlzdHJpYnV0ZVR5cGUgPSB7fSkpO1xuXG52YXIgaGFzMVNlbGVjdGVkSWRzU2VsZWN0b3IgPSBmdW5jdGlvbiBoYXMxU2VsZWN0ZWRJZHNTZWxlY3RvcihzKSB7XG4gIHJldHVybiBzLnBhZ2VTdGF0ZS5zZWxlY3RlZElkcy5sZW5ndGggPiAwO1xufTtcblxudmFyIGhhczJTZWxlY3RlZElkc1NlbGVjdG9yID0gZnVuY3Rpb24gaGFzMlNlbGVjdGVkSWRzU2VsZWN0b3Iocykge1xuICByZXR1cm4gcy5wYWdlU3RhdGUuc2VsZWN0ZWRJZHMubGVuZ3RoID4gMTtcbn07XG5cbnZhciBoYXMzU2VsZWN0ZWRJZHNTZWxlY3RvciA9IGZ1bmN0aW9uIGhhczNTZWxlY3RlZElkc1NlbGVjdG9yKHMpIHtcbiAgcmV0dXJuIHMucGFnZVN0YXRlLnNlbGVjdGVkSWRzLmxlbmd0aCA+IDI7XG59O1xuXG52YXIgaXNEZWJ1Z01vZGVTZWxlY3RvciA9IGZ1bmN0aW9uIGlzRGVidWdNb2RlU2VsZWN0b3Iocykge1xuICByZXR1cm4gcy5zZXR0aW5ncy5pc0RlYnVnTW9kZTtcbn07XG5cbnZhciBoYXNHcm91cFNlbGVjdGVkU2VsZWN0b3IgPSBmdW5jdGlvbiBoYXNHcm91cFNlbGVjdGVkU2VsZWN0b3Iocykge1xuICByZXR1cm4gcy5wYWdlU3RhdGUuc2VsZWN0ZWRJZHMuc29tZShmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gcy5wYWdlLnNoYXBlc1tpZF0uY2hpbGRyZW4gIT09IHVuZGVmaW5lZDtcbiAgfSk7XG59O1xuXG52YXIgQ29udGV4dE1lbnUgPSAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyhmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuO1xuXG4gIHZhciBfdXNlVExEcmF3Q29udGV4dCA9IHVzZVRMRHJhd0NvbnRleHQoKSxcbiAgICAgIHRsc3RhdGUgPSBfdXNlVExEcmF3Q29udGV4dC50bHN0YXRlLFxuICAgICAgdXNlQXBwU3RhdGUgPSBfdXNlVExEcmF3Q29udGV4dC51c2VBcHBTdGF0ZTtcblxuICB2YXIgaGFzU2VsZWN0aW9uID0gdXNlQXBwU3RhdGUoaGFzMVNlbGVjdGVkSWRzU2VsZWN0b3IpO1xuICB2YXIgaGFzVHdvT3JNb3JlID0gdXNlQXBwU3RhdGUoaGFzMlNlbGVjdGVkSWRzU2VsZWN0b3IpO1xuICB2YXIgaGFzVGhyZWVPck1vcmUgPSB1c2VBcHBTdGF0ZShoYXMzU2VsZWN0ZWRJZHNTZWxlY3Rvcik7XG4gIHZhciBpc0RlYnVnTW9kZSA9IHVzZUFwcFN0YXRlKGlzRGVidWdNb2RlU2VsZWN0b3IpO1xuICB2YXIgaGFzR3JvdXBTZWxlY3RlZCA9IHVzZUFwcFN0YXRlKGhhc0dyb3VwU2VsZWN0ZWRTZWxlY3Rvcik7XG4gIHZhciByQ29udGVudCA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdmFyIGhhbmRsZUR1cGxpY2F0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB0bHN0YXRlLmR1cGxpY2F0ZSgpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICB2YXIgaGFuZGxlR3JvdXAgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5ncm91cCgpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICB2YXIgaGFuZGxlTW92ZVRvQmFjayA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB0bHN0YXRlLm1vdmVUb0JhY2soKTtcbiAgfSwgW3Rsc3RhdGVdKTtcbiAgdmFyIGhhbmRsZU1vdmVCYWNrd2FyZCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB0bHN0YXRlLm1vdmVCYWNrd2FyZCgpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICB2YXIgaGFuZGxlTW92ZUZvcndhcmQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5tb3ZlRm9yd2FyZCgpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICB2YXIgaGFuZGxlTW92ZVRvRnJvbnQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5tb3ZlVG9Gcm9udCgpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICB2YXIgaGFuZGxlRGVsZXRlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHRsc3RhdGVbXCJkZWxldGVcIl0oKTtcbiAgfSwgW3Rsc3RhdGVdKTtcbiAgdmFyIGhhbmRsZUNvcHlBc0pzb24gPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5jb3B5QXNKc29uKCk7XG4gIH0sIFt0bHN0YXRlXSk7XG4gIHZhciBoYW5kbGVDb3B5QXNTdmcgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5jb3B5QXNTdmcoKTtcbiAgfSwgW3Rsc3RhdGVdKTtcbiAgdmFyIGhhbmRsZVVuZG8gPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS51bmRvKCk7XG4gIH0sIFt0bHN0YXRlXSk7XG4gIHZhciBoYW5kbGVSZWRvID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHRsc3RhdGUucmVkbygpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0TWVudVJvb3QsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dE1lbnUkMS5UcmlnZ2VyLCBudWxsLCBjaGlsZHJlbiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWVudUNvbnRlbnQsIHtcbiAgICBhczogQ29udGV4dE1lbnUkMS5Db250ZW50LFxuICAgIHJlZjogckNvbnRlbnRcbiAgfSwgaGFzU2VsZWN0aW9uID8gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0TWVudUJ1dHRvbiwge1xuICAgIG9uU2VsZWN0OiBoYW5kbGVEdXBsaWNhdGVcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgXCJEdXBsaWNhdGVcIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoS2JkLCB7XG4gICAgdmFyaWFudDogXCJtZW51XCJcbiAgfSwgXCIjRFwiKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dE1lbnVEaXZpZGVyLCBudWxsKSwgaGFzR3JvdXBTZWxlY3RlZCB8fCBoYXNUd29Pck1vcmUgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgaGFzR3JvdXBTZWxlY3RlZCAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHRNZW51QnV0dG9uLCB7XG4gICAgb25TZWxlY3Q6IGhhbmRsZUdyb3VwXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIFwiVW5ncm91cFwiKSwgUmVhY3QuY3JlYXRlRWxlbWVudChLYmQsIHtcbiAgICB2YXJpYW50OiBcIm1lbnVcIlxuICB9LCBcIiNcXHUyMUU3R1wiKSksIGhhc1R3b09yTW9yZSAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHRNZW51QnV0dG9uLCB7XG4gICAgb25TZWxlY3Q6IGhhbmRsZUdyb3VwXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIFwiR3JvdXBcIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoS2JkLCB7XG4gICAgdmFyaWFudDogXCJtZW51XCJcbiAgfSwgXCIjR1wiKSkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHRNZW51U3ViTWVudSwge1xuICAgIGxhYmVsOiBcIk1vdmVcIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHRNZW51QnV0dG9uLCB7XG4gICAgb25TZWxlY3Q6IGhhbmRsZU1vdmVUb0Zyb250XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIFwiVG8gRnJvbnRcIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoS2JkLCB7XG4gICAgdmFyaWFudDogXCJtZW51XCJcbiAgfSwgXCIjIFxcdTIxRTcgXVwiKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dE1lbnVCdXR0b24sIHtcbiAgICBvblNlbGVjdDogaGFuZGxlTW92ZUZvcndhcmRcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgXCJGb3J3YXJkXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEtiZCwge1xuICAgIHZhcmlhbnQ6IFwibWVudVwiXG4gIH0sIFwiIyBdXCIpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0TWVudUJ1dHRvbiwge1xuICAgIG9uU2VsZWN0OiBoYW5kbGVNb3ZlQmFja3dhcmRcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgXCJCYWNrd2FyZFwiKSwgUmVhY3QuY3JlYXRlRWxlbWVudChLYmQsIHtcbiAgICB2YXJpYW50OiBcIm1lbnVcIlxuICB9LCBcIiMgW1wiKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dE1lbnVCdXR0b24sIHtcbiAgICBvblNlbGVjdDogaGFuZGxlTW92ZVRvQmFja1xuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCBcIlRvIEJhY2tcIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoS2JkLCB7XG4gICAgdmFyaWFudDogXCJtZW51XCJcbiAgfSwgXCIjIFxcdTIxRTcgW1wiKSkpLCBoYXNUd29Pck1vcmUgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChBbGlnbkRpc3RyaWJ1dGVTdWJNZW51LCB7XG4gICAgaGFzVHdvT3JNb3JlOiBoYXNUd29Pck1vcmUsXG4gICAgaGFzVGhyZWVPck1vcmU6IGhhc1RocmVlT3JNb3JlXG4gIH0pLCBpc0RlYnVnTW9kZSAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHRNZW51QnV0dG9uLCB7XG4gICAgb25TZWxlY3Q6IGhhbmRsZUNvcHlBc0pzb25cbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgXCJDb3B5IERhdGFcIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoS2JkLCB7XG4gICAgdmFyaWFudDogXCJtZW51XCJcbiAgfSwgXCIjIFxcdTIxRTcgQ1wiKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dE1lbnVCdXR0b24sIHtcbiAgICBvblNlbGVjdDogaGFuZGxlQ29weUFzU3ZnXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIFwiQ29weSB0byBTVkdcIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoS2JkLCB7XG4gICAgdmFyaWFudDogXCJtZW51XCJcbiAgfSwgXCIjIFxcdTIxRTcgQ1wiKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dE1lbnVEaXZpZGVyLCBudWxsKSwgUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0TWVudUJ1dHRvbiwge1xuICAgIG9uU2VsZWN0OiBoYW5kbGVEZWxldGVcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgXCJEZWxldGVcIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoS2JkLCB7XG4gICAgdmFyaWFudDogXCJtZW51XCJcbiAgfSwgXCJcXHUyMzJCXCIpKSkgOiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHRNZW51QnV0dG9uLCB7XG4gICAgb25TZWxlY3Q6IGhhbmRsZVVuZG9cbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgXCJVbmRvXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEtiZCwge1xuICAgIHZhcmlhbnQ6IFwibWVudVwiXG4gIH0sIFwiIyBaXCIpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0TWVudUJ1dHRvbiwge1xuICAgIG9uU2VsZWN0OiBoYW5kbGVSZWRvXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIFwiUmVkb1wiKSwgUmVhY3QuY3JlYXRlRWxlbWVudChLYmQsIHtcbiAgICB2YXJpYW50OiBcIm1lbnVcIlxuICB9LCBcIiMgXFx1MjFFNyBaXCIpKSkpKTtcbn0pO1xuXG5mdW5jdGlvbiBBbGlnbkRpc3RyaWJ1dGVTdWJNZW51KF9yZWYyKSB7XG4gIHZhciBoYXNUaHJlZU9yTW9yZSA9IF9yZWYyLmhhc1RocmVlT3JNb3JlO1xuXG4gIHZhciBfdXNlVExEcmF3Q29udGV4dDIgPSB1c2VUTERyYXdDb250ZXh0KCksXG4gICAgICB0bHN0YXRlID0gX3VzZVRMRHJhd0NvbnRleHQyLnRsc3RhdGU7XG5cbiAgdmFyIGFsaWduVG9wID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHRsc3RhdGUuYWxpZ24oZXhwb3J0cy5BbGlnblR5cGUuVG9wKTtcbiAgfSwgW3Rsc3RhdGVdKTtcbiAgdmFyIGFsaWduQ2VudGVyVmVydGljYWwgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5hbGlnbihleHBvcnRzLkFsaWduVHlwZS5DZW50ZXJWZXJ0aWNhbCk7XG4gIH0sIFt0bHN0YXRlXSk7XG4gIHZhciBhbGlnbkJvdHRvbSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB0bHN0YXRlLmFsaWduKGV4cG9ydHMuQWxpZ25UeXBlLkJvdHRvbSk7XG4gIH0sIFt0bHN0YXRlXSk7XG4gIHZhciBzdHJldGNoVmVydGljYWxseSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB0bHN0YXRlLnN0cmV0Y2goZXhwb3J0cy5TdHJldGNoVHlwZS5WZXJ0aWNhbCk7XG4gIH0sIFt0bHN0YXRlXSk7XG4gIHZhciBkaXN0cmlidXRlVmVydGljYWxseSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB0bHN0YXRlLmRpc3RyaWJ1dGUoZXhwb3J0cy5EaXN0cmlidXRlVHlwZS5WZXJ0aWNhbCk7XG4gIH0sIFt0bHN0YXRlXSk7XG4gIHZhciBhbGlnbkxlZnQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5hbGlnbihleHBvcnRzLkFsaWduVHlwZS5MZWZ0KTtcbiAgfSwgW3Rsc3RhdGVdKTtcbiAgdmFyIGFsaWduQ2VudGVySG9yaXpvbnRhbCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB0bHN0YXRlLmFsaWduKGV4cG9ydHMuQWxpZ25UeXBlLkNlbnRlckhvcml6b250YWwpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICB2YXIgYWxpZ25SaWdodCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB0bHN0YXRlLmFsaWduKGV4cG9ydHMuQWxpZ25UeXBlLlJpZ2h0KTtcbiAgfSwgW3Rsc3RhdGVdKTtcbiAgdmFyIHN0cmV0Y2hIb3Jpem9udGFsbHkgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5zdHJldGNoKGV4cG9ydHMuU3RyZXRjaFR5cGUuSG9yaXpvbnRhbCk7XG4gIH0sIFt0bHN0YXRlXSk7XG4gIHZhciBkaXN0cmlidXRlSG9yaXpvbnRhbGx5ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHRsc3RhdGUuZGlzdHJpYnV0ZShleHBvcnRzLkRpc3RyaWJ1dGVUeXBlLkhvcml6b250YWwpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0TWVudVJvb3QsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dE1lbnUkMS5UcmlnZ2VySXRlbSwge1xuICAgIGFzOiBSb3dCdXR0b24sXG4gICAgYnA6IGJyZWFrcG9pbnRzXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIFwiQWxpZ24gLyBEaXN0cmlidXRlXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEljb25XcmFwcGVyLCB7XG4gICAgc2l6ZTogXCJzbWFsbFwiXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3RJY29ucy5DaGV2cm9uUmlnaHRJY29uLCBudWxsKSkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFN0eWxlZEdyaWQsIHtcbiAgICBhczogQ29udGV4dE1lbnUkMS5Db250ZW50LFxuICAgIHNpZGVPZmZzZXQ6IDIsXG4gICAgYWxpZ25PZmZzZXQ6IC0yLFxuICAgIHNlbGVjdGVkU3R5bGU6IGhhc1RocmVlT3JNb3JlID8gJ3RocmVlT3JNb3JlJyA6ICd0d29Pck1vcmUnXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dE1lbnVJY29uQnV0dG9uLCB7XG4gICAgb25TZWxlY3Q6IGFsaWduTGVmdFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0SWNvbnMuQWxpZ25MZWZ0SWNvbiwgbnVsbCkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHRNZW51SWNvbkJ1dHRvbiwge1xuICAgIG9uU2VsZWN0OiBhbGlnbkNlbnRlckhvcml6b250YWxcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChyZWFjdEljb25zLkFsaWduQ2VudGVySG9yaXpvbnRhbGx5SWNvbiwgbnVsbCkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHRNZW51SWNvbkJ1dHRvbiwge1xuICAgIG9uU2VsZWN0OiBhbGlnblJpZ2h0XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3RJY29ucy5BbGlnblJpZ2h0SWNvbiwgbnVsbCkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHRNZW51SWNvbkJ1dHRvbiwge1xuICAgIG9uU2VsZWN0OiBzdHJldGNoSG9yaXpvbnRhbGx5XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3RJY29ucy5TdHJldGNoSG9yaXpvbnRhbGx5SWNvbiwgbnVsbCkpLCBoYXNUaHJlZU9yTW9yZSAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHRNZW51SWNvbkJ1dHRvbiwge1xuICAgIG9uU2VsZWN0OiBkaXN0cmlidXRlSG9yaXpvbnRhbGx5XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3RJY29ucy5TcGFjZUV2ZW5seUhvcml6b250YWxseUljb24sIG51bGwpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0TWVudUljb25CdXR0b24sIHtcbiAgICBvblNlbGVjdDogYWxpZ25Ub3BcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChyZWFjdEljb25zLkFsaWduVG9wSWNvbiwgbnVsbCkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHRNZW51SWNvbkJ1dHRvbiwge1xuICAgIG9uU2VsZWN0OiBhbGlnbkNlbnRlclZlcnRpY2FsXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3RJY29ucy5BbGlnbkNlbnRlclZlcnRpY2FsbHlJY29uLCBudWxsKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dE1lbnVJY29uQnV0dG9uLCB7XG4gICAgb25TZWxlY3Q6IGFsaWduQm90dG9tXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3RJY29ucy5BbGlnbkJvdHRvbUljb24sIG51bGwpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0TWVudUljb25CdXR0b24sIHtcbiAgICBvblNlbGVjdDogc3RyZXRjaFZlcnRpY2FsbHlcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChyZWFjdEljb25zLlN0cmV0Y2hWZXJ0aWNhbGx5SWNvbiwgbnVsbCkpLCBoYXNUaHJlZU9yTW9yZSAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHRNZW51SWNvbkJ1dHRvbiwge1xuICAgIG9uU2VsZWN0OiBkaXN0cmlidXRlVmVydGljYWxseVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0SWNvbnMuU3BhY2VFdmVubHlWZXJ0aWNhbGx5SWNvbiwgbnVsbCkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHRNZW51QXJyb3csIHtcbiAgICBvZmZzZXQ6IDEzXG4gIH0pKSk7XG59XG5cbnZhciBTdHlsZWRHcmlkID0gLyojX19QVVJFX18qL3N0eWxlZChNZW51Q29udGVudCwge1xuICBkaXNwbGF5OiAnZ3JpZCcsXG4gIHZhcmlhbnRzOiB7XG4gICAgc2VsZWN0ZWRTdHlsZToge1xuICAgICAgdGhyZWVPck1vcmU6IHtcbiAgICAgICAgZ3JpZFRlbXBsYXRlQ29sdW1uczogJ3JlcGVhdCg1LCBhdXRvKSdcbiAgICAgIH0sXG4gICAgICB0d29Pck1vcmU6IHtcbiAgICAgICAgZ3JpZFRlbXBsYXRlQ29sdW1uczogJ3JlcGVhdCg0LCBhdXRvKSdcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pOyAvLyBmdW5jdGlvbiBNb3ZlVG9QYWdlTWVudSgpIHtcbi8vICAgY29uc3QgZG9jdW1lbnRQYWdlcyA9IHVzZVNlbGVjdG9yKChzKSA9PiBzLmRhdGEuZG9jdW1lbnQucGFnZXMpXG4vLyAgIGNvbnN0IGN1cnJlbnRQYWdlSWQgPSB1c2VTZWxlY3RvcigocykgPT4gcy5kYXRhLmN1cnJlbnRQYWdlSWQpXG4vLyAgIGlmICghZG9jdW1lbnRQYWdlc1tjdXJyZW50UGFnZUlkXSkgcmV0dXJuIG51bGxcbi8vICAgY29uc3Qgc29ydGVkID0gT2JqZWN0LnZhbHVlcyhkb2N1bWVudFBhZ2VzKVxuLy8gICAgIC5zb3J0KChhLCBiKSA9PiBhLmNoaWxkSW5kZXggLSBiLmNoaWxkSW5kZXgpXG4vLyAgICAgLmZpbHRlcigoYSkgPT4gYS5pZCAhPT0gY3VycmVudFBhZ2VJZClcbi8vICAgaWYgKHNvcnRlZC5sZW5ndGggPT09IDApIHJldHVybiBudWxsXG4vLyAgIHJldHVybiAoXG4vLyAgICAgPENvbnRleHRNZW51Um9vdD5cbi8vICAgICAgIDxDb250ZXh0TWVudUJ1dHRvbj5cbi8vICAgICAgICAgPHNwYW4+TW92ZSBUbyBQYWdlPC9zcGFuPlxuLy8gICAgICAgICA8SWNvbldyYXBwZXIgc2l6ZT1cInNtYWxsXCI+XG4vLyAgICAgICAgICAgPENoZXZyb25SaWdodEljb24gLz5cbi8vICAgICAgICAgPC9JY29uV3JhcHBlcj5cbi8vICAgICAgIDwvQ29udGV4dE1lbnVCdXR0b24+XG4vLyAgICAgICA8TWVudUNvbnRlbnQgYXM9e1JhZGl4Q29udGV4dE1lbnUuQ29udGVudH0gc2lkZU9mZnNldD17Mn0gYWxpZ25PZmZzZXQ9ey0yfT5cbi8vICAgICAgICAge3NvcnRlZC5tYXAoKHsgaWQsIG5hbWUgfSkgPT4gKFxuLy8gICAgICAgICAgIDxDb250ZXh0TWVudUJ1dHRvblxuLy8gICAgICAgICAgICAga2V5PXtpZH1cbi8vICAgICAgICAgICAgIGRpc2FibGVkPXtpZCA9PT0gY3VycmVudFBhZ2VJZH1cbi8vICAgICAgICAgICAgIG9uU2VsZWN0PXsoKSA9PiBzdGF0ZS5zZW5kKCdNT1ZFRF9UT19QQUdFJywgeyBpZCB9KX1cbi8vICAgICAgICAgICA+XG4vLyAgICAgICAgICAgICA8c3Bhbj57bmFtZX08L3NwYW4+XG4vLyAgICAgICAgICAgPC9Db250ZXh0TWVudUJ1dHRvbj5cbi8vICAgICAgICAgKSl9XG4vLyAgICAgICAgIDxDb250ZXh0TWVudUFycm93IG9mZnNldD17MTN9IC8+XG4vLyAgICAgICA8L01lbnVDb250ZW50PlxuLy8gICAgIDwvQ29udGV4dE1lbnVSb290PlxuLy8gICApXG4vLyB9XG5cbmZ1bmN0aW9uIFN2Z1JlZG8ocHJvcHMpIHtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgX2V4dGVuZHMoe1xuICAgIHZpZXdCb3g6IFwiMCAwIDE1IDE1XCIsXG4gICAgZmlsbDogXCJjdXJyZW50Q29sb3JcIixcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gIH0sIHByb3BzKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICBjbGlwUnVsZTogXCJldmVub2RkXCIsXG4gICAgZDogXCJNMTIuNSAyLjQ5NWEuNS41IDAgMDAtLjUuNXYyLjVIOS41YS41LjUgMCAxMDAgMWgzYS41LjUgMCAwMC41LS41di0zYS41LjUgMCAwMC0uNS0uNXpcIlxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICBjbGlwUnVsZTogXCJldmVub2RkXCIsXG4gICAgZDogXCJNNy42OTcgMi4wNDlhNSA1IDAgMTA0LjAyIDYuNjEzLjUuNSAwIDEwLS45NDQtLjMzMiA0IDQgMCAxMS0uOTQ2LTQuMTZsLjAxLjAxIDIuMzIgMi4xOGEuNS41IDAgMDAuNjg1LS43MjlsLTIuMzE0LTIuMTc1QTUgNSAwIDAwNy42OTcgMi4wNXpcIlxuICB9KSk7XG59XG5cbmZ1bmN0aW9uIFN2Z1RyYXNoKHByb3BzKSB7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIF9leHRlbmRzKHtcbiAgICB2aWV3Qm94OiBcIjAgMCAxNSAxNVwiLFxuICAgIGZpbGw6IFwiY3VycmVudENvbG9yXCIsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICB9LCBwcm9wcyksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgIGQ6IFwiTTIgNC42NTZhLjUuNSAwIDAxLjUtLjVoOS43YS41LjUgMCAwMTAgMUgyLjVhLjUuNSAwIDAxLS41LS41elwiXG4gIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIixcbiAgICBkOiBcIk02LjI3MiAzYS41NzguNTc4IDAgMDAtLjU3OC41Nzh2LjU3OGgzLjMxMXYtLjU3OEEuNTc4LjU3OCAwIDAwOC40MjggM0g2LjI3MnptMy43MzMgMS4xNTZ2LS41NzhBMS41NzggMS41NzggMCAwMDguNDI4IDJINi4yNzJhMS41NzggMS41NzggMCAwMC0xLjU3OCAxLjU3OHYuNTc4SDMuNTc4YS41LjUgMCAwMC0uNS41VjEyLjJhMS41NzggMS41NzggMCAwMDEuNTc3IDEuNTc4aDUuMzlhMS41NzggMS41NzggMCAwMDEuNTc3LTEuNTc4VjQuNjU2YS41LjUgMCAwMC0uNS0uNWgtMS4xMTd6bS01LjkyNyAxVjEyLjJhLjU3OC41NzggMCAwMC41NzcuNTc4aDUuMzlhLjU3OC41NzggMCAwMC41NzctLjU3OFY1LjE1Nkg0LjA3OHpcIlxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICBjbGlwUnVsZTogXCJldmVub2RkXCIsXG4gICAgZDogXCJNNi4yNzIgNi44NWEuNS41IDAgMDEuNS41djMuMjMzYS41LjUgMCAxMS0xIDBWNy4zNWEuNS41IDAgMDEuNS0uNXpNOC40MjggNi44NWEuNS41IDAgMDEuNS41djMuMjMzYS41LjUgMCAxMS0xIDBWNy4zNWEuNS41IDAgMDEuNS0uNXpcIlxuICB9KSk7XG59XG5cbmZ1bmN0aW9uIFN2Z1VuZG8ocHJvcHMpIHtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgX2V4dGVuZHMoe1xuICAgIHZpZXdCb3g6IFwiMCAwIDE1IDE1XCIsXG4gICAgZmlsbDogXCJjdXJyZW50Q29sb3JcIixcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gIH0sIHByb3BzKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICBjbGlwUnVsZTogXCJldmVub2RkXCIsXG4gICAgZDogXCJNMi41IDIuNDk1YS41LjUgMCAwMS41LjV2Mi41aDIuNWEuNS41IDAgMTEwIDFoLTNhLjUuNSAwIDAxLS41LS41di0zYS41LjUgMCAwMS41LS41elwiXG4gIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIixcbiAgICBkOiBcIk03LjMwMyAyLjA0OWE1IDUgMCAxMS00LjAyIDYuNjEzLjUuNSAwIDAxLjk0NC0uMzMyIDQgNCAwIDEwLjk0Ni00LjE2bC0uMDEuMDEtMi4zMiAyLjE4YS41LjUgMCAwMS0uNjg1LS43MjlsMi4zMTQtMi4xNzVBNSA1IDAgMDE3LjMwMyAyLjA1elwiXG4gIH0pKTtcbn1cblxudmFyIGlzQWxsTG9ja2VkU2VsZWN0b3IgPSBmdW5jdGlvbiBpc0FsbExvY2tlZFNlbGVjdG9yKHMpIHtcbiAgdmFyIHNlbGVjdGVkSWRzID0gcy5wYWdlU3RhdGUuc2VsZWN0ZWRJZHM7XG4gIHJldHVybiBzZWxlY3RlZElkcy5ldmVyeShmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gcy5wYWdlLnNoYXBlc1tpZF0uaXNMb2NrZWQ7XG4gIH0pO1xufTtcblxudmFyIGlzQWxsQXNwZWN0TG9ja2VkU2VsZWN0b3IgPSBmdW5jdGlvbiBpc0FsbEFzcGVjdExvY2tlZFNlbGVjdG9yKHMpIHtcbiAgdmFyIHNlbGVjdGVkSWRzID0gcy5wYWdlU3RhdGUuc2VsZWN0ZWRJZHM7XG4gIHJldHVybiBzZWxlY3RlZElkcy5ldmVyeShmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gcy5wYWdlLnNoYXBlc1tpZF0uaXNBc3BlY3RSYXRpb0xvY2tlZDtcbiAgfSk7XG59O1xuXG52YXIgaXNBbGxHcm91cGVkU2VsZWN0b3IgPSBmdW5jdGlvbiBpc0FsbEdyb3VwZWRTZWxlY3RvcihzKSB7XG4gIHZhciBzZWxlY3RlZFNoYXBlcyA9IHMucGFnZVN0YXRlLnNlbGVjdGVkSWRzLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gcy5wYWdlLnNoYXBlc1tpZF07XG4gIH0pO1xuICByZXR1cm4gc2VsZWN0ZWRTaGFwZXMuZXZlcnkoZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgcmV0dXJuIHNoYXBlLmNoaWxkcmVuICE9PSB1bmRlZmluZWQgfHwgc2hhcGUucGFyZW50SWQgPT09IHNlbGVjdGVkU2hhcGVzWzBdLnBhcmVudElkICYmIHNlbGVjdGVkU2hhcGVzWzBdLnBhcmVudElkICE9PSBzLmFwcFN0YXRlLmN1cnJlbnRQYWdlSWQ7XG4gIH0pO1xufTtcblxudmFyIGhhc1NlbGVjdGlvblNlbGVjdG9yID0gZnVuY3Rpb24gaGFzU2VsZWN0aW9uU2VsZWN0b3Iocykge1xuICByZXR1cm4gcy5wYWdlU3RhdGUuc2VsZWN0ZWRJZHMubGVuZ3RoID4gMDtcbn07XG5cbnZhciBoYXNNdWx0aXBsZVNlbGVjdGlvblNlbGVjdG9yID0gZnVuY3Rpb24gaGFzTXVsdGlwbGVTZWxlY3Rpb25TZWxlY3RvcihzKSB7XG4gIHJldHVybiBzLnBhZ2VTdGF0ZS5zZWxlY3RlZElkcy5sZW5ndGggPiAxO1xufTtcblxudmFyIFNoYXBlc0Z1bmN0aW9ucyA9IC8qI19fUFVSRV9fKi9SZWFjdC5tZW1vKGZ1bmN0aW9uICgpIHtcbiAgdmFyIF91c2VUTERyYXdDb250ZXh0ID0gdXNlVExEcmF3Q29udGV4dCgpLFxuICAgICAgdGxzdGF0ZSA9IF91c2VUTERyYXdDb250ZXh0LnRsc3RhdGUsXG4gICAgICB1c2VBcHBTdGF0ZSA9IF91c2VUTERyYXdDb250ZXh0LnVzZUFwcFN0YXRlO1xuXG4gIHZhciBpc0FsbExvY2tlZCA9IHVzZUFwcFN0YXRlKGlzQWxsTG9ja2VkU2VsZWN0b3IpO1xuICB2YXIgaXNBbGxBc3BlY3RMb2NrZWQgPSB1c2VBcHBTdGF0ZShpc0FsbEFzcGVjdExvY2tlZFNlbGVjdG9yKTtcbiAgdmFyIGlzQWxsR3JvdXBlZCA9IHVzZUFwcFN0YXRlKGlzQWxsR3JvdXBlZFNlbGVjdG9yKTtcbiAgdmFyIGhhc1NlbGVjdGlvbiA9IHVzZUFwcFN0YXRlKGhhc1NlbGVjdGlvblNlbGVjdG9yKTtcbiAgdmFyIGhhc011bHRpcGxlU2VsZWN0aW9uID0gdXNlQXBwU3RhdGUoaGFzTXVsdGlwbGVTZWxlY3Rpb25TZWxlY3Rvcik7XG4gIHZhciBoYW5kbGVSb3RhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5yb3RhdGUoKTtcbiAgfSwgW3Rsc3RhdGVdKTtcbiAgdmFyIGhhbmRsZUR1cGxpY2F0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB0bHN0YXRlLmR1cGxpY2F0ZSgpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICB2YXIgaGFuZGxlVG9nZ2xlTG9ja2VkID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHRsc3RhdGUudG9nZ2xlTG9ja2VkKCk7XG4gIH0sIFt0bHN0YXRlXSk7XG4gIHZhciBoYW5kbGVUb2dnbGVBc3BlY3RSYXRpbyA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB0bHN0YXRlLnRvZ2dsZUFzcGVjdFJhdGlvTG9ja2VkKCk7XG4gIH0sIFt0bHN0YXRlXSk7XG4gIHZhciBoYW5kbGVHcm91cCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB0bHN0YXRlLmdyb3VwKCk7XG4gIH0sIFt0bHN0YXRlXSk7XG4gIHZhciBoYW5kbGVNb3ZlVG9CYWNrID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHRsc3RhdGUubW92ZVRvQmFjaygpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICB2YXIgaGFuZGxlTW92ZUJhY2t3YXJkID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHRsc3RhdGUubW92ZUJhY2t3YXJkKCk7XG4gIH0sIFt0bHN0YXRlXSk7XG4gIHZhciBoYW5kbGVNb3ZlRm9yd2FyZCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB0bHN0YXRlLm1vdmVGb3J3YXJkKCk7XG4gIH0sIFt0bHN0YXRlXSk7XG4gIHZhciBoYW5kbGVNb3ZlVG9Gcm9udCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB0bHN0YXRlLm1vdmVUb0Zyb250KCk7XG4gIH0sIFt0bHN0YXRlXSk7XG4gIHZhciBoYW5kbGVEZWxldGUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZVtcImRlbGV0ZVwiXSgpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChCdXR0b25zUm93LCBudWxsLCBSZWFjdC5jcmVhdGVFbGVtZW50KEljb25CdXR0b24sIHtcbiAgICBicDogYnJlYWtwb2ludHMsXG4gICAgZGlzYWJsZWQ6ICFoYXNTZWxlY3Rpb24sXG4gICAgc2l6ZTogXCJzbWFsbFwiLFxuICAgIG9uQ2xpY2s6IGhhbmRsZUR1cGxpY2F0ZVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFRvb2x0aXAsIHtcbiAgICBsYWJlbDogXCJEdXBsaWNhdGVcIixcbiAgICBrYmQ6IFwiI0RcIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0SWNvbnMuQ29weUljb24sIG51bGwpKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSWNvbkJ1dHRvbiwge1xuICAgIGRpc2FibGVkOiAhaGFzU2VsZWN0aW9uLFxuICAgIHNpemU6IFwic21hbGxcIixcbiAgICBvbkNsaWNrOiBoYW5kbGVSb3RhdGVcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChUb29sdGlwLCB7XG4gICAgbGFiZWw6IFwiUm90YXRlXCJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChyZWFjdEljb25zLlJvdGF0ZUNvdW50ZXJDbG9ja3dpc2VJY29uLCBudWxsKSkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEljb25CdXR0b24sIHtcbiAgICBicDogYnJlYWtwb2ludHMsXG4gICAgZGlzYWJsZWQ6ICFoYXNTZWxlY3Rpb24sXG4gICAgc2l6ZTogXCJzbWFsbFwiLFxuICAgIG9uQ2xpY2s6IGhhbmRsZVRvZ2dsZUxvY2tlZFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFRvb2x0aXAsIHtcbiAgICBsYWJlbDogXCJUb29nbGUgTG9ja2VkXCIsXG4gICAga2JkOiBcIiNMXCJcbiAgfSwgaXNBbGxMb2NrZWQgPyBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0SWNvbnMuTG9ja0Nsb3NlZEljb24sIG51bGwpIDogUmVhY3QuY3JlYXRlRWxlbWVudChyZWFjdEljb25zLkxvY2tPcGVuMUljb24sIHtcbiAgICBvcGFjaXR5OiAwLjRcbiAgfSkpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChJY29uQnV0dG9uLCB7XG4gICAgYnA6IGJyZWFrcG9pbnRzLFxuICAgIGRpc2FibGVkOiAhaGFzU2VsZWN0aW9uLFxuICAgIHNpemU6IFwic21hbGxcIixcbiAgICBvbkNsaWNrOiBoYW5kbGVUb2dnbGVBc3BlY3RSYXRpb1xuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFRvb2x0aXAsIHtcbiAgICBsYWJlbDogXCJUb29nbGUgQXNwZWN0IFJhdGlvIExvY2tcIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0SWNvbnMuQXNwZWN0UmF0aW9JY29uLCB7XG4gICAgb3BhY2l0eTogaXNBbGxBc3BlY3RMb2NrZWQgPyAxIDogMC40XG4gIH0pKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSWNvbkJ1dHRvbiwge1xuICAgIGJwOiBicmVha3BvaW50cyxcbiAgICBkaXNhYmxlZDogIWlzQWxsR3JvdXBlZCAmJiAhaGFzTXVsdGlwbGVTZWxlY3Rpb24sXG4gICAgc2l6ZTogXCJzbWFsbFwiLFxuICAgIG9uQ2xpY2s6IGhhbmRsZUdyb3VwXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVG9vbHRpcCwge1xuICAgIGxhYmVsOiBcIkdyb3VwXCIsXG4gICAga2JkOiBcIiNHXCJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChyZWFjdEljb25zLkdyb3VwSWNvbiwge1xuICAgIG9wYWNpdHk6IGlzQWxsR3JvdXBlZCA/IDEgOiAwLjRcbiAgfSkpKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQnV0dG9uc1JvdywgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChJY29uQnV0dG9uLCB7XG4gICAgYnA6IGJyZWFrcG9pbnRzLFxuICAgIGRpc2FibGVkOiAhaGFzU2VsZWN0aW9uLFxuICAgIHNpemU6IFwic21hbGxcIixcbiAgICBvbkNsaWNrOiBoYW5kbGVNb3ZlVG9CYWNrXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVG9vbHRpcCwge1xuICAgIGxhYmVsOiBcIk1vdmUgdG8gQmFja1wiLFxuICAgIGtiZDogXCIjXFx1MjFFN1tcIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0SWNvbnMuUGluQm90dG9tSWNvbiwgbnVsbCkpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChJY29uQnV0dG9uLCB7XG4gICAgYnA6IGJyZWFrcG9pbnRzLFxuICAgIGRpc2FibGVkOiAhaGFzU2VsZWN0aW9uLFxuICAgIHNpemU6IFwic21hbGxcIixcbiAgICBvbkNsaWNrOiBoYW5kbGVNb3ZlQmFja3dhcmRcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChUb29sdGlwLCB7XG4gICAgbGFiZWw6IFwiTW92ZSBCYWNrd2FyZFwiLFxuICAgIGtiZDogXCIjW1wiXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3RJY29ucy5BcnJvd0Rvd25JY29uLCBudWxsKSkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEljb25CdXR0b24sIHtcbiAgICBicDogYnJlYWtwb2ludHMsXG4gICAgZGlzYWJsZWQ6ICFoYXNTZWxlY3Rpb24sXG4gICAgc2l6ZTogXCJzbWFsbFwiLFxuICAgIG9uQ2xpY2s6IGhhbmRsZU1vdmVGb3J3YXJkXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVG9vbHRpcCwge1xuICAgIGxhYmVsOiBcIk1vdmUgRm9yd2FyZFwiLFxuICAgIGtiZDogXCIjXVwiXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3RJY29ucy5BcnJvd1VwSWNvbiwgbnVsbCkpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChJY29uQnV0dG9uLCB7XG4gICAgYnA6IGJyZWFrcG9pbnRzLFxuICAgIGRpc2FibGVkOiAhaGFzU2VsZWN0aW9uLFxuICAgIHNpemU6IFwic21hbGxcIixcbiAgICBvbkNsaWNrOiBoYW5kbGVNb3ZlVG9Gcm9udFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFRvb2x0aXAsIHtcbiAgICBsYWJlbDogXCJNb3JlIHRvIEZyb250XCIsXG4gICAga2JkOiBcIiNcXHUyMUU3XVwiXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3RJY29ucy5QaW5Ub3BJY29uLCBudWxsKSkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEljb25CdXR0b24sIHtcbiAgICBicDogYnJlYWtwb2ludHMsXG4gICAgZGlzYWJsZWQ6ICFoYXNTZWxlY3Rpb24sXG4gICAgc2l6ZTogXCJzbWFsbFwiLFxuICAgIG9uQ2xpY2s6IGhhbmRsZURlbGV0ZVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFRvb2x0aXAsIHtcbiAgICBsYWJlbDogXCJEZWxldGVcIixcbiAgICBrYmQ6IFwiXFx1MjMyQlwiXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU3ZnVHJhc2gsIG51bGwpKSkpKTtcbn0pO1xuXG52YXIgQWxpZ25EaXN0cmlidXRlID0gLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGhhc1R3b09yTW9yZSA9IF9yZWYuaGFzVHdvT3JNb3JlLFxuICAgICAgaGFzVGhyZWVPck1vcmUgPSBfcmVmLmhhc1RocmVlT3JNb3JlO1xuXG4gIHZhciBfdXNlVExEcmF3Q29udGV4dCA9IHVzZVRMRHJhd0NvbnRleHQoKSxcbiAgICAgIHRsc3RhdGUgPSBfdXNlVExEcmF3Q29udGV4dC50bHN0YXRlO1xuXG4gIHZhciBhbGlnblRvcCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB0bHN0YXRlLmFsaWduKGV4cG9ydHMuQWxpZ25UeXBlLlRvcCk7XG4gIH0sIFt0bHN0YXRlXSk7XG4gIHZhciBhbGlnbkNlbnRlclZlcnRpY2FsID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHRsc3RhdGUuYWxpZ24oZXhwb3J0cy5BbGlnblR5cGUuQ2VudGVyVmVydGljYWwpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICB2YXIgYWxpZ25Cb3R0b20gPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5hbGlnbihleHBvcnRzLkFsaWduVHlwZS5Cb3R0b20pO1xuICB9LCBbdGxzdGF0ZV0pO1xuICB2YXIgc3RyZXRjaFZlcnRpY2FsbHkgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5zdHJldGNoKGV4cG9ydHMuU3RyZXRjaFR5cGUuVmVydGljYWwpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICB2YXIgZGlzdHJpYnV0ZVZlcnRpY2FsbHkgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5kaXN0cmlidXRlKGV4cG9ydHMuRGlzdHJpYnV0ZVR5cGUuVmVydGljYWwpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICB2YXIgYWxpZ25MZWZ0ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHRsc3RhdGUuYWxpZ24oZXhwb3J0cy5BbGlnblR5cGUuTGVmdCk7XG4gIH0sIFt0bHN0YXRlXSk7XG4gIHZhciBhbGlnbkNlbnRlckhvcml6b250YWwgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5hbGlnbihleHBvcnRzLkFsaWduVHlwZS5DZW50ZXJIb3Jpem9udGFsKTtcbiAgfSwgW3Rsc3RhdGVdKTtcbiAgdmFyIGFsaWduUmlnaHQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5hbGlnbihleHBvcnRzLkFsaWduVHlwZS5SaWdodCk7XG4gIH0sIFt0bHN0YXRlXSk7XG4gIHZhciBzdHJldGNoSG9yaXpvbnRhbGx5ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHRsc3RhdGUuc3RyZXRjaChleHBvcnRzLlN0cmV0Y2hUeXBlLkhvcml6b250YWwpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICB2YXIgZGlzdHJpYnV0ZUhvcml6b250YWxseSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB0bHN0YXRlLmRpc3RyaWJ1dGUoZXhwb3J0cy5EaXN0cmlidXRlVHlwZS5Ib3Jpem9udGFsKTtcbiAgfSwgW3Rsc3RhdGVdKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQnV0dG9uc1JvdywgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChJY29uQnV0dG9uLCB7XG4gICAgYnA6IGJyZWFrcG9pbnRzLFxuICAgIHNpemU6IFwic21hbGxcIixcbiAgICBkaXNhYmxlZDogIWhhc1R3b09yTW9yZSxcbiAgICBvbkNsaWNrOiBhbGlnbkxlZnRcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChyZWFjdEljb25zLkFsaWduTGVmdEljb24sIG51bGwpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChJY29uQnV0dG9uLCB7XG4gICAgYnA6IGJyZWFrcG9pbnRzLFxuICAgIHNpemU6IFwic21hbGxcIixcbiAgICBkaXNhYmxlZDogIWhhc1R3b09yTW9yZSxcbiAgICBvbkNsaWNrOiBhbGlnbkNlbnRlckhvcml6b250YWxcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChyZWFjdEljb25zLkFsaWduQ2VudGVySG9yaXpvbnRhbGx5SWNvbiwgbnVsbCkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEljb25CdXR0b24sIHtcbiAgICBicDogYnJlYWtwb2ludHMsXG4gICAgc2l6ZTogXCJzbWFsbFwiLFxuICAgIGRpc2FibGVkOiAhaGFzVHdvT3JNb3JlLFxuICAgIG9uQ2xpY2s6IGFsaWduUmlnaHRcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChyZWFjdEljb25zLkFsaWduUmlnaHRJY29uLCBudWxsKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSWNvbkJ1dHRvbiwge1xuICAgIGJwOiBicmVha3BvaW50cyxcbiAgICBzaXplOiBcInNtYWxsXCIsXG4gICAgZGlzYWJsZWQ6ICFoYXNUd29Pck1vcmUsXG4gICAgb25DbGljazogc3RyZXRjaEhvcml6b250YWxseVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0SWNvbnMuU3RyZXRjaEhvcml6b250YWxseUljb24sIG51bGwpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChJY29uQnV0dG9uLCB7XG4gICAgYnA6IGJyZWFrcG9pbnRzLFxuICAgIHNpemU6IFwic21hbGxcIixcbiAgICBkaXNhYmxlZDogIWhhc1RocmVlT3JNb3JlLFxuICAgIG9uQ2xpY2s6IGRpc3RyaWJ1dGVIb3Jpem9udGFsbHlcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChyZWFjdEljb25zLlNwYWNlRXZlbmx5SG9yaXpvbnRhbGx5SWNvbiwgbnVsbCkpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChCdXR0b25zUm93LCBudWxsLCBSZWFjdC5jcmVhdGVFbGVtZW50KEljb25CdXR0b24sIHtcbiAgICBicDogYnJlYWtwb2ludHMsXG4gICAgc2l6ZTogXCJzbWFsbFwiLFxuICAgIGRpc2FibGVkOiAhaGFzVHdvT3JNb3JlLFxuICAgIG9uQ2xpY2s6IGFsaWduVG9wXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3RJY29ucy5BbGlnblRvcEljb24sIG51bGwpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChJY29uQnV0dG9uLCB7XG4gICAgYnA6IGJyZWFrcG9pbnRzLFxuICAgIHNpemU6IFwic21hbGxcIixcbiAgICBkaXNhYmxlZDogIWhhc1R3b09yTW9yZSxcbiAgICBvbkNsaWNrOiBhbGlnbkNlbnRlclZlcnRpY2FsXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3RJY29ucy5BbGlnbkNlbnRlclZlcnRpY2FsbHlJY29uLCBudWxsKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSWNvbkJ1dHRvbiwge1xuICAgIGJwOiBicmVha3BvaW50cyxcbiAgICBzaXplOiBcInNtYWxsXCIsXG4gICAgZGlzYWJsZWQ6ICFoYXNUd29Pck1vcmUsXG4gICAgb25DbGljazogYWxpZ25Cb3R0b21cbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChyZWFjdEljb25zLkFsaWduQm90dG9tSWNvbiwgbnVsbCkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEljb25CdXR0b24sIHtcbiAgICBicDogYnJlYWtwb2ludHMsXG4gICAgc2l6ZTogXCJzbWFsbFwiLFxuICAgIGRpc2FibGVkOiAhaGFzVHdvT3JNb3JlLFxuICAgIG9uQ2xpY2s6IHN0cmV0Y2hWZXJ0aWNhbGx5XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3RJY29ucy5TdHJldGNoVmVydGljYWxseUljb24sIG51bGwpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChJY29uQnV0dG9uLCB7XG4gICAgYnA6IGJyZWFrcG9pbnRzLFxuICAgIHNpemU6IFwic21hbGxcIixcbiAgICBkaXNhYmxlZDogIWhhc1RocmVlT3JNb3JlLFxuICAgIG9uQ2xpY2s6IGRpc3RyaWJ1dGVWZXJ0aWNhbGx5XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3RJY29ucy5TcGFjZUV2ZW5seVZlcnRpY2FsbHlJY29uLCBudWxsKSkpKTtcbn0pO1xuXG52YXIgU3R5bGVEcm9wZG93bkNvbnRlbnQgPSAvKiNfX1BVUkVfXyovc3R5bGVkKCdkaXYnLCB7XG4gIGRpc3BsYXk6ICdncmlkJyxcbiAgcGFkZGluZzogNCxcbiAgZ3JpZFRlbXBsYXRlQ29sdW1uczogJ3JlcGVhdCg0LCAxZnIpJyxcbiAgYmFja2dyb3VuZENvbG9yOiAnJHBhbmVsJyxcbiAgYm9yZGVyUmFkaXVzOiA0LFxuICBib3JkZXI6ICcxcHggc29saWQgJHBhbmVsJyxcbiAgYm94U2hhZG93OiAnJDQnLFxuICB2YXJpYW50czoge1xuICAgIGRpcmVjdGlvbjoge1xuICAgICAgdmVydGljYWw6IHtcbiAgICAgICAgZ3JpZFRlbXBsYXRlQ29sdW1uczogJzFmcidcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xudmFyIFN0eWxlRHJvcGRvd25JdGVtID0gLyojX19QVVJFX18qL3N0eWxlZCgnYnV0dG9uJywge1xuICBoZWlnaHQ6ICczMnB4JyxcbiAgd2lkdGg6ICczMnB4JyxcbiAgYmFja2dyb3VuZENvbG9yOiAnJHBhbmVsJyxcbiAgYm9yZGVyUmFkaXVzOiAnNHB4JyxcbiAgcGFkZGluZzogJzAnLFxuICBtYXJnaW46ICcwJyxcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxuICBvdXRsaW5lOiAnbm9uZScsXG4gIGJvcmRlcjogJ25vbmUnLFxuICBwb2ludGVyRXZlbnRzOiAnYWxsJyxcbiAgY3Vyc29yOiAncG9pbnRlcicsXG4gICcmOmZvY3VzJzoge1xuICAgIGJhY2tncm91bmRDb2xvcjogJyRob3ZlcidcbiAgfSxcbiAgJyY6aG92ZXI6bm90KDpkaXNhYmxlZCknOiB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnJGhvdmVyJ1xuICB9LFxuICAnJjpkaXNhYmxlZCc6IHtcbiAgICBvcGFjaXR5OiAnMC41J1xuICB9LFxuICB2YXJpYW50czoge1xuICAgIGlzQWN0aXZlOiB7XG4gICAgICBcInRydWVcIjoge1xuICAgICAgICAnJiBzdmcnOiB7XG4gICAgICAgICAgZmlsbDogJyR0ZXh0JyxcbiAgICAgICAgICBzdHJva2U6ICckdGV4dCdcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiZmFsc2VcIjoge1xuICAgICAgICAnJiBzdmcnOiB7XG4gICAgICAgICAgZmlsbDogJyRpbmFjdGl2ZScsXG4gICAgICAgICAgc3Ryb2tlOiAnJGluYWN0aXZlJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbmZ1bmN0aW9uIEJveEljb24oX3JlZikge1xuICB2YXIgX3JlZiRmaWxsID0gX3JlZi5maWxsLFxuICAgICAgZmlsbCA9IF9yZWYkZmlsbCA9PT0gdm9pZCAwID8gJ25vbmUnIDogX3JlZiRmaWxsLFxuICAgICAgX3JlZiRzdHJva2UgPSBfcmVmLnN0cm9rZSxcbiAgICAgIHN0cm9rZSA9IF9yZWYkc3Ryb2tlID09PSB2b2lkIDAgPyAnY3VycmVudENvbG9yJyA6IF9yZWYkc3Ryb2tlO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7XG4gICAgd2lkdGg6IFwiMjRcIixcbiAgICBoZWlnaHQ6IFwiMjRcIixcbiAgICB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLFxuICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgIGZpbGw6IGZpbGwsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7XG4gICAgeDogXCI0XCIsXG4gICAgeTogXCI0XCIsXG4gICAgd2lkdGg6IFwiMTZcIixcbiAgICBoZWlnaHQ6IFwiMTZcIixcbiAgICByeDogXCIyXCIsXG4gICAgc3Ryb2tlV2lkdGg6IFwiMlwiXG4gIH0pKTtcbn1cbmZ1bmN0aW9uIERhc2hTb2xpZEljb24oKSB7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHtcbiAgICB3aWR0aDogXCIyNFwiLFxuICAgIGhlaWdodDogXCIyNFwiLFxuICAgIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIixcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIiwge1xuICAgIGN4OiAxMixcbiAgICBjeTogMTIsXG4gICAgcjogOCxcbiAgICBmaWxsOiBcIm5vbmVcIixcbiAgICBzdHJva2VXaWR0aDogMixcbiAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCJcbiAgfSkpO1xufVxuZnVuY3Rpb24gRGFzaERhc2hlZEljb24oKSB7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHtcbiAgICB3aWR0aDogXCIyNFwiLFxuICAgIGhlaWdodDogXCIyNFwiLFxuICAgIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIixcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIiwge1xuICAgIGN4OiAxMixcbiAgICBjeTogMTIsXG4gICAgcjogOCxcbiAgICBmaWxsOiBcIm5vbmVcIixcbiAgICBzdHJva2VXaWR0aDogMi41LFxuICAgIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIixcbiAgICBzdHJva2VEYXNoYXJyYXk6IDUwLjI2NTQ4ICogMC4xXG4gIH0pKTtcbn1cbnZhciBkb3R0ZWREYXNoYXJyYXkgPSA1MC4yNjU0OCAqIDAuMDI1ICsgXCIgXCIgKyA1MC4yNjU0OCAqIDAuMTtcbmZ1bmN0aW9uIERhc2hEb3R0ZWRJY29uKCkge1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7XG4gICAgd2lkdGg6IFwiMjRcIixcbiAgICBoZWlnaHQ6IFwiMjRcIixcbiAgICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIsIHtcbiAgICBjeDogMTIsXG4gICAgY3k6IDEyLFxuICAgIHI6IDgsXG4gICAgZmlsbDogXCJub25lXCIsXG4gICAgc3Ryb2tlV2lkdGg6IDIuNSxcbiAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gICAgc3Ryb2tlRGFzaGFycmF5OiBkb3R0ZWREYXNoYXJyYXlcbiAgfSkpO1xufVxuZnVuY3Rpb24gRGFzaERyYXdJY29uKCkge1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7XG4gICAgd2lkdGg6IFwiMjRcIixcbiAgICBoZWlnaHQ6IFwiMjRcIixcbiAgICB2aWV3Qm94OiBcIjEgMS41IDIxIDIyXCIsXG4gICAgZmlsbDogXCJjdXJyZW50Q29sb3JcIixcbiAgICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgZDogXCJNMTAuMDE2MiAxOS4yNzY4QzEwLjAxNjIgMTkuMjc2OCA5LjkwNjc5IDE5LjI1MTcgOS42ODc5IDE5LjIwMTdDOS40NjI3NSAxOS4xNDU0IDkuMTI4MTYgMTkuMDQyMiA4LjY4NDEzIDE4Ljg5MjFDOC4yMzM4NCAxOC43MzU4IDcuODE0ODIgMTguNTQ1IDcuNDI3MDcgMTguMzE5OUM3LjAzMzA3IDE4LjEwMSA2LjYyMzQzIDE3Ljc4ODMgNi4xOTgxNiAxNy4zODE4QzUuNzcyODkgMTYuOTc1MyA1LjMzNTExIDE2LjM3MTggNC44ODQ4MiAxNS41NzEzQzQuNDM0NTMgMTQuNzY0NSA0LjE1MzEgMTMuODU0NSA0LjA0MDUzIDEyLjg0MTRDMy45Mjc5NSAxMS44MjIgNC4wNDk5MSAxMC44NDY0IDQuNDA2MzkgOS45MTQ1MUM0Ljc2Mjg2IDguOTgyNjYgNS4zOTQ1MiA4LjEwMDg0IDYuMzAxMzUgNy4yNjkwNkM3LjIxNDQ0IDYuNDQzNTMgOC4yOTMyNSA1LjgzMzc3IDkuNTM3OCA1LjQzOTc2QzEwLjc4MjMgNS4wNTIwMiAxMS44MzMgNC45MjA2OCAxMi42ODk4IDUuMDQ1NzZDMTMuNTQ2NiA1LjE2NDU5IDE0LjM4NzggNS40MzY2NCAxNS4yMTMzIDUuODYxOTFDMTYuMDM4OCA2LjI4NzE4IDE2Ljc3NjggNi44Njg4IDE3LjQyNzIgNy42MDY3OEMxOC4wNzE0IDguMzQ0NzUgMTguNTQwNCA5LjIxNDA2IDE4LjgzNDQgMTAuMjE0N0MxOS4xMjgzIDExLjIxNTMgMTkuMTcyMSAxMi4yNTk4IDE4Ljk2NTcgMTMuMzQ4QzE4Ljc1OTMgMTQuNDI5OSAxOC4yODcyIDE1LjQzMzcgMTcuNTQ5MiAxNi4zNTkzQzE2LjgxMTIgMTcuMjg0OSAxNS45MjYzIDE4LjAwNzIgMTQuODk0NCAxOC41MjYzQzEzLjg2MjQgMTkuMDM5MSAxMi45MDU2IDE5LjMxNzQgMTIuMDIzOCAxOS4zNjEyQzExLjE0MiAxOS40MDUgMTAuMjEwMSAxOS4yNzA1IDkuMjI4MjMgMTguOTU3OEM4LjI0NjM1IDE4LjY0NTEgNy4zNTgyOCAxOC4xNTEgNi41NjQwMiAxNy40NzU2QzUuNzc2MDEgMTYuODAwMiA2LjA4ODcxIDE2Ljg2NTggNy41MDIxMiAxNy42NzI2QzguOTA5MjcgMTguNDczMSAxMC4xNDQ0IDE4Ljg0ODQgMTEuMjA3NiAxOC43OTgzQzEyLjI2NDUgMTguNzU0NSAxMy4yOTY1IDE4LjQ4MjUgMTQuMzAzNCAxNy45ODIyQzE1LjMxMDIgMTcuNDgxOSAxNi4xMjY0IDE2LjgyMjEgMTYuNzUxOCAxNi4wMDI4QzE3LjM3NzIgMTUuMTgzNSAxNy43NjgxIDE0LjMxMTEgMTcuOTI0NCAxMy4zODU1QzE4LjA4MDggMTIuNDU5OSAxOC4wNDAxIDExLjU3ODEgMTcuODAyNSAxMC43NEMxNy41NTg2IDkuOTAyIDE3LjE3MzkgOS4xNTQ2NCAxNi42NDg2IDguNDk3OTdDMTYuMTIzMyA3Ljg0MTMgMTUuMjI4OSA3LjI3ODQ0IDEzLjk2NTYgNi44MDkzOUMxMi43MDg2IDYuMzQwMzQgMTEuNDIwMyA2LjIwOTAxIDEwLjEwMDcgNi40MTUzOUM4Ljc4NzMyIDYuNjE1NTIgNy42OTU5OSA3LjA2ODkzIDYuODI2NjkgNy43NzU2NEM1Ljk2MzYzIDguNDg4NTkgNS4zNDc2MSA5LjI2NDA5IDQuOTc4NjMgMTAuMTAyMUM0LjYwOTY0IDEwLjk0MDIgNC40NTMyOSAxMS44Mzc2IDQuNTA5NTggMTIuNzk0NUM0LjU2NTg2IDEzLjc1MTMgNC43OTEwMSAxNC42MjM4IDUuMTg1MDEgMTUuNDExOEM1LjU3Mjc2IDE2LjE5OTggNS45NjM2MyAxNi44MDAyIDYuMzU3NjQgMTcuMjEyOUM2Ljc1MTY0IDE3LjYyNTcgNy4xMzMxMyAxNy45NTA5IDcuNTAyMTIgMTguMTg4NkM3Ljg3NzM2IDE4LjQzMjUgOC4yODA3NCAxOC42NDIgOC43MTIyNyAxOC44MTcxQzkuMTUwMDUgMTguOTkyMiA5LjQ3ODM5IDE5LjExMSA5LjY5NzI4IDE5LjE3MzZDOS45MTYxNyAxOS4yMzYxIDEwLjAyNTYgMTkuMjcwNSAxMC4wMjU2IDE5LjI3NjhIMTAuMDE2MlpcIixcbiAgICBzdHJva2VXaWR0aDogXCIyXCJcbiAgfSkpO1xufVxuZnVuY3Rpb24gSXNGaWxsZWRGaWxsSWNvbigpIHtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwge1xuICAgIHdpZHRoOiBcIjI0XCIsXG4gICAgaGVpZ2h0OiBcIjI0XCIsXG4gICAgdmlld0JveDogXCIwIDAgMjQgMjRcIixcbiAgICBmaWxsOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIixcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBkOiBcIk0yLjYxNjggMTEuMTMwM0MyLjYxNjggMTEuMTMwMyAyLjcwMjMgMTEuMDEzMSAyLjg3MzMgMTAuNzc4OEMzLjA0NDMgMTAuNTQ0NCAzLjEyOTggMTAuNDI3MiAzLjEyOTggMTAuNDI3MkMzLjEyOTggMTAuNDI3MiAzLjIzMzMzIDEwLjI4MjMgMy40NDA0IDkuOTkyMzZDMy42NDc0NiA5LjcwMjQ2IDMuODU4ODkgOS40MDM0MSA0LjA3NDcgOS4wOTUyMUM0LjI5MDUgOC43ODcwMSA0LjUwNjA2IDguNDc1NzQgNC43MjEzOSA4LjE2MTQxQzQuOTM2NzEgNy44NDcwOCA1LjE0MzM4IDcuNTQxMzkgNS4zNDE0IDcuMjQ0MzJDNS41Mzk0MyA2Ljk0NzI2IDUuNzIwNjggNi42NzE2MiA1Ljg4NTE3IDYuNDE3NDJDNi4wNDk2NiA2LjE2MzIxIDYuMjExNiA1LjkxNDc3IDYuMzcwOTkgNS42NzIxMUM2LjUzMDM4IDUuNDI5NDQgNi42OTUyOCA1LjE4ODA2IDYuODY1NjggNC45NDc5NkM3LjAzNjA4IDQuNzA3ODYgNy4yMTY5NCA0LjQ2OTkgNy40MDgyNCA0LjIzNDA5QzcuNTk5NTUgMy45OTgyOCA3LjgxMDYzIDMuNzYyODcgOC4wNDE1IDMuNTI3ODdDOC4yNzIzNiAzLjI5Mjg2IDguNzExMTQgMy4wMjY3IDkuMzU3ODIgMi43MjkzN0MxMC4wMDQ1IDIuNDMyMDMgMTAuNDcxMyAyLjM1MjgxIDEwLjc1ODEgMi40OTE2OUMxMS4wNDUgMi42MzA1NyAxMS4yNjM3IDIuODQwNDkgMTEuNDE0MSAzLjEyMTQ2QzExLjU2NDUgMy40MDI0MyAxMS42MTggMy43MDA3OSAxMS41NzQ2IDQuMDE2NTNDMTEuNTMxMiA0LjMzMjI3IDExLjQ2MjcgNC41OTg5MSAxMS4zNjkxIDQuODE2NDZDMTEuMjc1NiA1LjAzNDAxIDExLjA4NTggNS40MzkxOCAxMC43OTk4IDYuMDMxOTlDMTAuNTEzOSA2LjYyNDc5IDEwLjIxMjIgNy4xNzYxNyA5Ljg5NDk5IDcuNjg2MTJDOS41Nzc3MyA4LjE5NjA3IDkuMjUwNDggOC43MTUyOSA4LjkxMzIzIDkuMjQzNzlDOC41NzU5OCA5Ljc3MjI5IDguMjQxOTMgMTAuMzAzOCA3LjkxMTA3IDEwLjgzODJDNy41ODAyMSAxMS4zNzI2IDcuMjgyOCAxMS44NzI5IDcuMDE4ODUgMTIuMzM5QzYuNzU0ODkgMTIuODA1MSA2LjUzNzExIDEzLjIyNTkgNi4zNjU1MiAxMy42MDE0QzYuMTkzOTMgMTMuOTc3IDYuMDEzMiAxNC4zOTUxIDUuODIzMzIgMTQuODU1N0M1LjYzMzQ0IDE1LjMxNjMgNS40Mzc3MSAxNS42MTcgNS4yMzYxMiAxNS43NTc4QzUuMDM0NTMgMTUuODk4NiA0LjgwNTM3IDE1Ljc5OTMgNC41NDg2NSAxNS40NTk5QzQuMjkxOTMgMTUuMTIwNSA0LjExMjQ0IDE0Ljg3MjIgNC4wMTAyIDE0LjcxNDhDMy45MDc5NiAxNC41NTc1IDMuOTcwMDggMTQuMzgwMiA0LjE5NjU3IDE0LjE4M0M0LjQyMzA2IDEzLjk4NTggNC42OTAxNiAxMy43NTg0IDQuOTk3ODkgMTMuNTAwOUM1LjMwNTYxIDEzLjI0MzQgNS42NDI0NSAxMi45NjE3IDYuMDA4MzkgMTIuNjU1OUM2LjM3NDM0IDEyLjM1IDYuNjc2MTcgMTIuMDk2NyA2LjkxMzg5IDExLjg5NThDNy4xNTE2MSAxMS42OTUgNy4zOTAyNiAxMS40OTI2IDcuNjI5ODUgMTEuMjg4NUM3Ljg2OTQ0IDExLjA4NDQgOC4xNTMzMiAxMC44NDY3IDguNDgxNDggMTAuNTc1NEM4LjgwOTY1IDEwLjMwNDIgOS4yMzkwNyA5Ljk1NzcgOS43Njk3MiA5LjUzNjA0QzEwLjMwMDQgOS4xMTQzOSAxMC44NjcgOC42NjYwNCAxMS40Njk1IDguMTkxMDJDMTIuMDcyIDcuNzE1OTkgMTIuNjg2OSA3LjIyOTc1IDEzLjMxNDIgNi43MzIyOUMxMy45NDE1IDYuMjM0ODMgMTQuNTc0MSA1LjczMzc4IDE1LjIxMjEgNS4yMjkxNEMxNS44NSA0LjcyNDUgMTYuNDE2OCA0LjI2OTUzIDE2LjkxMjUgMy44NjQyM0MxNy40MDgxIDMuNDU4OTIgMTcuNzczOSAzLjE0NzE1IDE4LjAwOTkgMi45Mjg5MUMxOC4yNDU5IDIuNzEwNjYgMTguNTk2OSAyLjUwOTEyIDE5LjA2MzEgMi4zMjQyN0MxOS41MjkyIDIuMTM5NDIgMTkuODc1NCAyLjEwOTQ3IDIwLjEwMTcgMi4yMzQ0M0MyMC4zMjggMi4zNTkzOSAyMC40OTU5IDIuNTM4OTIgMjAuNjA1NiAyLjc3MzAyQzIwLjcxNTIgMy4wMDcxMiAyMC43NDU1IDMuMjUxMDggMjAuNjk2NiAzLjUwNDg5QzIwLjY0NzcgMy43NTg3MSAyMC42MTA4IDMuOTM1MzcgMjAuNTg1OSA0LjAzNDg3QzIwLjU2MSA0LjEzNDM3IDIwLjQ5OTggNC4zMjMwNCAyMC40MDIzIDQuNjAwODhDMjAuMzA0NyA0Ljg3ODcyIDIwLjE2MjEgNS4xNzQ0OSAxOS45NzQ1IDUuNDg4MkMxOS43ODY5IDUuODAxOTEgMTkuNTc2IDYuMTQ2NjkgMTkuMzQxOSA2LjUyMjU2QzE5LjEwNzggNi44OTg0MiAxOC45MDg2IDcuMjEzMzEgMTguNzQ0MyA3LjQ2NzIyQzE4LjU4IDcuNzIxMTMgMTguNDE0MiA3Ljk3NTkgMTguMjQ2OSA4LjIzMTUzQzE4LjA3OTYgOC40ODcxNiAxNy44ODM2IDguNzc4NjEgMTcuNjU4OCA5LjEwNTg4QzE3LjQzNCA5LjQzMzE2IDE3LjE0NDggOS44NDIwNSAxNi43OTEyIDEwLjMzMjZDMTYuNDM3NiAxMC44MjMxIDE2LjA2NTkgMTEuMzQyIDE1LjY3NiAxMS44ODkzQzE1LjI4NjIgMTIuNDM2NSAxNC45MDAxIDEyLjk5NjggMTQuNTE3OCAxMy41NzAxQzE0LjEzNTYgMTQuMTQzNSAxMy43NjgyIDE0LjcyNjQgMTMuNDE1OSAxNS4zMTkxQzEzLjA2MzUgMTUuOTExOCAxMi43NTc5IDE2LjQ2NzEgMTIuNDk4OSAxNi45ODVDMTIuMjQgMTcuNTAzIDEyLjA1MzMgMTcuOTUyNyAxMS45Mzg5IDE4LjMzNDJDMTEuODI0NCAxOC43MTU2IDExLjcyMjQgMTkuMTM0NyAxMS42MzI2IDE5LjU5MTJDMTEuNTQyOSAyMC4wNDc3IDExLjM3ODggMjAuNjA0MyAxMS4xNDAyIDIxLjI2MDlDMTAuOTAxNiAyMS45MTc1IDEwLjY0MjUgMjIuMjk5IDEwLjM2MjkgMjIuNDA1NEMxMC4wODMyIDIyLjUxMTggOS43OTg5NSAyMi41MjU4IDkuNTEwMTUgMjIuNDQ3NUM5LjIyMTM2IDIyLjM2OTIgOC45ODMxNSAyMi4yMTM1IDguNzk1NTQgMjEuOTgwNEM4LjYwNzkzIDIxLjc0NzMgOC41MzE0MSAyMS41NDQzIDguNTY1OTcgMjEuMzcxNEM4LjYwMDU0IDIxLjE5ODUgOC42ODA1IDIwLjkwNTUgOC44MDU4NiAyMC40OTI0QzguOTMxMjIgMjAuMDc5NCA5LjEwNjU0IDE5LjczMjIgOS4zMzE4MiAxOS40NTExQzkuNTU3MDkgMTkuMTcgOS44Mzk2IDE4LjgzNDcgMTAuMTc5MyAxOC40NDU0QzEwLjUxOTEgMTguMDU2IDEwLjg1ODggMTcuNjc1NiAxMS4xOTg1IDE3LjMwNDFDMTEuNTM4MSAxNi45MzI2IDExLjg2NzYgMTYuNTc5OCAxMi4xODcxIDE2LjI0NTdDMTIuNTA2NSAxNS45MTE3IDEyLjg0ODEgMTUuNTU5MiAxMy4yMTIxIDE1LjE4ODJDMTMuNTc2IDE0LjgxNzMgMTMuOTU2NyAxNC40NDE4IDE0LjM1NDIgMTQuMDYxNkMxNC43NTE3IDEzLjY4MTQgMTUuMTY2NiAxMy4zMDgyIDE1LjU5OSAxMi45NDE4QzE2LjAzMTMgMTIuNTc1NSAxNi40MzcgMTIuMjQ4OSAxNi44MTU5IDExLjk2MkMxNy4xOTQ4IDExLjY3NTIgMTcuNTEwMiAxMS40NDIzIDE3Ljc2MiAxMS4yNjM0QzE4LjAxMzggMTEuMDg0NCAxOC4zMDg0IDEwLjg5MDIgMTguNjQ1NyAxMC42ODA3QzE4Ljk4MyAxMC40NzExIDE5LjM3NDQgMTAuMzI0MyAxOS44MiAxMC4yNDAxQzIwLjI2NTYgMTAuMTU1OSAyMC42NTM0IDEwLjI2OTMgMjAuOTgzNCAxMC41ODAzQzIxLjMxMzQgMTAuODkxMyAyMS40NDk2IDExLjI3MTcgMjEuMzkyIDExLjcyMTVDMjEuMzM0NCAxMi4xNzEzIDIxLjEwNjcgMTIuNTA1MSAyMC43MDg5IDEyLjcyMjlDMjAuMzExMiAxMi45NDA2IDE5LjkwNzMgMTIuOTUyNiAxOS40OTczIDEyLjc1ODhDMTkuMDg3MyAxMi41NjUgMTguODQwMiAxMi4yNDUzIDE4Ljc1NjEgMTEuNzk5N0MxOC42NzE5IDExLjM1NDEgMTguNzg1MyAxMC45NjYzIDE5LjA5NjMgMTAuNjM2M0MxOS40MDczIDEwLjMwNjMgMTkuNzg3NyAxMC4xNzAxIDIwLjIzNzUgMTAuMjI3N0MyMC42ODczIDEwLjI4NTMgMjEuMDIxMSAxMC41MTMgMjEuMjM4OCAxMC45MTA4QzIxLjQ1NjYgMTEuMzA4NiAyMS40Njg2IDExLjcxMjQgMjEuMjc0OCAxMi4xMjI0QzIxLjA4MSAxMi41MzI0IDIwLjgwOTUgMTIuODM0NCAyMC40NjAzIDEzLjAyODZDMjAuMTExMSAxMy4yMjI3IDE5LjgwMzggMTMuNDAwNSAxOS41Mzg0IDEzLjU2MTlDMTkuMjczIDEzLjcyMzMgMTguOTczMiAxMy45MzA0IDE4LjYzODcgMTQuMTgzNEMxOC4zMDQzIDE0LjQzNjQgMTcuOTQ5OSAxNC43MzA5IDE3LjU3NTUgMTUuMDY3MUMxNy4yMDEgMTUuNDAzMiAxNi44MzM4IDE1Ljc1NjggMTYuNDczOSAxNi4xMjc4QzE2LjExNCAxNi40OTg3IDE1Ljc2MiAxNi44NzM4IDE1LjQxOCAxNy4yNTNDMTUuMDc0MSAxNy42MzIxIDE0Ljc0NjcgMTcuOTkzOSAxNC40MzU4IDE4LjMzODNDMTQuMTI1IDE4LjY4MjYgMTMuODAwNiAxOS4wMzQ2IDEzLjQ2MjcgMTkuMzk0MUMxMy4xMjQ4IDE5Ljc1MzcgMTIuNzg0MyAyMC4xMTUxIDEyLjQ0MTEgMjAuNDc4NEMxMi4wOTc5IDIwLjg0MTcgMTEuNzgxMSAyMS4xNzg0IDExLjQ5MDcgMjEuNDg4NUMxMS4yMDAzIDIxLjc5ODcgMTEuMDA5NyAyMi4wMDI1IDEwLjkxODcgMjIuMDk5OEMxMC44Mjc4IDIyLjE5NzEgMTAuNjQyNSAyMi4yOTkgMTAuMzYyOSAyMi40MDU0QzEwLjA4MzIgMjIuNTExOCA5Ljc5ODk1IDIyLjUyNTggOS41MTAxNSAyMi40NDc1QzkuMjIxMzYgMjIuMzY5MiA4Ljk4MzE1IDIyLjIxMzUgOC43OTU1NCAyMS45ODA0QzguNjA3OTMgMjEuNzQ3MyA4LjU2MzYxIDIxLjI5MTUgOC42NjI2IDIwLjYxMjlDOC43NjE1OCAxOS45MzQ0IDguODYwMjUgMTkuNDMzNiA4Ljk1ODYxIDE5LjExMDRDOS4wNTY5NyAxOC43ODczIDkuMTU5NzcgMTguNDc5MiA5LjI2NyAxOC4xODZDOS4zNzQyMyAxNy44OTI5IDkuNTEwNTkgMTcuNTcyMiA5LjY3NjA5IDE3LjIyNDFDOS44NDE1OSAxNi44NzU5IDEwLjA2MTcgMTYuNDIwOCAxMC4zMzY1IDE1Ljg1ODZDMTAuNjExMyAxNS4yOTYzIDEwLjkxNzMgMTQuNjkyOCAxMS4yNTQ0IDE0LjA0ODFDMTEuNTkxNSAxMy40MDMzIDExLjkzNzEgMTIuNzcwOSAxMi4yOTExIDEyLjE1MDlDMTIuNjQ1IDExLjUzMDkgMTIuOTk4NSAxMC45MjggMTMuMzUxNSAxMC4zNDIxQzEzLjcwNDUgOS43NTYyOCAxNC4wNDMgOS4yMDU5MyAxNC4zNjY5IDguNjkxMUMxNC42OTA4IDguMTc2MjggMTQuOTYzNyA3Ljc1MzcxIDE1LjE4NTYgNy40MjMzOUMxNS40MDc1IDcuMDkzMDggMTUuNjA2NCA2LjgwMzYyIDE1Ljc4MjUgNi41NTUwMUMxNS45NTg1IDYuMzA2NCAxNi4xMzM3IDYuMDYwMDYgMTYuMzA3OCA1LjgxNTk4QzE2LjQ4MiA1LjU3MTkgMTYuNjUzMyA1LjMzMjg4IDE2LjgyMTcgNS4wOTg5MUMxNi45OTAxIDQuODY0OTQgMTcuMjE2IDQuNTk3MzYgMTcuNDk5MyA0LjI5NjE1QzE3Ljc4MjYgMy45OTQ5NSAxOC4xNDYzIDMuNjI3MSAxOC41OTA0IDMuMTkyNkMxOS4wMzQ1IDIuNzU4MSAxOS4zNDA5IDIuNDU4NTUgMTkuNTA5NCAyLjI5MzkyQzE5LjY3OCAyLjEyOTMgMTkuODc1NCAyLjEwOTQ3IDIwLjEwMTcgMi4yMzQ0M0MyMC4zMjggMi4zNTkzOSAyMC40OTU5IDIuNTM4OTIgMjAuNjA1NiAyLjc3MzAyQzIwLjcxNTIgMy4wMDcxMiAyMC43NDU1IDMuMjUxMDggMjAuNjk2NiAzLjUwNDg5QzIwLjY0NzcgMy43NTg3MSAyMC4zNTg0IDQuMDU2OTMgMTkuODI4OCA0LjM5OTU3QzE5LjI5OTMgNC43NDIyIDE4Ljc5NTMgNS4xMTcxMSAxOC4zMTY4IDUuNTI0MzFDMTcuODM4NCA1LjkzMTUxIDE3LjMwNTcgNi40MDkwNyAxNi43MTg5IDYuOTU3MDFDMTYuMTMyMSA3LjUwNDk1IDE1LjU1NCA4LjA1ODUgMTQuOTg0NiA4LjYxNzY2QzE0LjQxNTEgOS4xNzY4MiAxMy44NTcxIDkuNzI5MzYgMTMuMzEwNCAxMC4yNzUzQzEyLjc2MzcgMTAuODIxMiAxMi4yNDM5IDExLjMzMzQgMTEuNzUwOSAxMS44MTE5QzExLjI1OCAxMi4yOTA1IDEwLjg1MTYgMTIuNjc0NyAxMC41MzE5IDEyLjk2NDVDMTAuMjEyMiAxMy4yNTQzIDkuOTMxMDIgMTMuNTAzIDkuNjg4NDQgMTMuNzEwNUM5LjQ0NTg2IDEzLjkxOCA5LjIwMzc2IDE0LjEyNDIgOC45NjIxNCAxNC4zMjlDOC43MjA1MSAxNC41MzM5IDguNDEyMjIgMTQuNzkxNyA4LjAzNzI4IDE1LjEwMjdDNy42NjIzMyAxNS40MTM2IDcuMzA1MiAxNS43MDQyIDYuOTY1ODcgMTUuOTc0NEM2LjYyNjU1IDE2LjI0NDcgNi4zMDYxNSAxNi40ODY3IDYuMDA0NjggMTYuNzAwNUM1LjcwMzIxIDE2LjkxNDMgNS40MDI4IDE3LjEwMTIgNS4xMDM0NSAxNy4yNjExQzQuODA0MSAxNy40MjEgNC40NjUyNyAxNy40ODI3IDQuMDg2OTcgMTcuNDQ2MkMzLjcwODY3IDE3LjQwOTggMy4zNjE1NyAxNy4yMDkgMy4wNDU2NiAxNi44NDM5QzIuNzI5NzUgMTYuNDc4OCAyLjU3NzUgMTYuMDc4NSAyLjU4ODkxIDE1LjY0MzJDMi42MDAzMyAxNS4yMDc5IDIuNzA2NzQgMTQuNzY4NCAyLjkwODE1IDE0LjMyNDhDMy4xMDk1NiAxMy44ODExIDMuMjk1NDYgMTMuNDkzOSAzLjQ2NTg2IDEzLjE2M0MzLjYzNjI1IDEyLjgzMiAzLjgwNzk5IDEyLjUxMTYgMy45ODEwNyAxMi4yMDE2QzQuMTU0MTUgMTEuODkxNiA0LjM3MjIzIDExLjQ5MDQgNC42MzUzIDEwLjk5NzlDNC44OTgzOCAxMC41MDU1IDUuMTgxNDggOS45Nzg2NCA1LjQ4NDYxIDkuNDE3MjdDNS43ODc3MyA4Ljg1NTkgNi4wODcyMyA4LjMwNDc3IDYuMzgzMSA3Ljc2MzlDNi42Nzg5OCA3LjIyMzAyIDYuOTYyMTMgNi42OTk3NiA3LjIzMjU3IDYuMTk0MTJDNy41MDMwMSA1LjY4ODQ3IDcuNzU1ODUgNS4yNDQwNCA3Ljk5MTA5IDQuODYwODFDOC4yMjYzMyA0LjQ3NzU5IDguNTc1MDUgNC4wNDY3NSA5LjAzNzI1IDMuNTY4MzFDOS40OTk0NiAzLjA4OTg3IDkuODMwMSAyLjc1NjEgMTAuMDI5MiAyLjU2NzAxQzEwLjIyODMgMi4zNzc5MSAxMC40NzEzIDIuMzUyODEgMTAuNzU4MSAyLjQ5MTY5QzExLjA0NSAyLjYzMDU3IDExLjI2MzcgMi44NDA0OSAxMS40MTQxIDMuMTIxNDZDMTEuNTY0NSAzLjQwMjQzIDExLjYxOCAzLjcwMDc5IDExLjU3NDYgNC4wMTY1M0MxMS41MzEyIDQuMzMyMjcgMTEuMTQzOSA0Ljc3Mjc4IDEwLjQxMjggNS4zMzgwN0M5LjY4MTczIDUuOTAzMzYgOS4xNzg4NiA2LjMwNzE4IDguOTA0MjEgNi41NDk1M0M4LjYyOTU1IDYuNzkxODggOC4zODI3MyA3LjAxMzY2IDguMTYzNzQgNy4yMTQ4NUM3Ljk0NDc1IDcuNDE2MDUgNy43MTU1MSA3LjYyMTYgNy40NzYwMyA3LjgzMTUxQzcuMjM2NTUgOC4wNDE0MSA2Ljk3MjI5IDguMjYzOTEgNi42ODMyNiA4LjQ5OTAxQzYuMzk0MjMgOC43MzQxIDYuMDkyMzMgOC45Njg3NiA1Ljc3NzU2IDkuMjAyOTdDNS40NjI3OSA5LjQzNzE5IDUuMTQ2OSA5LjY2MTYgNC44Mjk5IDkuODc2MjJDNC41MTI5IDEwLjA5MDggNC4yMDIxMSAxMC4yOTMyIDMuODk3NTMgMTAuNDgzNEwyLjYxNjggMTEuMTMwM1pcIixcbiAgICBzdHJva2VXaWR0aDogXCIwLjVcIixcbiAgICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCJcbiAgfSkpO1xufVxuXG52YXIgc2VsZWN0Q29sb3IgPSBmdW5jdGlvbiBzZWxlY3RDb2xvcihkYXRhKSB7XG4gIHJldHVybiBkYXRhLmFwcFN0YXRlLnNlbGVjdGVkU3R5bGUuY29sb3I7XG59O1xuXG52YXIgUXVpY2tDb2xvclNlbGVjdCA9IC8qI19fUFVSRV9fKi9SZWFjdC5tZW1vKGZ1bmN0aW9uICgpIHtcbiAgdmFyIF91c2VUaGVtZSA9IHVzZVRoZW1lKCksXG4gICAgICB0aGVtZSA9IF91c2VUaGVtZS50aGVtZTtcblxuICB2YXIgX3VzZVRMRHJhd0NvbnRleHQgPSB1c2VUTERyYXdDb250ZXh0KCksXG4gICAgICB0bHN0YXRlID0gX3VzZVRMRHJhd0NvbnRleHQudGxzdGF0ZSxcbiAgICAgIHVzZUFwcFN0YXRlID0gX3VzZVRMRHJhd0NvbnRleHQudXNlQXBwU3RhdGU7XG5cbiAgdmFyIGNvbG9yID0gdXNlQXBwU3RhdGUoc2VsZWN0Q29sb3IpO1xuICB2YXIgaGFuZGxlQ29sb3JDaGFuZ2UgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoY29sb3IpIHtcbiAgICB0bHN0YXRlLnN0eWxlKHtcbiAgICAgIGNvbG9yOiBjb2xvclxuICAgIH0pO1xuICB9LCBbdGxzdGF0ZV0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChEcm9wZG93bk1lbnUuUm9vdCwge1xuICAgIGRpcjogXCJsdHJcIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KERyb3Bkb3duTWVudUljb25UcmlnZ2VyQnV0dG9uLCB7XG4gICAgbGFiZWw6IFwiQ29sb3JcIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KEJveEljb24sIHtcbiAgICBmaWxsOiBzdHJva2VzW3RoZW1lXVtjb2xvcl0sXG4gICAgc3Ryb2tlOiBzdHJva2VzW3RoZW1lXVtjb2xvcl1cbiAgfSkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KERyb3Bkb3duTWVudS5Db250ZW50LCB7XG4gICAgc2lkZU9mZnNldDogOFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KERyb3Bkb3duTWVudS5Ecm9wZG93bk1lbnVSYWRpb0dyb3VwLCB7XG4gICAgdmFsdWU6IGNvbG9yLFxuICAgIG9uVmFsdWVDaGFuZ2U6IGhhbmRsZUNvbG9yQ2hhbmdlLFxuICAgIGFzOiBTdHlsZURyb3Bkb3duQ29udGVudFxuICB9LCBPYmplY3Qua2V5cyhzdHJva2VzW3RoZW1lXSkubWFwKGZ1bmN0aW9uIChjb2xvclN0eWxlKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRHJvcGRvd25NZW51LkRyb3Bkb3duTWVudVJhZGlvSXRlbSwge1xuICAgICAgYXM6IFN0eWxlRHJvcGRvd25JdGVtLFxuICAgICAga2V5OiBjb2xvclN0eWxlLFxuICAgICAgdGl0bGU6IGNvbG9yU3R5bGUsXG4gICAgICB2YWx1ZTogY29sb3JTdHlsZVxuICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQm94SWNvbiwge1xuICAgICAgZmlsbDogc3Ryb2tlc1t0aGVtZV1bY29sb3JTdHlsZV0sXG4gICAgICBzdHJva2U6IHN0cm9rZXNbdGhlbWVdW2NvbG9yU3R5bGVdXG4gICAgfSkpO1xuICB9KSkpKTtcbn0pO1xuXG52YXIgX3NpemVzO1xudmFyIHNpemVzID0gKF9zaXplcyA9IHt9LCBfc2l6ZXNbZXhwb3J0cy5TaXplU3R5bGUuU21hbGxdID0gNiwgX3NpemVzW2V4cG9ydHMuU2l6ZVN0eWxlLk1lZGl1bV0gPSAxMiwgX3NpemVzW2V4cG9ydHMuU2l6ZVN0eWxlLkxhcmdlXSA9IDIyLCBfc2l6ZXMpO1xuXG52YXIgc2VsZWN0U2l6ZSA9IGZ1bmN0aW9uIHNlbGVjdFNpemUoZGF0YSkge1xuICByZXR1cm4gZGF0YS5hcHBTdGF0ZS5zZWxlY3RlZFN0eWxlLnNpemU7XG59O1xuXG52YXIgUXVpY2tTaXplU2VsZWN0ID0gLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oZnVuY3Rpb24gKCkge1xuICB2YXIgX3VzZVRMRHJhd0NvbnRleHQgPSB1c2VUTERyYXdDb250ZXh0KCksXG4gICAgICB0bHN0YXRlID0gX3VzZVRMRHJhd0NvbnRleHQudGxzdGF0ZSxcbiAgICAgIHVzZUFwcFN0YXRlID0gX3VzZVRMRHJhd0NvbnRleHQudXNlQXBwU3RhdGU7XG5cbiAgdmFyIHNpemUgPSB1c2VBcHBTdGF0ZShzZWxlY3RTaXplKTtcbiAgdmFyIGNoYW5nZVNpemVTdHlsZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChzaXplKSB7XG4gICAgdGxzdGF0ZS5zdHlsZSh7XG4gICAgICBzaXplOiBzaXplXG4gICAgfSk7XG4gIH0sIFt0bHN0YXRlXSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KERyb3Bkb3duTWVudS5Sb290LCB7XG4gICAgZGlyOiBcImx0clwiXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRHJvcGRvd25NZW51SWNvblRyaWdnZXJCdXR0b24sIHtcbiAgICBsYWJlbDogXCJTaXplXCJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChDaXJjbGVJY29uLCB7XG4gICAgc2l6ZTogc2l6ZXNbc2l6ZV0sXG4gICAgc3Ryb2tlOiBcIm5vbmVcIixcbiAgICBmaWxsOiBcImN1cnJlbnRDb2xvclwiXG4gIH0pKSwgUmVhY3QuY3JlYXRlRWxlbWVudChEcm9wZG93bk1lbnUuQ29udGVudCwge1xuICAgIHNpZGVPZmZzZXQ6IDhcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChEcm9wZG93bk1lbnUuRHJvcGRvd25NZW51UmFkaW9Hcm91cCwge1xuICAgIGFzOiBTdHlsZURyb3Bkb3duQ29udGVudCxcbiAgICBkaXJlY3Rpb246IFwidmVydGljYWxcIixcbiAgICB2YWx1ZTogc2l6ZSxcbiAgICBvblZhbHVlQ2hhbmdlOiBjaGFuZ2VTaXplU3R5bGVcbiAgfSwgT2JqZWN0LmtleXMoZXhwb3J0cy5TaXplU3R5bGUpLm1hcChmdW5jdGlvbiAoc2l6ZVN0eWxlKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRHJvcGRvd25NZW51LkRyb3Bkb3duTWVudVJhZGlvSXRlbSwge1xuICAgICAga2V5OiBzaXplU3R5bGUsXG4gICAgICBhczogU3R5bGVEcm9wZG93bkl0ZW0sXG4gICAgICBpc0FjdGl2ZTogc2l6ZSA9PT0gc2l6ZVN0eWxlLFxuICAgICAgdmFsdWU6IHNpemVTdHlsZVxuICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2lyY2xlSWNvbiwge1xuICAgICAgc2l6ZTogc2l6ZXNbc2l6ZVN0eWxlXVxuICAgIH0pKTtcbiAgfSkpKSk7XG59KTtcblxudmFyIF9kYXNoZXM7XG52YXIgZGFzaGVzID0gKF9kYXNoZXMgPSB7fSwgX2Rhc2hlc1tleHBvcnRzLkRhc2hTdHlsZS5EcmF3XSA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KERhc2hEcmF3SWNvbiwgbnVsbCksIF9kYXNoZXNbZXhwb3J0cy5EYXNoU3R5bGUuU29saWRdID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGFzaFNvbGlkSWNvbiwgbnVsbCksIF9kYXNoZXNbZXhwb3J0cy5EYXNoU3R5bGUuRGFzaGVkXSA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KERhc2hEYXNoZWRJY29uLCBudWxsKSwgX2Rhc2hlc1tleHBvcnRzLkRhc2hTdHlsZS5Eb3R0ZWRdID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGFzaERvdHRlZEljb24sIG51bGwpLCBfZGFzaGVzKTtcblxudmFyIHNlbGVjdERhc2ggPSBmdW5jdGlvbiBzZWxlY3REYXNoKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuYXBwU3RhdGUuc2VsZWN0ZWRTdHlsZS5kYXNoO1xufTtcblxudmFyIFF1aWNrRGFzaFNlbGVjdCA9IC8qI19fUFVSRV9fKi9SZWFjdC5tZW1vKGZ1bmN0aW9uICgpIHtcbiAgdmFyIF91c2VUTERyYXdDb250ZXh0ID0gdXNlVExEcmF3Q29udGV4dCgpLFxuICAgICAgdGxzdGF0ZSA9IF91c2VUTERyYXdDb250ZXh0LnRsc3RhdGUsXG4gICAgICB1c2VBcHBTdGF0ZSA9IF91c2VUTERyYXdDb250ZXh0LnVzZUFwcFN0YXRlO1xuXG4gIHZhciBkYXNoID0gdXNlQXBwU3RhdGUoc2VsZWN0RGFzaCk7XG4gIHZhciBjaGFuZ2VEYXNoU3R5bGUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZGFzaCkge1xuICAgIHRsc3RhdGUuc3R5bGUoe1xuICAgICAgZGFzaDogZGFzaFxuICAgIH0pO1xuICB9LCBbdGxzdGF0ZV0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChEcm9wZG93bk1lbnUuUm9vdCwge1xuICAgIGRpcjogXCJsdHJcIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KERyb3Bkb3duTWVudUljb25UcmlnZ2VyQnV0dG9uLCB7XG4gICAgbGFiZWw6IFwiRGFzaFwiXG4gIH0sIGRhc2hlc1tkYXNoXSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRHJvcGRvd25NZW51LkNvbnRlbnQsIHtcbiAgICBzaWRlT2Zmc2V0OiA4XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRHJvcGRvd25NZW51LkRyb3Bkb3duTWVudVJhZGlvR3JvdXAsIHtcbiAgICBhczogU3R5bGVEcm9wZG93bkNvbnRlbnQsXG4gICAgZGlyZWN0aW9uOiBcInZlcnRpY2FsXCIsXG4gICAgdmFsdWU6IGRhc2gsXG4gICAgb25WYWx1ZUNoYW5nZTogY2hhbmdlRGFzaFN0eWxlXG4gIH0sIE9iamVjdC5rZXlzKGV4cG9ydHMuRGFzaFN0eWxlKS5tYXAoZnVuY3Rpb24gKGRhc2hTdHlsZSkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KERyb3Bkb3duTWVudS5Ecm9wZG93bk1lbnVSYWRpb0l0ZW0sIHtcbiAgICAgIGFzOiBTdHlsZURyb3Bkb3duSXRlbSxcbiAgICAgIGtleTogZGFzaFN0eWxlLFxuICAgICAgaXNBY3RpdmU6IGRhc2ggPT09IGRhc2hTdHlsZSxcbiAgICAgIHZhbHVlOiBkYXNoU3R5bGVcbiAgICB9LCBkYXNoZXNbZGFzaFN0eWxlXSk7XG4gIH0pKSkpO1xufSk7XG5cbnZhciBpc0ZpbGxlZFNlbGVjdG9yID0gZnVuY3Rpb24gaXNGaWxsZWRTZWxlY3RvcihkYXRhKSB7XG4gIHJldHVybiBkYXRhLmFwcFN0YXRlLnNlbGVjdGVkU3R5bGUuaXNGaWxsZWQ7XG59O1xuXG52YXIgUXVpY2tGaWxsU2VsZWN0ID0gLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oZnVuY3Rpb24gKCkge1xuICB2YXIgX3VzZVRMRHJhd0NvbnRleHQgPSB1c2VUTERyYXdDb250ZXh0KCksXG4gICAgICB0bHN0YXRlID0gX3VzZVRMRHJhd0NvbnRleHQudGxzdGF0ZSxcbiAgICAgIHVzZUFwcFN0YXRlID0gX3VzZVRMRHJhd0NvbnRleHQudXNlQXBwU3RhdGU7XG5cbiAgdmFyIGlzRmlsbGVkID0gdXNlQXBwU3RhdGUoaXNGaWxsZWRTZWxlY3Rvcik7XG4gIHZhciBoYW5kbGVJc0ZpbGxlZENoYW5nZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChpc0ZpbGxlZCkge1xuICAgIHRsc3RhdGUuc3R5bGUoe1xuICAgICAgaXNGaWxsZWQ6IGlzRmlsbGVkXG4gICAgfSk7XG4gIH0sIFt0bHN0YXRlXSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KENoZWNrYm94LlJvb3QsIHtcbiAgICBkaXI6IFwibHRyXCIsXG4gICAgYXM6IEljb25CdXR0b24sXG4gICAgYnA6IGJyZWFrcG9pbnRzLFxuICAgIGNoZWNrZWQ6IGlzRmlsbGVkLFxuICAgIG9uQ2hlY2tlZENoYW5nZTogaGFuZGxlSXNGaWxsZWRDaGFuZ2VcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChUb29sdGlwLCB7XG4gICAgbGFiZWw6IFwiRmlsbFwiXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSWNvbldyYXBwZXIsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQm94SWNvbiwgbnVsbCksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2hlY2tib3guSW5kaWNhdG9yLCBudWxsLCBSZWFjdC5jcmVhdGVFbGVtZW50KElzRmlsbGVkRmlsbEljb24sIG51bGwpKSkpKTtcbn0pO1xuXG52YXIgaXNTdHlsZU9wZW5TZWxlY3RvciA9IGZ1bmN0aW9uIGlzU3R5bGVPcGVuU2VsZWN0b3Iocykge1xuICByZXR1cm4gcy5hcHBTdGF0ZS5pc1N0eWxlT3Blbjtcbn07XG5cbmZ1bmN0aW9uIFN0eWxlUGFuZWwoKSB7XG4gIHZhciBfdXNlVExEcmF3Q29udGV4dCA9IHVzZVRMRHJhd0NvbnRleHQoKSxcbiAgICAgIHRsc3RhdGUgPSBfdXNlVExEcmF3Q29udGV4dC50bHN0YXRlLFxuICAgICAgdXNlQXBwU3RhdGUgPSBfdXNlVExEcmF3Q29udGV4dC51c2VBcHBTdGF0ZTtcblxuICB2YXIgaXNPcGVuID0gdXNlQXBwU3RhdGUoaXNTdHlsZU9wZW5TZWxlY3Rvcik7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEZsb2F0aW5nQ29udGFpbmVyLCB7XG4gICAgZGlyZWN0aW9uOiBcImNvbHVtblwiXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQnV0dG9uc1JvdywgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChRdWlja0NvbG9yU2VsZWN0LCBudWxsKSwgUmVhY3QuY3JlYXRlRWxlbWVudChRdWlja1NpemVTZWxlY3QsIG51bGwpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFF1aWNrRGFzaFNlbGVjdCwgbnVsbCksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUXVpY2tGaWxsU2VsZWN0LCBudWxsKSwgUmVhY3QuY3JlYXRlRWxlbWVudChJY29uQnV0dG9uLCB7XG4gICAgYnA6IGJyZWFrcG9pbnRzLFxuICAgIHRpdGxlOiBcIlN0eWxlXCIsXG4gICAgc2l6ZTogXCJzbWFsbFwiLFxuICAgIG9uUG9pbnRlckRvd246IHRsc3RhdGUudG9nZ2xlU3R5bGVQYW5lbFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFRvb2x0aXAsIHtcbiAgICBsYWJlbDogaXNPcGVuID8gJ0Nsb3NlJyA6ICdNb3JlJ1xuICB9LCBpc09wZW4gPyBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0SWNvbnMuQ3Jvc3MySWNvbiwgbnVsbCkgOiBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0SWNvbnMuRG90c0hvcml6b250YWxJY29uLCBudWxsKSkpKSwgaXNPcGVuICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2VsZWN0ZWRTaGFwZUNvbnRlbnQsIG51bGwpKTtcbn1cbnZhciBzaG93S2JkcyA9ICEgLyojX19QVVJFX18qL2NvcmUuVXRpbHMuaXNNb2JpbGUoKTtcblxudmFyIHNlbGVjdGVkU2hhcGVzQ291bnRTZWxlY3RvciA9IGZ1bmN0aW9uIHNlbGVjdGVkU2hhcGVzQ291bnRTZWxlY3RvcihzKSB7XG4gIHJldHVybiBzLnBhZ2VTdGF0ZS5zZWxlY3RlZElkcy5sZW5ndGg7XG59O1xuXG5mdW5jdGlvbiBTZWxlY3RlZFNoYXBlQ29udGVudCgpIHtcbiAgdmFyIF91c2VUTERyYXdDb250ZXh0MiA9IHVzZVRMRHJhd0NvbnRleHQoKSxcbiAgICAgIHRsc3RhdGUgPSBfdXNlVExEcmF3Q29udGV4dDIudGxzdGF0ZSxcbiAgICAgIHVzZUFwcFN0YXRlID0gX3VzZVRMRHJhd0NvbnRleHQyLnVzZUFwcFN0YXRlO1xuXG4gIHZhciBzZWxlY3RlZFNoYXBlc0NvdW50ID0gdXNlQXBwU3RhdGUoc2VsZWN0ZWRTaGFwZXNDb3VudFNlbGVjdG9yKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRGl2aWRlciwgbnVsbCksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2hhcGVzRnVuY3Rpb25zLCBudWxsKSwgUmVhY3QuY3JlYXRlRWxlbWVudChEaXZpZGVyLCBudWxsKSwgUmVhY3QuY3JlYXRlRWxlbWVudChBbGlnbkRpc3RyaWJ1dGUsIHtcbiAgICBoYXNUd29Pck1vcmU6IHNlbGVjdGVkU2hhcGVzQ291bnQgPiAxLFxuICAgIGhhc1RocmVlT3JNb3JlOiBzZWxlY3RlZFNoYXBlc0NvdW50ID4gMlxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChEaXZpZGVyLCBudWxsKSwgUmVhY3QuY3JlYXRlRWxlbWVudChSb3dCdXR0b24sIHtcbiAgICBicDogYnJlYWtwb2ludHMsXG4gICAgZGlzYWJsZWQ6IHNlbGVjdGVkU2hhcGVzQ291bnQgPT09IDAsXG4gICAgb25DbGljazogdGxzdGF0ZS5jb3B5XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIFwiQ29weVwiKSwgc2hvd0tiZHMgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChLYmQsIHtcbiAgICB2YXJpYW50OiBcIm1lbnVcIlxuICB9LCBcIiNDXCIpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChSb3dCdXR0b24sIHtcbiAgICBicDogYnJlYWtwb2ludHMsXG4gICAgb25DbGljazogdGxzdGF0ZS5wYXN0ZVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCBcIlBhc3RlXCIpLCBzaG93S2JkcyAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KEtiZCwge1xuICAgIHZhcmlhbnQ6IFwibWVudVwiXG4gIH0sIFwiI1ZcIikpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFJvd0J1dHRvbiwge1xuICAgIGJwOiBicmVha3BvaW50cyxcbiAgICBvbkNsaWNrOiB0bHN0YXRlLmNvcHlBc1N2Z1xuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCBcIkNvcHkgdG8gU1ZHXCIpLCBzaG93S2JkcyAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KEtiZCwge1xuICAgIHZhcmlhbnQ6IFwibWVudVwiXG4gIH0sIFwiXFx1MjFFNyNDXCIpKSk7XG59XG5cbnZhciBhY3RpdmVUb29sU2VsZWN0b3IgPSBmdW5jdGlvbiBhY3RpdmVUb29sU2VsZWN0b3Iocykge1xuICByZXR1cm4gcy5hcHBTdGF0ZS5hY3RpdmVUb29sO1xufTtcblxuZnVuY3Rpb24gU3RhdHVzQmFyKCkge1xuICB2YXIgX3VzZVRMRHJhd0NvbnRleHQgPSB1c2VUTERyYXdDb250ZXh0KCksXG4gICAgICB1c2VBcHBTdGF0ZSA9IF91c2VUTERyYXdDb250ZXh0LnVzZUFwcFN0YXRlO1xuXG4gIHZhciBhY3RpdmVUb29sID0gdXNlQXBwU3RhdGUoYWN0aXZlVG9vbFNlbGVjdG9yKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU3RhdHVzQmFyQ29udGFpbmVyLCB7XG4gICAgc2l6ZToge1xuICAgICAgJ0BzbSc6ICdzbWFsbCdcbiAgICB9XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2VjdGlvbiwgbnVsbCwgYWN0aXZlVG9vbCkpO1xufVxudmFyIFN0YXR1c0JhckNvbnRhaW5lciA9IC8qI19fUFVSRV9fKi9zdHlsZWQoJ2RpdicsIHtcbiAgaGVpZ2h0OiA0MCxcbiAgdXNlclNlbGVjdDogJ25vbmUnLFxuICBib3JkZXJUb3A6ICcxcHggc29saWQgJGJvcmRlcicsXG4gIGdyaWRBcmVhOiAnc3RhdHVzJyxcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICBjb2xvcjogJyR0ZXh0JyxcbiAganVzdGlmeUNvbnRlbnQ6ICdzcGFjZS1iZXR3ZWVuJyxcbiAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gIGJhY2tncm91bmRDb2xvcjogJyRwYW5lbCcsXG4gIGdhcDogOCxcbiAgZm9udEZhbWlseTogJyR1aScsXG4gIGZvbnRTaXplOiAnJDAnLFxuICBwYWRkaW5nOiAnMCAxNnB4JyxcbiAgdmFyaWFudHM6IHtcbiAgICBzaXplOiB7XG4gICAgICBzbWFsbDoge1xuICAgICAgICBmb250U2l6ZTogJyQxJ1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG52YXIgU2VjdGlvbiA9IC8qI19fUFVSRV9fKi9zdHlsZWQoJ2RpdicsIHtcbiAgd2hpdGVTcGFjZTogJ25vd3JhcCcsXG4gIG92ZXJmbG93OiAnaGlkZGVuJ1xufSk7XG5cbnZhciBUb29sQnV0dG9uID0gLyojX19QVVJFX18qL3N0eWxlZCgnYnV0dG9uJywge1xuICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgaGVpZ2h0OiAnMzJweCcsXG4gIHdpZHRoOiAnMzJweCcsXG4gIGNvbG9yOiAnJHRleHQnLFxuICBiYWNrZ3JvdW5kQ29sb3I6ICckcGFuZWwnLFxuICBib3JkZXJSYWRpdXM6ICc0cHgnLFxuICBwYWRkaW5nOiAnMCcsXG4gIG1hcmdpbjogJzAnLFxuICBkaXNwbGF5OiAnZ3JpZCcsXG4gIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gIG91dGxpbmU6ICdub25lJyxcbiAgYm9yZGVyOiAnbm9uZScsXG4gIHBvaW50ZXJFdmVudHM6ICdhbGwnLFxuICBmb250U2l6ZTogJyQwJyxcbiAgY3Vyc29yOiAncG9pbnRlcicsXG4gICcmID4gKic6IHtcbiAgICBncmlkUm93OiAxLFxuICAgIGdyaWRDb2x1bW46IDFcbiAgfSxcbiAgJyY6ZGlzYWJsZWQnOiB7XG4gICAgb3BhY2l0eTogJzAuNSdcbiAgfSxcbiAgJyYgPiBzcGFuJzoge1xuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgIGFsaWduSXRlbXM6ICdjZW50ZXInXG4gIH1cbn0pO1xudmFyIFByaW1hcnlUb29sQnV0dG9uID0gLyojX19QVVJFX18qL3N0eWxlZChUb29sQnV0dG9uLCB7XG4gIHZhcmlhbnRzOiB7XG4gICAgYnA6IHtcbiAgICAgIG1vYmlsZToge1xuICAgICAgICBoZWlnaHQ6IDQ0LFxuICAgICAgICB3aWR0aDogNDQsXG4gICAgICAgICcmIHN2ZzpudGgtb2YtdHlwZSgxKSc6IHtcbiAgICAgICAgICBoZWlnaHQ6ICcyMHB4JyxcbiAgICAgICAgICB3aWR0aDogJzIwcHgnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzbWFsbDoge1xuICAgICAgICAnJjpob3Zlcjpub3QoOmRpc2FibGVkKSc6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICckaG92ZXInXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtZWRpdW06IHt9LFxuICAgICAgbGFyZ2U6IHt9XG4gICAgfSxcbiAgICBpc0FjdGl2ZToge1xuICAgICAgXCJ0cnVlXCI6IHtcbiAgICAgICAgY29sb3I6ICckc2VsZWN0ZWQnXG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbnZhciBTZWNvbmRhcnlUb29sQnV0dG9uID0gLyojX19QVVJFX18qL3N0eWxlZChUb29sQnV0dG9uLCB7XG4gIHZhcmlhbnRzOiB7XG4gICAgYnA6IHtcbiAgICAgIG1vYmlsZToge1xuICAgICAgICBoZWlnaHQ6IDQ0LFxuICAgICAgICB3aWR0aDogNDQsXG4gICAgICAgICcmIHN2ZzpudGgtb2YtdHlwZSgxKSc6IHtcbiAgICAgICAgICBoZWlnaHQ6ICcxOHB4JyxcbiAgICAgICAgICB3aWR0aDogJzE4cHgnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzbWFsbDoge1xuICAgICAgICAnJjpob3Zlcjpub3QoOmRpc2FibGVkKSc6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICckaG92ZXInXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtZWRpdW06IHt9LFxuICAgICAgbGFyZ2U6IHt9XG4gICAgfSxcbiAgICBpc0FjdGl2ZToge1xuICAgICAgXCJ0cnVlXCI6IHtcbiAgICAgICAgY29sb3I6ICckc2VsZWN0ZWQnXG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbnZhciBUZXJ0aWFyeVRvb2xCdXR0b24gPSAvKiNfX1BVUkVfXyovc3R5bGVkKFRvb2xCdXR0b24sIHtcbiAgdmFyaWFudHM6IHtcbiAgICBicDoge1xuICAgICAgbW9iaWxlOiB7XG4gICAgICAgIGhlaWdodDogMzIsXG4gICAgICAgIHdpZHRoOiA0NCxcbiAgICAgICAgJyYgc3ZnOm50aC1vZi10eXBlKDEpJzoge1xuICAgICAgICAgIGhlaWdodDogJzE2cHgnLFxuICAgICAgICAgIHdpZHRoOiAnMTZweCdcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNtYWxsOiB7XG4gICAgICAgIGhlaWdodDogNDAsXG4gICAgICAgIHdpZHRoOiA0MCxcbiAgICAgICAgJyYgc3ZnOm50aC1vZi10eXBlKDEpJzoge1xuICAgICAgICAgIGhlaWdodDogJzE4cHgnLFxuICAgICAgICAgIHdpZHRoOiAnMThweCdcbiAgICAgICAgfSxcbiAgICAgICAgJyY6aG92ZXI6bm90KDpkaXNhYmxlZCknOiB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnJGhvdmVyJ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWVkaXVtOiB7fSxcbiAgICAgIGxhcmdlOiB7fVxuICAgIH1cbiAgfVxufSk7XG5mdW5jdGlvbiBQcmltYXJ5QnV0dG9uKF9yZWYpIHtcbiAgdmFyIGxhYmVsID0gX3JlZi5sYWJlbCxcbiAgICAgIGtiZCA9IF9yZWYua2JkLFxuICAgICAgb25DbGljayA9IF9yZWYub25DbGljayxcbiAgICAgIG9uRG91YmxlQ2xpY2sgPSBfcmVmLm9uRG91YmxlQ2xpY2ssXG4gICAgICBpc0FjdGl2ZSA9IF9yZWYuaXNBY3RpdmUsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFRvb2x0aXAsIHtcbiAgICBsYWJlbDogbGFiZWxbMF0udG9VcHBlckNhc2UoKSArIGxhYmVsLnNsaWNlKDEpLFxuICAgIGtiZDoga2JkXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUHJpbWFyeVRvb2xCdXR0b24sIHtcbiAgICBuYW1lOiBsYWJlbCxcbiAgICBicDoge1xuICAgICAgJ0Bpbml0aWFsJzogJ21vYmlsZScsXG4gICAgICAnQHNtJzogJ3NtYWxsJyxcbiAgICAgICdAbWQnOiAnbWVkaXVtJyxcbiAgICAgICdAbGcnOiAnbGFyZ2UnXG4gICAgfSxcbiAgICBvbkNsaWNrOiBvbkNsaWNrLFxuICAgIG9uRG91YmxlQ2xpY2s6IG9uRG91YmxlQ2xpY2ssXG4gICAgaXNBY3RpdmU6IGlzQWN0aXZlXG4gIH0sIGNoaWxkcmVuKSk7XG59XG5mdW5jdGlvbiBTZWNvbmRhcnlCdXR0b24oX3JlZjIpIHtcbiAgdmFyIGxhYmVsID0gX3JlZjIubGFiZWwsXG4gICAgICBrYmQgPSBfcmVmMi5rYmQsXG4gICAgICBvbkNsaWNrID0gX3JlZjIub25DbGljayxcbiAgICAgIG9uRG91YmxlQ2xpY2sgPSBfcmVmMi5vbkRvdWJsZUNsaWNrLFxuICAgICAgaXNBY3RpdmUgPSBfcmVmMi5pc0FjdGl2ZSxcbiAgICAgIGNoaWxkcmVuID0gX3JlZjIuY2hpbGRyZW47XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFRvb2x0aXAsIHtcbiAgICBsYWJlbDogbGFiZWxbMF0udG9VcHBlckNhc2UoKSArIGxhYmVsLnNsaWNlKDEpLFxuICAgIGtiZDoga2JkXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2Vjb25kYXJ5VG9vbEJ1dHRvbiwge1xuICAgIG5hbWU6IGxhYmVsLFxuICAgIGJwOiB7XG4gICAgICAnQGluaXRpYWwnOiAnbW9iaWxlJyxcbiAgICAgICdAc20nOiAnc21hbGwnLFxuICAgICAgJ0BtZCc6ICdtZWRpdW0nLFxuICAgICAgJ0BsZyc6ICdsYXJnZSdcbiAgICB9LFxuICAgIG9uQ2xpY2s6IG9uQ2xpY2ssXG4gICAgb25Eb3VibGVDbGljazogb25Eb3VibGVDbGljayxcbiAgICBpc0FjdGl2ZTogaXNBY3RpdmVcbiAgfSwgY2hpbGRyZW4pKTtcbn1cbmZ1bmN0aW9uIFRlcnRpYXJ5QnV0dG9uKF9yZWYzKSB7XG4gIHZhciBsYWJlbCA9IF9yZWYzLmxhYmVsLFxuICAgICAga2JkID0gX3JlZjMua2JkLFxuICAgICAgb25DbGljayA9IF9yZWYzLm9uQ2xpY2ssXG4gICAgICBvbkRvdWJsZUNsaWNrID0gX3JlZjMub25Eb3VibGVDbGljayxcbiAgICAgIGNoaWxkcmVuID0gX3JlZjMuY2hpbGRyZW47XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFRvb2x0aXAsIHtcbiAgICBsYWJlbDogbGFiZWxbMF0udG9VcHBlckNhc2UoKSArIGxhYmVsLnNsaWNlKDEpLFxuICAgIGtiZDoga2JkXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGVydGlhcnlUb29sQnV0dG9uLCB7XG4gICAgbmFtZTogbGFiZWwsXG4gICAgYnA6IHtcbiAgICAgICdAaW5pdGlhbCc6ICdtb2JpbGUnLFxuICAgICAgJ0BzbSc6ICdzbWFsbCcsXG4gICAgICAnQG1kJzogJ21lZGl1bScsXG4gICAgICAnQGxnJzogJ2xhcmdlJ1xuICAgIH0sXG4gICAgb25DbGljazogb25DbGljayxcbiAgICBvbkRvdWJsZUNsaWNrOiBvbkRvdWJsZUNsaWNrXG4gIH0sIGNoaWxkcmVuKSk7XG59XG52YXIgVGVydGlhcnlCdXR0b25zQ29udGFpbmVyID0gLyojX19QVVJFX18qL3N0eWxlZChGbG9hdGluZ0NvbnRhaW5lciwge1xuICBib3hTaGFkb3c6ICckMycsXG4gIHZhcmlhbnRzOiB7XG4gICAgYnA6IHtcbiAgICAgIG1vYmlsZToge1xuICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbidcbiAgICAgIH0sXG4gICAgICBzbWFsbDoge1xuICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAgZmxleERpcmVjdGlvbjogJ3JvdydcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuXG52YXIgVW5kb1JlZG8gPSAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyhmdW5jdGlvbiAoKSB7XG4gIHZhciBfdXNlVExEcmF3Q29udGV4dCA9IHVzZVRMRHJhd0NvbnRleHQoKSxcbiAgICAgIHRsc3RhdGUgPSBfdXNlVExEcmF3Q29udGV4dC50bHN0YXRlO1xuXG4gIHZhciBoYW5kbGVEZWxldGUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZVtcImRlbGV0ZVwiXSgpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICB2YXIgaGFuZGxlQ2xlYXIgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5jbGVhcigpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChUZXJ0aWFyeUJ1dHRvbnNDb250YWluZXIsIHtcbiAgICBicDoge1xuICAgICAgJ0Bpbml0aWFsJzogJ21vYmlsZScsXG4gICAgICAnQHNtJzogJ3NtYWxsJ1xuICAgIH1cbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChUZXJ0aWFyeUJ1dHRvbiwge1xuICAgIGxhYmVsOiBcIlVuZG9cIixcbiAgICBrYmQ6IFwiI1pcIixcbiAgICBvbkNsaWNrOiB0bHN0YXRlLnVuZG9cbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChTdmdVbmRvLCBudWxsKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGVydGlhcnlCdXR0b24sIHtcbiAgICBsYWJlbDogXCJSZWRvXCIsXG4gICAga2JkOiBcIiNcXHUyMUU3XCIsXG4gICAgb25DbGljazogdGxzdGF0ZS5yZWRvXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU3ZnUmVkbywgbnVsbCkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFRlcnRpYXJ5QnV0dG9uLCB7XG4gICAgbGFiZWw6IFwiRGVsZXRlXCIsXG4gICAga2JkOiBcIlxcdTIzMkJcIixcbiAgICBvbkNsaWNrOiBoYW5kbGVEZWxldGUsXG4gICAgb25Eb3VibGVDbGljazogaGFuZGxlQ2xlYXJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChTdmdUcmFzaCwgbnVsbCkpKTtcbn0pO1xuXG52YXIgWm9vbSA9IC8qI19fUFVSRV9fKi9SZWFjdC5tZW1vKGZ1bmN0aW9uICgpIHtcbiAgdmFyIF91c2VUTERyYXdDb250ZXh0ID0gdXNlVExEcmF3Q29udGV4dCgpLFxuICAgICAgdGxzdGF0ZSA9IF91c2VUTERyYXdDb250ZXh0LnRsc3RhdGU7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGVydGlhcnlCdXR0b25zQ29udGFpbmVyLCB7XG4gICAgYnA6IHtcbiAgICAgICdAaW5pdGlhbCc6ICdtb2JpbGUnLFxuICAgICAgJ0BzbSc6ICdzbWFsbCdcbiAgICB9XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGVydGlhcnlCdXR0b24sIHtcbiAgICBsYWJlbDogXCJab29tIE91dFwiLFxuICAgIGtiZDogXCIjXFx1MjIxMlwiLFxuICAgIG9uQ2xpY2s6IHRsc3RhdGUuem9vbU91dFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0SWNvbnMuWm9vbU91dEljb24sIG51bGwpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChUZXJ0aWFyeUJ1dHRvbiwge1xuICAgIGxhYmVsOiBcIlpvb20gSW5cIixcbiAgICBrYmQ6IFwiIytcIixcbiAgICBvbkNsaWNrOiB0bHN0YXRlLnpvb21JblxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KHJlYWN0SWNvbnMuWm9vbUluSWNvbiwgbnVsbCkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFpvb21Db3VudGVyLCBudWxsKSk7XG59KTtcblxudmFyIHpvb21TZWxlY3RvciA9IGZ1bmN0aW9uIHpvb21TZWxlY3RvcihzKSB7XG4gIHJldHVybiBzLnBhZ2VTdGF0ZS5jYW1lcmEuem9vbTtcbn07XG5cbmZ1bmN0aW9uIFpvb21Db3VudGVyKCkge1xuICB2YXIgX3VzZVRMRHJhd0NvbnRleHQyID0gdXNlVExEcmF3Q29udGV4dCgpLFxuICAgICAgdGxzdGF0ZSA9IF91c2VUTERyYXdDb250ZXh0Mi50bHN0YXRlLFxuICAgICAgdXNlQXBwU3RhdGUgPSBfdXNlVExEcmF3Q29udGV4dDIudXNlQXBwU3RhdGU7XG5cbiAgdmFyIHpvb20gPSB1c2VBcHBTdGF0ZSh6b29tU2VsZWN0b3IpO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChUZXJ0aWFyeUJ1dHRvbiwge1xuICAgIGxhYmVsOiBcIlJlc2V0IFpvb21cIixcbiAgICBrYmQ6IFwiXFx1MjFFNzBcIixcbiAgICBvbkNsaWNrOiB0bHN0YXRlLnpvb21Ub0FjdHVhbCxcbiAgICBvbkRvdWJsZUNsaWNrOiB0bHN0YXRlLnpvb21Ub0ZpdFxuICB9LCBNYXRoLnJvdW5kKHpvb20gKiAxMDApLCBcIiVcIik7XG59XG5cbnZhciBpc0VtcHR5Q2FudmFzU2VsZWN0b3IgPSBmdW5jdGlvbiBpc0VtcHR5Q2FudmFzU2VsZWN0b3Iocykge1xuICByZXR1cm4gT2JqZWN0LmtleXMocy5wYWdlLnNoYXBlcykubGVuZ3RoID4gMCAmJiBzLmFwcFN0YXRlLmlzRW1wdHlDYW52YXM7XG59O1xuXG52YXIgQmFja1RvQ29udGVudCA9IC8qI19fUFVSRV9fKi9SZWFjdC5tZW1vKGZ1bmN0aW9uICgpIHtcbiAgdmFyIF91c2VUTERyYXdDb250ZXh0ID0gdXNlVExEcmF3Q29udGV4dCgpLFxuICAgICAgdGxzdGF0ZSA9IF91c2VUTERyYXdDb250ZXh0LnRsc3RhdGUsXG4gICAgICB1c2VBcHBTdGF0ZSA9IF91c2VUTERyYXdDb250ZXh0LnVzZUFwcFN0YXRlO1xuXG4gIHZhciBpc0VtcHR5Q2FudmFzID0gdXNlQXBwU3RhdGUoaXNFbXB0eUNhbnZhc1NlbGVjdG9yKTtcbiAgaWYgKCFpc0VtcHR5Q2FudmFzKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQmFja1RvQ29udGVudEJ1dHRvbiwgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChSb3dCdXR0b24sIHtcbiAgICBvbkNsaWNrOiB0bHN0YXRlLnpvb21Ub0NvbnRlbnRcbiAgfSwgXCJCYWNrIHRvIGNvbnRlbnRcIikpO1xufSk7XG52YXIgQmFja1RvQ29udGVudEJ1dHRvbiA9IC8qI19fUFVSRV9fKi9zdHlsZWQoRmxvYXRpbmdDb250YWluZXIsIHtcbiAgcG9pbnRlckV2ZW50czogJ2FsbCcsXG4gIHdpZHRoOiAnZml0LWNvbnRlbnQnLFxuICBncmlkUm93OiAxLFxuICBmbGV4R3JvdzogMixcbiAgZGlzcGxheTogJ2Jsb2NrJ1xufSk7XG5cbnZhciBhY3RpdmVUb29sU2VsZWN0b3IkMSA9IGZ1bmN0aW9uIGFjdGl2ZVRvb2xTZWxlY3RvcihzKSB7XG4gIHJldHVybiBzLmFwcFN0YXRlLmFjdGl2ZVRvb2w7XG59O1xuXG52YXIgaXNUb29sTG9ja2VkU2VsZWN0b3IgPSBmdW5jdGlvbiBpc1Rvb2xMb2NrZWRTZWxlY3RvcihzKSB7XG4gIHJldHVybiBzLmFwcFN0YXRlLmlzVG9vbExvY2tlZDtcbn07XG5cbnZhciBpc0RlYnVnTW9kZVNlbGVjdG9yJDEgPSBmdW5jdGlvbiBpc0RlYnVnTW9kZVNlbGVjdG9yKHMpIHtcbiAgcmV0dXJuIHMuc2V0dGluZ3MuaXNEZWJ1Z01vZGU7XG59O1xuXG52YXIgVG9vbHNQYW5lbCA9IC8qI19fUFVSRV9fKi9SZWFjdC5tZW1vKGZ1bmN0aW9uICgpIHtcbiAgdmFyIF91c2VUTERyYXdDb250ZXh0ID0gdXNlVExEcmF3Q29udGV4dCgpLFxuICAgICAgdGxzdGF0ZSA9IF91c2VUTERyYXdDb250ZXh0LnRsc3RhdGUsXG4gICAgICB1c2VBcHBTdGF0ZSA9IF91c2VUTERyYXdDb250ZXh0LnVzZUFwcFN0YXRlO1xuXG4gIHZhciBhY3RpdmVUb29sID0gdXNlQXBwU3RhdGUoYWN0aXZlVG9vbFNlbGVjdG9yJDEpO1xuICB2YXIgaXNUb29sTG9ja2VkID0gdXNlQXBwU3RhdGUoaXNUb29sTG9ja2VkU2VsZWN0b3IpO1xuICB2YXIgaXNEZWJ1Z01vZGUgPSB1c2VBcHBTdGF0ZShpc0RlYnVnTW9kZVNlbGVjdG9yJDEpO1xuICB2YXIgc2VsZWN0U2VsZWN0VG9vbCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB0bHN0YXRlLnNlbGVjdFRvb2woJ3NlbGVjdCcpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICB2YXIgc2VsZWN0RHJhd1Rvb2wgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdGxzdGF0ZS5zZWxlY3RUb29sKGV4cG9ydHMuVExEcmF3U2hhcGVUeXBlLkRyYXcpO1xuICB9LCBbdGxzdGF0ZV0pO1xuICB2YXIgc2VsZWN0UmVjdGFuZ2xlVG9vbCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB0bHN0YXRlLnNlbGVjdFRvb2woZXhwb3J0cy5UTERyYXdTaGFwZVR5cGUuUmVjdGFuZ2xlKTtcbiAgfSwgW3Rsc3RhdGVdKTtcbiAgdmFyIHNlbGVjdEVsbGlwc2VUb29sID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHRsc3RhdGUuc2VsZWN0VG9vbChleHBvcnRzLlRMRHJhd1NoYXBlVHlwZS5FbGxpcHNlKTtcbiAgfSwgW3Rsc3RhdGVdKTsgLy8gY29uc3Qgc2VsZWN0QXJyb3dUb29sID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAvLyAgIHRsc3RhdGUuc2VsZWN0VG9vbChUTERyYXdTaGFwZVR5cGUuRWxsaXBzZSlcbiAgLy8gfSwgW3Rsc3RhdGVdKVxuICAvLyBjb25zdCBzZWxlY3RUZXh0VG9vbCA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgLy8gICB0bHN0YXRlLnNlbGVjdFRvb2woVExEcmF3U2hhcGVUeXBlLkVsbGlwc2UpXG4gIC8vIH0sIFt0bHN0YXRlXSlcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChUb29sc1BhbmVsQ29udGFpbmVyLCBudWxsLCBSZWFjdC5jcmVhdGVFbGVtZW50KExlZnRXcmFwLCB7XG4gICAgc2l6ZToge1xuICAgICAgJ0Bpbml0aWFsJzogJ21vYmlsZScsXG4gICAgICAnQHNtJzogJ3NtYWxsJ1xuICAgIH1cbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChab29tLCBudWxsKSwgUmVhY3QuY3JlYXRlRWxlbWVudChGbG9hdGluZ0NvbnRhaW5lciwgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChTZWNvbmRhcnlCdXR0b24sIHtcbiAgICBsYWJlbDogJ1NlbGVjdCcsXG4gICAga2JkOiAnMScsXG4gICAgb25DbGljazogc2VsZWN0U2VsZWN0VG9vbCxcbiAgICBpc0FjdGl2ZTogYWN0aXZlVG9vbCA9PT0gJ3NlbGVjdCdcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChyZWFjdEljb25zLkN1cnNvckFycm93SWNvbiwgbnVsbCkpKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2VudGVyV3JhcCwgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChCYWNrVG9Db250ZW50LCBudWxsKSwgUmVhY3QuY3JlYXRlRWxlbWVudChGbG9hdGluZ0NvbnRhaW5lciwgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChQcmltYXJ5QnV0dG9uLCB7XG4gICAga2JkOiAnMicsXG4gICAgbGFiZWw6IGV4cG9ydHMuVExEcmF3U2hhcGVUeXBlLkRyYXcsXG4gICAgb25DbGljazogc2VsZWN0RHJhd1Rvb2wsXG4gICAgaXNBY3RpdmU6IGFjdGl2ZVRvb2wgPT09IGV4cG9ydHMuVExEcmF3U2hhcGVUeXBlLkRyYXdcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChyZWFjdEljb25zLlBlbmNpbDFJY29uLCBudWxsKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUHJpbWFyeUJ1dHRvbiwge1xuICAgIGtiZDogJzMnLFxuICAgIGxhYmVsOiBleHBvcnRzLlRMRHJhd1NoYXBlVHlwZS5SZWN0YW5nbGUsXG4gICAgb25DbGljazogc2VsZWN0UmVjdGFuZ2xlVG9vbCxcbiAgICBpc0FjdGl2ZTogYWN0aXZlVG9vbCA9PT0gZXhwb3J0cy5UTERyYXdTaGFwZVR5cGUuUmVjdGFuZ2xlXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3RJY29ucy5TcXVhcmVJY29uLCBudWxsKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUHJpbWFyeUJ1dHRvbiwge1xuICAgIGtiZDogJzQnLFxuICAgIGxhYmVsOiBleHBvcnRzLlRMRHJhd1NoYXBlVHlwZS5EcmF3LFxuICAgIG9uQ2xpY2s6IHNlbGVjdEVsbGlwc2VUb29sLFxuICAgIGlzQWN0aXZlOiBhY3RpdmVUb29sID09PSBleHBvcnRzLlRMRHJhd1NoYXBlVHlwZS5FbGxpcHNlXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3RJY29ucy5DaXJjbGVJY29uLCBudWxsKSkpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChSaWdodFdyYXAsIHtcbiAgICBzaXplOiB7XG4gICAgICAnQGluaXRpYWwnOiAnbW9iaWxlJyxcbiAgICAgICdAc20nOiAnc21hbGwnXG4gICAgfVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KEZsb2F0aW5nQ29udGFpbmVyLCBudWxsLCBSZWFjdC5jcmVhdGVFbGVtZW50KFNlY29uZGFyeUJ1dHRvbiwge1xuICAgIGtiZDogJzcnLFxuICAgIGxhYmVsOiAnTG9jayBUb29sJyxcbiAgICBvbkNsaWNrOiB0bHN0YXRlLnRvZ2dsZVRvb2xMb2NrLFxuICAgIGlzQWN0aXZlOiBpc1Rvb2xMb2NrZWRcbiAgfSwgaXNUb29sTG9ja2VkID8gUmVhY3QuY3JlYXRlRWxlbWVudChyZWFjdEljb25zLkxvY2tDbG9zZWRJY29uLCBudWxsKSA6IFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3RJY29ucy5Mb2NrT3BlbjFJY29uLCBudWxsKSkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFVuZG9SZWRvLCBudWxsKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU3RhdHVzV3JhcCwgbnVsbCwgaXNEZWJ1Z01vZGUgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChTdGF0dXNCYXIsIG51bGwpKSk7XG59KTtcbnZhciBUb29sc1BhbmVsQ29udGFpbmVyID0gLyojX19QVVJFX18qL3N0eWxlZCgnZGl2Jywge1xuICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgYm90dG9tOiAwLFxuICBsZWZ0OiAwLFxuICByaWdodDogMCxcbiAgd2lkdGg6ICcxMDAlJyxcbiAgbWluV2lkdGg6IDAsXG4gIG1heFdpZHRoOiAnMTAwJScsXG4gIGRpc3BsYXk6ICdncmlkJyxcbiAgZ3JpZFRlbXBsYXRlQ29sdW1uczogJzFmciBhdXRvIDFmcicsXG4gIHBhZGRpbmc6ICcwJyxcbiAgYWxpZ25JdGVtczogJ2ZsZXgtZW5kJyxcbiAgekluZGV4OiAyMDAsXG4gIGdyaWRHYXA6ICckNCcsXG4gIGdyaWRSb3dHYXA6ICckNCcsXG4gIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgJyYgPiBkaXYgPiAqJzoge1xuICAgIHBvaW50ZXJFdmVudHM6ICdhbGwnXG4gIH1cbn0pO1xudmFyIENlbnRlcldyYXAgPSAvKiNfX1BVUkVfXyovc3R5bGVkKCdkaXYnLCB7XG4gIGdyaWRSb3c6IDEsXG4gIGdyaWRDb2x1bW46IDIsXG4gIGRpc3BsYXk6ICdmbGV4JyxcbiAgd2lkdGg6ICdmaXQtY29udGVudCcsXG4gIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLFxuICBnYXA6IDEyXG59KTtcbnZhciBMZWZ0V3JhcCA9IC8qI19fUFVSRV9fKi9zdHlsZWQoJ2RpdicsIHtcbiAgZ3JpZFJvdzogMSxcbiAgZ3JpZENvbHVtbjogMSxcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICBwYWRkaW5nTGVmdDogJyQzJyxcbiAgdmFyaWFudHM6IHtcbiAgICBzaXplOiB7XG4gICAgICBtb2JpbGU6IHtcbiAgICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICAgIGp1c3RpZnlDb250ZW50OiAnZmxleC1lbmQnLFxuICAgICAgICBhbGlnbkl0ZW1zOiAnZmxleC1zdGFydCcsXG4gICAgICAgICcmID4gKjpudGgtb2YtdHlwZSgxKSc6IHtcbiAgICAgICAgICBtYXJnaW5Cb3R0b206ICc4cHgnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzbWFsbDoge1xuICAgICAgICBmbGV4RGlyZWN0aW9uOiAncm93JyxcbiAgICAgICAgYWxpZ25JdGVtczogJ2ZsZXgtZW5kJyxcbiAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdzcGFjZS1iZXR3ZWVuJyxcbiAgICAgICAgJyYgPiAqOm50aC1vZi10eXBlKDEpJzoge1xuICAgICAgICAgIG1hcmdpbkJvdHRvbTogJzBweCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG52YXIgUmlnaHRXcmFwID0gLyojX19QVVJFX18qL3N0eWxlZCgnZGl2Jywge1xuICBncmlkUm93OiAxLFxuICBncmlkQ29sdW1uOiAzLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHBhZGRpbmdSaWdodDogJyQzJyxcbiAgdmFyaWFudHM6IHtcbiAgICBzaXplOiB7XG4gICAgICBtb2JpbGU6IHtcbiAgICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbi1yZXZlcnNlJyxcbiAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdmbGV4LWVuZCcsXG4gICAgICAgIGFsaWduSXRlbXM6ICdmbGV4LWVuZCcsXG4gICAgICAgICcmID4gKjpudGgtb2YtdHlwZSgyKSc6IHtcbiAgICAgICAgICBtYXJnaW5Cb3R0b206ICc4cHgnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzbWFsbDoge1xuICAgICAgICBmbGV4RGlyZWN0aW9uOiAncm93JyxcbiAgICAgICAgYWxpZ25JdGVtczogJ2ZsZXgtZW5kJyxcbiAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdzcGFjZS1iZXR3ZWVuJyxcbiAgICAgICAgJyYgPiAqOm50aC1vZi10eXBlKDIpJzoge1xuICAgICAgICAgIG1hcmdpbkJvdHRvbTogJzBweCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG52YXIgU3RhdHVzV3JhcCA9IC8qI19fUFVSRV9fKi9zdHlsZWQoJ2RpdicsIHtcbiAgZ3JpZFJvdzogMixcbiAgZ3JpZENvbHVtbjogJzEgLyBzcGFuIDMnXG59KTtcblxudmFyIFRMRFIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUTERSKCkge31cblxuICBUTERSLmdldFNoYXBlVXRpbHMgPSBmdW5jdGlvbiBnZXRTaGFwZVV0aWxzJDEoc2hhcGUpIHtcbiAgICByZXR1cm4gZ2V0U2hhcGVVdGlscyhzaGFwZSk7XG4gIH07XG5cbiAgVExEUi5nZXRTZWxlY3RlZFNoYXBlcyA9IGZ1bmN0aW9uIGdldFNlbGVjdGVkU2hhcGVzKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5wYWdlU3RhdGUuc2VsZWN0ZWRJZHMubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuIGRhdGEucGFnZS5zaGFwZXNbaWRdO1xuICAgIH0pO1xuICB9O1xuXG4gIFRMRFIuc2NyZWVuVG9Xb3JsZCA9IGZ1bmN0aW9uIHNjcmVlblRvV29ybGQoZGF0YSwgcG9pbnQpIHtcbiAgICB2YXIgY2FtZXJhID0gZGF0YS5wYWdlU3RhdGUuY2FtZXJhO1xuICAgIHJldHVybiBjb3JlLlZlYy5zdWIoY29yZS5WZWMuZGl2KHBvaW50LCBjYW1lcmEuem9vbSksIGNhbWVyYS5wb2ludCk7XG4gIH07XG5cbiAgVExEUi5nZXRWaWV3cG9ydCA9IGZ1bmN0aW9uIGdldFZpZXdwb3J0KGRhdGEpIHtcbiAgICB2YXIgX3RoaXMkc2NyZWVuVG9Xb3JsZCA9IHRoaXMuc2NyZWVuVG9Xb3JsZChkYXRhLCBbMCwgMF0pLFxuICAgICAgICBtaW5YID0gX3RoaXMkc2NyZWVuVG9Xb3JsZFswXSxcbiAgICAgICAgbWluWSA9IF90aGlzJHNjcmVlblRvV29ybGRbMV07XG5cbiAgICB2YXIgX3RoaXMkc2NyZWVuVG9Xb3JsZDIgPSB0aGlzLnNjcmVlblRvV29ybGQoZGF0YSwgW3dpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHRdKSxcbiAgICAgICAgbWF4WCA9IF90aGlzJHNjcmVlblRvV29ybGQyWzBdLFxuICAgICAgICBtYXhZID0gX3RoaXMkc2NyZWVuVG9Xb3JsZDJbMV07XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWluWDogbWluWCxcbiAgICAgIG1pblk6IG1pblksXG4gICAgICBtYXhYOiBtYXhYLFxuICAgICAgbWF4WTogbWF4WSxcbiAgICAgIGhlaWdodDogbWF4WCAtIG1pblgsXG4gICAgICB3aWR0aDogbWF4WSAtIG1pbllcbiAgICB9O1xuICB9O1xuXG4gIFRMRFIuZ2V0Q2FtZXJhWm9vbSA9IGZ1bmN0aW9uIGdldENhbWVyYVpvb20oem9vbSkge1xuICAgIHJldHVybiBjb3JlLlV0aWxzLmNsYW1wKHpvb20sIDAuMSwgNSk7XG4gIH07XG5cbiAgVExEUi5nZXRDdXJyZW50Q2FtZXJhID0gZnVuY3Rpb24gZ2V0Q3VycmVudENhbWVyYShkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEucGFnZVN0YXRlLmNhbWVyYTtcbiAgfTtcblxuICBUTERSLmdldFBhZ2UgPSBmdW5jdGlvbiBnZXRQYWdlKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5wYWdlO1xuICB9O1xuXG4gIFRMRFIuZ2V0UGFnZVN0YXRlID0gZnVuY3Rpb24gZ2V0UGFnZVN0YXRlKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5wYWdlU3RhdGU7XG4gIH07XG5cbiAgVExEUi5nZXRTZWxlY3RlZElkcyA9IGZ1bmN0aW9uIGdldFNlbGVjdGVkSWRzKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5wYWdlU3RhdGUuc2VsZWN0ZWRJZHM7XG4gIH07XG5cbiAgVExEUi5nZXRTaGFwZXMgPSBmdW5jdGlvbiBnZXRTaGFwZXMoZGF0YSkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKGRhdGEucGFnZS5zaGFwZXMpO1xuICB9O1xuXG4gIFRMRFIuZ2V0Q2FtZXJhID0gZnVuY3Rpb24gZ2V0Q2FtZXJhKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5wYWdlU3RhdGUuY2FtZXJhO1xuICB9O1xuXG4gIFRMRFIuZ2V0U2hhcGUgPSBmdW5jdGlvbiBnZXRTaGFwZShkYXRhLCBzaGFwZUlkKSB7XG4gICAgcmV0dXJuIGRhdGEucGFnZS5zaGFwZXNbc2hhcGVJZF07XG4gIH07XG5cbiAgVExEUi5nZXRCb3VuZHMgPSBmdW5jdGlvbiBnZXRCb3VuZHMoc2hhcGUpIHtcbiAgICByZXR1cm4gZ2V0U2hhcGVVdGlscyhzaGFwZSkuZ2V0Qm91bmRzKHNoYXBlKTtcbiAgfTtcblxuICBUTERSLmdldFJvdGF0ZWRCb3VuZHMgPSBmdW5jdGlvbiBnZXRSb3RhdGVkQm91bmRzKHNoYXBlKSB7XG4gICAgcmV0dXJuIGdldFNoYXBlVXRpbHMoc2hhcGUpLmdldFJvdGF0ZWRCb3VuZHMoc2hhcGUpO1xuICB9O1xuXG4gIFRMRFIuZ2V0U2VsZWN0ZWRCb3VuZHMgPSBmdW5jdGlvbiBnZXRTZWxlY3RlZEJvdW5kcyhkYXRhKSB7XG4gICAgcmV0dXJuIGNvcmUuVXRpbHMuZ2V0Q29tbW9uQm91bmRzKHRoaXMuZ2V0U2VsZWN0ZWRTaGFwZXMoZGF0YSkubWFwKGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgcmV0dXJuIGdldFNoYXBlVXRpbHMoc2hhcGUpLmdldEJvdW5kcyhzaGFwZSk7XG4gICAgfSkpO1xuICB9O1xuXG4gIFRMRFIuZ2V0UGFyZW50SWQgPSBmdW5jdGlvbiBnZXRQYXJlbnRJZChkYXRhLCBpZCkge1xuICAgIHZhciBzaGFwZSA9IGRhdGEucGFnZS5zaGFwZXNbaWRdO1xuICAgIHJldHVybiBzaGFwZS5wYXJlbnRJZDtcbiAgfTtcblxuICBUTERSLmdldFBvaW50ZWRJZCA9IGZ1bmN0aW9uIGdldFBvaW50ZWRJZChkYXRhLCBpZCkge1xuICAgIHZhciBzaGFwZSA9IGRhdGEucGFnZS5zaGFwZXNbaWRdO1xuICAgIGlmICghc2hhcGUpIHJldHVybiBpZDtcbiAgICByZXR1cm4gc2hhcGUucGFyZW50SWQgPT09IGRhdGEucGFnZVN0YXRlLmN1cnJlbnRQYXJlbnRJZCB8fCBzaGFwZS5wYXJlbnRJZCA9PT0gZGF0YS5wYWdlLmlkID8gaWQgOiB0aGlzLmdldFBvaW50ZWRJZChkYXRhLCBzaGFwZS5wYXJlbnRJZCk7XG4gIH07XG5cbiAgVExEUi5nZXREcmlsbGVkUG9pbnRlZElkID0gZnVuY3Rpb24gZ2V0RHJpbGxlZFBvaW50ZWRJZChkYXRhLCBpZCkge1xuICAgIHZhciBzaGFwZSA9IGRhdGEucGFnZS5zaGFwZXNbaWRdO1xuICAgIHZhciBfZGF0YSRwYWdlU3RhdGUgPSBkYXRhLnBhZ2VTdGF0ZSxcbiAgICAgICAgY3VycmVudFBhcmVudElkID0gX2RhdGEkcGFnZVN0YXRlLmN1cnJlbnRQYXJlbnRJZCxcbiAgICAgICAgcG9pbnRlZElkID0gX2RhdGEkcGFnZVN0YXRlLnBvaW50ZWRJZDtcbiAgICByZXR1cm4gc2hhcGUucGFyZW50SWQgPT09IGRhdGEucGFnZS5pZCB8fCBzaGFwZS5wYXJlbnRJZCA9PT0gcG9pbnRlZElkIHx8IHNoYXBlLnBhcmVudElkID09PSBjdXJyZW50UGFyZW50SWQgPyBpZCA6IHRoaXMuZ2V0RHJpbGxlZFBvaW50ZWRJZChkYXRhLCBzaGFwZS5wYXJlbnRJZCk7XG4gIH07XG5cbiAgVExEUi5nZXRUb3BQYXJlbnRJZCA9IGZ1bmN0aW9uIGdldFRvcFBhcmVudElkKGRhdGEsIGlkKSB7XG4gICAgdmFyIHNoYXBlID0gZGF0YS5wYWdlLnNoYXBlc1tpZF07XG5cbiAgICBpZiAoc2hhcGUucGFyZW50SWQgPT09IHNoYXBlLmlkKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIlNoYXBlIGhhcyB0aGUgc2FtZSBpZCBhcyBpdHMgcGFyZW50ISBcIiArIHNoYXBlLmlkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2hhcGUucGFyZW50SWQgPT09IGRhdGEucGFnZS5pZCB8fCBzaGFwZS5wYXJlbnRJZCA9PT0gZGF0YS5wYWdlU3RhdGUuY3VycmVudFBhcmVudElkID8gaWQgOiB0aGlzLmdldFRvcFBhcmVudElkKGRhdGEsIHNoYXBlLnBhcmVudElkKTtcbiAgfSAvLyBHZXQgYW4gYXJyYXkgb2YgYSBzaGFwZSBpZCBhbmQgaXRzIGRlc2NlbmRhbnQgc2hhcGVzJyBpZHNcbiAgO1xuXG4gIFRMRFIuZ2V0RG9jdW1lbnRCcmFuY2ggPSBmdW5jdGlvbiBnZXREb2N1bWVudEJyYW5jaChkYXRhLCBpZCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgc2hhcGUgPSBkYXRhLnBhZ2Uuc2hhcGVzW2lkXTtcbiAgICBpZiAoc2hhcGUuY2hpbGRyZW4gPT09IHVuZGVmaW5lZCkgcmV0dXJuIFtpZF07XG4gICAgcmV0dXJuIFtpZF0uY29uY2F0KHNoYXBlLmNoaWxkcmVuLmZsYXRNYXAoZnVuY3Rpb24gKGNoaWxkSWQpIHtcbiAgICAgIHJldHVybiBfdGhpcy5nZXREb2N1bWVudEJyYW5jaChkYXRhLCBjaGlsZElkKTtcbiAgICB9KSk7XG4gIH07XG5cbiAgVExEUi5nZXRTZWxlY3RlZEJyYW5jaFNuYXBzaG90ID0gZnVuY3Rpb24gZ2V0U2VsZWN0ZWRCcmFuY2hTbmFwc2hvdChkYXRhLCBmbikge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIHBhZ2UgPSB0aGlzLmdldFBhZ2UoZGF0YSk7XG4gICAgdmFyIGNvcGllcyA9IHRoaXMuZ2V0U2VsZWN0ZWRJZHMoZGF0YSkuZmxhdE1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHJldHVybiBfdGhpczIuZ2V0RG9jdW1lbnRCcmFuY2goZGF0YSwgaWQpLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIHBhZ2Uuc2hhcGVzW2lkXTtcbiAgICAgIH0pO1xuICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgIHJldHVybiAhc2hhcGUuaXNMb2NrZWQ7XG4gICAgfSkubWFwKGNvcmUuVXRpbHMuZGVlcENsb25lKTtcblxuICAgIGlmIChmbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gY29waWVzLm1hcChmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgICBpZDogc2hhcGUuaWRcbiAgICAgICAgfSwgZm4oc2hhcGUpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBjb3BpZXM7XG4gIH07XG5cbiAgVExEUi5nZXRTZWxlY3RlZFNoYXBlU25hcHNob3QgPSBmdW5jdGlvbiBnZXRTZWxlY3RlZFNoYXBlU25hcHNob3QoZGF0YSwgZm4pIHtcbiAgICB2YXIgY29waWVzID0gdGhpcy5nZXRTZWxlY3RlZFNoYXBlcyhkYXRhKS5maWx0ZXIoZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICByZXR1cm4gIXNoYXBlLmlzTG9ja2VkO1xuICAgIH0pLm1hcChjb3JlLlV0aWxzLmRlZXBDbG9uZSk7XG5cbiAgICBpZiAoZm4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGNvcGllcy5tYXAoZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgICAgaWQ6IHNoYXBlLmlkXG4gICAgICAgIH0sIGZuKHNoYXBlKSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29waWVzO1xuICB9IC8vIEZvciBhIGdpdmVuIGFycmF5IG9mIHNoYXBlIGlkcywgYW4gYXJyYXkgb2YgYWxsIG90aGVyIHNoYXBlcyB0aGF0IG1heSBiZSBhZmZlY3RlZCBieSBhIG11dGF0aW9uIHRvIGl0LlxuICAvLyBVc2UgdGhpcyB0byBkZWNpZGUgd2hpY2ggc2hhcGVzIHRvIGNsb25lIGFzIGJlZm9yZSAvIGFmdGVyIGZvciBhIGNvbW1hbmQuXG4gIDtcblxuICBUTERSLmdldEFsbEVmZmVjdGVkU2hhcGVJZHMgPSBmdW5jdGlvbiBnZXRBbGxFZmZlY3RlZFNoYXBlSWRzKGRhdGEsIGlkcykge1xuICAgIHZhciB2aXNpdGVkID0gbmV3IFNldChpZHMpO1xuICAgIGlkcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgdmFyIHNoYXBlID0gZGF0YS5wYWdlLnNoYXBlc1tpZF07IC8vIEFkZCBkZXNjZW5kYW50IHNoYXBlc1xuXG4gICAgICBmdW5jdGlvbiBjb2xsZWN0RGVzY2VuZGFudHMoc2hhcGUpIHtcbiAgICAgICAgaWYgKHNoYXBlLmNoaWxkcmVuID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgICAgc2hhcGUuY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjaGlsZElkKSB7XG4gICAgICAgICAgcmV0dXJuICF2aXNpdGVkLmhhcyhjaGlsZElkKTtcbiAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGRJZCkge1xuICAgICAgICAgIHZpc2l0ZWQuYWRkKGNoaWxkSWQpO1xuICAgICAgICAgIGNvbGxlY3REZXNjZW5kYW50cyhkYXRhLnBhZ2Uuc2hhcGVzW2NoaWxkSWRdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbGxlY3REZXNjZW5kYW50cyhzaGFwZSk7IC8vIEFkZCBhc2VjZW5kYW50IHNoYXBlc1xuXG4gICAgICBmdW5jdGlvbiBjb2xsZWN0QXNjZW5kYW50cyhzaGFwZSkge1xuICAgICAgICB2YXIgcGFyZW50SWQgPSBzaGFwZS5wYXJlbnRJZDtcbiAgICAgICAgaWYgKHBhcmVudElkID09PSBkYXRhLnBhZ2UuaWQpIHJldHVybjtcbiAgICAgICAgaWYgKHZpc2l0ZWQuaGFzKHBhcmVudElkKSkgcmV0dXJuO1xuICAgICAgICB2aXNpdGVkLmFkZChwYXJlbnRJZCk7XG4gICAgICAgIGNvbGxlY3RBc2NlbmRhbnRzKGRhdGEucGFnZS5zaGFwZXNbcGFyZW50SWRdKTtcbiAgICAgIH1cblxuICAgICAgY29sbGVjdEFzY2VuZGFudHMoc2hhcGUpOyAvLyBBZGQgYmluZGluZ3MgdGhhdCBhcmUgdG8gb3IgZnJvbSBhbnkgb2YgdGhlIHZpc2l0ZWQgc2hhcGVzICh0aGlzIGRvZXMgbm90IGhhdmUgdG8gYmUgcmVjdXJzaXZlKVxuXG4gICAgICB2aXNpdGVkLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIE9iamVjdC52YWx1ZXMoZGF0YS5wYWdlLmJpbmRpbmdzKS5maWx0ZXIoZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgICAgICAgICByZXR1cm4gYmluZGluZy5mcm9tSWQgPT09IGlkIHx8IGJpbmRpbmcudG9JZCA9PT0gaWQ7XG4gICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRlZC5hZGQoYmluZGluZy5mcm9tSWQgPT09IGlkID8gYmluZGluZy50b0lkIDogYmluZGluZy5mcm9tSWQpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pOyAvLyBSZXR1cm4gdGhlIHVuaXF1ZSBhcnJheSBvZiB2aXNpdGVkIHNoYXBlc1xuXG4gICAgcmV0dXJuIEFycmF5LmZyb20odmlzaXRlZC52YWx1ZXMoKSk7XG4gIH07XG5cbiAgVExEUi5yZWN1cnNpdmVseVVwZGF0ZUNoaWxkcmVuID0gZnVuY3Rpb24gcmVjdXJzaXZlbHlVcGRhdGVDaGlsZHJlbihkYXRhLCBpZCwgYmVmb3JlU2hhcGVzLCBhZnRlclNoYXBlcykge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgaWYgKGJlZm9yZVNoYXBlcyA9PT0gdm9pZCAwKSB7XG4gICAgICBiZWZvcmVTaGFwZXMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoYWZ0ZXJTaGFwZXMgPT09IHZvaWQgMCkge1xuICAgICAgYWZ0ZXJTaGFwZXMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgc2hhcGUgPSBkYXRhLnBhZ2Uuc2hhcGVzW2lkXTtcblxuICAgIGlmIChzaGFwZS5jaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZGVsdGFzID0gdGhpcy5nZXRTaGFwZVV0aWxzKHNoYXBlKS51cGRhdGVDaGlsZHJlbihzaGFwZSwgc2hhcGUuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZElkKSB7XG4gICAgICAgIHJldHVybiBkYXRhLnBhZ2Uuc2hhcGVzW2NoaWxkSWRdO1xuICAgICAgfSkpO1xuXG4gICAgICBpZiAoZGVsdGFzKSB7XG4gICAgICAgIHJldHVybiBkZWx0YXMucmVkdWNlKGZ1bmN0aW9uIChjRGF0YSwgZGVsdGEpIHtcbiAgICAgICAgICB2YXIgZGVsdGFTaGFwZSA9IGNEYXRhLnBhZ2Uuc2hhcGVzW2RlbHRhLmlkXTtcblxuICAgICAgICAgIGlmICghYmVmb3JlU2hhcGVzW2RlbHRhU2hhcGUuaWRdKSB7XG4gICAgICAgICAgICBiZWZvcmVTaGFwZXNbZGVsdGFTaGFwZS5pZF0gPSBkZWx0YVNoYXBlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNEYXRhLnBhZ2Uuc2hhcGVzW2RlbHRhU2hhcGUuaWRdID0gX3RoaXMzLmdldFNoYXBlVXRpbHMoZGVsdGFTaGFwZSkubXV0YXRlKGRlbHRhU2hhcGUsIGRlbHRhKTtcbiAgICAgICAgICBhZnRlclNoYXBlc1tkZWx0YVNoYXBlLmlkXSA9IGNEYXRhLnBhZ2Uuc2hhcGVzW2RlbHRhU2hhcGUuaWRdO1xuXG4gICAgICAgICAgaWYgKGRlbHRhU2hhcGUuY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgX3RoaXMzLnJlY3Vyc2l2ZWx5VXBkYXRlQ2hpbGRyZW4oY0RhdGEsIGRlbHRhU2hhcGUuaWQsIGJlZm9yZVNoYXBlcywgYWZ0ZXJTaGFwZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjRGF0YTtcbiAgICAgICAgfSwgZGF0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgVExEUi5yZWN1cnNpdmVseVVwZGF0ZVBhcmVudHMgPSBmdW5jdGlvbiByZWN1cnNpdmVseVVwZGF0ZVBhcmVudHMoZGF0YSwgaWQsIGJlZm9yZVNoYXBlcywgYWZ0ZXJTaGFwZXMpIHtcbiAgICBpZiAoYmVmb3JlU2hhcGVzID09PSB2b2lkIDApIHtcbiAgICAgIGJlZm9yZVNoYXBlcyA9IHt9O1xuICAgIH1cblxuICAgIGlmIChhZnRlclNoYXBlcyA9PT0gdm9pZCAwKSB7XG4gICAgICBhZnRlclNoYXBlcyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBzaGFwZSA9IGRhdGEucGFnZS5zaGFwZXNbaWRdO1xuXG4gICAgaWYgKHNoYXBlLnBhcmVudElkICE9PSBkYXRhLnBhZ2UuaWQpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBkYXRhLnBhZ2Uuc2hhcGVzW3NoYXBlLnBhcmVudElkXTtcbiAgICAgIHZhciBkZWx0YSA9IHRoaXMuZ2V0U2hhcGVVdGlscyhzaGFwZSkub25DaGlsZHJlbkNoYW5nZShwYXJlbnQsIHBhcmVudC5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkSWQpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEucGFnZS5zaGFwZXNbY2hpbGRJZF07XG4gICAgICB9KSk7XG5cbiAgICAgIGlmIChkZWx0YSkge1xuICAgICAgICBpZiAoIWJlZm9yZVNoYXBlc1twYXJlbnQuaWRdKSB7XG4gICAgICAgICAgYmVmb3JlU2hhcGVzW3BhcmVudC5pZF0gPSBwYXJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLnBhZ2Uuc2hhcGVzW3BhcmVudC5pZF0gPSB0aGlzLmdldFNoYXBlVXRpbHMocGFyZW50KS5tdXRhdGUocGFyZW50LCBkZWx0YSk7XG4gICAgICAgIGFmdGVyU2hhcGVzW3BhcmVudC5pZF0gPSBkYXRhLnBhZ2Uuc2hhcGVzW3BhcmVudC5pZF07XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJlbnQucGFyZW50SWQgIT09IGRhdGEucGFnZS5pZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWN1cnNpdmVseVVwZGF0ZVBhcmVudHMoZGF0YSwgcGFyZW50LnBhcmVudElkLCBiZWZvcmVTaGFwZXMsIGFmdGVyU2hhcGVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcblxuICBUTERSLnVwZGF0ZUJpbmRpbmdzID0gZnVuY3Rpb24gdXBkYXRlQmluZGluZ3MoZGF0YSwgaWQsIGJlZm9yZVNoYXBlcywgYWZ0ZXJTaGFwZXMpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIGlmIChiZWZvcmVTaGFwZXMgPT09IHZvaWQgMCkge1xuICAgICAgYmVmb3JlU2hhcGVzID0ge307XG4gICAgfVxuXG4gICAgaWYgKGFmdGVyU2hhcGVzID09PSB2b2lkIDApIHtcbiAgICAgIGFmdGVyU2hhcGVzID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoZGF0YS5wYWdlLmJpbmRpbmdzKS5maWx0ZXIoZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgICAgIHJldHVybiBiaW5kaW5nLmZyb21JZCA9PT0gaWQgfHwgYmluZGluZy50b0lkID09PSBpZDtcbiAgICB9KS5yZWR1Y2UoZnVuY3Rpb24gKGNEYXRhLCBiaW5kaW5nKSB7XG4gICAgICBpZiAoIWJlZm9yZVNoYXBlc1tiaW5kaW5nLmlkXSkge1xuICAgICAgICBiZWZvcmVTaGFwZXNbYmluZGluZy5mcm9tSWRdID0gY29yZS5VdGlscy5kZWVwQ2xvbmUoY0RhdGEucGFnZS5zaGFwZXNbYmluZGluZy5mcm9tSWRdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFiZWZvcmVTaGFwZXNbYmluZGluZy50b0lkXSkge1xuICAgICAgICBiZWZvcmVTaGFwZXNbYmluZGluZy50b0lkXSA9IGNvcmUuVXRpbHMuZGVlcENsb25lKGNEYXRhLnBhZ2Uuc2hhcGVzW2JpbmRpbmcudG9JZF0pO1xuICAgICAgfVxuXG4gICAgICBfdGhpczQub25CaW5kaW5nQ2hhbmdlKGNEYXRhLCBjRGF0YS5wYWdlLnNoYXBlc1tiaW5kaW5nLmZyb21JZF0sIGJpbmRpbmcsIGNEYXRhLnBhZ2Uuc2hhcGVzW2JpbmRpbmcudG9JZF0pO1xuXG4gICAgICBhZnRlclNoYXBlc1tiaW5kaW5nLmZyb21JZF0gPSBjb3JlLlV0aWxzLmRlZXBDbG9uZShjRGF0YS5wYWdlLnNoYXBlc1tiaW5kaW5nLmZyb21JZF0pO1xuICAgICAgYWZ0ZXJTaGFwZXNbYmluZGluZy50b0lkXSA9IGNvcmUuVXRpbHMuZGVlcENsb25lKGNEYXRhLnBhZ2Uuc2hhcGVzW2JpbmRpbmcudG9JZF0pO1xuICAgICAgcmV0dXJuIGNEYXRhO1xuICAgIH0sIGRhdGEpO1xuICB9O1xuXG4gIFRMRFIuZ2V0Q2hpbGRJbmRleEFib3ZlID0gZnVuY3Rpb24gZ2V0Q2hpbGRJbmRleEFib3ZlKGRhdGEsIGlkKSB7XG4gICAgdmFyIHBhZ2UgPSB0aGlzLmdldFBhZ2UoZGF0YSk7XG4gICAgdmFyIHNoYXBlID0gcGFnZS5zaGFwZXNbaWRdO1xuICAgIHZhciBzaWJsaW5ncyA9IE9iamVjdC52YWx1ZXMocGFnZS5zaGFwZXMpLmZpbHRlcihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIHBhcmVudElkID0gX3JlZi5wYXJlbnRJZDtcbiAgICAgIHJldHVybiBwYXJlbnRJZCA9PT0gc2hhcGUucGFyZW50SWQ7XG4gICAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEuY2hpbGRJbmRleCAtIGIuY2hpbGRJbmRleDtcbiAgICB9KTtcbiAgICB2YXIgaW5kZXggPSBzaWJsaW5ncy5pbmRleE9mKHNoYXBlKTtcbiAgICB2YXIgbmV4dFNpYmxpbmcgPSBzaWJsaW5nc1tpbmRleCArIDFdO1xuICAgIGlmICghbmV4dFNpYmxpbmcpIHJldHVybiBzaGFwZS5jaGlsZEluZGV4ICsgMTtcbiAgICByZXR1cm4gKHNoYXBlLmNoaWxkSW5kZXggKyBuZXh0U2libGluZy5jaGlsZEluZGV4KSAvIDI7XG4gIH1cbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAvKiAgICAgICAgICAgICAgICAgICAgICBNdXRhdGlvbnMgICAgICAgICAgICAgICAgICAgICAqL1xuXG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gIDtcblxuICBUTERSLnNldFNlbGVjdGVkSWRzID0gZnVuY3Rpb24gc2V0U2VsZWN0ZWRJZHMoZGF0YSwgaWRzKSB7XG4gICAgZGF0YS5wYWdlU3RhdGUuc2VsZWN0ZWRJZHMgPSBpZHM7XG4gIH07XG5cbiAgVExEUi5kZXNlbGVjdEFsbCA9IGZ1bmN0aW9uIGRlc2VsZWN0QWxsKGRhdGEpIHtcbiAgICB0aGlzLnNldFNlbGVjdGVkSWRzKGRhdGEsIFtdKTtcbiAgfTtcblxuICBUTERSLm11dGF0ZVNoYXBlcyA9IGZ1bmN0aW9uIG11dGF0ZVNoYXBlcyhkYXRhLCBpZHMsIGZuKSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICB2YXIgYmVmb3JlU2hhcGVzID0ge307XG4gICAgdmFyIGFmdGVyU2hhcGVzID0ge307XG4gICAgaWRzLmZvckVhY2goZnVuY3Rpb24gKGlkLCBpKSB7XG4gICAgICB2YXIgc2hhcGUgPSBkYXRhLnBhZ2Uuc2hhcGVzW2lkXTtcbiAgICAgIHZhciBjaGFuZ2UgPSBmbihzaGFwZSwgaSk7XG4gICAgICBiZWZvcmVTaGFwZXNbaWRdID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5rZXlzKGNoYW5nZSkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIFtrZXksIHNoYXBlW2tleV1dO1xuICAgICAgfSkpO1xuICAgICAgYWZ0ZXJTaGFwZXNbaWRdID0gY2hhbmdlO1xuICAgICAgZGF0YS5wYWdlLnNoYXBlc1tpZF0gPSBfdGhpczUuZ2V0U2hhcGVVdGlscyhzaGFwZSkubXV0YXRlKHNoYXBlLCBjaGFuZ2UpO1xuICAgIH0pO1xuICAgIHZhciBkYXRhV2l0aENoaWxkcmVuQ2hhbmdlcyA9IGlkcy5yZWR1Y2UoZnVuY3Rpb24gKGNEYXRhLCBpZCkge1xuICAgICAgcmV0dXJuIF90aGlzNS5yZWN1cnNpdmVseVVwZGF0ZUNoaWxkcmVuKGNEYXRhLCBpZCwgYmVmb3JlU2hhcGVzLCBhZnRlclNoYXBlcyk7XG4gICAgfSwgZGF0YSk7XG4gICAgdmFyIGRhdGFXaXRoUGFyZW50Q2hhbmdlcyA9IGlkcy5yZWR1Y2UoZnVuY3Rpb24gKGNEYXRhLCBpZCkge1xuICAgICAgcmV0dXJuIF90aGlzNS5yZWN1cnNpdmVseVVwZGF0ZVBhcmVudHMoY0RhdGEsIGlkLCBiZWZvcmVTaGFwZXMsIGFmdGVyU2hhcGVzKTtcbiAgICB9LCBkYXRhV2l0aENoaWxkcmVuQ2hhbmdlcyk7XG4gICAgdmFyIGRhdGFXaXRoQmluZGluZ0NoYW5nZXMgPSBpZHMucmVkdWNlKGZ1bmN0aW9uIChjRGF0YSwgaWQpIHtcbiAgICAgIHJldHVybiBfdGhpczUudXBkYXRlQmluZGluZ3MoY0RhdGEsIGlkLCBiZWZvcmVTaGFwZXMsIGFmdGVyU2hhcGVzKTtcbiAgICB9LCBkYXRhV2l0aFBhcmVudENoYW5nZXMpO1xuICAgIHJldHVybiB7XG4gICAgICBiZWZvcmU6IGJlZm9yZVNoYXBlcyxcbiAgICAgIGFmdGVyOiBhZnRlclNoYXBlcyxcbiAgICAgIGRhdGE6IGRhdGFXaXRoQmluZGluZ0NoYW5nZXNcbiAgICB9O1xuICB9O1xuXG4gIFRMRFIuY3JlYXRlU2hhcGVzID0gZnVuY3Rpb24gY3JlYXRlU2hhcGVzKGRhdGEsIHNoYXBlcykge1xuICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgdmFyIHBhZ2UgPSB0aGlzLmdldFBhZ2UoZGF0YSk7XG4gICAgdmFyIHNoYXBlSWRzID0gc2hhcGVzLm1hcChmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgIHJldHVybiBzaGFwZS5pZDtcbiAgICB9KTsgLy8gVXBkYXRlIHNlbGVjdGVkIGlkc1xuXG4gICAgdGhpcy5zZXRTZWxlY3RlZElkcyhkYXRhLCBzaGFwZUlkcyk7IC8vIFJlc3RvcmUgZGVsZXRlZCBzaGFwZXNcblxuICAgIHNoYXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgdmFyIG5ld1NoYXBlID0gX2V4dGVuZHMoe30sIHNoYXBlKTtcblxuICAgICAgcGFnZS5zaGFwZXNbc2hhcGUuaWRdID0gbmV3U2hhcGU7XG4gICAgfSk7IC8vIFVwZGF0ZSBwYXJlbnRzXG5cbiAgICBzaGFwZXMuZm9yRWFjaChmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgIGlmIChzaGFwZS5wYXJlbnRJZCA9PT0gZGF0YS5wYWdlLmlkKSByZXR1cm47XG4gICAgICB2YXIgcGFyZW50ID0gcGFnZS5zaGFwZXNbc2hhcGUucGFyZW50SWRdO1xuXG4gICAgICBfdGhpczYubXV0YXRlKGRhdGEsIHBhcmVudCwge1xuICAgICAgICBjaGlsZHJlbjogcGFyZW50LmNoaWxkcmVuLmluY2x1ZGVzKHNoYXBlLmlkKSA/IHBhcmVudC5jaGlsZHJlbiA6IFtdLmNvbmNhdChwYXJlbnQuY2hpbGRyZW4sIFtzaGFwZS5pZF0pXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBUTERSLm9uU2Vzc2lvbkNvbXBsZXRlID0gZnVuY3Rpb24gb25TZXNzaW9uQ29tcGxldGUoZGF0YSwgc2hhcGUpIHtcbiAgICB2YXIgZGVsdGEgPSBnZXRTaGFwZVV0aWxzKHNoYXBlKS5vblNlc3Npb25Db21wbGV0ZShzaGFwZSk7XG5cbiAgICBpZiAoIWRlbHRhKSByZXR1cm4gc2hhcGU7XG4gICAgcmV0dXJuIHRoaXMubXV0YXRlKGRhdGEsIHNoYXBlLCBkZWx0YSk7XG4gIH07XG5cbiAgVExEUi5vbkNoaWxkcmVuQ2hhbmdlID0gZnVuY3Rpb24gb25DaGlsZHJlbkNoYW5nZShkYXRhLCBzaGFwZSkge1xuICAgIHZhciBkZWx0YSA9IGdldFNoYXBlVXRpbHMoc2hhcGUpLm9uQ2hpbGRyZW5DaGFuZ2Uoc2hhcGUsIHNoYXBlLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHJldHVybiBkYXRhLnBhZ2Uuc2hhcGVzW2lkXTtcbiAgICB9KSk7XG5cbiAgICBpZiAoIWRlbHRhKSByZXR1cm4gc2hhcGU7XG4gICAgcmV0dXJuIHRoaXMubXV0YXRlKGRhdGEsIHNoYXBlLCBkZWx0YSk7XG4gIH07XG5cbiAgVExEUi5vbkJpbmRpbmdDaGFuZ2UgPSBmdW5jdGlvbiBvbkJpbmRpbmdDaGFuZ2UoZGF0YSwgc2hhcGUsIGJpbmRpbmcsIG90aGVyU2hhcGUpIHtcbiAgICB2YXIgZGVsdGEgPSBnZXRTaGFwZVV0aWxzKHNoYXBlKS5vbkJpbmRpbmdDaGFuZ2Uoc2hhcGUsIGJpbmRpbmcsIG90aGVyU2hhcGUsIGdldFNoYXBlVXRpbHMob3RoZXJTaGFwZSkuZ2V0Qm91bmRzKG90aGVyU2hhcGUpKTtcblxuICAgIGlmICghZGVsdGEpIHJldHVybiBzaGFwZTtcbiAgICByZXR1cm4gdGhpcy5tdXRhdGUoZGF0YSwgc2hhcGUsIGRlbHRhKTtcbiAgfTtcblxuICBUTERSLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIHRyYW5zZm9ybShkYXRhLCBzaGFwZSwgYm91bmRzLCBpbmZvKSB7XG4gICAgcmV0dXJuIHRoaXMubXV0YXRlKGRhdGEsIHNoYXBlLCBnZXRTaGFwZVV0aWxzKHNoYXBlKS50cmFuc2Zvcm0oc2hhcGUsIGJvdW5kcywgaW5mbykpO1xuICB9O1xuXG4gIFRMRFIudHJhbnNmb3JtU2luZ2xlID0gZnVuY3Rpb24gdHJhbnNmb3JtU2luZ2xlKGRhdGEsIHNoYXBlLCBib3VuZHMsIGluZm8pIHtcbiAgICByZXR1cm4gdGhpcy5tdXRhdGUoZGF0YSwgc2hhcGUsIGdldFNoYXBlVXRpbHMoc2hhcGUpLnRyYW5zZm9ybVNpbmdsZShzaGFwZSwgYm91bmRzLCBpbmZvKSk7XG4gIH07XG5cbiAgVExEUi5tdXRhdGUgPSBmdW5jdGlvbiBtdXRhdGUoZGF0YSwgc2hhcGUsIHByb3BzKSB7XG4gICAgdmFyIG5leHQgPSBnZXRTaGFwZVV0aWxzKHNoYXBlKS5tdXRhdGUoc2hhcGUsIHByb3BzKTtcblxuICAgIGlmICgnY2hpbGRyZW4nIGluIHByb3BzKSB7XG4gICAgICBuZXh0ID0gdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKGRhdGEsIG5leHQpO1xuICAgIH1cblxuICAgIGRhdGEucGFnZS5zaGFwZXNbbmV4dC5pZF0gPSBuZXh0O1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgLyogICAgICAgICAgICAgICAgICAgICAgIFBhcmVudHMgICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuICA7XG5cbiAgVExEUi51cGRhdGVQYXJlbnRzID0gZnVuY3Rpb24gdXBkYXRlUGFyZW50cyhkYXRhLCBjaGFuZ2VkU2hhcGVJZHMpIHtcbiAgICBpZiAoY2hhbmdlZFNoYXBlSWRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgdmFyIF90aGlzJGdldFBhZ2UgPSB0aGlzLmdldFBhZ2UoZGF0YSksXG4gICAgICAgIHNoYXBlcyA9IF90aGlzJGdldFBhZ2Uuc2hhcGVzO1xuXG4gICAgdmFyIHBhcmVudFRvVXBkYXRlSWRzID0gQXJyYXkuZnJvbShuZXcgU2V0KGNoYW5nZWRTaGFwZUlkcy5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgICByZXR1cm4gc2hhcGVzW2lkXS5wYXJlbnRJZDtcbiAgICB9KS52YWx1ZXMoKSkpLmZpbHRlcihmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHJldHVybiBpZCAhPT0gZGF0YS5wYWdlLmlkO1xuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShwYXJlbnRUb1VwZGF0ZUlkcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgcGFyZW50SWQgPSBfc3RlcC52YWx1ZTtcbiAgICAgIHZhciBwYXJlbnQgPSBzaGFwZXNbcGFyZW50SWRdO1xuXG4gICAgICBpZiAoIXBhcmVudC5jaGlsZHJlbikge1xuICAgICAgICB0aHJvdyBFcnJvcignQSBzaGFwZSBpcyBwYXJlbnRlZCB0byBhIHNoYXBlIHdpdGhvdXQgYSBjaGlsZHJlbiBhcnJheS4nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKGRhdGEsIHBhcmVudCk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVQYXJlbnRzKGRhdGEsIHBhcmVudFRvVXBkYXRlSWRzKTtcbiAgfTtcblxuICBUTERSLmdldFNlbGVjdGVkU3R5bGUgPSBmdW5jdGlvbiBnZXRTZWxlY3RlZFN0eWxlKGRhdGEpIHtcbiAgICB2YXIgcGFnZSA9IGRhdGEucGFnZSxcbiAgICAgICAgcGFnZVN0YXRlID0gZGF0YS5wYWdlU3RhdGUsXG4gICAgICAgIGN1cnJlbnRTdHlsZSA9IGRhdGEuYXBwU3RhdGUuY3VycmVudFN0eWxlO1xuXG4gICAgaWYgKHBhZ2VTdGF0ZS5zZWxlY3RlZElkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBjdXJyZW50U3R5bGU7XG4gICAgfVxuXG4gICAgdmFyIHNoYXBlU3R5bGVzID0gZGF0YS5wYWdlU3RhdGUuc2VsZWN0ZWRJZHMubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuIHBhZ2Uuc2hhcGVzW2lkXS5zdHlsZTtcbiAgICB9KTtcbiAgICB2YXIgY29tbW9uU3R5bGUgPSB7fTtcbiAgICB2YXIgb3ZlcnJpZGVzID0gbmV3IFNldChbXSk7XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIHZhciBzaGFwZVN0eWxlID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgT2JqZWN0LmtleXMoY3VycmVudFN0eWxlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlcy5oYXMoa2V5KSkgcmV0dXJuO1xuXG4gICAgICAgIGlmIChjb21tb25TdHlsZVtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgY29tbW9uU3R5bGVba2V5XSA9IHNoYXBlU3R5bGVba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY29tbW9uU3R5bGVba2V5XSA9PT0gc2hhcGVTdHlsZVtrZXldKSByZXR1cm47IC8vIEB0cy1pZ25vcmVcblxuICAgICAgICAgIGNvbW1vblN0eWxlW2tleV0gPSBjdXJyZW50U3R5bGVba2V5XTtcbiAgICAgICAgICBvdmVycmlkZXMuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShzaGFwZVN0eWxlcyksIF9zdGVwMjsgIShfc3RlcDIgPSBfaXRlcmF0b3IyKCkpLmRvbmU7KSB7XG4gICAgICBfbG9vcCgpO1xuICAgIH1cblxuICAgIHJldHVybiBjb21tb25TdHlsZTtcbiAgfVxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gIC8qICAgICAgICAgICAgICAgICAgICAgIEJpbmRpbmdzICAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgO1xuXG4gIFRMRFIuZ2V0QmluZGluZyA9IGZ1bmN0aW9uIGdldEJpbmRpbmcoZGF0YSwgaWQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQYWdlKGRhdGEpLmJpbmRpbmdzW2lkXTtcbiAgfTtcblxuICBUTERSLmdldEJpbmRpbmdzID0gZnVuY3Rpb24gZ2V0QmluZGluZ3MoZGF0YSkge1xuICAgIHZhciBwYWdlID0gdGhpcy5nZXRQYWdlKGRhdGEpO1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHBhZ2UuYmluZGluZ3MpO1xuICB9O1xuXG4gIFRMRFIuZ2V0QmluZGluZ3NXaXRoU2hhcGVJZHMgPSBmdW5jdGlvbiBnZXRCaW5kaW5nc1dpdGhTaGFwZUlkcyhkYXRhLCBpZHMpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KHRoaXMuZ2V0QmluZGluZ3MoZGF0YSkuZmlsdGVyKGZ1bmN0aW9uIChiaW5kaW5nKSB7XG4gICAgICByZXR1cm4gaWRzLmluY2x1ZGVzKGJpbmRpbmcudG9JZCkgfHwgaWRzLmluY2x1ZGVzKGJpbmRpbmcuZnJvbUlkKTtcbiAgICB9KSkudmFsdWVzKCkpO1xuICB9O1xuXG4gIFRMRFIuY3JlYXRlQmluZGluZ3MgPSBmdW5jdGlvbiBjcmVhdGVCaW5kaW5ncyhkYXRhLCBiaW5kaW5ncykge1xuICAgIHZhciBwYWdlID0gdGhpcy5nZXRQYWdlKGRhdGEpO1xuICAgIGJpbmRpbmdzLmZvckVhY2goZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgICAgIHJldHVybiBwYWdlLmJpbmRpbmdzW2JpbmRpbmcuaWRdID0gYmluZGluZztcbiAgICB9KTtcbiAgfTtcblxuICBUTERSLmRlbGV0ZUJpbmRpbmdzID0gZnVuY3Rpb24gZGVsZXRlQmluZGluZ3MoZGF0YSwgaWRzKSB7XG4gICAgaWYgKGlkcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICB2YXIgcGFnZSA9IHRoaXMuZ2V0UGFnZShkYXRhKTtcbiAgICBpZHMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHJldHVybiBkZWxldGUgcGFnZS5iaW5kaW5nc1tpZF07XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFRMRFI7XG59KCk7XG5cbmZ1bmN0aW9uIGFsaWduKGRhdGEsIGlkcywgdHlwZSkge1xuICB2YXIgaW5pdGlhbFNoYXBlcyA9IGlkcy5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIFRMRFIuZ2V0U2hhcGUoZGF0YSwgaWQpO1xuICB9KTtcbiAgdmFyIGJvdW5kc0ZvclNoYXBlcyA9IGluaXRpYWxTaGFwZXMubWFwKGZ1bmN0aW9uIChzaGFwZSkge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogc2hhcGUuaWQsXG4gICAgICBwb2ludDogW10uY29uY2F0KHNoYXBlLnBvaW50KSxcbiAgICAgIGJvdW5kczogVExEUi5nZXRTaGFwZVV0aWxzKHNoYXBlKS5nZXRCb3VuZHMoc2hhcGUpXG4gICAgfTtcbiAgfSk7XG4gIHZhciBjb21tb25Cb3VuZHMgPSBjb3JlLlV0aWxzLmdldENvbW1vbkJvdW5kcyhib3VuZHNGb3JTaGFwZXMubWFwKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIGJvdW5kcyA9IF9yZWYuYm91bmRzO1xuICAgIHJldHVybiBib3VuZHM7XG4gIH0pKTtcbiAgdmFyIG1pZFggPSBjb21tb25Cb3VuZHMubWluWCArIGNvbW1vbkJvdW5kcy53aWR0aCAvIDI7XG4gIHZhciBtaWRZID0gY29tbW9uQm91bmRzLm1pblkgKyBjb21tb25Cb3VuZHMuaGVpZ2h0IC8gMjtcbiAgdmFyIGRlbHRhTWFwID0gT2JqZWN0LmZyb21FbnRyaWVzKGJvdW5kc0ZvclNoYXBlcy5tYXAoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgdmFyIF9BbGlnblR5cGUkQ2VudGVyVmVydDtcblxuICAgIHZhciBpZCA9IF9yZWYyLmlkLFxuICAgICAgICBwb2ludCA9IF9yZWYyLnBvaW50LFxuICAgICAgICBib3VuZHMgPSBfcmVmMi5ib3VuZHM7XG4gICAgcmV0dXJuIFtpZCwge1xuICAgICAgcHJldjogcG9pbnQsXG4gICAgICBuZXh0OiAoX0FsaWduVHlwZSRDZW50ZXJWZXJ0ID0ge30sIF9BbGlnblR5cGUkQ2VudGVyVmVydFtleHBvcnRzLkFsaWduVHlwZS5DZW50ZXJWZXJ0aWNhbF0gPSBbcG9pbnRbMF0sIG1pZFkgLSBib3VuZHMuaGVpZ2h0IC8gMl0sIF9BbGlnblR5cGUkQ2VudGVyVmVydFtleHBvcnRzLkFsaWduVHlwZS5DZW50ZXJIb3Jpem9udGFsXSA9IFttaWRYIC0gYm91bmRzLndpZHRoIC8gMiwgcG9pbnRbMV1dLCBfQWxpZ25UeXBlJENlbnRlclZlcnRbZXhwb3J0cy5BbGlnblR5cGUuVG9wXSA9IFtwb2ludFswXSwgY29tbW9uQm91bmRzLm1pblldLCBfQWxpZ25UeXBlJENlbnRlclZlcnRbZXhwb3J0cy5BbGlnblR5cGUuQm90dG9tXSA9IFtwb2ludFswXSwgY29tbW9uQm91bmRzLm1heFkgLSBib3VuZHMuaGVpZ2h0XSwgX0FsaWduVHlwZSRDZW50ZXJWZXJ0W2V4cG9ydHMuQWxpZ25UeXBlLkxlZnRdID0gW2NvbW1vbkJvdW5kcy5taW5YLCBwb2ludFsxXV0sIF9BbGlnblR5cGUkQ2VudGVyVmVydFtleHBvcnRzLkFsaWduVHlwZS5SaWdodF0gPSBbY29tbW9uQm91bmRzLm1heFggLSBib3VuZHMud2lkdGgsIHBvaW50WzFdXSwgX0FsaWduVHlwZSRDZW50ZXJWZXJ0KVt0eXBlXVxuICAgIH1dO1xuICB9KSk7XG5cbiAgdmFyIF9UTERSJG11dGF0ZVNoYXBlcyA9IFRMRFIubXV0YXRlU2hhcGVzKGRhdGEsIGlkcywgZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgaWYgKCFkZWx0YU1hcFtzaGFwZS5pZF0pIHJldHVybiBzaGFwZTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9pbnQ6IGRlbHRhTWFwW3NoYXBlLmlkXS5uZXh0XG4gICAgfTtcbiAgfSksXG4gICAgICBiZWZvcmUgPSBfVExEUiRtdXRhdGVTaGFwZXMuYmVmb3JlLFxuICAgICAgYWZ0ZXIgPSBfVExEUiRtdXRhdGVTaGFwZXMuYWZ0ZXI7XG5cbiAgcmV0dXJuIHtcbiAgICBpZDogJ2FsaWduX3NoYXBlcycsXG4gICAgYmVmb3JlOiB7XG4gICAgICBwYWdlOiB7XG4gICAgICAgIHNoYXBlczogX2V4dGVuZHMoe30sIGJlZm9yZSlcbiAgICAgIH1cbiAgICB9LFxuICAgIGFmdGVyOiB7XG4gICAgICBwYWdlOiB7XG4gICAgICAgIHNoYXBlczogX2V4dGVuZHMoe30sIGFmdGVyKVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZGlzdHJpYnV0ZShkYXRhLCBpZHMsIHR5cGUpIHtcbiAgdmFyIGluaXRpYWxTaGFwZXMgPSBpZHMubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgIHJldHVybiBkYXRhLnBhZ2Uuc2hhcGVzW2lkXTtcbiAgfSk7XG4gIHZhciBkZWx0YU1hcCA9IE9iamVjdC5mcm9tRW50cmllcyhnZXREaXN0cmlidXRpb25zKGluaXRpYWxTaGFwZXMsIHR5cGUpLm1hcChmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBbZC5pZCwgZF07XG4gIH0pKTtcblxuICB2YXIgX1RMRFIkbXV0YXRlU2hhcGVzID0gVExEUi5tdXRhdGVTaGFwZXMoZGF0YSwgaWRzLCBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICBpZiAoIWRlbHRhTWFwW3NoYXBlLmlkXSkgcmV0dXJuIHNoYXBlO1xuICAgIHJldHVybiB7XG4gICAgICBwb2ludDogZGVsdGFNYXBbc2hhcGUuaWRdLm5leHRcbiAgICB9O1xuICB9KSxcbiAgICAgIGJlZm9yZSA9IF9UTERSJG11dGF0ZVNoYXBlcy5iZWZvcmUsXG4gICAgICBhZnRlciA9IF9UTERSJG11dGF0ZVNoYXBlcy5hZnRlcjtcblxuICByZXR1cm4ge1xuICAgIGlkOiAnZGlzdHJpYnV0ZV9zaGFwZXMnLFxuICAgIGJlZm9yZToge1xuICAgICAgcGFnZToge1xuICAgICAgICBzaGFwZXM6IF9leHRlbmRzKHt9LCBiZWZvcmUpXG4gICAgICB9XG4gICAgfSxcbiAgICBhZnRlcjoge1xuICAgICAgcGFnZToge1xuICAgICAgICBzaGFwZXM6IF9leHRlbmRzKHt9LCBhZnRlcilcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldERpc3RyaWJ1dGlvbnMoaW5pdGlhbFNoYXBlcywgdHlwZSkge1xuICB2YXIgZW50cmllcyA9IGluaXRpYWxTaGFwZXMubWFwKGZ1bmN0aW9uIChzaGFwZSkge1xuICAgIHZhciB1dGlscyA9IFRMRFIuZ2V0U2hhcGVVdGlscyhzaGFwZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBzaGFwZS5pZCxcbiAgICAgIHBvaW50OiBbXS5jb25jYXQoc2hhcGUucG9pbnQpLFxuICAgICAgYm91bmRzOiB1dGlscy5nZXRCb3VuZHMoc2hhcGUpLFxuICAgICAgY2VudGVyOiB1dGlscy5nZXRDZW50ZXIoc2hhcGUpXG4gICAgfTtcbiAgfSk7XG4gIHZhciBsZW4gPSBlbnRyaWVzLmxlbmd0aDtcbiAgdmFyIGNvbW1vbkJvdW5kcyA9IGNvcmUuVXRpbHMuZ2V0Q29tbW9uQm91bmRzKGVudHJpZXMubWFwKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIGJvdW5kcyA9IF9yZWYuYm91bmRzO1xuICAgIHJldHVybiBib3VuZHM7XG4gIH0pKTtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuRGlzdHJpYnV0ZVR5cGUuSG9yaXpvbnRhbDpcbiAgICAgIHtcbiAgICAgICAgdmFyIHNwYW4gPSBlbnRyaWVzLnJlZHVjZShmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICAgIHJldHVybiBhICsgYy5ib3VuZHMud2lkdGg7XG4gICAgICAgIH0sIDApO1xuXG4gICAgICAgIGlmIChzcGFuID4gY29tbW9uQm91bmRzLndpZHRoKSB7XG4gICAgICAgICAgdmFyIGxlZnQgPSBlbnRyaWVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLmJvdW5kcy5taW5YIC0gYi5ib3VuZHMubWluWDtcbiAgICAgICAgICB9KVswXTtcbiAgICAgICAgICB2YXIgcmlnaHQgPSBlbnRyaWVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmJvdW5kcy5tYXhYIC0gYS5ib3VuZHMubWF4WDtcbiAgICAgICAgICB9KVswXTtcbiAgICAgICAgICB2YXIgZW50cmllc1RvTW92ZSA9IGVudHJpZXMuZmlsdGVyKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICByZXR1cm4gYSAhPT0gbGVmdCAmJiBhICE9PSByaWdodDtcbiAgICAgICAgICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5jZW50ZXJbMF0gLSBiLmNlbnRlclswXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgc3RlcCA9IChyaWdodC5jZW50ZXJbMF0gLSBsZWZ0LmNlbnRlclswXSkgLyAobGVuIC0gMSk7XG4gICAgICAgICAgdmFyIHggPSBsZWZ0LmNlbnRlclswXSArIHN0ZXA7XG4gICAgICAgICAgZW50cmllc1RvTW92ZS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMiwgaSkge1xuICAgICAgICAgICAgdmFyIGlkID0gX3JlZjIuaWQsXG4gICAgICAgICAgICAgICAgcG9pbnQgPSBfcmVmMi5wb2ludCxcbiAgICAgICAgICAgICAgICBib3VuZHMgPSBfcmVmMi5ib3VuZHM7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgIHByZXY6IHBvaW50LFxuICAgICAgICAgICAgICBuZXh0OiBbeCArIHN0ZXAgKiBpIC0gYm91bmRzLndpZHRoIC8gMiwgYm91bmRzLm1pblldXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2VudHJpZXNUb01vdmUgPSBlbnRyaWVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLmNlbnRlclswXSAtIGIuY2VudGVyWzBdO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF94ID0gY29tbW9uQm91bmRzLm1pblg7XG5cbiAgICAgICAgICB2YXIgX3N0ZXAgPSAoY29tbW9uQm91bmRzLndpZHRoIC0gc3BhbikgLyAobGVuIC0gMSk7XG5cbiAgICAgICAgICBfZW50cmllc1RvTW92ZS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMywgaSkge1xuICAgICAgICAgICAgdmFyIGlkID0gX3JlZjMuaWQsXG4gICAgICAgICAgICAgICAgcG9pbnQgPSBfcmVmMy5wb2ludCxcbiAgICAgICAgICAgICAgICBib3VuZHMgPSBfcmVmMy5ib3VuZHM7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgIHByZXY6IHBvaW50LFxuICAgICAgICAgICAgICBuZXh0OiBbX3gsIGJvdW5kcy5taW5ZXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfeCArPSBib3VuZHMud2lkdGggKyBfc3RlcDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBleHBvcnRzLkRpc3RyaWJ1dGVUeXBlLlZlcnRpY2FsOlxuICAgICAge1xuICAgICAgICB2YXIgX3NwYW4gPSBlbnRyaWVzLnJlZHVjZShmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICAgIHJldHVybiBhICsgYy5ib3VuZHMuaGVpZ2h0O1xuICAgICAgICB9LCAwKTtcblxuICAgICAgICBpZiAoX3NwYW4gPiBjb21tb25Cb3VuZHMuaGVpZ2h0KSB7XG4gICAgICAgICAgdmFyIHRvcCA9IGVudHJpZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEuYm91bmRzLm1pblkgLSBiLmJvdW5kcy5taW5ZO1xuICAgICAgICAgIH0pWzBdO1xuICAgICAgICAgIHZhciBib3R0b20gPSBlbnRyaWVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmJvdW5kcy5tYXhZIC0gYS5ib3VuZHMubWF4WTtcbiAgICAgICAgICB9KVswXTtcblxuICAgICAgICAgIHZhciBfZW50cmllc1RvTW92ZTIgPSBlbnRyaWVzLmZpbHRlcihmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgcmV0dXJuIGEgIT09IHRvcCAmJiBhICE9PSBib3R0b207XG4gICAgICAgICAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEuY2VudGVyWzFdIC0gYi5jZW50ZXJbMV07XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX3N0ZXAyID0gKGJvdHRvbS5jZW50ZXJbMV0gLSB0b3AuY2VudGVyWzFdKSAvIChsZW4gLSAxKTtcblxuICAgICAgICAgIHZhciB5ID0gdG9wLmNlbnRlclsxXSArIF9zdGVwMjtcblxuICAgICAgICAgIF9lbnRyaWVzVG9Nb3ZlMi5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmNCwgaSkge1xuICAgICAgICAgICAgdmFyIGlkID0gX3JlZjQuaWQsXG4gICAgICAgICAgICAgICAgcG9pbnQgPSBfcmVmNC5wb2ludCxcbiAgICAgICAgICAgICAgICBib3VuZHMgPSBfcmVmNC5ib3VuZHM7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgIHByZXY6IHBvaW50LFxuICAgICAgICAgICAgICBuZXh0OiBbYm91bmRzLm1pblgsIHkgKyBfc3RlcDIgKiBpIC0gYm91bmRzLmhlaWdodCAvIDJdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2VudHJpZXNUb01vdmUzID0gZW50cmllcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5jZW50ZXJbMV0gLSBiLmNlbnRlclsxXTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfeSA9IGNvbW1vbkJvdW5kcy5taW5ZO1xuXG4gICAgICAgICAgdmFyIF9zdGVwMyA9IChjb21tb25Cb3VuZHMuaGVpZ2h0IC0gX3NwYW4pIC8gKGxlbiAtIDEpO1xuXG4gICAgICAgICAgX2VudHJpZXNUb01vdmUzLmZvckVhY2goZnVuY3Rpb24gKF9yZWY1LCBpKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBfcmVmNS5pZCxcbiAgICAgICAgICAgICAgICBwb2ludCA9IF9yZWY1LnBvaW50LFxuICAgICAgICAgICAgICAgIGJvdW5kcyA9IF9yZWY1LmJvdW5kcztcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgcHJldjogcG9pbnQsXG4gICAgICAgICAgICAgIG5leHQ6IFtib3VuZHMubWluWCwgX3ldXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF95ICs9IGJvdW5kcy5oZWlnaHQgKyBfc3RlcDM7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBzdHlsZShkYXRhLCBpZHMsIGNoYW5nZXMpIHtcbiAgdmFyIF9UTERSJG11dGF0ZVNoYXBlcyA9IFRMRFIubXV0YXRlU2hhcGVzKGRhdGEsIGlkcywgZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0eWxlOiBfZXh0ZW5kcyh7fSwgc2hhcGUuc3R5bGUsIGNoYW5nZXMpXG4gICAgfTtcbiAgfSksXG4gICAgICBiZWZvcmUgPSBfVExEUiRtdXRhdGVTaGFwZXMuYmVmb3JlLFxuICAgICAgYWZ0ZXIgPSBfVExEUiRtdXRhdGVTaGFwZXMuYWZ0ZXI7XG5cbiAgcmV0dXJuIHtcbiAgICBpZDogJ3N0eWxlX3NoYXBlcycsXG4gICAgYmVmb3JlOiB7XG4gICAgICBwYWdlOiB7XG4gICAgICAgIHNoYXBlczogX2V4dGVuZHMoe30sIGJlZm9yZSlcbiAgICAgIH0sXG4gICAgICBhcHBTdGF0ZToge1xuICAgICAgICBjdXJyZW50U3R5bGU6IF9leHRlbmRzKHt9LCBkYXRhLmFwcFN0YXRlLmN1cnJlbnRTdHlsZSlcbiAgICAgIH1cbiAgICB9LFxuICAgIGFmdGVyOiB7XG4gICAgICBwYWdlOiB7XG4gICAgICAgIHNoYXBlczogX2V4dGVuZHMoe30sIGFmdGVyKVxuICAgICAgfSxcbiAgICAgIGFwcFN0YXRlOiB7XG4gICAgICAgIGN1cnJlbnRTdHlsZTogX2V4dGVuZHMoe30sIGRhdGEuYXBwU3RhdGUuY3VycmVudFN0eWxlLCBjaGFuZ2VzKVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZHVwbGljYXRlKGRhdGEsIGlkcykge1xuICB2YXIgZGVsdGEgPSBjb3JlLlZlYy5kaXYoWzE2LCAxNl0sIGRhdGEucGFnZVN0YXRlLmNhbWVyYS56b29tKTtcbiAgdmFyIGFmdGVyID0gT2JqZWN0LmZyb21FbnRyaWVzKFRMRFIuZ2V0U2VsZWN0ZWRJZHMoZGF0YSkubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgIHJldHVybiBkYXRhLnBhZ2Uuc2hhcGVzW2lkXTtcbiAgfSkubWFwKGZ1bmN0aW9uIChzaGFwZSkge1xuICAgIHZhciBpZCA9IGNvcmUuVXRpbHMudW5pcXVlSWQoKTtcbiAgICByZXR1cm4gW2lkLCBfZXh0ZW5kcyh7fSwgY29yZS5VdGlscy5kZWVwQ2xvbmUoc2hhcGUpLCB7XG4gICAgICBpZDogaWQsXG4gICAgICBwb2ludDogY29yZS5WZWMuYWRkKHNoYXBlLnBvaW50LCBkZWx0YSlcbiAgICB9KV07XG4gIH0pKTtcbiAgdmFyIGJlZm9yZSA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3Qua2V5cyhhZnRlcikubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgIHJldHVybiBbaWQsIHVuZGVmaW5lZF07XG4gIH0pKTtcbiAgcmV0dXJuIHtcbiAgICBpZDogJ2R1cGxpY2F0ZScsXG4gICAgYmVmb3JlOiB7XG4gICAgICBwYWdlOiB7XG4gICAgICAgIHNoYXBlczogX2V4dGVuZHMoe30sIGJlZm9yZSlcbiAgICAgIH0sXG4gICAgICBwYWdlU3RhdGU6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2VTdGF0ZSwge1xuICAgICAgICBzZWxlY3RlZElkczogaWRzXG4gICAgICB9KVxuICAgIH0sXG4gICAgYWZ0ZXI6IHtcbiAgICAgIHBhZ2U6IHtcbiAgICAgICAgc2hhcGVzOiBfZXh0ZW5kcyh7fSwgYWZ0ZXIpXG4gICAgICB9LFxuICAgICAgcGFnZVN0YXRlOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlU3RhdGUsIHtcbiAgICAgICAgc2VsZWN0ZWRJZHM6IE9iamVjdC5rZXlzKGFmdGVyKVxuICAgICAgfSlcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1vdmUoZGF0YSwgaWRzLCB0eXBlKSB7XG4gIHZhciBfcmVzdWx0LCBfcmVzdWx0MjtcblxuICAvLyBHZXQgdGhlIHVuaXF1ZSBwYXJlbnQgaWRzIGZvciB0aGUgc2VsZWN0ZWQgZWxlbWVudHNcbiAgdmFyIHBhcmVudElkcyA9IG5ldyBTZXQoaWRzLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gZGF0YS5wYWdlLnNoYXBlc1tpZF0ucGFyZW50SWQ7XG4gIH0pKTtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBiZWZvcmU6IHt9LFxuICAgIGFmdGVyOiB7fVxuICB9O1xuICB2YXIgc3RhcnRJbmRleDtcbiAgdmFyIHN0YXJ0Q2hpbGRJbmRleDtcbiAgdmFyIHN0ZXA7IC8vIENvbGxlY3Qgc2hhcGVzIHdpdGggY29tbW9uIHBhcmVudHMgaW50byBhIHRhYmxlIHVuZGVyIHRoZWlyIHBhcmVudCBpZFxuXG4gIEFycmF5LmZyb20ocGFyZW50SWRzLnZhbHVlcygpKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJlbnRJZCkge1xuICAgIHZhciBzb3J0ZWRDaGlsZHJlbiA9IHBhcmVudElkID09PSBkYXRhLnBhZ2UuaWQgPyBPYmplY3QudmFsdWVzKGRhdGEucGFnZS5zaGFwZXMpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLmNoaWxkSW5kZXggLSBiLmNoaWxkSW5kZXg7XG4gICAgfSkgOiBkYXRhLnBhZ2Uuc2hhcGVzW3BhcmVudElkXS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkSWQpIHtcbiAgICAgIHJldHVybiBkYXRhLnBhZ2Uuc2hhcGVzW2NoaWxkSWRdO1xuICAgIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLmNoaWxkSW5kZXggLSBiLmNoaWxkSW5kZXg7XG4gICAgfSk7XG4gICAgdmFyIHNvcnRlZENoaWxkSWRzID0gc29ydGVkQ2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgcmV0dXJuIHNoYXBlLmlkO1xuICAgIH0pO1xuICAgIHZhciBzb3J0ZWRJbmRpY2VzVG9Nb3ZlID0gaWRzLmZpbHRlcihmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHJldHVybiBzb3J0ZWRDaGlsZElkcy5pbmNsdWRlcyhpZCk7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuIHNvcnRlZENoaWxkSWRzLmluZGV4T2YoaWQpO1xuICAgIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhIC0gYjtcbiAgICB9KTtcbiAgICBpZiAoc29ydGVkSW5kaWNlc1RvTW92ZS5sZW5ndGggPT09IHNvcnRlZENoaWxkSWRzLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIGV4cG9ydHMuTW92ZVR5cGUuVG9CYWNrOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gICAgICAgICAgICAgICBhICAgICAgIGIgIGNcbiAgICAgICAgICAvLyBJbml0aWFsICAgMSAgIDIgICAgMyAgNCAgNSAgNiAgN1xuICAgICAgICAgIC8vIEZpbmFsICAgLjI1ICAuNSAgLjc1ICAxICAzICA2ICA3XG4gICAgICAgICAgLy8gICAgICAgICAgIGEgICBiICAgIGNcbiAgICAgICAgICAvLyBGaW5kIHRoZSBsb3dlc3QgXCJvcGVuXCIgaW5kZXhcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvcnRlZENoaWxkSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc29ydGVkSW5kaWNlc1RvTW92ZS5pbmNsdWRlcyhpKSkgY29udGludWU7XG4gICAgICAgICAgICBzdGFydEluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gLy8gRmluZCB0aGUgbG93ZXN0IGNoaWxkIGluZGV4IHRoYXQgaXNuJ3QgaW4gc29ydGVkSW5kaWNlc1RvTW92ZVxuXG5cbiAgICAgICAgICBzdGFydENoaWxkSW5kZXggPSBzb3J0ZWRDaGlsZHJlbltzdGFydEluZGV4XS5jaGlsZEluZGV4OyAvLyBGaW5kIHRoZSBzdGVwIGZvciBlYWNoIGFkZGl0aW9uYWwgY2hpbGRcblxuICAgICAgICAgIHN0ZXAgPSBzdGFydENoaWxkSW5kZXggLyAoc29ydGVkSW5kaWNlc1RvTW92ZS5sZW5ndGggKyAxKTsgLy8gR2V0IHRoZSByZXN1bHRzIG9mIG1vdmluZyB0aGUgc2VsZWN0ZWQgc2hhcGVzIGJlbG93IHRoZSBmaXJzdCBvcGVuIGluZGV4J3Mgc2hhcGVcblxuICAgICAgICAgIHJlc3VsdCA9IFRMRFIubXV0YXRlU2hhcGVzKGRhdGEsIHNvcnRlZEluZGljZXNUb01vdmUubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICByZXR1cm4gc29ydGVkQ2hpbGRyZW5baV0uaWQ7XG4gICAgICAgICAgfSkucmV2ZXJzZSgpLCBmdW5jdGlvbiAoX3NoYXBlLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBjaGlsZEluZGV4OiBzdGFydENoaWxkSW5kZXggLSAoaSArIDEpICogc3RlcFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIGV4cG9ydHMuTW92ZVR5cGUuVG9Gcm9udDpcbiAgICAgICAge1xuICAgICAgICAgIC8vICAgICAgICAgICAgICBhICAgICBiICBjXG4gICAgICAgICAgLy8gSW5pdGlhbCAgIDEgIDIgIDMgIDQgIDUgIDYgICA3XG4gICAgICAgICAgLy8gRmluYWwgICAgIDEgIDMgIDYgIDcgIDggIDkgIDEwXG4gICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgIGEgIGIgICBjXG4gICAgICAgICAgLy8gRmluZCB0aGUgaGlnaGVzdCBcIm9wZW5cIiBpbmRleFxuICAgICAgICAgIGZvciAodmFyIF9pID0gc29ydGVkQ2hpbGRJZHMubGVuZ3RoIC0gMTsgX2kgPj0gMDsgX2ktLSkge1xuICAgICAgICAgICAgaWYgKHNvcnRlZEluZGljZXNUb01vdmUuaW5jbHVkZXMoX2kpKSBjb250aW51ZTtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBfaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gLy8gRmluZCB0aGUgbG93ZXN0IGNoaWxkIGluZGV4IHRoYXQgaXNuJ3QgaW4gc29ydGVkSW5kaWNlc1RvTW92ZVxuXG5cbiAgICAgICAgICBzdGFydENoaWxkSW5kZXggPSBzb3J0ZWRDaGlsZHJlbltzdGFydEluZGV4XS5jaGlsZEluZGV4OyAvLyBGaW5kIHRoZSBzdGVwIGZvciBlYWNoIGFkZGl0aW9uYWwgY2hpbGRcblxuICAgICAgICAgIHN0ZXAgPSAxOyAvLyBHZXQgdGhlIHJlc3VsdHMgb2YgbW92aW5nIHRoZSBzZWxlY3RlZCBzaGFwZXMgYmVsb3cgdGhlIGZpcnN0IG9wZW4gaW5kZXgncyBzaGFwZVxuXG4gICAgICAgICAgcmVzdWx0ID0gVExEUi5tdXRhdGVTaGFwZXMoZGF0YSwgc29ydGVkSW5kaWNlc1RvTW92ZS5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3J0ZWRDaGlsZHJlbltpXS5pZDtcbiAgICAgICAgICB9KSwgZnVuY3Rpb24gKF9zaGFwZSwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgY2hpbGRJbmRleDogc3RhcnRDaGlsZEluZGV4ICsgKGkgKyAxKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIGV4cG9ydHMuTW92ZVR5cGUuQmFja3dhcmQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyAgICAgICAgICAgICAgIGEgICAgICAgICAgIGIgIGNcbiAgICAgICAgICAvLyBJbml0aWFsICAgIDEgIDIgICAgIDMgICAgIDQgIDUgIDYgIDdcbiAgICAgICAgICAvLyBGaW5hbCAgICAgLjUgIDEgIDEuNjYgIDIuMzMgIDMgIDYgIDdcbiAgICAgICAgICAvLyAgICAgICAgICAgYSAgICAgICAgIGIgICAgIGNcbiAgICAgICAgICB2YXIgaW5kZXhNYXAgPSB7fTsgLy8gU3RhcnRpbmcgZnJvbSB0aGUgdG9wLi4uXG5cbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSBzb3J0ZWRDaGlsZElkcy5sZW5ndGggLSAxOyBfaTIgPj0gMDsgX2kyLS0pIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGZvdW5kIGEgbW92aW5nIGluZGV4Li4uXG4gICAgICAgICAgICBpZiAoc29ydGVkSW5kaWNlc1RvTW92ZS5pbmNsdWRlcyhfaTIpKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGogPSBfaTI7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgLy8gaXRlcmF0ZSBkb3dud2FyZCB1bnRpbCB3ZSBmaW5kIGFuIG9wZW4gc3BvdFxuICAgICAgICAgICAgICAgIGlmICghc29ydGVkSW5kaWNlc1RvTW92ZS5pbmNsdWRlcyhqKSkge1xuICAgICAgICAgICAgICAgICAgLy8gaSA9IHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY2xvc2VkIHNwb3RcbiAgICAgICAgICAgICAgICAgIC8vIGogPSB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IG9wZW4gc3BvdFxuICAgICAgICAgICAgICAgICAgc3RhcnRDaGlsZEluZGV4ID0gaiA9PT0gMCA/IHNvcnRlZENoaWxkcmVuW2pdLmNoaWxkSW5kZXggLyAyIDogc29ydGVkQ2hpbGRyZW5baiAtIDFdLmNoaWxkSW5kZXg7XG5cbiAgICAgICAgICAgICAgICAgIHZhciBfc3RlcCA9IChzb3J0ZWRDaGlsZHJlbltqXS5jaGlsZEluZGV4IC0gc3RhcnRDaGlsZEluZGV4KSAvIChfaTIgLSBqICsgMSk7XG5cbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgX2kyIC0gajsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4TWFwW3NvcnRlZENoaWxkcmVuW2ogKyBrICsgMV0uaWRdID0gc3RhcnRDaGlsZEluZGV4ICsgX3N0ZXAgKiAoayArIDEpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoT2JqZWN0LnZhbHVlcyhpbmRleE1hcCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gR2V0IHRoZSByZXN1bHRzIG9mIG1vdmluZyB0aGUgc2VsZWN0ZWQgc2hhcGVzIGJlbG93IHRoZSBmaXJzdCBvcGVuIGluZGV4J3Mgc2hhcGVcbiAgICAgICAgICAgIHJlc3VsdCA9IFRMRFIubXV0YXRlU2hhcGVzKGRhdGEsIHNvcnRlZEluZGljZXNUb01vdmUubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzb3J0ZWRDaGlsZHJlbltpXS5pZDtcbiAgICAgICAgICAgIH0pLCBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4OiBpbmRleE1hcFtzaGFwZS5pZF1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgZXhwb3J0cy5Nb3ZlVHlwZS5Gb3J3YXJkOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gICAgICAgICAgICAgYSAgICAgYiBjXG4gICAgICAgICAgLy8gSW5pdGlhbCAgIDEgMiAgIDMgNCA1IDYgN1xuICAgICAgICAgIC8vIEZpbmFsICAgICAxIDMgMy41IDYgNyA4IDlcbiAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgYSAgICAgYiBjXG4gICAgICAgICAgdmFyIF9pbmRleE1hcCA9IHt9OyAvLyBTdGFydGluZyBmcm9tIHRoZSB0b3AuLi5cblxuICAgICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IHNvcnRlZENoaWxkSWRzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGZvdW5kIGEgbW92aW5nIGluZGV4Li4uXG4gICAgICAgICAgICBpZiAoc29ydGVkSW5kaWNlc1RvTW92ZS5pbmNsdWRlcyhfaTMpKSB7XG4gICAgICAgICAgICAgIC8vIFNlYXJjaCBmb3IgdGhlIGZpcnN0IG9wZW4gc3BvdCBhYm92ZSB0aGlzIG9uZVxuICAgICAgICAgICAgICBmb3IgKHZhciBfaiA9IF9pMzsgX2ogPCBzb3J0ZWRDaGlsZElkcy5sZW5ndGg7IF9qKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNvcnRlZEluZGljZXNUb01vdmUuaW5jbHVkZXMoX2opKSB7XG4gICAgICAgICAgICAgICAgICAvLyBpID0gdGhlIGxvdyBpbmRleCBvZiB0aGUgZmlyc3QgY2xvc2VkIHNwb3RcbiAgICAgICAgICAgICAgICAgIC8vIGogPSB0aGUgaGlnaCBpbmRleCBvZiB0aGUgZmlyc3Qgb3BlbiBzcG90XG4gICAgICAgICAgICAgICAgICBzdGFydENoaWxkSW5kZXggPSBzb3J0ZWRDaGlsZHJlbltfal0uY2hpbGRJbmRleDtcblxuICAgICAgICAgICAgICAgICAgdmFyIF9zdGVwMiA9IF9qID09PSBzb3J0ZWRDaGlsZElkcy5sZW5ndGggLSAxID8gMSA6IChzb3J0ZWRDaGlsZHJlbltfaiArIDFdLmNoaWxkSW5kZXggLSBzdGFydENoaWxkSW5kZXgpIC8gKF9qIC0gX2kzICsgMSk7XG5cbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9rID0gMDsgX2sgPCBfaiAtIF9pMzsgX2srKykge1xuICAgICAgICAgICAgICAgICAgICBfaW5kZXhNYXBbc29ydGVkQ2hpbGRyZW5bX2kzICsgX2tdLmlkXSA9IHN0YXJ0Q2hpbGRJbmRleCArIF9zdGVwMiAqIChfayArIDEpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoT2JqZWN0LnZhbHVlcyhfaW5kZXhNYXApLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgcmVzdWx0cyBvZiBtb3ZpbmcgdGhlIHNlbGVjdGVkIHNoYXBlcyBiZWxvdyB0aGUgZmlyc3Qgb3BlbiBpbmRleCdzIHNoYXBlXG4gICAgICAgICAgICByZXN1bHQgPSBUTERSLm11dGF0ZVNoYXBlcyhkYXRhLCBzb3J0ZWRJbmRpY2VzVG9Nb3ZlLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICByZXR1cm4gc29ydGVkQ2hpbGRyZW5baV0uaWQ7XG4gICAgICAgICAgICB9KSwgZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleDogX2luZGV4TWFwW3NoYXBlLmlkXVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGlkOiAnbW92ZV9zaGFwZXMnLFxuICAgIGJlZm9yZToge1xuICAgICAgcGFnZTogX2V4dGVuZHMoe30sIGRhdGEucGFnZSwge1xuICAgICAgICBzaGFwZXM6ICgoX3Jlc3VsdCA9IHJlc3VsdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZXN1bHQuYmVmb3JlKSB8fCB7fVxuICAgICAgfSlcbiAgICB9LFxuICAgIGFmdGVyOiB7XG4gICAgICBwYWdlOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlLCB7XG4gICAgICAgIHNoYXBlczogKChfcmVzdWx0MiA9IHJlc3VsdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZXN1bHQyLmFmdGVyKSB8fCB7fVxuICAgICAgfSlcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZShkYXRhLCBpZHMsIGRlbHRhKSB7XG4gIHZhciBfVExEUiRtdXRhdGVTaGFwZXMgPSBUTERSLm11dGF0ZVNoYXBlcyhkYXRhLCBpZHMsIGZ1bmN0aW9uIChzaGFwZSkge1xuICAgIHJldHVybiB7XG4gICAgICBwb2ludDogY29yZS5WZWMuYWRkKHNoYXBlLnBvaW50LCBkZWx0YSlcbiAgICB9O1xuICB9KSxcbiAgICAgIGJlZm9yZSA9IF9UTERSJG11dGF0ZVNoYXBlcy5iZWZvcmUsXG4gICAgICBhZnRlciA9IF9UTERSJG11dGF0ZVNoYXBlcy5hZnRlcjtcblxuICByZXR1cm4ge1xuICAgIGlkOiAndHJhbnNsYXRlX3NoYXBlcycsXG4gICAgYmVmb3JlOiB7XG4gICAgICBwYWdlOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlLCB7XG4gICAgICAgIHNoYXBlczogX2V4dGVuZHMoe30sIGJlZm9yZSlcbiAgICAgIH0pXG4gICAgfSxcbiAgICBhZnRlcjoge1xuICAgICAgcGFnZTogX2V4dGVuZHMoe30sIGRhdGEucGFnZSwge1xuICAgICAgICBzaGFwZXM6IF9leHRlbmRzKHt9LCBhZnRlcilcbiAgICAgIH0pXG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiB0b2dnbGUoZGF0YSwgaWRzLCBwcm9wKSB7XG4gIHZhciBpbml0aWFsU2hhcGVzID0gaWRzLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gZGF0YS5wYWdlLnNoYXBlc1tpZF07XG4gIH0pO1xuICB2YXIgaXNBbGxUb2dnbGVkID0gaW5pdGlhbFNoYXBlcy5ldmVyeShmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICByZXR1cm4gc2hhcGVbcHJvcF07XG4gIH0pO1xuXG4gIHZhciBfVExEUiRtdXRhdGVTaGFwZXMgPSBUTERSLm11dGF0ZVNoYXBlcyhkYXRhLCBUTERSLmdldFNlbGVjdGVkSWRzKGRhdGEpLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICByZXR1cm4gX3JlZiA9IHt9LCBfcmVmW3Byb3BdID0gIWlzQWxsVG9nZ2xlZCwgX3JlZjtcbiAgfSksXG4gICAgICBiZWZvcmUgPSBfVExEUiRtdXRhdGVTaGFwZXMuYmVmb3JlLFxuICAgICAgYWZ0ZXIgPSBfVExEUiRtdXRhdGVTaGFwZXMuYWZ0ZXI7XG5cbiAgcmV0dXJuIHtcbiAgICBpZDogJ3RvZ2dsZV9zaGFwZXMnLFxuICAgIGJlZm9yZToge1xuICAgICAgcGFnZToge1xuICAgICAgICBzaGFwZXM6IF9leHRlbmRzKHt9LCBiZWZvcmUpXG4gICAgICB9XG4gICAgfSxcbiAgICBhZnRlcjoge1xuICAgICAgcGFnZToge1xuICAgICAgICBzaGFwZXM6IF9leHRlbmRzKHt9LCBhZnRlcilcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlbGV0ZVNoYXBlcyhkYXRhLCBpZHMpIHtcbiAgcmV0dXJuIHtcbiAgICBpZDogJ3RvZ2dsZV9zaGFwZXMnLFxuICAgIGJlZm9yZToge1xuICAgICAgcGFnZToge1xuICAgICAgICBzaGFwZXM6IE9iamVjdC5mcm9tRW50cmllcyhpZHMubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgIHJldHVybiBbaWQsIGRhdGEucGFnZS5zaGFwZXNbaWRdXTtcbiAgICAgICAgfSkpXG4gICAgICB9LFxuICAgICAgcGFnZVN0YXRlOiB7XG4gICAgICAgIHNlbGVjdGVkSWRzOiBbXS5jb25jYXQoZGF0YS5wYWdlU3RhdGUuc2VsZWN0ZWRJZHMpXG4gICAgICB9XG4gICAgfSxcbiAgICBhZnRlcjoge1xuICAgICAgcGFnZToge1xuICAgICAgICBzaGFwZXM6IE9iamVjdC5mcm9tRW50cmllcyhpZHMubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgIHJldHVybiBbaWQsIHVuZGVmaW5lZF07XG4gICAgICAgIH0pKVxuICAgICAgfSxcbiAgICAgIHBhZ2VTdGF0ZToge1xuICAgICAgICBzZWxlY3RlZElkczogW11cbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbnZhciBQSTIgPSBNYXRoLlBJICogMjtcbmZ1bmN0aW9uIHJvdGF0ZShkYXRhLCBpZHMsIGRlbHRhKSB7XG4gIGlmIChkZWx0YSA9PT0gdm9pZCAwKSB7XG4gICAgZGVsdGEgPSAtUEkyIC8gNDtcbiAgfVxuXG4gIHZhciBpbml0aWFsU2hhcGVzID0gaWRzLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gZGF0YS5wYWdlLnNoYXBlc1tpZF07XG4gIH0pO1xuICB2YXIgYm91bmRzRm9yU2hhcGVzID0gaW5pdGlhbFNoYXBlcy5tYXAoZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgdmFyIHV0aWxzID0gVExEUi5nZXRTaGFwZVV0aWxzKHNoYXBlKTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHNoYXBlLmlkLFxuICAgICAgcG9pbnQ6IFtdLmNvbmNhdChzaGFwZS5wb2ludCksXG4gICAgICBib3VuZHM6IHV0aWxzLmdldEJvdW5kcyhzaGFwZSksXG4gICAgICBjZW50ZXI6IHV0aWxzLmdldENlbnRlcihzaGFwZSksXG4gICAgICByb3RhdGlvbjogc2hhcGUucm90YXRpb25cbiAgICB9O1xuICB9KTtcbiAgdmFyIGNvbW1vbkJvdW5kcyA9IGNvcmUuVXRpbHMuZ2V0Q29tbW9uQm91bmRzKGJvdW5kc0ZvclNoYXBlcy5tYXAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgYm91bmRzID0gX3JlZi5ib3VuZHM7XG4gICAgcmV0dXJuIGJvdW5kcztcbiAgfSkpO1xuICB2YXIgY29tbW9uQm91bmRzQ2VudGVyID0gY29yZS5VdGlscy5nZXRCb3VuZHNDZW50ZXIoY29tbW9uQm91bmRzKTtcbiAgdmFyIHJvdGF0aW9ucyA9IE9iamVjdC5mcm9tRW50cmllcyhib3VuZHNGb3JTaGFwZXMubWFwKGZ1bmN0aW9uIChfcmVmMikge1xuICAgIHZhciBpZCA9IF9yZWYyLmlkLFxuICAgICAgICBwb2ludCA9IF9yZWYyLnBvaW50LFxuICAgICAgICBjZW50ZXIgPSBfcmVmMi5jZW50ZXIsXG4gICAgICAgIHJvdGF0aW9uID0gX3JlZjIucm90YXRpb247XG4gICAgdmFyIG9mZnNldCA9IGNvcmUuVmVjLnN1YihjZW50ZXIsIHBvaW50KTtcbiAgICB2YXIgbmV4dFBvaW50ID0gY29yZS5WZWMuc3ViKGNvcmUuVmVjLnJvdFdpdGgoY2VudGVyLCBjb21tb25Cb3VuZHNDZW50ZXIsIC0oUEkyIC8gNCkpLCBvZmZzZXQpO1xuICAgIHZhciBuZXh0Um90YXRpb24gPSAoUEkyICsgKChyb3RhdGlvbiB8fCAwKSArIGRlbHRhKSkgJSBQSTI7XG4gICAgcmV0dXJuIFtpZCwge1xuICAgICAgcG9pbnQ6IG5leHRQb2ludCxcbiAgICAgIHJvdGF0aW9uOiBuZXh0Um90YXRpb25cbiAgICB9XTtcbiAgfSkpO1xuICB2YXIgcHJldkJvdW5kc1JvdGF0aW9uID0gZGF0YS5wYWdlU3RhdGUuYm91bmRzUm90YXRpb247XG4gIHZhciBuZXh0Qm91bmRzUm90YXRpb24gPSAoUEkyICsgKChkYXRhLnBhZ2VTdGF0ZS5ib3VuZHNSb3RhdGlvbiB8fCAwKSArIGRlbHRhKSkgJSBQSTI7XG5cbiAgdmFyIF9UTERSJG11dGF0ZVNoYXBlcyA9IFRMRFIubXV0YXRlU2hhcGVzKGRhdGEsIGlkcywgZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgcmV0dXJuIHJvdGF0aW9uc1tzaGFwZS5pZF07XG4gIH0pLFxuICAgICAgYmVmb3JlID0gX1RMRFIkbXV0YXRlU2hhcGVzLmJlZm9yZSxcbiAgICAgIGFmdGVyID0gX1RMRFIkbXV0YXRlU2hhcGVzLmFmdGVyO1xuXG4gIHJldHVybiB7XG4gICAgaWQ6ICd0b2dnbGVfc2hhcGVzJyxcbiAgICBiZWZvcmU6IHtcbiAgICAgIHBhZ2U6IHtcbiAgICAgICAgc2hhcGVzOiBfZXh0ZW5kcyh7fSwgYmVmb3JlKVxuICAgICAgfSxcbiAgICAgIHBhZ2VTdGF0ZToge1xuICAgICAgICBib3VuZHNSb3RhdGlvbjogcHJldkJvdW5kc1JvdGF0aW9uXG4gICAgICB9XG4gICAgfSxcbiAgICBhZnRlcjoge1xuICAgICAgcGFnZToge1xuICAgICAgICBzaGFwZXM6IF9leHRlbmRzKHt9LCBhZnRlcilcbiAgICAgIH0sXG4gICAgICBwYWdlU3RhdGU6IHtcbiAgICAgICAgYm91bmRzUm90YXRpb246IG5leHRCb3VuZHNSb3RhdGlvblxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gc3RyZXRjaChkYXRhLCBpZHMsIHR5cGUpIHtcbiAgdmFyIGluaXRpYWxTaGFwZXMgPSBpZHMubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgIHJldHVybiBkYXRhLnBhZ2Uuc2hhcGVzW2lkXTtcbiAgfSk7XG4gIHZhciBib3VuZHNGb3JTaGFwZXMgPSBpbml0aWFsU2hhcGVzLm1hcChmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICByZXR1cm4gVExEUi5nZXRCb3VuZHMoc2hhcGUpO1xuICB9KTtcbiAgdmFyIGNvbW1vbkJvdW5kcyA9IGNvcmUuVXRpbHMuZ2V0Q29tbW9uQm91bmRzKGJvdW5kc0ZvclNoYXBlcyk7XG5cbiAgdmFyIF9UTERSJG11dGF0ZVNoYXBlcyA9IFRMRFIubXV0YXRlU2hhcGVzKGRhdGEsIGlkcywgZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgdmFyIGJvdW5kcyA9IFRMRFIuZ2V0Qm91bmRzKHNoYXBlKTtcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBleHBvcnRzLlN0cmV0Y2hUeXBlLkhvcml6b250YWw6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbmV3Qm91bmRzID0gX2V4dGVuZHMoe30sIGJvdW5kcywge1xuICAgICAgICAgICAgbWluWDogY29tbW9uQm91bmRzLm1pblgsXG4gICAgICAgICAgICBtYXhYOiBjb21tb25Cb3VuZHMubWF4WCxcbiAgICAgICAgICAgIHdpZHRoOiBjb21tb25Cb3VuZHMud2lkdGhcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiBUTERSLmdldFNoYXBlVXRpbHMoc2hhcGUpLnRyYW5zZm9ybVNpbmdsZShzaGFwZSwgbmV3Qm91bmRzLCB7XG4gICAgICAgICAgICB0eXBlOiBjb3JlLlRMQm91bmRzQ29ybmVyLlRvcExlZnQsXG4gICAgICAgICAgICBzY2FsZVg6IG5ld0JvdW5kcy53aWR0aCAvIGJvdW5kcy53aWR0aCxcbiAgICAgICAgICAgIHNjYWxlWTogMSxcbiAgICAgICAgICAgIGluaXRpYWxTaGFwZTogc2hhcGUsXG4gICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW46IFswLjUsIDAuNV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIGV4cG9ydHMuU3RyZXRjaFR5cGUuVmVydGljYWw6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX25ld0JvdW5kcyA9IF9leHRlbmRzKHt9LCBib3VuZHMsIHtcbiAgICAgICAgICAgIG1pblk6IGNvbW1vbkJvdW5kcy5taW5ZLFxuICAgICAgICAgICAgbWF4WTogY29tbW9uQm91bmRzLm1heFksXG4gICAgICAgICAgICBoZWlnaHQ6IGNvbW1vbkJvdW5kcy5oZWlnaHRcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiBUTERSLmdldFNoYXBlVXRpbHMoc2hhcGUpLnRyYW5zZm9ybVNpbmdsZShzaGFwZSwgX25ld0JvdW5kcywge1xuICAgICAgICAgICAgdHlwZTogY29yZS5UTEJvdW5kc0Nvcm5lci5Ub3BMZWZ0LFxuICAgICAgICAgICAgc2NhbGVYOiAxLFxuICAgICAgICAgICAgc2NhbGVZOiBfbmV3Qm91bmRzLmhlaWdodCAvIGJvdW5kcy5oZWlnaHQsXG4gICAgICAgICAgICBpbml0aWFsU2hhcGU6IHNoYXBlLFxuICAgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiBbMC41LCAwLjVdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gIH0pLFxuICAgICAgYmVmb3JlID0gX1RMRFIkbXV0YXRlU2hhcGVzLmJlZm9yZSxcbiAgICAgIGFmdGVyID0gX1RMRFIkbXV0YXRlU2hhcGVzLmFmdGVyO1xuXG4gIHJldHVybiB7XG4gICAgaWQ6ICdzdHJldGNoX3NoYXBlcycsXG4gICAgYmVmb3JlOiB7XG4gICAgICBwYWdlOiB7XG4gICAgICAgIHNoYXBlczogX2V4dGVuZHMoe30sIGJlZm9yZSlcbiAgICAgIH1cbiAgICB9LFxuICAgIGFmdGVyOiB7XG4gICAgICBwYWdlOiB7XG4gICAgICAgIHNoYXBlczogX2V4dGVuZHMoe30sIGFmdGVyKVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlKGRhdGEsIHNoYXBlcykge1xuICByZXR1cm4ge1xuICAgIGlkOiAndG9nZ2xlX3NoYXBlcycsXG4gICAgYmVmb3JlOiB7XG4gICAgICBwYWdlOiB7XG4gICAgICAgIHNoYXBlczogT2JqZWN0LmZyb21FbnRyaWVzKHNoYXBlcy5tYXAoZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICAgICAgcmV0dXJuIFtzaGFwZS5pZCwgdW5kZWZpbmVkXTtcbiAgICAgICAgfSkpXG4gICAgICB9XG4gICAgfSxcbiAgICBhZnRlcjoge1xuICAgICAgcGFnZToge1xuICAgICAgICBzaGFwZXM6IE9iamVjdC5mcm9tRW50cmllcyhzaGFwZXMubWFwKGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgICAgIHJldHVybiBbc2hhcGUuaWQsIHNoYXBlXTtcbiAgICAgICAgfSkpXG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgQnJ1c2hTZXNzaW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnJ1c2hTZXNzaW9uKF9kYXRhLCBfcG9pbnQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5pZCA9ICdicnVzaCc7XG4gICAgdGhpcy5vcmlnaW4gPSB2b2lkIDA7XG4gICAgdGhpcy5zbmFwc2hvdCA9IHZvaWQgMDtcblxuICAgIHRoaXMuc3RhcnQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuICAgIHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIHBvaW50LCBjb250YWluTW9kZSkge1xuICAgICAgaWYgKGNvbnRhaW5Nb2RlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGFpbk1vZGUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNuYXBzaG90ID0gX3RoaXMuc25hcHNob3QsXG4gICAgICAgICAgb3JpZ2luID0gX3RoaXMub3JpZ2luOyAvLyBDcmVhdGUgYSBib3VuZGluZyBib3ggYmV0d2VlbiB0aGUgb3JpZ2luIGFuZCB0aGUgbmV3IHBvaW50XG5cbiAgICAgIHZhciBicnVzaCA9IGNvcmUuVXRpbHMuZ2V0Qm91bmRzRnJvbVBvaW50cyhbb3JpZ2luLCBwb2ludF0pO1xuICAgICAgY29yZS5icnVzaFVwZGF0ZXIuc2V0KGJydXNoKTsgLy8gRmluZCBpZHMgb2YgYnJ1c2hlZCBzaGFwZXNcblxuICAgICAgdmFyIGhpdHMgPSBuZXcgU2V0KCk7XG4gICAgICB2YXIgc2VsZWN0ZWRJZHMgPSBuZXcgU2V0KHNuYXBzaG90LnNlbGVjdGVkSWRzKTtcbiAgICAgIHNuYXBzaG90LnNoYXBlc1RvVGVzdC5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBpZCA9IF9yZWYuaWQsXG4gICAgICAgICAgICB1dGlsID0gX3JlZi51dGlsLFxuICAgICAgICAgICAgc2VsZWN0SWQgPSBfcmVmLnNlbGVjdElkO1xuICAgICAgICBpZiAoc2VsZWN0ZWRJZHMuaGFzKGlkKSkgcmV0dXJuO1xuICAgICAgICB2YXIgc2hhcGUgPSBkYXRhLnBhZ2Uuc2hhcGVzW2lkXTtcblxuICAgICAgICBpZiAoIWhpdHMuaGFzKHNlbGVjdElkKSkge1xuICAgICAgICAgIGlmIChjb250YWluTW9kZSA/IGNvcmUuVXRpbHMuYm91bmRzQ29udGFpbihicnVzaCwgdXRpbC5nZXRCb3VuZHMoc2hhcGUpKSA6IHV0aWwuaGl0VGVzdEJvdW5kcyhzaGFwZSwgYnJ1c2gpKSB7XG4gICAgICAgICAgICBoaXRzLmFkZChzZWxlY3RJZCk7IC8vIFdoZW4gYnJ1c2hpbmcgYSBzaGFwZSwgc2VsZWN0IGl0cyB0b3AgZ3JvdXAgcGFyZW50LlxuXG4gICAgICAgICAgICBpZiAoIXNlbGVjdGVkSWRzLmhhcyhzZWxlY3RJZCkpIHtcbiAgICAgICAgICAgICAgc2VsZWN0ZWRJZHMuYWRkKHNlbGVjdElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdGVkSWRzLmhhcyhzZWxlY3RJZCkpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkSWRzW1wiZGVsZXRlXCJdKHNlbGVjdElkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc2VsZWN0ZWRJZHMuc2l6ZSA9PT0gZGF0YS5wYWdlU3RhdGUuc2VsZWN0ZWRJZHMubGVuZ3RoICYmIGRhdGEucGFnZVN0YXRlLnNlbGVjdGVkSWRzLmV2ZXJ5KGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWRJZHMuaGFzKGlkKTtcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGRhdGEsIHtcbiAgICAgICAgcGFnZVN0YXRlOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlU3RhdGUsIHtcbiAgICAgICAgICBzZWxlY3RlZElkczogQXJyYXkuZnJvbShzZWxlY3RlZElkcy52YWx1ZXMoKSlcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLm9yaWdpbiA9IGNvcmUuVmVjLnJvdW5kKF9wb2ludCk7XG4gICAgdGhpcy5zbmFwc2hvdCA9IGdldEJydXNoU25hcHNob3QoX2RhdGEpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEJydXNoU2Vzc2lvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNhbmNlbCA9IGZ1bmN0aW9uIGNhbmNlbChkYXRhKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBkYXRhLCB7XG4gICAgICBwYWdlU3RhdGU6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2VTdGF0ZSwge1xuICAgICAgICBzZWxlY3RlZElkczogdGhpcy5zbmFwc2hvdC5zZWxlY3RlZElkc1xuICAgICAgfSlcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGxldGUgPSBmdW5jdGlvbiBjb21wbGV0ZShkYXRhKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBkYXRhLCB7XG4gICAgICBwYWdlU3RhdGU6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2VTdGF0ZSwge1xuICAgICAgICBzZWxlY3RlZElkczogW10uY29uY2F0KGRhdGEucGFnZVN0YXRlLnNlbGVjdGVkSWRzKVxuICAgICAgfSlcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gQnJ1c2hTZXNzaW9uO1xufSgpO1xuLyoqXHJcbiAqIEdldCBhIHNuYXBzaG90IG9mIHRoZSBjdXJyZW50IHNlbGVjdGVkIGlkcywgZm9yIGVhY2ggc2hhcGUgdGhhdCBpc1xyXG4gKiBub3QgYWxyZWFkeSBzZWxlY3RlZCwgdGhlIHNoYXBlJ3MgaWQgYW5kIGEgdGVzdCB0byBzZWUgd2hldGhlciB0aGVcclxuICogYnJ1c2ggd2lsbCBpbnRlcnNlY3QgdGhhdCBzaGFwZS4gRm9yIHRlc3RzLCBzdGFydCBicm9hZCAtPiBmaW5lLlxyXG4gKi9cblxuZnVuY3Rpb24gZ2V0QnJ1c2hTbmFwc2hvdChkYXRhKSB7XG4gIHZhciBzZWxlY3RlZElkcyA9IFtdLmNvbmNhdChkYXRhLnBhZ2VTdGF0ZS5zZWxlY3RlZElkcyk7XG4gIHZhciBzaGFwZXNUb1Rlc3QgPSBUTERSLmdldFNoYXBlcyhkYXRhKS5maWx0ZXIoZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgcmV0dXJuICEoc2hhcGUuaXNIaWRkZW4gfHwgc2hhcGUuY2hpbGRyZW4gIT09IHVuZGVmaW5lZCB8fCBzZWxlY3RlZElkcy5pbmNsdWRlcyhzaGFwZS5pZCkgfHwgc2VsZWN0ZWRJZHMuaW5jbHVkZXMoc2hhcGUucGFyZW50SWQpKTtcbiAgfSkubWFwKGZ1bmN0aW9uIChzaGFwZSkge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogc2hhcGUuaWQsXG4gICAgICB1dGlsOiBnZXRTaGFwZVV0aWxzKHNoYXBlKSxcbiAgICAgIGJvdW5kczogZ2V0U2hhcGVVdGlscyhzaGFwZSkuZ2V0Qm91bmRzKHNoYXBlKSxcbiAgICAgIHNlbGVjdElkOiBUTERSLmdldFRvcFBhcmVudElkKGRhdGEsIHNoYXBlLmlkKVxuICAgIH07XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHNlbGVjdGVkSWRzOiBzZWxlY3RlZElkcyxcbiAgICBzaGFwZXNUb1Rlc3Q6IHNoYXBlc1RvVGVzdFxuICB9O1xufVxuXG52YXIgVHJhbnNsYXRlU2Vzc2lvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRyYW5zbGF0ZVNlc3Npb24oX2RhdGEsIF9wb2ludCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLmlkID0gJ3RyYW5zbGF0ZSc7XG4gICAgdGhpcy5kZWx0YSA9IFswLCAwXTtcbiAgICB0aGlzLnByZXYgPSBbMCwgMF07XG4gICAgdGhpcy5vcmlnaW4gPSB2b2lkIDA7XG4gICAgdGhpcy5zbmFwc2hvdCA9IHZvaWQgMDtcbiAgICB0aGlzLmlzQ2xvbmluZyA9IGZhbHNlO1xuXG4gICAgdGhpcy5zdGFydCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuXG4gICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgcG9pbnQsIGlzQWxpZ25lZCwgaXNDbG9uaW5nKSB7XG4gICAgICBpZiAoaXNBbGlnbmVkID09PSB2b2lkIDApIHtcbiAgICAgICAgaXNBbGlnbmVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Nsb25pbmcgPT09IHZvaWQgMCkge1xuICAgICAgICBpc0Nsb25pbmcgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIF90aGlzJHNuYXBzaG90ID0gX3RoaXMuc25hcHNob3QsXG4gICAgICAgICAgY2xvbmVzID0gX3RoaXMkc25hcHNob3QuY2xvbmVzLFxuICAgICAgICAgIGluaXRpYWxTaGFwZXMgPSBfdGhpcyRzbmFwc2hvdC5pbml0aWFsU2hhcGVzO1xuXG4gICAgICB2YXIgbmV4dCA9IF9leHRlbmRzKHt9LCBkYXRhLCB7XG4gICAgICAgIHBhZ2U6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2UpLFxuICAgICAgICBzaGFwZXM6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2Uuc2hhcGVzKSxcbiAgICAgICAgcGFnZVN0YXRlOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlU3RhdGUpXG4gICAgICB9KTtcblxuICAgICAgdmFyIGRlbHRhID0gY29yZS5WZWMuc3ViKHBvaW50LCBfdGhpcy5vcmlnaW4pO1xuXG4gICAgICBpZiAoaXNBbGlnbmVkKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhkZWx0YVswXSkgPCBNYXRoLmFicyhkZWx0YVsxXSkpIHtcbiAgICAgICAgICBkZWx0YVswXSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsdGFbMV0gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0cnVlRGVsdGEgPSBjb3JlLlZlYy5zdWIoZGVsdGEsIF90aGlzLnByZXYpO1xuICAgICAgX3RoaXMuZGVsdGEgPSBkZWx0YTtcbiAgICAgIF90aGlzLnByZXYgPSBkZWx0YTsgLy8gSWYgY2xvbmluZy4uLlxuXG4gICAgICBpZiAoaXNDbG9uaW5nKSB7XG4gICAgICAgIC8vIE5vdCBDbG9uaW5nIC0+IENsb25pbmdcbiAgICAgICAgaWYgKCFfdGhpcy5pc0Nsb25pbmcpIHtcbiAgICAgICAgICBfdGhpcy5pc0Nsb25pbmcgPSB0cnVlOyAvLyBNb3ZlIG9yaWdpbmFsIHNoYXBlcyBiYWNrIHRvIHN0YXJ0XG5cbiAgICAgICAgICBuZXh0LnBhZ2Uuc2hhcGVzID0gX2V4dGVuZHMoe30sIG5leHQucGFnZS5zaGFwZXMsIE9iamVjdC5mcm9tRW50cmllcyhpbml0aWFsU2hhcGVzLm1hcChmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgICAgICAgIHJldHVybiBbc2hhcGUuaWQsIF9leHRlbmRzKHt9LCBuZXh0LnBhZ2Uuc2hhcGVzW3NoYXBlLmlkXSwge1xuICAgICAgICAgICAgICBwb2ludDogc2hhcGUucG9pbnRcbiAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICB9KSkpO1xuICAgICAgICAgIG5leHQucGFnZS5zaGFwZXMgPSBfZXh0ZW5kcyh7fSwgbmV4dC5wYWdlLnNoYXBlcywgT2JqZWN0LmZyb21FbnRyaWVzKGNsb25lcy5tYXAoZnVuY3Rpb24gKGNsb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gW2Nsb25lLmlkLCBfZXh0ZW5kcyh7fSwgY2xvbmUsIHtcbiAgICAgICAgICAgICAgcG9pbnQ6IGNvcmUuVmVjLmFkZChjbG9uZS5wb2ludCwgZGVsdGEpXG4gICAgICAgICAgICB9KV07XG4gICAgICAgICAgfSkpKTtcbiAgICAgICAgICBuZXh0LnBhZ2VTdGF0ZS5zZWxlY3RlZElkcyA9IGNsb25lcy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHJldHVybiBjLmlkO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vIEVpdGhlciB3YXksIG1vdmUgdGhlIGNsb25lc1xuXG5cbiAgICAgICAgbmV4dC5wYWdlLnNoYXBlcyA9IF9leHRlbmRzKHt9LCBuZXh0LnBhZ2Uuc2hhcGVzLCBPYmplY3QuZnJvbUVudHJpZXMoY2xvbmVzLm1hcChmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgICAgICByZXR1cm4gW2Nsb25lLmlkLCBfZXh0ZW5kcyh7fSwgY2xvbmUsIHtcbiAgICAgICAgICAgIHBvaW50OiBjb3JlLlZlYy5hZGQobmV4dC5wYWdlLnNoYXBlc1tjbG9uZS5pZF0ucG9pbnQsIHRydWVEZWx0YSlcbiAgICAgICAgICB9KV07XG4gICAgICAgIH0pKSk7XG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgfSAvLyBJZiBub3QgY2xvbmluZy4uLlxuICAgICAgLy8gQ2xvbmluZyAtPiBOb3QgQ2xvbmluZ1xuXG5cbiAgICAgIGlmIChfdGhpcy5pc0Nsb25pbmcpIHtcbiAgICAgICAgX3RoaXMuaXNDbG9uaW5nID0gZmFsc2U7IC8vIERlbGV0ZSB0aGUgY2xvbmVzXG5cbiAgICAgICAgY2xvbmVzLmZvckVhY2goZnVuY3Rpb24gKGNsb25lKSB7XG4gICAgICAgICAgcmV0dXJuIGRlbGV0ZSBuZXh0LnBhZ2Uuc2hhcGVzW2Nsb25lLmlkXTtcbiAgICAgICAgfSk7IC8vIE1vdmUgdGhlIG9yaWdpbmFsIHNoYXBlcyBiYWNrIHRvIHRoZSBjdXJzb3IgcG9zaXRpb25cblxuICAgICAgICBuZXh0LnBhZ2Uuc2hhcGVzID0gX2V4dGVuZHMoe30sIG5leHQucGFnZS5zaGFwZXMsIE9iamVjdC5mcm9tRW50cmllcyhpbml0aWFsU2hhcGVzLm1hcChmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgICAgICByZXR1cm4gW3NoYXBlLmlkLCBfZXh0ZW5kcyh7fSwgbmV4dC5wYWdlLnNoYXBlc1tzaGFwZS5pZF0sIHtcbiAgICAgICAgICAgIHBvaW50OiBjb3JlLlZlYy5hZGQoc2hhcGUucG9pbnQsIGRlbHRhKVxuICAgICAgICAgIH0pXTtcbiAgICAgICAgfSkpKTsgLy8gU2V0IHNlbGVjdGVkIGlkc1xuXG4gICAgICAgIG5leHQucGFnZVN0YXRlLnNlbGVjdGVkSWRzID0gaW5pdGlhbFNoYXBlcy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICByZXR1cm4gYy5pZDtcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIE1vdmUgdGhlIHNoYXBlcyBieSB0aGUgZGVsdGFcblxuXG4gICAgICBuZXh0LnBhZ2Uuc2hhcGVzID0gX2V4dGVuZHMoe30sIG5leHQucGFnZS5zaGFwZXMsIE9iamVjdC5mcm9tRW50cmllcyhpbml0aWFsU2hhcGVzLm1hcChmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgICAgcmV0dXJuIFtzaGFwZS5pZCwgX2V4dGVuZHMoe30sIG5leHQucGFnZS5zaGFwZXNbc2hhcGUuaWRdLCB7XG4gICAgICAgICAgcG9pbnQ6IGNvcmUuVmVjLmFkZChuZXh0LnBhZ2Uuc2hhcGVzW3NoYXBlLmlkXS5wb2ludCwgdHJ1ZURlbHRhKVxuICAgICAgICB9KV07XG4gICAgICB9KSkpO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcblxuICAgIHRoaXMuY2FuY2VsID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgZGF0YSwge1xuICAgICAgICBwYWdlOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlLCB7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZSAtIFdlIG5lZWQgdG8gc2V0IGRlbGV0ZWQgc2hhcGVzIHRvIHVuZGVmaW5lZCBpbiBvcmRlciB0byBjb3JyZWN0bHkgZGVlcCBtZXJnZSB0aGVtIGF3YXkuXG4gICAgICAgICAgc2hhcGVzOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlLnNoYXBlcywgT2JqZWN0LmZyb21FbnRyaWVzKF90aGlzLnNuYXBzaG90LmNsb25lcy5tYXAoZnVuY3Rpb24gKGNsb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gW2Nsb25lLmlkLCB1bmRlZmluZWRdO1xuICAgICAgICAgIH0pKSwgT2JqZWN0LmZyb21FbnRyaWVzKF90aGlzLnNuYXBzaG90LmluaXRpYWxTaGFwZXMubWFwKGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtzaGFwZS5pZCwgX2V4dGVuZHMoe30sIGRhdGEucGFnZS5zaGFwZXNbc2hhcGUuaWRdLCB7XG4gICAgICAgICAgICAgIHBvaW50OiBzaGFwZS5wb2ludFxuICAgICAgICAgICAgfSldO1xuICAgICAgICAgIH0pKSlcbiAgICAgICAgfSksXG4gICAgICAgIHBhZ2VTdGF0ZTogX2V4dGVuZHMoe30sIGRhdGEucGFnZVN0YXRlLCB7XG4gICAgICAgICAgc2VsZWN0ZWRJZHM6IF90aGlzLnNuYXBzaG90LnNlbGVjdGVkSWRzXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5vcmlnaW4gPSBfcG9pbnQ7XG4gICAgdGhpcy5zbmFwc2hvdCA9IGdldFRyYW5zbGF0ZVNuYXBzaG90KF9kYXRhKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBUcmFuc2xhdGVTZXNzaW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uY29tcGxldGUgPSBmdW5jdGlvbiBjb21wbGV0ZShkYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiAndHJhbnNsYXRlJyxcbiAgICAgIGJlZm9yZTogX2V4dGVuZHMoe30sIGRhdGEsIHtcbiAgICAgICAgcGFnZTogX2V4dGVuZHMoe30sIGRhdGEucGFnZSwge1xuICAgICAgICAgIHNoYXBlczogX2V4dGVuZHMoe30sIGRhdGEucGFnZS5zaGFwZXMsIE9iamVjdC5mcm9tRW50cmllcyh0aGlzLnNuYXBzaG90LmNsb25lcy5tYXAoZnVuY3Rpb24gKGNsb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gW2Nsb25lLmlkLCB1bmRlZmluZWRdO1xuICAgICAgICAgIH0pKSwgT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuc25hcHNob3QuaW5pdGlhbFNoYXBlcy5tYXAoZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gW3NoYXBlLmlkLCB7XG4gICAgICAgICAgICAgIHBvaW50OiBzaGFwZS5wb2ludFxuICAgICAgICAgICAgfV07XG4gICAgICAgICAgfSkpKVxuICAgICAgICB9KSxcbiAgICAgICAgcGFnZVN0YXRlOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlU3RhdGUsIHtcbiAgICAgICAgICBzZWxlY3RlZElkczogdGhpcy5zbmFwc2hvdC5zZWxlY3RlZElkc1xuICAgICAgICB9KVxuICAgICAgfSksXG4gICAgICBhZnRlcjogX2V4dGVuZHMoe30sIGRhdGEsIHtcbiAgICAgICAgcGFnZTogX2V4dGVuZHMoe30sIGRhdGEucGFnZSwge1xuICAgICAgICAgIHNoYXBlczogX2V4dGVuZHMoe30sIGRhdGEucGFnZS5zaGFwZXMsIE9iamVjdC5mcm9tRW50cmllcyh0aGlzLnNuYXBzaG90LmNsb25lcy5tYXAoZnVuY3Rpb24gKGNsb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gW2Nsb25lLmlkLCBkYXRhLnBhZ2Uuc2hhcGVzW2Nsb25lLmlkXV07XG4gICAgICAgICAgfSkpLCBPYmplY3QuZnJvbUVudHJpZXModGhpcy5zbmFwc2hvdC5pbml0aWFsU2hhcGVzLm1hcChmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgICAgICAgIHJldHVybiBbc2hhcGUuaWQsIHtcbiAgICAgICAgICAgICAgcG9pbnQ6IGRhdGEucGFnZS5zaGFwZXNbc2hhcGUuaWRdLnBvaW50XG4gICAgICAgICAgICB9XTtcbiAgICAgICAgICB9KSkpXG4gICAgICAgIH0pLFxuICAgICAgICBwYWdlU3RhdGU6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2VTdGF0ZSwge1xuICAgICAgICAgIHNlbGVjdGVkSWRzOiBbXS5jb25jYXQoZGF0YS5wYWdlU3RhdGUuc2VsZWN0ZWRJZHMpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIFRyYW5zbGF0ZVNlc3Npb247XG59KCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG5cbmZ1bmN0aW9uIGdldFRyYW5zbGF0ZVNuYXBzaG90KGRhdGEpIHtcbiAgdmFyIHNlbGVjdGVkU2hhcGVzID0gVExEUi5nZXRTZWxlY3RlZFNoYXBlU25hcHNob3QoZGF0YSk7XG4gIHZhciBoYXNVbmxvY2tlZFNoYXBlcyA9IHNlbGVjdGVkU2hhcGVzLmxlbmd0aCA+IDA7XG4gIHZhciBpbml0aWFsUGFyZW50cyA9IEFycmF5LmZyb20obmV3IFNldChzZWxlY3RlZFNoYXBlcy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gcy5wYXJlbnRJZDtcbiAgfSkpLnZhbHVlcygpKS5maWx0ZXIoZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIGlkICE9PSBkYXRhLnBhZ2UuaWQ7XG4gIH0pLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgc2hhcGUgPSBUTERSLmdldFNoYXBlKGRhdGEsIGlkKTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGlkLFxuICAgICAgY2hpbGRyZW46IHNoYXBlLmNoaWxkcmVuXG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgc2VsZWN0ZWRJZHM6IFRMRFIuZ2V0U2VsZWN0ZWRJZHMoZGF0YSksXG4gICAgaGFzVW5sb2NrZWRTaGFwZXM6IGhhc1VubG9ja2VkU2hhcGVzLFxuICAgIGluaXRpYWxQYXJlbnRzOiBpbml0aWFsUGFyZW50cyxcbiAgICBpbml0aWFsU2hhcGVzOiBzZWxlY3RlZFNoYXBlcy5tYXAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBpZCA9IF9yZWYuaWQsXG4gICAgICAgICAgcG9pbnQgPSBfcmVmLnBvaW50LFxuICAgICAgICAgIHBhcmVudElkID0gX3JlZi5wYXJlbnRJZDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICBwYXJlbnRJZDogcGFyZW50SWRcbiAgICAgIH07XG4gICAgfSksXG4gICAgY2xvbmVzOiBzZWxlY3RlZFNoYXBlcy5maWx0ZXIoZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICByZXR1cm4gc2hhcGUuY2hpbGRyZW4gPT09IHVuZGVmaW5lZDtcbiAgICB9KS5mbGF0TWFwKGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgdmFyIGNsb25lID0gX2V4dGVuZHMoe30sIHNoYXBlLCB7XG4gICAgICAgIGlkOiBjb3JlLlV0aWxzLnVuaXF1ZUlkKCksXG4gICAgICAgIHBhcmVudElkOiBzaGFwZS5wYXJlbnRJZCxcbiAgICAgICAgY2hpbGRJbmRleDogVExEUi5nZXRDaGlsZEluZGV4QWJvdmUoZGF0YSwgc2hhcGUuaWQpXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH0pXG4gIH07XG59XG5cbnZhciBUcmFuc2Zvcm1TaW5nbGVTZXNzaW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVHJhbnNmb3JtU2luZ2xlU2Vzc2lvbihfZGF0YSwgX3BvaW50LCBfdHJhbnNmb3JtVHlwZSwgY29tbWFuZElkKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmIChfdHJhbnNmb3JtVHlwZSA9PT0gdm9pZCAwKSB7XG4gICAgICBfdHJhbnNmb3JtVHlwZSA9IGNvcmUuVExCb3VuZHNDb3JuZXIuQm90dG9tUmlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKGNvbW1hbmRJZCA9PT0gdm9pZCAwKSB7XG4gICAgICBjb21tYW5kSWQgPSAndHJhbnNmb3JtX3NpbmdsZSc7XG4gICAgfVxuXG4gICAgdGhpcy5pZCA9ICd0cmFuc2Zvcm1fc2luZ2xlJztcbiAgICB0aGlzLmNvbW1hbmRJZCA9IHZvaWQgMDtcbiAgICB0aGlzLnRyYW5zZm9ybVR5cGUgPSB2b2lkIDA7XG4gICAgdGhpcy5vcmlnaW4gPSB2b2lkIDA7XG4gICAgdGhpcy5zY2FsZVggPSAxO1xuICAgIHRoaXMuc2NhbGVZID0gMTtcbiAgICB0aGlzLnNuYXBzaG90ID0gdm9pZCAwO1xuXG4gICAgdGhpcy5zdGFydCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuXG4gICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgcG9pbnQsIGlzQXNwZWN0UmF0aW9Mb2NrZWQpIHtcbiAgICAgIHZhciBfZXh0ZW5kczI7XG5cbiAgICAgIGlmIChpc0FzcGVjdFJhdGlvTG9ja2VkID09PSB2b2lkIDApIHtcbiAgICAgICAgaXNBc3BlY3RSYXRpb0xvY2tlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHJhbnNmb3JtVHlwZSA9IF90aGlzLnRyYW5zZm9ybVR5cGU7XG4gICAgICB2YXIgX3RoaXMkc25hcHNob3QgPSBfdGhpcy5zbmFwc2hvdCxcbiAgICAgICAgICBpbml0aWFsU2hhcGVCb3VuZHMgPSBfdGhpcyRzbmFwc2hvdC5pbml0aWFsU2hhcGVCb3VuZHMsXG4gICAgICAgICAgaW5pdGlhbFNoYXBlID0gX3RoaXMkc25hcHNob3QuaW5pdGlhbFNoYXBlLFxuICAgICAgICAgIGlkID0gX3RoaXMkc25hcHNob3QuaWQ7XG4gICAgICB2YXIgc2hhcGUgPSBkYXRhLnBhZ2Uuc2hhcGVzW2lkXTtcbiAgICAgIHZhciB1dGlscyA9IFRMRFIuZ2V0U2hhcGVVdGlscyhzaGFwZSk7XG4gICAgICB2YXIgbmV3Qm91bmRzID0gY29yZS5VdGlscy5nZXRUcmFuc2Zvcm1lZEJvdW5kaW5nQm94KGluaXRpYWxTaGFwZUJvdW5kcywgdHJhbnNmb3JtVHlwZSwgY29yZS5WZWMuc3ViKHBvaW50LCBfdGhpcy5vcmlnaW4pLCBzaGFwZS5yb3RhdGlvbiwgaXNBc3BlY3RSYXRpb0xvY2tlZCB8fCBzaGFwZS5pc0FzcGVjdFJhdGlvTG9ja2VkIHx8IHV0aWxzLmlzQXNwZWN0UmF0aW9Mb2NrZWQpO1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBkYXRhLCB7XG4gICAgICAgIHBhZ2U6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2UsIHtcbiAgICAgICAgICBzaGFwZXM6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2Uuc2hhcGVzLCAoX2V4dGVuZHMyID0ge30sIF9leHRlbmRzMltzaGFwZS5pZF0gPSBfZXh0ZW5kcyh7fSwgaW5pdGlhbFNoYXBlLCBUTERSLmdldFNoYXBlVXRpbHMoc2hhcGUpLnRyYW5zZm9ybVNpbmdsZShzaGFwZSwgbmV3Qm91bmRzLCB7XG4gICAgICAgICAgICBpbml0aWFsU2hhcGU6IGluaXRpYWxTaGFwZSxcbiAgICAgICAgICAgIHR5cGU6IF90aGlzLnRyYW5zZm9ybVR5cGUsXG4gICAgICAgICAgICBzY2FsZVg6IG5ld0JvdW5kcy5zY2FsZVgsXG4gICAgICAgICAgICBzY2FsZVk6IG5ld0JvdW5kcy5zY2FsZVksXG4gICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW46IFswLjUsIDAuNV1cbiAgICAgICAgICB9KSksIF9leHRlbmRzMikpXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5jYW5jZWwgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdmFyIF9leHRlbmRzMztcblxuICAgICAgdmFyIF90aGlzJHNuYXBzaG90MiA9IF90aGlzLnNuYXBzaG90LFxuICAgICAgICAgIGlkID0gX3RoaXMkc25hcHNob3QyLmlkLFxuICAgICAgICAgIGluaXRpYWxTaGFwZSA9IF90aGlzJHNuYXBzaG90Mi5pbml0aWFsU2hhcGU7XG4gICAgICBkYXRhLnBhZ2Uuc2hhcGVzW2lkXSA9IGluaXRpYWxTaGFwZTtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgZGF0YSwge1xuICAgICAgICBwYWdlOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlLCB7XG4gICAgICAgICAgc2hhcGVzOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlLnNoYXBlcywgKF9leHRlbmRzMyA9IHt9LCBfZXh0ZW5kczNbaWRdID0gaW5pdGlhbFNoYXBlLCBfZXh0ZW5kczMpKVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMub3JpZ2luID0gX3BvaW50O1xuICAgIHRoaXMudHJhbnNmb3JtVHlwZSA9IF90cmFuc2Zvcm1UeXBlO1xuICAgIHRoaXMuc25hcHNob3QgPSBnZXRUcmFuc2Zvcm1TaW5nbGVTbmFwc2hvdChfZGF0YSwgX3RyYW5zZm9ybVR5cGUpO1xuICAgIHRoaXMuY29tbWFuZElkID0gY29tbWFuZElkO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFRyYW5zZm9ybVNpbmdsZVNlc3Npb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5jb21wbGV0ZSA9IGZ1bmN0aW9uIGNvbXBsZXRlKGRhdGEpIHtcbiAgICB2YXIgX3NoYXBlcywgX3NoYXBlczI7XG5cbiAgICBpZiAoIXRoaXMuc25hcHNob3QuaGFzVW5sb2NrZWRTaGFwZSkgcmV0dXJuIGRhdGE7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0aGlzLmNvbW1hbmRJZCxcbiAgICAgIGJlZm9yZToge1xuICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgc2hhcGVzOiAoX3NoYXBlcyA9IHt9LCBfc2hhcGVzW3RoaXMuc25hcHNob3QuaWRdID0gdGhpcy5zbmFwc2hvdC5pbml0aWFsU2hhcGUsIF9zaGFwZXMpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhZnRlcjoge1xuICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgc2hhcGVzOiAoX3NoYXBlczIgPSB7fSwgX3NoYXBlczJbdGhpcy5zbmFwc2hvdC5pZF0gPSBkYXRhLnBhZ2Uuc2hhcGVzW3RoaXMuc25hcHNob3QuaWRdLCBfc2hhcGVzMilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIFRyYW5zZm9ybVNpbmdsZVNlc3Npb247XG59KCk7XG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1TaW5nbGVTbmFwc2hvdChkYXRhLCB0cmFuc2Zvcm1UeXBlKSB7XG4gIHZhciBzaGFwZSA9IGRhdGEucGFnZS5zaGFwZXNbZGF0YS5wYWdlU3RhdGUuc2VsZWN0ZWRJZHNbMF1dO1xuXG4gIGlmICghc2hhcGUpIHtcbiAgICB0aHJvdyBFcnJvcignWW91IG11c3QgaGF2ZSBvbmUgc2hhcGUgc2VsZWN0ZWQuJyk7XG4gIH1cblxuICB2YXIgYm91bmRzID0gVExEUi5nZXRCb3VuZHMoc2hhcGUpO1xuICByZXR1cm4ge1xuICAgIGlkOiBzaGFwZS5pZCxcbiAgICBoYXNVbmxvY2tlZFNoYXBlOiAhc2hhcGUuaXNMb2NrZWQsXG4gICAgdHlwZTogdHJhbnNmb3JtVHlwZSxcbiAgICBpbml0aWFsU2hhcGU6IGNvcmUuVXRpbHMuZGVlcENsb25lKHNoYXBlKSxcbiAgICBpbml0aWFsU2hhcGVCb3VuZHM6IGJvdW5kc1xuICB9O1xufVxuXG52YXIgVHJhbnNmb3JtU2Vzc2lvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRyYW5zZm9ybVNlc3Npb24oX2RhdGEsIF9wb2ludCwgX3RyYW5zZm9ybVR5cGUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKF90cmFuc2Zvcm1UeXBlID09PSB2b2lkIDApIHtcbiAgICAgIF90cmFuc2Zvcm1UeXBlID0gY29yZS5UTEJvdW5kc0Nvcm5lci5Cb3R0b21SaWdodDtcbiAgICB9XG5cbiAgICB0aGlzLmlkID0gJ3RyYW5zZm9ybSc7XG4gICAgdGhpcy5zY2FsZVggPSAxO1xuICAgIHRoaXMuc2NhbGVZID0gMTtcbiAgICB0aGlzLnRyYW5zZm9ybVR5cGUgPSB2b2lkIDA7XG4gICAgdGhpcy5vcmlnaW4gPSB2b2lkIDA7XG4gICAgdGhpcy5zbmFwc2hvdCA9IHZvaWQgMDtcblxuICAgIHRoaXMuc3RhcnQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuICAgIHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIHBvaW50LCBpc0FzcGVjdFJhdGlvTG9ja2VkLCBfYWx0S2V5KSB7XG4gICAgICBpZiAoaXNBc3BlY3RSYXRpb0xvY2tlZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlzQXNwZWN0UmF0aW9Mb2NrZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRyYW5zZm9ybVR5cGUgPSBfdGhpcy50cmFuc2Zvcm1UeXBlLFxuICAgICAgICAgIF90aGlzJHNuYXBzaG90ID0gX3RoaXMuc25hcHNob3QsXG4gICAgICAgICAgc2hhcGVCb3VuZHMgPSBfdGhpcyRzbmFwc2hvdC5zaGFwZUJvdW5kcyxcbiAgICAgICAgICBpbml0aWFsQm91bmRzID0gX3RoaXMkc25hcHNob3QuaW5pdGlhbEJvdW5kcyxcbiAgICAgICAgICBpc0FsbEFzcGVjdFJhdGlvTG9ja2VkID0gX3RoaXMkc25hcHNob3QuaXNBbGxBc3BlY3RSYXRpb0xvY2tlZDtcblxuICAgICAgdmFyIG5leHQgPSBfZXh0ZW5kcyh7fSwgZGF0YSwge1xuICAgICAgICBwYWdlOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlKVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBzaGFwZXMgPSBuZXh0LnBhZ2Uuc2hhcGVzO1xuICAgICAgdmFyIG5ld0JvdW5kaW5nQm94ID0gY29yZS5VdGlscy5nZXRUcmFuc2Zvcm1lZEJvdW5kaW5nQm94KGluaXRpYWxCb3VuZHMsIHRyYW5zZm9ybVR5cGUsIGNvcmUuVmVjLnZlYyhfdGhpcy5vcmlnaW4sIHBvaW50KSwgZGF0YS5wYWdlU3RhdGUuYm91bmRzUm90YXRpb24sIGlzQXNwZWN0UmF0aW9Mb2NrZWQgfHwgaXNBbGxBc3BlY3RSYXRpb0xvY2tlZCk7IC8vIE5vdyB3b3JrIGJhY2t3YXJkIHRvIGNhbGN1bGF0ZSBhIG5ldyBib3VuZGluZyBib3ggZm9yIGVhY2ggb2YgdGhlIHNoYXBlcy5cblxuICAgICAgX3RoaXMuc2NhbGVYID0gbmV3Qm91bmRpbmdCb3guc2NhbGVYO1xuICAgICAgX3RoaXMuc2NhbGVZID0gbmV3Qm91bmRpbmdCb3guc2NhbGVZO1xuICAgICAgbmV4dC5wYWdlLnNoYXBlcyA9IF9leHRlbmRzKHt9LCBuZXh0LnBhZ2Uuc2hhcGVzLCBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoc2hhcGVCb3VuZHMpLm1hcChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgaWQgPSBfcmVmWzBdLFxuICAgICAgICAgICAgX3JlZiQgPSBfcmVmWzFdLFxuICAgICAgICAgICAgaW5pdGlhbFNoYXBlID0gX3JlZiQuaW5pdGlhbFNoYXBlLFxuICAgICAgICAgICAgaW5pdGlhbFNoYXBlQm91bmRzID0gX3JlZiQuaW5pdGlhbFNoYXBlQm91bmRzLFxuICAgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luID0gX3JlZiQudHJhbnNmb3JtT3JpZ2luO1xuICAgICAgICB2YXIgbmV3U2hhcGVCb3VuZHMgPSBjb3JlLlV0aWxzLmdldFJlbGF0aXZlVHJhbnNmb3JtZWRCb3VuZGluZ0JveChuZXdCb3VuZGluZ0JveCwgaW5pdGlhbEJvdW5kcywgaW5pdGlhbFNoYXBlQm91bmRzLCBfdGhpcy5zY2FsZVggPCAwLCBfdGhpcy5zY2FsZVkgPCAwKTtcbiAgICAgICAgdmFyIHNoYXBlID0gc2hhcGVzW2lkXTtcbiAgICAgICAgcmV0dXJuIFtpZCwgX2V4dGVuZHMoe30sIGluaXRpYWxTaGFwZSwgVExEUi50cmFuc2Zvcm0obmV4dCwgc2hhcGUsIG5ld1NoYXBlQm91bmRzLCB7XG4gICAgICAgICAgdHlwZTogX3RoaXMudHJhbnNmb3JtVHlwZSxcbiAgICAgICAgICBpbml0aWFsU2hhcGU6IGluaXRpYWxTaGFwZSxcbiAgICAgICAgICBzY2FsZVg6IF90aGlzLnNjYWxlWCxcbiAgICAgICAgICBzY2FsZVk6IF90aGlzLnNjYWxlWSxcbiAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW46IHRyYW5zZm9ybU9yaWdpblxuICAgICAgICB9KSldO1xuICAgICAgfSkpKTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG5cbiAgICB0aGlzLmNhbmNlbCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB2YXIgc2hhcGVCb3VuZHMgPSBfdGhpcy5zbmFwc2hvdC5zaGFwZUJvdW5kcztcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgZGF0YSwge1xuICAgICAgICBwYWdlOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlLCB7XG4gICAgICAgICAgc2hhcGVzOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlLnNoYXBlcywgT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHNoYXBlQm91bmRzKS5tYXAoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBfcmVmMlswXSxcbiAgICAgICAgICAgICAgICBpbml0aWFsU2hhcGUgPSBfcmVmMlsxXS5pbml0aWFsU2hhcGU7XG4gICAgICAgICAgICByZXR1cm4gW2lkLCBpbml0aWFsU2hhcGVdO1xuICAgICAgICAgIH0pKSlcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLm9yaWdpbiA9IF9wb2ludDtcbiAgICB0aGlzLnRyYW5zZm9ybVR5cGUgPSBfdHJhbnNmb3JtVHlwZTtcbiAgICB0aGlzLnNuYXBzaG90ID0gZ2V0VHJhbnNmb3JtU25hcHNob3QoX2RhdGEsIF90cmFuc2Zvcm1UeXBlKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBUcmFuc2Zvcm1TZXNzaW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uY29tcGxldGUgPSBmdW5jdGlvbiBjb21wbGV0ZShkYXRhKSB7XG4gICAgdmFyIF90aGlzJHNuYXBzaG90MiA9IHRoaXMuc25hcHNob3QsXG4gICAgICAgIGhhc1VubG9ja2VkU2hhcGVzID0gX3RoaXMkc25hcHNob3QyLmhhc1VubG9ja2VkU2hhcGVzLFxuICAgICAgICBzaGFwZUJvdW5kcyA9IF90aGlzJHNuYXBzaG90Mi5zaGFwZUJvdW5kcztcbiAgICBpZiAoIWhhc1VubG9ja2VkU2hhcGVzKSByZXR1cm4gZGF0YTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6ICd0cmFuc2Zvcm0nLFxuICAgICAgYmVmb3JlOiB7XG4gICAgICAgIHBhZ2U6IHtcbiAgICAgICAgICBzaGFwZXM6IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhzaGFwZUJvdW5kcykubWFwKGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgICAgICAgdmFyIGlkID0gX3JlZjNbMF0sXG4gICAgICAgICAgICAgICAgaW5pdGlhbFNoYXBlID0gX3JlZjNbMV0uaW5pdGlhbFNoYXBlO1xuICAgICAgICAgICAgcmV0dXJuIFtpZCwgaW5pdGlhbFNoYXBlXTtcbiAgICAgICAgICB9KSlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFmdGVyOiB7XG4gICAgICAgIHBhZ2U6IHtcbiAgICAgICAgICBzaGFwZXM6IE9iamVjdC5mcm9tRW50cmllcyh0aGlzLnNuYXBzaG90LmluaXRpYWxTaGFwZXMubWFwKGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtzaGFwZS5pZCwgZGF0YS5wYWdlLnNoYXBlc1tzaGFwZS5pZF1dO1xuICAgICAgICAgIH0pKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4gVHJhbnNmb3JtU2Vzc2lvbjtcbn0oKTtcbmZ1bmN0aW9uIGdldFRyYW5zZm9ybVNuYXBzaG90KGRhdGEsIHRyYW5zZm9ybVR5cGUpIHtcbiAgdmFyIGluaXRpYWxTaGFwZXMgPSBUTERSLmdldFNlbGVjdGVkQnJhbmNoU25hcHNob3QoZGF0YSk7XG4gIHZhciBoYXNVbmxvY2tlZFNoYXBlcyA9IGluaXRpYWxTaGFwZXMubGVuZ3RoID4gMDtcbiAgdmFyIGlzQWxsQXNwZWN0UmF0aW9Mb2NrZWQgPSBpbml0aWFsU2hhcGVzLmV2ZXJ5KGZ1bmN0aW9uIChzaGFwZSkge1xuICAgIHJldHVybiBzaGFwZS5pc0FzcGVjdFJhdGlvTG9ja2VkIHx8IFRMRFIuZ2V0U2hhcGVVdGlscyhzaGFwZSkuaXNBc3BlY3RSYXRpb0xvY2tlZDtcbiAgfSk7XG4gIHZhciBzaGFwZXNCb3VuZHMgPSBPYmplY3QuZnJvbUVudHJpZXMoaW5pdGlhbFNoYXBlcy5tYXAoZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgcmV0dXJuIFtzaGFwZS5pZCwgVExEUi5nZXRCb3VuZHMoc2hhcGUpXTtcbiAgfSkpO1xuICB2YXIgYm91bmRzQXJyID0gT2JqZWN0LnZhbHVlcyhzaGFwZXNCb3VuZHMpO1xuICB2YXIgY29tbW9uQm91bmRzID0gY29yZS5VdGlscy5nZXRDb21tb25Cb3VuZHMoYm91bmRzQXJyKTtcbiAgdmFyIGluaXRpYWxJbm5lckJvdW5kcyA9IGNvcmUuVXRpbHMuZ2V0Qm91bmRzRnJvbVBvaW50cyhib3VuZHNBcnIubWFwKGNvcmUuVXRpbHMuZ2V0Qm91bmRzQ2VudGVyKSk7IC8vIFJldHVybiBhIG1hcHBpbmcgb2Ygc2hhcGVzIHRvIGJvdW5kcyB0b2dldGhlciB3aXRoIHRoZSByZWxhdGl2ZVxuICAvLyBwb3NpdGlvbnMgb2YgdGhlIHNoYXBlJ3MgYm91bmRzIHdpdGhpbiB0aGUgY29tbW9uIGJvdW5kcyBzaGFwZS5cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IHRyYW5zZm9ybVR5cGUsXG4gICAgaGFzVW5sb2NrZWRTaGFwZXM6IGhhc1VubG9ja2VkU2hhcGVzLFxuICAgIGlzQWxsQXNwZWN0UmF0aW9Mb2NrZWQ6IGlzQWxsQXNwZWN0UmF0aW9Mb2NrZWQsXG4gICAgaW5pdGlhbFNoYXBlczogaW5pdGlhbFNoYXBlcyxcbiAgICBpbml0aWFsQm91bmRzOiBjb21tb25Cb3VuZHMsXG4gICAgc2hhcGVCb3VuZHM6IE9iamVjdC5mcm9tRW50cmllcyhpbml0aWFsU2hhcGVzLm1hcChmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgIHZhciBpbml0aWFsU2hhcGVCb3VuZHMgPSBzaGFwZXNCb3VuZHNbc2hhcGUuaWRdO1xuICAgICAgdmFyIGljID0gY29yZS5VdGlscy5nZXRCb3VuZHNDZW50ZXIoaW5pdGlhbFNoYXBlQm91bmRzKTtcbiAgICAgIHZhciBpeCA9IChpY1swXSAtIGluaXRpYWxJbm5lckJvdW5kcy5taW5YKSAvIGluaXRpYWxJbm5lckJvdW5kcy53aWR0aDtcbiAgICAgIHZhciBpeSA9IChpY1sxXSAtIGluaXRpYWxJbm5lckJvdW5kcy5taW5ZKSAvIGluaXRpYWxJbm5lckJvdW5kcy5oZWlnaHQ7XG4gICAgICByZXR1cm4gW3NoYXBlLmlkLCB7XG4gICAgICAgIGluaXRpYWxTaGFwZTogc2hhcGUsXG4gICAgICAgIGluaXRpYWxTaGFwZUJvdW5kczogaW5pdGlhbFNoYXBlQm91bmRzLFxuICAgICAgICB0cmFuc2Zvcm1PcmlnaW46IFtpeCwgaXldXG4gICAgICB9XTtcbiAgICB9KSlcbiAgfTtcbn1cblxudmFyIERyYXdTZXNzaW9uID0gZnVuY3Rpb24gRHJhd1Nlc3Npb24oX2RhdGEsIGlkLCBfcG9pbnQpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLmlkID0gJ2RyYXcnO1xuICB0aGlzLm9yaWdpbiA9IHZvaWQgMDtcbiAgdGhpcy5wcmV2aW91cyA9IHZvaWQgMDtcbiAgdGhpcy5sYXN0ID0gdm9pZCAwO1xuICB0aGlzLnBvaW50cyA9IHZvaWQgMDtcbiAgdGhpcy5zbmFwc2hvdCA9IHZvaWQgMDtcbiAgdGhpcy5pc0xvY2tlZCA9IHZvaWQgMDtcbiAgdGhpcy5sb2NrZWREaXJlY3Rpb24gPSB2b2lkIDA7XG5cbiAgdGhpcy5zdGFydCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgcG9pbnQsIHByZXNzdXJlLCBpc0xvY2tlZCkge1xuICAgIHZhciBfZXh0ZW5kczI7XG5cbiAgICBpZiAoaXNMb2NrZWQgPT09IHZvaWQgMCkge1xuICAgICAgaXNMb2NrZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgc25hcHNob3QgPSBfdGhpcy5zbmFwc2hvdDsgLy8gRHJhd2luZyB3aGlsZSBob2xkaW5nIHNoaWZ0IHdpbGwgXCJsb2NrXCIgdGhlIHBlbiB0byBlaXRoZXIgdGhlXG4gICAgLy8geCBvciB5IGF4aXMsIGRlcGVuZGluZyBvbiB3aGljaCBkaXJlY3Rpb24gaGFzIHRoZSBncmVhdGVyXG4gICAgLy8gZGVsdGEuIFByZXNzaW5nIHNoaWZ0IHdpbGwgYWxzbyBhZGQgbW9yZSBwb2ludHMgdG8gXCJyZXR1cm5cIlxuICAgIC8vIHRoZSBwZW4gdG8gdGhlIGF4aXMuXG5cbiAgICBpZiAoaXNMb2NrZWQpIHtcbiAgICAgIGlmICghX3RoaXMuaXNMb2NrZWQgJiYgX3RoaXMucG9pbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFyIGJvdW5kcyA9IGNvcmUuVXRpbHMuZ2V0Qm91bmRzRnJvbVBvaW50cyhfdGhpcy5wb2ludHMpO1xuXG4gICAgICAgIGlmIChib3VuZHMud2lkdGggPiA4IHx8IGJvdW5kcy5oZWlnaHQgPiA4KSB7XG4gICAgICAgICAgX3RoaXMuaXNMb2NrZWQgPSB0cnVlO1xuICAgICAgICAgIHZhciByZXR1cm5pbmcgPSBbXS5jb25jYXQoX3RoaXMucHJldmlvdXMpO1xuICAgICAgICAgIHZhciBpc1ZlcnRpY2FsID0gYm91bmRzLmhlaWdodCA+IDg7XG5cbiAgICAgICAgICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgICAgICAgICAgX3RoaXMubG9ja2VkRGlyZWN0aW9uID0gJ3ZlcnRpY2FsJztcbiAgICAgICAgICAgIHJldHVybmluZ1swXSA9IF90aGlzLm9yaWdpblswXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMubG9ja2VkRGlyZWN0aW9uID0gJ2hvcml6b250YWwnO1xuICAgICAgICAgICAgcmV0dXJuaW5nWzFdID0gX3RoaXMub3JpZ2luWzFdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzLnByZXZpb3VzID0gcmV0dXJuaW5nO1xuXG4gICAgICAgICAgX3RoaXMucG9pbnRzLnB1c2goY29yZS5WZWMuc3ViKHJldHVybmluZywgX3RoaXMub3JpZ2luKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKF90aGlzLmlzTG9ja2VkKSB7XG4gICAgICBfdGhpcy5pc0xvY2tlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChfdGhpcy5pc0xvY2tlZCkge1xuICAgICAgaWYgKF90aGlzLmxvY2tlZERpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICBwb2ludFswXSA9IF90aGlzLm9yaWdpblswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvaW50WzFdID0gX3RoaXMub3JpZ2luWzFdO1xuICAgICAgfVxuICAgIH0gLy8gTG93IHBhc3MgdGhlIGN1cnJlbnQgaW5wdXQgcG9pbnQgYWdhaW5zdCB0aGUgcHJldmlvdXMgb25lXG5cblxuICAgIHZhciBuZXh0UHJldiA9IGNvcmUuVmVjLm1lZChfdGhpcy5wcmV2aW91cywgcG9pbnQpO1xuICAgIF90aGlzLnByZXZpb3VzID0gbmV4dFByZXY7IC8vIERvbid0IGFkZCBkdXBsaWNhdGUgcG9pbnRzLiBJdCdzIGltcG9ydGFudCB0byB0ZXN0IGFnYWluc3QgdGhlXG4gICAgLy8gYWRqdXN0ZWQgKGxvdy1wYXNzZWQpIHBvaW50IHJhdGhlciB0aGFuIHRoZSBpbnB1dCBwb2ludC5cblxuICAgIHZhciBuZXdQb2ludCA9IGNvcmUuVmVjLnJvdW5kKFtdLmNvbmNhdChjb3JlLlZlYy5zdWIoX3RoaXMucHJldmlvdXMsIF90aGlzLm9yaWdpbiksIFtwcmVzc3VyZV0pKTtcbiAgICBpZiAoY29yZS5WZWMuaXNFcXVhbChfdGhpcy5sYXN0LCBuZXdQb2ludCkpIHJldHVybiBkYXRhO1xuICAgIF90aGlzLmxhc3QgPSBuZXdQb2ludDtcblxuICAgIF90aGlzLnBvaW50cy5wdXNoKG5ld1BvaW50KTsgLy8gV2UgZHJhdyBhIGRvdCB3aGVuIHRoZSBudW1iZXIgb2YgcG9pbnRzIGlzIDEgb3IgMiwgc28gdGhpcyBndWFyZFxuICAgIC8vIHByZXZlbnRzIGEgXCJmbGFzaFwiIG9mIGEgZG90IHdoZW4gYSB1c2VyIGJlZ2lucyBkcmF3aW5nIGEgbGluZS5cblxuXG4gICAgaWYgKF90aGlzLnBvaW50cy5sZW5ndGggPD0gMikgcmV0dXJuIGRhdGE7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBkYXRhLCB7XG4gICAgICBwYWdlOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlLCB7XG4gICAgICAgIHNoYXBlczogX2V4dGVuZHMoe30sIGRhdGEucGFnZS5zaGFwZXMsIChfZXh0ZW5kczIgPSB7fSwgX2V4dGVuZHMyW3NuYXBzaG90LmlkXSA9IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2Uuc2hhcGVzW3NuYXBzaG90LmlkXSwge1xuICAgICAgICAgIHBvaW50czogW10uY29uY2F0KF90aGlzLnBvaW50cylcbiAgICAgICAgfSksIF9leHRlbmRzMikpXG4gICAgICB9KSxcbiAgICAgIHBhZ2VTdGF0ZTogX2V4dGVuZHMoe30sIGRhdGEucGFnZVN0YXRlLCB7XG4gICAgICAgIHNlbGVjdGVkSWRzOiBbc25hcHNob3QuaWRdXG4gICAgICB9KVxuICAgIH0pO1xuICB9O1xuXG4gIHRoaXMuY2FuY2VsID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgX2V4dGVuZHMzO1xuXG4gICAgdmFyIHNuYXBzaG90ID0gX3RoaXMuc25hcHNob3Q7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBkYXRhLCB7XG4gICAgICBwYWdlOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlLCB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgc2hhcGVzOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlLnNoYXBlcywgKF9leHRlbmRzMyA9IHt9LCBfZXh0ZW5kczNbc25hcHNob3QuaWRdID0gdW5kZWZpbmVkLCBfZXh0ZW5kczMpKVxuICAgICAgfSksXG4gICAgICBwYWdlU3RhdGU6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2VTdGF0ZSwge1xuICAgICAgICBzZWxlY3RlZElkczogW11cbiAgICAgIH0pXG4gICAgfSk7XG4gIH07XG5cbiAgdGhpcy5jb21wbGV0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIF9zaGFwZXMsIF9zaGFwZXMyO1xuXG4gICAgdmFyIHNuYXBzaG90ID0gX3RoaXMuc25hcHNob3Q7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiAnY3JlYXRlX2RyYXcnLFxuICAgICAgYmVmb3JlOiB7XG4gICAgICAgIHBhZ2U6IHtcbiAgICAgICAgICBzaGFwZXM6IChfc2hhcGVzID0ge30sIF9zaGFwZXNbc25hcHNob3QuaWRdID0gdW5kZWZpbmVkLCBfc2hhcGVzKVxuICAgICAgICB9LFxuICAgICAgICBwYWdlU3RhdGU6IHtcbiAgICAgICAgICBzZWxlY3RlZElkczogW11cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFmdGVyOiB7XG4gICAgICAgIHBhZ2U6IHtcbiAgICAgICAgICBzaGFwZXM6IChfc2hhcGVzMiA9IHt9LCBfc2hhcGVzMltzbmFwc2hvdC5pZF0gPSBkYXRhLnBhZ2Uuc2hhcGVzW3NuYXBzaG90LmlkXSwgX3NoYXBlczIpXG4gICAgICAgIH0sXG4gICAgICAgIHBhZ2VTdGF0ZToge1xuICAgICAgICAgIHNlbGVjdGVkSWRzOiBbXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICB0aGlzLm9yaWdpbiA9IF9wb2ludDtcbiAgdGhpcy5wcmV2aW91cyA9IF9wb2ludDtcbiAgdGhpcy5sYXN0ID0gX3BvaW50O1xuICB0aGlzLnNuYXBzaG90ID0gZ2V0RHJhd1NuYXBzaG90KF9kYXRhLCBpZCk7IC8vIEFkZCBhIGZpcnN0IHBvaW50IGJ1dCBkb24ndCB1cGRhdGUgdGhlIHNoYXBlIHlldC4gV2UnbGwgdXBkYXRlXG4gIC8vIHdoZW4gdGhlIGRyYXcgc2Vzc2lvbiBlbmRzOyBpZiB0aGUgdXNlciBoYXNuJ3QgYWRkZWQgYWRkaXRpb25hbFxuICAvLyBwb2ludHMsIHRoaXMgc2luZ2xlIHBvaW50IHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXMgYSBcImRvdFwiIHNoYXBlLlxuXG4gIHRoaXMucG9pbnRzID0gW1swLCAwLCAwLjVdXTtcbn07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG5cbmZ1bmN0aW9uIGdldERyYXdTbmFwc2hvdChkYXRhLCBzaGFwZUlkKSB7XG4gIHZhciBwYWdlID0gZGF0YS5wYWdlO1xuXG4gIHZhciBfVXRpbHMkZGVlcENsb25lID0gY29yZS5VdGlscy5kZWVwQ2xvbmUocGFnZS5zaGFwZXNbc2hhcGVJZF0pLFxuICAgICAgcG9pbnRzID0gX1V0aWxzJGRlZXBDbG9uZS5wb2ludHMsXG4gICAgICBwb2ludCA9IF9VdGlscyRkZWVwQ2xvbmUucG9pbnQ7XG5cbiAgcmV0dXJuIHtcbiAgICBpZDogc2hhcGVJZCxcbiAgICBwb2ludDogcG9pbnQsXG4gICAgcG9pbnRzOiBwb2ludHNcbiAgfTtcbn1cblxudmFyIFBJMiQxID0gTWF0aC5QSSAqIDI7XG52YXIgUm90YXRlU2Vzc2lvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJvdGF0ZVNlc3Npb24oX2RhdGEsIF9wb2ludCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLmlkID0gJ3JvdGF0ZSc7XG4gICAgdGhpcy5kZWx0YSA9IFswLCAwXTtcbiAgICB0aGlzLm9yaWdpbiA9IHZvaWQgMDtcbiAgICB0aGlzLnNuYXBzaG90ID0gdm9pZCAwO1xuICAgIHRoaXMucHJldiA9IDA7XG5cbiAgICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICB0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBwb2ludCwgaXNMb2NrZWQpIHtcbiAgICAgIGlmIChpc0xvY2tlZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlzTG9ja2VkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBfdGhpcyRzbmFwc2hvdCA9IF90aGlzLnNuYXBzaG90LFxuICAgICAgICAgIGNvbW1vbkJvdW5kc0NlbnRlciA9IF90aGlzJHNuYXBzaG90LmNvbW1vbkJvdW5kc0NlbnRlcixcbiAgICAgICAgICBpbml0aWFsU2hhcGVzID0gX3RoaXMkc25hcHNob3QuaW5pdGlhbFNoYXBlcztcblxuICAgICAgdmFyIG5leHQgPSBfZXh0ZW5kcyh7fSwgZGF0YSwge1xuICAgICAgICBwYWdlOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlKSxcbiAgICAgICAgcGFnZVN0YXRlOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlU3RhdGUpXG4gICAgICB9KTtcblxuICAgICAgdmFyIHBhZ2UgPSBuZXh0LnBhZ2UsXG4gICAgICAgICAgcGFnZVN0YXRlID0gbmV4dC5wYWdlU3RhdGU7XG4gICAgICB2YXIgYTEgPSBjb3JlLlZlYy5hbmdsZShjb21tb25Cb3VuZHNDZW50ZXIsIF90aGlzLm9yaWdpbik7XG4gICAgICB2YXIgYTIgPSBjb3JlLlZlYy5hbmdsZShjb21tb25Cb3VuZHNDZW50ZXIsIHBvaW50KTtcbiAgICAgIHZhciByb3QgPSBhMiAtIGExO1xuICAgICAgX3RoaXMucHJldiA9IHJvdDtcblxuICAgICAgaWYgKGlzTG9ja2VkKSB7XG4gICAgICAgIHJvdCA9IGNvcmUuVXRpbHMuY2xhbXBUb1JvdGF0aW9uVG9TZWdtZW50cyhyb3QsIDI0KTtcbiAgICAgIH1cblxuICAgICAgcGFnZVN0YXRlLmJvdW5kc1JvdGF0aW9uID0gKFBJMiQxICsgKF90aGlzLnNuYXBzaG90LmJvdW5kc1JvdGF0aW9uICsgcm90KSkgJSBQSTIkMTtcbiAgICAgIG5leHQucGFnZS5zaGFwZXMgPSBfZXh0ZW5kcyh7fSwgbmV4dC5wYWdlLnNoYXBlcywgT2JqZWN0LmZyb21FbnRyaWVzKGluaXRpYWxTaGFwZXMubWFwKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBpZCA9IF9yZWYuaWQsXG4gICAgICAgICAgICBjZW50ZXIgPSBfcmVmLmNlbnRlcixcbiAgICAgICAgICAgIG9mZnNldCA9IF9yZWYub2Zmc2V0LFxuICAgICAgICAgICAgX3JlZiRzaGFwZSRyb3RhdGlvbiA9IF9yZWYuc2hhcGUucm90YXRpb24sXG4gICAgICAgICAgICByb3RhdGlvbiA9IF9yZWYkc2hhcGUkcm90YXRpb24gPT09IHZvaWQgMCA/IDAgOiBfcmVmJHNoYXBlJHJvdGF0aW9uO1xuICAgICAgICB2YXIgc2hhcGUgPSBwYWdlLnNoYXBlc1tpZF07XG4gICAgICAgIHZhciBuZXh0Um90YXRpb24gPSBpc0xvY2tlZCA/IGNvcmUuVXRpbHMuY2xhbXBUb1JvdGF0aW9uVG9TZWdtZW50cyhyb3RhdGlvbiArIHJvdCwgMjQpIDogcm90YXRpb24gKyByb3Q7XG4gICAgICAgIHZhciBuZXh0UG9pbnQgPSBjb3JlLlZlYy5zdWIoY29yZS5WZWMucm90V2l0aChjZW50ZXIsIGNvbW1vbkJvdW5kc0NlbnRlciwgcm90KSwgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIFtpZCwgX2V4dGVuZHMoe30sIG5leHQucGFnZS5zaGFwZXNbaWRdLCBUTERSLm11dGF0ZShkYXRhLCBzaGFwZSwge1xuICAgICAgICAgIHBvaW50OiBuZXh0UG9pbnQsXG4gICAgICAgICAgcm90YXRpb246IChQSTIkMSArIG5leHRSb3RhdGlvbikgJSBQSTIkMVxuICAgICAgICB9KSldO1xuICAgICAgfSkpKTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG5cbiAgICB0aGlzLmNhbmNlbCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB2YXIgaW5pdGlhbFNoYXBlcyA9IF90aGlzLnNuYXBzaG90LmluaXRpYWxTaGFwZXM7XG5cbiAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoaW5pdGlhbFNoYXBlcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zdGVwLnZhbHVlLFxuICAgICAgICAgICAgaWQgPSBfc3RlcCR2YWx1ZS5pZCxcbiAgICAgICAgICAgIHNoYXBlID0gX3N0ZXAkdmFsdWUuc2hhcGU7XG4gICAgICAgIGRhdGEucGFnZS5zaGFwZXNbaWRdID0gX2V4dGVuZHMoe30sIHNoYXBlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBkYXRhLCB7XG4gICAgICAgIHBhZ2U6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2UsIHtcbiAgICAgICAgICBzaGFwZXM6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2Uuc2hhcGVzLCBPYmplY3QuZnJvbUVudHJpZXMoaW5pdGlhbFNoYXBlcy5tYXAoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBfcmVmMi5pZCxcbiAgICAgICAgICAgICAgICBzaGFwZSA9IF9yZWYyLnNoYXBlO1xuICAgICAgICAgICAgcmV0dXJuIFtpZCwgc2hhcGVdO1xuICAgICAgICAgIH0pKSlcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLm9yaWdpbiA9IF9wb2ludDtcbiAgICB0aGlzLnNuYXBzaG90ID0gZ2V0Um90YXRlU25hcHNob3QoX2RhdGEpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFJvdGF0ZVNlc3Npb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5jb21wbGV0ZSA9IGZ1bmN0aW9uIGNvbXBsZXRlKGRhdGEpIHtcbiAgICB2YXIgX3RoaXMkc25hcHNob3QyID0gdGhpcy5zbmFwc2hvdCxcbiAgICAgICAgaGFzVW5sb2NrZWRTaGFwZXMgPSBfdGhpcyRzbmFwc2hvdDIuaGFzVW5sb2NrZWRTaGFwZXMsXG4gICAgICAgIGluaXRpYWxTaGFwZXMgPSBfdGhpcyRzbmFwc2hvdDIuaW5pdGlhbFNoYXBlcztcbiAgICBpZiAoIWhhc1VubG9ja2VkU2hhcGVzKSByZXR1cm4gZGF0YTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6ICdyb3RhdGUnLFxuICAgICAgYmVmb3JlOiB7XG4gICAgICAgIHBhZ2U6IHtcbiAgICAgICAgICBzaGFwZXM6IE9iamVjdC5mcm9tRW50cmllcyhpbml0aWFsU2hhcGVzLm1hcChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgICAgIHZhciBfcmVmMyRzaGFwZSA9IF9yZWYzLnNoYXBlLFxuICAgICAgICAgICAgICAgIGlkID0gX3JlZjMkc2hhcGUuaWQsXG4gICAgICAgICAgICAgICAgcG9pbnQgPSBfcmVmMyRzaGFwZS5wb2ludCxcbiAgICAgICAgICAgICAgICBfcmVmMyRzaGFwZSRyb3RhdGlvbiA9IF9yZWYzJHNoYXBlLnJvdGF0aW9uLFxuICAgICAgICAgICAgICAgIHJvdGF0aW9uID0gX3JlZjMkc2hhcGUkcm90YXRpb24gPT09IHZvaWQgMCA/IHVuZGVmaW5lZCA6IF9yZWYzJHNoYXBlJHJvdGF0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIFtpZCwge1xuICAgICAgICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgICAgICAgIHJvdGF0aW9uOiByb3RhdGlvblxuICAgICAgICAgICAgfV07XG4gICAgICAgICAgfSkpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhZnRlcjoge1xuICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgc2hhcGVzOiBPYmplY3QuZnJvbUVudHJpZXModGhpcy5zbmFwc2hvdC5pbml0aWFsU2hhcGVzLm1hcChmdW5jdGlvbiAoX3JlZjQpIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IF9yZWY0LnNoYXBlO1xuICAgICAgICAgICAgdmFyIF9kYXRhJHBhZ2Ukc2hhcGVzJHNoYSA9IGRhdGEucGFnZS5zaGFwZXNbc2hhcGUuaWRdLFxuICAgICAgICAgICAgICAgIHBvaW50ID0gX2RhdGEkcGFnZSRzaGFwZXMkc2hhLnBvaW50LFxuICAgICAgICAgICAgICAgIHJvdGF0aW9uID0gX2RhdGEkcGFnZSRzaGFwZXMkc2hhLnJvdGF0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIFtzaGFwZS5pZCwge1xuICAgICAgICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgICAgICAgIHJvdGF0aW9uOiByb3RhdGlvblxuICAgICAgICAgICAgfV07XG4gICAgICAgICAgfSkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBSb3RhdGVTZXNzaW9uO1xufSgpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuXG5mdW5jdGlvbiBnZXRSb3RhdGVTbmFwc2hvdChkYXRhKSB7XG4gIHZhciBpbml0aWFsU2hhcGVzID0gVExEUi5nZXRTZWxlY3RlZEJyYW5jaFNuYXBzaG90KGRhdGEpO1xuXG4gIGlmIChpbml0aWFsU2hhcGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IEVycm9yKCdObyBzZWxlY3RlZCBzaGFwZXMhJyk7XG4gIH1cblxuICB2YXIgaGFzVW5sb2NrZWRTaGFwZXMgPSBpbml0aWFsU2hhcGVzLmxlbmd0aCA+IDA7XG4gIHZhciBzaGFwZXNCb3VuZHMgPSBPYmplY3QuZnJvbUVudHJpZXMoaW5pdGlhbFNoYXBlcy5tYXAoZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgcmV0dXJuIFtzaGFwZS5pZCwgVExEUi5nZXRCb3VuZHMoc2hhcGUpXTtcbiAgfSkpO1xuICB2YXIgcm90YXRlZEJvdW5kcyA9IE9iamVjdC5mcm9tRW50cmllcyhpbml0aWFsU2hhcGVzLm1hcChmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICByZXR1cm4gW3NoYXBlLmlkLCBUTERSLmdldFJvdGF0ZWRCb3VuZHMoc2hhcGUpXTtcbiAgfSkpO1xuICB2YXIgYm91bmRzID0gY29yZS5VdGlscy5nZXRDb21tb25Cb3VuZHMoT2JqZWN0LnZhbHVlcyhzaGFwZXNCb3VuZHMpKTtcbiAgdmFyIGNvbW1vbkJvdW5kc0NlbnRlciA9IGNvcmUuVXRpbHMuZ2V0Qm91bmRzQ2VudGVyKGJvdW5kcyk7XG4gIHJldHVybiB7XG4gICAgaGFzVW5sb2NrZWRTaGFwZXM6IGhhc1VubG9ja2VkU2hhcGVzLFxuICAgIGJvdW5kc1JvdGF0aW9uOiBkYXRhLnBhZ2VTdGF0ZS5ib3VuZHNSb3RhdGlvbiB8fCAwLFxuICAgIGNvbW1vbkJvdW5kc0NlbnRlcjogY29tbW9uQm91bmRzQ2VudGVyLFxuICAgIGluaXRpYWxTaGFwZXM6IGluaXRpYWxTaGFwZXMuZmlsdGVyKGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgcmV0dXJuIHNoYXBlLmNoaWxkcmVuID09PSB1bmRlZmluZWQ7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgdmFyIGJvdW5kcyA9IFRMRFIuZ2V0Qm91bmRzKHNoYXBlKTtcbiAgICAgIHZhciBjZW50ZXIgPSBjb3JlLlV0aWxzLmdldEJvdW5kc0NlbnRlcihib3VuZHMpO1xuICAgICAgdmFyIG9mZnNldCA9IGNvcmUuVmVjLnN1YihjZW50ZXIsIHNoYXBlLnBvaW50KTtcbiAgICAgIHZhciByb3RhdGlvbk9mZnNldCA9IGNvcmUuVmVjLnN1YihjZW50ZXIsIGNvcmUuVXRpbHMuZ2V0Qm91bmRzQ2VudGVyKHJvdGF0ZWRCb3VuZHNbc2hhcGUuaWRdKSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogc2hhcGUuaWQsXG4gICAgICAgIHNoYXBlOiBjb3JlLlV0aWxzLmRlZXBDbG9uZShzaGFwZSksXG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICByb3RhdGlvbk9mZnNldDogcm90YXRpb25PZmZzZXQsXG4gICAgICAgIGNlbnRlcjogY2VudGVyXG4gICAgICB9O1xuICAgIH0pXG4gIH07XG59XG5cbnZhciBpbml0aWFsRGF0YSA9IHtcbiAgc2V0dGluZ3M6IHtcbiAgICBpc1Blbk1vZGU6IGZhbHNlLFxuICAgIGlzRGFya01vZGU6IGZhbHNlLFxuICAgIGlzRGVidWdNb2RlOiBcImRldmVsb3BtZW50XCIgPT09ICdkZXZlbG9wbWVudCcsXG4gICAgaXNSZWFkb25seU1vZGU6IGZhbHNlLFxuICAgIG51ZGdlRGlzdGFuY2VMYXJnZTogMTAsXG4gICAgbnVkZ2VEaXN0YW5jZVNtYWxsOiAxXG4gIH0sXG4gIGFwcFN0YXRlOiB7XG4gICAgYWN0aXZlVG9vbFR5cGU6IHVuZGVmaW5lZCxcbiAgICBhY3RpdmVUb29sOiAnc2VsZWN0JyxcbiAgICBob3ZlcmVkSWQ6IHVuZGVmaW5lZCxcbiAgICBjdXJyZW50UGFnZUlkOiAncGFnZScsXG4gICAgcGFnZXM6IFt7XG4gICAgICBpZDogJ3BhZ2UnXG4gICAgfV0sXG4gICAgY3VycmVudFN0eWxlOiBkZWZhdWx0U3R5bGUsXG4gICAgc2VsZWN0ZWRTdHlsZTogZGVmYXVsdFN0eWxlLFxuICAgIGlzVG9vbExvY2tlZDogZmFsc2UsXG4gICAgaXNTdHlsZU9wZW46IGZhbHNlLFxuICAgIGlzRW1wdHlDYW52YXM6IGZhbHNlXG4gIH0sXG4gIHBhZ2U6IHtcbiAgICBpZDogJ3BhZ2UnLFxuICAgIGNoaWxkSW5kZXg6IDEsXG4gICAgc2hhcGVzOiB7Ly8gcmVjdDE6IHtcbiAgICAgIC8vICAgaWQ6ICdyZWN0MScsXG4gICAgICAvLyAgIHBhcmVudElkOiAncGFnZScsXG4gICAgICAvLyAgIG5hbWU6ICdSZWN0YW5nbGUnLFxuICAgICAgLy8gICBjaGlsZEluZGV4OiAxLFxuICAgICAgLy8gICB0eXBlOiBUTERyYXdTaGFwZVR5cGUuUmVjdGFuZ2xlLFxuICAgICAgLy8gICBwb2ludDogWzMyLCAzMl0sXG4gICAgICAvLyAgIHNpemU6IFsxMDAsIDEwMF0sXG4gICAgICAvLyAgIHN0eWxlOiBkZWZhdWx0U3R5bGUsXG4gICAgICAvLyB9LFxuICAgIH0sXG4gICAgYmluZGluZ3M6IHsvLyBUT0RPXG4gICAgfVxuICB9LFxuICBwYWdlU3RhdGU6IHtcbiAgICBpZDogJ3BhZ2UnLFxuICAgIHNlbGVjdGVkSWRzOiBbXSxcbiAgICBjYW1lcmE6IHtcbiAgICAgIHBvaW50OiBbMCwgMF0sXG4gICAgICB6b29tOiAxXG4gICAgfVxuICB9XG59O1xudmFyIFRMRHJhd1N0YXRlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVExEcmF3U3RhdGUoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuc3RvcmUgPSBjcmVhdGVSZWFjdChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaW5pdGlhbERhdGE7XG4gICAgfSk7XG4gICAgdGhpcy5oaXN0b3J5ID0ge1xuICAgICAgc3RhY2s6IFtdLFxuICAgICAgcG9pbnRlcjogLTFcbiAgICB9O1xuICAgIHRoaXMuc2Vzc2lvbiA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXR1cyA9IHtcbiAgICAgIGN1cnJlbnQ6ICdpZGxlJyxcbiAgICAgIHByZXZpb3VzOiAnaWRsZSdcbiAgICB9O1xuICAgIHRoaXMucG9pbnRlZElkID0gdm9pZCAwO1xuICAgIHRoaXMucG9pbnRlZEhhbmRsZSA9IHZvaWQgMDtcbiAgICB0aGlzLnBvaW50ZWRCb3VuZHNIYW5kbGUgPSB2b2lkIDA7XG4gICAgdGhpcy5jdXJyZW50RG9jdW1lbnRJZCA9ICdkb2MnO1xuICAgIHRoaXMuY3VycmVudFBhZ2VJZCA9ICdwYWdlJztcbiAgICB0aGlzLnBhZ2VzID0ge1xuICAgICAgcGFnZTogaW5pdGlhbERhdGEucGFnZVxuICAgIH07XG4gICAgdGhpcy5wYWdlU3RhdGVzID0ge1xuICAgICAgcGFnZTogaW5pdGlhbERhdGEucGFnZVN0YXRlXG4gICAgfTtcbiAgICB0aGlzLl9vbkNoYW5nZSA9IHZvaWQgMDtcbiAgICB0aGlzLmdldFN0YXRlID0gdGhpcy5zdG9yZS5nZXRTdGF0ZTtcblxuICAgIHRoaXMuc2V0U3RhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBfdGhpcy5nZXRTdGF0ZSgpOyAvLyBBcHBseSBpbmNvbWluZyBjaGFuZ2VcblxuXG4gICAgICB2YXIgcmVzdWx0ID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicgPyBkYXRhKGN1cnJlbnQpIDogZGF0YTtcblxuICAgICAgdmFyIG5leHQgPSBfZXh0ZW5kcyh7fSwgY3VycmVudCwgcmVzdWx0KTtcblxuICAgICAgaWYgKCdwYWdlJyBpbiByZXN1bHQpIHtcbiAgICAgICAgbmV4dC5wYWdlID0gX2V4dGVuZHMoe30sIG5leHQucGFnZSwge1xuICAgICAgICAgIHNoYXBlczogT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKG5leHQucGFnZS5zaGFwZXMpLmZpbHRlcihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gX3JlZlsxXTtcbiAgICAgICAgICAgIHJldHVybiBzaGFwZSAmJiAoc2hhcGUucGFyZW50SWQgPT09IG5leHQucGFnZS5pZCB8fCBuZXh0LnBhZ2Uuc2hhcGVzW3NoYXBlLnBhcmVudElkXSk7XG4gICAgICAgICAgfSkpXG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBBcHBseSBzZWxlY3RlZCBzdHlsZSBjaGFuZ2UsIGlmIGFueVxuXG5cbiAgICAgIHZhciBuZXdTZWxlY3RlZFN0eWxlID0gVExEUi5nZXRTZWxlY3RlZFN0eWxlKG5leHQpO1xuXG4gICAgICBpZiAobmV3U2VsZWN0ZWRTdHlsZSkge1xuICAgICAgICBuZXh0ID0gX2V4dGVuZHMoe30sIG5leHQsIHtcbiAgICAgICAgICBhcHBTdGF0ZTogX2V4dGVuZHMoe30sIGN1cnJlbnQuYXBwU3RhdGUsIG5leHQuYXBwU3RhdGUsIHtcbiAgICAgICAgICAgIHNlbGVjdGVkU3R5bGU6IG5ld1NlbGVjdGVkU3R5bGVcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuc3RvcmUuc2V0U3RhdGUobmV4dCk7XG5cbiAgICAgIF90aGlzLnBhZ2VzW25leHQucGFnZS5pZF0gPSBuZXh0LnBhZ2U7XG4gICAgICBfdGhpcy5wYWdlU3RhdGVzW25leHQucGFnZS5pZF0gPSBuZXh0LnBhZ2VTdGF0ZTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRTaGFwZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuIF90aGlzLmdldFN0YXRlKCkucGFnZS5zaGFwZXNbaWRdO1xuICAgIH07XG5cbiAgICB0aGlzLmdldFBhZ2UgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGlmIChpZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlkID0gX3RoaXMuY3VycmVudFBhZ2VJZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzLnBhZ2VzW2lkXTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRQYWdlU3RhdGUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGlmIChpZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlkID0gX3RoaXMuY3VycmVudFBhZ2VJZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzLnBhZ2VTdGF0ZXNbaWRdO1xuICAgIH07XG5cbiAgICB0aGlzLmdldEFwcFN0YXRlID0gZnVuY3Rpb24gKGlkKSB7XG5cbiAgICAgIHJldHVybiBfdGhpcy5nZXRTdGF0ZSgpLmFwcFN0YXRlO1xuICAgIH07XG5cbiAgICB0aGlzLmdldFBhZ2VQb2ludCA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgdmFyIF90aGlzJGdldFBhZ2VTdGF0ZSA9IF90aGlzLmdldFBhZ2VTdGF0ZSgpLFxuICAgICAgICAgIGNhbWVyYSA9IF90aGlzJGdldFBhZ2VTdGF0ZS5jYW1lcmE7XG5cbiAgICAgIHJldHVybiBjb3JlLlZlYy5zdWIoY29yZS5WZWMuZGl2KHBvaW50LCBjYW1lcmEuem9vbSksIGNhbWVyYS5wb2ludCk7XG4gICAgfTtcblxuICAgIHRoaXMudG9nZ2xlU3R5bGVQYW5lbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYXBwU3RhdGU6IF9leHRlbmRzKHt9LCBkYXRhLmFwcFN0YXRlLCB7XG4gICAgICAgICAgICBpc1N0eWxlT3BlbjogIWRhdGEuYXBwU3RhdGUuaXNTdHlsZU9wZW5cbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5jb3B5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVE9ET1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLnBhc3RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVE9ET1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLmNvcHlBc1N2ZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFRPRE9cbiAgICAgIHJldHVybiAnPHN2Zy8+JztcbiAgICB9O1xuXG4gICAgdGhpcy5jb3B5QXNKc29uID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVE9ET1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH07XG5cbiAgICB0aGlzLnRvZ2dsZVBlbk1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNldHRpbmdzOiBfZXh0ZW5kcyh7fSwgZGF0YS5zZXR0aW5ncywge1xuICAgICAgICAgICAgaXNQZW5Nb2RlOiAhZGF0YS5zZXR0aW5ncy5pc1Blbk1vZGVcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy50b2dnbGVEYXJrTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc2V0dGluZ3M6IF9leHRlbmRzKHt9LCBkYXRhLnNldHRpbmdzLCB7XG4gICAgICAgICAgICBpc0RhcmtNb2RlOiAhZGF0YS5zZXR0aW5ncy5pc0RhcmtNb2RlXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFwcFN0YXRlOiBfZXh0ZW5kcyh7fSwgZGF0YS5hcHBTdGF0ZSwgaW5pdGlhbERhdGEuYXBwU3RhdGUpLFxuICAgICAgICAgIHNldHRpbmdzOiBfZXh0ZW5kcyh7fSwgZGF0YS5hcHBTdGF0ZSwgaW5pdGlhbERhdGEuc2V0dGluZ3MpXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgX3RoaXMuX29uQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcy5fb25DaGFuZ2UoX3RoaXMsIFwicmVzZXRcIik7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMuc2VsZWN0VG9vbCA9IGZ1bmN0aW9uICh0b29sKSB7XG4gICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFwcFN0YXRlOiBfZXh0ZW5kcyh7fSwgZGF0YS5hcHBTdGF0ZSwge1xuICAgICAgICAgICAgYWN0aXZlVG9vbDogdG9vbCxcbiAgICAgICAgICAgIGFjdGl2ZVRvb2xUeXBlOiB0b29sID09PSAnc2VsZWN0JyA/ICdzZWxlY3QnIDogVExEUi5nZXRTaGFwZVV0aWxzKHtcbiAgICAgICAgICAgICAgdHlwZTogdG9vbFxuICAgICAgICAgICAgfSkudG9vbFR5cGVcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy50b2dnbGVUb29sTG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYXBwU3RhdGU6IF9leHRlbmRzKHt9LCBkYXRhLmFwcFN0YXRlLCB7XG4gICAgICAgICAgICBpc1Rvb2xMb2NrZWQ6IHRydWVcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy56b29tSW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaSA9IE1hdGgucm91bmQoX3RoaXMuc3RvcmUuZ2V0U3RhdGUoKS5wYWdlU3RhdGUuY2FtZXJhLnpvb20gKiAxMDAgLyAyNSk7XG4gICAgICB2YXIgbmV4dFpvb20gPSBUTERSLmdldENhbWVyYVpvb20oKGkgKyAxKSAqIDAuMjUpO1xuXG4gICAgICBfdGhpcy56b29tVG8obmV4dFpvb20pO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMuem9vbU91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpID0gTWF0aC5yb3VuZChfdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLnBhZ2VTdGF0ZS5jYW1lcmEuem9vbSAqIDEwMCAvIDI1KTtcbiAgICAgIHZhciBuZXh0Wm9vbSA9IFRMRFIuZ2V0Q2FtZXJhWm9vbSgoaSAtIDEpICogMC4yNSk7XG5cbiAgICAgIF90aGlzLnpvb21UbyhuZXh0Wm9vbSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy56b29tVG9GaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgc2hhcGVzID0gT2JqZWN0LnZhbHVlcyhkYXRhLnBhZ2Uuc2hhcGVzKTtcbiAgICAgICAgaWYgKHNoYXBlcy5sZW5ndGggPT09IDApIHJldHVybiB7XG4gICAgICAgICAgcGFnZVN0YXRlOiBkYXRhLnBhZ2VTdGF0ZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgYm91bmRzID0gY29yZS5VdGlscy5nZXRDb21tb25Cb3VuZHMoT2JqZWN0LnZhbHVlcyhzaGFwZXMpLm1hcChUTERSLmdldEJvdW5kcykpO1xuICAgICAgICB2YXIgem9vbSA9IFRMRFIuZ2V0Q2FtZXJhWm9vbShib3VuZHMud2lkdGggPiBib3VuZHMuaGVpZ2h0ID8gKHdpbmRvdy5pbm5lcldpZHRoIC0gMTI4KSAvIGJvdW5kcy53aWR0aCA6ICh3aW5kb3cuaW5uZXJIZWlnaHQgLSAxMjgpIC8gYm91bmRzLmhlaWdodCk7XG4gICAgICAgIHZhciBteCA9ICh3aW5kb3cuaW5uZXJXaWR0aCAtIGJvdW5kcy53aWR0aCAqIHpvb20pIC8gMiAvIHpvb207XG4gICAgICAgIHZhciBteSA9ICh3aW5kb3cuaW5uZXJIZWlnaHQgLSBib3VuZHMuaGVpZ2h0ICogem9vbSkgLyAyIC8gem9vbTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYWdlU3RhdGU6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2VTdGF0ZSwge1xuICAgICAgICAgICAgY2FtZXJhOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlU3RhdGUuY2FtZXJhLCB7XG4gICAgICAgICAgICAgIHBvaW50OiBjb3JlLlZlYy5hZGQoWy1ib3VuZHMubWluWCwgLWJvdW5kcy5taW5ZXSwgW214LCBteV0pLFxuICAgICAgICAgICAgICB6b29tOiB6b29tXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLnpvb21Ub1NlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmIChUTERSLmdldFNlbGVjdGVkSWRzKGRhdGEpLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHtcbiAgICAgICAgICBwYWdlU3RhdGU6IGRhdGEucGFnZVN0YXRlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBib3VuZHMgPSBUTERSLmdldFNlbGVjdGVkQm91bmRzKGRhdGEpO1xuICAgICAgICB2YXIgem9vbSA9IFRMRFIuZ2V0Q2FtZXJhWm9vbShib3VuZHMud2lkdGggPiBib3VuZHMuaGVpZ2h0ID8gKHdpbmRvdy5pbm5lcldpZHRoIC0gMTI4KSAvIGJvdW5kcy53aWR0aCA6ICh3aW5kb3cuaW5uZXJIZWlnaHQgLSAxMjgpIC8gYm91bmRzLmhlaWdodCk7XG4gICAgICAgIHZhciBteCA9ICh3aW5kb3cuaW5uZXJXaWR0aCAtIGJvdW5kcy53aWR0aCAqIHpvb20pIC8gMiAvIHpvb207XG4gICAgICAgIHZhciBteSA9ICh3aW5kb3cuaW5uZXJIZWlnaHQgLSBib3VuZHMuaGVpZ2h0ICogem9vbSkgLyAyIC8gem9vbTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYWdlU3RhdGU6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2VTdGF0ZSwge1xuICAgICAgICAgICAgY2FtZXJhOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlU3RhdGUuY2FtZXJhLCB7XG4gICAgICAgICAgICAgIHBvaW50OiBjb3JlLlZlYy5hZGQoWy1ib3VuZHMubWluWCwgLWJvdW5kcy5taW5ZXSwgW214LCBteV0pLFxuICAgICAgICAgICAgICB6b29tOiB6b29tXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLnJlc2V0Q2FtZXJhID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYWdlU3RhdGU6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2VTdGF0ZSwge1xuICAgICAgICAgICAgY2FtZXJhOiB7XG4gICAgICAgICAgICAgIHpvb206IDEsXG4gICAgICAgICAgICAgIHBvaW50OiBbd2luZG93LmlubmVyV2lkdGggLyAyLCB3aW5kb3cuaW5uZXJIZWlnaHQgLyAyXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLnpvb21Ub0NvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgc2hhcGVzID0gT2JqZWN0LnZhbHVlcyhkYXRhLnBhZ2Uuc2hhcGVzKTtcbiAgICAgICAgaWYgKHNoYXBlcy5sZW5ndGggPT09IDApIHJldHVybiB7XG4gICAgICAgICAgcGFnZVN0YXRlOiBkYXRhLnBhZ2VTdGF0ZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgYm91bmRzID0gY29yZS5VdGlscy5nZXRDb21tb25Cb3VuZHMoT2JqZWN0LnZhbHVlcyhzaGFwZXMpLm1hcChUTERSLmdldEJvdW5kcykpO1xuICAgICAgICB2YXIgem9vbSA9IGRhdGEucGFnZVN0YXRlLmNhbWVyYS56b29tO1xuICAgICAgICB2YXIgbXggPSAod2luZG93LmlubmVyV2lkdGggLSBib3VuZHMud2lkdGggKiB6b29tKSAvIDIgLyB6b29tO1xuICAgICAgICB2YXIgbXkgPSAod2luZG93LmlubmVySGVpZ2h0IC0gYm91bmRzLmhlaWdodCAqIHpvb20pIC8gMiAvIHpvb207XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGFnZVN0YXRlOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlU3RhdGUsIHtcbiAgICAgICAgICAgIGNhbWVyYTogX2V4dGVuZHMoe30sIGRhdGEucGFnZVN0YXRlLmNhbWVyYSwge1xuICAgICAgICAgICAgICBwb2ludDogY29yZS5WZWMuYWRkKFstYm91bmRzLm1pblgsIC1ib3VuZHMubWluWV0sIFtteCwgbXldKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy56b29tVG9BY3R1YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy56b29tVG8oMSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5sb2FkRG9jdW1lbnQgPSBmdW5jdGlvbiAoZG9jdW1lbnQsIG9uQ2hhbmdlKSB7XG4gICAgICBfdGhpcy5fb25DaGFuZ2UgPSBvbkNoYW5nZTtcbiAgICAgIF90aGlzLmN1cnJlbnREb2N1bWVudElkID0gZG9jdW1lbnQuaWQ7XG4gICAgICBfdGhpcy5wYWdlcyA9IGNvcmUuVXRpbHMuZGVlcENsb25lKGRvY3VtZW50LnBhZ2VzKTtcbiAgICAgIF90aGlzLnBhZ2VTdGF0ZXMgPSBjb3JlLlV0aWxzLmRlZXBDbG9uZShkb2N1bWVudC5wYWdlU3RhdGVzKTtcbiAgICAgIF90aGlzLmN1cnJlbnRQYWdlSWQgPSBPYmplY3QudmFsdWVzKF90aGlzLnBhZ2VzKVswXS5pZDtcblxuICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYWdlOiBfdGhpcy5wYWdlc1tfdGhpcy5jdXJyZW50UGFnZUlkXSxcbiAgICAgICAgICBwYWdlU3RhdGU6IF90aGlzLnBhZ2VTdGF0ZXNbX3RoaXMuY3VycmVudFBhZ2VJZF0sXG4gICAgICAgICAgYXBwU3RhdGU6IF9leHRlbmRzKHt9LCBkYXRhLmFwcFN0YXRlLCB7XG4gICAgICAgICAgICBwYWdlSWRzOiBPYmplY3QudmFsdWVzKF90aGlzLnBhZ2VzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgIHJldHVybiAoYS5jaGlsZEluZGV4IHx8IDApIC0gKGIuY2hpbGRJbmRleCB8fCAwKTtcbiAgICAgICAgICAgIH0pLm1hcChmdW5jdGlvbiAocGFnZSkge1xuICAgICAgICAgICAgICByZXR1cm4gcGFnZS5pZDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMudW5kbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBoaXN0b3J5ID0gX3RoaXMuaGlzdG9yeTtcbiAgICAgIGlmIChoaXN0b3J5LnBvaW50ZXIgPD0gLTEpIHJldHVybiBfdGhpcztcbiAgICAgIHZhciBjb21tYW5kID0gaGlzdG9yeS5zdGFja1toaXN0b3J5LnBvaW50ZXJdO1xuXG4gICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gY29yZS5VdGlscy5kZWVwTWVyZ2UoZGF0YSwgY29tbWFuZC5iZWZvcmUpO1xuICAgICAgfSk7XG5cbiAgICAgIGhpc3RvcnkucG9pbnRlci0tO1xuICAgICAgX3RoaXMuX29uQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcy5fb25DaGFuZ2UoX3RoaXMsIFwidW5kbzpcIiArIGNvbW1hbmQuaWQpO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLnJlZG8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaGlzdG9yeSA9IF90aGlzLmhpc3Rvcnk7XG4gICAgICBpZiAoaGlzdG9yeS5wb2ludGVyID49IGhpc3Rvcnkuc3RhY2subGVuZ3RoIC0gMSkgcmV0dXJuIF90aGlzO1xuICAgICAgaGlzdG9yeS5wb2ludGVyKys7XG4gICAgICB2YXIgY29tbWFuZCA9IGhpc3Rvcnkuc3RhY2tbaGlzdG9yeS5wb2ludGVyXTtcblxuICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGNvcmUuVXRpbHMuZGVlcE1lcmdlKGRhdGEsIGNvbW1hbmQuYWZ0ZXIpO1xuICAgICAgfSk7XG5cbiAgICAgIF90aGlzLl9vbkNoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMuX29uQ2hhbmdlKF90aGlzLCBcInJlZG86XCIgKyBjb21tYW5kLmlkKTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5zZWxlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgaWRzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBpZHNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnNldFNlbGVjdGVkSWRzKGlkcyk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5zZWxlY3RBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFwcFN0YXRlOiBfZXh0ZW5kcyh7fSwgZGF0YS5hcHBTdGF0ZSwge1xuICAgICAgICAgICAgYWN0aXZlVG9vbDogJ3NlbGVjdCcsXG4gICAgICAgICAgICBhY3RpdmVUb29sVHlwZTogJ3NlbGVjdCdcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBwYWdlU3RhdGU6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2VTdGF0ZSwge1xuICAgICAgICAgICAgc2VsZWN0ZWRJZHM6IE9iamVjdC5rZXlzKGRhdGEucGFnZS5zaGFwZXMpXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMuZGVzZWxlY3RBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5zZXRTZWxlY3RlZElkcyhbXSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5zdHlsZSA9IGZ1bmN0aW9uIChzdHlsZSQxLCBpZHMpIHtcbiAgICAgIHZhciBkYXRhID0gX3RoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgICAgdmFyIGlkc1RvTXV0YXRlID0gaWRzID8gaWRzIDogZGF0YS5wYWdlU3RhdGUuc2VsZWN0ZWRJZHM7XG5cbiAgICAgIF90aGlzW1wiZG9cIl0oc3R5bGUoZGF0YSwgaWRzVG9NdXRhdGUsIHN0eWxlJDEpKTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLmFsaWduID0gZnVuY3Rpb24gKHR5cGUsIGlkcykge1xuICAgICAgdmFyIGRhdGEgPSBfdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICB2YXIgaWRzVG9NdXRhdGUgPSBpZHMgPyBpZHMgOiBkYXRhLnBhZ2VTdGF0ZS5zZWxlY3RlZElkcztcblxuICAgICAgX3RoaXNbXCJkb1wiXShhbGlnbihkYXRhLCBpZHNUb011dGF0ZSwgdHlwZSkpO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMuZGlzdHJpYnV0ZSA9IGZ1bmN0aW9uICh0eXBlLCBpZHMpIHtcbiAgICAgIHZhciBkYXRhID0gX3RoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgICAgdmFyIGlkc1RvTXV0YXRlID0gaWRzID8gaWRzIDogZGF0YS5wYWdlU3RhdGUuc2VsZWN0ZWRJZHM7XG5cbiAgICAgIF90aGlzW1wiZG9cIl0oZGlzdHJpYnV0ZShkYXRhLCBpZHNUb011dGF0ZSwgdHlwZSkpO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMuc3RyZXRjaCA9IGZ1bmN0aW9uICh0eXBlLCBpZHMpIHtcbiAgICAgIHZhciBkYXRhID0gX3RoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgICAgdmFyIGlkc1RvTXV0YXRlID0gaWRzID8gaWRzIDogZGF0YS5wYWdlU3RhdGUuc2VsZWN0ZWRJZHM7XG5cbiAgICAgIF90aGlzW1wiZG9cIl0oc3RyZXRjaChkYXRhLCBpZHNUb011dGF0ZSwgdHlwZSkpO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMubW92ZVRvQmFjayA9IGZ1bmN0aW9uIChpZHMpIHtcbiAgICAgIHZhciBkYXRhID0gX3RoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgICAgdmFyIGlkc1RvTXV0YXRlID0gaWRzID8gaWRzIDogZGF0YS5wYWdlU3RhdGUuc2VsZWN0ZWRJZHM7XG5cbiAgICAgIF90aGlzW1wiZG9cIl0obW92ZShkYXRhLCBpZHNUb011dGF0ZSwgZXhwb3J0cy5Nb3ZlVHlwZS5Ub0JhY2spKTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLm1vdmVCYWNrd2FyZCA9IGZ1bmN0aW9uIChpZHMpIHtcbiAgICAgIHZhciBkYXRhID0gX3RoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgICAgdmFyIGlkc1RvTXV0YXRlID0gaWRzID8gaWRzIDogZGF0YS5wYWdlU3RhdGUuc2VsZWN0ZWRJZHM7XG5cbiAgICAgIF90aGlzW1wiZG9cIl0obW92ZShkYXRhLCBpZHNUb011dGF0ZSwgZXhwb3J0cy5Nb3ZlVHlwZS5CYWNrd2FyZCkpO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMubW92ZUZvcndhcmQgPSBmdW5jdGlvbiAoaWRzKSB7XG4gICAgICB2YXIgZGF0YSA9IF90aGlzLnN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAgIHZhciBpZHNUb011dGF0ZSA9IGlkcyA/IGlkcyA6IGRhdGEucGFnZVN0YXRlLnNlbGVjdGVkSWRzO1xuXG4gICAgICBfdGhpc1tcImRvXCJdKG1vdmUoZGF0YSwgaWRzVG9NdXRhdGUsIGV4cG9ydHMuTW92ZVR5cGUuRm9yd2FyZCkpO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMubW92ZVRvRnJvbnQgPSBmdW5jdGlvbiAoaWRzKSB7XG4gICAgICB2YXIgZGF0YSA9IF90aGlzLnN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAgIHZhciBpZHNUb011dGF0ZSA9IGlkcyA/IGlkcyA6IGRhdGEucGFnZVN0YXRlLnNlbGVjdGVkSWRzO1xuXG4gICAgICBfdGhpc1tcImRvXCJdKG1vdmUoZGF0YSwgaWRzVG9NdXRhdGUsIGV4cG9ydHMuTW92ZVR5cGUuVG9Gcm9udCkpO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMubnVkZ2UgPSBmdW5jdGlvbiAoZGVsdGEsIGlzTWFqb3IsIGlkcykge1xuICAgICAgaWYgKGlzTWFqb3IgPT09IHZvaWQgMCkge1xuICAgICAgICBpc01ham9yID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRhID0gX3RoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgICAgdmFyIGlkc1RvTXV0YXRlID0gaWRzID8gaWRzIDogZGF0YS5wYWdlU3RhdGUuc2VsZWN0ZWRJZHM7XG5cbiAgICAgIF90aGlzW1wiZG9cIl0odHJhbnNsYXRlKGRhdGEsIGlkc1RvTXV0YXRlLCBjb3JlLlZlYy5tdWwoZGVsdGEsIGlzTWFqb3IgPyAxMCA6IDEpKSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5kdXBsaWNhdGUgPSBmdW5jdGlvbiAoaWRzKSB7XG4gICAgICB2YXIgZGF0YSA9IF90aGlzLnN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAgIHZhciBpZHNUb011dGF0ZSA9IGlkcyA/IGlkcyA6IGRhdGEucGFnZVN0YXRlLnNlbGVjdGVkSWRzO1xuXG4gICAgICBfdGhpc1tcImRvXCJdKGR1cGxpY2F0ZShkYXRhLCBpZHNUb011dGF0ZSkpO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMudG9nZ2xlSGlkZGVuID0gZnVuY3Rpb24gKGlkcykge1xuICAgICAgdmFyIGRhdGEgPSBfdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICB2YXIgaWRzVG9NdXRhdGUgPSBpZHMgPyBpZHMgOiBkYXRhLnBhZ2VTdGF0ZS5zZWxlY3RlZElkcztcblxuICAgICAgX3RoaXNbXCJkb1wiXSh0b2dnbGUoZGF0YSwgaWRzVG9NdXRhdGUsICdpc0hpZGRlbicpKTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLnRvZ2dsZUxvY2tlZCA9IGZ1bmN0aW9uIChpZHMpIHtcbiAgICAgIHZhciBkYXRhID0gX3RoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgICAgdmFyIGlkc1RvTXV0YXRlID0gaWRzID8gaWRzIDogZGF0YS5wYWdlU3RhdGUuc2VsZWN0ZWRJZHM7XG5cbiAgICAgIF90aGlzW1wiZG9cIl0odG9nZ2xlKGRhdGEsIGlkc1RvTXV0YXRlLCAnaXNMb2NrZWQnKSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy50b2dnbGVBc3BlY3RSYXRpb0xvY2tlZCA9IGZ1bmN0aW9uIChpZHMpIHtcbiAgICAgIHZhciBkYXRhID0gX3RoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgICAgdmFyIGlkc1RvTXV0YXRlID0gaWRzID8gaWRzIDogZGF0YS5wYWdlU3RhdGUuc2VsZWN0ZWRJZHM7XG5cbiAgICAgIF90aGlzW1wiZG9cIl0odG9nZ2xlKGRhdGEsIGlkc1RvTXV0YXRlLCAnaXNBc3BlY3RSYXRpb0xvY2tlZCcpKTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLnJvdGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSwgaWRzKSB7XG4gICAgICBpZiAoZGVsdGEgPT09IHZvaWQgMCkge1xuICAgICAgICBkZWx0YSA9IE1hdGguUEkgKiAtMC41O1xuICAgICAgfVxuXG4gICAgICB2YXIgZGF0YSA9IF90aGlzLnN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAgIHZhciBpZHNUb011dGF0ZSA9IGlkcyA/IGlkcyA6IGRhdGEucGFnZVN0YXRlLnNlbGVjdGVkSWRzO1xuXG4gICAgICBfdGhpc1tcImRvXCJdKHJvdGF0ZShkYXRhLCBpZHNUb011dGF0ZSwgZGVsdGEpKTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLmdyb3VwID0gZnVuY3Rpb24gKGlkcykge1xuICAgICAgLy8gVE9ET1xuICAgICAgLy8gY29uc3QgZGF0YSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKVxuICAgICAgLy8gY29uc3QgaWRzVG9NdXRhdGUgPSBpZHMgPyBpZHMgOiBkYXRhLnBhZ2VTdGF0ZS5zZWxlY3RlZElkc1xuICAgICAgLy8gdGhpcy5kbyhjb21tYW5kcy50b2dnbGUoZGF0YSwgaWRzVG9NdXRhdGUsICdpc0FzcGVjdFJhdGlvTG9ja2VkJykpXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGRhdGEgPSBfdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNoYXBlcyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBzaGFwZXNbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgX3RoaXNbXCJkb1wiXShjcmVhdGUoZGF0YSwgc2hhcGVzKSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpc1tcImRlbGV0ZVwiXSA9IGZ1bmN0aW9uIChpZHMpIHtcbiAgICAgIHZhciBkYXRhID0gX3RoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgICAgdmFyIGlkc1RvTXV0YXRlID0gaWRzID8gaWRzIDogZGF0YS5wYWdlU3RhdGUuc2VsZWN0ZWRJZHM7XG4gICAgICBpZiAoaWRzVG9NdXRhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gX3RoaXM7XG5cbiAgICAgIF90aGlzW1wiZG9cIl0oZGVsZXRlU2hhcGVzKGRhdGEsIGlkc1RvTXV0YXRlKSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnNlbGVjdEFsbCgpO1xuXG4gICAgICBfdGhpc1tcImRlbGV0ZVwiXSgpO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgc3dpdGNoIChfdGhpcy5zdGF0dXMuY3VycmVudCkge1xuICAgICAgICBjYXNlICdpZGxlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBfdGhpcy5kZXNlbGVjdEFsbCgpO1xuXG4gICAgICAgICAgICBfdGhpcy5zZWxlY3RUb29sKCdzZWxlY3QnKTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2JydXNoaW5nJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBfdGhpcy5jYW5jZWxTZXNzaW9uKCk7XG5cbiAgICAgICAgICAgIGNvcmUuYnJ1c2hVcGRhdGVyLmNsZWFyKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAndHJhbnNsYXRpbmcnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIF90aGlzLmNhbmNlbFNlc3Npb24oKTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3RyYW5zZm9ybWluZyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgX3RoaXMuY2FuY2VsU2Vzc2lvbigpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAncm90YXRpbmcnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIF90aGlzLmNhbmNlbFNlc3Npb24oKTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2NyZWF0aW5nJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBfdGhpcy5jYW5jZWxTZXNzaW9uKCk7XG5cbiAgICAgICAgICAgIF90aGlzW1wiZGVsZXRlXCJdKCk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLnNhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBUT0RPXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMuc3RhcnRCcnVzaFNlc3Npb24gPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIF90aGlzLnNldFN0YXR1cygnYnJ1c2hpbmcnKTtcblxuICAgICAgX3RoaXMuc3RhcnRTZXNzaW9uKG5ldyBCcnVzaFNlc3Npb24oX3RoaXMuc3RvcmUuZ2V0U3RhdGUoKSwgcG9pbnQpKTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLnVwZGF0ZUJydXNoU2Vzc2lvbiA9IGZ1bmN0aW9uIChwb2ludCwgbWV0YUtleSkge1xuICAgICAgaWYgKG1ldGFLZXkgPT09IHZvaWQgMCkge1xuICAgICAgICBtZXRhS2V5ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnVwZGF0ZVNlc3Npb24ocG9pbnQsIG1ldGFLZXkpO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMuc3RhcnRUcmFuc2xhdGVTZXNzaW9uID0gZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICBfdGhpcy5zZXRTdGF0dXMoJ3RyYW5zbGF0aW5nJyk7XG5cbiAgICAgIF90aGlzLnN0YXJ0U2Vzc2lvbihuZXcgVHJhbnNsYXRlU2Vzc2lvbihfdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLCBwb2ludCkpO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMudXBkYXRlVHJhbnNsYXRlU2Vzc2lvbiA9IGZ1bmN0aW9uIChwb2ludCwgc2hpZnRLZXksIGFsdEtleSkge1xuICAgICAgaWYgKHNoaWZ0S2V5ID09PSB2b2lkIDApIHtcbiAgICAgICAgc2hpZnRLZXkgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFsdEtleSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGFsdEtleSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy51cGRhdGVTZXNzaW9uKHBvaW50LCBzaGlmdEtleSwgYWx0S2V5KTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLnN0YXJ0VHJhbnNmb3JtU2Vzc2lvbiA9IGZ1bmN0aW9uIChwb2ludCwgaGFuZGxlLCBjb21tYW5kSWQpIHtcbiAgICAgIHZhciBzZWxlY3RlZElkcyA9IF90aGlzLnNlbGVjdGVkSWRzO1xuICAgICAgaWYgKHNlbGVjdGVkSWRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIF90aGlzO1xuXG4gICAgICBfdGhpcy5zZXRTdGF0dXMoJ3RyYW5zZm9ybWluZycpO1xuXG4gICAgICBfdGhpcy5wb2ludGVkQm91bmRzSGFuZGxlID0gaGFuZGxlO1xuXG4gICAgICBpZiAoX3RoaXMucG9pbnRlZEJvdW5kc0hhbmRsZSA9PT0gJ3JvdGF0ZScpIHtcbiAgICAgICAgX3RoaXMuc3RhcnRTZXNzaW9uKG5ldyBSb3RhdGVTZXNzaW9uKF90aGlzLnN0b3JlLmdldFN0YXRlKCksIHBvaW50KSk7XG4gICAgICB9IGVsc2UgaWYgKF90aGlzLnNlbGVjdGVkSWRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBfdGhpcy5zdGFydFNlc3Npb24obmV3IFRyYW5zZm9ybVNpbmdsZVNlc3Npb24oX3RoaXMuc3RvcmUuZ2V0U3RhdGUoKSwgcG9pbnQsIF90aGlzLnBvaW50ZWRCb3VuZHNIYW5kbGUsIGNvbW1hbmRJZCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuc3RhcnRTZXNzaW9uKG5ldyBUcmFuc2Zvcm1TZXNzaW9uKF90aGlzLnN0b3JlLmdldFN0YXRlKCksIHBvaW50LCBfdGhpcy5wb2ludGVkQm91bmRzSGFuZGxlKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy51cGRhdGVUcmFuc2Zvcm1TZXNzaW9uID0gZnVuY3Rpb24gKHBvaW50LCBzaGlmdEtleSwgYWx0S2V5KSB7XG4gICAgICBpZiAoc2hpZnRLZXkgPT09IHZvaWQgMCkge1xuICAgICAgICBzaGlmdEtleSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWx0S2V5ID09PSB2b2lkIDApIHtcbiAgICAgICAgYWx0S2V5ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnVwZGF0ZVNlc3Npb24ocG9pbnQsIHNoaWZ0S2V5LCBhbHRLZXkpO1xuXG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHRoaXMuc3RhcnREcmF3U2Vzc2lvbiA9IGZ1bmN0aW9uIChpZCwgcG9pbnQpIHtcbiAgICAgIF90aGlzLnNldFN0YXR1cygnY3JlYXRpbmcnKTtcblxuICAgICAgX3RoaXMuc3RhcnRTZXNzaW9uKG5ldyBEcmF3U2Vzc2lvbihfdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLCBpZCwgcG9pbnQpKTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLnVwZGF0ZURyYXdTZXNzaW9uID0gZnVuY3Rpb24gKHBvaW50LCBwcmVzc3VyZSwgc2hpZnRLZXkpIHtcbiAgICAgIGlmIChzaGlmdEtleSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHNoaWZ0S2V5ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnVwZGF0ZVNlc3Npb24ocG9pbnQsIHByZXNzdXJlLCBzaGlmdEtleSk7XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy51cGRhdGVTZXNzaW9uc09uUG9pbnRlck1vdmUgPSBmdW5jdGlvbiAoaW5mbykge1xuICAgICAgc3dpdGNoIChfdGhpcy5zdGF0dXMuY3VycmVudCkge1xuICAgICAgICBjYXNlICdwb2ludGluZ0JvdW5kc0hhbmRsZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKGNvcmUuVmVjLmRpc3QoaW5mby5vcmlnaW4sIGluZm8ucG9pbnQpID4gNCkge1xuICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0dXMoJ3RyYW5zZm9ybWluZycpO1xuXG4gICAgICAgICAgICAgIF90aGlzLnN0YXJ0VHJhbnNmb3JtU2Vzc2lvbihfdGhpcy5nZXRQYWdlUG9pbnQoaW5mby5vcmlnaW4pLCBfdGhpcy5wb2ludGVkQm91bmRzSGFuZGxlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3BvaW50aW5nQm91bmRzJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoY29yZS5WZWMuZGlzdChpbmZvLm9yaWdpbiwgaW5mby5wb2ludCkgPiA0KSB7XG4gICAgICAgICAgICAgIF90aGlzLnNldFN0YXR1cygndHJhbnNsYXRpbmcnKTtcblxuICAgICAgICAgICAgICBfdGhpcy5zdGFydFRyYW5zbGF0ZVNlc3Npb24oX3RoaXMuZ2V0UGFnZVBvaW50KGluZm8ub3JpZ2luKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdicnVzaGluZyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgX3RoaXMudXBkYXRlQnJ1c2hTZXNzaW9uKF90aGlzLmdldFBhZ2VQb2ludChpbmZvLnBvaW50KSwgaW5mby5tZXRhS2V5KTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3RyYW5zbGF0aW5nJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBfdGhpcy51cGRhdGVUcmFuc2xhdGVTZXNzaW9uKF90aGlzLmdldFBhZ2VQb2ludChpbmZvLnBvaW50KSwgaW5mby5zaGlmdEtleSwgaW5mby5hbHRLZXkpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAndHJhbnNmb3JtaW5nJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBfdGhpcy51cGRhdGVUcmFuc2Zvcm1TZXNzaW9uKF90aGlzLmdldFBhZ2VQb2ludChpbmZvLnBvaW50KSwgaW5mby5zaGlmdEtleSwgaW5mby5hbHRLZXkpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnY3JlYXRpbmcnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX3RoaXMuYXBwU3RhdGUuYWN0aXZlVG9vbFR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnZHJhdyc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlRHJhd1Nlc3Npb24oX3RoaXMuZ2V0UGFnZVBvaW50KGluZm8ucG9pbnQpLCBpbmZvLnByZXNzdXJlLCBpbmZvLnNoaWZ0S2V5KTtcblxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNhc2UgJ2JvdW5kcyc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlVHJhbnNmb3JtU2Vzc2lvbihfdGhpcy5nZXRQYWdlUG9pbnQoaW5mby5wb2ludCksIGluZm8uc2hpZnRLZXkpO1xuXG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5vbktleURvd24gPSBmdW5jdGlvbiAoa2V5LCBpbmZvKSB7XG4gICAgICBpZiAoa2V5ID09PSAnRXNjYXBlJykge1xuICAgICAgICBfdGhpcy5jYW5jZWwoKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoX3RoaXMuc3RhdHVzLmN1cnJlbnQpIHtcbiAgICAgICAgY2FzZSAnaWRsZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2JydXNoaW5nJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnTWV0YScgfHwga2V5ID09PSAnQ29udHJvbCcpIHtcbiAgICAgICAgICAgICAgX3RoaXMudXBkYXRlQnJ1c2hTZXNzaW9uKF90aGlzLmdldFBhZ2VQb2ludChpbmZvLnBvaW50KSwgaW5mby5tZXRhS2V5KTtcblxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICd0cmFuc2xhdGluZyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ0VzY2FwZScpIHtcbiAgICAgICAgICAgICAgX3RoaXMuY2FuY2VsU2Vzc2lvbihfdGhpcy5nZXRQYWdlUG9pbnQoaW5mby5wb2ludCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnU2hpZnQnIHx8IGtleSA9PT0gJ0FsdCcpIHtcbiAgICAgICAgICAgICAgX3RoaXMudXBkYXRlVHJhbnNsYXRlU2Vzc2lvbihfdGhpcy5nZXRQYWdlUG9pbnQoaW5mby5wb2ludCksIGluZm8uc2hpZnRLZXksIGluZm8uYWx0S2V5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3RyYW5zZm9ybWluZyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ0VzY2FwZScpIHtcbiAgICAgICAgICAgICAgX3RoaXMuY2FuY2VsU2Vzc2lvbihfdGhpcy5nZXRQYWdlUG9pbnQoaW5mby5wb2ludCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnU2hpZnQnIHx8IGtleSA9PT0gJ0FsdCcpIHtcbiAgICAgICAgICAgICAgX3RoaXMudXBkYXRlVHJhbnNmb3JtU2Vzc2lvbihfdGhpcy5nZXRQYWdlUG9pbnQoaW5mby5wb2ludCksIGluZm8uc2hpZnRLZXksIGluZm8uYWx0S2V5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm9uS2V5VXAgPSBmdW5jdGlvbiAoa2V5LCBpbmZvKSB7XG4gICAgICBzd2l0Y2ggKF90aGlzLnN0YXR1cy5jdXJyZW50KSB7XG4gICAgICAgIGNhc2UgJ2JydXNoaW5nJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnTWV0YScgfHwga2V5ID09PSAnQ29udHJvbCcpIHtcbiAgICAgICAgICAgICAgX3RoaXMudXBkYXRlQnJ1c2hTZXNzaW9uKF90aGlzLmdldFBhZ2VQb2ludChpbmZvLnBvaW50KSwgaW5mby5tZXRhS2V5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3RyYW5zZm9ybWluZyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ1NoaWZ0JyB8fCBrZXkgPT09ICdBbHQnKSB7XG4gICAgICAgICAgICAgIF90aGlzLnVwZGF0ZVRyYW5zZm9ybVNlc3Npb24oX3RoaXMuZ2V0UGFnZVBvaW50KGluZm8ucG9pbnQpLCBpbmZvLnNoaWZ0S2V5LCBpbmZvLmFsdEtleSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICd0cmFuc2xhdGluZyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ1NoaWZ0JyB8fCBrZXkgPT09ICdBbHQnKSB7XG4gICAgICAgICAgICAgIF90aGlzLnVwZGF0ZVRyYW5zZm9ybVNlc3Npb24oX3RoaXMuZ2V0UGFnZVBvaW50KGluZm8ucG9pbnQpLCBpbmZvLnNoaWZ0S2V5LCBpbmZvLmFsdEtleSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5vblBpbmNoU3RhcnQgPSBmdW5jdGlvbiAoaW5mbykge1xuICAgICAgX3RoaXMuc2V0U3RhdHVzKCdwaW5jaGluZycpO1xuICAgIH07XG5cbiAgICB0aGlzLm9uUGluY2hFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5zZXRTdGF0dXMoX3RoaXMuc3RhdHVzLnByZXZpb3VzKTtcbiAgICB9O1xuXG4gICAgdGhpcy5vblBpbmNoID0gZnVuY3Rpb24gKGluZm8sIGUpIHtcbiAgICAgIGlmIChfdGhpcy5zdGF0dXMuY3VycmVudCAhPT0gJ3BpbmNoaW5nJykgcmV0dXJuO1xuXG4gICAgICBfdGhpcy5waW5jaFpvb20oaW5mby5vcmlnaW4sIGluZm8uZGVsdGEsIGluZm8uZGVsdGFbMl0gLyAzNTApO1xuXG4gICAgICBfdGhpcy51cGRhdGVTZXNzaW9uc09uUG9pbnRlck1vdmUoaW5mbywgZSk7XG4gICAgfTtcblxuICAgIHRoaXMub25QYW4gPSBmdW5jdGlvbiAoaW5mbywgZSkge1xuICAgICAgdmFyIGRlbHRhID0gY29yZS5WZWMuZGl2KGluZm8uZGVsdGEsIF90aGlzLmdldFBhZ2VTdGF0ZSgpLmNhbWVyYS56b29tKTtcblxuICAgICAgdmFyIHByZXYgPSBfdGhpcy5nZXRQYWdlU3RhdGUoKS5jYW1lcmEucG9pbnQ7XG5cbiAgICAgIHZhciBuZXh0ID0gY29yZS5WZWMuc3ViKHByZXYsIGRlbHRhKTtcbiAgICAgIGlmIChjb3JlLlZlYy5pc0VxdWFsKG5leHQsIHByZXYpKSByZXR1cm47XG5cbiAgICAgIF90aGlzLnBhbihkZWx0YSk7XG5cbiAgICAgIF90aGlzLnVwZGF0ZVNlc3Npb25zT25Qb2ludGVyTW92ZShpbmZvLCBlKTtcbiAgICB9O1xuXG4gICAgdGhpcy5vblpvb20gPSBmdW5jdGlvbiAoaW5mbywgZSkge1xuICAgICAgX3RoaXMuem9vbShpbmZvLmRlbHRhWzJdIC8gMTAwKTtcblxuICAgICAgX3RoaXMudXBkYXRlU2Vzc2lvbnNPblBvaW50ZXJNb3ZlKGluZm8sIGUpO1xuICAgIH07XG5cbiAgICB0aGlzLm9uUG9pbnRlckRvd24gPSBmdW5jdGlvbiAoaW5mbykge1xuICAgICAgc3dpdGNoIChfdGhpcy5zdGF0dXMuY3VycmVudCkge1xuICAgICAgICBjYXNlICdpZGxlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzd2l0Y2ggKF90aGlzLmFwcFN0YXRlLmFjdGl2ZVRvb2wpIHtcbiAgICAgICAgICAgICAgY2FzZSAnZHJhdyc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdHVzKCdjcmVhdGluZycpO1xuXG4gICAgICAgICAgICAgICAgICBfdGhpcy5jcmVhdGVBY3RpdmVUb29sU2hhcGUoaW5mby5wb2ludCk7XG5cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjYXNlICdyZWN0YW5nbGUnOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXR1cygnY3JlYXRpbmcnKTtcblxuICAgICAgICAgICAgICAgICAgX3RoaXMuY3JlYXRlQWN0aXZlVG9vbFNoYXBlKGluZm8ucG9pbnQpO1xuXG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY2FzZSAnZWxsaXBzZSc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdHVzKCdjcmVhdGluZycpO1xuXG4gICAgICAgICAgICAgICAgICBfdGhpcy5jcmVhdGVBY3RpdmVUb29sU2hhcGUoaW5mby5wb2ludCk7XG5cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMub25Qb2ludGVyTW92ZSA9IGZ1bmN0aW9uIChpbmZvLCBlKSB7XG4gICAgICBfdGhpcy51cGRhdGVTZXNzaW9uc09uUG9pbnRlck1vdmUoaW5mbywgZSk7XG4gICAgfTtcblxuICAgIHRoaXMub25Qb2ludGVyVXAgPSBmdW5jdGlvbiAoaW5mbykge1xuICAgICAgdmFyIGRhdGEgPSBfdGhpcy5nZXRTdGF0ZSgpO1xuXG4gICAgICBzd2l0Y2ggKF90aGlzLnN0YXR1cy5jdXJyZW50KSB7XG4gICAgICAgIGNhc2UgJ3BvaW50aW5nQm91bmRzSGFuZGxlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0dXMoJ2lkbGUnKTtcblxuICAgICAgICAgICAgX3RoaXMucG9pbnRlZEJvdW5kc0hhbmRsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdwb2ludGluZ0JvdW5kcyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKGluZm8udGFyZ2V0ID09PSAnYm91bmRzJykge1xuICAgICAgICAgICAgICAvLyBJZiB3ZSBqdXN0IGNsaWNrZWQgdGhlIHNlbGVjdGluZyBib3VuZHMncyBiYWNrZ3JvdW5kLCBjbGVhciB0aGUgc2VsZWN0aW9uXG4gICAgICAgICAgICAgIF90aGlzLmRlc2VsZWN0QWxsKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEucGFnZVN0YXRlLnNlbGVjdGVkSWRzLmluY2x1ZGVzKGluZm8udGFyZ2V0KSkge1xuICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBob2xkaW5nIHNoaWZ0Li4uXG4gICAgICAgICAgICAgIGlmIChpbmZvLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gVW5sZXNzIHdlIGp1c3Qgc2hpZnQtc2VsZWN0ZWQgdGhlIHNoYXBlLCByZW1vdmUgaXQgZnJvbSB0aGUgc2VsZWN0ZWQgc2hhcGVzXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnBvaW50ZWRJZCAhPT0gaW5mby50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLnNldFNlbGVjdGVkSWRzKGRhdGEucGFnZVN0YXRlLnNlbGVjdGVkSWRzLmZpbHRlcihmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkICE9PSBpbmZvLnRhcmdldDtcbiAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdHVzKCdpZGxlJyk7XG5cbiAgICAgICAgICAgIF90aGlzLnBvaW50ZWRJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdicnVzaGluZyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgX3RoaXMuY29tcGxldGVTZXNzaW9uKCk7XG5cbiAgICAgICAgICAgIGNvcmUuYnJ1c2hVcGRhdGVyLmNsZWFyKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAndHJhbnNsYXRpbmcnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIF90aGlzLmNvbXBsZXRlU2Vzc2lvbihfdGhpcy5nZXRQYWdlUG9pbnQoaW5mby5wb2ludCkpO1xuXG4gICAgICAgICAgICBfdGhpcy5wb2ludGVkSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAndHJhbnNmb3JtaW5nJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBfdGhpcy5jb21wbGV0ZVNlc3Npb24oX3RoaXMuZ2V0UGFnZVBvaW50KGluZm8ucG9pbnQpKTtcblxuICAgICAgICAgICAgX3RoaXMucG9pbnRlZEJvdW5kc0hhbmRsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdjcmVhdGluZyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgX3RoaXMuY29tcGxldGVTZXNzaW9uKF90aGlzLmdldFBhZ2VQb2ludChpbmZvLnBvaW50KSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm9uUG9pbnRDYW52YXMgPSBmdW5jdGlvbiAoaW5mbykge1xuICAgICAgc3dpdGNoIChfdGhpcy5zdGF0dXMuY3VycmVudCkge1xuICAgICAgICBjYXNlICdpZGxlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzd2l0Y2ggKF90aGlzLmFwcFN0YXRlLmFjdGl2ZVRvb2wpIHtcbiAgICAgICAgICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAvLyBVbmxlc3MgdGhlIHVzZXIgaXMgaG9sZGluZyBzaGlmdCBvciBtZXRhLCBjbGVhciB0aGUgY3VycmVudCBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgIGlmICghKGluZm8uc2hpZnRLZXkgfHwgaW5mby5tZXRhS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kZXNlbGVjdEFsbCgpO1xuICAgICAgICAgICAgICAgICAgfSAvLyBTdGFydCBhIGJydXNoIHNlc3Npb25cblxuXG4gICAgICAgICAgICAgICAgICBfdGhpcy5zdGFydEJydXNoU2Vzc2lvbihfdGhpcy5nZXRQYWdlUG9pbnQoaW5mby5wb2ludCkpO1xuXG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm9uRG91YmxlQ2xpY2tDYW52YXMgPSBmdW5jdGlvbiAoKSB7Ly8gVW51c2VkXG4gICAgfTtcblxuICAgIHRoaXMub25SaWdodFBvaW50Q2FudmFzID0gZnVuY3Rpb24gKCkgey8vIFVudXNlZFxuICAgIH07XG5cbiAgICB0aGlzLm9uRHJhZ0NhbnZhcyA9IGZ1bmN0aW9uICgpIHsvLyBVbnVzZWRcbiAgICB9O1xuXG4gICAgdGhpcy5vblJlbGVhc2VDYW52YXMgPSBmdW5jdGlvbiAoKSB7Ly8gVW51c2VkXG4gICAgfTtcblxuICAgIHRoaXMub25Qb2ludFNoYXBlID0gZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgIHZhciBkYXRhID0gX3RoaXMuZ2V0U3RhdGUoKTtcblxuICAgICAgc3dpdGNoIChfdGhpcy5zdGF0dXMuY3VycmVudCkge1xuICAgICAgICBjYXNlICdpZGxlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzd2l0Y2ggKF90aGlzLmFwcFN0YXRlLmFjdGl2ZVRvb2wpIHtcbiAgICAgICAgICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAoaW5mby5tZXRhS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoaWxlIGhvbGRpbmcgY29tbWFuZCBrZXksIGFsbG93IGV2ZW50IHRvIHBhc3MgdGhyb3VnaCB0byBjYW52YXNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoIWRhdGEucGFnZVN0YXRlLnNlbGVjdGVkSWRzLmluY2x1ZGVzKGluZm8udGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIHBvaW50ZWQgSUQgdG8gdGhlIHNoYXBlIHRoYXQgd2FzIGNsaWNrZWQuXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnBvaW50ZWRJZCA9IGluZm8udGFyZ2V0OyAvLyBJZiB0aGUgc2hhcGUgaXMgbm90IHNlbGVjdGVkOyB0aGVuIGlmIHRoZSB1c2VyIGlzIHByZXNzaW5nIHNoaWZ0LFxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIHNoYXBlIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbjsgb3RoZXJ3aXNlLCBzZXQgdGhlIHNoYXBlIGFzXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBvbmx5IHNlbGVjdGVkIHNoYXBlLlxuXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldFNlbGVjdGVkSWRzKFtpbmZvLnRhcmdldF0sIGluZm8uc2hpZnRLZXkpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0dXMoJ3BvaW50aW5nQm91bmRzJyk7XG5cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMub25SZWxlYXNlU2hhcGUgPSBmdW5jdGlvbiAoaW5mbykgey8vIGNvbnN0IGRhdGEgPSB0aGlzLmdldFN0YXRlKClcbiAgICAgIC8vIHN3aXRjaCAodGhpcy5zdGF0dXMuY3VycmVudCkge1xuICAgICAgLy8gICBjYXNlICdwb2ludGluZ0JvdW5kcyc6IHtcbiAgICAgIC8vICAgICBpZiAoaW5mby5tZXRhS2V5KSB7XG4gICAgICAvLyAgICAgICAvLyBXaGlsZSBob2xkaW5nIGNvbW1hbmQga2V5LCBhbGxvdyBldmVudCB0byBwYXNzIHRocm91Z2ggdG8gY2FudmFzXG4gICAgICAvLyAgICAgICByZXR1cm5cbiAgICAgIC8vICAgICB9XG4gICAgICAvLyAgICAgLy8gSWYgdGhlIHNoYXBlIGlzIHNlbGVjdGVkLi4uXG4gICAgICAvLyAgICAgaWYgKFxuICAgICAgLy8gICAgICAgZGF0YS5wYWdlU3RhdGUuc2VsZWN0ZWRJZHMuaW5jbHVkZXMoaW5mby50YXJnZXQpICYmXG4gICAgICAvLyAgICAgICB0aGlzLnBvaW50ZWRJZCAhPT0gaW5mby50YXJnZXQgJiZcbiAgICAgIC8vICAgICAgIGluZm8uc2hpZnRLZXlcbiAgICAgIC8vICAgICApIHtcbiAgICAgIC8vICAgICAgIC8vIElmIHRoZSBzaGFwZSBpcyBub3Qgc2VsZWN0ZWQ7IHRoZW4gaWYgdGhlIHVzZXIgaXMgcHJlc3Npbmcgc2hpZnQsXG4gICAgICAvLyAgICAgICAvLyBhZGQgdGhlIHNoYXBlIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbjsgb3RoZXJ3aXNlLCBzZXQgdGhlIHNoYXBlIGFzXG4gICAgICAvLyAgICAgICAvLyB0aGUgb25seSBzZWxlY3RlZCBzaGFwZS5cbiAgICAgIC8vICAgICAgIHRoaXMuc2V0U2VsZWN0ZWRJZHMoZGF0YS5wYWdlU3RhdGUuc2VsZWN0ZWRJZHMuZmlsdGVyKChpZCkgPT4gaWQgIT09IGluZm8udGFyZ2V0KSlcbiAgICAgIC8vICAgICB9XG4gICAgICAvLyAgICAgdGhpcy5zZXRTdGF0dXMoJ3BvaW50aW5nQm91bmRzJylcbiAgICAgIC8vICAgICBicmVha1xuICAgICAgLy8gICB9XG4gICAgICAvLyB9XG4gICAgfTtcblxuICAgIHRoaXMub25Eb3VibGVDbGlja1NoYXBlID0gZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgIGlmIChfdGhpcy5zZWxlY3RlZElkcy5pbmNsdWRlcyhpbmZvLnRhcmdldCkpIHtcbiAgICAgICAgX3RoaXMuc2V0U2VsZWN0ZWRJZHMoW2luZm8udGFyZ2V0XSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMub25SaWdodFBvaW50U2hhcGUgPSBmdW5jdGlvbiAoKSB7Ly8gVE9ET1xuICAgIH07XG5cbiAgICB0aGlzLm9uRHJhZ1NoYXBlID0gZnVuY3Rpb24gKGluZm8pIHsvLyBVbnVzZWRcbiAgICB9O1xuXG4gICAgdGhpcy5vbkhvdmVyU2hhcGUgPSBmdW5jdGlvbiAoaW5mbykge1xuICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhcHBTdGF0ZTogX2V4dGVuZHMoe30sIGRhdGEuYXBwU3RhdGUsIHtcbiAgICAgICAgICAgIGhvdmVyZWRJZDogaW5mby50YXJnZXRcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMub25VbmhvdmVyU2hhcGUgPSBmdW5jdGlvbiAoaW5mbykge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpcy5nZXRTdGF0ZSgpLmFwcFN0YXRlLmhvdmVyZWRJZCA9PT0gaW5mby50YXJnZXQpIHtcbiAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgYXBwU3RhdGU6IF9leHRlbmRzKHt9LCBkYXRhLmFwcFN0YXRlLCB7XG4gICAgICAgICAgICAgICAgaG92ZXJlZElkOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIDEwKTtcbiAgICB9O1xuXG4gICAgdGhpcy5vblBvaW50Qm91bmRzID0gZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgIF90aGlzLnNldFN0YXR1cygncG9pbnRpbmdCb3VuZHMnKTtcbiAgICB9O1xuXG4gICAgdGhpcy5vbkRvdWJsZUNsaWNrQm91bmRzID0gZnVuY3Rpb24gKCkgey8vIFRPRE9cbiAgICB9O1xuXG4gICAgdGhpcy5vblJpZ2h0UG9pbnRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7Ly8gVE9ET1xuICAgIH07XG5cbiAgICB0aGlzLm9uRHJhZ0JvdW5kcyA9IGZ1bmN0aW9uIChpbmZvKSB7Ly8gVW51c2VkXG4gICAgfTtcblxuICAgIHRoaXMub25Ib3ZlckJvdW5kcyA9IGZ1bmN0aW9uICgpIHsvLyBUT0RPXG4gICAgfTtcblxuICAgIHRoaXMub25VbmhvdmVyQm91bmRzID0gZnVuY3Rpb24gKCkgey8vIFRPRE9cbiAgICB9O1xuXG4gICAgdGhpcy5vblJlbGVhc2VCb3VuZHMgPSBmdW5jdGlvbiAoaW5mbykge1xuICAgICAgc3dpdGNoIChfdGhpcy5zdGF0dXMuY3VycmVudCkge1xuICAgICAgICBjYXNlICd0cmFuc2xhdGluZyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgX3RoaXMuY29tcGxldGVTZXNzaW9uKF90aGlzLmdldFBhZ2VQb2ludChpbmZvLnBvaW50KSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdicnVzaGluZyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgX3RoaXMuY29tcGxldGVTZXNzaW9uKCk7XG5cbiAgICAgICAgICAgIGNvcmUuYnJ1c2hVcGRhdGVyLmNsZWFyKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMub25Qb2ludEJvdW5kc0hhbmRsZSA9IGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICBfdGhpcy5wb2ludGVkQm91bmRzSGFuZGxlID0gaW5mby50YXJnZXQ7XG5cbiAgICAgIF90aGlzLnNldFN0YXR1cygncG9pbnRpbmdCb3VuZHNIYW5kbGUnKTtcbiAgICB9O1xuXG4gICAgdGhpcy5vbkRvdWJsZUNsaWNrQm91bmRzSGFuZGxlID0gZnVuY3Rpb24gKCkgey8vIFRPRE9cbiAgICB9O1xuXG4gICAgdGhpcy5vblJpZ2h0UG9pbnRCb3VuZHNIYW5kbGUgPSBmdW5jdGlvbiAoKSB7Ly8gVE9ET1xuICAgIH07XG5cbiAgICB0aGlzLm9uRHJhZ0JvdW5kc0hhbmRsZSA9IGZ1bmN0aW9uICgpIHsvLyBVbnVzZWRcbiAgICB9O1xuXG4gICAgdGhpcy5vbkhvdmVyQm91bmRzSGFuZGxlID0gZnVuY3Rpb24gKCkgey8vIFRPRE9cbiAgICB9O1xuXG4gICAgdGhpcy5vblVuaG92ZXJCb3VuZHNIYW5kbGUgPSBmdW5jdGlvbiAoKSB7Ly8gVE9ET1xuICAgIH07XG5cbiAgICB0aGlzLm9uUmVsZWFzZUJvdW5kc0hhbmRsZSA9IGZ1bmN0aW9uICgpIHsvLyBUT0RPXG4gICAgfTtcblxuICAgIHRoaXMub25Qb2ludEhhbmRsZSA9IGZ1bmN0aW9uICgpIHsvLyBUT0RPXG4gICAgfTtcblxuICAgIHRoaXMub25Eb3VibGVDbGlja0hhbmRsZSA9IGZ1bmN0aW9uICgpIHsvLyBUT0RPXG4gICAgfTtcblxuICAgIHRoaXMub25SaWdodFBvaW50SGFuZGxlID0gZnVuY3Rpb24gKCkgey8vIFRPRE9cbiAgICB9O1xuXG4gICAgdGhpcy5vbkRyYWdIYW5kbGUgPSBmdW5jdGlvbiAoKSB7Ly8gVE9ET1xuICAgIH07XG5cbiAgICB0aGlzLm9uSG92ZXJIYW5kbGUgPSBmdW5jdGlvbiAoKSB7Ly8gVE9ET1xuICAgIH07XG5cbiAgICB0aGlzLm9uVW5ob3ZlckhhbmRsZSA9IGZ1bmN0aW9uICgpIHsvLyBUT0RPXG4gICAgfTtcblxuICAgIHRoaXMub25SZWxlYXNlSGFuZGxlID0gZnVuY3Rpb24gKCkgey8vIFRPRE9cbiAgICB9O1xuXG4gICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChpZHMpIHtcbiAgICAgIHZhciBhcHBTdGF0ZSA9IF90aGlzLmdldEFwcFN0YXRlKCk7XG5cbiAgICAgIGlmIChhcHBTdGF0ZS5pc0VtcHR5Q2FudmFzICYmIGlkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFwcFN0YXRlOiBfZXh0ZW5kcyh7fSwgZGF0YS5hcHBTdGF0ZSwge1xuICAgICAgICAgICAgICBpc0VtcHR5Q2FudmFzOiBmYWxzZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoIWFwcFN0YXRlLmlzRW1wdHlDYW52YXMgJiYgaWRzLmxlbmd0aCA8PSAwKSB7XG4gICAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFwcFN0YXRlOiBfZXh0ZW5kcyh7fSwgZGF0YS5hcHBTdGF0ZSwge1xuICAgICAgICAgICAgICBpc0VtcHR5Q2FudmFzOiB0cnVlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHsvLyBUT0RPXG4gICAgfTtcblxuICAgIHRoaXMub25CbHVyRWRpdGluZ1NoYXBlID0gZnVuY3Rpb24gKCkgey8vIFRPRE9cbiAgICB9O1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFRMRHJhd1N0YXRlLnByb3RvdHlwZTtcblxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0gU3RhdHVzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuICBfcHJvdG8uc2V0U3RhdHVzID0gZnVuY3Rpb24gc2V0U3RhdHVzKHN0YXR1cykge1xuICAgIHRoaXMuc3RhdHVzLnByZXZpb3VzID0gdGhpcy5zdGF0dXMuY3VycmVudDtcbiAgICB0aGlzLnN0YXR1cy5jdXJyZW50ID0gc3RhdHVzO1xuICAgIHJldHVybiB0aGlzOyAvLyBjb25zb2xlLmxvZyh0aGlzLnN0YXR1cy5wcmV2aW91cywgJyAtPiAnLCB0aGlzLnN0YXR1cy5jdXJyZW50KVxuICB9XG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tIEFwcCBTdGF0ZSAtLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gIDtcblxuICBfcHJvdG8ucGluY2hab29tID0gZnVuY3Rpb24gcGluY2hab29tKHBvaW50LCBkZWx0YSwgem9vbURlbHRhKSB7XG4gICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdmFyIGNhbWVyYSA9IGRhdGEucGFnZVN0YXRlLmNhbWVyYTtcbiAgICAgIHZhciBuZXh0UG9pbnQgPSBjb3JlLlZlYy5hZGQoY2FtZXJhLnBvaW50LCBjb3JlLlZlYy5kaXYoZGVsdGEsIGNhbWVyYS56b29tKSk7XG4gICAgICB2YXIgbmV4dFpvb20gPSBUTERSLmdldENhbWVyYVpvb20oY2FtZXJhLnpvb20gLSB6b29tRGVsdGEgKiBjYW1lcmEuem9vbSk7XG4gICAgICB2YXIgcDAgPSBjb3JlLlZlYy5zdWIoY29yZS5WZWMuZGl2KHBvaW50LCBjYW1lcmEuem9vbSksIG5leHRQb2ludCk7XG4gICAgICB2YXIgcDEgPSBjb3JlLlZlYy5zdWIoY29yZS5WZWMuZGl2KHBvaW50LCBuZXh0Wm9vbSksIG5leHRQb2ludCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYWdlU3RhdGU6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2VTdGF0ZSwge1xuICAgICAgICAgIGNhbWVyYTogX2V4dGVuZHMoe30sIGRhdGEucGFnZVN0YXRlLmNhbWVyYSwge1xuICAgICAgICAgICAgcG9pbnQ6IGNvcmUuVmVjLmFkZChuZXh0UG9pbnQsIGNvcmUuVmVjLnN1YihwMSwgcDApKSxcbiAgICAgICAgICAgIHpvb206IG5leHRab29tXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnpvb21UbyA9IGZ1bmN0aW9uIHpvb21UbyhuZXh0KSB7XG4gICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdmFyIF9UTERSJGdldEN1cnJlbnRDYW1lciA9IFRMRFIuZ2V0Q3VycmVudENhbWVyYShkYXRhKSxcbiAgICAgICAgICB6b29tID0gX1RMRFIkZ2V0Q3VycmVudENhbWVyLnpvb20sXG4gICAgICAgICAgcG9pbnQgPSBfVExEUiRnZXRDdXJyZW50Q2FtZXIucG9pbnQ7XG5cbiAgICAgIHZhciBjZW50ZXIgPSBbd2luZG93LmlubmVyV2lkdGggLyAyLCB3aW5kb3cuaW5uZXJIZWlnaHQgLyAyXTtcbiAgICAgIHZhciBwMCA9IGNvcmUuVmVjLnN1Yihjb3JlLlZlYy5kaXYoY2VudGVyLCB6b29tKSwgcG9pbnQpO1xuICAgICAgdmFyIHAxID0gY29yZS5WZWMuc3ViKGNvcmUuVmVjLmRpdihjZW50ZXIsIG5leHQpLCBwb2ludCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYWdlU3RhdGU6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2VTdGF0ZSwge1xuICAgICAgICAgIGNhbWVyYTogX2V4dGVuZHMoe30sIGRhdGEucGFnZVN0YXRlLmNhbWVyYSwge1xuICAgICAgICAgICAgcG9pbnQ6IGNvcmUuVmVjLmFkZChwb2ludCwgY29yZS5WZWMuc3ViKHAxLCBwMCkpLFxuICAgICAgICAgICAgem9vbTogbmV4dFxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by56b29tID0gZnVuY3Rpb24gem9vbShkZWx0YSkge1xuICAgIHZhciB6b29tID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLnBhZ2VTdGF0ZS5jYW1lcmEuem9vbTtcbiAgICB2YXIgbmV4dFpvb20gPSBUTERSLmdldENhbWVyYVpvb20oem9vbSAtIGRlbHRhICogem9vbSk7XG4gICAgdGhpcy56b29tVG8obmV4dFpvb20pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5wYW4gPSBmdW5jdGlvbiBwYW4oZGVsdGEpIHtcbiAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB2YXIgX1RMRFIkZ2V0Q3VycmVudENhbWVyMiA9IFRMRFIuZ2V0Q3VycmVudENhbWVyYShkYXRhKSxcbiAgICAgICAgICBwb2ludCA9IF9UTERSJGdldEN1cnJlbnRDYW1lcjIucG9pbnQ7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhZ2VTdGF0ZTogX2V4dGVuZHMoe30sIGRhdGEucGFnZVN0YXRlLCB7XG4gICAgICAgICAgY2FtZXJhOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlU3RhdGUuY2FtZXJhLCB7XG4gICAgICAgICAgICBwb2ludDogY29yZS5WZWMuc3ViKHBvaW50LCBkZWx0YSlcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tIERvY3VtZW50IC0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuICA7XG5cbiAgX3Byb3RvLnNldEN1cnJlbnRQYWdlSWQgPSBmdW5jdGlvbiBzZXRDdXJyZW50UGFnZUlkKHBhZ2VJZCkge1xuICAgIGlmIChwYWdlSWQgPT09IHRoaXMuY3VycmVudFBhZ2VJZCkgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy5jdXJyZW50UGFnZUlkID0gcGFnZUlkO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgcGFnZTogdGhpcy5wYWdlc1twYWdlSWRdLFxuICAgICAgcGFnZVN0YXRlOiB0aGlzLnBhZ2VTdGF0ZXNbcGFnZUlkXVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tIFNlc3Npb25zIC0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gIDtcblxuICBfcHJvdG8uc3RhcnRTZXNzaW9uID0gZnVuY3Rpb24gc3RhcnRTZXNzaW9uKHNlc3Npb24pIHtcbiAgICB2YXIgX3RoaXMkX29uQ2hhbmdlO1xuXG4gICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zID4gMSA/IF9sZW4zIC0gMSA6IDApLCBfa2V5MyA9IDE7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgIGFyZ3NbX2tleTMgLSAxXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgfVxuXG4gICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICByZXR1cm4gc2Vzc2lvbi5zdGFydC5hcHBseShzZXNzaW9uLCBbZGF0YV0uY29uY2F0KGFyZ3MpKTtcbiAgICB9KTtcbiAgICAoX3RoaXMkX29uQ2hhbmdlID0gdGhpcy5fb25DaGFuZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRfb25DaGFuZ2UuY2FsbCh0aGlzLCB0aGlzLCBcInNlc3Npb246c3RhcnRfXCIgKyBzZXNzaW9uLmlkKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8udXBkYXRlU2Vzc2lvbiA9IGZ1bmN0aW9uIHVwZGF0ZVNlc3Npb24oKSB7XG4gICAgdmFyIF90aGlzJF9vbkNoYW5nZTI7XG5cbiAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgIGFyZ3NbX2tleTRdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICB9XG5cbiAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICBpZiAoIXNlc3Npb24pIHJldHVybjtcbiAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICByZXR1cm4gc2Vzc2lvbi51cGRhdGUuYXBwbHkoc2Vzc2lvbiwgW2RhdGFdLmNvbmNhdChhcmdzKSk7XG4gICAgfSk7XG4gICAgKF90aGlzJF9vbkNoYW5nZTIgPSB0aGlzLl9vbkNoYW5nZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJF9vbkNoYW5nZTIuY2FsbCh0aGlzLCB0aGlzLCBcInNlc3Npb246dXBkYXRlOlwiICsgc2Vzc2lvbi5pZCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLmNhbmNlbFNlc3Npb24gPSBmdW5jdGlvbiBjYW5jZWxTZXNzaW9uKCkge1xuICAgIHZhciBfdGhpcyRfb25DaGFuZ2UzO1xuXG4gICAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41KSwgX2tleTUgPSAwOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgICBhcmdzW19rZXk1XSA9IGFyZ3VtZW50c1tfa2V5NV07XG4gICAgfVxuXG4gICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG4gICAgaWYgKCFzZXNzaW9uKSByZXR1cm47XG4gICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgcmV0dXJuIHNlc3Npb24uY2FuY2VsLmFwcGx5KHNlc3Npb24sIFtkYXRhXS5jb25jYXQoYXJncykpO1xuICAgIH0pO1xuICAgIHRoaXMuc2V0U3RhdHVzKCdpZGxlJyk7XG4gICAgdGhpcy5zZXNzaW9uID0gdW5kZWZpbmVkO1xuICAgIChfdGhpcyRfb25DaGFuZ2UzID0gdGhpcy5fb25DaGFuZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRfb25DaGFuZ2UzLmNhbGwodGhpcywgdGhpcywgXCJzZXNzaW9uOmNhbmNlbDpcIiArIHNlc3Npb24uaWQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5jb21wbGV0ZVNlc3Npb24gPSBmdW5jdGlvbiBjb21wbGV0ZVNlc3Npb24oKSB7XG4gICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG4gICAgaWYgKCFzZXNzaW9uKSByZXR1cm47XG4gICAgdGhpcy5zZXRTdGF0dXMoJ2lkbGUnKTtcblxuICAgIGZvciAodmFyIF9sZW42ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNiksIF9rZXk2ID0gMDsgX2tleTYgPCBfbGVuNjsgX2tleTYrKykge1xuICAgICAgYXJnc1tfa2V5Nl0gPSBhcmd1bWVudHNbX2tleTZdO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBzZXNzaW9uLmNvbXBsZXRlLmFwcGx5KHNlc3Npb24sIFt0aGlzLnN0b3JlLmdldFN0YXRlKCldLmNvbmNhdChhcmdzKSk7XG5cbiAgICBpZiAoJ2FmdGVyJyBpbiByZXN1bHQpIHtcbiAgICAgIHRoaXNbXCJkb1wiXShyZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3RoaXMkX29uQ2hhbmdlNDtcblxuICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gY29yZS5VdGlscy5kZWVwTWVyZ2UoZGF0YSwgcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgICAgKF90aGlzJF9vbkNoYW5nZTQgPSB0aGlzLl9vbkNoYW5nZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJF9vbkNoYW5nZTQuY2FsbCh0aGlzLCB0aGlzLCBcInNlc3Npb246Y29tcGxldGU6XCIgKyBzZXNzaW9uLmlkKTtcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMkYXBwU3RhdGUgPSB0aGlzLmFwcFN0YXRlLFxuICAgICAgICBpc1Rvb2xMb2NrZWQgPSBfdGhpcyRhcHBTdGF0ZS5pc1Rvb2xMb2NrZWQsXG4gICAgICAgIGFjdGl2ZVRvb2wgPSBfdGhpcyRhcHBTdGF0ZS5hY3RpdmVUb29sO1xuXG4gICAgaWYgKCFpc1Rvb2xMb2NrZWQgJiYgYWN0aXZlVG9vbCAhPT0gJ2RyYXcnKSB7XG4gICAgICB0aGlzLnNlbGVjdFRvb2woJ3NlbGVjdCcpO1xuICAgIH1cblxuICAgIHRoaXMuc2Vzc2lvbiA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLSBDb21tYW5kcyAtLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuICA7XG5cbiAgX3Byb3RvW1wiZG9cIl0gPSBmdW5jdGlvbiBfZG8oY29tbWFuZCkge1xuICAgIHZhciBfdGhpcyRfb25DaGFuZ2U1O1xuXG4gICAgdmFyIGhpc3RvcnkgPSB0aGlzLmhpc3Rvcnk7XG5cbiAgICBpZiAoaGlzdG9yeS5wb2ludGVyICE9PSBoaXN0b3J5LnN0YWNrLmxlbmd0aCAtIDEpIHtcbiAgICAgIGhpc3Rvcnkuc3RhY2sgPSBoaXN0b3J5LnN0YWNrLnNsaWNlKDAsIGhpc3RvcnkucG9pbnRlciArIDEpO1xuICAgIH1cblxuICAgIGhpc3Rvcnkuc3RhY2sucHVzaChjb21tYW5kKTtcbiAgICBoaXN0b3J5LnBvaW50ZXIgPSBoaXN0b3J5LnN0YWNrLmxlbmd0aCAtIDE7XG4gICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgcmV0dXJuIGNvcmUuVXRpbHMuZGVlcE1lcmdlKGRhdGEsIGhpc3Rvcnkuc3RhY2tbaGlzdG9yeS5wb2ludGVyXS5hZnRlcik7XG4gICAgfSk7XG4gICAgKF90aGlzJF9vbkNoYW5nZTUgPSB0aGlzLl9vbkNoYW5nZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJF9vbkNoYW5nZTUuY2FsbCh0aGlzLCB0aGlzLCBcImNvbW1hbmQ6XCIgKyBjb21tYW5kLmlkKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLSBTZWxlY3Rpb24gLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuICBfcHJvdG8uc2V0U2VsZWN0ZWRJZHMgPSBmdW5jdGlvbiBzZXRTZWxlY3RlZElkcyhpZHMsIHB1c2gpIHtcbiAgICBpZiAocHVzaCA9PT0gdm9pZCAwKSB7XG4gICAgICBwdXNoID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFnZVN0YXRlOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlU3RhdGUsIHtcbiAgICAgICAgICBzZWxlY3RlZElkczogcHVzaCA/IFtdLmNvbmNhdChkYXRhLnBhZ2VTdGF0ZS5zZWxlY3RlZElkcywgaWRzKSA6IFtdLmNvbmNhdChpZHMpXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5jcmVhdGVBY3RpdmVUb29sU2hhcGUgPSBmdW5jdGlvbiBjcmVhdGVBY3RpdmVUb29sU2hhcGUocG9pbnQpIHtcbiAgICB2YXIgaWQgPSBjb3JlLlV0aWxzLnVuaXF1ZUlkKCk7XG4gICAgdmFyIHBhZ2VQb2ludCA9IGNvcmUuVmVjLnJvdW5kKHRoaXMuZ2V0UGFnZVBvaW50KHBvaW50KSk7XG4gICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdmFyIF9leHRlbmRzMjtcblxuICAgICAgdmFyIF9kYXRhJGFwcFN0YXRlID0gZGF0YS5hcHBTdGF0ZSxcbiAgICAgICAgICBhY3RpdmVUb29sID0gX2RhdGEkYXBwU3RhdGUuYWN0aXZlVG9vbCxcbiAgICAgICAgICBhY3RpdmVUb29sVHlwZSA9IF9kYXRhJGFwcFN0YXRlLmFjdGl2ZVRvb2xUeXBlO1xuICAgICAgaWYgKGFjdGl2ZVRvb2wgPT09ICdzZWxlY3QnKSByZXR1cm4gZGF0YTtcbiAgICAgIGlmICghYWN0aXZlVG9vbFR5cGUpIHRocm93IEVycm9yO1xuICAgICAgdmFyIHV0aWxzID0gVExEUi5nZXRTaGFwZVV0aWxzKHtcbiAgICAgICAgdHlwZTogYWN0aXZlVG9vbFxuICAgICAgfSk7XG4gICAgICB2YXIgc2hhcGVzID0gT2JqZWN0LnZhbHVlcyhkYXRhLnBhZ2Uuc2hhcGVzKTtcbiAgICAgIHZhciBjaGlsZEluZGV4ID0gc2hhcGVzLmxlbmd0aCA9PT0gMCA/IDEgOiBzaGFwZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYi5jaGlsZEluZGV4IC0gYS5jaGlsZEluZGV4O1xuICAgICAgfSlbMF0uY2hpbGRJbmRleCArIDE7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYWdlOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlLCB7XG4gICAgICAgICAgc2hhcGVzOiBfZXh0ZW5kcyh7fSwgZGF0YS5wYWdlLnNoYXBlcywgKF9leHRlbmRzMiA9IHt9LCBfZXh0ZW5kczJbaWRdID0gdXRpbHMuY3JlYXRlKHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBkYXRhLnBhZ2UuaWQsXG4gICAgICAgICAgICBjaGlsZEluZGV4OiBjaGlsZEluZGV4LFxuICAgICAgICAgICAgcG9pbnQ6IHBhZ2VQb2ludCxcbiAgICAgICAgICAgIHN0eWxlOiBfZXh0ZW5kcyh7fSwgZGF0YS5hcHBTdGF0ZS5jdXJyZW50U3R5bGUpXG4gICAgICAgICAgfSksIF9leHRlbmRzMikpXG4gICAgICAgIH0pLFxuICAgICAgICBwYWdlU3RhdGU6IF9leHRlbmRzKHt9LCBkYXRhLnBhZ2VTdGF0ZSwge1xuICAgICAgICAgIHNlbGVjdGVkSWRzOiBbaWRdXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgdmFyIF90aGlzJGdldEFwcFN0YXRlID0gdGhpcy5nZXRBcHBTdGF0ZSgpLFxuICAgICAgICBhY3RpdmVUb29sID0gX3RoaXMkZ2V0QXBwU3RhdGUuYWN0aXZlVG9vbCxcbiAgICAgICAgYWN0aXZlVG9vbFR5cGUgPSBfdGhpcyRnZXRBcHBTdGF0ZS5hY3RpdmVUb29sVHlwZTtcblxuICAgIHN3aXRjaCAoYWN0aXZlVG9vbFR5cGUpIHtcbiAgICAgIGNhc2UgJ2RyYXcnOlxuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5zdGFydERyYXdTZXNzaW9uKGlkLCBwYWdlUG9pbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2JvdW5kcyc6XG4gICAgICAgIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0VHJhbnNmb3JtU2Vzc2lvbihwYWdlUG9pbnQsIGNvcmUuVExCb3VuZHNDb3JuZXIuQm90dG9tUmlnaHQsIFwiY3JlYXRlX1wiICsgYWN0aXZlVG9vbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEV2ZW50cyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgO1xuXG4gIF9jcmVhdGVDbGFzcyhUTERyYXdTdGF0ZSwgW3tcbiAgICBrZXk6IFwiZG9jdW1lbnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiB0aGlzLmN1cnJlbnREb2N1bWVudElkLFxuICAgICAgICBwYWdlczogdGhpcy5wYWdlcyxcbiAgICAgICAgcGFnZVN0YXRlczogdGhpcy5wYWdlU3RhdGVzXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkYXRhXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZWxlY3RlZElkc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFnZVN0YXRlLnNlbGVjdGVkSWRzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYWdlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYWdlc1t0aGlzLmN1cnJlbnRQYWdlSWRdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYWdlU3RhdGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhZ2VTdGF0ZXNbdGhpcy5jdXJyZW50UGFnZUlkXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwU3RhdGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGEuYXBwU3RhdGU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRMRHJhd1N0YXRlO1xufSgpO1xuXG52YXIgaGlkZUJvdW5kc1NlbGVjdG9yID0gZnVuY3Rpb24gaGlkZUJvdW5kc1NlbGVjdG9yKHMpIHtcbiAgcmV0dXJuIHMuYXBwU3RhdGUuYWN0aXZlVG9vbCAhPT0gJ3NlbGVjdCc7XG59O1xuXG52YXIgcGFnZVNlbGVjdG9yID0gZnVuY3Rpb24gcGFnZVNlbGVjdG9yKHMpIHtcbiAgcmV0dXJuIHMucGFnZTtcbn07XG5cbnZhciBwYWdlU3RhdGVTZWxlY3RvciA9IGZ1bmN0aW9uIHBhZ2VTdGF0ZVNlbGVjdG9yKHMpIHtcbiAgcmV0dXJuIHMucGFnZVN0YXRlO1xufTtcblxuZnVuY3Rpb24gVExEcmF3KF9yZWYpIHtcbiAgdmFyIGRvY3VtZW50ID0gX3JlZi5kb2N1bWVudCxcbiAgICAgIGN1cnJlbnRQYWdlSWQgPSBfcmVmLmN1cnJlbnRQYWdlSWQsXG4gICAgICBvbk1vdW50ID0gX3JlZi5vbk1vdW50LFxuICAgICAgX29uQ2hhbmdlID0gX3JlZi5vbkNoYW5nZTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgVExEcmF3U3RhdGUoKTtcbiAgfSksXG4gICAgICB0bHN0YXRlID0gX1JlYWN0JHVzZVN0YXRlWzBdO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUyID0gUmVhY3QudXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0bHN0YXRlOiB0bHN0YXRlLFxuICAgICAgdXNlQXBwU3RhdGU6IHRsc3RhdGUuc3RvcmVcbiAgICB9O1xuICB9KSxcbiAgICAgIGNvbnRleHQgPSBfUmVhY3QkdXNlU3RhdGUyWzBdO1xuXG4gIHVzZUtleWJvYXJkU2hvcnRjdXRzKHRsc3RhdGUpO1xuICB2YXIgaGlkZUJvdW5kcyA9IGNvbnRleHQudXNlQXBwU3RhdGUoaGlkZUJvdW5kc1NlbGVjdG9yKTtcbiAgdmFyIHBhZ2UgPSBjb250ZXh0LnVzZUFwcFN0YXRlKHBhZ2VTZWxlY3Rvcik7XG4gIHZhciBwYWdlU3RhdGUgPSBjb250ZXh0LnVzZUFwcFN0YXRlKHBhZ2VTdGF0ZVNlbGVjdG9yKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWRvY3VtZW50KSByZXR1cm47XG4gICAgdGxzdGF0ZS5sb2FkRG9jdW1lbnQoZG9jdW1lbnQsIF9vbkNoYW5nZSk7XG4gIH0sIFtkb2N1bWVudCwgdGxzdGF0ZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICghY3VycmVudFBhZ2VJZCkgcmV0dXJuO1xuICAgIHRsc3RhdGUuc2V0Q3VycmVudFBhZ2VJZChjdXJyZW50UGFnZUlkKTtcbiAgfSwgW2N1cnJlbnRQYWdlSWQsIHRsc3RhdGVdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBvbk1vdW50ID09IG51bGwgPyB2b2lkIDAgOiBvbk1vdW50KHRsc3RhdGUpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtdKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVExEcmF3Q29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQocmVhY3RJZC5JZFByb3ZpZGVyLCBudWxsLCBSZWFjdC5jcmVhdGVFbGVtZW50KExheW91dCwgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0TWVudSwgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChjb3JlLlJlbmRlcmVyLCB7XG4gICAgcGFnZTogcGFnZSxcbiAgICBwYWdlU3RhdGU6IHBhZ2VTdGF0ZSxcbiAgICBzaGFwZVV0aWxzOiB0bGRyYXdTaGFwZVV0aWxzLFxuICAgIGhpZGVCb3VuZHM6IGhpZGVCb3VuZHMsXG4gICAgb25QaW5jaFN0YXJ0OiB0bHN0YXRlLm9uUGluY2hTdGFydCxcbiAgICBvblBpbmNoRW5kOiB0bHN0YXRlLm9uUGluY2hFbmQsXG4gICAgb25QaW5jaDogdGxzdGF0ZS5vblBpbmNoLFxuICAgIG9uUGFuOiB0bHN0YXRlLm9uUGFuLFxuICAgIG9uWm9vbTogdGxzdGF0ZS5vblpvb20sXG4gICAgb25Qb2ludGVyRG93bjogdGxzdGF0ZS5vblBvaW50ZXJEb3duLFxuICAgIG9uUG9pbnRlck1vdmU6IHRsc3RhdGUub25Qb2ludGVyTW92ZSxcbiAgICBvblBvaW50ZXJVcDogdGxzdGF0ZS5vblBvaW50ZXJVcCxcbiAgICBvblBvaW50Q2FudmFzOiB0bHN0YXRlLm9uUG9pbnRDYW52YXMsXG4gICAgb25Eb3VibGVDbGlja0NhbnZhczogdGxzdGF0ZS5vbkRvdWJsZUNsaWNrQ2FudmFzLFxuICAgIG9uUmlnaHRQb2ludENhbnZhczogdGxzdGF0ZS5vblJpZ2h0UG9pbnRDYW52YXMsXG4gICAgb25EcmFnQ2FudmFzOiB0bHN0YXRlLm9uRHJhZ0NhbnZhcyxcbiAgICBvblJlbGVhc2VDYW52YXM6IHRsc3RhdGUub25SZWxlYXNlQ2FudmFzLFxuICAgIG9uUG9pbnRTaGFwZTogdGxzdGF0ZS5vblBvaW50U2hhcGUsXG4gICAgb25Eb3VibGVDbGlja1NoYXBlOiB0bHN0YXRlLm9uRG91YmxlQ2xpY2tTaGFwZSxcbiAgICBvblJpZ2h0UG9pbnRTaGFwZTogdGxzdGF0ZS5vblJpZ2h0UG9pbnRTaGFwZSxcbiAgICBvbkRyYWdTaGFwZTogdGxzdGF0ZS5vbkRyYWdTaGFwZSxcbiAgICBvbkhvdmVyU2hhcGU6IHRsc3RhdGUub25Ib3ZlclNoYXBlLFxuICAgIG9uVW5ob3ZlclNoYXBlOiB0bHN0YXRlLm9uVW5ob3ZlclNoYXBlLFxuICAgIG9uUmVsZWFzZVNoYXBlOiB0bHN0YXRlLm9uUmVsZWFzZVNoYXBlLFxuICAgIG9uUG9pbnRCb3VuZHM6IHRsc3RhdGUub25Qb2ludEJvdW5kcyxcbiAgICBvbkRvdWJsZUNsaWNrQm91bmRzOiB0bHN0YXRlLm9uRG91YmxlQ2xpY2tCb3VuZHMsXG4gICAgb25SaWdodFBvaW50Qm91bmRzOiB0bHN0YXRlLm9uUmlnaHRQb2ludEJvdW5kcyxcbiAgICBvbkRyYWdCb3VuZHM6IHRsc3RhdGUub25EcmFnQm91bmRzLFxuICAgIG9uSG92ZXJCb3VuZHM6IHRsc3RhdGUub25Ib3ZlckJvdW5kcyxcbiAgICBvblVuaG92ZXJCb3VuZHM6IHRsc3RhdGUub25VbmhvdmVyQm91bmRzLFxuICAgIG9uUmVsZWFzZUJvdW5kczogdGxzdGF0ZS5vblJlbGVhc2VCb3VuZHMsXG4gICAgb25Qb2ludEJvdW5kc0hhbmRsZTogdGxzdGF0ZS5vblBvaW50Qm91bmRzSGFuZGxlLFxuICAgIG9uRG91YmxlQ2xpY2tCb3VuZHNIYW5kbGU6IHRsc3RhdGUub25Eb3VibGVDbGlja0JvdW5kc0hhbmRsZSxcbiAgICBvblJpZ2h0UG9pbnRCb3VuZHNIYW5kbGU6IHRsc3RhdGUub25SaWdodFBvaW50Qm91bmRzSGFuZGxlLFxuICAgIG9uRHJhZ0JvdW5kc0hhbmRsZTogdGxzdGF0ZS5vbkRyYWdCb3VuZHNIYW5kbGUsXG4gICAgb25Ib3ZlckJvdW5kc0hhbmRsZTogdGxzdGF0ZS5vbkhvdmVyQm91bmRzSGFuZGxlLFxuICAgIG9uVW5ob3ZlckJvdW5kc0hhbmRsZTogdGxzdGF0ZS5vblVuaG92ZXJCb3VuZHNIYW5kbGUsXG4gICAgb25SZWxlYXNlQm91bmRzSGFuZGxlOiB0bHN0YXRlLm9uUmVsZWFzZUJvdW5kc0hhbmRsZSxcbiAgICBvblBvaW50SGFuZGxlOiB0bHN0YXRlLm9uUG9pbnRIYW5kbGUsXG4gICAgb25Eb3VibGVDbGlja0hhbmRsZTogdGxzdGF0ZS5vbkRvdWJsZUNsaWNrSGFuZGxlLFxuICAgIG9uUmlnaHRQb2ludEhhbmRsZTogdGxzdGF0ZS5vblJpZ2h0UG9pbnRIYW5kbGUsXG4gICAgb25EcmFnSGFuZGxlOiB0bHN0YXRlLm9uRHJhZ0hhbmRsZSxcbiAgICBvbkhvdmVySGFuZGxlOiB0bHN0YXRlLm9uSG92ZXJIYW5kbGUsXG4gICAgb25VbmhvdmVySGFuZGxlOiB0bHN0YXRlLm9uVW5ob3ZlckhhbmRsZSxcbiAgICBvblJlbGVhc2VIYW5kbGU6IHRsc3RhdGUub25SZWxlYXNlSGFuZGxlLFxuICAgIG9uQ2hhbmdlOiB0bHN0YXRlLm9uQ2hhbmdlLFxuICAgIG9uRXJyb3I6IHRsc3RhdGUub25FcnJvcixcbiAgICBvbkJsdXJFZGl0aW5nU2hhcGU6IHRsc3RhdGUub25CbHVyRWRpdGluZ1NoYXBlXG4gIH0pKSwgUmVhY3QuY3JlYXRlRWxlbWVudChTcGFjZXIsIG51bGwpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFN0eWxlUGFuZWwsIG51bGwpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFRvb2xzUGFuZWwsIG51bGwpKSkpO1xufVxudmFyIFNwYWNlciA9IC8qI19fUFVSRV9fKi9zdHlsZWQoJ2RpdicsIHtcbiAgZmxleEdyb3c6IDJcbn0pOyAvLyBjb25zdCBNZW51QnV0dG9ucyA9IHN0eWxlZCgnZGl2Jywge1xuLy8gICBkaXNwbGF5OiAnZmxleCcsXG4vLyAgIGdhcDogOCxcbi8vIH0pXG5cbnZhciBMYXlvdXQgPSAvKiNfX1BVUkVfXyovc3R5bGVkKCdtYWluJywge1xuICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICB0b3A6IDAsXG4gIGxlZnQ6IDAsXG4gIGJvdHRvbTogMCxcbiAgcmlnaHQ6IDAsXG4gIGhlaWdodDogJzEwMCUnLFxuICB3aWR0aDogJzEwMCUnLFxuICBwYWRkaW5nOiAnOHB4IDhweCAwIDhweCcsXG4gIHpJbmRleDogMjAwLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIGFsaWduSXRlbXM6ICdmbGV4LXN0YXJ0JyxcbiAganVzdGlmeUNvbnRlbnQ6ICdmbGV4LXN0YXJ0JyxcbiAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gIG91dGxpbmU6ICdub25lJyxcbiAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAnJiA+IConOiB7XG4gICAgcG9pbnRlckV2ZW50czogJ2FsbCdcbiAgfSxcbiAgJyYgLnRsLWNvbnRhaW5lcic6IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMFxuICB9XG59KTtcblxuZXhwb3J0cy5UTERyYXcgPSBUTERyYXc7XG5leHBvcnRzLlRMRHJhd1NoYXBlVXRpbCA9IFRMRHJhd1NoYXBlVXRpbDtcbmV4cG9ydHMuVExEcmF3U3RhdGUgPSBUTERyYXdTdGF0ZTtcbmV4cG9ydHMuY3JlYXRlU2hhcGUgPSBjcmVhdGVTaGFwZTtcbmV4cG9ydHMuZGVmYXVsdFN0eWxlID0gZGVmYXVsdFN0eWxlO1xuZXhwb3J0cy5maWxscyA9IGZpbGxzO1xuZXhwb3J0cy5nZXRGb250U2l6ZSA9IGdldEZvbnRTaXplO1xuZXhwb3J0cy5nZXRGb250U3R5bGUgPSBnZXRGb250U3R5bGU7XG5leHBvcnRzLmdldFBlcmZlY3REYXNoUHJvcHMgPSBnZXRQZXJmZWN0RGFzaFByb3BzO1xuZXhwb3J0cy5nZXRTaGFwZVN0eWxlID0gZ2V0U2hhcGVTdHlsZTtcbmV4cG9ydHMuZ2V0U2hhcGVVdGlscyA9IGdldFNoYXBlVXRpbHM7XG5leHBvcnRzLmdldFN0cm9rZVdpZHRoID0gZ2V0U3Ryb2tlV2lkdGg7XG5leHBvcnRzLnN0cm9rZXMgPSBzdHJva2VzO1xuZXhwb3J0cy50bGRyYXdTaGFwZVV0aWxzID0gdGxkcmF3U2hhcGVVdGlscztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRsZHJhdy5janMuZGV2ZWxvcG1lbnQuanMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../packages/tldraw/dist/tldraw.cjs.development.js\n");

/***/ })

};
;