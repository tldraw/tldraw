(function(a,b){"object"==typeof exports&&"undefined"!=typeof module?b(exports):"function"==typeof define&&define.amd?define(["exports"],b):(a=a||self,b(a.msgpackr={}))})(this,function(a){'use strict';var b=Math.floor;function c(){try{let a=d();if(D==y)// finished reading this source, cleanup references
z=null,x=null,B&&(B=null);else if(D>y){// over read
let a=new Error("Unexpected end of MessagePack data");throw a.incomplete=!0,a}else if(!i)throw new Error("Data read, but end of buffer not reached");// else more to read, but we are reading sequentially, so don't clear source yet
return a}catch(a){throw p(),(a instanceof RangeError||a.message.startsWith("Unexpected end of buffer"))&&(a.incomplete=!0),a}}function d(){let a=x[D++];if(160>a){if(!(128>a)){if(!(144>a)){a-=144;let b=Array(a);for(let c=0;c<a;c++)b[c]=d();return b}if(a-=128,E.mapsAsObjects){let b={};for(let c=0;c<a;c++)b[n()]=d();return b}else{let b=new Map;for(let c=0;c<a;c++)b.set(d(),d());return b}}else if(64>a)return a;else{let b=z[63&a];if(b)return b.read||(b.read=e(b)),b.read();if(E.getStructures){let c=o(()=>(x=null,E.getStructures()));return!0===z?E.structures=z=c:z.splice.apply(z,[0,c.length].concat(c)),b=z[63&a],b?(b.read||(b.read=e(b)),b.read()):a}return a}}else if(192>a){// fixstr
let b=a-160;if(G>=D)return A.slice(D-F,(D+=b)-F);if(0==G&&140>y){// for small blocks, avoiding the overhead of the extract call is helpful
let a=16>b?k(b):j(b);if(null!=a)return a}return N(b)}else{let b;switch(a){case 192:return null;case 193:return K;// "never-used", return special object to denote that
case 194:return!1;case 195:return!0;case 196:// bin 8
return l(x[D++]);case 197:return b=C.getUint16(D),D+=2,l(b);case 198:return b=C.getUint32(D),D+=4,l(b);case 199:// ext 8
return m(x[D++]);case 200:return b=C.getUint16(D),D+=2,m(b);case 201:return b=C.getUint32(D),D+=4,m(b);case 202:if(b=C.getFloat32(D),2<E.useFloat32){// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
let a=W[(127&x[D])<<1|x[D+1]>>7];return D+=4,(a*b+(0<b?.5:-.5)>>0)/a}return D+=4,b;case 203:return b=C.getFloat64(D),D+=8,b;// uint handlers
case 204:return x[D++];case 205:return b=C.getUint16(D),D+=2,b;case 206:return b=C.getUint32(D),D+=4,b;case 207:return E.uint64AsNumber?72057594037927940*x[D++]+281474976710656*x[D++]+1099511627776*x[D++]+4294967296*x[D++]+16777216*x[D++]+(x[D++]<<16)+(x[D++]<<8)+x[D++]:(b=C.getBigUint64(D),D+=8,b);// int handlers
case 208:return C.getInt8(D++);case 209:return b=C.getInt16(D),D+=2,b;case 210:return b=C.getInt32(D),D+=4,b;case 211:return b=C.getBigInt64(D),D+=8,b;case 212:if(b=x[D++],114==b)return T(x[D++]);else{let a=H[b];if(a)return a.read?(D++,a.read(d())):a.noBuffer?(D++,a()):a(x.subarray(D,++D));throw new Error("Unknown extension "+b)}case 213:// fixext 2
return m(2);case 214:// fixext 4
return m(4);case 215:// fixext 8
return m(8);case 216:// fixext 16
return m(16);case 217:return b=x[D++],G>=D?A.slice(D-F,(D+=b)-F):O(b);case 218:return b=C.getUint16(D),D+=2,G>=D?A.slice(D-F,(D+=b)-F):P(b);case 219:return b=C.getUint32(D),D+=4,G>=D?A.slice(D-F,(D+=b)-F):Q(b);case 220:return b=C.getUint16(D),D+=2,g(b);case 221:return b=C.getUint32(D),D+=4,g(b);case 222:return b=C.getUint16(D),D+=2,h(b);case 223:return b=C.getUint32(D),D+=4,h(b);default:// negative int
if(224<=a)return a-256;if(void 0===a){let a=new Error("Unexpected end of MessagePack data");throw a.incomplete=!0,a}throw new Error("Unknown MessagePack token "+a);}}}function e(a){function b(){// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function
if(2<b.count++)return this.read=new Function("r","return function(){return {"+a.map(a=>M.test(a)?a+":r()":"["+JSON.stringify(a)+"]:r()").join(",")+"}}")(d),this.read();let c={};for(let b,e=0,f=a.length;e<f;e++)b=a[e],c[b]=d();return c}return b.count=0,b}function f(a){let b;if(16>a&&(b=k(a)))return b;if(64<a&&w)return w.decode(x.subarray(D,D+=a));const c=D+a,d=[];for(b="";D<c;){const a=x[D++];if(0==(128&a))d.push(a);else if(192==(224&a)){// 2 bytes
const b=63&x[D++];d.push((31&a)<<6|b)}else if(224==(240&a)){// 3 bytes
const b=63&x[D++],c=63&x[D++];d.push((31&a)<<12|b<<6|c)}else if(240==(248&a)){// 4 bytes
const b=63&x[D++],c=63&x[D++],e=63&x[D++];let f=(7&a)<<18|b<<12|c<<6|e;65535<f&&(f-=65536,d.push(55296|1023&f>>>10),f=56320|1023&f),d.push(f)}else d.push(a);4096<=d.length&&(b+=R.apply(String,d),d.length=0)}return 0<d.length&&(b+=R.apply(String,d)),b}function g(a){let b=Array(a);for(let c=0;c<a;c++)b[c]=d();return b}function h(a){if(E.mapsAsObjects){let b={};for(let c=0;c<a;c++)b[n()]=d();return b}else{let b=new Map;for(let c=0;c<a;c++)b.set(d(),d());return b}}function j(a){let b=D,c=Array(a);for(let d=0;d<a;d++){const a=x[D++];if(0<(128&a))return void(D=b);c[d]=a}return R.apply(String,c)}function k(p){if(4>p){if(!(2>p)){let d=x[D++],a=x[D++];if(0<(128&d)||0<(128&a))return void(D-=2);if(3>p)return R(d,a);let b=x[D++];return 0<(128&b)?void(D-=3):R(d,a,b)}if(0===p)return"";else{let b=x[D++];return 1<(128&b)?void(D-=1):R(b)}}else{let q=x[D++],a=x[D++],b=x[D++],c=x[D++];if(0<(128&q)||0<(128&a)||0<(128&b)||0<(128&c))return void(D-=4);if(6>p){if(4===p)return R(q,a,b,c);else{let d=x[D++];return 0<(128&d)?void(D-=5):R(q,a,b,c,d)}}else if(8>p){let d=x[D++],e=x[D++];if(0<(128&d)||0<(128&e))return void(D-=6);if(7>p)return R(q,a,b,c,d,e);let f=x[D++];return 0<(128&f)?void(D-=7):R(q,a,b,c,d,e,f)}else{let d=x[D++],e=x[D++],f=x[D++],g=x[D++];if(0<(128&d)||0<(128&e)||0<(128&f)||0<(128&g))return void(D-=8);if(10>p){if(8===p)return R(q,a,b,c,d,e,f,g);else{let h=x[D++];return 0<(128&h)?void(D-=9):R(q,a,b,c,d,e,f,g,h)}}else if(12>p){let h=x[D++],i=x[D++];if(0<(128&h)||0<(128&i))return void(D-=10);if(11>p)return R(q,a,b,c,d,e,f,g,h,i);let j=x[D++];return 0<(128&j)?void(D-=11):R(q,a,b,c,d,e,f,g,h,i,j)}else{let h=x[D++],i=x[D++],j=x[D++],k=x[D++];if(0<(128&h)||0<(128&i)||0<(128&j)||0<(128&k))return void(D-=12);if(!(14>p)){let l=x[D++],m=x[D++];if(0<(128&l)||0<(128&m))return void(D-=14);if(15>p)return R(q,a,b,c,d,e,f,g,h,i,j,k,l,m);let n=x[D++];return 0<(128&n)?void(D-=15):R(q,a,b,c,d,e,f,g,h,i,j,k,l,m,n)}if(12===p)return R(q,a,b,c,d,e,f,g,h,i,j,k);else{let l=x[D++];return 0<(128&l)?void(D-=13):R(q,a,b,c,d,e,f,g,h,i,j,k,l)}}}}}function l(a){return E.copyBuffers?// specifically use the copying slice (not the node one)
Uint8Array.prototype.slice.call(x,D,D+=a):x.subarray(D,D+=a)}function m(a){let b=x[D++];if(H[b])return H[b](x.subarray(D,D+=a));throw new Error("Unknown extension type "+b)}function n(){let a=x[D++];if(160<=a&&192>a){if(a-=160,G>=D)// if it has been extracted, must use it (and faster anyway)
return A.slice(D-F,(D+=a)-F);if(!(0==G&&180>y))return N(a)}else return D--,d();let b,c=4095&(a<<5^(1<a?C.getUint16(D):0<a?x[D]:0)),e=S[c],f=D,g=D+a-3,h=0;if(e&&e.bytes==a){for(;f<g;){if(b=C.getUint32(f),b!=e[h++]){f=1879048192;break}f+=4}for(g+=3;f<g;)if(b=x[f++],b!=e[h++]){f=1879048192;break}if(f===g)return D=f,e.string;g-=3,f=D}for(e=[],S[c]=e,e.bytes=a;f<g;)b=C.getUint32(f),e.push(b),f+=4;for(g+=3;f<g;)b=x[f++],e.push(b);// for small blocks, avoiding the overhead of the extract call is helpful
let l=16>a?k(a):j(a);return null==l?e.string=N(a):e.string=l}// the registration of the record definition extension (as "r")
// notepack defines extension 0 to mean undefined, so use that as the default here
// registration of bulk record definition?
// currentExtensions[0x52] = () =>
function o(a){let b=y,c=D,d=F,e=G,f=A,g=B,h=new Uint8Array(x.slice(0,y)),j=z,k=E,l=i,m=a();return y=b,D=c,F=d,G=e,A=f,B=g,x=h,i=l,z=j,E=k,C=new DataView(x.buffer,x.byteOffset,x.byteLength),m}function p(){x=null,B=null,z=null}function q(a){H[a.type]=a.unpack?a.unpack:a}function r(a,b,c){let d=a.byteLength;if(256>d+1){var{target:e,position:f}=c(4+d);e[f++]=199,e[f++]=d+1}else if(65536>d+1){var{target:e,position:f}=c(5+d);e[f++]=200,e[f++]=d+1>>8,e[f++]=255&d+1}else{var{target:e,position:f,targetView:g}=c(7+d);// plus one for the type byte
e[f++]=201,g.setUint32(f,d+1),f+=4}// "t" for typed array
e[f++]=116,e[f++]=b,e.set(new Uint8Array(a.buffer,a.byteOffset,a.byteLength),f)}function s(a,b){let c=a.byteLength;var d,e;if(256>c){var{target:d,position:e}=b(c+2);d[e++]=196,d[e++]=c}else if(65536>c){var{target:d,position:e}=b(c+3);d[e++]=197,d[e++]=c>>8,d[e++]=255&c}else{var{target:d,position:e,targetView:f}=b(c+5);d[e++]=198,f.setUint32(e,c),e+=4}d.set(a,e)}function t(a,b,c,d){let e=a.length;return 1===e?b[c++]=212:2===e?b[c++]=213:4===e?b[c++]=214:8===e?b[c++]=215:16===e?b[c++]=216:256>e?(b[c++]=199,b[c++]=e):65536>e?(b[c++]=200,b[c++]=e>>8,b[c++]=255&e):(b[c++]=201,b[c++]=e>>24,b[c++]=255&e>>16,b[c++]=255&e>>8,b[c++]=255&e),b[c++]=d,b.set(a,c),c+=e,c}function u(a,b){// insert the ids that need to be referenced for structured clones
let c,d=6*b.length,e=a.length-d;for(b.sort((c,a)=>c.offset>a.offset?1:-1);c=b.pop();){let b=c.offset,f=c.id;a.copyWithin(b+d,b,e),d-=6;let g=b+d;// 'i'
a[g++]=214,a[g++]=105,a[g++]=f>>24,a[g++]=255&f>>16,a[g++]=255&f>>8,a[g++]=255&f,e=b}return a}function v(a){if(a.Class){if(!a.pack&&!a.write)throw new Error("Extension has no pack or write function");if(a.pack&&!a.type)throw new Error("Extension has no type (numeric code to identify the extension)");ca.unshift(a.Class),ba.unshift(a)}q(a)}var w;try{w=new TextDecoder}catch(a){}var x,y,z,A,B,C,D=0,E={},F=0,G=0,H=[],I={useRecords:!1,mapsAsObjects:!0};class J{}const K=new J;K.name="MessagePack 0xC1";var i=!1;class L{constructor(a){a&&(!1===a.useRecords&&a.mapsAsObjects===void 0&&(a.mapsAsObjects=!0),a.getStructures&&!a.structures&&((a.structures=[]).uninitialized=!0)),Object.assign(this,a)}unpack(a,b){if(x)// re-entrant execution, save the state and restore it after we do this unpack
return o(()=>(p(),this?this.unpack(a,b):L.prototype.unpack.call(I,a,b)));if(y=-1<b?b:a.length,D=0,G=0,A=null,x=a,C=a.dataView||(a.dataView=new DataView(a.buffer,a.byteOffset,a.byteLength)),this){if(E=this,this.structures)return z=this.structures,c();(!z||0<z.length)&&(z=[])}else E=I,(!z||0<z.length)&&(z=[]);return c()}unpackMultiple(a,b){let d,e=0;try{i=!0;let f=a.length,g=this?this.unpack(a,f):X.unpack(a,f);if(b){for(b(g);D<f;)if(e=D,!1===b(c()))return;}else{for(d=[g];D<f;)e=D,d.push(c());return d}}catch(a){throw a.lastPosition=e,a.values=d,a}finally{i=!1,p()}}decode(a,b){return this.unpack(a,b)}}const M=/^[a-zA-Z_$][a-zA-Z\d_$]*$/;var N=f,O=f,P=f,Q=f,R=String.fromCharCode,S=Array(4096);const T=a=>{let b=z[63&a]=d();return b.read=e(b),b.read()};var U="object"==typeof window?window:global;H[0]=()=>{},H[0].noBuffer=!0,H[101]=()=>{let a=d();return(U[a[0]]||Error)(a[1])},H[105]=()=>{// id extension (for structured clones)
let a=C.getUint32(D-4);B||(B=new Map);let b,c=x[D];b=144<=c&&160>c||220==c||221==c?[]:{};let e={target:b};// a placeholder object
B.set(a,e);let f=d();// read the next value as the target object to id
return e.used?Object.assign(b,f):(e.target=f,f);// no cycle, can just use the returned read object
},H[112]=()=>{// pointer extension (for structured clones)
let a=C.getUint32(D-4),b=B.get(a);return b.used=!0,b.target},H[115]=()=>new Set(d());const V=["Int8","Uint8","Uint8Clamped","Int16","Uint16","Int32","Uint32","Float32","Float64","BigInt64","BigUint64"].map(a=>a+"Array");H[116]=a=>{let b=a[0],c=V[b];if(!c)throw new Error("Could not find typed array for code "+b);// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned
return new U[c](Uint8Array.prototype.slice.call(a,1).buffer)},H[120]=()=>{let a=d();return new RegExp(a[0],a[1])},H[255]=a=>{// 32-bit date extension
if(4==a.length)return new Date(1e3*(16777216*a[0]+(a[1]<<16)+(a[2]<<8)+a[3]));if(8==a.length)return new Date(((a[0]<<22)+(a[1]<<14)+(a[2]<<6)+(a[3]>>2))/1e6+1e3*(4294967296*(3&a[3])+16777216*a[4]+(a[5]<<16)+(a[6]<<8)+a[7]));if(12==a.length)// TODO: Implement support for negative
return new Date(((a[0]<<24)+(a[1]<<16)+(a[2]<<8)+a[3])/1e6+1e3*((128&a[4]?-281474976710656:0)+1099511627776*a[6]+4294967296*a[7]+16777216*a[8]+(a[9]<<16)+(a[10]<<8)+a[11]));throw new Error("Invalid timestamp length")};const W=Array(147);// this is a table matching binary exponents to the multiplier to determine significant digit rounding
for(let c=0;256>c;c++)W[c]=+("1e"+b(45.15-.30103*c));var X=new L({useRecords:!1});const Y=X.unpack,Z=X.unpackMultiple,$=X.unpack,_={NEVER:0,ALWAYS:1,DECIMAL_ROUND:3,DECIMAL_FIT:4};let aa;try{aa=new TextEncoder}catch(a){}let ba,ca;const da="undefined"!=typeof Buffer,ea=da?Buffer.allocUnsafeSlow:Uint8Array,fa=da?Buffer:Uint8Array,ga=da?4294967296:2144337920;let ha,ia,ja,ka=0;const la=Symbol("record-id");class ma extends L{constructor(a){super(a),this.offset=0;let b,c,d,e,f,g=0,h=fa.prototype.utf8Write?function(a,b,c){return ha.utf8Write(a,b,c)}:!!(aa&&aa.encodeInto)&&function(a,b){return aa.encodeInto(a,ha.subarray(b)).written},i=this,j=32,k=a&&a.sequential;k&&!a.saveStructures&&(j=0,this.structures=[]);let m=[],n=0,o=0;if(this.structures&&this.structures.length>j)throw new Error("Too many shared structures");this.pack=this.encode=function(a){if(ha||(ha=new ea(8192),ia=new DataView(ha.buffer,0,8192),ka=0),ja=ha.length-10,2048>ja-ka?(ha=new ea(ha.length),ia=new DataView(ha.buffer,0,ha.length),ja=ha.length-10,ka=0):ka=2147483640&ka+7,b=ka,f=i.structuredClone?new Map:null,c=i.structures,c){c.uninitialized&&(i.structures=c=i.getStructures()||[]);let a=c.length;if(a>j&&!k&&(a=j),!c.transitions){c.transitions=Object.create(null);for(let b,d=0;d<a;d++){if(b=c[d],!b)continue;let a,e=c.transitions;for(let c,d=0,f=b.length;d<f;d++)c=b[d],a=e[c],a||(a=e[c]=Object.create(null)),e=a;e[la]=d+64}g=c.length}k||(c.nextId=a+64)}d&&(d=!1),e=c||[];try{// update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially
if(p(a),i.offset=ka,f&&f.idsToInsert){ka+=6*f.idsToInsert.length,ka>ja&&r(ka),i.offset=ka;let a=u(ha.subarray(b,ka),f.idsToInsert);return f=null,a}return ha.subarray(b,ka);// position can change if we call pack again in saveStructures, so we get the buffer now
}finally{if(c){if(10>o&&o++,1e4<n)c.transitions=null,o=0,n=0,0<m.length&&(m=[]);else if(0<m.length&&!k){for(let a=0,b=m.length;a<b;a++)m[a][la]=0;m=[]}if(d&&i.saveStructures){if(i.structures.length>j&&(i.structures=i.structures.slice(0,j)),!1===i.saveStructures(i.structures,g))return i.structures=i.getStructures()||[],i.pack(a);g=i.structures.length}}}};const p=a=>{ka>ja&&(ha=r(ka));var c,d=typeof a;if("string"==d){let b,d=a.length;b=32>d?1:256>d?2:65536>d?3:5;let e=3*d;if(ka+e>ja&&(ha=r(ka+e)),64>d||!h){let e,f,g,h=ka+b;for(e=0;e<d;e++)f=a.charCodeAt(e),128>f?ha[h++]=f:2048>f?(ha[h++]=192|f>>6,ha[h++]=128|63&f):55296==(64512&f)&&56320==(64512&(g=a.charCodeAt(e+1)))?(f=65536+((1023&f)<<10)+(1023&g),e++,ha[h++]=240|f>>18,ha[h++]=128|63&f>>12,ha[h++]=128|63&f>>6,ha[h++]=128|63&f):(ha[h++]=224|f>>12,ha[h++]=128|63&f>>6,ha[h++]=128|63&f);c=h-ka-b}else c=h(a,ka+b,e);32>c?ha[ka++]=160|c:256>c?(2>b&&ha.copyWithin(ka+2,ka+1,ka+1+c),ha[ka++]=217,ha[ka++]=c):65536>c?(3>b&&ha.copyWithin(ka+3,ka+2,ka+2+c),ha[ka++]=218,ha[ka++]=c>>8,ha[ka++]=255&c):(5>b&&ha.copyWithin(ka+5,ka+3,ka+3+c),ha[ka++]=219,ia.setUint32(ka,c),ka+=4),ka+=c}else if("number"===d){if(a>>>0===a)64>a?ha[ka++]=a:256>a?(ha[ka++]=204,ha[ka++]=a):65536>a?(ha[ka++]=205,ha[ka++]=a>>8,ha[ka++]=255&a):(ha[ka++]=206,ia.setUint32(ka,a),ka+=4);else if(a>>0===a)-32<=a?ha[ka++]=256+a:-128<=a?(ha[ka++]=208,ha[ka++]=a+256):-32768<=a?(ha[ka++]=209,ia.setInt16(ka,a),ka+=2):(ha[ka++]=210,ia.setInt32(ka,a),ka+=4);else{let b;if(0<(b=this.useFloat32)&&4294967296>a&&-2147483648<=a){ha[ka++]=202,ia.setFloat32(ka,a);let c;if(4>b||// this checks for  rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
(c=a*W[(127&ha[ka])<<1|ha[ka+1]>>7])>>0===c)return void(ka+=4);// move back into position for writing a double
ka--}ha[ka++]=203,ia.setFloat64(ka,a),ka+=8}}else if("object"===d){if(!a)ha[ka++]=192;else{if(f){let c=f.get(a);if(c){if(!c.id){let a=f.idsToInsert||(f.idsToInsert=[]);c.id=a.push(c)}return ha[ka++]=214,ha[ka++]=112,ia.setUint32(ka,c.id),void(ka+=4)}f.set(a,{offset:ka-b})}let d=a.constructor;if(d===Object)q(a,!0);else if(d===Array){c=a.length,16>c?ha[ka++]=144|c:65536>c?(ha[ka++]=220,ha[ka++]=c>>8,ha[ka++]=255&c):(ha[ka++]=221,ia.setUint32(ka,c),ka+=4);for(let b=0;b<c;b++)p(a[b])}else if(d===Map){c=a.size,16>c?ha[ka++]=128|c:65536>c?(ha[ka++]=222,ha[ka++]=c>>8,ha[ka++]=255&c):(ha[ka++]=223,ia.setUint32(ka,c),ka+=4);for(let[b,c]of a)p(b),p(c)}else{for(let b,c=0,d=ba.length;c<d;c++)if(b=ca[c],a instanceof b){let b=ba[c];if(b.write)return b.type&&(ha[ka++]=212,ha[ka++]=b.type,ha[ka++]=0),void p(b.write.call(this,a));let d=ha,e=ia,f=ka;ha=null;let g;try{g=b.pack.call(this,a,a=>(ha=d,d=null,ka+=a,ka>ja&&r(ka),{target:ha,targetView:ia,position:ka-a}),p)}finally{d&&(ha=d,ia=e,ka=f,ja=ha.length-10)}return void(g&&(g.length+ka>ja&&r(g.length+ka),ka=t(g,ha,ka,b.type)))}// no extension found, write as object
q(a,!a.hasOwnProperty)}}}else if("boolean"===d)ha[ka++]=a?195:194;else if("bigint"===d){if(a<BigInt(1)<<BigInt(63)&&a>=-(BigInt(1)<<BigInt(63)))ha[ka++]=211,ia.setBigInt64(ka,a);else if(a<BigInt(1)<<BigInt(64)&&0<a)ha[ka++]=207,ia.setBigUint64(ka,a);else// overflow
if(this.largeBigIntToFloat)ha[ka++]=203,ia.setFloat64(ka,+a);else throw new RangeError(a+" was too large to fit in MessagePack 64-bit integer format, set largeBigIntToFloat to convert to float-64");ka+=8}else if("undefined"===d)this.encodeUndefinedAsNil?ha[ka++]=192:(ha[ka++]=212,ha[ka++]=0,ha[ka++]=0);else if("function"===d)p(this.writeFunction&&this.writeFunction());else throw new Error("Unknown type: "+d)},q=!1===this.useRecords?this.variableMapSize?a=>{// this method is slightly slower, but generates "preferred serialization" (optimally small for smaller objects)
let b=Object.keys(a),c=b.length;16>c?ha[ka++]=128|c:65536>c?(ha[ka++]=222,ha[ka++]=c>>8,ha[ka++]=255&c):(ha[ka++]=223,ia.setUint32(ka,c),ka+=4);let d;for(let e=0;e<c;e++)p(d=b[e]),p(a[d])}:(a,c)=>{ha[ka++]=222;// always using map 16, so we can preallocate and set the length afterwards
let d=ka-b;ka+=2;let e=0;for(let b in a)(c||a.hasOwnProperty(b))&&(p(b),p(a[b]),e++);ha[d++ +b]=e>>8,ha[d+b]=255&e}:/*	sharedStructures ?  // For highly stable structures, using for-in can a little bit faster
			(object, safePrototype) => {
				let nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))
				let objectOffset = position++ - start
				let wroteKeys
				for (let key in object) {
					if (safePrototype || object.hasOwnProperty(key)) {
						nextTransition = transition[key]
						if (!nextTransition) {
							nextTransition = transition[key] = Object.create(null)
							nextTransition.__keys__ = (transition.__keys__ || []).concat([key])
							/*let keys = Object.keys(object)
							if 
							let size = 0
							let startBranch = transition.__keys__ ? transition.__keys__.length : 0
							for (let i = 0, l = keys.length; i++) {
								let key = keys[i]
								size += key.length << 2
								if (i >= startBranch) {
									nextTransition = nextTransition[key] = Object.create(null)
									nextTransition.__keys__ = keys.slice(0, i + 1)
								}
							}
							makeRoom(position + size)
							nextTransition = transition[key]
							target.copy(target, )
							objectOffset
						}
						transition = nextTransition
						pack(object[key])
					}
				}
				let id = transition.id
				if (!id) {
					id = transition.id = structures.push(transition.__keys__) + 63
					if (sharedStructures.onUpdate)
						sharedStructures.onUpdate(id, transition.__keys__)
				}
				target[objectOffset + start] = id
			}*/a=>{let b,f=Object.keys(a),g=e.transitions||(e.transitions=Object.create(null)),h=0;for(let c,d=0,e=f.length;d<e;d++)c=f[d],b=g[c],b||(b=g[c]=Object.create(null),h++),g=b;let i=g[la];i?ha[ka++]=i:(i=e.nextId++,!i&&(i=64,e.nextId=65),128<=i&&(e.nextId=(i=j+64)+1),g[la]=i,e[63&i]=f,c&&c.length<=j?(ha[ka++]=i,d=!0):(ha[ka++]=212,ha[ka++]=114,ha[ka++]=i,h&&(n+=o*h),m.length>=64-j&&(m.shift()[la]=0),m.push(g),p(f)));// now write the values
for(let b=0,c=f.length;b<c;b++)p(a[f[b]])},r=a=>{var c=Math.min,d=Math.round,e=Math.max;let f;if(16777216<a){// special handling for really large buffers
if(a-b>ga)throw new Error("Packed buffer would be larger than maximum buffer size");f=c(ga,4096*d(e((a-b)*(67108864<a?1.25:2),16777216)/4096))}else// faster handling for smaller buffers
f=(e(a-b<<2,ha.length-1)>>12)+1<<12;let g=new ea(f);return ia=new DataView(g.buffer,0,f),ha.copy?ha.copy(g,0,b,a):g.set(ha.slice(b,a)),ka-=b,b=0,ja=g.length-10,ha=g}}useBuffer(a){// this means we are finished using our own buffer and we can write over it safely
ha=a,ia=new DataView(ha.buffer,ha.byteOffset,ha.byteLength),ka=0}}ca=[Date,Set,Error,RegExp,ArrayBuffer,Object.getPrototypeOf(Uint8Array.prototype).constructor/*TypedArray*/,J],ba=[{pack(a,c){let d=a.getTime()/1e3;if((this.useTimestamp32||0===a.getMilliseconds())&&0<=d&&4294967296>d){// Timestamp 32
let{target:a,targetView:b,position:e}=c(6);a[e++]=214,a[e++]=255,b.setUint32(e,d)}else if(0<d&&17179869184>d){// Timestamp 64
let{target:b,targetView:e,position:f}=c(10);b[f++]=215,b[f++]=255,e.setUint32(f,4e6*a.getMilliseconds()+(d/1e3/4294967296>>0)),e.setUint32(f+4,d)}else{// Timestamp 96
let{target:e,targetView:f,position:g}=c(15);e[g++]=199,e[g++]=12,e[g++]=255,f.setUint32(g,1e6*a.getMilliseconds()),f.setBigInt64(g+4,BigInt(b(d)))}}},{pack(a,b,c){let d=Array.from(a),{target:e,position:f}=b(this.structuredClone?3:0);this.structuredClone&&(e[f++]=212,e[f++]=115,e[f++]=0),c(d)}},{pack(a,b,c){let{target:d,position:e}=b(this.structuredClone?3:0);this.structuredClone&&(d[e++]=212,d[e++]=101,d[e++]=0),c([a.name,a.message])}},{pack(a,b,c){let{target:d,position:e}=b(this.structuredClone?3:0);this.structuredClone&&(d[e++]=212,d[e++]=120,d[e++]=0),c([a.source,a.flags])}},{pack(a,b){this.structuredClone?r(a,16,b):s(da?Buffer.from(a):new Uint8Array(a),b)}},{pack(a,b){let c=a.constructor;c!==fa&&this.structuredClone?r(a,V.indexOf(c.name),b):s(a,b)}},{pack(a,b){// specific 0xC1 object
let{target:c,position:d}=b(1);c[d]=193}}];let na=new ma({useRecords:!1});const oa=na.pack,pa=na.pack,{NEVER:qa,ALWAYS:ra,DECIMAL_ROUND:sa,DECIMAL_FIT:ta}=_;a.ALWAYS=ra,a.C1=K,a.DECIMAL_FIT=ta,a.DECIMAL_ROUND=sa,a.Decoder=L,a.Encoder=ma,a.FLOAT32_OPTIONS=_,a.NEVER=qa,a.Packr=ma,a.Unpackr=L,a.addExtension=v,a.clearSource=p,a.decode=$,a.encode=pa,a.mapsAsObjects=!0,a.pack=oa,a.unpack=Y,a.unpackMultiple=Z,a.useRecords=!1,Object.defineProperty(a,"__esModule",{value:!0})});
