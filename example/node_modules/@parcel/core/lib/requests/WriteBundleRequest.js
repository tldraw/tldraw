"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createWriteBundleRequest;

var _constants = require("../constants");

function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));

  _nullthrows = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

var _Bundle = require("../public/Bundle");

function _utils() {
  const data = require("@parcel/utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _stream() {
  const data = require("stream");

  _stream = function () {
    return data;
  };

  return data;
}

var _projectPath = require("../projectPath");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const BOUNDARY_LENGTH = _constants.HASH_REF_PREFIX.length + 32 - 1;

/**
 * Writes a bundle to the dist directory, replacing hash references with the final content hashes.
 */
function createWriteBundleRequest(input) {
  let nameHash = (0, _nullthrows().default)(input.hashRefToNameHash.get(input.bundle.hashReference));
  return {
    id: `${input.bundle.id}:${input.info.hash}:${nameHash}`,
    type: 'write_bundle_request',
    run,
    input
  };
}

async function run({
  input,
  options,
  api
}) {
  var _info$time;

  let {
    bundleGraph,
    bundle,
    info,
    hashRefToNameHash
  } = input;
  let {
    inputFS,
    outputFS
  } = options;
  let name = (0, _nullthrows().default)(bundle.name);
  let thisHashReference = bundle.hashReference;

  if (info.type !== bundle.type) {
    name = name.slice(0, -_path().default.extname(name).length) + '.' + info.type;
  }

  if (name.includes(thisHashReference)) {
    let thisNameHash = (0, _nullthrows().default)(hashRefToNameHash.get(thisHashReference));
    name = name.replace(thisHashReference, thisNameHash);
  }

  let filePath = (0, _projectPath.joinProjectPath)(bundle.target.distDir, name); // Watch the bundle and source map for deletion.
  // Also watch the dist dir because invalidateOnFileDelete does not currently
  // invalidate when a parent directory is deleted.
  // TODO: do we want to also watch for file edits?

  api.invalidateOnFileDelete(bundle.target.distDir);
  api.invalidateOnFileDelete(filePath);
  let cacheKeys = info.cacheKeys;
  let mapKey = cacheKeys.map;
  let fullPath = (0, _projectPath.fromProjectPath)(options.projectRoot, filePath);

  if (mapKey && bundle.env.sourceMap && !bundle.env.sourceMap.inline) {
    api.invalidateOnFileDelete((0, _projectPath.toProjectPath)(options.projectRoot, fullPath + '.map'));
  }

  let dir = _path().default.dirname(fullPath);

  await outputFS.mkdirp(dir); // ? Got rid of dist exists, is this an expensive operation
  // Use the file mode from the entry asset as the file mode for the bundle.
  // Don't do this for browser builds, as the executable bit in particular is unnecessary.

  let publicBundle = _Bundle.NamedBundle.get(bundle, bundleGraph, options);

  let mainEntry = publicBundle.getMainEntry();
  let writeOptions = publicBundle.env.isBrowser() || !mainEntry ? undefined : {
    mode: (await inputFS.stat(mainEntry.filePath)).mode
  };
  let contentStream = options.cache.getStream(cacheKeys.content);
  let size = await writeFileStream(outputFS, fullPath, contentStream, info.hashReferences, hashRefToNameHash, writeOptions);

  if (mapKey && bundle.env.sourceMap && !bundle.env.sourceMap.inline && (await options.cache.has(mapKey))) {
    let mapStream = options.cache.getStream(mapKey);
    await writeFileStream(outputFS, fullPath + '.map', mapStream, info.hashReferences, hashRefToNameHash);
  }

  let res = {
    filePath,
    stats: {
      size,
      time: (_info$time = info.time) !== null && _info$time !== void 0 ? _info$time : 0
    }
  };
  api.storeResult(res);
  return res;
}

function writeFileStream(fs, filePath, stream, hashReferences, hashRefToNameHash, options) {
  return new Promise((resolve, reject) => {
    let initialStream = hashReferences.length ? stream.pipe(replaceStream(hashRefToNameHash)) : stream;
    let fsStream = fs.createWriteStream(filePath, options);
    let fsStreamClosed = new Promise(resolve => {
      fsStream.on('close', () => resolve());
    });
    let bytesWritten = 0;
    initialStream.pipe(new (_utils().TapStream)(buf => {
      bytesWritten += buf.length;
    })).pipe(fsStream).on('finish', () => resolve(fsStreamClosed.then(() => bytesWritten))).on('error', reject);
  });
}

function replaceStream(hashRefToNameHash) {
  let boundaryStr = '';
  return new (_stream().Transform)({
    transform(chunk, encoding, cb) {
      let str = boundaryStr + chunk.toString();
      let replaced = str.replace(_constants.HASH_REF_REGEX, match => {
        return hashRefToNameHash.get(match) || match;
      });
      boundaryStr = replaced.slice(replaced.length - BOUNDARY_LENGTH);
      let strUpToBoundary = replaced.slice(0, replaced.length - BOUNDARY_LENGTH);
      cb(null, strUpToBoundary);
    },

    flush(cb) {
      cb(null, boundaryStr);
    }

  });
}